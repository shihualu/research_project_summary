diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index 8d67d92eb..25b28542d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -139,7 +139,7 @@ static Y y(Y y) {
   }
 
   @SuppressWarnings("dependency-cycle")
-  @Component
+  @Component(modules = CycleModule.class)
   interface CycleComponent {
     A a();
 
@@ -148,6 +148,14 @@ static Y y(Y y) {
     ChildCycleComponent child();
   }
 
+  @Module
+  static class CycleModule {
+    @Provides
+    static Object provideObjectWithCycle(@SuppressWarnings("unused") Provider<Object> object) {
+      return "object";
+    }
+  }
+
   @SuppressWarnings("dependency-cycle")
   @Component
   interface SelfCycleComponent {
@@ -158,5 +166,8 @@ static Y y(Y y) {
   interface ChildCycleComponent {
     @SuppressWarnings("dependency-cycle")
     A a();
+
+    @SuppressWarnings("dependency-cycle")
+    Object object();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index 612096417..1df73db75 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -108,8 +108,10 @@ static BoundInParentAndChild inParentAndChildEntry() {
       return BoundInParentAndChild.IN_PARENT;
     }
 
+    /* This is not static because otherwise we have no tests that cover the case where a
+     * subcomponent uses a module instance installed onto a parent component. */
     @Provides(type = SET)
-    static RequiresMultibindings<BoundInParentAndChild>
+    RequiresMultibindings<BoundInParentAndChild>
         requiresMultibindingsInParentAndChildElement(
             RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
       return requiresMultibindingsInParentAndChild;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
index 279bc954c..94f27be02 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -30,6 +30,7 @@
 
   @Subcomponent.Builder
   interface Builder {
+    @SuppressWarnings("repeated-module")
     Builder repeatedModule(RepeatedModule repeatedModule);
 
     SubcomponentWithRepeatedModule build();
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
index e50eaee69..b205e9d43 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
@@ -42,6 +42,6 @@ public void longCycle() {
   @Test
   public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
     DaggerLongCycle_LongCycleComponent.class
-        .getDeclaredMethod("initialize1", DaggerLongCycle_LongCycleComponent.Builder.class);
+        .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
index 375c90a19..6572215ff 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -150,7 +150,7 @@ public void basicMonitoringWithFailure() throws Exception {
     }
   }
 
-  private static final class FakeProductionComponentMonitor implements ProductionComponentMonitor {
+  private static final class FakeProductionComponentMonitor extends ProductionComponentMonitor {
     final Map<ProducerToken, ProducerMonitor> monitors = new LinkedHashMap<>();
 
     @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 261e1b270..8467c30fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,40 +27,25 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.internal.DelegateFactory;
-import dagger.internal.Factory;
-import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
-import dagger.internal.MembersInjectors;
-import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
-import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
-import java.util.Collection;
 import java.util.HashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -82,14 +67,20 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.nullCheck;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
-import static dagger.internal.codegen.MemberSelect.emptyMapProviderFactory;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
+import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
@@ -97,11 +88,29 @@
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+import static dagger.internal.codegen.TypeNames.FACTORY;
+import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.SCOPED_PROVIDER;
+import static dagger.internal.codegen.TypeNames.SET_FACTORY;
+import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
+import static dagger.internal.codegen.TypeNames.STRING;
+import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
-import static dagger.internal.codegen.writer.Snippet.nullCheck;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -119,28 +128,24 @@
   protected final Types types;
   protected final Key.Factory keyFactory;
   protected final Kind nullableValidationType;
-  protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
-  private final Map<Binding, InitializationState> contributionInitializationStates =
-      new HashMap<>();
-  protected ClassWriter componentWriter;
-  private final Map<BindingKey, MemberSelect> memberSelectSnippets = new HashMap<>();
-  private final Map<ContributionBinding, MemberSelect> multibindingContributionSnippets =
-      new HashMap<>();
-  protected ConstructorWriter constructorWriter;
+  protected TypeSpec.Builder component;
+  private final UniqueNameSet componentFieldNames = new UniqueNameSet();
+  private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
+  protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
 
   /**
    * For each component requirement, the builder field. This map is empty for subcomponents that do
    * not use a builder.
    */
-  private ImmutableMap<TypeElement, FieldWriter> builderFields = ImmutableMap.of();
+  private ImmutableMap<TypeElement, FieldSpec> builderFields = ImmutableMap.of();
 
   /**
-   * For each component requirement, the snippet for the component field that holds it.
+   * For each component requirement, the member select for the component field that holds it.
    *
    * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
    * any requirement that is reused from a subcomponent of this component.
@@ -169,59 +174,61 @@ protected final TypeElement componentDefinitionType() {
   }
 
   protected final ClassName componentDefinitionTypeName() {
-    return ClassName.fromTypeElement(componentDefinitionType());
+    return ClassName.get(componentDefinitionType());
   }
 
   /**
-   * Returns an expression snippet that evaluates to an instance of the contribution, looking for
-   * either a builder field or a component field.
+   * Returns an expression that evaluates to an instance of the contribution, looking for either a
+   * builder field or a component field.
    */
-  private Snippet getComponentContributionSnippet(TypeElement contributionType) {
+  private CodeBlock getComponentContributionExpression(TypeElement contributionType) {
     if (builderFields.containsKey(contributionType)) {
-      return Snippet.format("builder.%s", builderFields.get(contributionType).name());
+      return CodeBlocks.format("builder.$N", builderFields.get(contributionType));
     } else {
-      Optional<Snippet> snippet = getOrCreateComponentContributionFieldSnippet(contributionType);
-      checkState(snippet.isPresent(), "no builder or component field for %s", contributionType);
-      return snippet.get();
+      Optional<CodeBlock> codeBlock =
+          getOrCreateComponentContributionFieldExpression(contributionType);
+      checkState(codeBlock.isPresent(), "no builder or component field for %s", contributionType);
+      return codeBlock.get();
     }
   }
 
   /**
-   * Returns a snippet for a component contribution field. Adds a field the first time one is
+   * Returns an expression for a component contribution field. Adds a field the first time one is
    * requested for a contribution type if this component's builder has a field for it.
    */
-  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
       TypeElement contributionType) {
     MemberSelect fieldSelect = componentContributionFields.get(contributionType);
     if (fieldSelect == null) {
       if (!builderFields.containsKey(contributionType)) {
         return Optional.absent();
       }
-      FieldWriter componentField =
-          componentWriter.addField(contributionType, simpleVariableName(contributionType));
-      componentField.addModifiers(PRIVATE, FINAL);
-      constructorWriter
-          .body()
-          .addSnippet(
-              "this.%s = builder.%s;",
-              componentField.name(),
-              builderFields.get(contributionType).name());
-      fieldSelect = localField(name, componentField.name());
+      FieldSpec componentField =
+          componentField(ClassName.get(contributionType), simpleVariableName(contributionType))
+              .addModifiers(PRIVATE, FINAL)
+              .build();
+      component.addField(componentField);
+      constructor.addCode(
+          "this.$N = builder.$N;", componentField, builderFields.get(contributionType));
+      fieldSelect = localField(name, componentField.name);
       componentContributionFields.put(contributionType, fieldSelect);
     }
-    return Optional.of(fieldSelect.getSnippetFor(name));
+    return Optional.of(fieldSelect.getExpressionFor(name));
   }
 
-  private Snippet getMemberSelectSnippet(BindingKey key) {
-    return getMemberSelect(key).getSnippetFor(name);
+  /**
+   * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
+   */
+  protected final FieldSpec.Builder componentField(TypeName type, String name) {
+    return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
   }
 
-  protected MemberSelect getMemberSelect(BindingKey key) {
-    return memberSelectSnippets.get(key);
+  private CodeBlock getMemberSelectExpression(BindingKey key) {
+    return getMemberSelect(key).getExpressionFor(name);
   }
 
-  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
-    return Optional.fromNullable(multibindingContributionSnippets.get(binding));
+  protected MemberSelect getMemberSelect(BindingKey key) {
+    return memberSelects.get(key);
   }
 
   /**
@@ -237,119 +244,112 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     initializationStates.put(bindingKey, state);
   }
 
-  private InitializationState getContributionInitializationState(Binding binding) {
-    return contributionInitializationStates.containsKey(binding)
-        ? contributionInitializationStates.get(binding)
-        : UNINITIALIZED;
-  }
-
-  private void setContributionInitializationState(Binding binding, InitializationState state) {
-    contributionInitializationStates.put(binding, state);
-  }
-
-  ImmutableSet<JavaWriter> write() {
-    if (javaWriters.isEmpty()) {
-      writeComponent();
-    }
-    return ImmutableSet.copyOf(javaWriters);
-  }
-
-  private void writeComponent() {
-    componentWriter = createComponentClass();
-    addConstructor();
+  /**
+   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
+   * This is only intended to be called once (and will throw on successive invocations). If the
+   * component must be regenerated, use a new instance.
+   */
+  final TypeSpec.Builder write() {
+    checkState(component == null, "ComponentWriter has already been generated.");
+    component = createComponentClass();
     addBuilder();
     addFactoryMethods();
     addFields();
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
+    component.addMethod(constructor.build());
+    return component;
   }
 
   /**
    * Creates the component implementation class.
    */
-  protected abstract ClassWriter createComponentClass();
-
-  private void addConstructor() {
-    constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-  }
+  protected abstract TypeSpec.Builder createComponentClass();
 
   /**
    * Adds a builder type.
    */
   protected void addBuilder() {
-    ClassWriter builderWriter = createBuilder();
-    builderWriter.addModifiers(FINAL);
-    builderWriter.addConstructor().addModifiers(PRIVATE);
-    builderName = Optional.of(builderWriter.name());
+    builderName = Optional.of(builderName());
+    TypeSpec.Builder componentBuilder =
+        createBuilder(builderName.get().simpleName()).addModifiers(FINAL);
 
     Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
     if (builderSpec.isPresent()) {
-      builderWriter.addModifiers(PRIVATE);
-      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
+      componentBuilder.addModifiers(PRIVATE);
+      addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
     } else {
-      builderWriter.addModifiers(PUBLIC);
+      componentBuilder
+          .addModifiers(PUBLIC)
+          .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
     }
 
-    builderFields = addBuilderFields(builderWriter);
-    addBuildMethod(builderWriter, builderSpec);
-    addBuilderMethods(builderWriter, builderSpec);
+    builderFields = addBuilderFields(componentBuilder);
+    addBuildMethod(componentBuilder, builderSpec);
+    addBuilderMethods(componentBuilder, builderSpec);
+    addBuilderClass(componentBuilder.build());
 
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
+    constructor.addParameter(builderName.get(), "builder");
+    constructor.addStatement("assert builder != null");
   }
 
+  /**
+   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
+   * this in different classes.
+   */
+  protected abstract void addBuilderClass(TypeSpec builder);
+
   /**
    * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
    * requirements}. Regardless of builder spec, there is always one field per requirement.
    */
-  private ImmutableMap<TypeElement, FieldWriter> addBuilderFields(ClassWriter builderWriter) {
-    ImmutableMap.Builder<TypeElement, FieldWriter> builderFieldsBuilder = ImmutableMap.builder();
+  private ImmutableMap<TypeElement, FieldSpec> addBuilderFields(TypeSpec.Builder componentBuilder) {
+    UniqueNameSet builderFieldNames = new UniqueNameSet();
+    ImmutableMap.Builder<TypeElement, FieldSpec> builderFields = ImmutableMap.builder();
     for (TypeElement contributionElement : graph.componentRequirements()) {
-      String contributionName = simpleVariableName(contributionElement);
-      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
-      builderField.addModifiers(PRIVATE);
-      builderFieldsBuilder.put(contributionElement, builderField);
+      String contributionName =
+          builderFieldNames.getUniqueName(simpleVariableName(contributionElement));
+      FieldSpec builderField =
+          FieldSpec.builder(ClassName.get(contributionElement), contributionName, PRIVATE).build();
+      componentBuilder.addField(builderField);
+      builderFields.put(contributionElement, builderField);
     }
-    return builderFieldsBuilder.build();
+    return builderFields.build();
   }
 
   /** Adds the build method to the builder. */
-  private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> builderSpec) {
-    MethodWriter buildMethod;
+  private void addBuildMethod(
+      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
+    MethodSpec.Builder buildMethod;
     if (builderSpec.isPresent()) {
       ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
       // Note: we don't use the specBuildMethod.getReturnType() as the return type
       // because it might be a type variable.  We make use of covariant returns to allow
       // us to return the component type, which will always be valid.
       buildMethod =
-          builderWriter.addMethod(
-              componentDefinitionTypeName(), specBuildMethod.getSimpleName().toString());
-      buildMethod.annotate(Override.class);
+          methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
     } else {
-      buildMethod = builderWriter.addMethod(componentDefinitionTypeName(), "build");
+      buildMethod = methodBuilder("build");
     }
-    buildMethod.addModifiers(PUBLIC);
+    buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
 
-    for (Map.Entry<TypeElement, FieldWriter> builderFieldEntry : builderFields.entrySet()) {
-      FieldWriter builderField = builderFieldEntry.getValue();
+    for (Map.Entry<TypeElement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
+      FieldSpec builderField = builderFieldEntry.getValue();
       if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
-        buildMethod.body()
-            .addSnippet("if (%1$s == null) { this.%1$s = new %2$s(); }",
-                builderField.name(),
-                builderField.type());
+        buildMethod.addCode(
+            "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
       } else {
-        buildMethod.body()
-            .addSnippet(
-                "if (%s == null) { throw new %s(%s.class.getCanonicalName() + \" must be set\"); }",
-                builderField.name(),
-                ClassName.fromClass(IllegalStateException.class),
-                builderField.type());
+        buildMethod.addCode(
+            "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
+            builderField,
+            ILLEGAL_STATE_EXCEPTION,
+            builderField.type,
+            " must be set");
       }
     }
-
-    buildMethod.body().addSnippet("return new %s(this);", name);
+    buildMethod.addStatement("return new $T(this)", name);
+    componentBuilder.addMethod(buildMethod.build());
   }
 
   /**
@@ -357,92 +357,90 @@ private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> bui
    * present, it will tailor the methods to match the spec.
    */
   private void addBuilderMethods(
-      ClassWriter builderWriter,
-      Optional<BuilderSpec> builderSpec) {
+      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
     if (builderSpec.isPresent()) {
+      UniqueNameSet parameterNames = new UniqueNameSet();
       for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
           builderSpec.get().methodMap().entrySet()) {
         TypeElement builderMethodType = builderMethodEntry.getKey();
         ExecutableElement specMethod = builderMethodEntry.getValue();
-        MethodWriter builderMethod = addBuilderMethodFromSpec(builderWriter, specMethod);
+        MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
         String parameterName =
-            Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName().toString();
-        builderMethod.addParameter(builderMethodType, parameterName);
-        builderMethod.body().addSnippet(nullCheck(parameterName));
+            parameterNames.getUniqueName(
+                Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());
+        builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);
+        builderMethod.addCode(nullCheck(parameterName));
         if (graph.componentRequirements().contains(builderMethodType)) {
           // required type
-          builderMethod.body().addSnippet("this.%s = %s;",
-              builderFields.get(builderMethodType).name(),
-              parameterName);
+          builderMethod.addStatement(
+              "this.$N = $L", builderFields.get(builderMethodType), parameterName);
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
         } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
           // owned, but not required
-          builderMethod.body()
-              .addSnippet("// This module is declared, but not used in the component. "
-                  + "This method is a no-op");
+          builderMethod.addCode(
+              "// This module is declared, but not used in the component. This method is a "
+                  + "no-op\n");
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
         } else {
           // neither owned nor required, so it must be an inherited module
-          builderMethod
-              .body()
-              .addSnippet(
-                  "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
-                  ClassName.fromClass(UnsupportedOperationException.class),
-                  ClassName.fromClass(String.class),
-                  StringLiteral.forValue(
-                      "%s cannot be set because it is inherited from the enclosing component"),
-                  ClassName.fromTypeElement(builderMethodType));
+          builderMethod.addStatement(
+              "throw new $T($T.format($S, $T.class.getCanonicalName()))",
+              UNSUPPORTED_OPERATION_EXCEPTION,
+              STRING,
+              "%s cannot be set because it is inherited from the enclosing component",
+              ClassName.get(builderMethodType));
         }
+        componentBuilder.addMethod(builderMethod.build());
       }
     } else {
       for (TypeElement componentRequirement : graph.availableDependencies()) {
         String componentRequirementName = simpleVariableName(componentRequirement);
-        MethodWriter builderMethod = builderWriter.addMethod(
-            builderWriter.name(),
-            componentRequirementName);
-        builderMethod.addModifiers(PUBLIC);
-        builderMethod.addParameter(componentRequirement, componentRequirementName);
-        builderMethod.body().addSnippet(nullCheck(componentRequirementName));
+        MethodSpec.Builder builderMethod =
+            methodBuilder(componentRequirementName)
+                .returns(builderName.get())
+                .addModifiers(PUBLIC)
+                .addParameter(ClassName.get(componentRequirement), componentRequirementName)
+                .addCode(nullCheck(componentRequirementName));
         if (graph.componentRequirements().contains(componentRequirement)) {
-          builderMethod.body()
-              .addSnippet("this.%s = %s;",
-                  builderFields.get(componentRequirement).name(),
-                  componentRequirementName);
+          builderMethod.addStatement(
+              "this.$N = $L", builderFields.get(componentRequirement), componentRequirementName);
         } else {
-          builderMethod.annotate(Deprecated.class);
+          builderMethod.addAnnotation(Deprecated.class);
         }
-        builderMethod.body().addSnippet("return this;");
+        builderMethod.addStatement("return this");
+        componentBuilder.addMethod(builderMethod.build());
       }
     }
   }
 
   private void addBuilderMethodReturnStatementForSpec(
-      ExecutableElement specMethod, MethodWriter builderMethod) {
+      ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
     if (!specMethod.getReturnType().getKind().equals(VOID)) {
-      builderMethod.body().addSnippet("return this;");
+      builderMethod.addStatement("return this");
     }
   }
 
-  private MethodWriter addBuilderMethodFromSpec(
-      ClassWriter builderWriter, ExecutableElement method) {
-    String methodName = method.getSimpleName().toString();
+  private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
     TypeMirror returnType = method.getReturnType();
+    MethodSpec.Builder builderMethod =
+        methodBuilder(method.getSimpleName().toString())
+            .addAnnotation(Override.class)
+            .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
     // If the return type is void, we add a method with the void return type.
-    // Otherwise we use the builderWriter and take advantage of covariant returns
+    // Otherwise we use the generated builder name and take advantage of covariant returns
     // (so that we don't have to worry about setter methods that return type variables).
-    MethodWriter builderMethod =
-        returnType.getKind().equals(TypeKind.VOID)
-            ? builderWriter.addMethod(returnType, methodName)
-            : builderWriter.addMethod(builderWriter, methodName);
-    builderMethod.annotate(Override.class);
-    builderMethod.addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+    if (!returnType.getKind().equals(TypeKind.VOID)) {
+      builderMethod.returns(builderName.get());
+    }
     return builderMethod;
   }
 
   /**
    * Creates the builder class.
    */
-  protected abstract ClassWriter createBuilder();
+  protected abstract TypeSpec.Builder createBuilder(String builderName);
+
+  protected abstract ClassName builderName();
 
   /**
    * Adds component factory methods.
@@ -462,7 +460,7 @@ private void addField(ResolvedBindings resolvedBindings) {
     // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
     if (staticMemberSelect.isPresent()) {
-      memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
+      memberSelects.put(bindingKey, staticMemberSelect.get());
       return;
     }
 
@@ -471,90 +469,72 @@ private void addField(ResolvedBindings resolvedBindings) {
       return;
     }
 
-    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
-    boolean useRawType = bindingPackage.isPresent()
-        && !bindingPackage.get().equals(name.packageName());
-    if (resolvedBindings.isMultibindings()) {
-      // note that here we rely on the order of the resolved bindings being from parent to child
-      // otherwise, the numbering wouldn't work
-      int contributionNumber = 0;
-      for (ContributionBinding contributionBinding : resolvedBindings.contributionBindings()) {
-        contributionNumber++;
-        if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
-          FrameworkField contributionBindingField =
-              FrameworkField.createForSyntheticContributionBinding(
-                  contributionNumber, contributionBinding);
-          FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
-
-          multibindingContributionSnippets.put(
-              contributionBinding,
-              localField(name, contributionField.name()));
-        }
-      }
-    }
-
-    FrameworkField bindingField = FrameworkField.createForResolvedBindings(resolvedBindings);
-    FieldWriter frameworkField = addFrameworkField(useRawType, bindingField);
-
-    memberSelectSnippets.put(
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings);
+    memberSelects.put(
         bindingKey,
-        localField(name, frameworkField.name()));
+        localField(name, frameworkField.name));
   }
 
-  private FieldWriter addFrameworkField(boolean useRawType,
-      FrameworkField contributionBindingField) {
-    FieldWriter contributionField =
-        componentWriter.addField(
+  private FieldSpec addFrameworkField(ResolvedBindings resolvedBindings) {
+    boolean useRawType = useRawType(resolvedBindings);
+
+    FrameworkField contributionBindingField =
+        FrameworkField.createForResolvedBindings(resolvedBindings);
+    FieldSpec.Builder contributionField =
+        componentField(
             useRawType
-                ? contributionBindingField.frameworkType().type()
+                ? contributionBindingField.frameworkType().rawType
                 : contributionBindingField.frameworkType(),
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
-      contributionField.annotate(SuppressWarnings.class).setValue("rawtypes");
+      contributionField.addAnnotation(AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES);
     }
-    return contributionField;
+
+    FieldSpec field = contributionField.build();
+    component.addField(field);
+    return field;
+  }
+
+  private boolean useRawType(ResolvedBindings resolvedBindings) {
+    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+    return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
   }
 
   /**
    * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
    * no-op members injection binding, then we don't need a field to hold its factory. In that case,
-   * this method returns the static member select snippet that returns the factory or no-op members
+   * this method returns the static member select that returns the factory or no-op members
    * injector.
    */
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
-        if (resolvedBindings.isMultibindings()
-            && resolvedBindings.contributionBindings().isEmpty()) {
-          switch (resolvedBindings.contributionType()) {
-            case MAP:
-              return Optional.of(emptyMapProviderFactory(
-                  MapType.from(resolvedBindings.key().type())));
-
-            case SET:
-              return Optional.of(emptySetFactoryStaticMemberSelect(resolvedBindings));
+        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
+          switch (contributionBinding.bindingKind()) {
+            case SYNTHETIC_MULTIBOUND_MAP:
+              BindingType bindingType = contributionBinding.bindingType();
+              MapType mapType = MapType.from(contributionBinding.key().type());
+              return Optional.of(
+                  emptyFrameworkMapFactory(
+                      frameworkMapFactoryClassName(bindingType),
+                      mapType.keyType(),
+                      mapType.unwrappedValueType(bindingType.frameworkClass())));
+
+            case SYNTHETIC_MULTIBOUND_SET:
+              return Optional.of(
+                  emptySetFactoryStaticMemberSelect(
+                      contributionBinding.bindingType(), contributionBinding.key()));
 
-            case UNIQUE:
             default:
-              throw new AssertionError("Multibindings must be map or set, not " + resolvedBindings);
+              return Optional.of(
+                  staticMethod(
+                      generatedClassNameForBinding(contributionBinding),
+                      CodeBlocks.format("create()")));
           }
         }
-        if (resolvedBindings.contributionBindings().size() != 1) {
-          return Optional.absent();
-        }
-        ContributionBinding contributionBinding =
-            getOnlyElement(resolvedBindings.contributionBindings());
-        if (contributionBinding.contributionType().isMultibinding()
-            || !contributionBinding.bindingType().equals(BindingType.PROVISION)) {
-          return Optional.absent();
-        }
-        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-            && !contributionBinding.scope().isPresent()) {
-          return Optional.of(
-              staticMethod(
-                  generatedClassNameForBinding(contributionBinding), Snippet.format("create()")));
-        }
         break;
 
       case MEMBERS_INJECTION:
@@ -573,18 +553,18 @@ private FieldWriter addFrameworkField(boolean useRawType,
   }
 
   /**
-   * A static member select for a call to {@code F.create()} where {@code F} is either
-   * {@link SetFactory}, {@link SetProducer}, or {@link SetOfProducedProducer}, depending on the
-   * set bindings.
+   * A static member select for an empty set factory. Calls
+   * {@link SetFactory#create(javax.inject.Provider...)},
+   * {@link SetProducer#create(dagger.producers.Producer...)}, or
+   * {@link SetOfProducedProducer#create(dagger.producers.Producer...)}, depending on the set
+   * bindings.
    */
-  private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindings) {
-    ClassName setFactoryClassName = setFactoryClassName(setBindings);
-    return emptySetProvider(setFactoryClassName,
-        SetType.from(setBindings.bindingKey().key().type()));
+  private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
+    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key.type()));
   }
 
   /**
-   * Returns a {@link Set} factory class name appropriate for the set bindings.
+   * The {@link Set} factory class name appropriate for set bindings.
    *
    * <ul>
    * <li>{@link SetFactory} for provision bindings.
@@ -592,18 +572,51 @@ private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindi
    * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
    * </ul>
    */
-  private ClassName setFactoryClassName(ResolvedBindings setBindings) {
-    if (setBindings.bindingType().equals(BindingType.PROVISION)) {
-      return ClassName.fromClass(SetFactory.class);
+  private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
+    if (bindingType.equals(BindingType.PROVISION)) {
+      return SET_FACTORY;
     } else {
-      SetType setType = SetType.from(setBindings.bindingKey().key().type());
-      return ClassName.fromClass(
-          setType.elementsAreTypeOf(Produced.class)
-              ? SetOfProducedProducer.class
-              : SetProducer.class);
+      SetType setType = SetType.from(key.type());
+      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
+    }
+  }
+
+  /**
+   * The {@link Map}-of-value factory class name appropriate for map bindings.
+   *
+   * <ul>
+   * <li>{@link MapFactory} for provision bindings.
+   * <li>{@link MapProducer} for production bindings.
+   * </ul>
+   */
+  private static ClassName mapFactoryClassName(ContributionBinding binding) {
+    switch (binding.bindingType()) {
+      case PRODUCTION:
+        return MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)
+            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
+
+      case PROVISION:
+      case MEMBERS_INJECTION:
+        return MAP_FACTORY;
+
+      default:
+        throw new AssertionError(binding.toString());
     }
   }
 
+  /**
+   * The {@link Map}-of-framework factory class name appropriate for map bindings.
+   *
+   * <ul>
+   * <li>{@link MapProviderFactory} for provision bindings.
+   * <li>{@link MapOfProducerProducer} for production bindings.
+   * </ul>
+   */
+  private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
+    return bindingType.equals(BindingType.PRODUCTION)
+        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
+  }
+
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -618,38 +631,29 @@ private void implementInterfaceMethods() {
             requestElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
-          MethodWriter interfaceMethod =
-              requestType.getReturnType().getKind().equals(VOID)
-                  ? componentWriter.addMethod(
-                      VoidName.VOID, requestElement.getSimpleName().toString())
-                  : componentWriter.addMethod(
-                      requestType.getReturnType(), requestElement.getSimpleName().toString());
-          interfaceMethod.annotate(Override.class);
-          interfaceMethod.addModifiers(PUBLIC);
+          MethodSpec.Builder interfaceMethod =
+              methodBuilder(requestElement.getSimpleName().toString())
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(TypeName.get(requestType.getReturnType()));
           BindingKey bindingKey = interfaceRequest.bindingKey();
           MemberSelect memberSelect = getMemberSelect(bindingKey);
-          Snippet memberSelectSnippet = memberSelect.getSnippetFor(name);
+          CodeBlock memberSelectCodeBlock = memberSelect.getExpressionFor(name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
               List<? extends VariableElement> parameters = requestElement.getParameters();
               if (parameters.isEmpty()) {
                 // we're returning the framework type
-                interfaceMethod.body().addSnippet("return %s;", memberSelectSnippet);
+                interfaceMethod.addStatement("return $L", memberSelectCodeBlock);
               } else {
-                VariableElement parameter = Iterables.getOnlyElement(parameters);
-                Name parameterName = parameter.getSimpleName();
+                Name parameterName = Iterables.getOnlyElement(parameters).getSimpleName();
                 interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(
-                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    TypeName.get(Iterables.getOnlyElement(requestType.getParameterTypes())),
                     parameterName.toString());
-                interfaceMethod
-                    .body()
-                    .addSnippet(
-                        "%s.injectMembers(%s);",
-                        memberSelectSnippet,
-                        parameterName);
+                interfaceMethod.addStatement(
+                    "$L.injectMembers($L)", memberSelectCodeBlock, parameterName);
                 if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                  interfaceMethod.addStatement("return $L", parameterName);
                 }
               }
               break;
@@ -660,14 +664,10 @@ private void implementInterfaceMethods() {
                 // If using a parameterized enum type, then we need to store the factory
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
-                TypeName factoryType =
-                    ParameterizedTypeName.create(
-                        Provider.class, TypeNames.forTypeMirror(requestType.getReturnType()));
+                TypeName factoryType = providerOf(TypeName.get(requestType.getReturnType()));
                 interfaceMethod
-                    .body()
-                    .addSnippet(
-                        "%s factory = %s;", factoryType, memberSelectSnippet);
-                interfaceMethod.body().addSnippet("return factory.get();");
+                    .addStatement("$T factory = $L", factoryType, memberSelectCodeBlock)
+                    .addStatement("return factory.get()");
                 break;
               }
               // fall through in the else case.
@@ -676,16 +676,14 @@ private void implementInterfaceMethods() {
             case PRODUCER:
             case PROVIDER:
             case FUTURE:
-              interfaceMethod
-                  .body()
-                  .addSnippet(
-                      "return %s;",
-                      frameworkTypeUsageStatement(
-                          memberSelectSnippet, interfaceRequest.kind()));
+              interfaceMethod.addStatement(
+                  "return $L",
+                  frameworkTypeUsageStatement(memberSelectCodeBlock, interfaceRequest.kind()));
               break;
             default:
               throw new AssertionError();
           }
+          component.addMethod(interfaceMethod.build());
         }
       }
     }
@@ -695,163 +693,103 @@ private void addSubcomponents() {
     for (Map.Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
       SubcomponentWriter subcomponent =
           new SubcomponentWriter(this, subgraphEntry.getKey(), subgraphEntry.getValue());
-      javaWriters.addAll(subcomponent.write());
+      component.addType(subcomponent.write().build());
     }
   }
 
-  private static final int SNIPPETS_PER_INITIALIZATION_METHOD = 100;
+  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
   private void initializeFrameworkTypes() {
-    ImmutableList.Builder<Snippet> snippetsBuilder = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      snippetsBuilder.addAll(initializeFrameworkType(bindingKey).asSet());
+      codeBlocks.addAll(initializeFrameworkType(bindingKey).asSet());
     }
-    ImmutableList<Snippet> snippets = snippetsBuilder.build();
-
-    List<List<Snippet>> partitions = Lists.partition(snippets, SNIPPETS_PER_INITIALIZATION_METHOD);
-    for (int i = 0; i < partitions.size(); i++) {
-      MethodWriter initializeMethod =
-          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
-      /* TODO(gak): Strictly speaking, we only need the suppression here if we are also initializing
-       * a raw field in this method, but the structure of this code makes it awkward to pass that
-       * bit through.  This will be cleaned up when we no longer separate fields and initilization
-       * as we do now. */
-      initializeMethod.annotate(SuppressWarnings.class).setValue("unchecked");
-      for (Snippet snippet : partitions.get(i)) {
-        initializeMethod.body().addSnippet(snippet);
-      }
-      initializeMethod.addModifiers(PRIVATE);
+    List<List<CodeBlock>> partitions =
+        Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
+
+    UniqueNameSet methodNames = new UniqueNameSet();
+    for (List<CodeBlock> partition : partitions) {
+      String methodName = methodNames.getUniqueName("initialize");
+      MethodSpec.Builder initializeMethod =
+          methodBuilder(methodName)
+              .addModifiers(PRIVATE)
+              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
+               * initializing a raw field in this method, but the structure of this code makes it
+               * awkward to pass that bit through.  This will be cleaned up when we no longer
+               * separate fields and initilization as we do now. */
+              .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
+              .addCode(CodeBlocks.concat(partition));
       if (builderName.isPresent()) {
-        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
-        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
+        initializeMethod.addParameter(builderName.get(), "builder", FINAL);
+        constructor.addStatement("$L(builder)", methodName);
       } else {
-        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
+        constructor.addStatement("$L()", methodName);
       }
+      component.addMethod(initializeMethod.build());
     }
   }
 
   /**
-   * Returns a single snippet representing the initialization of the framework type.
+   * Returns a single code block representing the initialization of the framework type.
    *
-   * <p>Note that this must be a single snippet because initialization snippets can be invoked from
-   * any place in any order.  By requiring a single snippet (often of concatenated snippets) we
-   * ensure that things like local variables always behave as expected by the initialization logic.
+   * <p>Note that this must be a single code block because initialization code blocks can be invoked
+   * from any place in any order.  By requiring a single code block (often of concatenated code
+   * blocks) we ensure that things like local variables always behave as expected by the
+   * initialization logic.
    */
-  private Optional<Snippet> initializeFrameworkType(BindingKey bindingKey) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-
-    // There's no field for inherited bindings.
-    if (resolvedBindings.ownedBindings().isEmpty()) {
+  private Optional<CodeBlock> initializeFrameworkType(BindingKey bindingKey) {
+    // If the field is inherited or the member select is static, don't initialize.
+    MemberSelect memberSelect = getMemberSelect(bindingKey);
+    if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
       return Optional.absent();
     }
-
+    
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
-        switch (resolvedBindings.contributionType()) {
-          case SET:
-            return Optional.of(initializeSetMultibindings(resolvedBindings));
-          case MAP:
-            return Optional.of(initializeMapMultibindings(resolvedBindings));
-          case UNIQUE:
-            return initializeUniqueContributionBinding(resolvedBindings);
-          default:
-            throw new AssertionError();
-        }
+        return initializeContributionBinding(bindingKey);
 
       case MEMBERS_INJECTION:
-        return initializeMembersInjectionBinding(resolvedBindings);
+        return initializeMembersInjectionBinding(bindingKey);
 
       default:
         throw new AssertionError();
     }
   }
 
-  private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-
-    ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-      Optional<MemberSelect> multibindingContributionSnippet =
-          getMultibindingContributionSnippet(binding);
-      checkState(multibindingContributionSnippet.isPresent(), "%s was not found", binding);
-      Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
-      if (multibindingContributionSnippet.get().owningClass().equals(name)
-          // the binding might already be initialized by a different set binding that shares the
-          // same contributions (e.g., Set<T> and Set<Produced<T>>)
-          && getContributionInitializationState(binding)
-              .equals(InitializationState.UNINITIALIZED)) {
-        Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
-        initializationSnippets.add(Snippet.format("this.%s = %s;", snippet, initializeSnippet));
-        setContributionInitializationState(binding, InitializationState.INITIALIZED);
-      }
-      parameterSnippets.add(snippet);
-    }
-    Snippet initializeSetSnippet =
-        Snippet.format(
-            "%s.create(%s)",
-            setFactoryClassName(resolvedBindings),
-            makeParametersSnippet(parameterSnippets.build()));
-    initializationSnippets.add(
-        initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
-
-    return Snippet.concat(initializationSnippets.build());
-  }
-
-  private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-      Optional<MemberSelect> multibindingContributionSnippet =
-          getMultibindingContributionSnippet(binding);
-      if (multibindingContributionSnippet.isPresent()
-          && multibindingContributionSnippet.get().owningClass().equals(name)) {
-        initializationSnippets.add(
-            Snippet.format(
-                "this.%s = %s;",
-                multibindingContributionSnippet.get().getSnippetFor(name),
-                initializeFactoryForContributionBinding(binding)));
-      }
-    }
-    initializationSnippets.add(
-        initializeMember(resolvedBindings.bindingKey(), initializeMapBinding(resolvedBindings)));
-
-    return Snippet.concat(initializationSnippets.build());
-  }
-
-  private Optional<Snippet> initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
-    ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
+  private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
+    ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
     if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
       return Optional.absent();
     }
 
     return Optional.of(
-        Snippet.concat(
+        CodeBlocks.concat(
             ImmutableList.of(
                 initializeDelegateFactoriesForUninitializedDependencies(binding),
-                initializeMember(
-                    resolvedBindings.bindingKey(),
-                    initializeFactoryForContributionBinding(binding)))));
+                initializeMember(bindingKey, initializeFactoryForContributionBinding(binding)))));
   }
 
-  private Optional<Snippet> initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
-    MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
+  private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
+    MembersInjectionBinding binding =
+        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
+
     if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
       return Optional.absent();
     }
 
     return Optional.of(
-        Snippet.concat(
+        CodeBlocks.concat(
             ImmutableList.of(
                 initializeDelegateFactoriesForUninitializedDependencies(binding),
-                initializeMember(
-                    resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)))));
+                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
   }
 
   /**
    * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
    * because of a dependency cycle.
    */
-  private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+  private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
+    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
     for (BindingKey dependencyKey :
         FluentIterable.from(binding.implicitDependencies())
@@ -859,66 +797,63 @@ private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding
             .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        initializationSnippets.add(
-            Snippet.format(
-                "this.%s = new %s();",
-                getMemberSelectSnippet(dependencyKey),
-                ClassName.fromClass(DelegateFactory.class)));
+        initializations.add(
+            CodeBlocks.format(
+                "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
         setInitializationState(dependencyKey, DELEGATED);
       }
     }
 
-    return Snippet.concat(initializationSnippets.build());
+    return CodeBlocks.concat(initializations.build());
   }
 
-  private Snippet initializeMember(BindingKey bindingKey, Snippet initializationSnippet) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+  private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
+    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
-    Snippet memberSelect = getMemberSelectSnippet(bindingKey);
-    Snippet delegateFactoryVariable = delegateFactoryVariableSnippet(bindingKey);
+    CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
+    CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializationSnippets.add(
-          Snippet.format(
-              "%1$s %2$s = (%1$s) %3$s;",
-              ClassName.fromClass(DelegateFactory.class),
-              delegateFactoryVariable,
-              memberSelect));
+      initializations.add(
+          CodeBlocks.format(
+              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
     }
-    initializationSnippets.add(
-        Snippet.format("this.%s = %s;", memberSelect, initializationSnippet));
+    initializations.add(
+        CodeBlocks.format("this.$L = $L;", memberSelect, initializationCodeBlock));
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializationSnippets.add(
-          Snippet.format("%s.setDelegatedProvider(%s);", delegateFactoryVariable, memberSelect));
+      initializations.add(
+          CodeBlocks.format("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
     }
     setInitializationState(bindingKey, INITIALIZED);
 
-    return Snippet.concat(initializationSnippets.build());
+    return CodeBlocks.concat(initializations.build());
   }
 
-  private Snippet delegateFactoryVariableSnippet(BindingKey key) {
-    return Snippet.format("%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
+  private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
+    return CodeBlocks.format(
+        "$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
   }
 
-  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeNames.forTypeMirror(binding.key().type());
+  private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
-        return Snippet.format(
-            "%s.<%s>create(%s)",
-            ClassName.fromClass(InstanceFactory.class),
+        return CodeBlocks.format(
+            "$T.<$T>create($L)",
+            INSTANCE_FACTORY,
             bindingKeyTypeName,
             bindingKeyTypeName.equals(componentDefinitionTypeName())
                 ? "this"
-                : getComponentContributionSnippet(MoreTypes.asTypeElement(binding.key().type())));
+                : getComponentContributionExpression(
+                    MoreTypes.asTypeElement(binding.key().type())));
 
       case COMPONENT_PROVISION:
         {
           TypeElement bindingTypeElement =
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
           String localFactoryVariable = simpleVariableName(bindingTypeElement);
-          Snippet callFactoryMethodSnippet =
-              Snippet.format(
-                  "%s.%s()",
+          CodeBlock callFactoryMethod =
+              CodeBlocks.format(
+                  "$L.$L()",
                   localFactoryVariable,
                   binding.bindingElement().getSimpleName().toString());
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
@@ -927,231 +862,213 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           // We can easily include the raw type (no generics) + annotation type (no values),
           // using .class & String.format -- but that wouldn't be the whole story.
           // What should we do?
-          StringLiteral failMsg =
-              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          Snippet getMethodBody =
+          CodeBlock getMethodBody =
               binding.nullableType().isPresent()
                       || nullableValidationType.equals(Diagnostic.Kind.WARNING)
-                  ? Snippet.format("return %s;", callFactoryMethodSnippet)
-                  : Snippet.format(
+                  ? CodeBlocks.format("return $L;", callFactoryMethod)
+                  : CodeBlocks.format(
                       Joiner.on('\n')
                           .join(
-                              "%s provided = %s;",
+                              "$T provided = $L;",
                               "if (provided == null) {",
-                              "  throw new NullPointerException(%s);",
+                              "  throw new NullPointerException($S);",
                               "}",
                               "return provided;"),
                       bindingKeyTypeName,
-                      callFactoryMethodSnippet,
-                      failMsg);
-          return Snippet.format(
+                      callFactoryMethod,
+                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          return CodeBlocks.format(
               Joiner.on('\n')
                   .join(
-                      "new %1$s<%2$s>() {",
-                      "  private final %5$s %6$s = %3$s;",
-                      "  %4$s@Override public %2$s get() {",
-                      "    %7$s",
+                      "new $1T<$2T>() {",
+                      "  private final $5T $6L = $3L;",
+                      "  $4L@Override public $2T get() {",
+                      "    $7L",
                       "  }",
                       "}"),
-              /* 1 */ ClassName.fromClass(Factory.class),
+              /* 1 */ FACTORY,
               /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionSnippet(bindingTypeElement),
-              /* 4 */ nullableSnippet(binding.nullableType()),
-              /* 5 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 3 */ getComponentContributionExpression(bindingTypeElement),
+              /* 4 */ nullableAnnotation(binding.nullableType()),
+              /* 5 */ TypeName.get(bindingTypeElement.asType()),
               /* 6 */ localFactoryVariable,
               /* 7 */ getMethodBody);
         }
 
       case SUBCOMPONENT_BUILDER:
-        return Snippet.format(
+        return CodeBlocks.format(
             Joiner.on('\n')
                 .join(
-                    "new %1$s<%2$s>() {",
-                    "  @Override public %2$s get() {",
-                    "    return %3$s();",
+                    "new $1T<$2T>() {",
+                    "  @Override public $2T get() {",
+                    "    return $3L();",
                     "  }",
                     "}"),
-            /* 1 */ ClassName.fromClass(Factory.class),
+            /* 1 */ FACTORY,
             /* 2 */ bindingKeyTypeName,
             /* 3 */ binding.bindingElement().getSimpleName().toString());
 
       case INJECTION:
       case PROVISION:
         {
-          List<Snippet> parameters =
+          List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
           if (binding.bindingKind().equals(PROVISION)
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
-            parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
+            arguments.add(getComponentContributionExpression(binding.contributedBy().get()));
           }
-          parameters.addAll(
-              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER));
+          arguments.addAll(getDependencyArguments(binding));
 
-          Snippet factorySnippet =
-              Snippet.format(
-                  "%s.create(%s)",
+          CodeBlock factoryCreate =
+              CodeBlocks.format(
+                  "$T.create($L)",
                   generatedClassNameForBinding(binding),
-                  Snippet.makeParametersSnippet(parameters));
+                  makeParametersCodeBlock(arguments));
           return binding.scope().isPresent()
-              ? Snippet.format(
-                  "%s.create(%s)", ClassName.fromClass(ScopedProvider.class), factorySnippet)
-              : factorySnippet;
+              ? CodeBlocks.format("$T.create($L)", SCOPED_PROVIDER, factoryCreate)
+              : factoryCreate;
         }
 
       case COMPONENT_PRODUCTION:
         {
           TypeElement bindingTypeElement =
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-          return Snippet.format(
+          return CodeBlocks.format(
               Joiner.on('\n')
                   .join(
-                      "new %1$s<%2$s>() {",
-                      "  private final %6$s %7$s = %4$s;",
-                      "  @Override public %3$s<%2$s> get() {",
-                      "    return %7$s.%5$s();",
+                      "new $1T<$2T>() {",
+                      "  private final $6T $7L = $4L;",
+                      "  @Override public $3T<$2T> get() {",
+                      "    return $7L.$5L();",
                       "  }",
                       "}"),
-              /* 1 */ ClassName.fromClass(Producer.class),
-              /* 2 */ TypeNames.forTypeMirror(binding.key().type()),
-              /* 3 */ ClassName.fromClass(ListenableFuture.class),
-              /* 4 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 1 */ PRODUCER,
+              /* 2 */ TypeName.get(binding.key().type()),
+              /* 3 */ LISTENABLE_FUTURE,
+              /* 4 */ getComponentContributionExpression(bindingTypeElement),
               /* 5 */ binding.bindingElement().getSimpleName().toString(),
-              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 6 */ TypeName.get(bindingTypeElement.asType()),
               /* 7 */ simpleVariableName(bindingTypeElement));
         }
 
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         {
-          List<Snippet> parameters =
+          List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
           if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-            parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
+            arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
           }
-          parameters.add(
-              getComponentContributionSnippet(
+          arguments.add(
+              getComponentContributionExpression(
                   graph.componentDescriptor().executorDependency().get()));
-          parameters.addAll(
-              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PRODUCER));
+          arguments.addAll(getDependencyArguments(binding));
 
-          return Snippet.format(
-              "new %s(%s)",
+          return CodeBlocks.format(
+              "new $T($L)",
               generatedClassNameForBinding(binding),
-              Snippet.makeParametersSnippet(parameters));
+              makeParametersCodeBlock(arguments));
         }
 
       case SYNTHETIC_MAP:
-        checkState(
-            MapType.isMap(binding.key().type()),
-            "Expected synthetic binding to be for a map: %s",
-            binding);
-        final ClassName contributionClassName;
-        switch (binding.bindingType()) {
-          case PRODUCTION:
-            if (MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)) {
-              contributionClassName = ClassName.fromClass(MapOfProducedProducer.class);
-            } else {
-              contributionClassName = ClassName.fromClass(MapProducer.class);
-            }
-            break;
-          case PROVISION:
-            contributionClassName = ClassName.fromClass(MapFactory.class);
-            break;
-          default:
-            throw new AssertionError();
-        }
-        return Snippet.format(
-            "%s.create(%s)",
-            contributionClassName,
-            getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
-                .getSnippetFor(name));
+        return CodeBlocks.format(
+            "$T.create($L)",
+            mapFactoryClassName(binding),
+            getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
+
+      case SYNTHETIC_MULTIBOUND_SET:
+        return initializeFactoryForSetMultibinding(binding);
+
+      case SYNTHETIC_MULTIBOUND_MAP:
+        return initializeFactoryForMapMultibinding(binding);
 
       default:
-        throw new AssertionError();
+        throw new AssertionError(binding.toString());
     }
   }
 
-  private Snippet nullableSnippet(Optional<DeclaredType> nullableType) {
+  private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
     return nullableType.isPresent()
-        ? Snippet.format("@%s ", TypeNames.forTypeMirror(nullableType.get()))
-        : Snippet.format("");
+        ? CodeBlocks.format("@$T ", TypeName.get(nullableType.get()))
+        : CodeBlocks.format("");
   }
 
-  private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
+  private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     switch (binding.injectionStrategy()) {
       case NO_OP:
-        return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
+        return CodeBlocks.format("$T.noOp()", MEMBERS_INJECTORS);
       case INJECT_MEMBERS:
-        List<Snippet> parameters =
-            getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER);
-        return Snippet.format(
-            "%s.create(%s)",
+        return CodeBlocks.format(
+            "$T.create($L)",
             membersInjectorNameForType(binding.bindingElement()),
-            Snippet.makeParametersSnippet(parameters));
+            makeParametersCodeBlock(getDependencyArguments(binding)));
       default:
         throw new AssertionError();
     }
   }
 
   /**
-   * The snippets that represent factory arguments for the dependencies of a binding.
+   * The expressions that represent factory arguments for the dependencies of a binding.
    */
-  private List<Snippet> getDependencyParameterSnippets(
-      Binding binding, DependencyRequestMapper dependencyRequestMapper) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> dependencyRequestsForUnresolvedKey :
-        indexDependenciesByUnresolvedKey(binding).asMap().values()) {
-      BindingKey requestedKey =
-          Iterables.getOnlyElement(
-              FluentIterable.from(dependencyRequestsForUnresolvedKey)
-                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                  .toSet());
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
-      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetFor(name);
-      if (resolvedBindings.frameworkClass().equals(Provider.class)
-          && dependencyRequestMapper
-              .getFrameworkClass(dependencyRequestsForUnresolvedKey)
-              .equals(Producer.class)) {
-        parameters.add(
-            Snippet.format(
-                "%s.producerFromProvider(%s)",
-                ClassName.fromClass(Producers.class),
-                frameworkSnippet));
-      } else {
-        parameters.add(frameworkSnippet);
-      }
+  private ImmutableList<CodeBlock> getDependencyArguments(
+      Binding binding) {
+    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      parameters.add(getDependencyArgument(frameworkDependency));
     }
     return parameters.build();
   }
 
-  private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
-    MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
-    boolean hasProductionContribution =
-        Iterables.any(
-            resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION));
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-    snippets.add(
-        Snippet.format(
-            "%s.<%s, %s>builder(%d)",
-            ClassName.fromClass(
-                hasProductionContribution ? MapOfProducerProducer.class : MapProviderFactory.class),
-            TypeNames.forTypeMirror(mapType.keyType()),
-            TypeNames.forTypeMirror(
-                mapType.unwrappedValueType(
-                    hasProductionContribution ? Producer.class : Provider.class)),
-            resolvedBindings.contributionBindings().size()));
-
-    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-      snippets.add(
-          Snippet.format(
-              "    .put(%s, %s)",
-              getMapKeySnippet(binding.bindingElement()),
-              getMultibindingContributionSnippet(binding).get().getSnippetFor(name)));
+  /**
+   * The expression to use as an argument for a dependency.
+   */
+  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
+    BindingKey requestedKey = frameworkDependency.bindingKey();
+    CodeBlock frameworkExpression = getMemberSelectExpression(requestedKey);
+    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+    if (resolvedBindings.frameworkClass().equals(Provider.class)
+        && frameworkDependency.frameworkClass().equals(Producer.class)) {
+      return CodeBlocks.format("$T.producerFromProvider($L)", PRODUCERS, frameworkExpression);
+    } else {
+      return frameworkExpression;
     }
+  }
 
-    snippets.add(Snippet.format("    .build()"));
+  private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
+    return CodeBlocks.format(
+        "$T.create($L)",
+        setFactoryClassName(binding.bindingType(), binding.key()),
+        makeParametersCodeBlock(getDependencyArguments(binding)));
+  }
+
+  private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
+    ImmutableSet<FrameworkDependency> frameworkDependencies =
+        FrameworkDependency.frameworkDependenciesForBinding(binding);
+
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    MapType mapType = MapType.from(binding.key().type());
+    codeBlocks.add(
+        CodeBlocks.format(
+            "$T.<$T, $T>builder($L)",
+            frameworkMapFactoryClassName(binding.bindingType()),
+            TypeName.get(mapType.keyType()),
+            TypeName.get(
+                mapType.unwrappedValueType(binding.bindingType().frameworkClass())),
+            frameworkDependencies.size()));
+
+    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+      BindingKey bindingKey = frameworkDependency.bindingKey();
+      ContributionBinding contributionBinding =
+          graph.resolvedBindings().get(bindingKey).contributionBinding();
+      codeBlocks.add(
+          CodeBlocks.format(
+              ".put($L, $L)",
+              getMapKeyExpression(contributionBinding.bindingElement()),
+              getDependencyArgument(frameworkDependency)));
+    }
+    codeBlocks.add(CodeBlocks.format(".build()"));
 
-    return Snippet.concat(snippets.build());
+    return CodeBlocks.concat(codeBlocks.build());
   }
 
   private static String simpleVariableName(TypeElement typeElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index f7ed3ac77..a85b8f6a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,6 +33,7 @@
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
 import dagger.Subcomponent;
+import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
@@ -65,6 +66,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -280,6 +282,7 @@ private BindingGraph create(
       final ComponentDescriptor componentDescriptor;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
+      final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
@@ -303,6 +306,15 @@ private BindingGraph create(
         assert multibindingDeclarations != null;
         this.multibindingDeclarations = multibindingDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
+
+        ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
+            ImmutableSetMultimap.builder();
+        for (ContributionBinding binding : explicitBindingsSet) {
+          if (binding.key().bindingMethod().isPresent()) {
+            explicitMultibindingsBuilder.put(binding.key().withoutBindingMethod(), binding);
+          }
+        }
+        this.explicitMultibindings = explicitMultibindingsBuilder.build();
       }
 
       /**
@@ -331,17 +343,20 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
+            Set<ContributionBinding> multibindings = new LinkedHashSet<>();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
 
             // Add explicit bindings and declarations (those from modules and components).
             contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
+            multibindings.addAll(getExplicitMultibindings(bindingKey.key()));
             multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
 
             // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
             // Set<T>.
             Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
             contributionBindings.addAll(getExplicitBindings(implicitSetKey));
+            multibindings.addAll(getExplicitMultibindings(implicitSetKey));
             multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
 
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
@@ -353,14 +368,14 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             Optional<Key> implicitMapProviderKey =
                 keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
             ImmutableSet<ContributionBinding> explicitProviderMapBindings =
-                getExplicitBindings(implicitMapProviderKey);
+                getExplicitMultibindings(implicitMapProviderKey);
             ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
                 getMultibindingDeclarations(implicitMapProviderKey);
 
             Optional<Key> implicitMapProducerKey =
                 keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
             ImmutableSet<ContributionBinding> explicitProducerMapBindings =
-                getExplicitBindings(implicitMapProducerKey);
+                getExplicitMultibindings(implicitMapProducerKey);
             ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
                 getMultibindingDeclarations(implicitMapProducerKey);
 
@@ -381,9 +396,27 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   provisionBindingFactory.implicitMapOfProviderBinding(request));
             }
 
+            Iterable<? extends HasBindingType> multibindingsAndDeclarations =
+                Iterables.concat(multibindings, multibindingDeclarations);
+            if (Iterables.any(
+                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
+              /* If there are production multibindings, add a synthetic binding that depends on each
+               * individual multibinding. */
+              contributionBindings.add(
+                  productionBindingFactory.syntheticMultibinding(request, multibindings));
+            } else if (Iterables.any(
+                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
+              /* If there are provision multibindings but not production ones, add a synthetic
+               * binding that depends on each individual multibinding. */
+              contributionBindings.add(
+                  provisionBindingFactory.syntheticMultibinding(request, multibindings));
+            }
+
             /* If there are no explicit or synthetic bindings or multibinding declarations, use an
              * implicit @Inject- constructed binding if there is one. */
-            if (contributionBindings.isEmpty() && multibindingDeclarations.isEmpty()) {
+            if (contributionBindings.isEmpty()
+                && multibindings.isEmpty()
+                && multibindingDeclarations.isEmpty()) {
               contributionBindings.addAll(
                   injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
             }
@@ -500,6 +533,26 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
             : ImmutableSet.<ContributionBinding>of();
       }
 
+      /**
+       * Returns the explicit multibindings whose key (minus its {@link Key#bindingMethod()})
+       * matches the {@code requestKey} from this and all ancestor resolvers.
+       */
+      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
+        ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          explicitMultibindingsForKey.addAll(resolver.explicitMultibindings.get(requestKey));
+        }
+        return explicitMultibindingsForKey.build();
+      }
+
+      private ImmutableSet<ContributionBinding> getExplicitMultibindings(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getExplicitMultibindings(optionalKey.get())
+            : ImmutableSet.<ContributionBinding>of();
+      }
+
       /**
        * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
        * ancestor resolvers.
@@ -603,7 +656,7 @@ void resolve(DependencyRequest request) {
       }
 
       private final class MultibindingDependencies {
-        private final Set<BindingKey> cycleChecker = new HashSet<>();
+        private final Set<Object> cycleChecker = new HashSet<>();
 
         /**
          * Returns {@code true} if {@code bindingKey} previously resolved to multibindings with
@@ -660,6 +713,9 @@ public Boolean call() {
          * multibindings with contributions from subcomponents.
          */
         boolean dependsOnLocalMultibindings(final Binding binding) {
+          if (!cycleChecker.add(binding)) {
+            return false;
+          }
           try {
             return bindingDependsOnLocalMultibindingsCache.get(
                 binding,
@@ -684,8 +740,10 @@ public Boolean call() {
         }
 
         private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
-          return resolvedBindings.isMultibindings()
-              && explicitBindings.containsKey(resolvedBindings.key());
+          return FluentIterable.from(resolvedBindings.contributionBindings())
+                  .transform(ContributionBinding.KIND)
+                  .anyMatch(IS_SYNTHETIC_MULTIBINDING_KIND)
+              && explicitMultibindings.containsKey(resolvedBindings.key());
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 413896c38..15c540ede 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -35,13 +35,13 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.TypeName;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.SourceElement.HasSourceElement;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
@@ -77,7 +77,6 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
-import static com.google.common.collect.Iterables.skip;
 import static com.google.common.collect.Maps.filterKeys;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
@@ -85,7 +84,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -286,44 +286,32 @@ private boolean validateResolvedBinding(
 
       switch (resolvedBinding.bindingKey().kind()) {
         case CONTRIBUTION:
-          ImmutableSet<ContributionBinding> contributionBindings =
-              resolvedBinding.contributionBindings();
           if (Iterables.any(
               resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
             // TODO(dpb): How could this ever happen, even in an invalid graph?
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          if (!validateNullability(path.peek().request(), contributionBindings)) {
+          if (!validateNullability(path.peek().request(), resolvedBinding.contributionBindings())) {
             return false;
           }
-          if (Iterables.any(contributionBindings, BindingType.isOfType(BindingType.PRODUCTION))
-              && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path);
+          if (resolvedBinding.contributionBindings().size() > 1) {
+            reportDuplicateBindings(path);
             return false;
           }
-          ImmutableSet<ContributionType> contributionTypes =
-              declarationsByType(resolvedBinding).keySet();
-          if (contributionTypes.size() > 1) {
-            reportMultipleBindingTypes(path);
+          ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
+          if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
+              && doesPathRequireProvisionOnly(path)) {
+            reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if (contributionBindings.size() <= 1) {
-            return true;
-          }
-          switch (getOnlyElement(contributionTypes)) {
-            case UNIQUE:
-              reportDuplicateBindings(path);
-              return false;
-            case MAP:
-              boolean duplicateMapKeys = hasDuplicateMapKeys(path, contributionBindings);
-              boolean inconsistentMapKeyAnnotationTypes =
-                  hasInconsistentMapKeyAnnotationTypes(path, contributionBindings);
-              return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
-            case SET:
-              break;
-            default:
-              throw new AssertionError();
+          if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
+            ImmutableSet<ContributionBinding> multibindings =
+                inlineSyntheticContributions(resolvedBinding).contributionBindings();
+            boolean duplicateMapKeys = reportIfDuplicateMapKeys(path, multibindings);
+            boolean inconsistentMapKeyAnnotationTypes =
+                reportIfInconsistentMapKeyAnnotationTypes(path, multibindings);
+            return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
           }
           break;
         case MEMBERS_INJECTION:
@@ -346,8 +334,8 @@ private boolean validateResolvedBinding(
 
     /**
      * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
-     * that any {@link #SYNTHETIC_MAP} {@link ContributionBinding}s are replaced by the contribution
-     * bindings and multibinding declarations of their dependencies.
+     * that any synthetic {@link ContributionBinding}s are replaced by the contribution bindings and
+     * multibinding declarations of their dependencies.
      *
      * <p>For example, if:
      *
@@ -365,8 +353,9 @@ private boolean validateResolvedBinding(
      * <p>The replacement is repeated until none of the bindings are synthetic.
      */
     private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedBinding) {
-      if (!Iterables.any(
-          resolvedBinding.contributionBindings(), ContributionBinding.isOfKind(SYNTHETIC_MAP))) {
+      if (!FluentIterable.from(resolvedBinding.contributionBindings())
+          .transform(ContributionBinding.KIND)
+          .anyMatch(IS_SYNTHETIC_KIND)) {
         return resolvedBinding;
       }
       
@@ -375,23 +364,21 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
 
-      Queue<Map.Entry<ComponentDescriptor, ContributionBinding>> contributionQueue =
-          new ArrayDeque<>(resolvedBinding.allContributionBindings().entries());
-
-      for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry =
-              contributionQueue.poll();
-          bindingEntry != null;
-          bindingEntry = contributionQueue.poll()) {
-        ContributionBinding binding = bindingEntry.getValue();
-        if (binding.bindingKind().equals(SYNTHETIC_MAP)) {
-          BindingKey syntheticBindingDependency =
-              getOnlyElement(binding.dependencies()).bindingKey();
-          ResolvedBindings dependencyBindings =
-              subject.resolvedBindings().get(syntheticBindingDependency);
-          multibindingDeclarations.addAll(dependencyBindings.multibindingDeclarations());
-          contributionQueue.addAll(dependencyBindings.allContributionBindings().entries());
-        } else {
-          contributions.put(bindingEntry);
+      Queue<ResolvedBindings> queue = new ArrayDeque<>();
+      queue.add(resolvedBinding);
+
+      for (ResolvedBindings queued = queue.poll(); queued != null; queued = queue.poll()) {
+        multibindingDeclarations.addAll(queued.multibindingDeclarations());
+        for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
+            queued.allContributionBindings().entries()) {
+          ContributionBinding binding = bindingEntry.getValue();
+          if (binding.isSyntheticBinding()) {
+            for (DependencyRequest dependency : binding.dependencies()) {
+              queue.add(subject.resolvedBindings().get(dependency.bindingKey()));
+            }
+          } else {
+            contributions.put(bindingEntry);
+          }
         }
       }
       return ResolvedBindings.forContributionBindings(
@@ -422,7 +409,7 @@ private boolean validateNullability(
        * (Maybe this happens if the code was already compiled before this point?)
        * ... we manually print out the request in that case, otherwise the error
        * message is kind of useless. */
-      String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+      String typeName = TypeName.get(request.key().type()).toString();
 
       boolean valid = true;
       for (ContributionBinding binding : bindings) {
@@ -443,7 +430,7 @@ private boolean validateNullability(
      * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
      * for the same map key.
      */
-    private boolean hasDuplicateMapKeys(
+    private boolean reportIfDuplicateMapKeys(
         Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
       boolean hasDuplicateMapKeys = false;
       for (Collection<ContributionBinding> mapBindingsForMapKey :
@@ -460,7 +447,7 @@ private boolean hasDuplicateMapKeys(
      * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
      * {@link MapKey} annotation type.
      */
-    private boolean hasInconsistentMapKeyAnnotationTypes(
+    private boolean reportIfInconsistentMapKeyAnnotationTypes(
         Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
       ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
           mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
@@ -896,6 +883,12 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
+      if (FluentIterable.from(resolvedBinding.contributionBindings())
+          .transform(ContributionBinding.KIND)
+          .anyMatch(IS_SYNTHETIC_KIND)) {
+        reportMultipleBindingTypes(path);
+        return;
+      }
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
@@ -915,6 +908,11 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
           declarationsByType(resolvedBinding);
+      verify(
+          declarationsByType.keySet().size() > 1,
+          "expected multiple binding types for %s: %s",
+          resolvedBinding.bindingKey(),
+          declarationsByType);
       for (ContributionType type :
           Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
         builder.append(INDENT);
@@ -1013,11 +1011,13 @@ private void reportCycle(
      * really broken.
      */
     private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
-      DependencyRequest lastDependencyRequest = cycle.get(0);
-      for (DependencyRequest dependencyRequest : skip(cycle, 1)) {
+      for (int i = 1; i < cycle.size(); i++) {
+        DependencyRequest dependencyRequest = cycle.get(i);
         switch (dependencyRequest.kind()) {
           case PROVIDER:
-            if (!isImplicitProviderMapForValueMap(dependencyRequest, lastDependencyRequest)) {
+            if (isImplicitProviderMapForValueMap(dependencyRequest, cycle.get(i - 1))) {
+              i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
+            } else {
               return true;
             }
             break;
@@ -1035,7 +1035,6 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
           default:
             break;
         }
-        lastDependencyRequest = dependencyRequest;
       }
       return false;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 0bb43f65a..626308d79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,6 +16,8 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
@@ -28,10 +30,21 @@ static CodeBlock format(String format, Object... args) {
     return CodeBlock.builder().add(format, args).build();
   }
 
+  /**
+   * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.
+   */
   static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return join(codeBlocks, ", ");
   }
 
+  /**
+   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
+   * newline.
+   */
+  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
+    return join(codeBlocks, "\n");
+  }
+
   static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     CodeBlock.Builder builder = CodeBlock.builder();
     Iterator<CodeBlock> iterator = codeBlocks.iterator();
@@ -44,7 +57,19 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     return builder.build();
   }
 
-  static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
+  static CodeBlock nullCheck(String thingToCheck) {
+    return format("if ($L == null) { throw new NullPointerException(); } ", thingToCheck);
+  }
+
+  static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
+    return FluentIterable.from(typeMirrors).transform(TYPE_MIRROR_TO_CODE_BLOCK);
+  }
+
+  static CodeBlock stringLiteral(String toWrap) {
+    return format("$S", toWrap);
+  }
+
+  private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
       new Function<TypeMirror, CodeBlock>() {
         @Override
         public CodeBlock apply(TypeMirror typeMirror) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 379a60236..2b47e3baa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,11 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Component;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
@@ -32,7 +32,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends JavaWriterSourceFileGenerator<BindingGraph> {
+final class ComponentGenerator extends JavaPoetSourceFileGenerator<BindingGraph> {
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
@@ -54,14 +54,10 @@
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
-        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
-    String componentName = "Dagger" + componentDefinitionClassName.classFileName('_');
-    return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(BindingGraph input) {
-    return ImmutableSet.of(input.componentDescriptor().componentDefinitionType());
+        ClassName.get(input.componentDescriptor().componentDefinitionType());
+    String componentName =
+        "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
+    return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
   }
 
   @Override
@@ -70,9 +66,10 @@ ClassName nameGeneratedType(BindingGraph input) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    return new ComponentWriter(
-            types, elements, keyFactory, nullableValidationType, componentName, input)
-        .write();
+  Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
+    return Optional.of(
+        new ComponentWriter(
+                types, elements, keyFactory, nullableValidationType, componentName, input)
+            .write());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 3a09e8cba..f9318a106 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
@@ -22,11 +23,13 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.Map;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
 import static com.google.common.base.Functions.constant;
+import static java.util.Arrays.asList;
 
 /**
  * Validates the relationships between parent components and subcomponents.
@@ -42,7 +45,7 @@
 
   private ValidationReport<TypeElement> validateSubcomponentMethods(
       ComponentDescriptor componentDescriptor,
-      Map<TypeElement, TypeElement> existingModuleToOwners) {
+      ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
     ValidationReport.Builder<TypeElement> reportBuilder =
         ValidationReport.about(componentDescriptor.componentDefinitionType());
     for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
@@ -55,17 +58,17 @@
         case PRODUCTION_SUBCOMPONENT:
           for (VariableElement factoryMethodParameter :
               subcomponentMethodDescriptor.methodElement().getParameters()) {
-            TypeElement origininatingComponent =
-                existingModuleToOwners.get(
-                    MoreTypes.asTypeElement(factoryMethodParameter.asType()));
-            if (origininatingComponent != null) {
+            TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
+            TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
+            if (originatingComponent != null) {
               /* Factory method tries to pass a module that is already present in the parent.
                * This is an error. */
               reportBuilder.addError(
                   String.format(
-                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                      "%s is present in %s. A subcomponent cannot use an instance of a "
                           + "module that differs from its parent.",
-                      origininatingComponent.getQualifiedName()),
+                      moduleType.getSimpleName(),
+                      originatingComponent.getQualifiedName()),
                   factoryMethodParameter);
             }
           }
@@ -75,23 +78,32 @@
           BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
           for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
               subcomponentBuilderSpec.methodMap().entrySet()) {
-            TypeElement origininatingComponent =
-                existingModuleToOwners.get(builderMethodEntry.getKey());
-            if (origininatingComponent != null) {
-              /* A subcomponent builder allows you to pass a module that is already present in the
-               * parent.  This can't be an error because it might be valid in _other_ components, so
-               * we warn here. */
-              ExecutableElement builderMethodElement = builderMethodEntry.getValue();
+            TypeElement moduleType = builderMethodEntry.getKey();
+            TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
+            /* A subcomponent builder allows you to pass a module that is already present in the
+             * parent.  This can't be an error because it might be valid in _other_ components, so
+             * we warn here, unless the warning is suppressed on the subcomponent method or the
+             * builder method. */
+            ExecutableElement builderMethodElement = builderMethodEntry.getValue();
+            if (originatingComponent != null
+                && !repeatedModuleWarningsSuppressed(subcomponentMethodDescriptor.methodElement())
+                && !repeatedModuleWarningsSuppressed(builderMethodElement)) {
               /* TODO(gak): consider putting this on the builder method directly if it's in the
                * component being compiled */
               reportBuilder.addWarning(
                   String.format(
-                      "This module is present in %s. Subcomponents cannot use an instance of a "
-                          + "module that differs from its parent. The implementation of %s "
-                          + "in this component will throw %s.",
-                      origininatingComponent.getQualifiedName(),
+                      "%1$s is installed in %2$s. A subcomponent cannot use an instance of a "
+                          + "module that differs from its parent. The implementation of %4$s "
+                          + "in %5$s will throw %6$s. To suppress this warning, annotate "
+                          + "either %4$s, %3$s, %5$s.%7$s, or %5$s with "
+                          + "@SuppressWarnings(\"repeated-module\").",
+                      moduleType.getSimpleName(),
+                      originatingComponent.getQualifiedName(),
+                      subcomponentBuilderSpec.builderDefinitionType().getQualifiedName(),
                       builderMethodElement.getSimpleName(),
-                      UnsupportedOperationException.class.getSimpleName()),
+                      componentDescriptor.componentDefinitionType().getQualifiedName(),
+                      UnsupportedOperationException.class.getSimpleName(),
+                      subcomponentMethodDescriptor.methodElement().getSimpleName()),
                   builderMethodElement);
             }
           }
@@ -114,4 +126,19 @@
     }
     return reportBuilder.build();
   }
+
+  private boolean repeatedModuleWarningsSuppressed(Element element) {
+    while (true) {
+      // TODO(dpb): Extract a method to check whether a warning is suppressed on an element.
+      SuppressWarnings suppressWarnings = element.getAnnotation(SuppressWarnings.class);
+      if (suppressWarnings != null
+          && asList(suppressWarnings.value()).contains("repeated-module")) {
+        return true;
+      }
+      if (MoreElements.isType(element)) {
+        return false;
+      }
+      element = element.getEnclosingElement();
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index d67214d68..e66907977 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -78,7 +78,7 @@ public SourceVersion getSupportedSourceVersion() {
     HasSourceElementFormatter hasSourceElementFormatter =
         new HasSourceElementFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
-    KeyFormatter keyFormatter = new KeyFormatter();
+    KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator(
@@ -107,15 +107,12 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
 
-    this.factoryGenerator =
-        new FactoryGenerator(
-            filer, elements, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
-    this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, DependencyRequestMapper.FOR_PROVIDER);
+    this.factoryGenerator = new FactoryGenerator(filer, elements, nullableDiagnosticType);
+    this.membersInjectorGenerator = new MembersInjectorGenerator(filer, elements);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements, DependencyRequestMapper.FOR_PRODUCER);
+        new ProducerFactoryGenerator(filer, elements);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index aeab5a746..6a7750fa2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -23,22 +23,23 @@
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import javax.annotation.Generated;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -142,58 +143,55 @@ public String apply(ComponentDescriptor componentDescriptor) {
   }
 
   @Override
-  protected ClassWriter createComponentClass() {
-    JavaWriter javaWriter = JavaWriter.inPackage(name.packageName());
-    javaWriters.add(javaWriter);
-
-    ClassWriter componentWriter = javaWriter.addClass(name.simpleName());
-    componentWriter.addModifiers(PUBLIC, FINAL);
-    componentWriter.setSupertype(componentDefinitionType());
-    return componentWriter;
+  protected TypeSpec.Builder createComponentClass() {
+    TypeSpec.Builder component = classBuilder(name.simpleName()).addModifiers(PUBLIC, FINAL);
+    addSupertype(component, componentDefinitionType());
+    return component;
   }
 
   @Override
-  protected ClassWriter createBuilder() {
-    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
-    builderWriter.addModifiers(STATIC);
+  protected ClassName builderName() {
+    return name.nestedClass("Builder");
+  }
+
+  @Override
+  protected TypeSpec.Builder createBuilder(String builderSimpleName) {
+    TypeSpec.Builder builder = classBuilder(builderSimpleName).addModifiers(STATIC);
 
     // Only top-level components have the factory builder() method.
     // Mirror the user's builder API type if they had one.
-    MethodWriter builderFactoryMethod =
-        graph.componentDescriptor().builderSpec().isPresent()
-            ? componentWriter.addMethod(
-                graph
-                    .componentDescriptor()
-                    .builderSpec()
-                    .get()
-                    .builderDefinitionType()
-                    .asType(),
-                "builder")
-            : componentWriter.addMethod(builderWriter, "builder");
-    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
-    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
-    return builderWriter;
+    MethodSpec builderFactoryMethod =
+        methodBuilder("builder")
+            .addModifiers(PUBLIC, STATIC)
+            .returns(
+                graph.componentDescriptor().builderSpec().isPresent()
+                    ? ClassName.get(
+                        graph.componentDescriptor().builderSpec().get().builderDefinitionType())
+                    : builderName.get())
+            .addStatement("return new $T()", builderName.get())
+            .build();
+    component.addMethod(builderFactoryMethod);
+    return builder;
+  }
+
+  @Override
+  protected void addBuilderClass(TypeSpec builder) {
+    component.addType(builder);
   }
 
   @Override
   protected void addFactoryMethods() {
     if (canInstantiateAllRequirements()) {
-      MethodWriter factoryMethod =
-          componentWriter.addMethod(componentDefinitionTypeName(), "create");
-      factoryMethod.addModifiers(PUBLIC, STATIC);
-      // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod
-          .body()
-          .addSnippet(
-              "return builder().%s();",
-              graph.componentDescriptor().builderSpec().isPresent()
-                  ? graph
-                      .componentDescriptor()
-                      .builderSpec()
-                      .get()
-                      .buildMethod()
-                      .getSimpleName()
-                  : "build");
+      CharSequence buildMethodName =
+          graph.componentDescriptor().builderSpec().isPresent()
+              ? graph.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
+              : "build";
+      component.addMethod(
+          methodBuilder("create")
+              .returns(componentDefinitionTypeName())
+              .addModifiers(PUBLIC, STATIC)
+              .addStatement("return builder().$L()", buildMethodName)
+              .build());
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index dbe84067d..71cb38afd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -21,6 +21,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
@@ -38,6 +39,8 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -61,7 +64,7 @@
       return Sets.union(membersInjectionRequest().asSet(), dependencies());
     }
   }
-  
+
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -80,9 +83,20 @@
    * implicitly by the framework.
    */
   boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_MAP);
+    return IS_SYNTHETIC_KIND.apply(bindingKind());
   }
 
+  /**
+   * A function that returns the kind of a binding.
+   */
+  static final Function<ContributionBinding, Kind> KIND =
+      new Function<ContributionBinding, Kind>() {
+        @Override
+        public Kind apply(ContributionBinding binding) {
+          return binding.bindingKind();
+        }
+      };
+
   /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> membersInjectionRequest();
 
@@ -97,6 +111,18 @@ boolean isSyntheticBinding() {
      */
     SYNTHETIC_MAP,
 
+    /**
+     * A synthetic binding for a multibound set that depends on the individual multibinding
+     * {@link Provides @Provides} or {@link Produces @Produces} methods.
+     */
+    SYNTHETIC_MULTIBOUND_SET,
+
+    /**
+     * A synthetic binding for a multibound map that depends on the individual multibinding
+     * {@link Provides @Provides} or {@link Produces @Produces} methods.
+     */
+    SYNTHETIC_MULTIBOUND_MAP,
+
     // Provision kinds
 
     /** An {@link Inject}-annotated constructor. */
@@ -131,6 +157,36 @@ boolean isSyntheticBinding() {
      * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
      */
     COMPONENT_PRODUCTION,
+    ;
+
+    /**
+     * A predicate that tests whether a kind is for synthetic bindings.
+     */
+    static final Predicate<Kind> IS_SYNTHETIC_KIND =
+        Predicates.in(
+            immutableEnumSet(SYNTHETIC_MAP, SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+
+    /**
+     * A predicate that tests whether a kind is for synthetic multibindings.
+     */
+    static final Predicate<Kind> IS_SYNTHETIC_MULTIBINDING_KIND =
+        Predicates.in(immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+
+    /**
+     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the
+     * request's key.
+     */
+    static Kind forMultibindingRequest(DependencyRequest request) {
+      Key key = request.key();
+      if (SetType.isSet(key.type())) {
+        return SYNTHETIC_MULTIBOUND_SET;
+      } else if (MapType.isMap(key.type())) {
+        return SYNTHETIC_MULTIBOUND_MAP;
+      } else {
+        throw new IllegalArgumentException(
+            String.format("request is not for a set or map: %s", request));
+      }
+    }
   }
 
   /**
@@ -141,12 +197,8 @@ boolean isSyntheticBinding() {
   /**
    * A predicate that passes for bindings of a given kind.
    */
-  static Predicate<ContributionBinding> isOfKind(final Kind kind) {
-    return new Predicate<ContributionBinding>() {
-      @Override
-      public boolean apply(ContributionBinding binding) {
-        return binding.bindingKind().equals(kind);
-      }};
+  static Predicate<ContributionBinding> isOfKind(Kind kind) {
+    return Predicates.compose(Predicates.equalTo(kind), KIND);
   }
 
   /** The provision type that was used to bind the key. */
@@ -180,10 +232,12 @@ FactoryCreationStrategy factoryCreationStrategy() {
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 
       case INJECTION:
+      case SYNTHETIC_MULTIBOUND_SET:
+      case SYNTHETIC_MULTIBOUND_MAP:
         return implicitDependencies().isEmpty()
             ? FactoryCreationStrategy.ENUM_INSTANCE
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-
+        
       default:
         return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 453215667..f0a726a91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -201,6 +201,42 @@ DependencyRequest forImplicitMapBinding(
           Optional.<String>absent());
     }
 
+    /**
+     * Creates a dependency request, with the same element as {@code request}, for one individual
+     * {@code multibindingContribution}.
+     */
+    DependencyRequest forMultibindingContribution(
+        DependencyRequest request, ContributionBinding multibindingContribution) {
+      checkArgument(
+          multibindingContribution.contributionType().isMultibinding(),
+          "multibindingContribution must be a multibinding: %s",
+          multibindingContribution);
+      checkArgument(
+          multibindingContribution.key().bindingMethod().isPresent(),
+          "multibindingContribution's key must have a binding method identifier: %s",
+          multibindingContribution);
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          multibindingContribution.key(),
+          request.requestElement(),
+          request.enclosingType(),
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
+    /**
+     * Creates dependency requests, with the same element as {@code request}, for each individual
+     * multibinding contribution in {@code multibindingContributions}.
+     */
+    ImmutableSet<DependencyRequest> forMultibindingContributions(
+        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
+      for (ContributionBinding multibindingContribution : multibindingContributions) {
+        requests.add(forMultibindingContribution(request, multibindingContribution));
+      }
+      return requests.build();
+    }
+
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return forRequiredVariable(variableElement, Optional.<String>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index 1dc48fc8b..9ca294206 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -94,4 +94,8 @@
   }
 
   static final DependencyRequestMapper FOR_PRODUCER = new MapperForProducer();
+
+  static DependencyRequestMapper forBindingType(BindingType bindingType) {
+    return bindingType.equals(BindingType.PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 41406f80c..2077864d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -195,9 +195,6 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_CONTRIBUTION_TYPES_FORMAT =
-      "More than one binding present of different types %s";
-
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
       "%s has incompatible bindings or declarations:\n";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 8b548c0db..94ec0e5af 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -30,7 +30,6 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
-import dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -49,17 +48,17 @@
 import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.TypeNames.factoryOf;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.TypeNames.factoryOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -74,22 +73,19 @@
  */
 final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
 
-  private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
   FactoryGenerator(
       Filer filer,
       Elements elements,
-      DependencyRequestMapper dependencyRequestMapper,
       Diagnostic.Kind nullableValidationType) {
     super(filer, elements);
-    this.dependencyRequestMapper = dependencyRequestMapper;
     this.nullableValidationType = nullableValidationType;
   }
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    return javapoetGeneratedClassNameForBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -112,8 +108,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     TypeSpec.Builder factoryBuilder;
     Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+    ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
     boolean useRawType =
         binding.factoryCreationStrategy() == ENUM_INSTANCE
             && binding.bindingKind() == INJECTION
@@ -146,7 +141,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         }
         for (FrameworkField bindingField : fields.values()) {
           addConstructorParameterAndTypeField(
-              bindingField.javapoetFrameworkType(),
+              bindingField.frameworkType(),
               bindingField.name(),
               factoryBuilder,
               constructorBuilder.get());
@@ -196,7 +191,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           case CLASS_CONSTRUCTOR:
             createMethodBuilder.addStatement(
                 "return new $T($L)",
-                javapoetParameterizedGeneratedTypeNameForBinding(binding),
+                parameterizedGeneratedTypeNameForBinding(binding),
                 makeParametersCodeBlock(
                     Lists.transform(params, CodeBlocks.PARAMETER_NAME)));
             break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
new file mode 100644
index 000000000..57851cbf0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Maps;
+import java.util.Collection;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+/**
+ * The framework class and binding key for a resolved dependency of a binding. If a binding has
+ * several dependencies for a key, then only one instance of this class will represent them all.
+ *
+ * <p>In the following example, the binding {@code provideFoo()} has two dependency requests:
+ *
+ * <ol>
+ * <li>{@code Bar bar}
+ * <li>{@code Provider<Bar> barProvider}
+ * </ol>
+ *
+ * But they both can be satisfied with the same instance of {@code Provider<Bar>}. So one instance
+ * of {@code FrameworkDependency} will be used for both. Its {@link #bindingKey()} will be for
+ * {@code Bar}, and its {@link #frameworkClass()} will be {@link Provider}.
+ *
+ * <pre><code>
+ *   {@literal @Provides} static Foo provideFoo(Bar bar, {@literal Provider<Bar>} barProvider) {
+ *     return new Foo();
+ *   }
+ * </code></pre>
+ */
+@AutoValue
+abstract class FrameworkDependency {
+
+  /**
+   * The fully-resolved binding key shared by all the dependency requests.
+   */
+  abstract BindingKey bindingKey();
+
+  /**
+   * The framework class to use for these requests.
+   */
+  abstract Class<?> frameworkClass();
+
+  /**
+   * The dependency requests that are all satisfied by one framework instance.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencyRequests();
+
+  /**
+   * The framework dependencies of {@code binding}. There will be one element for each
+   * different binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of
+   * {@code binding}.
+   *
+   * <p>For example, given the following modules:
+   * <pre><code>
+   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
+   *     {@literal @Provides} Foo provideFoo(T t, String string) {
+   *       return ;
+   *     }
+   *   }
+   *
+   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
+   * </code></pre>
+   *
+   * Both dependencies of {@code StringModule.provideFoo} have the same binding key:
+   * {@code String}. But there are still two dependencies, because in the unresolved binding they
+   * have different binding keys:
+   *
+   * <dl>
+   * <dt>{@code T} <dd>{@code String t}
+   * <dt>{@code String} <dd>{@code String string}
+   * </dl>
+   * 
+   * <p>Note that the sets returned by this method when called on the same binding will be equal,
+   * and their elements will be in the same order.
+   */
+  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
+   * instances of Binding, because it really depends on the order of the binding's dependencies,
+   * and two equal instances of Binding may have the same dependencies in a different order. */
+  static ImmutableSet<FrameworkDependency> frameworkDependenciesForBinding(Binding binding) {
+    DependencyRequestMapper dependencyRequestMapper =
+        DependencyRequestMapper.forBindingType(binding.bindingType());
+    ImmutableSet.Builder<FrameworkDependency> frameworkDependencies = ImmutableSet.builder();
+    for (Collection<DependencyRequest> requests : groupByUnresolvedKey(binding)) {
+      frameworkDependencies.add(
+          new AutoValue_FrameworkDependency(
+              getOnlyElement(
+                  FluentIterable.from(requests)
+                      .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                      .toSet()),
+              dependencyRequestMapper.getFrameworkClass(requests),
+              ImmutableSet.copyOf(requests)));
+    }
+    return frameworkDependencies.build();
+  }
+
+  /**
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   */
+  private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
+      Binding binding) {
+    // If the binding has no unresolved version, just group the dependencies by binding key.
+    if (!binding.unresolved().isPresent()) {
+      return groupByKey(binding, Functions.<DependencyRequest>identity());
+    }
+
+    // Group the unresolved dependencies, replacing each one with its resolved version by looking it
+    // up by request element.
+    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
+        Maps.uniqueIndex(
+            binding.implicitDependencies(),
+            new Function<DependencyRequest, Element>() {
+              @Override
+              public Element apply(DependencyRequest dependencyRequest) {
+                return dependencyRequest.requestElement();
+              }
+            });
+    return groupByKey(
+        binding.unresolved().get(),
+        new Function<DependencyRequest, DependencyRequest>() {
+          @Override
+          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
+            return resolvedDependencies.get(unresolvedRequest.requestElement());
+          }
+        });
+  }
+
+  /**
+   * Groups a binding's dependency requests by their binding key.
+   *
+   * @param transformer applied to each dependency before inserting into the group
+   */
+  private static ImmutableList<Collection<DependencyRequest>> groupByKey(
+      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : binding.implicitDependencies()) {
+      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
+    }
+    return ImmutableList.copyOf(
+        dependenciesByKeyBuilder
+            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
+            .build()
+            .asMap()
+            .values());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index baad3b393..d8d2e37d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,19 +15,19 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeNames;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
-
 /**
  * A value object that represents a field used by Dagger-generated code.
  *
@@ -40,86 +40,66 @@
   static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, String name) {
     String suffix = frameworkClass.getSimpleName();
     ParameterizedTypeName frameworkType =
-        ParameterizedTypeName.create(
-            ClassName.fromClass(frameworkClass), TypeNames.forTypeMirror(key.type()));
-    com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType =
-        com.squareup.javapoet.ParameterizedTypeName.get(
-            com.squareup.javapoet.ClassName.get(frameworkClass),
-            com.squareup.javapoet.TypeName.get(key.type()));
+        ParameterizedTypeName.get(ClassName.get(frameworkClass), TypeName.get(key.type()));
     return new AutoValue_FrameworkField(
-        javapoetFrameworkType, frameworkType, name.endsWith(suffix) ? name : name + suffix);
+        frameworkType, name.endsWith(suffix) ? name : name + suffix);
   }
 
   private static FrameworkField createForMapBindingContribution(Key key, String name) {
     TypeMirror type = MapType.from(key.type()).valueType();
+    String suffix = MoreTypes.asDeclared(type).asElement().getSimpleName().toString();
     return new AutoValue_FrameworkField(
-        (com.squareup.javapoet.ParameterizedTypeName) com.squareup.javapoet.TypeName.get(type),
-        (ParameterizedTypeName) TypeNames.forTypeMirror(type),
-        name);
-  }
-
-  static FrameworkField createForSyntheticContributionBinding(
-      int contributionNumber, ContributionBinding contributionBinding) {
-    switch (contributionBinding.contributionType()) {
-      case MAP:
-        return createForMapBindingContribution(
-            contributionBinding.key(),
-            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
-                + "Contribution"
-                + contributionNumber);
-
-      case SET:
-      case UNIQUE:
-        return createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            contributionBinding.key(),
-            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
-                + "Contribution"
-                + contributionNumber);
-      default:
-        throw new AssertionError();
-    }
+        (ParameterizedTypeName) TypeName.get(type),
+        name.endsWith(suffix) ? name : name + suffix);
   }
 
   static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
-    return createWithTypeFromKey(
-        resolvedBindings.frameworkClass(),
-        resolvedBindings.bindingKey().key(),
-        frameworkFieldName(resolvedBindings));
+    if (resolvedBindings.isMultibindingContribution()
+        && resolvedBindings.contributionType().equals(ContributionType.MAP)) {
+      return createForMapBindingContribution(
+          resolvedBindings.key(), frameworkFieldName(resolvedBindings));
+    } else {
+      return createWithTypeFromKey(
+          resolvedBindings.frameworkClass(),
+          resolvedBindings.key(),
+          frameworkFieldName(resolvedBindings));
+    }
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && resolvedBindings.contributionType().equals(ContributionType.UNIQUE)) {
-      ContributionBinding binding = getOnlyElement(resolvedBindings.contributionBindings());
-      if (!binding.bindingKind().equals(ContributionBinding.Kind.SYNTHETIC_MAP)) {
-        return BINDING_ELEMENT_NAME.visit(binding.bindingElement());
+    if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+      ContributionBinding binding = resolvedBindings.contributionBinding();
+      if (!binding.isSyntheticBinding()) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
       }
     }
-    return KeyVariableNamer.INSTANCE.apply(bindingKey.key());
+    return KeyVariableNamer.INSTANCE.apply(resolvedBindings.key());
   }
 
-  private static final ElementVisitor<String, Void> BINDING_ELEMENT_NAME =
-      new ElementKindVisitor6<String, Void>() {
+  private static final ElementVisitor<String, Binding> BINDING_ELEMENT_NAME =
+      new ElementKindVisitor6<String, Binding>() {
+
+        @Override
+        protected String defaultAction(Element e, Binding p) {
+          throw new IllegalArgumentException("Unexpected binding " + p);
+        }
+
         @Override
-        public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-          return visit(e.getEnclosingElement());
+        public String visitExecutableAsConstructor(ExecutableElement e, Binding p) {
+          return visit(e.getEnclosingElement(), p);
         }
 
         @Override
-        public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+        public String visitExecutableAsMethod(ExecutableElement e, Binding p) {
           return e.getSimpleName().toString();
         }
 
         @Override
-        public String visitType(TypeElement e, Void p) {
-          return CaseFormat.UPPER_CAMEL.to(
-              CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());
+        public String visitType(TypeElement e, Binding p) {
+          return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());
         }
       };
 
-  abstract com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType();
   abstract ParameterizedTypeName frameworkType();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index ee92a0db3..59726f214 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -24,9 +24,9 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Provides;
-import dagger.internal.codegen.writer.ClassName;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Map;
@@ -72,7 +72,8 @@
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
     private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
 
-    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
+    void generateBindings(JavaPoetSourceFileGenerator<B> generator)
+        throws SourceFileGenerationException {
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
@@ -115,10 +116,9 @@ void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
       return !binding.unresolved().isPresent()
-          && elements.getTypeElement(factoryName.canonicalName()) == null
+          && elements.getTypeElement(factoryName.toString()) == null
           && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
-
     }
 
     /** Caches the binding for future lookups by key. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
index 745fe7b79..0c7da456c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
@@ -41,12 +41,9 @@
  * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
  * fail to write successfully are deleted.
  *
- * <p>This differs from {@link JavaWriterSourceFileGenerator} only in that it uses JavaPoet for
- * constructing the source code model. It is intended for this to take on all usages of JavaWriter.
- *
  * @param <T> The input type from which source is to be generated.
  */
-abstract class JavaPoetSourceFileGenerator<T> implements SourceFileGenerator<T> {
+abstract class JavaPoetSourceFileGenerator<T> {
   private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
 
   private static final AnnotationSpec GENERATED =
@@ -63,8 +60,8 @@
     generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
   }
 
-  @Override
-  public final void generate(T input) throws SourceFileGenerationException {
+  /** Generates a source file to be compiled for {@code T}. */
+  void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     try {
       Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
deleted file mode 100644
index e43b1a5c5..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.TypeWriter;
-import java.io.IOException;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A template class that provides a framework for properly handling IO while generating source files
- * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
- * fail to write successfully are deleted.
- *
- * @param <T> The input type from which source is to be generated.
- * @author Gregory Kick
- * @since 2.0
- */
-abstract class JavaWriterSourceFileGenerator<T> implements SourceFileGenerator<T> {
-  private final Filer filer;
-  private final boolean generatedAnnotationAvailable;
-
-  JavaWriterSourceFileGenerator(Filer filer, Elements elements) {
-    this.filer = checkNotNull(filer);
-    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
-  }
-
-  @Override
-  public final void generate(T input) throws SourceFileGenerationException {
-    ClassName generatedTypeName = nameGeneratedType(input);
-    ImmutableSet<Element> originatingElements =
-        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
-    try {
-      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
-      for (JavaWriter javaWriter : writers) {
-        javaWriter.markGenerated(generatedAnnotationAvailable);
-        try {
-          javaWriter.file(filer, originatingElements);
-        } catch (IOException e) {
-          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
-              e, getElementForErrorReporting(input));
-        }
-      }
-    } catch (Exception e) {
-      // if the code above threw a SFGE, use that
-      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
-      // otherwise, throw a new one
-      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
-          getElementForErrorReporting(input));
-    }
-  }
-
-  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
-    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
-      @Override public ClassName apply(TypeWriter input) {
-        return input.name();
-      }
-    });
-  }
-
-  /**
-   * Implementations should return the {@link ClassName} for the top-level type to be generated.
-   */
-  abstract ClassName nameGeneratedType(T input);
-
-  /**
-   * Implementations should return {@link Element} instances from which the source is to be
-   * generated.
-   */
-  abstract Iterable<? extends Element> getOriginatingElements(T input);
-
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
-
-  /**
-   * Returns a set of writers to be generated for {@code T} input.
-   */
-  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 77a92ed3a..af635fcba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -91,11 +91,28 @@
    * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+  
+  /**
+   * For multibinding contributions, this is the binding method element. Each multibound map and set
+   * is represented by a
+   * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
+   * synthetic binding} that depends on the specific contributions to that map or set. Each such
+   * contribution binding therefore needs a key that identifies the specific binding, and not only
+   * the qualified type that is bound.
+   */
+  abstract Optional<SourceElement> bindingMethod();
 
+  /**
+   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
+   * for the type of this key.
+   */
   Optional<AnnotationMirror> qualifier() {
     return unwrapOptionalEquivalence(wrappedQualifier());
   }
 
+  /**
+   * The type represented by this key.
+   */
   TypeMirror type() {
     return wrappedType().get();
   }
@@ -105,9 +122,31 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
     return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
   }
 
-  Key withType(Types types, TypeMirror newType) {
-    return new AutoValue_Key(wrappedQualifier(),
-        MoreTypes.equivalence().wrap(normalize(types, newType)));
+  /**
+   * A key whose {@link #qualifier()} and {@link #bindingMethod()} are equivalent to this one's, but
+   * with {@code newType} (normalized) as its {@link #type()}.
+   */
+  private Key withType(Types types, TypeMirror newType) {
+    return new AutoValue_Key(
+        wrappedQualifier(),
+        MoreTypes.equivalence().wrap(normalize(types, newType)),
+        bindingMethod());
+  }
+
+  /**
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but
+   * with {@code bindingMethod} as its {@link #bindingMethod()}.
+   */
+  private Key withBindingMethod(SourceElement bindingMethod) {
+    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.of(bindingMethod));
+  }
+
+  /**
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
+   * absent {@link #bindingMethod()}.
+   */
+  Key withoutBindingMethod() {
+    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.<SourceElement>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -162,6 +201,7 @@ public String toString() {
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
+        .add("bindingMethod", bindingMethod().orNull())
         .toString();
   }
 
@@ -258,29 +298,36 @@ Key forSubcomponentBuilderMethod(
       return forMethod(subcomponentBuilderMethod, returnType);
     }
 
-    Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
-      checkNotNull(method);
-      checkArgument(method.getKind().equals(METHOD));
+    Key forProvidesMethod(SourceElement sourceElement) {
+      checkArgument(sourceElement.element().getKind().equals(METHOD));
+      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       Provides providesAnnotation = method.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
       TypeMirror keyType =
           providesOrProducesKeyType(
               returnType,
               method,
               Optional.of(providesAnnotation.type()),
               Optional.<Produces.Type>absent());
-      return forMethod(method, keyType);
+      Key key = forMethod(method, keyType);
+      return providesAnnotation.type().equals(Provides.Type.UNIQUE)
+          ? key
+          : key.withBindingMethod(sourceElement);
     }
 
     // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
-    Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
-      checkNotNull(method);
-      checkArgument(method.getKind().equals(METHOD));
+    Key forProducesMethod(SourceElement sourceElement) {
+      checkArgument(sourceElement.element().getKind().equals(METHOD));
+      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       Produces producesAnnotation = method.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
       TypeMirror unfuturedType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         unfuturedType =
@@ -292,7 +339,10 @@ Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
               method,
               Optional.<Provides.Type>absent(),
               Optional.of(producesAnnotation.type()));
-      return forMethod(method, keyType);
+      Key key = forMethod(method, keyType);
+      return producesAnnotation.type().equals(Produces.Type.UNIQUE)
+          ? key
+          : key.withBindingMethod(sourceElement);
     }
     
     /**
@@ -362,31 +412,36 @@ private TypeMirror mapKeyType(ExecutableElement method) {
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
-          MoreTypes.equivalence().wrap(keyType));
+          MoreTypes.equivalence().wrap(keyType),
+          Optional.<SourceElement>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(type));
+          MoreTypes.equivalence().wrap(type),
+          Optional.<SourceElement>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)),
+          Optional.<SourceElement>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)),
+          Optional.<SourceElement>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
-          MoreTypes.equivalence().wrap(normalize(types, type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)),
+          Optional.<SourceElement>absent());
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index 6e695f33a..a670c1bae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -15,21 +15,38 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+
 /**
- * Formats a {@link Key} into a {@link String} suitable for use in error messages
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages and JSON keys.
  *
  * @author Christian Gruber
  * @since 2.0
  */
 final class KeyFormatter extends Formatter<Key> {
+  
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  KeyFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
 
   @Override public String format(Key request) {
+    if (request.bindingMethod().isPresent()) {
+      // If there's a binding method, its signature is enough.
+      SourceElement bindingMethod = request.bindingMethod().get();
+      return methodSignatureFormatter.format(
+          MoreElements.asExecutable(bindingMethod.element()),
+          Optional.of(MoreTypes.asDeclared(bindingMethod.contributedBy().get().asType())));
+    }
     StringBuilder builder = new StringBuilder();
     if (request.qualifier().isPresent()) {
       builder.append(request.qualifier().get());
       builder.append(' ');
     }
-    builder.append(request.type()); // TODO(cgruber): Use TypeMirrorFormatter.
+    builder.append(request.type());
     return builder.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 423d62615..e831ef296 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -41,7 +41,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MapKeys.getJavapoetMapKeyCreatorClassName;
+import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -95,7 +95,7 @@ static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
 
   @Override
   ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return getJavapoetMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
+    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 3bfd46916..5be196420 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -20,11 +20,10 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
@@ -48,12 +47,12 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.transform;
-import static dagger.internal.codegen.SourceFiles.classFileName;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.canonicalName;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * Methods for extracting {@link MapKey} annotations and key snippets from binding elements.
+ * Methods for extracting {@link MapKey} annotations and key code blocks from binding elements.
  */
 final class MapKeys {
 
@@ -133,28 +132,17 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
     return keyTypeElementVisitor.visit(onlyElement.getReturnType());
   }
 
-  /**
-   * Returns the name of the generated class that contains the static {@code create} methods for a
-   * {@link MapKey} annotation type.
-   */
-  public static com.squareup.javapoet.ClassName getJavapoetMapKeyCreatorClassName(
-      TypeElement mapKeyType) {
-    com.squareup.javapoet.ClassName mapKeyTypeName =
-        com.squareup.javapoet.ClassName.get(mapKeyType);
-    return mapKeyTypeName.topLevelClassName().peerClass(classFileName(mapKeyTypeName) + "Creator");
-  }
-
   /**
    * Returns the name of the generated class that contains the static {@code create} methods for a
    * {@link MapKey} annotation type.
    */
   public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName mapKeyTypeName = ClassName.fromTypeElement(mapKeyType);
-    return mapKeyTypeName.topLevelClassName().peerNamed(mapKeyTypeName.classFileName() + "Creator");
+    ClassName mapKeyTypeName = ClassName.get(mapKeyType);
+    return mapKeyTypeName.topLevelClassName().peerClass(canonicalName(mapKeyTypeName) + "Creator");
   }
 
   /**
-   * Returns a snippet for the map key specified by the {@link MapKey} annotation on
+   * Returns a code block for the map key specified by the {@link MapKey} annotation on
    * {@code bindingElement}.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
@@ -162,22 +150,22 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  static Snippet getMapKeySnippet(Element bindingElement) {
+  static CodeBlock getMapKeyExpression(Element bindingElement) {
     AnnotationMirror mapKey = getMapKey(bindingElement).get();
     ClassName mapKeyCreator =
         getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     if (unwrappedValue.isPresent()) {
-      return new MapKeySnippetExceptArrays(mapKeyCreator)
+      return new MapKeyExpressionExceptArrays(mapKeyCreator)
           .visit(unwrappedValue.get(), unwrappedValue.get());
     } else {
-      return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
+      return annotationExpression(mapKey, new MapKeyExpression(mapKeyCreator));
     }
   }
 
   /**
-   * Returns a snippet to create the visited value in code. Expects its parameter to be a class with
-   * static creation methods for all nested annotation types.
+   * Returns a code block to create the visited value in code. Expects its parameter to be a class
+   * with static creation methods for all nested annotation types.
    *
    * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
    * <em>when used in an annotation</em>, which is not always the same as the representation needed
@@ -186,141 +174,141 @@ static Snippet getMapKeySnippet(Element bindingElement) {
    * <p>For example, inside an annotation, a nested array of {@code int}s is simply
    * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
    */
-  private static class MapKeySnippet
-      extends SimpleAnnotationValueVisitor6<Snippet, AnnotationValue> {
+  private static class MapKeyExpression
+      extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
 
     final ClassName mapKeyCreator;
 
-    MapKeySnippet(ClassName mapKeyCreator) {
+    MapKeyExpression(ClassName mapKeyCreator) {
       this.mapKeyCreator = mapKeyCreator;
     }
 
     @Override
-    public Snippet visitEnumConstant(VariableElement c, AnnotationValue p) {
-      return Snippet.format(
-          "%s.%s", TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+    public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
+      return CodeBlocks.format(
+          "$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
     }
 
     @Override
-    public Snippet visitAnnotation(AnnotationMirror a, AnnotationValue p) {
-      return annotationSnippet(a, this);
+    public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+      return annotationExpression(a, this);
     }
 
     @Override
-    public Snippet visitType(TypeMirror t, AnnotationValue p) {
-      return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
+    public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
+      return CodeBlocks.format("$T.class", TypeName.get(t));
     }
 
     @Override
-    public Snippet visitString(String s, AnnotationValue p) {
-      return Snippet.format("%s", p);
+    public CodeBlock visitString(String s, AnnotationValue p) {
+      return CodeBlocks.format("$S", s);
     }
 
     @Override
-    public Snippet visitByte(byte b, AnnotationValue p) {
-      return Snippet.format("(byte) %s", b);
+    public CodeBlock visitByte(byte b, AnnotationValue p) {
+      return CodeBlocks.format("(byte) $L", b);
     }
 
     @Override
-    public Snippet visitChar(char c, AnnotationValue p) {
-      return Snippet.format("%s", p);
+    public CodeBlock visitChar(char c, AnnotationValue p) {
+      return CodeBlocks.format("$L", p);
     }
 
     @Override
-    public Snippet visitDouble(double d, AnnotationValue p) {
-      return Snippet.format("%sD", d);
+    public CodeBlock visitDouble(double d, AnnotationValue p) {
+      return CodeBlocks.format("$LD", d);
     }
 
     @Override
-    public Snippet visitFloat(float f, AnnotationValue p) {
-      return Snippet.format("%sF", f);
+    public CodeBlock visitFloat(float f, AnnotationValue p) {
+      return CodeBlocks.format("$LF", f);
     }
 
     @Override
-    public Snippet visitInt(int i, AnnotationValue p) {
-      return Snippet.format("(int) %s", i);
+    public CodeBlock visitInt(int i, AnnotationValue p) {
+      return CodeBlocks.format("(int) $L", i);
     }
 
     @Override
-    public Snippet visitLong(long i, AnnotationValue p) {
-      return Snippet.format("%sL", i);
+    public CodeBlock visitLong(long i, AnnotationValue p) {
+      return CodeBlocks.format("$LL", i);
     }
 
     @Override
-    public Snippet visitShort(short s, AnnotationValue p) {
-      return Snippet.format("(short) %s", s);
+    public CodeBlock visitShort(short s, AnnotationValue p) {
+      return CodeBlocks.format("(short) $L", s);
     }
 
     @Override
-    protected Snippet defaultAction(Object o, AnnotationValue p) {
-      return Snippet.format("%s", o);
+    protected CodeBlock defaultAction(Object o, AnnotationValue p) {
+      return CodeBlocks.format("$L", o);
     }
 
     @Override
-    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
       for (int i = 0; i < values.size(); i++) {
-        snippets.add(this.visit(values.get(i), p));
+        codeBlocks.add(this.visit(values.get(i), p));
       }
-      return Snippet.format("{%s}", makeParametersSnippet(snippets.build()));
+      return CodeBlocks.format("{$L}", makeParametersCodeBlock(codeBlocks.build()));
     }
   }
 
   /**
-   * Returns a snippet for the visited value. Expects its parameter to be a class with static
+   * Returns a code block for the visited value. Expects its parameter to be a class with static
    * creation methods for all nested annotation types.
    *
    * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
    */
-  private static class MapKeySnippetExceptArrays extends MapKeySnippet {
+  private static class MapKeyExpressionExceptArrays extends MapKeyExpression {
 
-    MapKeySnippetExceptArrays(ClassName mapKeyCreator) {
+    MapKeyExpressionExceptArrays(ClassName mapKeyCreator) {
       super(mapKeyCreator);
     }
 
     @Override
-    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
       throw new IllegalArgumentException("Cannot unwrap arrays");
     }
   }
 
   /**
-   * Returns a snippet that calls a static method on {@code mapKeySnippet.mapKeyCreator} to create
-   * an annotation from {@code mapKeyAnnotation}.
+   * Returns a code block that calls a static method on {@code mapKeyCodeBlock.mapKeyCreator} to
+   * create an annotation from {@code mapKeyAnnotation}.
    */
-  private static Snippet annotationSnippet(
-      AnnotationMirror mapKeyAnnotation, final MapKeySnippet mapKeySnippet) {
-    return Snippet.format(
-        "%s.create%s(%s)",
-        mapKeySnippet.mapKeyCreator,
+  private static CodeBlock annotationExpression(
+      AnnotationMirror mapKeyAnnotation, final MapKeyExpression mapKeyExpression) {
+    return CodeBlocks.format(
+        "$T.create$L($L)",
+        mapKeyExpression.mapKeyCreator,
         mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
-        makeParametersSnippet(
+        makeParametersCodeBlock(
             transform(
                 getAnnotationValuesWithDefaults(mapKeyAnnotation).entrySet(),
-                new Function<Map.Entry<ExecutableElement, AnnotationValue>, Snippet>() {
+                new Function<Map.Entry<ExecutableElement, AnnotationValue>, CodeBlock>() {
                   @Override
-                  public Snippet apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
+                  public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
                     return ARRAY_LITERAL_PREFIX.visit(
                         entry.getKey().getReturnType(),
-                        mapKeySnippet.visit(entry.getValue(), entry.getValue()));
+                        mapKeyExpression.visit(entry.getValue(), entry.getValue()));
                   }
                 })));
   }
 
   /**
-   * If the visited type is an array, prefixes the parameter snippet with {@code new T[]}, where
+   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where
    * {@code T} is the raw array component type.
    */
-  private static final SimpleTypeVisitor6<Snippet, Snippet> ARRAY_LITERAL_PREFIX =
-      new SimpleTypeVisitor6<Snippet, Snippet>() {
+  private static final SimpleTypeVisitor6<CodeBlock, CodeBlock> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<CodeBlock, CodeBlock>() {
 
         @Override
-        public Snippet visitArray(ArrayType t, Snippet p) {
-          return Snippet.format("new %s[] %s", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        public CodeBlock visitArray(ArrayType t, CodeBlock p) {
+          return CodeBlocks.format("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
         }
 
         @Override
-        protected Snippet defaultAction(TypeMirror e, Snippet p) {
+        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {
           return p;
         }
       };
@@ -333,12 +321,12 @@ protected Snippet defaultAction(TypeMirror e, Snippet p) {
       new SimpleTypeVisitor6<TypeName, Void>() {
         @Override
         public TypeName visitDeclared(DeclaredType t, Void p) {
-          return ClassName.fromTypeElement(MoreTypes.asTypeElement(t));
+          return ClassName.get(MoreTypes.asTypeElement(t));
         }
 
         @Override
         protected TypeName defaultAction(TypeMirror e, Void p) {
-          return TypeNames.forTypeMirror(e);
+          return TypeName.get(e);
         }
       };
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 54fc45e87..0639dbf3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -15,30 +15,34 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
 import dagger.internal.MapProviderFactory;
-import dagger.internal.MembersInjectors;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.internal.MapOfProducerProducer;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.SET;
 
 /**
- * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link Snippet}.
+ * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link CodeBlock}.
  */
 abstract class MemberSelect {
   /**
    * Returns a {@link MemberSelect} that accesses the field given by {@code fieldName} owned by
    * {@code owningClass}.  In this context "local" refers to the fact that the field is owned by the
-   * type (or an enclosing type) from which the snippet will be used.  The returned
+   * type (or an enclosing type) from which the code block will be used.  The returned
    * {@link MemberSelect} will not be valid for accessing the field from a different class
    * (regardless of accessibility).
    */
@@ -55,34 +59,34 @@ static MemberSelect localField(ClassName owningClass, String fieldName) {
     }
 
     @Override
-    Snippet getSnippetFor(ClassName usingClass) {
+    CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? Snippet.format("%s", fieldName)
-          : Snippet.format("%s.this.%s", owningClass(), fieldName);
+          ? CodeBlocks.format("$L", fieldName)
+          : CodeBlocks.format("$T.this.$L", owningClass(), fieldName);
     }
   }
 
   /**
    * Returns a {@link MemberSelect} for the invocation of a static method (given by
-   * {@code methodInvocationSnippet}) on the {@code owningClass}.
+   * {@code methodInvocationCodeBlock}) on the {@code owningClass}.
    */
-  static MemberSelect staticMethod(ClassName owningClass, Snippet methodInvocationSnippet) {
-    return new StaticMethod(owningClass, methodInvocationSnippet);
+  static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocationCodeBlock) {
+    return new StaticMethod(owningClass, methodInvocationCodeBlock);
   }
 
   private static final class StaticMethod extends MemberSelect {
-    final Snippet methodSnippet;
+    final CodeBlock methodCodeBlock;
 
-    StaticMethod(ClassName owningClass, Snippet methodSnippet) {
+    StaticMethod(ClassName owningClass, CodeBlock methodCodeBlock) {
       super(owningClass, true);
-      this.methodSnippet = checkNotNull(methodSnippet);
+      this.methodCodeBlock = checkNotNull(methodCodeBlock);
     }
 
     @Override
-    Snippet getSnippetFor(ClassName usingClass) {
+    CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? methodSnippet
-          : Snippet.format("%s.%s", owningClass(), methodSnippet);
+          ? methodCodeBlock
+          : CodeBlocks.format("$T.$L", owningClass(), methodCodeBlock);
     }
   }
 
@@ -91,21 +95,30 @@ Snippet getSnippetFor(ClassName usingClass) {
    */
   static MemberSelect noOpMembersInjector(TypeMirror type) {
     return new ParameterizedStaticMethod(
-        ClassName.fromClass(MembersInjectors.class),
+        MEMBERS_INJECTORS,
         ImmutableList.of(type),
-        Snippet.format("noOp()"),
-        ClassName.fromClass(MembersInjector.class));
+        CodeBlocks.format("noOp()"),
+        MEMBERS_INJECTOR);
   }
 
   /**
-   * Returns the {@link MemberSelect} an empty implementation of {@link MapProviderFactory}.
+   * A {@link MemberSelect} for an empty map of framework types.
+   *
+   * @param frameworkMapFactoryClass either {@link MapProviderFactory}
+   *     or {@link MapOfProducerProducer}
    */
-  static MemberSelect emptyMapProviderFactory(MapType mapType) {
+  static MemberSelect emptyFrameworkMapFactory(
+      ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {
+    checkArgument(
+        frameworkMapFactoryClass.equals(MAP_PROVIDER_FACTORY)
+            || frameworkMapFactoryClass.equals(MAP_OF_PRODUCER_PRODUCER),
+        "frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s",
+        frameworkMapFactoryClass);
     return new ParameterizedStaticMethod(
-        ClassName.fromClass(MapProviderFactory.class),
-        ImmutableList.of(mapType.keyType(), mapType.unwrappedValueType(Provider.class)),
-        Snippet.format("empty()"),
-        ClassName.fromClass(MapProviderFactory.class));
+        frameworkMapFactoryClass,
+        ImmutableList.of(keyType, unwrappedValueType),
+        CodeBlocks.format("empty()"),
+        frameworkMapFactoryClass);
   }
 
   /**
@@ -117,53 +130,41 @@ static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType)
     return new ParameterizedStaticMethod(
         setFactoryType,
         ImmutableList.of(setType.elementType()),
-        Snippet.format("create()"),
-        ClassName.fromClass(Set.class));
+        CodeBlocks.format("create()"),
+        SET);
   }
 
-  static final class ParameterizedStaticMethod extends MemberSelect {
+  private static final class ParameterizedStaticMethod extends MemberSelect {
     final ImmutableList<TypeMirror> typeParameters;
-    final Snippet methodSnippet;
+    final CodeBlock methodCodeBlock;
     final ClassName rawReturnType;
 
     ParameterizedStaticMethod(
         ClassName owningClass,
         ImmutableList<TypeMirror> typeParameters,
-        Snippet methodSnippet,
+        CodeBlock methodCodeBlock,
         ClassName rawReturnType) {
       super(owningClass, true);
       this.typeParameters = typeParameters;
-      this.methodSnippet = methodSnippet;
+      this.methodCodeBlock = methodCodeBlock;
       this.rawReturnType = rawReturnType;
     }
 
     @Override
-    Snippet getSnippetFor(ClassName usingClass) {
+    CodeBlock getExpressionFor(ClassName usingClass) {
       boolean accessible = true;
       for (TypeMirror typeParameter : typeParameters) {
         accessible &= isTypeAccessibleFrom(typeParameter, usingClass.packageName());
       }
 
       if (accessible) {
-        Snippet typeParametersSnippet = Snippet.makeParametersSnippet(
-            FluentIterable.from(typeParameters)
-                .transform(new Function<TypeMirror, Snippet>() {
-                  @Override
-                  public Snippet apply(TypeMirror input) {
-                    return Snippet.format("%s", TypeNames.forTypeMirror(input));
-                  }
-                }));
-        return Snippet.format(
-            "%s.<%s>%s",
+        return CodeBlocks.format(
+            "$T.<$L>$L",
             owningClass(),
-            typeParametersSnippet,
-            methodSnippet);
+            makeParametersCodeBlock(toCodeBlocks(typeParameters)),
+            methodCodeBlock);
       } else {
-        return Snippet.format(
-            "((%s) %s.%s)",
-            rawReturnType,
-            owningClass(),
-            methodSnippet);
+        return CodeBlocks.format("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
       }
     }
   }
@@ -190,7 +191,8 @@ boolean staticMember() {
   }
 
   /**
-   * Returns a {@link Snippet} suitable for accessing the member from the given {@code usingClass}.
+   * Returns a {@link CodeBlock} suitable for accessing the member from the given {@code
+   * usingClass}.
    */
-  abstract Snippet getSnippetFor(ClassName usingClass);
-}
\ No newline at end of file
+  abstract CodeBlock getExpressionFor(ClassName usingClass);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index d4539a8f6..293dc7466 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -56,12 +56,12 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
-import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -74,17 +74,14 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends JavaPoetSourceFileGenerator<MembersInjectionBinding> {
-  private final DependencyRequestMapper dependencyRequestMapper;
 
-  MembersInjectorGenerator(
-      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+  MembersInjectorGenerator(Filer filer, Elements elements) {
     super(filer, elements);
-    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return javapoetMembersInjectorNameForType(binding.bindingElement());
+    return membersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
@@ -125,7 +122,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
             .addCode("}");
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+        SourceFiles.generateBindingFieldsForDependencies(binding);
 
     ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
 
@@ -141,11 +138,11 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
             .addTypeVariables(typeParameters);
 
     createMethodBuilder.addCode(
-        "return new $T(", javapoetParameterizedGeneratedTypeNameForBinding(binding));
+        "return new $T(", parameterizedGeneratedTypeNameForBinding(binding));
     ImmutableList.Builder<CodeBlock> constructorInvocationParameters = ImmutableList.builder();
 
     boolean usesRawFrameworkTypes = false;
-    UniqueNames fieldNames = new UniqueNames();
+    UniqueNameSet fieldNames = new UniqueNameSet();
     for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
       BindingKey bindingKey = fieldEntry.getKey();
       FrameworkField bindingField = fieldEntry.getValue();
@@ -158,8 +155,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       String fieldName = fieldNames.getUniqueName(bindingField.name());
       TypeName fieldType =
           useRawFrameworkType
-              ? bindingField.javapoetFrameworkType().rawType
-              : bindingField.javapoetFrameworkType();
+              ? bindingField.frameworkType().rawType
+              : bindingField.frameworkType();
       FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
@@ -255,7 +252,7 @@ private CodeBlock delegateInjectMemberCodeBlock(
       ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
     return CodeBlocks.format(
         "$L.$L($L);",
-        javapoetMembersInjectorNameForType(
+        membersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
         injectionSiteDelegateMethodName(injectionSite.element()),
         makeParametersCodeBlock(
@@ -388,17 +385,4 @@ public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
           return visibleToMembersInjector(p, t.asElement());
         }
       };
-
-  private static final class UniqueNames {
-    private final Set<String> uniqueNames = new HashSet<>();
-
-    String getUniqueName(String base) {
-      String name = base;
-      for (int differentiator = 2; !uniqueNames.add(name); differentiator++) {
-        name = base + differentiator;
-      }
-      uniqueNames.add(name);
-      return name;
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 078977e16..896458650 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import java.util.Iterator;
 import java.util.List;
@@ -26,7 +27,6 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
@@ -94,6 +94,20 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
+  public String format(SourceElement sourceElement) {
+    return format(
+        MoreElements.asExecutable(sourceElement.element()),
+        sourceElement
+            .contributedBy()
+            .transform(
+                new Function<TypeElement, DeclaredType>() {
+                  @Override
+                  public DeclaredType apply(TypeElement contributingModule) {
+                    return MoreTypes.asDeclared(contributingModule.asType());
+                  }
+                }));
+  }
+
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
       TypeMirror type) {
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
@@ -104,12 +118,6 @@ private static void appendParameter(StringBuilder builder, VariableElement param
   }
 
   private static String nameOfType(TypeMirror type) {
-    if (type.getKind().isPrimitive()) {
-      return MoreTypes.asPrimitiveType(type).toString();
-    } else if (type.getKind() == TypeKind.VOID) {
-      return "void";
-    } else {
-      return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
-    }
+    return stripCommonTypePrefixes(type.toString());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 954b91eeb..1c4871e5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -159,12 +159,10 @@ ModuleDescriptor create(TypeElement moduleElement) {
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
-          bindings.add(
-              provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement.asType()));
+          bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
         }
         if (isAnnotationPresent(moduleMethod, Produces.class)) {
-          bindings.add(
-              productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
+          bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));
         }
       }
       
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 1afda7d90..00d73bda1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -110,15 +110,18 @@
         if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
           // all of the provides methods in this module are valid!
           // time to generate some factories!
-          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
-              .transform(new Function<ExecutableElement, ProvisionBinding>() {
-                @Override
-                public ProvisionBinding apply(ExecutableElement providesMethod) {
-                  return provisionBindingFactory.forProvidesMethod(providesMethod,
-                      providesMethod.getEnclosingElement().asType());
-                }
-              })
-              .toSet();
+          ImmutableSet<ProvisionBinding> bindings =
+              FluentIterable.from(moduleProvidesMethods)
+                  .transform(
+                      new Function<ExecutableElement, ProvisionBinding>() {
+                        @Override
+                        public ProvisionBinding apply(ExecutableElement providesMethod) {
+                          return provisionBindingFactory.forProvidesMethod(
+                              providesMethod,
+                              MoreElements.asType(providesMethod.getEnclosingElement()));
+                        }
+                      })
+                  .toSet();
 
           try {
             for (ProvisionBinding binding : bindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 4741ef5b0..6dfa0952b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -44,18 +44,19 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
-import static dagger.internal.codegen.TypeNames.abstractProducerOf;
-import static dagger.internal.codegen.TypeNames.listOf;
-import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
 import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
-import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
 import static dagger.internal.codegen.TypeNames.VOID_CLASS;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
+import static dagger.internal.codegen.TypeNames.listOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -71,17 +72,13 @@
  */
 final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
 
-  private final DependencyRequestMapper dependencyRequestMapper;
-
-  ProducerFactoryGenerator(
-      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+  ProducerFactoryGenerator(Filer filer, Elements elements) {
     super(filer, elements);
-    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return javapoetGeneratedClassNameForBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -104,7 +101,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .superclass(abstractProducerOf(providedTypeName));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+        SourceFiles.generateBindingFieldsForDependencies(binding);
 
     MethodSpec.Builder constructorBuilder =
         constructorBuilder()
@@ -124,7 +121,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.javapoetFrameworkType();
+      TypeName fieldType = bindingField.frameworkType();
       addFieldAndConstructorParameter(
           factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
@@ -497,10 +494,6 @@ private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
       return CodeBlocks.format("");
     }
-    return CodeBlocks.format(
-        "throws $L",
-        CodeBlocks.join(
-            FluentIterable.from(thrownTypes)
-                .transform(CodeBlocks.TYPE_MIRROR_TO_CODE_BLOCK), ", "));
+    return CodeBlocks.format("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index cc167e599..d3873e969 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -113,15 +113,18 @@
           if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()) {
             // all of the produces methods in this module are valid!
             // time to generate some factories!
-            ImmutableSet<ProductionBinding> bindings = FluentIterable.from(moduleProducesMethods)
-                .transform(new Function<ExecutableElement, ProductionBinding>() {
-                  @Override
-                  public ProductionBinding apply(ExecutableElement producesMethod) {
-                    return productionBindingFactory.forProducesMethod(producesMethod,
-                        producesMethod.getEnclosingElement().asType());
-                  }
-                })
-                .toSet();
+            ImmutableSet<ProductionBinding> bindings =
+                FluentIterable.from(moduleProducesMethods)
+                    .transform(
+                        new Function<ExecutableElement, ProductionBinding>() {
+                          @Override
+                          public ProductionBinding apply(ExecutableElement producesMethod) {
+                            return productionBindingFactory.forProducesMethod(
+                                producesMethod,
+                                MoreElements.asType(producesMethod.getEnclosingElement()));
+                          }
+                        })
+                    .toSet();
 
             try {
               for (ProductionBinding binding : bindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 391d804e4..ab8a5d33f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -26,9 +26,9 @@
 import dagger.producers.Produces;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
@@ -93,19 +93,17 @@ public BindingType bindingType() {
     }
 
     ProductionBinding forProducesMethod(
-        ExecutableElement producesMethod, TypeMirror contributedBy) {
-      checkNotNull(producesMethod);
+        ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
-      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      SourceElement sourceElement = SourceElement.forElement(producesMethod, contributedBy);
+      Key key = keyFactory.forProducesMethod(sourceElement);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, producesMethod));
-      Key key = keyFactory.forProducesMethod(resolvedMethod, producesMethod);
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              declaredContainer,
+              MoreTypes.asDeclared(contributedBy.asType()),
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       DependencyRequest monitorRequest =
@@ -114,7 +112,7 @@ ProductionBinding forProducesMethod(
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
-          SourceElement.forElement(producesMethod, MoreTypes.asTypeElement(declaredContainer)),
+          sourceElement,
           key,
           dependencies,
           findBindingPackage(key),
@@ -148,6 +146,25 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           Optional.<DependencyRequest>absent());
     }
 
+    /**
+     * A binding that depends explicitly on a set of individual provision or production multibinding
+     * contribution methods.
+     */
+    ProductionBinding syntheticMultibinding(
+        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+      return new AutoValue_ProductionBinding(
+          SourceElement.forElement(request.requestElement()),
+          request.key(),
+          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
+          findBindingPackage(request.key()),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.forMultibindingRequest(request),
+          Produces.Type.UNIQUE,
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent());
+    }
+
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 7b2fb5d8e..346fdc4b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -29,7 +29,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -152,24 +151,23 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       return Optional.absent();
     }
 
-    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror contributedBy) {
-      checkNotNull(providesMethod);
+    ProvisionBinding forProvidesMethod(
+        ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
-      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      SourceElement sourceElement = SourceElement.forElement(providesMethod, contributedBy);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, providesMethod));
-      Key key = keyFactory.forProvidesMethod(resolvedMethod, providesMethod);
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+      Key key = keyFactory.forProvidesMethod(sourceElement);
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              declaredContainer,
+              MoreTypes.asDeclared(contributedBy.asType()),
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
-          SourceElement.forElement(providesMethod, MoreTypes.asTypeElement(declaredContainer)),
+          sourceElement,
           key,
           dependencies,
           findBindingPackage(key),
@@ -205,6 +203,25 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
+    /**
+     * A binding that depends explicitly on a set of individual provision multibinding contribution
+     * methods.
+     */
+    ProvisionBinding syntheticMultibinding(
+        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+      return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(request.requestElement()),
+          request.key(),
+          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
+          findBindingPackage(request.key()),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.forMultibindingRequest(request),
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
+          scopeOf(request.requestElement()));
+    }
+
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 62b102245..6eae6ccd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -24,7 +24,6 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
-import dagger.MembersInjector;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
@@ -35,10 +34,10 @@
 import static com.google.common.collect.Iterables.concat;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT;
 
 /**
- * The collection of bindings that have been resolved for a binding key.
+ * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
+ * exactly one binding.
  *
  * @author Gregory Kick
  */
@@ -233,18 +232,21 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
   }
 
   /**
-   * {@code true} if this is a multibindings contribution.
+   * {@code true} if this is a multibinding contribution.
    */
-  boolean isMultibindings() {
-    return !(contributionBindings().isEmpty() && multibindingDeclarations().isEmpty())
-        && contributionType().isMultibinding();
+  boolean isMultibindingContribution() {
+    return contributionBindings().size() == 1
+        && contributionBinding().contributionType().isMultibinding();
   }
 
   /**
-   * {@code true} if this is a unique contribution binding.
+   * Returns the single contribution binding.
+   *
+   * @throws IllegalStateException if there is not exactly one element in
+   *     {@link #contributionBindings()}, which will never happen for contributions in valid graphs
    */
-  boolean isUniqueContribution() {
-    return !contributionBindings().isEmpty() && !contributionType().isMultibinding();
+  ContributionBinding contributionBinding() {
+    return getOnlyElement(contributionBindings());
   }
 
   /**
@@ -272,7 +274,11 @@ public BindingType bindingType() {
   public ContributionType contributionType() {
     ImmutableSet<ContributionType> types = contributionTypes();
     checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
-    checkState(types.size() == 1, MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types);
+    checkState(
+        types.size() == 1,
+        "More than one binding present of different types for %s: %s",
+        bindingKey(),
+        bindingsAndDeclarationsByContributionType());
     return getOnlyElement(types);
   }
 
@@ -322,15 +328,6 @@ public ContributionType contributionType() {
    * The framework class associated with these bindings.
    */
   Class<?> frameworkClass() {
-    switch (bindingKey().kind()) {
-      case CONTRIBUTION:
-        return Iterables.any(contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))
-            ? BindingType.PRODUCTION.frameworkClass()
-            : BindingType.PROVISION.frameworkClass();
-      case MEMBERS_INJECTION:
-        return MembersInjector.class;
-      default:
-        throw new AssertionError();
-    }
+    return bindingType().frameworkClass();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
index 29949629b..b8bcf5263 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
@@ -15,12 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
 
 /**
  * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
@@ -48,6 +51,16 @@ TypeElement enclosingTypeElement() {
     return BINDING_TYPE_ELEMENT.visit(element());
   }
 
+  /**
+   * The type of {@link #element()}, considered as a member of {@link #contributedBy()} if it is
+   * present.
+   */
+  TypeMirror asMemberOfContributingType(Types types) {
+    return contributedBy().isPresent()
+        ? types.asMemberOf(MoreTypes.asDeclared(contributedBy().get().asType()), element())
+        : element().asType();
+  }
+
   private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
       new SimpleElementVisitor6<TypeElement, Void>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 05c4f3a6d..46a04d63c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -16,9 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
+import com.squareup.javapoet.ClassName;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 
@@ -37,52 +35,17 @@
  */
 final class SourceFileGenerationException extends Exception {
   // TODO(ronshapiro): remove these unused values
-  private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
-  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
-      Optional<? extends Element> associatedElement) {
-    super(createMessage(generatedClassNames, cause.getMessage()), cause);
-    this.generatedClassNames = ImmutableSet.copyOf(generatedClassNames);
-    this.associatedElement = checkNotNull(associatedElement);
-  }
-
-  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause) {
-    this(generatedClassNames, cause, Optional.<Element>absent());
-  }
-
-  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
-      Element associatedElement) {
-    this(generatedClassNames, cause, Optional.of(associatedElement));
-  }
-
   SourceFileGenerationException(
-      Optional<com.squareup.javapoet.ClassName> generatedClassName,
+      Optional<ClassName> generatedClassName,
       Throwable cause,
       Optional<? extends Element> associatedElement) {
     super(createMessage(generatedClassName, cause.getMessage()), cause);
-    this.generatedClassNames = ImmutableSet.of();
     this.associatedElement = checkNotNull(associatedElement);
   }
 
-  public ImmutableSet<ClassName> generatedClassNames() {
-    return generatedClassNames;
-  }
-
-  public Optional<? extends Element> associatedElement() {
-    return associatedElement;
-  }
-
-  private static String createMessage(Iterable<ClassName> generatedClassNames, String message) {
-    return String.format("Could not generate %s: %s.",
-        Iterables.isEmpty(generatedClassNames)
-            ? "unknown files"
-            : Iterables.toString(generatedClassNames),
-        message);
-  }
-
-  private static String createMessage(
-      Optional<com.squareup.javapoet.ClassName> generatedClassName, String message) {
+  private static String createMessage(Optional<ClassName> generatedClassName, String message) {
     return String.format("Could not generate %s: %s.",
         generatedClassName.isPresent()
             ? generatedClassName.get()
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
deleted file mode 100644
index ddb889f34..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-/**
- * A template for types that generate source files from an annotation processor.
- *
- * @param <T> The input type from which source is to be generated.
- * @author Gregory Kick
- * @since 2.0
- */
-interface SourceFileGenerator<T> {
-  /** Generates a source file to be compiled for {@code T}. */
-  void generate(T input) throws SourceFileGenerationException;
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index f7b2f8ee9..0e3e6e6fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -14,35 +14,21 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Splitter;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
-import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
@@ -50,6 +36,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
 
 /**
@@ -60,7 +47,8 @@
  */
 class SourceFiles {
 
-  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('$');
+  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('_');
+  private static final Joiner CANONICAL_NAME_JOINER = Joiner.on('$');
 
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
@@ -80,62 +68,6 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
-  /**
-   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
-   * from the {@link Binding#unresolved()} binding if it exists.
-   *
-   * <p>Consider a generic type {@code Foo<T>} with a constructor {@code Foo(T t, T t1, A a, A a1)}.
-   * Its factory's {@code create} method should take only two parameters:
-   * {@code create(Provider<T> tProvider, Provider<A> aProvider)}. However, if the component
-   * initializes a factory for {@code Foo<A>}, it really has only one dependency:
-   * both arguments should be the same {@code Provider<A>}. In order to get the right number of
-   * arguments, we have to index resolved binding's dependencies by their keys in the unresolved
-   * version of the binding.
-   */
-  // TODO(dpb): Move this to DependencyRequest.
-  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
-      Binding binding) {
-    // If the binding is already fully resolved, just index the dependencies by binding key.
-    if (!binding.unresolved().isPresent()) {
-      return indexDependenciesByKey(binding, Functions.<DependencyRequest>identity());
-    }
-    
-    // Index the unresolved dependencies, replacing each one with its resolved version by looking it
-    // up by request element.
-    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
-        Maps.uniqueIndex(
-            binding.implicitDependencies(),
-            new Function<DependencyRequest, Element>() {
-              @Override
-              public Element apply(DependencyRequest dependencyRequest) {
-                return dependencyRequest.requestElement();
-              }
-            });
-    return indexDependenciesByKey(
-        binding.unresolved().get(),
-        new Function<DependencyRequest, DependencyRequest>() {
-          @Override
-          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
-            return resolvedDependencies.get(unresolvedRequest.requestElement());
-          }
-        });
-  }
-
-  /**
-   * Groups a binding's dependency requests by their binding key.
-   *
-   * @param transformer applied to each dependency before inserting into the multimap
-   */
-  private static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
-      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : binding.implicitDependencies()) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
-    }
-    return dependenciesByKeyBuilder.orderValuesBy(DEPENDENCY_ORDERING).build();
-  }
-
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
    * all of the dependencies of {@code binding}. It is responsible for choosing a name that
@@ -145,66 +77,47 @@ public DependencyRequest apply(DependencyRequest unresolvedRequest) {
    * <li>is <i>probably</i> associated with the type being bound
    * <li>is unique within the class
    * </ul>
-   *
+   * 
    * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
-      DependencyRequestMapper dependencyRequestMapper, Binding binding) {
-    ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByUnresolvedKey(binding);
-    Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
-        dependenciesByKey.asMap();
+      Binding binding) {
+    checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
+
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
-    for (Entry<BindingKey, Collection<DependencyRequest>> entry
-        : dependenciesByKeyMap.entrySet()) {
-      BindingKey bindingKey = entry.getKey();
-      Collection<DependencyRequest> requests = entry.getValue();
-      Class<?> frameworkClass =
-          dependencyRequestMapper.getFrameworkClass(requests.iterator().next());
-      // collect together all of the names that we would want to call the provider
-      ImmutableSet<String> dependencyNames =
-          FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
-    
-      if (dependencyNames.size() == 1) {
-        // if there's only one name, great! use it!
-        String name = Iterables.getOnlyElement(dependencyNames);
-        bindingFields.put(
-            bindingKey,
-            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey.key(), name));
-      } else {
-        // in the event that a field is being used for a bunch of deps with different names,
-        // add all the names together with "And"s in the middle. E.g.: stringAndS
-        Iterator<String> namesIterator = dependencyNames.iterator();
-        String first = namesIterator.next();
-        StringBuilder compositeNameBuilder = new StringBuilder(first);
-        while (namesIterator.hasNext()) {
-          compositeNameBuilder.append("And").append(
-              CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
-        }
-        bindingFields.put(
-            bindingKey,
-            FrameworkField.createWithTypeFromKey(
-                frameworkClass, bindingKey.key(), compositeNameBuilder.toString()));
-      }
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      bindingFields.put(
+          frameworkDependency.bindingKey(),
+          FrameworkField.createWithTypeFromKey(
+              frameworkDependency.frameworkClass(),
+              frameworkDependency.bindingKey().key(),
+              fieldNameForDependency(frameworkDependency)));
     }
     return bindingFields.build();
   }
 
-  static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
-      DependencyRequest.Kind dependencyKind) {
-    switch (dependencyKind) {
-      case LAZY:
-        return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
-            frameworkTypeMemberSelect);
-      case INSTANCE:
-      case FUTURE:
-        return Snippet.format("%s.get()", frameworkTypeMemberSelect);
-      case PROVIDER:
-      case PRODUCER:
-      case MEMBERS_INJECTOR:
-        return Snippet.format("%s", frameworkTypeMemberSelect);
-      default:
-        throw new AssertionError();
+  private static String fieldNameForDependency(FrameworkDependency frameworkDependency) {
+    // collect together all of the names that we would want to call the provider
+    ImmutableSet<String> dependencyNames =
+        FluentIterable.from(frameworkDependency.dependencyRequests())
+            .transform(new DependencyVariableNamer())
+            .toSet();
+
+    if (dependencyNames.size() == 1) {
+      // if there's only one name, great! use it!
+      return Iterables.getOnlyElement(dependencyNames);
+    } else {
+      // in the event that a field is being used for a bunch of deps with different names,
+      // add all the names together with "And"s in the middle. E.g.: stringAndS
+      Iterator<String> namesIterator = dependencyNames.iterator();
+      String first = namesIterator.next();
+      StringBuilder compositeNameBuilder = new StringBuilder(first);
+      while (namesIterator.hasNext()) {
+        compositeNameBuilder
+            .append("And")
+            .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+      }
+      return compositeNameBuilder.toString();
     }
   }
 
@@ -235,51 +148,7 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
         checkArgument(!contribution.isSyntheticBinding());
-        ClassName enclosingClassName = ClassName.fromTypeElement(contribution.bindingTypeElement());
-        switch (contribution.bindingKind()) {
-          case INJECTION:
-          case PROVISION:
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
-            return enclosingClassName
-                .topLevelClassName()
-                .peerNamed(
-                    enclosingClassName.classFileName()
-                        + "_"
-                        + factoryPrefix(contribution)
-                        + "Factory");
-
-          default:
-            throw new AssertionError();
-        }
-
-      case MEMBERS_INJECTION:
-        return membersInjectorNameForType(binding.bindingTypeElement());
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  /**
-   * Returns the generated factory or members injector name parameterized with the proper type
-   * parameters if necessary.
-   */
-  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
-    return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
-  }
-
-  /**
-   * Returns the generated factory or members injector name for a binding.
-   */
-  static com.squareup.javapoet.ClassName javapoetGeneratedClassNameForBinding(Binding binding) {
-    switch (binding.bindingType()) {
-      case PROVISION:
-      case PRODUCTION:
-        ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(!contribution.isSyntheticBinding());
-        com.squareup.javapoet.ClassName enclosingClassName =
-            com.squareup.javapoet.ClassName.get(contribution.bindingTypeElement());
+        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement());
         switch (contribution.bindingKind()) {
           case INJECTION:
           case PROVISION:
@@ -288,7 +157,7 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
             return enclosingClassName
                 .topLevelClassName()
                 .peerClass(
-                    classFileName(enclosingClassName)
+                    canonicalName(enclosingClassName)
                         + "_"
                         + factoryPrefix(contribution)
                         + "Factory");
@@ -298,24 +167,23 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
         }
 
       case MEMBERS_INJECTION:
-        return javapoetMembersInjectorNameForType(binding.bindingTypeElement());
+        return membersInjectorNameForType(binding.bindingTypeElement());
 
       default:
         throw new AssertionError();
     }
   }
 
-  static com.squareup.javapoet.TypeName javapoetParameterizedGeneratedTypeNameForBinding(
+  static TypeName parameterizedGeneratedTypeNameForBinding(
       Binding binding) {
-    com.squareup.javapoet.ClassName className = javapoetGeneratedClassNameForBinding(binding);
-    ImmutableList<com.squareup.javapoet.TypeName> typeParameters =
-        javapoetBindingTypeParameters(binding);
+    ClassName className = generatedClassNameForBinding(binding);
+    ImmutableList<TypeName> typeParameters = bindingTypeParameters(binding);
     if (typeParameters.isEmpty()) {
       return className;
     } else {
-      return com.squareup.javapoet.ParameterizedTypeName.get(
+      return ParameterizedTypeName.get(
           className,
-          FluentIterable.from(typeParameters).toArray(com.squareup.javapoet.TypeName.class));
+          FluentIterable.from(typeParameters).toArray(TypeName.class));
     }
   }
 
@@ -353,58 +221,45 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     }
   }
 
-  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding) {
+  static ImmutableList<TypeName> bindingTypeParameters(
+      Binding binding) {
     Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
     if (!typeMirror.isPresent()) {
       return ImmutableList.of();
     }
-    TypeName bindingTypeName = dagger.internal.codegen.writer.TypeNames.forTypeMirror(typeMirror.get());
+    TypeName bindingTypeName = TypeName.get(typeMirror.get());
     return bindingTypeName instanceof ParameterizedTypeName
-        ? ((ParameterizedTypeName) bindingTypeName).parameters()
+        ? ImmutableList.copyOf(((ParameterizedTypeName) bindingTypeName).typeArguments)
         : ImmutableList.<TypeName>of();
   }
 
-  static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
-      Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    com.squareup.javapoet.TypeName bindingTypeName =
-        com.squareup.javapoet.TypeName.get(typeMirror.get());
-    return bindingTypeName instanceof com.squareup.javapoet.ParameterizedTypeName
-        ? ImmutableList.copyOf(
-            ((com.squareup.javapoet.ParameterizedTypeName) bindingTypeName).typeArguments)
-        : ImmutableList.<com.squareup.javapoet.TypeName>of();
-  }
-  
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
-    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
-    return injectedClassName
-        .topLevelClassName()
-        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
+    return siblingClassName(typeElement,  "_MembersInjector");
   }
 
-  static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
-      TypeElement typeElement) {
-    return siblingClassName(typeElement,  "_MembersInjector");
+  /**
+   * @deprecated prefer {@link #classFileName(ClassName)} instead and avoid dollar signs in
+   * generated source.
+   */
+  @Deprecated
+  static String canonicalName(ClassName className) {
+    return CANONICAL_NAME_JOINER.join(className.simpleNames());
   }
 
-  static String classFileName(com.squareup.javapoet.ClassName className) {
+  static String classFileName(ClassName className) {
     return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
   }
 
-  static com.squareup.javapoet.ClassName generatedMonitoringModuleName(
+  static ClassName generatedMonitoringModuleName(
       TypeElement componentElement) {
     return siblingClassName(componentElement, "_MonitoringModule");
   }
 
-  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code which could
-  // use this.
-  private static com.squareup.javapoet.ClassName siblingClassName(
-      TypeElement typeElement, String suffix) {
-    com.squareup.javapoet.ClassName className = com.squareup.javapoet.ClassName.get(typeElement);
-    return className.topLevelClassName().peerClass(classFileName(className) + suffix);
+  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code
+  // which could use this.
+  private static ClassName siblingClassName(TypeElement typeElement, String suffix) {
+    ClassName className = ClassName.get(typeElement);
+    return className.topLevelClassName().peerClass(canonicalName(className) + suffix);
   }
 
   private static String factoryPrefix(ContributionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 36963a7e8..118713147 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -19,14 +19,13 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -38,8 +37,13 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.difference;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.nullCheck;
 import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -69,7 +73,7 @@ public SubcomponentWriter(
   }
 
   private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
-    return parent.name.nestedClassNamed(
+    return parent.name.nestedClass(
         parent.subcomponentImplNames.get(subgraph.componentDescriptor()));
   }
 
@@ -82,10 +86,10 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
       TypeElement contributionType) {
-    return super.getOrCreateComponentContributionFieldSnippet(contributionType)
-        .or(parent.getOrCreateComponentContributionFieldSnippet(contributionType));
+    return super.getOrCreateComponentContributionFieldExpression(contributionType)
+        .or(parent.getOrCreateComponentContributionFieldExpression(contributionType));
   }
 
   @Override
@@ -94,12 +98,6 @@ protected MemberSelect getMemberSelect(BindingKey key) {
     return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
   }
 
-  @Override
-  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
-    return super.getMultibindingContributionSnippet(binding)
-        .or(parent.getMultibindingContributionSnippet(binding));
-  }
-
   private ExecutableType resolvedSubcomponentFactoryMethod() {
     return MoreTypes.asExecutable(
         types.asMemberOf(
@@ -108,19 +106,16 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
   }
 
   @Override
-  protected ClassWriter createComponentClass() {
-    ClassWriter componentWriter = parent.componentWriter.addNestedClass(name.simpleName());
-    componentWriter.addModifiers(PRIVATE, FINAL);
-    componentWriter.setSupertype(
+  protected TypeSpec.Builder createComponentClass() {
+    TypeSpec.Builder subcomponent = classBuilder(name.simpleName()).addModifiers(PRIVATE, FINAL);
+
+    addSupertype(
+        subcomponent,
         MoreTypes.asTypeElement(
             graph.componentDescriptor().builderSpec().isPresent()
-                ? graph
-                    .componentDescriptor()
-                    .builderSpec()
-                    .get()
-                    .componentType()
+                ? graph.componentDescriptor().builderSpec().get().componentType()
                 : resolvedSubcomponentFactoryMethod().getReturnType()));
-    return componentWriter;
+    return subcomponent;
   }
 
   @Override
@@ -132,60 +127,70 @@ protected void addBuilder() {
   }
 
   @Override
-  protected ClassWriter createBuilder() {
+  protected ClassName builderName() {
+    return name.peerClass(componentDefinitionTypeName().simpleName() + "Builder");
+  }
+
+  @Override
+  protected TypeSpec.Builder createBuilder(String builderSimpleName) {
     // Only write subcomponent builders if there is a spec.
     verify(graph.componentDescriptor().builderSpec().isPresent());
-    return parent.componentWriter.addNestedClass(
-        componentDefinitionTypeName().simpleName() + "Builder");
+    return classBuilder(builderSimpleName);
+  }
+
+  @Override
+  protected void addBuilderClass(TypeSpec builder) {
+    parent.component.addType(builder);
   }
 
   @Override
   protected void addFactoryMethods() {
-    MethodWriter componentMethod;
+    MethodSpec.Builder componentMethod =
+        methodBuilder(subcomponentFactoryMethod.getSimpleName().toString())
+            .addModifiers(PUBLIC)
+            .addAnnotation(Override.class);
     if (graph.componentDescriptor().builderSpec().isPresent()) {
       BuilderSpec spec = graph.componentDescriptor().builderSpec().get();
-      componentMethod =
-          parent.componentWriter.addMethod(
-              spec.builderDefinitionType().asType(),
-              subcomponentFactoryMethod.getSimpleName().toString());
-      componentMethod.body().addSnippet("return new %s();", builderName.get());
+      componentMethod
+          .returns(ClassName.get(spec.builderDefinitionType()))
+          .addStatement("return new $T()", builderName.get());
     } else {
       ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
-      componentMethod =
-          parent.componentWriter.addMethod(
-              resolvedMethod.getReturnType(), subcomponentFactoryMethod.getSimpleName().toString());
+      componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
       writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
     }
-    componentMethod.addModifiers(PUBLIC);
-    componentMethod.annotate(Override.class);
+    parent.component.addMethod(componentMethod.build());
   }
 
   private void writeSubcomponentWithoutBuilder(
-      MethodWriter componentMethod, ExecutableType resolvedMethod) {
-    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+      MethodSpec.Builder componentMethod, ExecutableType resolvedMethod) {
+    ImmutableList.Builder<CodeBlock> subcomponentConstructorParameters = ImmutableList.builder();
     List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
     List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
     for (int i = 0; i < params.size(); i++) {
       VariableElement moduleVariable = params.get(i);
       TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
-      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      TypeName moduleType = TypeName.get(paramTypes.get(i));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
       if (!componentContributionFields.containsKey(moduleTypeElement)) {
         String preferredModuleName =
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
-        FieldWriter contributionField =
-            componentWriter.addField(moduleTypeElement, preferredModuleName);
-        contributionField.addModifiers(PRIVATE, FINAL);
-        String actualModuleName = contributionField.name();
-        constructorWriter.addParameter(moduleType, actualModuleName);
-        constructorWriter.body()
-            .addSnippet("if (%s == null) {", actualModuleName)
-            .addSnippet("  throw new NullPointerException();")
-            .addSnippet("}");
-        constructorWriter.body().addSnippet("this.%1$s = %1$s;", actualModuleName);
+        FieldSpec contributionField =
+            componentField(ClassName.get(moduleTypeElement), preferredModuleName)
+                .addModifiers(PRIVATE, FINAL)
+                .build();
+        component.addField(contributionField);
+
+        String actualModuleName = contributionField.name;
+        constructor
+            .addParameter(moduleType, actualModuleName)
+            .addCode(nullCheck(actualModuleName))
+            .addStatement("this.$1L = $1L", actualModuleName);
+
         MemberSelect moduleSelect = localField(name, actualModuleName);
         componentContributionFields.put(moduleTypeElement, moduleSelect);
-        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
+        subcomponentConstructorParameters.add(
+            CodeBlocks.format("$L", moduleVariable.getSimpleName()));
       }
     }
 
@@ -195,16 +200,19 @@ private void writeSubcomponentWithoutBuilder(
     for (TypeElement moduleType : uninitializedModules) {
       String preferredModuleName =
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
-      FieldWriter contributionField = componentWriter.addField(moduleType, preferredModuleName);
-      contributionField.addModifiers(PRIVATE, FINAL);
-      String actualModuleName = contributionField.name();
-      constructorWriter.body().addSnippet("this.%s = new %s();",
-          actualModuleName, ClassName.fromTypeElement(moduleType));
+      FieldSpec contributionField =
+          componentField(ClassName.get(moduleType), preferredModuleName)
+              .addModifiers(PRIVATE, FINAL)
+              .build();
+      component.addField(contributionField);
+      String actualModuleName = contributionField.name;
+      constructor.addStatement(
+          "this.$L = new $T()", actualModuleName, ClassName.get(moduleType));
       MemberSelect moduleSelect = localField(name, actualModuleName);
       componentContributionFields.put(moduleType, moduleSelect);
     }
 
-    componentMethod.body().addSnippet("return new %s(%s);",
-        name, Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+    componentMethod.addStatement("return new $T($L)",
+        name, makeParametersCodeBlock(subcomponentConstructorParameters.build()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 80d83efba..e005761d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -23,11 +23,24 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
+import dagger.internal.DelegateFactory;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.Factory;
+import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.ScopedProvider;
+import dagger.internal.SetFactory;
 import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.MapOfProducedProducer;
+import dagger.producers.internal.MapOfProducerProducer;
+import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetOfProducedProducer;
+import dagger.producers.internal.SetProducer;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
@@ -43,17 +56,35 @@
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
+  static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
+  static final ClassName ILLEGAL_STATE_EXCEPTION = ClassName.get(IllegalStateException.class);
   static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
+  static final ClassName INSTANCE_FACTORY = ClassName.get(InstanceFactory.class);
   static final ClassName LIST = ClassName.get(List.class);
   static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
+  static final ClassName MAP_FACTORY = ClassName.get(MapFactory.class);
+  static final ClassName MAP_OF_PRODUCED_PRODUCER = ClassName.get(MapOfProducedProducer.class);
+  static final ClassName MAP_OF_PRODUCER_PRODUCER = ClassName.get(MapOfProducerProducer.class);
+  static final ClassName MAP_PRODUCER = ClassName.get(MapProducer.class);
+  static final ClassName MAP_PROVIDER_FACTORY = ClassName.get(MapProviderFactory.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
+  static final ClassName MEMBERS_INJECTORS = ClassName.get(MembersInjectors.class);
   static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
   static final ClassName PRODUCED = ClassName.get(Produced.class);
+  static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
+  static final ClassName SCOPED_PROVIDER = ClassName.get(ScopedProvider.class);
+  static final ClassName SET = ClassName.get(Set.class);
+  static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
+  static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
+  static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
+  static final ClassName STRING = ClassName.get(String.class);
+  static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
+      ClassName.get(UnsupportedOperationException.class);
 
   /**
    * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java b/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
new file mode 100644
index 000000000..325436140
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Convenience methods for use with JavaPoet's {@link TypeSpec}.
+ */
+final class TypeSpecs {
+
+  /**
+   * If {@code supertype} is a class, adds it as a superclass for {@code typeBuilder}; if it is an
+   * interface, adds it as a superinterface.
+   */
+  static void addSupertype(TypeSpec.Builder typeBuilder, TypeElement supertype) {
+    switch (supertype.getKind()) {
+      case CLASS:
+        typeBuilder.superclass(ClassName.get(supertype));
+        break;
+      case INTERFACE:
+        typeBuilder.addSuperinterface(ClassName.get(supertype));
+        break;
+      default:
+        throw new AssertionError(supertype + " is neither a class nor an interface.");
+    }
+  }
+
+  private TypeSpecs() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java b/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
new file mode 100644
index 000000000..b63b203e7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * A collector for names to be used in the same namespace that should not conflict.
+ */
+final class UniqueNameSet {
+  private final Set<String> uniqueNames = new HashSet<>();
+
+  /**
+   * Generates a unique name using {@code base}. If {@code base} has not yet been added, it will be
+   * returned as-is. If your {@code base} is healthy, this will always return {@code base}.
+   */
+  String getUniqueName(CharSequence base) {
+    String name = base.toString();
+    for (int differentiator = 2; !uniqueNames.add(name); differentiator++) {
+      name = base.toString() + differentiator;
+    }
+    return name;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
deleted file mode 100644
index 9ffab1871..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.SortedMap;
-
-import static dagger.internal.codegen.writer.Writables.toStringWritable;
-
-public final class AnnotationWriter implements Writable, HasClassReferences {
-  private final ClassName annotationName;
-  private final Set<HasClassReferences> memberReferences = Sets.newLinkedHashSet();
-  private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
-
-  AnnotationWriter(ClassName annotationName) {
-    this.annotationName = annotationName;
-  }
-
-  public void setValue(String value) {
-    setMember("value", value);
-  }
-
-  public void setMember(String name, int value) {
-    memberMap.put(name, toStringWritable(value));
-  }
-
-  public void setMember(String name, String value) {
-    memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
-  }
-
-  public <T extends Enum<T>> void setMember(String name, T value) {
-    Snippet snippet = Snippet.format("%s.%s", ClassName.fromClass(value.getClass()), value);
-    memberMap.put(name, snippet);
-    memberReferences.add(snippet);
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append('@');
-    annotationName.write(appendable, context);
-    if (!memberMap.isEmpty()) {
-      appendable.append('(');
-      boolean singleEntry = memberMap.size() == 1;
-      Iterator<Entry<String, Writable>> iterator = memberMap.entrySet().iterator();
-      while (iterator.hasNext()) {
-        Entry<String, Writable> member = iterator.next();
-        if (!singleEntry || !member.getKey().equals("value")) {
-          appendable.append(member.getKey()).append(" = ");
-        }
-        member.getValue().write(appendable, context);
-        if (iterator.hasNext()) {
-          appendable.append(",");
-        }
-      }
-      appendable.append(')');
-    }
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(memberReferences)
-        .append(annotationName)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
deleted file mode 100644
index e7960629e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import java.io.IOException;
-import java.util.Set;
-
-final class ArrayTypeName implements TypeName {
-  private final TypeName componentType;
-
-  ArrayTypeName(TypeName componentType) {
-    this.componentType = componentType;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return componentType.referencedClasses();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return componentType.write(appendable, context).append("[]");
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return (obj instanceof ArrayTypeName)
-        && this.componentType.equals(((ArrayTypeName) obj).componentType);
-  }
-
-  @Override
-  public int hashCode() {
-    return componentType.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
deleted file mode 100644
index c00dd5f07..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Lists;
-import java.io.IOException;
-import java.util.List;
-import java.util.Set;
-
-public final class BlockWriter implements Writable, HasClassReferences {
-  private final List<Snippet> snippets;
-
-  BlockWriter() {
-    this.snippets = Lists.newArrayList();
-  }
-
-  public BlockWriter addSnippet(String snippet, Object... args) {
-    snippets.add(Snippet.format(snippet, args));
-    return this;
-  }
-
-  public BlockWriter addSnippet(Snippet snippet) {
-    snippets.add(snippet);
-    return this;
-  }
-
-  boolean isEmpty() {
-    return snippets.isEmpty();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    for (Snippet snippet : snippets) {
-      appendable.append('\n');
-      snippet.write(appendable, context);
-    }
-    return appendable.append('\n');
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(snippets)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
deleted file mode 100644
index bd0791fc6..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Ascii;
-import com.google.common.base.Joiner;
-import com.google.common.base.Objects;
-import com.google.common.base.Optional;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.NestingKind;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.NestingKind.MEMBER;
-import static javax.lang.model.element.NestingKind.TOP_LEVEL;
-
-/**
- * Represents a fully-qualified class name for {@link NestingKind#TOP_LEVEL} and
- * {@link NestingKind#MEMBER} classes.
- *
- * @since 2.0
- */
-public final class ClassName implements TypeName, Comparable<ClassName> {
-  private String fullyQualifiedName = null;
-  private final String packageName;
-  /* From top to bottom.  E.g.: this field will contain ["A", "B"] for pgk.A.B.C */
-  private final ImmutableList<String> enclosingSimpleNames;
-  private final String simpleName;
-
-  private ClassName(String packageName, ImmutableList<String> enclosingSimpleNames,
-      String simpleName) {
-    this.packageName = packageName;
-    this.enclosingSimpleNames = enclosingSimpleNames;
-    this.simpleName = simpleName;
-  }
-
-  public String packageName() {
-    return packageName;
-  }
-
-  public ImmutableList<String> enclosingSimpleNames() {
-    return enclosingSimpleNames;
-  }
-
-  public Optional<ClassName> enclosingClassName() {
-    return enclosingSimpleNames.isEmpty()
-        ? Optional.<ClassName>absent()
-        : Optional.of(new ClassName(packageName,
-            enclosingSimpleNames.subList(0, enclosingSimpleNames.size() - 1),
-            enclosingSimpleNames.get(enclosingSimpleNames.size() - 1)));
-  }
-
-  public String simpleName() {
-    return simpleName;
-  }
-
-  public String canonicalName() {
-    if (fullyQualifiedName == null) {
-      StringBuilder builder = new StringBuilder(packageName());
-      if (builder.length() > 0) {
-        builder.append('.');
-      }
-      for (String enclosingSimpleName : enclosingSimpleNames()) {
-        builder.append(enclosingSimpleName).append('.');
-      }
-      fullyQualifiedName = builder.append(simpleName()).toString();
-    }
-    return fullyQualifiedName;
-  }
-
-  /**
-   * Equivalent to {@link #classFileName(char) classFileName('$')}
-   */
-  public String classFileName() {
-    return classFileName('$');
-  }
-
-  /**
-   * Returns the class name (excluding package).
-   *
-   * <p>The returned value includes the names of its enclosing classes (if any) but not the package
-   * name. e.g. {@code fromClass(Map.Entry.class).classFileName('_')} will return {@code Map_Entry}.
-   */
-  public String classFileName(char separator) {
-    StringBuilder builder = new StringBuilder();
-    for (String enclosingSimpleName : enclosingSimpleNames) {
-      builder.append(enclosingSimpleName).append(separator);
-    }
-    return builder.append(simpleName()).toString();
-  }
-
-  public ClassName topLevelClassName() {
-    Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
-    return enclosingIterator.hasNext()
-        ? new ClassName(packageName(), ImmutableList.<String>of(),
-            enclosingIterator.next())
-        : this;
-  }
-
-  public ClassName nestedClassNamed(String memberClassName) {
-    checkNotNull(memberClassName);
-    checkArgument(SourceVersion.isIdentifier(memberClassName));
-    return new ClassName(packageName(),
-        new ImmutableList.Builder<String>()
-            .addAll(enclosingSimpleNames())
-            .add(simpleName())
-            .build(),
-        memberClassName);
-  }
-
-  public ClassName peerNamed(String peerClassName) {
-    checkNotNull(peerClassName);
-    checkArgument(SourceVersion.isIdentifier(peerClassName));
-    return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
-  }
-
-  /**
-   * Returns a parameterized type name with this as its raw type if {@code parameters} is not empty.
-   * If {@code parameters} is empty, returns this object.
-   */
-  public TypeName withTypeParameters(List<? extends TypeName> parameters) {
-    return parameters.isEmpty() ? this : ParameterizedTypeName.create(this, parameters);
-  }
-
-  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
-      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
-
-  public static ClassName fromTypeElement(TypeElement element) {
-    checkNotNull(element);
-    checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
-    String simpleName = element.getSimpleName().toString();
-    List<String> enclosingNames = new ArrayList<String>();
-    Element current = element.getEnclosingElement();
-    while (current.getKind().isClass() || current.getKind().isInterface()) {
-      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
-      enclosingNames.add(current.getSimpleName().toString());
-      current = current.getEnclosingElement();
-    }
-    PackageElement packageElement = getPackage(current);
-    Collections.reverse(enclosingNames);
-    return new ClassName(packageElement.getQualifiedName().toString(),
-        ImmutableList.copyOf(enclosingNames), simpleName);
-  }
-
-  public static ClassName fromClass(Class<?> clazz) {
-    checkNotNull(clazz);
-    List<String> enclosingNames = new ArrayList<String>();
-    Class<?> current = clazz.getEnclosingClass();
-    while (current != null) {
-      enclosingNames.add(current.getSimpleName());
-      current = current.getEnclosingClass();
-    }
-    Collections.reverse(enclosingNames);
-    return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
-  }
-
-  private static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This
-   * method assumes that the input is ASCII and follows typical Java style (lower-case package
-   * names, upper-camel-case class names) and may produce incorrect results or throw
-   * {@link IllegalArgumentException} otherwise. For that reason, {@link #fromClass(Class)} and
-   * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}
-   * instances without such restrictions.
-   */
-  public static ClassName bestGuessFromString(String classNameString) {
-    checkNotNull(classNameString);
-    List<String> parts = Splitter.on('.').splitToList(classNameString);
-    int firstClassPartIndex = -1;
-    for (int i = 0; i < parts.size(); i++) {
-      String part = parts.get(i);
-      checkArgument(SourceVersion.isIdentifier(part));
-      char firstChar = part.charAt(0);
-      if (Ascii.isLowerCase(firstChar)) {
-        // looks like a package part
-        if (firstClassPartIndex >= 0) {
-          throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
-        }
-      } else if (Ascii.isUpperCase(firstChar)) {
-        // looks like a class part
-        if (firstClassPartIndex < 0) {
-          firstClassPartIndex = i;
-        }
-      } else {
-        throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
-      }
-    }
-    int lastIndex = parts.size() - 1;
-    return new ClassName(
-        Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),
-        firstClassPartIndex == lastIndex
-            ? ImmutableList.<String>of()
-            : ImmutableList.copyOf(parts.subList(firstClassPartIndex, lastIndex)),
-        parts.get(lastIndex));
-  }
-
-  public static ClassName create(
-      String packageName, List<String> enclosingSimpleNames, String simpleName) {
-    return new ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
-        simpleName);
-  }
-
-  public static ClassName create(String packageName, String simpleName) {
-    return new ClassName(packageName, ImmutableList.<String>of(), simpleName);
-  }
-
-  @Override
-  public String toString() {
-    return canonicalName();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append(context.sourceReferenceForClassName(this));
-    return appendable;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == this) {
-      return true;
-    } else if (obj instanceof ClassName) {
-      ClassName that = (ClassName) obj;
-      return this.packageName.equals(that.packageName)
-          && this.enclosingSimpleNames.equals(that.enclosingSimpleNames)
-          && this.simpleName.equals(that.simpleName);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(packageName, enclosingSimpleNames, simpleName);
-  }
-
-  @Override
-  public int compareTo(ClassName o) {
-    return canonicalName().compareTo(o.canonicalName());
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of(this);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
deleted file mode 100644
index edaba3a2d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-public final class ClassWriter extends TypeWriter {
-  private Optional<TypeName> superclass;
-  private final List<ConstructorWriter> constructorWriters;
-  private final List<TypeVariableName> typeParameters;
-
-  ClassWriter(ClassName className) {
-    super(className);
-    this.superclass = Optional.absent();
-    this.constructorWriters = Lists.newArrayList();
-    this.typeParameters = Lists.newArrayList();
-  }
-
-  public void setSuperclass(TypeName typeReference) {
-    checkState(!superclass.isPresent());
-    superclass = Optional.of(typeReference);
-  }
-
-  /**
-   * If {@code supertype} is a class, makes this class extend it; if it is an interface, makes this
-   * class implement it.
-   */
-  public void setSupertype(TypeElement supertype) {
-    switch (supertype.getKind()) {
-      case CLASS:
-        setSuperclass(ClassName.fromTypeElement(supertype));
-        break;
-      case INTERFACE:
-        addImplementedType(supertype);
-        break;
-      default:
-        throw new IllegalArgumentException(supertype + " must be a class or interface");
-    }
-  }
-
-  public ConstructorWriter addConstructor() {
-    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
-    constructorWriters.add(constructorWriter);
-    return constructorWriter;
-  }
-
-  public void addTypeParameter(TypeVariableName typeVariableName) {
-    this.typeParameters.add(typeVariableName);
-  }
-
-  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
-    Iterables.addAll(typeParameters, typeVariableNames);
-  }
-
-  public List<TypeVariableName> typeParameters() {
-    return ImmutableList.copyOf(typeParameters);
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet());
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append("class ").append(name.simpleName());
-    Writables.join(", ", typeParameters, "<", ">", appendable, context);
-    if (superclass.isPresent()) {
-      appendable.append(" extends ");
-      superclass.get().write(appendable, context);
-    }
-    Writables.join(", ", implementedTypes, " implements ", "", appendable, context);
-    appendable.append(" {");
-    if (!fieldWriters.isEmpty()) {
-      appendable.append('\n');
-    }
-    for (VariableWriter fieldWriter : fieldWriters.values()) {
-      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
-    }
-    for (ConstructorWriter constructorWriter : constructorWriters) {
-      appendable.append('\n');
-      if (!isDefaultConstructor(constructorWriter)) {
-        constructorWriter.write(new IndentingAppendable(appendable), context);
-      }
-    }
-    for (MethodWriter methodWriter : methodWriters) {
-      appendable.append('\n');
-      methodWriter.write(new IndentingAppendable(appendable), context);
-    }
-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
-      appendable.append('\n');
-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
-    }
-    appendable.append("}\n");
-    return appendable;
-  }
-
-  private static final Set<Modifier> VISIBILIY_MODIFIERS =
-      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
-
-  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
-    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
-        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
-        && constructorWriter.body().isEmpty();
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(nestedTypeWriters)
-        .append(fieldWriters.values())
-        .append(constructorWriters)
-        .append(methodWriters)
-        .append(implementedTypes)
-        .append(superclass.asSet())
-        .append(annotations)
-        .append(typeParameters)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
deleted file mode 100644
index 387c1ddf1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {
-  private final String name;
-  private final Map<String, VariableWriter> parameterWriters;
-  private final BlockWriter blockWriter;
-
-  ConstructorWriter(String name) {
-    this.name = name;
-    this.parameterWriters = Maps.newLinkedHashMap();
-    this.blockWriter = new BlockWriter();
-  }
-
-  public VariableWriter addParameter(Class<?> type, String name) {
-    return addParameter(ClassName.fromClass(type), name);
-  }
-
-  public VariableWriter addParameter(TypeElement type, String name) {
-    return addParameter(ClassName.fromTypeElement(type), name);
-  }
-
-  public VariableWriter addParameter(TypeWriter type, String name) {
-    return addParameter(type.name, name);
-  }
-
-  public VariableWriter addParameter(TypeName type, String name) {
-    VariableWriter parameterWriter = new VariableWriter(type, name);
-    parameterWriters.put(name, parameterWriter);
-    return parameterWriter;
-  }
-  
-  public Map<String, TypeName> parameters() {
-    ImmutableMap.Builder<String, TypeName> params = ImmutableMap.builder();
-    for (Map.Entry<String, VariableWriter> entry : parameterWriters.entrySet()) {
-      params.put(entry.getKey(), entry.getValue().type());
-    }
-    return params.build();
-  }
-
-  public BlockWriter body() {
-    return blockWriter;
-  }
-
-  private VariableWriter addParameter(ClassName type, String name) {
-    checkArgument(!parameterWriters.containsKey(name));
-    VariableWriter parameterWriter = new VariableWriter(type, name);
-    parameterWriters.put(name, parameterWriter);
-    return parameterWriter;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(parameterWriters.values())
-        .append(annotations)
-        .append(blockWriter)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append(name).append('(');
-    Writables.join(", ", parameterWriters.values(), appendable, context);
-    appendable.append(") {");
-    blockWriter.write(new IndentingAppendable(appendable), context);
-    return appendable.append("}\n");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
deleted file mode 100644
index 4ab017d79..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.Modifier;
-
-import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-public final class EnumWriter extends TypeWriter {
-  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();
-  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();
-
-  EnumWriter(ClassName name) {
-    super(name);
-  }
-
-  public ConstantWriter addConstant(String name) {
-    ConstantWriter constantWriter = new ConstantWriter(name);
-    constantWriters.put(name, constantWriter);
-    return constantWriter;
-  }
-
-  public ConstructorWriter addConstructor() {
-    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
-    constructorWriters.add(constructorWriter);
-    return constructorWriter;
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet());
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append("enum ").append(name.simpleName());
-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
-    if (implementedTypesIterator.hasNext()) {
-      appendable.append(" implements ");
-      implementedTypesIterator.next().write(appendable, context);
-      while (implementedTypesIterator.hasNext()) {
-        appendable.append(", ");
-        implementedTypesIterator.next().write(appendable, context);
-      }
-    }
-    appendable.append(" {");
-
-    checkState(!constantWriters.isEmpty(), "Cannot write an enum with no constants.");
-    appendable.append('\n');
-    ImmutableList<ConstantWriter> constantWriterList =
-        ImmutableList.copyOf(constantWriters.values());
-    for (ConstantWriter constantWriter
-        : constantWriterList.subList(0, constantWriterList.size() - 1)) {
-      constantWriter.write(appendable, context);
-      appendable.append(",\n");
-    }
-    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);
-    appendable.append(";\n");
-
-    if (!fieldWriters.isEmpty()) {
-      appendable.append('\n');
-    }
-    for (VariableWriter fieldWriter : fieldWriters.values()) {
-      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
-    }
-    for (ConstructorWriter constructorWriter : constructorWriters) {
-      appendable.append('\n');
-      if (!isDefaultConstructor(constructorWriter)) {
-        constructorWriter.write(new IndentingAppendable(appendable), context);
-      }
-    }
-    for (MethodWriter methodWriter : methodWriters) {
-      appendable.append('\n');
-      methodWriter.write(new IndentingAppendable(appendable), context);
-    }
-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
-      appendable.append('\n');
-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
-    }
-    appendable.append("}\n");
-    return appendable;
-  }
-
-  private static final Set<Modifier> VISIBILIY_MODIFIERS =
-      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
-
-  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
-    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
-        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
-        && constructorWriter.body().isEmpty();
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(nestedTypeWriters)
-        .append(constantWriters.values())
-        .append(fieldWriters.values())
-        .append(constructorWriters)
-        .append(methodWriters)
-        .append(implementedTypes)
-        .append(annotations)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-
-  public static final class ConstantWriter implements Writable, HasClassReferences {
-    private final String name;
-    private final List<Snippet> constructorSnippets;
-
-    private ConstantWriter(String name) {
-      this.name = name;
-      this.constructorSnippets = Lists.newArrayList();
-    }
-
-    ConstantWriter addArgument(Snippet snippet) {
-      constructorSnippets.add(snippet);
-      return this;
-    }
-
-    @Override
-    public Appendable write(Appendable appendable, Context context) throws IOException {
-      appendable.append(name);
-      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();
-      if (snippetIterator.hasNext()) {
-        appendable.append('(');
-        snippetIterator.next().write(appendable, context);
-        while (snippetIterator.hasNext()) {
-          appendable.append(", ");
-          snippetIterator.next().write(appendable, context);
-        }
-        appendable.append(')');
-      }
-      return appendable;
-    }
-
-    @Override
-    public Set<ClassName> referencedClasses() {
-      return FluentIterable.from(constructorSnippets)
-          .transformAndConcat(HasClassReferences.COMBINER)
-          .toSet();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
deleted file mode 100644
index b45e5d9ae..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import java.io.IOException;
-import java.util.Set;
-
-public final class FieldWriter extends VariableWriter {
-  private Optional<Snippet> initializer;
-
-  FieldWriter(TypeName type, String name) {
-    super(type, name);
-    this.initializer = Optional.absent();
-  }
-
-  public void setInitializer(Snippet initializer) {
-    this.initializer = Optional.of(initializer);
-  }
-
-  public void setInitializer(String initializer, Object... args) {
-    this.initializer = Optional.of(Snippet.format(initializer, args));
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    super.write(appendable, context);
-    if (initializer.isPresent()) {
-      appendable.append(" = ");
-      initializer.get().write(appendable, context);
-    }
-    appendable.append(';');
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(ImmutableList.of(type()), initializer.asSet(), annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
deleted file mode 100644
index e463ea2cb..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import java.util.Set;
-
-public interface HasClassReferences {
-  Set<ClassName> referencedClasses();
-
-  static final Function<HasClassReferences, Set<ClassName>> COMBINER =
-      new Function<HasClassReferences, Set<ClassName>>() {
-        @Override
-        public Set<ClassName> apply(HasClassReferences input) {
-          return input.referencedClasses();
-        }
-      };
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
deleted file mode 100644
index a6909ed10..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-interface HasTypeName {
-  TypeName name();
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java b/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
deleted file mode 100644
index d96f8a3a2..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.AbstractIterator;
-import java.io.IOException;
-import java.util.Iterator;
-
-final class IndentingAppendable implements Appendable {
-  private final String indentation;
-  private final Appendable delegate;
-  private boolean requiresIndent = true;
-
-  IndentingAppendable(Appendable delegate) {
-    this("  ", delegate);
-  }
-
-  IndentingAppendable(String indentation, Appendable delegate) {
-    this.indentation = indentation;
-    this.delegate = delegate;
-  }
-
-  @Override
-  public Appendable append(CharSequence csq) throws IOException {
-    return append(csq, 0, csq.length());
-  }
-
-  @Override
-  public Appendable append(CharSequence csq, int start, int end) throws IOException {
-    Iterator<CharSequence> lines = lines(csq, start, end);
-    while (lines.hasNext()) {
-      CharSequence line = lines.next();
-      maybeIndent();
-      delegate.append(line);
-      if (line.charAt(line.length() - 1) == '\n') {
-        requiresIndent = true;
-      }
-    }
-    return this;
-  }
-
-  @Override
-  public Appendable append(char c) throws IOException {
-    maybeIndent();
-    delegate.append(c);
-    if (c == '\n') {
-      requiresIndent = true;
-    }
-    return this;
-  }
-
-  void maybeIndent() throws IOException {
-    if (requiresIndent) {
-      delegate.append(indentation);
-    }
-    requiresIndent = false;
-  }
-
-  private static Iterator<CharSequence> lines(
-      final CharSequence csq, final int start, final int end) {
-    return new AbstractIterator<CharSequence>() {
-      int index = start;
-
-      @Override protected CharSequence computeNext() {
-        int nextStart = index;
-        while (index < end && csq.charAt(index) != '\n') {
-          index++;
-        }
-        if (index < end && csq.charAt(index) == '\n') {
-          index++;
-        }
-        int nextEnd = index;
-        return nextStart >= end
-            ? endOfData()
-            : csq.subSequence(nextStart, nextEnd);
-      }
-    };
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
deleted file mode 100644
index ffcfc7562..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-
-public final class InterfaceWriter extends TypeWriter {
-  private final List<TypeVariableName> typeVariables;
-  InterfaceWriter(ClassName name) {
-    super(name);
-    this.typeVariables = Lists.newArrayList();
-  }
-
-  public void addTypeVariable(TypeVariableName typeVariable) {
-    this.typeVariables.add(typeVariable);
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet());
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append("interface ").append(name.simpleName());
-    if (!typeVariables.isEmpty()) {
-      appendable.append('<');
-      Joiner.on(", ").appendTo(appendable, typeVariables);
-      appendable.append('>');
-    }
-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
-    if (implementedTypesIterator.hasNext()) {
-      appendable.append(" extends ");
-      implementedTypesIterator.next().write(appendable, context);
-      while (implementedTypesIterator.hasNext()) {
-        appendable.append(", ");
-        implementedTypesIterator.next().write(appendable, context);
-      }
-    }
-    appendable.append(" {");
-    for (MethodWriter methodWriter : methodWriters) {
-      appendable.append('\n');
-      methodWriter.write(new IndentingAppendable(appendable), context);
-    }
-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
-      appendable.append('\n');
-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
-    }
-    appendable.append("}\n");
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(nestedTypeWriters)
-        .append(methodWriters)
-        .append(implementedTypes)
-        .append(annotations)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
deleted file mode 100644
index 674dd621e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.BiMap;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.HashBiMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.Sets;
-import com.google.common.io.CharSink;
-import com.google.common.io.CharSource;
-import com.google.googlejavaformat.java.Formatter;
-import com.google.googlejavaformat.java.FormatterException;
-import dagger.internal.codegen.ComponentProcessor;
-import dagger.internal.codegen.writer.Writable.Context;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Generated;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.PackageElement;
-import javax.tools.JavaFileObject;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static java.util.Collections.unmodifiableList;
-
-/**
- * Writes a single compilation unit.
- */
-public final class JavaWriter {
-  public static JavaWriter inPackage(String packageName) {
-    return new JavaWriter(packageName);
-  }
-
-  public static JavaWriter inPackage(Package enclosingPackage) {
-    return new JavaWriter(enclosingPackage.getName());
-  }
-
-  public static JavaWriter inPackage(PackageElement packageElement) {
-    return new JavaWriter(packageElement.getQualifiedName().toString());
-  }
-
-  private final String packageName;
-  // TODO(gak): disallow multiple types in a file?
-  private final List<TypeWriter> typeWriters;
-  private final List<ClassName> explicitImports;
-
-  private JavaWriter(String packageName) {
-    this.packageName = packageName;
-    this.typeWriters = Lists.newArrayList();
-    this.explicitImports = Lists.newArrayList();
-  }
-
-  public List<TypeWriter> getTypeWriters() {
-    return unmodifiableList(typeWriters);
-  }
-
-  public JavaWriter addImport(Class<?> importedClass) {
-    explicitImports.add(ClassName.fromClass(importedClass));
-    return this;
-  }
-
-  public ClassWriter addClass(String simpleName) {
-    checkNotNull(simpleName);
-    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));
-    typeWriters.add(classWriter);
-    return classWriter;
-  }
-
-  public EnumWriter addEnum(String simpleName) {
-    checkNotNull(simpleName);
-    EnumWriter writer = new EnumWriter(ClassName.create(packageName, simpleName));
-    typeWriters.add(writer);
-    return writer;
-  }
-
-  public InterfaceWriter addInterface(String simpleName) {
-    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));
-    typeWriters.add(writer);
-    return writer;
-  }
-
-  public void markGenerated(boolean generatedAnnotationAvailable) {
-    for (TypeWriter typeWriter : typeWriters) {
-      typeWriter.markGenerated(generatedAnnotationAvailable);
-    }
-  }
-
-  public <A extends Appendable> A write(A appendable) throws IOException {
-    if (!packageName.isEmpty()) {
-      appendable.append("package ").append(packageName).append(";\n\n");
-    }
-
-    // write imports
-    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-
-    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()
-        .addAll(explicitImports)
-        .addAll(classNames)
-        .build();
-    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet();
-
-    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();
-    Deque<TypeWriter> declaredTypes = new ArrayDeque<>(typeWriters);
-    while (!declaredTypes.isEmpty()) {
-      TypeWriter currentType = declaredTypes.pop();
-      declaredSimpleNamesBuilder.add(currentType.name().simpleName());
-      declaredTypes.addAll(currentType.nestedTypeWriters);
-    }
-
-    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();
-
-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
-    for (ClassName className : importCandidates) {
-      if (!(className.packageName().equals(packageName)
-              && !className.enclosingClassName().isPresent())
-          && !(className.packageName().equals("java.lang")
-              && className.enclosingSimpleNames().isEmpty())
-          && !typeNames.contains(className.topLevelClassName())) {
-        Optional<ClassName> importCandidate = Optional.of(className);
-        while (importCandidate.isPresent()
-            && (importedClassIndex.containsKey(importCandidate.get().simpleName())
-                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {
-          importCandidate = importCandidate.get().enclosingClassName();
-        }
-        if (importCandidate.isPresent()) {
-          appendable.append("import ").append(importCandidate.get().canonicalName()).append(";\n");
-          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());
-        }
-      }
-    }
-
-    appendable.append('\n');
-
-    CompilationUnitContext context =
-        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));
-
-    // write types
-    for (TypeWriter typeWriter : typeWriters) {
-      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\n');
-    }
-    return appendable;
-  }
-
-  public void file(Filer filer, Iterable<? extends Element> originatingElements)
-      throws IOException {
-    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);
-  }
-
-  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)
-      throws IOException {
-    final JavaFileObject sourceFile = filer.createSourceFile(name,
-        Iterables.toArray(originatingElements, Element.class));
-    try {
-      new Formatter().formatSource(
-          CharSource.wrap(write(new StringBuilder())),
-          new CharSink() {
-            @Override public Writer openStream() throws IOException {
-              return sourceFile.openWriter();
-            }
-          });
-    } catch (FormatterException e) {
-      throw new IllegalStateException(
-          "The writer produced code that could not be parsed by the formatter", e);
-    }
-  }
-
-  @Override
-  public String toString() {
-    try {
-      return write(new StringBuilder()).toString();
-    } catch (IOException e) {
-      throw new AssertionError();
-    }
-  }
-
-  static final class CompilationUnitContext implements Context {
-    private final String packageName;
-    private final ImmutableSortedSet<ClassName> visibleClasses;
-
-    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {
-      this.packageName = packageName;
-      this.visibleClasses =
-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);
-    }
-
-    @Override
-    public Context createSubcontext(Set<ClassName> newTypes) {
-      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));
-    }
-
-    @Override
-    public String sourceReferenceForClassName(ClassName className) {
-      if (isImported(className)) {
-        return className.simpleName();
-      }
-      Optional<ClassName> enclosingClassName = className.enclosingClassName();
-      while (enclosingClassName.isPresent()) {
-        if (isImported(enclosingClassName.get())) {
-          return enclosingClassName.get().simpleName()
-              + className.canonicalName()
-                  .substring(enclosingClassName.get().canonicalName().length());
-        }
-        enclosingClassName = enclosingClassName.get().enclosingClassName();
-      }
-      return className.canonicalName();
-    }
-
-    private boolean collidesWithVisibleClass(ClassName className) {
-      return collidesWithVisibleClass(className.simpleName());
-    }
-
-    private boolean collidesWithVisibleClass(String simpleName) {
-      return FluentIterable.from(visibleClasses)
-          .transform(new Function<ClassName, String>() {
-            @Override public String apply(ClassName input) {
-              return input.simpleName();
-            }
-          })
-          .contains(simpleName);
-    }
-
-    private boolean isImported(ClassName className) {
-      return (packageName.equals(className.packageName())
-              && !className.enclosingClassName().isPresent()
-              && !collidesWithVisibleClass(className)) // need to account for scope & hiding
-          || visibleClasses.contains(className)
-          || (className.packageName().equals("java.lang")
-              && className.enclosingSimpleNames().isEmpty());
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
deleted file mode 100644
index eb4ff8d51..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-public final class MethodWriter extends Modifiable implements HasClassReferences, Writable {
-  private final TypeName returnType;
-  private final String name;
-  private final Map<String, VariableWriter> parameterWriters;
-  private final List<TypeVariableName> typeParameters;
-  private Optional<BlockWriter> body;
-
-  MethodWriter(TypeName returnType, String name) {
-    this.returnType = returnType;
-    this.name = name;
-    this.parameterWriters = Maps.newLinkedHashMap();
-    this.typeParameters = Lists.newArrayList();
-    this.body = Optional.absent();
-  }
-
-  public String name() {
-    return name;
-  }
-  
-  public TypeName returnType() {
-    return returnType;
-  }
-  
-  public void addTypeParameter(TypeVariableName typeVariableName) {
-    this.typeParameters.add(typeVariableName);
-  }
-  
-  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
-    Iterables.addAll(typeParameters, typeVariableNames);
-  }
-
-  public VariableWriter addParameter(Class<?> type, String name) {
-    return addParameter(ClassName.fromClass(type), name);
-  }
-
-  public VariableWriter addParameter(TypeElement type, String name) {
-    return addParameter(ClassName.fromTypeElement(type), name);
-  }
-
-  public VariableWriter addParameter(TypeWriter type, String name) {
-    return addParameter(type.name, name);
-  }
-
-  public VariableWriter addParameter(TypeName type, String name) {
-    checkArgument(!parameterWriters.containsKey(name));
-    VariableWriter parameterWriter = new VariableWriter(type, name);
-    parameterWriters.put(name, parameterWriter);
-    return parameterWriter;
-  }
-
-  public BlockWriter body() {
-    if (body.isPresent()) {
-      return body.get();
-    } else {
-      BlockWriter blockWriter = new BlockWriter();
-      body = Optional.of(blockWriter);
-      return blockWriter;
-    }
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable);
-    Writables.join(", ", typeParameters, "<", "> ", appendable, context);
-    returnType.write(appendable, context);
-    appendable.append(' ').append(name).append('(');
-    Writables.join(", ", parameterWriters.values(), appendable, context);
-    appendable.append(")");
-    if (body.isPresent()) {
-      appendable.append(" {");
-      body.get().write(new IndentingAppendable(appendable), context);
-      appendable.append("}\n");
-    } else {
-      appendable.append(";\n");
-    }
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(parameterWriters.values())
-        .append(returnType)
-        .append(body.asSet())
-        .append(annotations)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
deleted file mode 100644
index 91072baf6..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import dagger.internal.codegen.ComponentProcessor;
-import dagger.internal.codegen.writer.Writable.Context;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Generated;
-import javax.lang.model.element.Modifier;
-
-public abstract class Modifiable {
-
-  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
-
-  final Set<Modifier> modifiers;
-  final List<AnnotationWriter> annotations;
-  // This is not intended to be widely used; handling comments should be deferred to
-  // when Javapoet is adopted
-  private String generatedComment;
-
-  Modifiable() {
-    this.modifiers = EnumSet.noneOf(Modifier.class);
-    this.annotations = Lists.newArrayList();
-  }
-
-  public void addModifiers(Modifier first, Modifier... rest) {
-    addModifiers(Lists.asList(first, rest));
-  }
-
-  public void addModifiers(Iterable<Modifier> modifiers) {
-    Iterables.addAll(this.modifiers, modifiers);
-  }
-
-  public AnnotationWriter annotate(ClassName annotation) {
-    AnnotationWriter annotationWriter = new AnnotationWriter(annotation);
-    this.annotations.add(annotationWriter);
-    return annotationWriter;
-  }
-
-  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
-    return annotate(ClassName.fromClass(annotation));
-  }
-
-  public void markGenerated(boolean generatedAnnotationAvailable) {
-    if (generatedAnnotationAvailable) {
-      AnnotationWriter annotation = annotate(Generated.class);
-      annotation.setValue(ComponentProcessor.class.getName());
-      annotation.setMember("comments", GENERATED_COMMENTS);
-    } else {
-      generatedComment =
-          String.format(
-              "// Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
-    }
-  }
-
-  Appendable writeModifiers(Appendable appendable) throws IOException {
-    for (Modifier modifier : modifiers) {
-      appendable.append(modifier.toString()).append(' ');
-    }
-    return appendable;
-  }
-
-  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {
-    for (AnnotationWriter annotationWriter : annotations) {
-      annotationWriter.write(appendable, context).append('\n');
-    }
-    if (generatedComment != null) {
-      appendable.append(generatedComment).append('\n');
-    }
-    return appendable;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
deleted file mode 100644
index 0d3588b77..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-
-enum NullName implements TypeName {
-  NULL;
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append("null");
-  }
-
-  @Override
-  public String toString() {
-    return "null";
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
deleted file mode 100644
index e46a96186..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Objects;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Set;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Verify.verify;
-
-public final class ParameterizedTypeName implements TypeName {
-  private final ClassName type;
-  private final ImmutableList<TypeName> parameters;
-
-  ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
-    this.type = type;
-    this.parameters = ImmutableList.<TypeName>copyOf(parameters);
-  }
-  
-  public ClassName type() {
-    return type;
-  }
-  
-  public ImmutableList<TypeName> parameters() {
-    return parameters;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>()
-        .add(type);
-    for (TypeName parameter : parameters) {
-      builder.addAll(parameter.referencedClasses());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append(context.sourceReferenceForClassName(type));
-    Iterator<? extends TypeName> parameterIterator = parameters.iterator();
-    verify(parameterIterator.hasNext(), type.toString());
-    appendable.append('<');
-    parameterIterator.next().write(appendable, context);
-    while (parameterIterator.hasNext()) {
-      appendable.append(", ");
-      parameterIterator.next().write(appendable, context);
-    }
-    appendable.append('>');
-    return appendable;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof ParameterizedTypeName) {
-      ParameterizedTypeName that = (ParameterizedTypeName) obj;
-      return this.type.equals(that.type)
-          && this.parameters.equals(that.parameters);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(type, parameters);
-  }
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-
-  public static ParameterizedTypeName create(ClassName className,
-      TypeName... parameters) {
-    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
-  }
-
-  public static ParameterizedTypeName create(ClassName className,
-      Iterable<? extends TypeName> parameters) {
-    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
-  }
-
-  public static ParameterizedTypeName create(Class<?> parameterizedClass,
-      TypeName... parameters) {
-    checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);
-    return new ParameterizedTypeName(ClassName.fromClass(parameterizedClass),
-        ImmutableList.copyOf(parameters));
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
deleted file mode 100644
index 94961dd7a..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Ascii;
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-import javax.lang.model.type.PrimitiveType;
-
-public enum PrimitiveName implements TypeName {
-  BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of();
-  }
-
-  @Override
-  public String toString() {
-    return Ascii.toLowerCase(name());
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append(toString());
-  }
-
-  static PrimitiveName forTypeMirror(PrimitiveType mirror) {
-    switch (mirror.getKind()) {
-      case BOOLEAN:
-        return BOOLEAN;
-      case BYTE:
-        return BYTE;
-      case SHORT:
-        return SHORT;
-      case INT:
-        return INT;
-      case LONG:
-        return LONG;
-      case CHAR:
-        return CHAR;
-      case FLOAT:
-        return FLOAT;
-      case DOUBLE:
-        return DOUBLE;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  static PrimitiveName forClass(Class<?> primitiveClass) {
-    if (boolean.class.equals(primitiveClass)) {
-      return BOOLEAN;
-    }
-    if (byte.class.equals(primitiveClass)) {
-      return BYTE;
-    }
-    if (short.class.equals(primitiveClass)) {
-      return SHORT;
-    }
-    if (int.class.equals(primitiveClass)) {
-      return INT;
-    }
-    if (long.class.equals(primitiveClass)) {
-      return LONG;
-    }
-    if (char.class.equals(primitiveClass)) {
-      return CHAR;
-    }
-    if (float.class.equals(primitiveClass)) {
-      return FLOAT;
-    }
-    if (double.class.equals(primitiveClass)) {
-      return DOUBLE;
-    }
-    throw new IllegalArgumentException(primitiveClass + " is not a primitive type");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
deleted file mode 100644
index 80ab944f8..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Formatter;
-import java.util.Iterator;
-import java.util.Set;
-
-public abstract class Snippet implements HasClassReferences, Writable {
-
-  abstract ImmutableSet<TypeName> types();
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-
-  @Override
-  public final Set<ClassName> referencedClasses() {
-    return FluentIterable.from(types())
-        .transformAndConcat(
-            new Function<TypeName, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(TypeName input) {
-                return input.referencedClasses();
-              }
-            })
-        .toSet();
-  }
-
-  private static final class BasicSnippet extends Snippet {
-    final String format;
-    final ImmutableSet<TypeName> types;
-    final ImmutableList<Object> args;
-
-    BasicSnippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
-      this.format = format;
-      this.types = types;
-      this.args = args;
-    }
-
-    @Override
-    ImmutableSet<TypeName> types() {
-      return types;
-    }
-
-    @Override
-    public Appendable write(Appendable appendable, Context context) throws IOException {
-      ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
-      for (Object arg : args) {
-        if (arg instanceof Writable) {
-          formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
-        } else {
-          formattedArgsBuilder.add(arg);
-        }
-      }
-
-      @SuppressWarnings("resource") // intentionally don't close the formatter
-      Formatter formatter = new Formatter(appendable);
-      formatter.format(format, Iterables.toArray(formattedArgsBuilder.build(), Object.class));
-
-      return appendable;
-    }
-  }
-
-  private static final class CompoundSnippet extends Snippet {
-    final String joinToken;
-    final ImmutableList<Snippet> snippets;
-
-    CompoundSnippet(String joinToken, ImmutableList<Snippet> snippets) {
-      this.joinToken = joinToken;
-      this.snippets = snippets;
-    }
-
-    @Override
-    ImmutableSet<TypeName> types() {
-      return FluentIterable.from(snippets)
-          .transformAndConcat(
-              new Function<Snippet, Iterable<TypeName>>() {
-                @Override
-                public Iterable<TypeName> apply(Snippet input) {
-                  return input.types();
-                }
-              })
-          .toSet();
-    }
-
-    @Override
-    public Appendable write(Appendable appendable, Context context) throws IOException {
-      Iterator<Snippet> snippetIterator = snippets.iterator();
-      if (snippetIterator.hasNext()) {
-        Snippet firstSnippet = snippetIterator.next();
-        firstSnippet.write(appendable, context);
-        while (snippetIterator.hasNext()) {
-          Snippet nextSnippet = snippetIterator.next();
-          appendable.append(joinToken);
-          nextSnippet.write(appendable, context);
-        }
-      }
-      return appendable;
-    }
-  }
-
-  public static Snippet format(String format, Object... args) {
-    ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
-    for (Object arg : args) {
-      if (arg instanceof Snippet) {
-        types.addAll(((Snippet) arg).types());
-      }
-      if (arg instanceof TypeName) {
-        types.add((TypeName) arg);
-      }
-      if (arg instanceof HasTypeName) {
-        types.add(((HasTypeName) arg).name());
-      }
-    }
-    return new BasicSnippet(format, types.build(), ImmutableList.copyOf(args));
-  }
-
-  public static Snippet format(String format, Iterable<? extends Object> args) {
-    return format(format, Iterables.toArray(args, Object.class));
-  }
-
-  public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors) {
-    return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), "%s")),
-        selectors);
-  }
-
-  public static Snippet nullCheck(Object thingToCheck) {
-    return format("if (%s == null) { throw new NullPointerException(); } ", thingToCheck);
-  }
-
-  public static Snippet nullCheck(Object thingToCheck, String message) {
-    return format("if (%s == null) { throw new NullPointerException(%s); } ",
-        thingToCheck,
-        StringLiteral.forValue(message));
-  }
-
-  public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
-    return join(", ", parameterSnippets);
-  }
-
-  /**
-   * A snippet that concatenates its arguments with each snippet separated by a new line.
-   */
-  public static Snippet concat(Iterable<Snippet> snippets) {
-    return join("\n", snippets);
-  }
-
-  /**
-   * A snippet that joins its arguments with {@code joiner}.
-   */
-  public static Snippet join(String joinToken, Iterable<Snippet> snippets) {
-    return new CompoundSnippet(joinToken, ImmutableList.copyOf(snippets));
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java b/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
deleted file mode 100644
index 2d059f9af..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import java.util.Formatter;
-
-/**
- * Represents a string literal as found in Java source code.
- */
-public final class StringLiteral {
-  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */
-  public static StringLiteral forValue(String value) {
-    return new StringLiteral(value, stringLiteral(value));
-  }
-
-  /** Returns the string literal representing {@code data}, including wrapping quotes. */
-  private static String stringLiteral(String value) {
-    StringBuilder result = new StringBuilder();
-    result.append('"');
-    for (int i = 0; i < value.length(); i++) {
-      char c = value.charAt(i);
-      switch (c) {
-        case '"':
-          result.append("\\\"");
-          break;
-        case '\\':
-          result.append("\\\\");
-          break;
-        case '\b':
-          result.append("\\b");
-          break;
-        case '\t':
-          result.append("\\t");
-          break;
-        case '\n':
-          result.append("\\n");
-          break;
-        case '\f':
-          result.append("\\f");
-          break;
-        case '\r':
-          result.append("\\r");
-          break;
-        default:
-          if (Character.isISOControl(c)) {
-            new Formatter(result).format("\\u%04x", (int) c);
-          } else {
-            result.append(c);
-          }
-      }
-    }
-    result.append('"');
-    return result.toString();
-  }
-
-  private final String value;
-  private final String literal;
-
-  private StringLiteral(String value, String literal) {
-    this.value = value;
-    this.literal = literal;
-  }
-
-  public String value() {
-    return value;
-  }
-
-  public String literal() {
-    return literal;
-  }
-
-  @Override
-  public String toString() {
-    return literal;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == this) {
-      return true;
-    } else if (obj instanceof StringLiteral) {
-      return this.value.equals(((StringLiteral) obj).value);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return value.hashCode();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
deleted file mode 100644
index e0daf5312..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-public interface TypeName extends HasClassReferences, Writable {
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
deleted file mode 100644
index 4bc234739..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.NoType;
-import javax.lang.model.type.NullType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-public final class TypeNames {
-  static final Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =
-      new Function<TypeMirror, TypeName>() {
-        @Override public TypeName apply(TypeMirror input) {
-          return forTypeMirror(input);
-        }
-      };
-
-  public static TypeName forClass(Class<?> clazz) {
-    if (clazz.isPrimitive()) {
-      return PrimitiveName.forClass(clazz);
-    } else if (void.class.equals(clazz)) {
-      return VoidName.VOID;
-    } else if (clazz.isArray()) {
-      return new ArrayTypeName(forClass(clazz.getComponentType()));
-    } else {
-      return ClassName.fromClass(clazz);
-    }
-  }
-
-  public static TypeName forTypeMirror(TypeMirror mirror) {
-    return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {
-      @Override
-      protected TypeName defaultAction(TypeMirror e, Void p) {
-        throw new IllegalArgumentException(e.toString());
-      }
-      
-      @Override
-      public TypeName visitTypeVariable(TypeVariable t, Void p) {
-        return TypeVariableName.fromTypeVariable(t);
-      }
-
-      @Override
-      public ArrayTypeName visitArray(ArrayType t, Void p) {
-        return new ArrayTypeName(t.getComponentType().accept(this, null));
-      }
-
-      @Override
-      public TypeName visitDeclared(DeclaredType t, Void p) {
-        return t.getTypeArguments().isEmpty()
-            ? ClassName.fromTypeElement((TypeElement) t.asElement())
-            : new ParameterizedTypeName(
-                ClassName.fromTypeElement((TypeElement) t.asElement()),
-                FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));
-      }
-
-      @Override
-      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {
-        return PrimitiveName.forTypeMirror(t);
-      }
-
-      @Override
-      public WildcardName visitWildcard(WildcardType t, Void p) {
-        return WildcardName.forTypeMirror(t);
-      }
-
-      @Override
-      public NullName visitNull(NullType t, Void p) {
-        return NullName.NULL;
-      }
-
-      @Override
-      public TypeName visitNoType(NoType t, Void p) {
-        switch (t.getKind()) {
-          case VOID:
-            return VoidName.VOID;
-          case PACKAGE:
-            throw new IllegalArgumentException();
-          default:
-            throw new IllegalStateException();
-        }
-      }
-    }, null);
-  }
-
-  private TypeNames() {
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
deleted file mode 100644
index c6ee533ca..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Objects;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Set;
-import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-
-public final class TypeVariableName implements TypeName {
-  private final CharSequence name;
-  private final Iterable<? extends TypeName> extendsBounds;
-
-  TypeVariableName(CharSequence name, Iterable<? extends TypeName> extendsBounds) {
-    this.name = name;
-    this.extendsBounds = extendsBounds;
-  }
-
-  public CharSequence name() {
-    return name;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
-    for (TypeName bound : extendsBounds) {
-      builder.addAll(bound.referencedClasses());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append(name);
-    if (!Iterables.isEmpty(extendsBounds)) {
-      appendable.append(" extends ");
-      Iterator<? extends TypeName> iter = extendsBounds.iterator();
-      iter.next().write(appendable, context);
-      while (iter.hasNext()) {
-        appendable.append(" & ");
-        iter.next().write(appendable, context);  
-      }
-    }
-    return appendable;
-  }
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof TypeVariableName) {
-      TypeVariableName that = (TypeVariableName) obj;
-      return this.name.toString().equals(that.name.toString())
-          && this.extendsBounds.equals(that.extendsBounds);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(name, extendsBounds);
-  }
-
-  static TypeVariableName named(CharSequence name) {
-    return new TypeVariableName(name, ImmutableList.<TypeName>of());
-  }
-  
-  public static TypeVariableName fromTypeVariable(TypeVariable variable) {
-    // Note: We don't have any use right now for the bounds because these are references
-    // to the type & not the specification of the type itself.  We never generate
-    // code with type variables that include upper or lower bounds.
-    return named(variable.asElement().getSimpleName());
-  }
-
-  // TODO(sameb): Consider making this a whole different thing: TypeParameterName since it
-  // has different semantics than a TypeVariable (parameters only have upper bounds).
-  public static TypeVariableName fromTypeParameterElement(TypeParameterElement element) {
-    // We filter out bounds of type Object because those would just clutter the generated code.
-    Iterable<? extends TypeName> bounds =
-        FluentIterable.from(element.getBounds())
-            .filter(new Predicate<TypeMirror>() {
-              @Override public boolean apply(TypeMirror input) {
-                return !MoreTypes.isType(input) || !MoreTypes.isTypeOf(Object.class, input);
-              }
-            })
-            .transform(TypeNames.FOR_TYPE_MIRROR);
-    return new TypeVariableName(element.getSimpleName(), bounds);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
deleted file mode 100644
index b13d0831e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import java.util.List;
-import java.util.Map;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * Only named types. Doesn't cover anonymous inner classes.
- */
-public abstract class TypeWriter /* ha ha */ extends Modifiable
-    implements Writable, HasTypeName, HasClassReferences {
-  final ClassName name;
-  final List<TypeName> implementedTypes;
-  final List<MethodWriter> methodWriters;
-  final List<TypeWriter> nestedTypeWriters;
-  final Map<String, FieldWriter> fieldWriters;
-
-  TypeWriter(ClassName name) {
-    this.name = name;
-    this.implementedTypes = Lists.newArrayList();
-    this.methodWriters = Lists.newArrayList();
-    this.nestedTypeWriters = Lists.newArrayList();
-    this.fieldWriters = Maps.newLinkedHashMap();
-  }
-
-  @Override
-  public ClassName name() {
-    return name;
-  }
-
-  public MethodWriter addMethod(TypeWriter returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeMirror returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeName returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(Class<?> returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(ClassName.fromClass(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public ClassWriter addNestedClass(String name) {
-    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
-    nestedTypeWriters.add(innerClassWriter);
-    return innerClassWriter;
-  }
-
-  public void addImplementedType(TypeName typeReference) {
-    implementedTypes.add(typeReference);
-  }
-
-  public void addImplementedType(TypeElement typeElement) {
-    implementedTypes.add(ClassName.fromTypeElement(typeElement));
-  }
-
-  public FieldWriter addField(Class<?> type, String name) {
-    return addField(ClassName.fromClass(type), name);
-  }
-
-  public FieldWriter addField(TypeElement type, String name) {
-    return addField(ClassName.fromTypeElement(type), name);
-  }
-
-  public FieldWriter addField(TypeName type, String name) {
-    String candidateName = name;
-    int differentiator = 1;
-    while (fieldWriters.containsKey(candidateName)) {
-      candidateName = name + differentiator;
-      differentiator++;
-    }
-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
-    fieldWriters.put(candidateName, fieldWriter);
-    return fieldWriter;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
deleted file mode 100644
index 58ee1e494..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import java.io.IOException;
-import java.util.Set;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
-  private final TypeName type;
-  private final String name;
-
-  VariableWriter(TypeName type, String name) {
-    this.type = checkNotNull(type);
-    this.name = checkNotNull(name);
-  }
-
-  public TypeName type() {
-    return type;
-  }
-
-  public String name() {
-    return name;
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable);
-    type.write(appendable, context);
-    return appendable.append(' ').append(name);
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(annotations)
-        .append(type)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
deleted file mode 100644
index f82a4cab4..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-
-public enum VoidName implements TypeName {
-  VOID;
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of();
-  }
-
-  @Override
-  public String toString() {
-    return "void";
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append("void");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
deleted file mode 100644
index 7756f9311..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-import javax.lang.model.type.WildcardType;
-
-import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;
-
-public final class WildcardName implements TypeName {
-  private final Optional<TypeName> extendsBound;
-  private final Optional<TypeName> superBound;
-
-  WildcardName(Optional<TypeName> extendsBound,
-      Optional<TypeName> superBound) {
-    this.extendsBound = extendsBound;
-    this.superBound = superBound;
-  }
-
-  static WildcardName forTypeMirror(WildcardType mirror) {
-    return new WildcardName(
-        Optional.fromNullable(mirror.getExtendsBound()).transform(FOR_TYPE_MIRROR),
-        Optional.fromNullable(mirror.getSuperBound()).transform(FOR_TYPE_MIRROR));
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
-    if (extendsBound.isPresent()) {
-      builder.addAll(extendsBound.get().referencedClasses());
-    }
-    if (superBound.isPresent()) {
-      builder.addAll(superBound.get().referencedClasses());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append('?');
-    if (extendsBound.isPresent()) {
-      appendable.append(" extends ");
-      extendsBound.get().write(appendable, context);
-    }
-    if (superBound.isPresent()) {
-      appendable.append(" super ");
-      superBound.get().write(appendable, context);
-    }
-    return appendable;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
deleted file mode 100644
index 9a88f433d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import java.io.IOException;
-import java.util.Set;
-
-interface Writable {
-  interface Context {
-    String sourceReferenceForClassName(ClassName className);
-    Context createSubcontext(Set<ClassName> newTypes);
-  }
-
-  Appendable write(Appendable appendable, Context context) throws IOException;
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
deleted file mode 100644
index 0186cbfcf..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import dagger.internal.codegen.writer.Writable.Context;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Set;
-
-final class Writables {
-
-  /**
-   * Joins the writables by the given delimiter, writing out the
-   * prefix & suffix if there's at least one element.
-   */
-  static void join(String delimiter, Iterable<? extends Writable> writables,
-      String prefix, String suffix,
-      Appendable appendable, Context context) throws IOException {
-    Iterator<? extends Writable> iter = writables.iterator();
-    if (iter.hasNext()) {
-      appendable.append(prefix);
-      iter.next().write(appendable, context);
-      while (iter.hasNext()) {
-        appendable.append(delimiter);
-        iter.next().write(appendable, context);
-      }
-      appendable.append(suffix);
-    }
-  }
-
-  /** Joins the writables by the given delimiter. */
-  static void join(String delimiter, Iterable<? extends Writable> writables,
-      Appendable appendable, Context context) throws IOException {
-    join(delimiter, writables, "", "", appendable, context);
-  }
-
-  static Writable toStringWritable(final Object object) {
-    return new Writable() {
-      @Override
-      public Appendable write(Appendable appendable, Context context) throws IOException {
-        return appendable.append(object.toString());
-      }
-    };
-  }
-
-  private static final Context DEFAULT_CONTEXT = new Context() {
-    @Override
-    public String sourceReferenceForClassName(ClassName className) {
-      return className.canonicalName();
-    }
-
-    @Override
-    public Context createSubcontext(Set<ClassName> newTypes) {
-      throw new UnsupportedOperationException();
-    }
-  };
-
-  static String writeToString(Writable writable) {
-    StringBuilder builder = new StringBuilder();
-    try {
-      writable.write(builder, DEFAULT_CONTEXT);
-    } catch (IOException e) {
-      throw new AssertionError("StringBuilder doesn't throw IOException" + e);
-    }
-    return builder.toString();
-  }
-
-  private Writables() {
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
index b8349156d..607b5cbc0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -17,11 +17,10 @@
 
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
@@ -63,14 +62,13 @@ private ExecutableElement getXConstructor() {
   @Test public void frameworkType() {
     Key key = keyFactory.forInjectConstructorWithResolvedType(
         getXConstructor().getEnclosingElement().asType());
-    TypeName xClass = TypeNames.forTypeMirror(key.type());
+    TypeName xClass = TypeName.get(key.type());
     assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "test").frameworkType())
-        .isEqualTo(ParameterizedTypeName.create(ClassName.fromClass(Provider.class), xClass));
+        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Provider.class), xClass));
     assertThat(
             FrameworkField.createWithTypeFromKey(MembersInjector.class, key, "test")
                 .frameworkType())
-        .isEqualTo(
-            ParameterizedTypeName.create(ClassName.fromClass(MembersInjector.class), xClass));
+        .isEqualTo(ParameterizedTypeName.get(ClassName.get(MembersInjector.class), xClass));
   }
 
   @Test public void nameSuffix() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index d318cd37c..05f510121 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -65,7 +65,6 @@ public void testEmptyBuilder() {
         "package test;",
         "",
         "import javax.annotation.Generated;",
-        "import test.SimpleComponent",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
@@ -133,7 +132,6 @@ public void testUsesBuildAndSetterNames() {
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import test.TestComponent;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
@@ -235,7 +233,6 @@ public void testIgnoresModulesNotInApi() {
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import test.TestComponent;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index ba235258a..d389dfcb1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -23,8 +23,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
-import dagger.internal.codegen.writer.StringLiteral;
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
@@ -52,8 +52,8 @@
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
-  private static final StringLiteral NPE_LITERAL =
-      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  private static final CodeBlock NPE_LITERAL =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
@@ -387,13 +387,10 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "import test.OuterType.SimpleComponent;",
         "",
         GENERATED_ANNOTATION,
-        "public final class DaggerOuterType_SimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<B> bMembersInjector;",
+        "public final class DaggerOuterType_SimpleComponent implements OuterType.SimpleComponent {",
+        "  private MembersInjector<OuterType.B> bMembersInjector;",
         "",
         "  private DaggerOuterType_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
@@ -404,7 +401,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return new Builder();",
         "  }",
         "",
-        "  public static SimpleComponent create() {",
+        "  public static OuterType.SimpleComponent create() {",
         "    return builder().build();",
         "  }",
         "",
@@ -415,12 +412,12 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  }",
         "",
         "  @Override",
-        "  public A a() {",
+        "  public OuterType.A a() {",
         "    return OuterType$A_Factory.create().get();",
         "  }",
         "",
         "  @Override",
-        "  public void inject(B b) {",
+        "  public void inject(OuterType.B b) {",
         "    bMembersInjector.injectMembers(b);",
         "  }",
         "",
@@ -428,7 +425,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    private Builder() {",
         "    }",
         "",
-        "    public SimpleComponent build() {",
+        "    public OuterType.SimpleComponent build() {",
         "      return new DaggerOuterType_SimpleComponent(this);",
         "    }",
         "  }",
@@ -852,11 +849,7 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private Provider<Set<Object>> setOfObjectContribution1Provider;",
-            "  private Provider<Set<Object>> setOfObjectProvider;",
-            "  private Provider<Object> mapOfStringAndProviderOfObjectContribution1;",
-            "  private Provider<Map<String, Provider<Object>>>",
-            "      mapOfStringAndProviderOfObjectProvider;",
+            "  private Provider<Object> parentKeyObjectProvider;",
             "",
             "  private DaggerParent(Builder builder) {",
             "    assert builder != null;",
@@ -873,15 +866,8 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.setOfObjectContribution1Provider =",
-            "        ParentModule_ParentObjectFactory.create();",
-            "    this.setOfObjectProvider = SetFactory.create(setOfObjectContribution1Provider);",
-            "    this.mapOfStringAndProviderOfObjectContribution1 =",
+            "    this.parentKeyObjectProvider =",
             "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "    this.mapOfStringAndProviderOfObjectProvider =",
-            "        MapProviderFactory.<String, Object>builder(1)",
-            "            .put(\"parent key\", mapOfStringAndProviderOfObjectContribution1)",
-            "            .build();",
             "  }",
             "",
             "  @Override",
@@ -911,6 +897,9 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
+            "    private Provider<Set<Object>> setOfObjectProvider;",
+            "    private Provider<Map<String, Provider<Object>>>",
+            "        mapOfStringAndProviderOfObjectProvider;",
             "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
             "",
             "    private ChildImpl() {",
@@ -919,13 +908,19 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @SuppressWarnings(\"unchecked\")",
             "    private void initialize() {",
+            "      this.setOfObjectProvider = SetFactory.create(",
+            "          ParentModule_ParentObjectFactory.create());",
+            "      this.mapOfStringAndProviderOfObjectProvider =",
+            "          MapProviderFactory.<String, Object>builder(1)",
+            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
+            "              .build();",
             "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          DaggerParent.this.mapOfStringAndProviderOfObjectProvider);",
+            "          mapOfStringAndProviderOfObjectProvider);",
             "    }",
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
-            "      return DaggerParent.this.setOfObjectProvider.get();",
+            "      return setOfObjectProvider.get();",
             "    }",
             "",
             "    @Override",
@@ -1011,83 +1006,84 @@ public void subcomponentOmitsInheritedBindings() {
         "interface TestComponent {",
         "  Set<String> strings();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.SetFactory;",
-        "import java.util.Set;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Set<String>> setOfStringContribution1Provider;",
-        "  private Provider<Set<String>> setOfStringContribution2Provider;",
-        "  private Provider<Set<String>> setOfStringProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.setOfStringContribution1Provider =",
-        "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
-        "    this.setOfStringContribution2Provider =",
-        "        SetModule_StringFactory.create(builder.setModule);",
-        "    this.setOfStringProvider = SetFactory.create(",
-        "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Set<String> strings() {",
-        "    return setOfStringProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private EmptySetModule emptySetModule;",
-        "    private SetModule setModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (emptySetModule == null) {",
-        "        this.emptySetModule = new EmptySetModule();",
-        "      }",
-        "      if (setModule == null) {",
-        "        this.setModule = new SetModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
-        "      if (emptySetModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.emptySetModule = emptySetModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder setModule(SetModule setModule) {",
-        "      if (setModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.setModule = setModule;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Set<String>> emptySetProvider;",
+            "  private Provider<Set<String>> stringProvider;",
+            "  private Provider<Set<String>> setOfStringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.emptySetProvider =",
+            "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
+            "    this.stringProvider =",
+            "        SetModule_StringFactory.create(builder.setModule);",
+            "    this.setOfStringProvider = SetFactory.create(",
+            "        emptySetProvider, stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<String> strings() {",
+            "    return setOfStringProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private EmptySetModule emptySetModule;",
+            "    private SetModule setModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (emptySetModule == null) {",
+            "        this.emptySetModule = new EmptySetModule();",
+            "      }",
+            "      if (setModule == null) {",
+            "        this.setModule = new SetModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
+            "      if (emptySetModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.emptySetModule = emptySetModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder setModule(SetModule setModule) {",
+            "      if (setModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.setModule = setModule;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -1576,14 +1572,11 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import other.test.A;",
-        "import other.test.TestModule;",
-        "import other.test.TestModule_AFactory;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<test.A> aProvider;",
-        "  private Provider<A> aProvider1;",
+        "  private Provider<A> aProvider;",
+        "  private Provider<other.test.A> aProvider2;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
@@ -1600,38 +1593,38 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.aProvider = test.TestModule_AFactory.create(builder.testModule);",
-        "    this.aProvider1 = TestModule_AFactory.create(builder.testModule1);",
+        "    this.aProvider = TestModule_AFactory.create(builder.testModule);",
+        "    this.aProvider2 = other.test.TestModule_AFactory.create(builder.testModule2);",
         "  }",
         "",
         "  @Override",
-        "  public test.A a() {",
+        "  public A a() {",
         "    return aProvider.get();",
         "  }",
         "",
         "  @Override",
-        "  public A otherA() {",
-        "    return aProvider1.get();",
+        "  public other.test.A otherA() {",
+        "    return aProvider2.get();",
         "  }",
         "",
         "  public static final class Builder {",
-        "    private test.TestModule testModule;",
-        "    private TestModule testModule1;",
+        "    private TestModule testModule;",
+        "    private other.test.TestModule testModule2;",
         "",
         "    private Builder() {",
         "    }",
         "",
         "    public TestComponent build() {",
         "      if (testModule == null) {",
-        "        this.testModule = new test.TestModule();",
+        "        this.testModule = new TestModule();",
         "      }",
-        "      if (testModule1 == null) {",
-        "        this.testModule1 = new TestModule();",
+        "      if (testModule2 == null) {",
+        "        this.testModule2 = new other.test.TestModule();",
         "      }",
         "      return new DaggerTestComponent(this);",
         "    }",
         "",
-        "    public Builder testModule(test.TestModule testModule) {",
+        "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
         "        throw new NullPointerException();",
         "      }",
@@ -1639,11 +1632,11 @@ public void subcomponentOmitsInheritedBindings() {
         "      return this;",
         "    }",
         "",
-        "    public Builder testModule(TestModule testModule) {",
+        "    public Builder testModule(other.test.TestModule testModule) {",
         "      if (testModule == null) {",
         "        throw new NullPointerException();",
         "      }",
-        "      this.testModule1 = testModule;",
+        "      this.testModule2 = testModule;",
         "      return this;",
         "    }",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 0a37c2294..487830801 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -20,11 +20,6 @@
  */
 public final class GeneratedLines {
   public static final String GENERATED_ANNOTATION =
-      "@Generated("
-          + "comments = \"https://google.github.io/dagger\", "
-          + "value = \"dagger.internal.codegen.ComponentProcessor\")";
-
-  public static final String GENERATED_ANNOTATION_JAVAPOET =
       "@Generated("
           + "value = \"dagger.internal.codegen.ComponentProcessor\", "
           + "comments = \"https://google.github.io/dagger\")";
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 86e84690a..33a897670 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -315,6 +315,8 @@ public void cyclicDependencyNotBrokenByMapBinding() {
                 "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
                 "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
                 "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
+                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
+                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
                 "      test.Outer.CModule.c(test.Outer.C c)",
                 "          [parameter: test.Outer.C c]");
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a4429453e..de998be5f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -39,7 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -136,7 +136,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
         "  private final Provider<T> tProvider;",
         "",
@@ -182,7 +182,7 @@
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
             "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
             "",
@@ -226,7 +226,7 @@
         "import javax.annotation.Generated;",
         "",
         "@SuppressWarnings(\"rawtypes\")",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public enum GenericClass_Factory implements Factory<GenericClass> {",
         "  INSTANCE;",
         "",
@@ -263,7 +263,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
         "  private final Provider<B> bProvider;",
@@ -311,7 +311,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
         "        B extends List<? extends String>,",
         "        C extends List<? super String>>",
@@ -371,7 +371,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aAndA2AndPaAndLaProvider;",
         "  private final Provider<A> qaProvider;",
@@ -817,7 +817,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -862,7 +862,7 @@
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class AllInjections_Factory ",
             "    implements Factory<AllInjections> {",
             "",
@@ -918,7 +918,7 @@
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class B_Factory implements Factory<B> {",
             "",
             "  private final MembersInjector<B> bMembersInjector;",
@@ -964,7 +964,7 @@ public void wildcardDependency() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1012,7 +1012,7 @@ public void basicNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1064,7 +1064,7 @@ public void nestedNameCollision() {
         "import javax.inject.Provider;",
         "import other.pkg.Outer;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1117,7 +1117,7 @@ public void samePackageNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1165,7 +1165,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public enum SimpleType_Factory implements Factory<SimpleType> {",
         "  INSTANCE;",
         "",
@@ -1210,7 +1210,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public enum OuterType$A_Factory implements Factory<OuterType.A> {",
         "  INSTANCE;",
         "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index c1d622dfd..3eef6ab97 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -32,7 +32,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -70,10 +69,13 @@
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     assertThat(
-        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType()))
-        .isEqualTo(new AutoValue_Key(
-            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-            MoreTypes.equivalence().wrap(typeElement.asType())));
+            keyFactory.forInjectConstructorWithResolvedType(
+                constructor.getEnclosingElement().asType()))
+        .isEqualTo(
+            new AutoValue_Key(
+                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                MoreTypes.equivalence().wrap(typeElement.asType()),
+                Optional.<SourceElement>absent()));
   }
 
   static final class InjectedClass {
@@ -88,10 +90,12 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     assertThat(
-        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
-        .isEqualTo(new AutoValue_Key(
-            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-            MoreTypes.equivalence().wrap(stringType)));
+            keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement)))
+        .isEqualTo(
+            new AutoValue_Key(
+                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                MoreTypes.equivalence().wrap(stringType),
+                Optional.<SourceElement>absent()));
   }
 
   @Module
@@ -109,8 +113,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key =
-        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
+    Key key = keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
@@ -122,7 +125,7 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key provisionKey =
-        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
+        keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
 
     TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement injectableElement =
@@ -163,11 +166,13 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(
-          keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
-              .isEqualTo(new AutoValue_Key(
+      SourceElement sourceElement = SourceElement.forElement(providesMethod, moduleElement);
+      assertThat(keyFactory.forProvidesMethod(sourceElement))
+          .isEqualTo(
+              new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType)));
+                  MoreTypes.equivalence().wrap(setOfStringsType),
+                  Optional.of(sourceElement)));
     }
   }
 
@@ -212,9 +217,9 @@ String provideQualifiedString() {
     assertThat(integerType.getKind().isPrimitive()).isFalse();
     assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
-    Key intKey = keyFactory.forProvidesMethod((ExecutableType) intMethod.asType(), intMethod);
+    Key intKey = keyFactory.forProvidesMethod(SourceElement.forElement(intMethod, primitiveHolder));
     Key integerKey =
-        keyFactory.forProvidesMethod((ExecutableType) integerMethod.asType(), integerMethod);
+        keyFactory.forProvidesMethod(SourceElement.forElement(integerMethod, boxedPrimitiveHolder));
     assertThat(intKey).isEqualTo(integerKey);
   }
 
@@ -224,11 +229,13 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(
-          (ExecutableType) producesMethod.asType(), producesMethod))
-              .isEqualTo(new AutoValue_Key(
+      assertThat(
+              keyFactory.forProducesMethod(SourceElement.forElement(producesMethod, moduleElement)))
+          .isEqualTo(
+              new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(stringType)));
+                  MoreTypes.equivalence().wrap(stringType),
+                  Optional.<SourceElement>absent()));
     }
   }
 
@@ -251,11 +258,13 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(
-          (ExecutableType) producesMethod.asType(), producesMethod))
-          .isEqualTo(new AutoValue_Key(
+      SourceElement sourceElement = SourceElement.forElement(producesMethod, moduleElement);
+      assertThat(keyFactory.forProducesMethod(sourceElement))
+          .isEqualTo(
+              new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType)));
+                  MoreTypes.equivalence().wrap(setOfStringsType),
+                  Optional.of(sourceElement)));
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index ab2212722..1d70c289d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -110,88 +110,88 @@ public void mapBindingsWithEnumKey() {
         "interface TestComponent {",
         "  Map<PathEnum, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathEnum, Provider<Handler>>>",
-        "      mapOfPathEnumAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(PathEnum.ADMIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(PathEnum.LOGIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-        "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathEnum, Provider<Handler>>>",
+            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -270,86 +270,88 @@ public void mapBindingsWithStringKey() {
         "interface TestComponent {",
         "  Map<String, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<String, Provider<Handler>>>",
-        "      mapOfStringAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfStringAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfStringAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfStringAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<String, Handler>builder(2)",
-        "            .put(\"Admin\", mapOfStringAndProviderOfHandlerContribution1)",
-        "            .put(\"Login\", mapOfStringAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<String, Provider<Handler>> dispatcher() {",
-        "    return mapOfStringAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<String, Provider<Handler>>>",
+            "      mapOfStringAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfStringAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<String, Handler>builder(2)",
+            "            .put(\"Admin\", provideAdminHandlerProvider)",
+            "            .put(\"Login\", provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<Handler>> dispatcher() {",
+            "    return mapOfStringAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -437,88 +439,90 @@ public void mapBindingsWithWrappedKey() {
         "interface TestComponent {",
         "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
-        "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
-        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
-        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
-        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+            "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+            "                provideAdminHandlerProvider)",
+            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -608,92 +612,92 @@ public void mapBindingsWithNonProviderValue() {
         "interface TestComponent {",
         "  Map<PathEnum, Handler> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapFactory;",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathEnum, Provider<Handler>>>",
-        "      mapOfPathEnumAndProviderOfHandlerProvider;",
-        "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(PathEnum.ADMIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(PathEnum.LOGIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "    this.mapOfPathEnumAndHandlerProvider =",
-        "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathEnum, Handler> dispatcher() {",
-        "    return mapOfPathEnumAndHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathEnum, Provider<Handler>>>",
+            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+            "            .build();",
+            "    this.mapOfPathEnumAndHandlerProvider =",
+            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathEnum, Handler> dispatcher() {",
+            "    return mapOfPathEnumAndHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 98e88ca99..b70f0479c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -26,7 +26,6 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class MapKeyProcessorTest {
@@ -59,7 +58,7 @@ public void mapKeyCreatorFile() {
             "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class PathKeyCreator {",
             "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
@@ -105,7 +104,7 @@ public void nestedMapKeyCreatorFile() {
             "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class Container$PathKeyCreator {",
             "  @AutoAnnotation",
             "  public static Container.PathKey createPathKey("
@@ -200,88 +199,90 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathKey, Provider<Handler>>>",
-        "      mapOfPathKeyAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathKey, Provider<Handler>>>",
+            "      mapOfPathKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathKey, Handler>builder(2)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+            "                provideAdminHandlerProvider)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -376,88 +377,90 @@ public void mapKeyComponentFileWithDefaultField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathKey, Provider<Handler>>>",
-        "      mapOfPathKeyAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathKey, Provider<Handler>>>",
+            "      mapOfPathKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathKey, Handler>builder(2)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+            "                provideAdminHandlerProvider)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index ccc2f97bb..1b585f603 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -34,7 +34,6 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -227,7 +226,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_MembersInjector<A, B>",
         "    implements MembersInjector<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
@@ -320,7 +319,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
         "  private final Provider<T> tAndXProvider;",
@@ -392,7 +391,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
         "  private final Provider<String> stringProvider;",
@@ -462,7 +461,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class MethodInjection_MembersInjector",
         "     implements MembersInjector<MethodInjection> {",
         "",
@@ -541,7 +540,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -622,7 +621,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class AllInjections_MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -679,7 +678,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
@@ -741,7 +740,7 @@ public void simpleComponentWithNesting() {
           "import javax.annotation.Generated;",
           "import javax.inject.Provider;",
           "",
-          GENERATED_ANNOTATION_JAVAPOET,
+          GENERATED_ANNOTATION,
           "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
           "  private final Provider<OuterType.A> aProvider;",
           "",
@@ -806,7 +805,7 @@ public void componentWithNestingAndGeneratedType() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
             "  private final Provider<OuterType.A> aProvider;",
             "",
@@ -981,7 +980,7 @@ public void fieldInjectionForShadowedMember() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class Child_MembersInjector implements MembersInjector<Child> {",
             "  private final Provider<Foo> objectProvider;",
             "  private final Provider<Bar> objectProvider2;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index cd44b97e5..cda08be2d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,8 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-import dagger.Provides;
-import dagger.internal.codegen.writer.StringLiteral;
+import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,7 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
@@ -48,8 +47,8 @@
       "package test;",
       "public @interface Nullable {}");
 
-  private static final StringLiteral NPE_LITERAL =
-      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+  private static final CodeBlock NPE_LITERAL =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
@@ -375,7 +374,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -421,7 +420,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -462,7 +461,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -546,7 +545,7 @@ private String formatModuleErrorMessage(String msg) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
@@ -617,7 +616,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -668,7 +667,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideWildcardListFactory implements "
             + "Factory<Set<List<List<?>>>> {",
         "  private final TestModule module;",
@@ -715,7 +714,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -1004,7 +1003,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1043,7 +1042,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1076,7 +1075,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideBEntryFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1111,7 +1110,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
         "  private final ChildNumberModule module;",
         "",
@@ -1140,7 +1139,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class ChildIntegerModule_ProvideIntegerFactory",
         "    implements Factory<Integer> {",
         "  private final ChildIntegerModule module;",
@@ -1208,7 +1207,7 @@ public void genericSubclassedModule() {
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public enum ParameterizedModule_ProvideMapStringNumberFactory",
             "    implements Factory<Map<String, Number>> {",
             "  INSTANCE;",
@@ -1235,7 +1234,7 @@ public void genericSubclassedModule() {
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
             "    implements Factory<Object> {",
             "  INSTANCE;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 41fae8ad1..41a40a88c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -38,7 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -510,7 +510,7 @@ public void publicModuleNonPublicIncludes() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
             "  private final Executor executor;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1437e6f8a..c645056a5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -136,25 +136,19 @@
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor.Factory;",
             "import java.util.Set;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
-            "import test.TestClass.A;",
-            "import test.TestClass.AModule;",
-            "import test.TestClass.B;",
-            "import test.TestClass.BModule;",
-            "import test.TestClass.SimpleComponent;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
-            "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "  private Provider<Set<Factory>> setOfFactoryContribution1Provider;",
-            "  private Provider<Set<Factory>> setOfFactoryProvider;",
+            "public final class DaggerTestClass_SimpleComponent",
+            "    implements TestClass.SimpleComponent {",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Set<ProductionComponentMonitor.Factory>> setOfFactoryProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
-            "  private Provider<B> bProvider;",
-            "  private Producer<A> aProducer;",
+            "  private Provider<TestClass.B> bProvider;",
+            "  private Producer<TestClass.A> aProducer;",
             "",
             "  private DaggerTestClass_SimpleComponent(Builder builder) {",
             "    assert builder != null;",
@@ -167,11 +161,11 @@
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-            "    this.setOfFactoryContribution1Provider =",
+            "    this.simpleComponentProvider = ",
+            "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
+            "    this.setOfFactoryProvider = SetFactory.create(",
             "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
-            "            .create();",
-            "    this.setOfFactoryProvider = SetFactory.create(setOfFactoryContribution1Provider);",
+            "            .create());",
             "    this.monitorProvider =",
             "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "            builder.testClass$SimpleComponent_MonitoringModule,",
@@ -187,30 +181,30 @@
             "  }",
             "",
             "  @Override",
-            "  public ListenableFuture<A> a() {",
+            "  public ListenableFuture<TestClass.A> a() {",
             "    return aProducer.get();",
             "  }",
             "",
             "  public static final class Builder {",
             "    private TestClass$SimpleComponent_MonitoringModule",
             "        testClass$SimpleComponent_MonitoringModule;",
-            "    private BModule bModule;",
-            "    private AModule aModule;",
+            "    private TestClass.BModule bModule;",
+            "    private TestClass.AModule aModule;",
             "    private Executor executor;",
             "",
             "    private Builder() {",
             "    }",
             "",
-            "    public SimpleComponent build() {",
+            "    public TestClass.SimpleComponent build() {",
             "      if (testClass$SimpleComponent_MonitoringModule == null) {",
             "        this.testClass$SimpleComponent_MonitoringModule =",
             "            new TestClass$SimpleComponent_MonitoringModule();",
             "      }",
             "      if (bModule == null) {",
-            "        this.bModule = new BModule();",
+            "        this.bModule = new TestClass.BModule();",
             "      }",
             "      if (aModule == null) {",
-            "        this.aModule = new AModule();",
+            "        this.aModule = new TestClass.AModule();",
             "      }",
             "      if (executor == null) {",
             "        throw new IllegalStateException(Executor.class.getCanonicalName()",
@@ -219,7 +213,7 @@
             "      return new DaggerTestClass_SimpleComponent(this);",
             "    }",
             "",
-            "    public Builder aModule(AModule aModule) {",
+            "    public Builder aModule(TestClass.AModule aModule) {",
             "      if (aModule == null) {",
             "        throw new NullPointerException();",
             "      }",
@@ -227,7 +221,7 @@
             "      return this;",
             "    }",
             "",
-            "    public Builder bModule(BModule bModule) {",
+            "    public Builder bModule(TestClass.BModule bModule) {",
             "      if (bModule == null) {",
             "        throw new NullPointerException();",
             "      }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 6fc871684..145e856f2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -257,8 +257,9 @@ public void monitoringDependsOnProduction() {
             "  }",
             "}");
     String expectedError =
-        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory> is a"
-            + " provision, which cannot depend on a production.";
+        "@Provides(type=SET) dagger.producers.monitoring.ProductionComponentMonitor.Factory"
+            + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
+            + " which cannot depend on a production.";
     assertAbout(javaSource())
         .that(component)
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
index 6bf0c9ee0..dddda0e81 100644
--- a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -49,7 +49,7 @@ public void moduleRepeatedInSubcomponentFactoryMethod() {
         .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("This module is present in test.TestComponent.")
+        .withErrorContaining("TestModule is present in test.TestComponent.")
         .in(componentFile)
         .onLine(7)
         .atColumn(51);
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index 76287e946..a0ec1be51 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -509,8 +509,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import test.Bar.Sub;",
-            "import test.Foo;",
+            "import test.subpackage.Sub;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
@@ -546,22 +545,30 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "",
             "  private final class Foo_SubImpl implements Foo.Sub {",
             "",
+            "    private Foo_SubImpl() {}",
+            "",
             "    @Override",
-            "    public Sub newBarSubcomponent() {",
+            "    public Bar.Sub newBarSubcomponent() {",
             "      return new Bar_SubImpl();",
             "    }",
             "",
-            "    private final class Bar_SubImpl implements Sub {",
+            "    private final class Bar_SubImpl implements Bar.Sub {",
+            "",
+            "      private Bar_SubImpl() {}",
             "",
             "      @Override",
-            "      public test.subpackage.Sub newSubcomponentInSubpackage() {",
+            "      public Sub newSubcomponentInSubpackage() {",
             "        return new subpackage_SubImpl();",
             "      }",
             "",
-            "      private final class subpackage_SubImpl implements test.subpackage.Sub {}",
+            "      private final class subpackage_SubImpl implements Sub {",
+            "        private subpackage_SubImpl() {}",
+            "      }",
             "    }",
             "  }",
-            "  private final class NoConflictImpl implements NoConflict {}",
+            "  private final class NoConflictImpl implements NoConflict {",
+            "    private NoConflictImpl() {}",
+            "  }",
             "}");
 
     assertAbout(javaSources())
@@ -610,7 +617,6 @@ public void subcomponentSimpleNamesDisambiguated() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import test.deep.many.levels.that.match.test.Sub;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
@@ -627,7 +633,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "  }",
             "",
             "  @Override",
-            "  public test.Sub newSubcomponent() {",
+            "  public Sub newSubcomponent() {",
             "    return new test_SubImpl();",
             "  }",
             "",
@@ -639,14 +645,19 @@ public void subcomponentSimpleNamesDisambiguated() {
             "    }",
             "  }",
             "",
-            "  private final class test_SubImpl implements test.Sub {",
+            "  private final class test_SubImpl implements Sub {",
+            "",
+            "    private test_SubImpl() {}",
             "",
             "    @Override",
-            "    public Sub newDeepSubcomponent() {",
+            "    public test.deep.many.levels.that.match.test.Sub newDeepSubcomponent() {",
             "      return new match_test_SubImpl();",
             "    }",
             "",
-            "    private final class match_test_SubImpl implements Sub {}",
+            "    private final class match_test_SubImpl implements ",
+            "        test.deep.many.levels.that.match.test.Sub {",
+            "      private match_test_SubImpl() {}",
+            "    }",
             "  }",
             "}");
 
@@ -703,8 +714,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import top1.a.b.c.d.E.F.Sub;",
-            "import top2.a.b.c.d.E.F;",
+            "import top1.a.b.c.d.E;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
@@ -721,12 +731,12 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "  }",
             "",
             "  @Override",
-            "  public Sub top1() {",
+            "  public E.F.Sub top1() {",
             "    return new top1_a_b_c_d_E_F_SubImpl();",
             "  }",
             "",
             "  @Override",
-            "  public F.Sub top2() {",
+            "  public top2.a.b.c.d.E.F.Sub top2() {",
             "    return new top2_a_b_c_d_E_F_SubImpl();",
             "  }",
             "",
@@ -738,8 +748,12 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "    }",
             "  }",
             "",
-            "  private final class top1_a_b_c_d_E_F_SubImpl implements Sub {}",
-            "  private final class top2_a_b_c_d_E_F_SubImpl implements F.Sub {}",
+            "  private final class top1_a_b_c_d_E_F_SubImpl implements E.F.Sub {",
+            "    private top1_a_b_c_d_E_F_SubImpl() {}",
+            "  }",
+            "  private final class top2_a_b_c_d_E_F_SubImpl implements top2.a.b.c.d.E.F.Sub {",
+            "    private top2_a_b_c_d_E_F_SubImpl() {}",
+            "  }",
             "}");
 
     assertAbout(javaSources())
@@ -780,10 +794,9 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import test.Foo.C;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerC implements test.C {",
+            "public final class DaggerC implements C {",
             "  private DaggerC(Builder builder) {",
             "    assert builder != null;",
             "  }",
@@ -792,24 +805,26 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "    return new Builder();",
             "  }",
             "",
-            "  public static test.C create() {",
+            "  public static C create() {",
             "    return builder().build();",
             "  }",
             "",
             "  @Override",
-            "  public C newFooC() {",
+            "  public Foo.C newFooC() {",
             "    return new Foo_CImpl();",
             "  }",
             "",
             "  public static final class Builder {",
             "    private Builder() {}",
             "",
-            "    public test.C build() {",
+            "    public C build() {",
             "      return new DaggerC(this);",
             "    }",
             "  }",
             "",
-            "  private final class Foo_CImpl implements C {}",
+            "  private final class Foo_CImpl implements Foo.C {",
+            "    private Foo_CImpl() {}",
+            "  }",
             "}");
 
     assertAbout(javaSources())
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
deleted file mode 100644
index eff01b849..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.CompilationRule;
-import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;
-import java.util.Map;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public class ClassNameTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  @Test public void bestGuessForString_simpleClass() {
-    assertThat(ClassName.bestGuessFromString(String.class.getName()))
-        .isEqualTo(ClassName.create("java.lang", "String"));
-  }
-
-  static class OuterClass {
-    static class InnerClass {}
-  }
-
-  @Test public void bestGuessForString_nestedClass() {
-    assertThat(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
-        .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
-    assertThat(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
-        .isEqualTo(
-            ClassName.create("dagger.internal.codegen.writer",
-                ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
-  }
-
-  @Test public void bestGuessForString_defaultPackage() {
-    assertThat(ClassName.bestGuessFromString("SomeClass"))
-        .isEqualTo(ClassName.create("", "SomeClass"));
-    assertThat(ClassName.bestGuessFromString("SomeClass.Nested"))
-        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
-    assertThat(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
-        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
-  }
-
-  @Test public void bestGuessForString_confusingInput() {
-    try {
-      ClassName.bestGuessFromString("com.test.$");
-      fail();
-    } catch (IllegalArgumentException expected) {}
-    try {
-      ClassName.bestGuessFromString("com.test.LooksLikeAClass.pkg");
-      fail();
-    } catch (IllegalArgumentException expected) {}
-    try {
-      ClassName.bestGuessFromString("!@#$gibberish%^&*");
-      fail();
-    } catch (IllegalArgumentException expected) {}
-  }
-
-  @Test public void classNameFromTypeElement() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
-    assertThat(ClassName.fromTypeElement(element).canonicalName())
-        .isEqualTo("java.lang.Object");
-  }
-
-  @Test public void peerNamed_topLevelClass() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
-    ClassName className = ClassName.fromTypeElement(element);
-    ClassName peerName = className.peerNamed("Foo");
-    assertThat(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.writer.Foo");
-  }
-
-  @Test public void peerNamed_nestedClass() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
-    ClassName className = ClassName.fromTypeElement(element);
-    ClassName peerName = className.peerNamed("Foo");
-    assertThat(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.Foo");
-  }
-
-  @Test public void peerNamed_deeplyNestedClass() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
-    ClassName className = ClassName.fromTypeElement(element);
-    ClassName peerName = className.peerNamed("Foo");
-    assertThat(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo");
-  }
-
-  @Test public void fromClass_NonNestedClass() {
-    ClassName className = ClassName.fromClass(ClassNameTest.class);
-    assertThat(className.canonicalName()).isEqualTo(
-        "dagger.internal.codegen.writer.ClassNameTest");
-  }
-
-  @Test public void fromClass_NestedClass() {
-    ClassName className = ClassName.fromClass(InnerClass.class);
-    assertThat(className.canonicalName()).isEqualTo(
-        "dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass");
-  }
-
-  @Test public void fromClass_classFileName() {
-    ClassName className = ClassName.fromClass(InnerClass.class);
-    assertThat(className.classFileName('_')).isEqualTo("ClassNameTest_OuterClass_InnerClass");
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
deleted file mode 100644
index e775f7487..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class JavaWriterTest {
-  @Test public void referencedAndDeclaredSimpleName() {
-    JavaWriter javaWriter = JavaWriter.inPackage("test");
-    ClassWriter topClass = javaWriter.addClass("Top");
-    topClass.addNestedClass("Middle").addNestedClass("Bottom");
-    topClass.addField(ClassName.create("some.other.pkg", "Bottom"), "field");
-    assertThat(topClass.toString()).doesNotContain("import some.other.pkg.Bottom;");
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
deleted file mode 100644
index ec82e9605..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.testing.compile.CompilationRule;
-import java.nio.charset.Charset;
-import java.util.Set;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class TypeNamesTest {
-  @Rule public final CompilationRule compilation = new CompilationRule();
-
-  private TypeElement getElement(Class<?> clazz) {
-    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
-  }
-
-  private TypeMirror getType(Class<?> clazz) {
-    return getElement(clazz).asType();
-  }
-
-  @Test
-  public void forTypeMirror_basicTypes() {
-    assertThat(TypeNames.forTypeMirror(getType(Object.class)))
-        .isEqualTo(ClassName.fromClass(Object.class));
-    assertThat(TypeNames.forTypeMirror(getType(Charset.class)))
-        .isEqualTo(ClassName.fromClass(Charset.class));
-    assertThat(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
-        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
-  }
-
-  @Test
-  public void forTypeMirror_parameterizedType() {
-    DeclaredType setType =
-        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
-    assertThat(TypeNames.forTypeMirror(setType))
-        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
-  }
-
-  @Test
-  public void forTypeMirror_typeVariables() {
-    TypeMirror setType = getType(Set.class);
-    assertThat(TypeNames.forTypeMirror(setType))
-        .isEqualTo(ParameterizedTypeName.create(Set.class, TypeVariableName.named("E")));
-  }
-
-  @Test
-  public void forTypeMirror_primitive() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
-        .isEqualTo(PrimitiveName.BOOLEAN);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
-        .isEqualTo(PrimitiveName.BYTE);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
-        .isEqualTo(PrimitiveName.SHORT);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
-        .isEqualTo(PrimitiveName.INT);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
-        .isEqualTo(PrimitiveName.LONG);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
-        .isEqualTo(PrimitiveName.CHAR);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
-        .isEqualTo(PrimitiveName.FLOAT);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
-        .isEqualTo(PrimitiveName.DOUBLE);
-  }
-
-  @Test
-  public void forTypeMirror_arrays() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
-        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
-  }
-
-  @Test
-  public void forTypeMirror_void() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
-        .isEqualTo(VoidName.VOID);
-  }
-
-  @Test
-  public void forTypeMirror_null() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
-        .isEqualTo(NullName.NULL);
-  }
-}
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
index eb159bbf6..b6103d272 100644
--- a/producers/src/main/java/dagger/producers/Producer.java
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -18,6 +18,8 @@
 import dagger.internal.Beta;
 import com.google.common.util.concurrent.ListenableFuture;
 
+import javax.annotation.CheckReturnValue;
+
 /**
  * An interface that represents the production of a type {@code T}. You can also inject
  * {@code Producer<T>} instead of {@code T}, which will delay the execution of any code that
@@ -100,5 +102,6 @@
    * <p>If the key is bound to a {@link Produces} method, then calling this method multiple times
    * will return the same future.
    */
+  @CheckReturnValue
   ListenableFuture<T> get();
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index f18046231..b59104286 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -136,4 +136,17 @@ public void onFailure(Throwable t) {
           }
         });
   }
+
+  private static final ProducerMonitor NO_OP =
+      new ProducerMonitor() {
+        @Override
+        public <T> void addCallbackTo(ListenableFuture<T> future) {
+          // overridden to avoid adding a do-nothing callback
+        }
+      };
+
+  /** Returns a monitor that does no monitoring. */
+  public static ProducerMonitor noOp() {
+    return NO_OP;
+  }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
index 4dc2903fa..90e6d856a 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -45,12 +45,38 @@
  *
  * @author Jesse Beder
  */
-public interface ProductionComponentMonitor {
+public abstract class ProductionComponentMonitor {
   /** Returns a monitor for an individual {@linkplain Produces producer method}. */
-  ProducerMonitor producerMonitorFor(ProducerToken token);
+  public abstract ProducerMonitor producerMonitorFor(ProducerToken token);
 
-  public interface Factory {
+  private static final ProductionComponentMonitor NO_OP =
+      new ProductionComponentMonitor() {
+        @Override
+        public ProducerMonitor producerMonitorFor(ProducerToken token) {
+          return ProducerMonitor.noOp();
+        }
+      };
+
+  /** Returns a monitor that does no monitoring. */
+  public static ProductionComponentMonitor noOp() {
+    return NO_OP;
+  }
+
+  public abstract static class Factory {
     /** Creates a component-specific monitor when the component is created. */
-    ProductionComponentMonitor create(Object component);
+    public abstract ProductionComponentMonitor create(Object component);
+
+    private static final Factory NO_OP =
+        new Factory() {
+          @Override
+          public ProductionComponentMonitor create(Object component) {
+            return ProductionComponentMonitor.noOp();
+          }
+        };
+
+    /** Returns a factory that returns no-op monitors. */
+    public static Factory noOp() {
+      return NO_OP;
+    }
   }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
index e6ae829a3..fcdcb218b 100644
--- a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
@@ -17,6 +17,7 @@
 
 import com.google.common.base.Stopwatch;
 import com.google.common.base.Ticker;
+import dagger.internal.Beta;
 
 /**
  * A monitor that measures the timing of the execution of a production component, and logs those
@@ -25,7 +26,9 @@
  * <p>This assumes that the given recorders do not throw or return null; for example, by using
  * {@link TimingRecorders#delegatingProductionComponentTimingRecorderFactory}.
  */
-final class TimingProductionComponentMonitor implements ProductionComponentMonitor {
+// TODO(beder): Reduce the visibility of this class to package-private.
+@Beta
+public final class TimingProductionComponentMonitor extends ProductionComponentMonitor {
   private final ProductionComponentTimingRecorder recorder;
   private final Ticker ticker;
   private final Stopwatch stopwatch;
@@ -41,11 +44,11 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
     return new TimingProducerMonitor(recorder.producerTimingRecorderFor(token), ticker, stopwatch);
   }
 
-  static final class Factory implements ProductionComponentMonitor.Factory {
+  public static final class Factory extends ProductionComponentMonitor.Factory {
     private final ProductionComponentTimingRecorder.Factory recorderFactory;
     private final Ticker ticker;
 
-    Factory(ProductionComponentTimingRecorder.Factory recorderFactory) {
+    public Factory(ProductionComponentTimingRecorder.Factory recorderFactory) {
       this(recorderFactory, Ticker.systemTicker());
     }
 
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
index 842a55a36..34016e29f 100644
--- a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import dagger.internal.Beta;
 import java.util.Collection;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -26,7 +27,9 @@
  *
  * @author Jesse Beder
  */
-final class TimingRecorders {
+// TODO(beder): Reduce the visibility of this class to package-private.
+@Beta
+public final class TimingRecorders {
   private static final Logger logger = Logger.getLogger(TimingRecorders.class.getName());
 
   /**
@@ -38,7 +41,7 @@
    * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
    * component's execution to fail.
    */
-  static ProductionComponentTimingRecorder.Factory
+  public static ProductionComponentTimingRecorder.Factory
       delegatingProductionComponentTimingRecorderFactory(
           Collection<ProductionComponentTimingRecorder.Factory> factories) {
     switch (factories.size()) {
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
index 2a76c5f71..681f2c0fc 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
@@ -52,7 +52,7 @@ public ProductionComponentMonitor monitor(
             result = monitor = factory.create(componentProvider.get());
           } catch (RuntimeException e) {
             logger.log(Level.SEVERE, "RuntimeException while constructing monitor factories.", e);
-            result = monitor = Monitors.noOpProductionComponentMonitor();
+            result = monitor = ProductionComponentMonitor.noOp();
           }
         }
       }
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index d0ff778f0..4d7d5b765 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -17,7 +17,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
@@ -46,7 +45,7 @@
   public static ProductionComponentMonitor.Factory delegatingProductionComponentMonitorFactory(
       Collection<? extends ProductionComponentMonitor.Factory> factories) {
     if (factories.isEmpty()) {
-      return noOpProductionComponentMonitorFactory();
+      return ProductionComponentMonitor.Factory.noOp();
     } else if (factories.size() == 1) {
       return new NonThrowingProductionComponentMonitor.Factory(Iterables.getOnlyElement(factories));
     } else {
@@ -59,7 +58,7 @@
    * that the delegate throws.
    */
   private static final class NonThrowingProductionComponentMonitor
-      implements ProductionComponentMonitor {
+      extends ProductionComponentMonitor {
     private final ProductionComponentMonitor delegate;
 
     NonThrowingProductionComponentMonitor(ProductionComponentMonitor delegate) {
@@ -70,14 +69,14 @@
     public ProducerMonitor producerMonitorFor(ProducerToken token) {
       try {
         ProducerMonitor monitor = delegate.producerMonitorFor(token);
-        return monitor == null ? noOpProducerMonitor() : new NonThrowingProducerMonitor(monitor);
+        return monitor == null ? ProducerMonitor.noOp() : new NonThrowingProducerMonitor(monitor);
       } catch (RuntimeException e) {
         logProducerMonitorForException(e, delegate, token);
-        return noOpProducerMonitor();
+        return ProducerMonitor.noOp();
       }
     }
 
-    static final class Factory implements ProductionComponentMonitor.Factory {
+    static final class Factory extends ProductionComponentMonitor.Factory {
       private final ProductionComponentMonitor.Factory delegate;
 
       Factory(ProductionComponentMonitor.Factory delegate) {
@@ -89,11 +88,11 @@ public ProductionComponentMonitor create(Object component) {
         try {
           ProductionComponentMonitor monitor = delegate.create(component);
           return monitor == null
-              ? noOpProductionComponentMonitor()
+              ? ProductionComponentMonitor.noOp()
               : new NonThrowingProductionComponentMonitor(monitor);
         } catch (RuntimeException e) {
           logCreateException(e, delegate, component);
-          return noOpProductionComponentMonitor();
+          return ProductionComponentMonitor.noOp();
         }
       }
     }
@@ -161,7 +160,7 @@ public void failed(Throwable t) {
    * that the delegates throw.
    */
   private static final class DelegatingProductionComponentMonitor
-      implements ProductionComponentMonitor {
+      extends ProductionComponentMonitor {
     private final ImmutableList<ProductionComponentMonitor> delegates;
 
     DelegatingProductionComponentMonitor(ImmutableList<ProductionComponentMonitor> delegates) {
@@ -183,7 +182,7 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
       }
       ImmutableList<ProducerMonitor> monitors = monitorsBuilder.build();
       if (monitors.isEmpty()) {
-        return noOpProducerMonitor();
+        return ProducerMonitor.noOp();
       } else if (monitors.size() == 1) {
         return new NonThrowingProducerMonitor(Iterables.getOnlyElement(monitors));
       } else {
@@ -191,7 +190,7 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
       }
     }
 
-    static final class Factory implements ProductionComponentMonitor.Factory {
+    static final class Factory extends ProductionComponentMonitor.Factory {
       private final ImmutableList<? extends ProductionComponentMonitor.Factory> delegates;
 
       Factory(Iterable<? extends ProductionComponentMonitor.Factory> delegates) {
@@ -213,7 +212,7 @@ public ProductionComponentMonitor create(Object component) {
         }
         ImmutableList<ProductionComponentMonitor> monitors = monitorsBuilder.build();
         if (monitors.isEmpty()) {
-          return noOpProductionComponentMonitor();
+          return ProductionComponentMonitor.noOp();
         } else if (monitors.size() == 1) {
           return new NonThrowingProductionComponentMonitor(Iterables.getOnlyElement(monitors));
         } else {
@@ -290,57 +289,17 @@ public void failed(Throwable t) {
     }
   }
 
-  /** Returns a monitor factory that returns no-op component monitors. */
-  public static ProductionComponentMonitor.Factory noOpProductionComponentMonitorFactory() {
-    return NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY;
-  }
-
-  /** Returns a component monitor that returns no-op producer monitors. */
-  public static ProductionComponentMonitor noOpProductionComponentMonitor() {
-    return NO_OP_PRODUCTION_COMPONENT_MONITOR;
-  }
-
-  /** Returns a producer monitor that does nothing. */
-  public static ProducerMonitor noOpProducerMonitor() {
-    return NO_OP_PRODUCER_MONITOR;
-  }
-
   /** Returns a provider of a no-op component monitor. */
   public static Provider<ProductionComponentMonitor> noOpProductionComponentMonitorProvider() {
     return NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER;
   }
 
-  private static final ProductionComponentMonitor.Factory
-      NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY =
-          new ProductionComponentMonitor.Factory() {
-            @Override
-            public ProductionComponentMonitor create(Object component) {
-              return noOpProductionComponentMonitor();
-            }
-          };
-
-  private static final ProductionComponentMonitor NO_OP_PRODUCTION_COMPONENT_MONITOR =
-      new ProductionComponentMonitor() {
-        @Override
-        public ProducerMonitor producerMonitorFor(ProducerToken token) {
-          return noOpProducerMonitor();
-        }
-      };
-
-  private static final ProducerMonitor NO_OP_PRODUCER_MONITOR =
-      new ProducerMonitor() {
-        @Override
-        public <T> void addCallbackTo(ListenableFuture<T> future) {
-          // overridden to avoid adding a do-nothing callback
-        }
-      };
-
   private static final Provider<ProductionComponentMonitor>
       NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER =
           new Provider() {
             @Override
             public ProductionComponentMonitor get() {
-              return noOpProductionComponentMonitor();
+              return ProductionComponentMonitor.noOp();
             }
           };
 
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 6cb6bdbcc..5eb1ea790 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -63,6 +63,7 @@ public ProductionComponentMonitor get() {
   }
 
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void get_nullPointerException() {
     Producer<Object> producer = new DelegateProducer<>(componentMonitorProvider, null);
     try {
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
index 224d8e0b6..31952c334 100644
--- a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -59,7 +59,7 @@ public void zeroMonitorsReturnsNoOp() {
     ProductionComponentMonitor.Factory factory =
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.<ProductionComponentMonitor.Factory>of());
-    assertThat(factory).isSameAs(Monitors.noOpProductionComponentMonitorFactory());
+    assertThat(factory).isSameAs(ProductionComponentMonitor.Factory.noOp());
   }
 
   @Test
@@ -68,7 +68,7 @@ public void singleMonitor_nullProductionComponentMonitor() {
     ProductionComponentMonitor.Factory factory =
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.of(mockProductionComponentMonitorFactory));
-    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());
   }
 
   @Test
@@ -79,7 +79,7 @@ public void singleMonitor_throwingProductionComponentMonitorFactory() {
     ProductionComponentMonitor.Factory factory =
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.of(mockProductionComponentMonitorFactory));
-    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());
   }
 
   @Test
@@ -93,7 +93,7 @@ public void singleMonitor_nullProducerMonitor() {
             ImmutableList.of(mockProductionComponentMonitorFactory));
     ProductionComponentMonitor monitor = factory.create(new Object());
     assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
-        .isSameAs(Monitors.noOpProducerMonitor());
+        .isSameAs(ProducerMonitor.noOp());
   }
 
   @Test
@@ -108,7 +108,7 @@ public void singleMonitor_throwingProductionComponentMonitor() {
             ImmutableList.of(mockProductionComponentMonitorFactory));
     ProductionComponentMonitor monitor = factory.create(new Object());
     assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
-        .isSameAs(Monitors.noOpProducerMonitor());
+        .isSameAs(ProducerMonitor.noOp());
   }
 
   @Test
@@ -222,7 +222,7 @@ public void multipleMonitors_nullProductionComponentMonitors() {
                 mockProductionComponentMonitorFactoryA,
                 mockProductionComponentMonitorFactoryB,
                 mockProductionComponentMonitorFactoryC));
-    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());
   }
 
   @Test
@@ -242,7 +242,7 @@ public void multipleMonitors_throwingProductionComponentMonitorFactories() {
                 mockProductionComponentMonitorFactoryA,
                 mockProductionComponentMonitorFactoryB,
                 mockProductionComponentMonitorFactoryC));
-    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());
   }
 
   @Test
