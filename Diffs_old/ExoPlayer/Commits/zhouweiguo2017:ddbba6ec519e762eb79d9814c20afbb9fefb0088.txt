diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index bf4e3d9a4e..4a09b7168a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -22,18 +22,15 @@
 import android.media.MediaCodec;
 import android.media.MediaFormat;
 import android.support.annotation.IntDef;
-import android.util.Log;
 import android.view.Surface;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.UUID;
 
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
 import java.security.SecureRandom;
 import java.util.UUID;
 import java.util.Vector;
@@ -51,9 +48,7 @@
  */
 public final class C {
 
-    private C() {
-    }
-
+  private C() {}
 
     public static final int AES_BLOCK_LENGTH_BYTES = 16;
 
@@ -84,655 +79,631 @@ private C() {
     public static final int TS_STREAM_TYPE_AC3 = 0x81;
     public static final int TS_STREAM_TYPE_DTS = 0x8A;
 
-
-    /**
-     * Special constant representing a time corresponding to the end of a source. Suitable for use in
-     * any time base.
-     */
-    public static final long TIME_END_OF_SOURCE = Long.MIN_VALUE;
-
-    /**
-     * Special constant representing an unset or unknown time or duration. Suitable for use in any
-     * time base.
-     */
-    public static final long TIME_UNSET = Long.MIN_VALUE + 1;
-
-    /**
-     * Represents an unset or unknown index.
-     */
-    public static final int INDEX_UNSET = -1;
-
-    /**
-     * Represents an unset or unknown position.
-     */
-    public static final int POSITION_UNSET = -1;
-
-    /**
-     * Represents an unset or unknown length.
-     */
-    public static final int LENGTH_UNSET = -1;
-
-    /**
-     * The number of microseconds in one second.
-     */
-    public static final long MICROS_PER_SECOND = 1000000L;
-
-    /**
-     * The number of nanoseconds in one second.
-     */
-    public static final long NANOS_PER_SECOND = 1000000000L;
-
-    /**
-     * The name of the UTF-8 charset.
-     */
-    public static final String UTF8_NAME = "UTF-8";
-
-    /**
-     * The name of the UTF-16 charset.
-     */
-    public static final String UTF16_NAME = "UTF-16";
-
-    /**
-     * * The name of the serif font family.
-     */
-    public static final String SERIF_NAME = "serif";
-
-    /**
-     * * The name of the sans-serif font family.
-     */
-    public static final String SANS_SERIF_NAME = "sans-serif";
-
-    /**
-     * Crypto modes for a codec.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
-    public @interface CryptoMode {
-    }
-
-    /**
-     * @see MediaCodec#CRYPTO_MODE_UNENCRYPTED
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int CRYPTO_MODE_UNENCRYPTED = MediaCodec.CRYPTO_MODE_UNENCRYPTED;
-    /**
-     * @see MediaCodec#CRYPTO_MODE_AES_CTR
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
-    /**
-     * @see MediaCodec#CRYPTO_MODE_AES_CBC
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
-
-    /**
-     * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
-     * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
-
-    /**
-     * Represents an audio encoding, or an invalid or unset value.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-            ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
-            ENCODING_DTS_HD})
-    public @interface Encoding {
-    }
-
-    /**
-     * Represents a PCM audio encoding, or an invalid or unset value.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-            ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
-    public @interface PcmEncoding {
-    }
-
-    /**
-     * @see AudioFormat#ENCODING_INVALID
-     */
-    public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
-    /**
-     * @see AudioFormat#ENCODING_PCM_8BIT
-     */
-    public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
-    /**
-     * @see AudioFormat#ENCODING_PCM_16BIT
-     */
-    public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
-    /**
-     * PCM encoding with 24 bits per sample.
-     */
-    public static final int ENCODING_PCM_24BIT = 0x80000000;
-    /**
-     * PCM encoding with 32 bits per sample.
-     */
-    public static final int ENCODING_PCM_32BIT = 0x40000000;
-    /**
-     * @see AudioFormat#ENCODING_AC3
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
-    /**
-     * @see AudioFormat#ENCODING_E_AC3
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
-    /**
-     * @see AudioFormat#ENCODING_DTS
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
-    /**
-     * @see AudioFormat#ENCODING_DTS_HD
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
-
-    /**
-     * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
-     */
-    @SuppressWarnings({"InlinedApi", "deprecation"})
-    public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
-            ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
-
-    /**
-     * Stream types for an {@link android.media.AudioTrack}.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION, STREAM_TYPE_RING,
-            STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL})
-    public @interface StreamType {
-    }
-
-    /**
-     * @see AudioManager#STREAM_ALARM
-     */
-    public static final int STREAM_TYPE_ALARM = AudioManager.STREAM_ALARM;
-    /**
-     * @see AudioManager#STREAM_MUSIC
-     */
-    public static final int STREAM_TYPE_MUSIC = AudioManager.STREAM_MUSIC;
-    /**
-     * @see AudioManager#STREAM_NOTIFICATION
-     */
-    public static final int STREAM_TYPE_NOTIFICATION = AudioManager.STREAM_NOTIFICATION;
-    /**
-     * @see AudioManager#STREAM_RING
-     */
-    public static final int STREAM_TYPE_RING = AudioManager.STREAM_RING;
-    /**
-     * @see AudioManager#STREAM_SYSTEM
-     */
-    public static final int STREAM_TYPE_SYSTEM = AudioManager.STREAM_SYSTEM;
-    /**
-     * @see AudioManager#STREAM_VOICE_CALL
-     */
-    public static final int STREAM_TYPE_VOICE_CALL = AudioManager.STREAM_VOICE_CALL;
-    /**
-     * The default stream type used by audio renderers.
-     */
-    public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
-
-    /**
-     * Flags which can apply to a buffer containing a media sample.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
-            BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
-    public @interface BufferFlags {
-    }
-
-    /**
-     * Indicates that a buffer holds a synchronization sample.
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int BUFFER_FLAG_KEY_FRAME = MediaCodec.BUFFER_FLAG_KEY_FRAME;
-    /**
-     * Flag for empty buffers that signal that the end of the stream was reached.
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
-    /**
-     * Indicates that a buffer is (at least partially) encrypted.
-     */
-    public static final int BUFFER_FLAG_ENCRYPTED = 0x40000000;
-    /**
-     * Indicates that a buffer should be decoded but not rendered.
-     */
-    public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
-
-    /**
-     * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
-    public @interface VideoScalingMode {
-    }
-
-    /**
-     * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
-            MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
-    /**
-     * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
-            MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
-    /**
-     * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
-     */
-    public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
-
-    /**
-     * Track selection flags.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
-            SELECTION_FLAG_AUTOSELECT})
-    public @interface SelectionFlags {
-    }
-
-    /**
-     * Indicates that the track should be selected if user preferences do not state otherwise.
-     */
-    public static final int SELECTION_FLAG_DEFAULT = 1;
-    /**
-     * Indicates that the track must be displayed. Only applies to text tracks.
-     */
-    public static final int SELECTION_FLAG_FORCED = 2;
-    /**
-     * Indicates that the player may choose to play the track in absence of an explicit user
-     * preference.
-     */
-    public static final int SELECTION_FLAG_AUTOSELECT = 4;
-
-    /**
-     * Represents a streaming or other media type.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
-    public @interface ContentType {
-    }
-
-    /**
-     * Value returned by {@link Util#inferContentType(String)} for DASH manifests.
-     */
-    public static final int TYPE_DASH = 0;
-    /**
-     * Value returned by {@link Util#inferContentType(String)} for Smooth Streaming manifests.
-     */
-    public static final int TYPE_SS = 1;
-    /**
-     * Value returned by {@link Util#inferContentType(String)} for HLS manifests.
-     */
-    public static final int TYPE_HLS = 2;
-    /**
-     * Value returned by {@link Util#inferContentType(String)} for files other than DASH, HLS or
-     * Smooth Streaming manifests.
-     */
-    public static final int TYPE_OTHER = 3;
-
-    /**
-     * A return value for methods where the end of an input was encountered.
-     */
-    public static final int RESULT_END_OF_INPUT = -1;
-    /**
-     * A return value for methods where the length of parsed data exceeds the maximum length allowed.
-     */
-    public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
-    /**
-     * A return value for methods where nothing was read.
-     */
-    public static final int RESULT_NOTHING_READ = -3;
-    /**
-     * A return value for methods where a buffer was read.
-     */
-    public static final int RESULT_BUFFER_READ = -4;
-    /**
-     * A return value for methods where a format was read.
-     */
-    public static final int RESULT_FORMAT_READ = -5;
-
-    /**
-     * A data type constant for data of unknown or unspecified type.
-     */
-    public static final int DATA_TYPE_UNKNOWN = 0;
-    /**
-     * A data type constant for media, typically containing media samples.
-     */
-    public static final int DATA_TYPE_MEDIA = 1;
-    /**
-     * A data type constant for media, typically containing only initialization data.
-     */
-    public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
-    /**
-     * A data type constant for drm or encryption data.
-     */
-    public static final int DATA_TYPE_DRM = 3;
-    /**
-     * A data type constant for a manifest file.
-     */
-    public static final int DATA_TYPE_MANIFEST = 4;
-    /**
-     * A data type constant for time synchronization data.
-     */
-    public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
-    /**
-     * Applications or extensions may define custom {@code DATA_TYPE_*} constants greater than or
-     * equal to this value.
-     */
-    public static final int DATA_TYPE_CUSTOM_BASE = 10000;
-
-    /**
-     * A type constant for tracks of unknown type.
-     */
-    public static final int TRACK_TYPE_UNKNOWN = -1;
-    /**
-     * A type constant for tracks of some default type, where the type itself is unknown.
-     */
-    public static final int TRACK_TYPE_DEFAULT = 0;
-    /**
-     * A type constant for audio tracks.
-     */
-    public static final int TRACK_TYPE_AUDIO = 1;
-    /**
-     * A type constant for video tracks.
-     */
-    public static final int TRACK_TYPE_VIDEO = 2;
-    /**
-     * A type constant for text tracks.
-     */
-    public static final int TRACK_TYPE_TEXT = 3;
-    /**
-     * A type constant for metadata tracks.
-     */
-    public static final int TRACK_TYPE_METADATA = 4;
-    /**
-     * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
-     * equal to this value.
-     */
-    public static final int TRACK_TYPE_CUSTOM_BASE = 10000;
-
-    /**
-     * A selection reason constant for selections whose reasons are unknown or unspecified.
-     */
-    public static final int SELECTION_REASON_UNKNOWN = 0;
-    /**
-     * A selection reason constant for an initial track selection.
-     */
-    public static final int SELECTION_REASON_INITIAL = 1;
-    /**
-     * A selection reason constant for an manual (i.e. user initiated) track selection.
-     */
-    public static final int SELECTION_REASON_MANUAL = 2;
-    /**
-     * A selection reason constant for an adaptive track selection.
-     */
-    public static final int SELECTION_REASON_ADAPTIVE = 3;
-    /**
-     * A selection reason constant for a trick play track selection.
-     */
-    public static final int SELECTION_REASON_TRICK_PLAY = 4;
-    /**
-     * Applications or extensions may define custom {@code SELECTION_REASON_*} constants greater than
-     * or equal to this value.
-     */
-    public static final int SELECTION_REASON_CUSTOM_BASE = 10000;
-
-    /**
-     * A default size in bytes for an individual allocation that forms part of a larger buffer.
-     */
-    public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
-
-    /**
-     * A default size in bytes for a video buffer.
-     */
-    public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-    /**
-     * A default size in bytes for an audio buffer.
-     */
-    public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-    /**
-     * A default size in bytes for a text buffer.
-     */
-    public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-    /**
-     * A default size in bytes for a metadata buffer.
-     */
-    public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-    /**
-     * A default size in bytes for a muxed buffer (e.g. containing video, audio and text).
-     */
-    public static final int DEFAULT_MUXED_BUFFER_SIZE = DEFAULT_VIDEO_BUFFER_SIZE
-            + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
-
-    /**
-     * The Nil UUID as defined by
-     * <a href="https://tools.ietf.org/html/rfc4122#section-4.1.7">RFC4122</a>.
-     */
-    public static final UUID UUID_NIL = new UUID(0L, 0L);
-
-    /**
-     * UUID for the ClearKey DRM scheme.
-     * <p>
-     * ClearKey is supported on Android devices running Android 5.0 (API Level 21) and up.
-     */
-    public static final UUID CLEARKEY_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
-
-    /**
-     * UUID for the Widevine DRM scheme.
-     * <p>
-     * Widevine is supported on Android devices running Android 4.3 (API Level 18) and up.
-     */
-    public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
-
-    /**
-     * UUID for the PlayReady DRM scheme.
-     * <p>
-     * PlayReady is supported on all AndroidTV devices. Note that most other Android devices do not
-     * provide PlayReady support.
-     */
-    public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
-
-    /**
-     * The type of a message that can be passed to a video {@link Renderer} via
-     * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-     * should be the target {@link Surface}, or null.
-     */
-    public static final int MSG_SET_SURFACE = 1;
-
-    /**
-     * A type of a message that can be passed to an audio {@link Renderer} via
-     * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-     * should be a {@link Float} with 0 being silence and 1 being unity gain.
-     */
-    public static final int MSG_SET_VOLUME = 2;
-
-    /**
-     * A type of a message that can be passed to an audio {@link Renderer} via
-     * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-     * should be one of the integer stream types in {@link C.StreamType}, and will specify the stream
-     * type of the underlying {@link android.media.AudioTrack}. See also
-     * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}. If the stream type
-     * is not set, audio renderers use {@link #STREAM_TYPE_DEFAULT}.
-     * <p>
-     * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
-     * introduce a brief gap in audio output. Note also that tracks in the same audio session must
-     * share the same routing, so a new audio session id will be generated.
-     */
-    public static final int MSG_SET_STREAM_TYPE = 3;
-
-    /**
-     * The type of a message that can be passed to a {@link MediaCodec}-based video {@link Renderer}
-     * via {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message
-     * object should be one of the integer scaling modes in {@link C.VideoScalingMode}.
-     * <p>
-     * Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
-     * owned by a {@link android.view.SurfaceView}.
-     */
-    public static final int MSG_SET_SCALING_MODE = 4;
-
-    /**
-     * Applications or extensions may define custom {@code MSG_*} constants greater than or equal to
-     * this value.
-     */
-    public static final int MSG_CUSTOM_BASE = 10000;
-
-    /**
-     * The stereo mode for 360/3D/VR videos.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({
-            Format.NO_VALUE,
-            STEREO_MODE_MONO,
-            STEREO_MODE_TOP_BOTTOM,
-            STEREO_MODE_LEFT_RIGHT,
-            STEREO_MODE_STEREO_MESH
-    })
-    public @interface StereoMode {
-    }
-
-    /**
-     * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
-     */
-    public static final int STEREO_MODE_MONO = 0;
-    /**
-     * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
-     */
-    public static final int STEREO_MODE_TOP_BOTTOM = 1;
-    /**
-     * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
-     */
-    public static final int STEREO_MODE_LEFT_RIGHT = 2;
-    /**
-     * Indicates a stereo layout where the left and right eyes have separate meshes,
-     * used with 360/3D/VR videos.
-     */
-    public static final int STEREO_MODE_STEREO_MESH = 3;
-
-    /**
-     * Video colorspaces.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
-    public @interface ColorSpace {
-    }
-
-    /**
-     * @see MediaFormat#COLOR_STANDARD_BT709
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_SPACE_BT709 = MediaFormat.COLOR_STANDARD_BT709;
-    /**
-     * @see MediaFormat#COLOR_STANDARD_BT601_PAL
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_SPACE_BT601 = MediaFormat.COLOR_STANDARD_BT601_PAL;
-    /**
-     * @see MediaFormat#COLOR_STANDARD_BT2020
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
-
-    /**
-     * Video color transfer characteristics.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
-    public @interface ColorTransfer {
-    }
-
-    /**
-     * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_TRANSFER_SDR = MediaFormat.COLOR_TRANSFER_SDR_VIDEO;
-    /**
-     * @see MediaFormat#COLOR_TRANSFER_ST2084
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_TRANSFER_ST2084 = MediaFormat.COLOR_TRANSFER_ST2084;
-    /**
-     * @see MediaFormat#COLOR_TRANSFER_HLG
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
-
-    /**
-     * Video color range.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
-    public @interface ColorRange {
-    }
-
-    /**
-     * @see MediaFormat#COLOR_RANGE_LIMITED
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_RANGE_LIMITED = MediaFormat.COLOR_RANGE_LIMITED;
-    /**
-     * @see MediaFormat#COLOR_RANGE_FULL
-     */
-    @SuppressWarnings("InlinedApi")
-    public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
-
-    /**
-     * Priority for media playback.
-     * <p>
-     * <p>Larger values indicate higher priorities.
-     */
-    public static final int PRIORITY_PLAYBACK = 0;
-
-    /**
-     * Priority for media downloading.
-     * <p>
-     * <p>Larger values indicate higher priorities.
-     */
-    public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
-
-    /**
-     * Converts a time in microseconds to the corresponding time in milliseconds, preserving
-     * {@link #TIME_UNSET} values.
-     *
-     * @param timeUs The time in microseconds.
-     * @return The corresponding time in milliseconds.
-     */
-    public static long usToMs(long timeUs) {
-        return timeUs == TIME_UNSET ? TIME_UNSET : (timeUs / 1000);
-    }
-
-    /**
-     * Converts a time in milliseconds to the corresponding time in microseconds, preserving
-     * {@link #TIME_UNSET} values.
-     *
-     * @param timeMs The time in milliseconds.
-     * @return The corresponding time in microseconds.
-     */
-    public static long msToUs(long timeMs) {
-        return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
-    }
-
-    /**
-     * Returns a newly generated {@link android.media.AudioTrack} session identifier.
-     */
-    @TargetApi(21)
-    public static int generateAudioSessionIdV21(Context context) {
-        return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
-                .generateAudioSessionId();
-    }
+  /**
+   * Special constant representing a time corresponding to the end of a source. Suitable for use in
+   * any time base.
+   */
+  public static final long TIME_END_OF_SOURCE = Long.MIN_VALUE;
+
+  /**
+   * Special constant representing an unset or unknown time or duration. Suitable for use in any
+   * time base.
+   */
+  public static final long TIME_UNSET = Long.MIN_VALUE + 1;
+
+  /**
+   * Represents an unset or unknown index.
+   */
+  public static final int INDEX_UNSET = -1;
+
+  /**
+   * Represents an unset or unknown position.
+   */
+  public static final int POSITION_UNSET = -1;
+
+  /**
+   * Represents an unset or unknown length.
+   */
+  public static final int LENGTH_UNSET = -1;
+
+  /**
+   * The number of microseconds in one second.
+   */
+  public static final long MICROS_PER_SECOND = 1000000L;
+
+  /**
+   * The number of nanoseconds in one second.
+   */
+  public static final long NANOS_PER_SECOND = 1000000000L;
+
+  /**
+   * The name of the UTF-8 charset.
+   */
+  public static final String UTF8_NAME = "UTF-8";
+
+  /**
+   * The name of the UTF-16 charset.
+   */
+  public static final String UTF16_NAME = "UTF-16";
+
+  /**
+   * * The name of the serif font family.
+   */
+  public static final String SERIF_NAME = "serif";
+
+  /**
+   * * The name of the sans-serif font family.
+   */
+  public static final String SANS_SERIF_NAME = "sans-serif";
+
+  /**
+   * Crypto modes for a codec.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
+  public @interface CryptoMode {}
+  /**
+   * @see MediaCodec#CRYPTO_MODE_UNENCRYPTED
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int CRYPTO_MODE_UNENCRYPTED = MediaCodec.CRYPTO_MODE_UNENCRYPTED;
+  /**
+   * @see MediaCodec#CRYPTO_MODE_AES_CTR
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
+  /**
+   * @see MediaCodec#CRYPTO_MODE_AES_CBC
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
+
+  /**
+   * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
+   * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
+
+  /**
+   * Represents an audio encoding, or an invalid or unset value.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
+      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
+      ENCODING_DTS_HD})
+  public @interface Encoding {}
+
+  /**
+   * Represents a PCM audio encoding, or an invalid or unset value.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
+      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
+  public @interface PcmEncoding {}
+  /**
+   * @see AudioFormat#ENCODING_INVALID
+   */
+  public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
+  /**
+   * @see AudioFormat#ENCODING_PCM_8BIT
+   */
+  public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
+  /**
+   * @see AudioFormat#ENCODING_PCM_16BIT
+   */
+  public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
+  /**
+   * PCM encoding with 24 bits per sample.
+   */
+  public static final int ENCODING_PCM_24BIT = 0x80000000;
+  /**
+   * PCM encoding with 32 bits per sample.
+   */
+  public static final int ENCODING_PCM_32BIT = 0x40000000;
+  /**
+   * @see AudioFormat#ENCODING_AC3
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
+  /**
+   * @see AudioFormat#ENCODING_E_AC3
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+  /**
+   * @see AudioFormat#ENCODING_DTS
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
+  /**
+   * @see AudioFormat#ENCODING_DTS_HD
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
+
+  /**
+   * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
+   */
+  @SuppressWarnings({"InlinedApi", "deprecation"})
+  public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
+      ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
+
+  /**
+   * Stream types for an {@link android.media.AudioTrack}.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION, STREAM_TYPE_RING,
+      STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL})
+  public @interface StreamType {}
+  /**
+   * @see AudioManager#STREAM_ALARM
+   */
+  public static final int STREAM_TYPE_ALARM = AudioManager.STREAM_ALARM;
+  /**
+   * @see AudioManager#STREAM_MUSIC
+   */
+  public static final int STREAM_TYPE_MUSIC = AudioManager.STREAM_MUSIC;
+  /**
+   * @see AudioManager#STREAM_NOTIFICATION
+   */
+  public static final int STREAM_TYPE_NOTIFICATION = AudioManager.STREAM_NOTIFICATION;
+  /**
+   * @see AudioManager#STREAM_RING
+   */
+  public static final int STREAM_TYPE_RING = AudioManager.STREAM_RING;
+  /**
+   * @see AudioManager#STREAM_SYSTEM
+   */
+  public static final int STREAM_TYPE_SYSTEM = AudioManager.STREAM_SYSTEM;
+  /**
+   * @see AudioManager#STREAM_VOICE_CALL
+   */
+  public static final int STREAM_TYPE_VOICE_CALL = AudioManager.STREAM_VOICE_CALL;
+  /**
+   * The default stream type used by audio renderers.
+   */
+  public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
+
+  /**
+   * Flags which can apply to a buffer containing a media sample.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
+      BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
+  public @interface BufferFlags {}
+  /**
+   * Indicates that a buffer holds a synchronization sample.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int BUFFER_FLAG_KEY_FRAME = MediaCodec.BUFFER_FLAG_KEY_FRAME;
+  /**
+   * Flag for empty buffers that signal that the end of the stream was reached.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+  /**
+   * Indicates that a buffer is (at least partially) encrypted.
+   */
+  public static final int BUFFER_FLAG_ENCRYPTED = 0x40000000;
+  /**
+   * Indicates that a buffer should be decoded but not rendered.
+   */
+  public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
+
+  /**
+   * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
+  public @interface VideoScalingMode {}
+  /**
+   * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
+      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
+  /**
+   * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
+      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
+  /**
+   * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
+   */
+  public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
+
+  /**
+   * Track selection flags.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
+      SELECTION_FLAG_AUTOSELECT})
+  public @interface SelectionFlags {}
+  /**
+   * Indicates that the track should be selected if user preferences do not state otherwise.
+   */
+  public static final int SELECTION_FLAG_DEFAULT = 1;
+  /**
+   * Indicates that the track must be displayed. Only applies to text tracks.
+   */
+  public static final int SELECTION_FLAG_FORCED = 2;
+  /**
+   * Indicates that the player may choose to play the track in absence of an explicit user
+   * preference.
+   */
+  public static final int SELECTION_FLAG_AUTOSELECT = 4;
+
+  /**
+   * Represents a streaming or other media type.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
+  public @interface ContentType {}
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for DASH manifests.
+   */
+  public static final int TYPE_DASH = 0;
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for Smooth Streaming manifests.
+   */
+  public static final int TYPE_SS = 1;
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for HLS manifests.
+   */
+  public static final int TYPE_HLS = 2;
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for files other than DASH, HLS or
+   * Smooth Streaming manifests.
+   */
+  public static final int TYPE_OTHER = 3;
+
+  /**
+   * A return value for methods where the end of an input was encountered.
+   */
+  public static final int RESULT_END_OF_INPUT = -1;
+  /**
+   * A return value for methods where the length of parsed data exceeds the maximum length allowed.
+   */
+  public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
+  /**
+   * A return value for methods where nothing was read.
+   */
+  public static final int RESULT_NOTHING_READ = -3;
+  /**
+   * A return value for methods where a buffer was read.
+   */
+  public static final int RESULT_BUFFER_READ = -4;
+  /**
+   * A return value for methods where a format was read.
+   */
+  public static final int RESULT_FORMAT_READ = -5;
+
+  /**
+   * A data type constant for data of unknown or unspecified type.
+   */
+  public static final int DATA_TYPE_UNKNOWN = 0;
+  /**
+   * A data type constant for media, typically containing media samples.
+   */
+  public static final int DATA_TYPE_MEDIA = 1;
+  /**
+   * A data type constant for media, typically containing only initialization data.
+   */
+  public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
+  /**
+   * A data type constant for drm or encryption data.
+   */
+  public static final int DATA_TYPE_DRM = 3;
+  /**
+   * A data type constant for a manifest file.
+   */
+  public static final int DATA_TYPE_MANIFEST = 4;
+  /**
+   * A data type constant for time synchronization data.
+   */
+  public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
+  /**
+   * Applications or extensions may define custom {@code DATA_TYPE_*} constants greater than or
+   * equal to this value.
+   */
+  public static final int DATA_TYPE_CUSTOM_BASE = 10000;
+
+  /**
+   * A type constant for tracks of unknown type.
+   */
+  public static final int TRACK_TYPE_UNKNOWN = -1;
+  /**
+   * A type constant for tracks of some default type, where the type itself is unknown.
+   */
+  public static final int TRACK_TYPE_DEFAULT = 0;
+  /**
+   * A type constant for audio tracks.
+   */
+  public static final int TRACK_TYPE_AUDIO = 1;
+  /**
+   * A type constant for video tracks.
+   */
+  public static final int TRACK_TYPE_VIDEO = 2;
+  /**
+   * A type constant for text tracks.
+   */
+  public static final int TRACK_TYPE_TEXT = 3;
+  /**
+   * A type constant for metadata tracks.
+   */
+  public static final int TRACK_TYPE_METADATA = 4;
+  /**
+   * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
+   * equal to this value.
+   */
+  public static final int TRACK_TYPE_CUSTOM_BASE = 10000;
+
+  /**
+   * A selection reason constant for selections whose reasons are unknown or unspecified.
+   */
+  public static final int SELECTION_REASON_UNKNOWN = 0;
+  /**
+   * A selection reason constant for an initial track selection.
+   */
+  public static final int SELECTION_REASON_INITIAL = 1;
+  /**
+   * A selection reason constant for an manual (i.e. user initiated) track selection.
+   */
+  public static final int SELECTION_REASON_MANUAL = 2;
+  /**
+   * A selection reason constant for an adaptive track selection.
+   */
+  public static final int SELECTION_REASON_ADAPTIVE = 3;
+  /**
+   * A selection reason constant for a trick play track selection.
+   */
+  public static final int SELECTION_REASON_TRICK_PLAY = 4;
+  /**
+   * Applications or extensions may define custom {@code SELECTION_REASON_*} constants greater than
+   * or equal to this value.
+   */
+  public static final int SELECTION_REASON_CUSTOM_BASE = 10000;
+
+  /**
+   * A default size in bytes for an individual allocation that forms part of a larger buffer.
+   */
+  public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
+
+  /**
+   * A default size in bytes for a video buffer.
+   */
+  public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /**
+   * A default size in bytes for an audio buffer.
+   */
+  public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /**
+   * A default size in bytes for a text buffer.
+   */
+  public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /**
+   * A default size in bytes for a metadata buffer.
+   */
+  public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /**
+   * A default size in bytes for a muxed buffer (e.g. containing video, audio and text).
+   */
+  public static final int DEFAULT_MUXED_BUFFER_SIZE = DEFAULT_VIDEO_BUFFER_SIZE
+      + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
+
+  /**
+   * The Nil UUID as defined by
+   * <a href="https://tools.ietf.org/html/rfc4122#section-4.1.7">RFC4122</a>.
+   */
+  public static final UUID UUID_NIL = new UUID(0L, 0L);
+
+  /**
+   * UUID for the ClearKey DRM scheme.
+   * <p>
+   * ClearKey is supported on Android devices running Android 5.0 (API Level 21) and up.
+   */
+  public static final UUID CLEARKEY_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
+
+  /**
+   * UUID for the Widevine DRM scheme.
+   * <p>
+   * Widevine is supported on Android devices running Android 4.3 (API Level 18) and up.
+   */
+  public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
+
+  /**
+   * UUID for the PlayReady DRM scheme.
+   * <p>
+   * PlayReady is supported on all AndroidTV devices. Note that most other Android devices do not
+   * provide PlayReady support.
+   */
+  public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
+
+  /**
+   * The type of a message that can be passed to a video {@link Renderer} via
+   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+   * should be the target {@link Surface}, or null.
+   */
+  public static final int MSG_SET_SURFACE = 1;
+
+  /**
+   * A type of a message that can be passed to an audio {@link Renderer} via
+   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+   * should be a {@link Float} with 0 being silence and 1 being unity gain.
+   */
+  public static final int MSG_SET_VOLUME = 2;
+
+  /**
+   * A type of a message that can be passed to an audio {@link Renderer} via
+   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+   * should be one of the integer stream types in {@link C.StreamType}, and will specify the stream
+   * type of the underlying {@link android.media.AudioTrack}. See also
+   * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}. If the stream type
+   * is not set, audio renderers use {@link #STREAM_TYPE_DEFAULT}.
+   * <p>
+   * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
+   * introduce a brief gap in audio output. Note also that tracks in the same audio session must
+   * share the same routing, so a new audio session id will be generated.
+   */
+  public static final int MSG_SET_STREAM_TYPE = 3;
+
+  /**
+   * The type of a message that can be passed to a {@link MediaCodec}-based video {@link Renderer}
+   * via {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message
+   * object should be one of the integer scaling modes in {@link C.VideoScalingMode}.
+   * <p>
+   * Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
+   * owned by a {@link android.view.SurfaceView}.
+   */
+  public static final int MSG_SET_SCALING_MODE = 4;
+
+  /**
+   * Applications or extensions may define custom {@code MSG_*} constants greater than or equal to
+   * this value.
+   */
+  public static final int MSG_CUSTOM_BASE = 10000;
+
+  /**
+   * The stereo mode for 360/3D/VR videos.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+      Format.NO_VALUE,
+      STEREO_MODE_MONO,
+      STEREO_MODE_TOP_BOTTOM,
+      STEREO_MODE_LEFT_RIGHT,
+      STEREO_MODE_STEREO_MESH
+  })
+  public @interface StereoMode {}
+  /**
+   * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_MONO = 0;
+  /**
+   * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_TOP_BOTTOM = 1;
+  /**
+   * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_LEFT_RIGHT = 2;
+  /**
+   * Indicates a stereo layout where the left and right eyes have separate meshes,
+   * used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_STEREO_MESH = 3;
+
+  /**
+   * Video colorspaces.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
+  public @interface ColorSpace {}
+  /**
+   * @see MediaFormat#COLOR_STANDARD_BT709
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_SPACE_BT709 = MediaFormat.COLOR_STANDARD_BT709;
+  /**
+   * @see MediaFormat#COLOR_STANDARD_BT601_PAL
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_SPACE_BT601 = MediaFormat.COLOR_STANDARD_BT601_PAL;
+  /**
+   * @see MediaFormat#COLOR_STANDARD_BT2020
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
+
+  /**
+   * Video color transfer characteristics.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
+  public @interface ColorTransfer {}
+  /**
+   * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_TRANSFER_SDR = MediaFormat.COLOR_TRANSFER_SDR_VIDEO;
+  /**
+   * @see MediaFormat#COLOR_TRANSFER_ST2084
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_TRANSFER_ST2084 = MediaFormat.COLOR_TRANSFER_ST2084;
+  /**
+   * @see MediaFormat#COLOR_TRANSFER_HLG
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
+
+  /**
+   * Video color range.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
+  public @interface ColorRange {}
+  /**
+   * @see MediaFormat#COLOR_RANGE_LIMITED
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_RANGE_LIMITED = MediaFormat.COLOR_RANGE_LIMITED;
+  /**
+   * @see MediaFormat#COLOR_RANGE_FULL
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
+
+  /**
+   * Priority for media playback.
+   *
+   * <p>Larger values indicate higher priorities.
+   */
+  public static final int PRIORITY_PLAYBACK = 0;
+
+  /**
+   * Priority for media downloading.
+   *
+   * <p>Larger values indicate higher priorities.
+   */
+  public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
+
+  /**
+   * Converts a time in microseconds to the corresponding time in milliseconds, preserving
+   * {@link #TIME_UNSET} values.
+   *
+   * @param timeUs The time in microseconds.
+   * @return The corresponding time in milliseconds.
+   */
+  public static long usToMs(long timeUs) {
+    return timeUs == TIME_UNSET ? TIME_UNSET : (timeUs / 1000);
+  }
+
+  /**
+   * Converts a time in milliseconds to the corresponding time in microseconds, preserving
+   * {@link #TIME_UNSET} values.
+   *
+   * @param timeMs The time in milliseconds.
+   * @return The corresponding time in microseconds.
+   */
+  public static long msToUs(long timeMs) {
+    return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
+  }
+
+  /**
+   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+   */
+  @TargetApi(21)
+  public static int generateAudioSessionIdV21(Context context) {
+    return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
+        .generateAudioSessionId();
+  }
 
 
     public static final byte[] AES_CBC(byte[] content, byte[] keyBytes, byte[] iv, boolean bEncrypt) {
@@ -757,8 +728,10 @@ public static int generateAudioSessionIdV21(Context context) {
     }
 
     /**
+     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html
+     *
      * Encryption of NAL units
-     * <p>
+     *
      * Encrypted_nal_unit () {
      * nal_unit_type_byte                // 1 byte
      * unencrypted_leader                // 31 bytes
@@ -769,11 +742,6 @@ public static int generateAudioSessionIdV21(Context context) {
      * unencrypted_block           // MIN(144, bytes_remaining()) bytes
      * }
      * }
-     * <p>
-     * Each NAL unit is formed with start code emulation prevention applied. The preceding start code is not part of the protected block and is not encrypted. The byte containing the nal_unit_type value, plus the 31 bytes that follow, are unencrypted. The contiguous data that follows the unencrypted bytes is a protected block. Any protected block with a length of 16 bytes or fewer has no encryption applied; therefore, a NAL unit with length of 48 bytes or fewer is completely unencrypted.
-     * <p>
-     * The protected block uses 10% skip encryption. Each 16-byte block of encrypted data is followed by up to nine 16-byte blocks of unencrypted data.
-     *
      *
      * @param dataSampleAES IDR/Slice data
      * @param sizeSampleAES size of sample-aes encrypted NAL data
@@ -872,8 +840,10 @@ public static final void decryptSampleAes(byte[] buffer, int bufferSize, byte[]
 
 
     /**
+     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html
+     *
      * Encryption of AAC Audio Frames
-     * <p>
+     *
      * Encrypted_AAC_Frame () {
      * ADTS_Header                        // 7 or 9 bytes
      * unencrypted_leader                 // 16 bytes
@@ -882,9 +852,6 @@ public static final void decryptSampleAes(byte[] buffer, int bufferSize, byte[]
      * }
      * unencrypted_trailer                // 0-15 bytes
      * }
-     * <p>
-     * The ADTS header, which can be 7 or 9 bytes long, plus the first 16 bytes of the frame after it, are unencrypted. The contiguous data section that follows is encrypted. The size, in bytes, of the encrypted section must be an integer multiple of 16 and is possibly zero. The AAC frame ends with 0 to 15 unencrypted bytes. Start code emulation prevention is not performed on the encrypted frame.
-     *
      * @param dataSampleAES IDR/Slice data, not used, use the sampleData directly to avoid data copy
      * @param sizeSampleAES
      */
@@ -925,4 +892,5 @@ public static final void decryptSampleAes_Audio(ParsableByteArray dataSampleAES,
         System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition(), size);
     }
 
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index ecf1feb5d5..0bffd28ba5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -18,7 +18,8 @@
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.media.MediaFormat;
-
+import android.os.Parcel;
+import android.os.Parcelable;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -33,7 +34,7 @@
 /**
  * Representation of a media format.
  */
-public final class Format {
+public final class Format implements Parcelable {
 
   /**
    * A value for various fields to indicate that the field's value is unknown or not applicable.
@@ -177,14 +178,11 @@
   @C.SelectionFlags
   public final int selectionFlags;
 
-
-
   /**
    * The language, or null if unknown or not applicable.
    */
   public final String language;
 
-  public final int streamType;
   /**
    * The Accessibility channel, or {@link #NO_VALUE} if not known or applicable.
    */
@@ -210,14 +208,6 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
     return createVideoSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, initializationData, NO_VALUE, NO_VALUE, drmInitData);
   }
-  public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
-                                               int bitrate, int maxInputSize, int width, int height, float frameRate,
-                                               List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
-                                               DrmInitData drmInitData, int streamType) {
-    return createVideoSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, width,
-            height, frameRate, initializationData, rotationDegrees, pixelWidthHeightRatio, null,
-            NO_VALUE, null, drmInitData, streamType);
-  }
 
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate,
@@ -228,17 +218,6 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
         NO_VALUE, null, drmInitData);
   }
 
-  public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
-                                               int bitrate, int maxInputSize, int width, int height, float frameRate,
-                                               List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
-                                               byte[] projectionData, @C.StereoMode int stereoMode, ColorInfo colorInfo,
-                                               DrmInitData drmInitData, int streamType) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, width, height,
-            frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-            colorInfo, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, 0, null, NO_VALUE,
-            OFFSET_SAMPLE_RELATIVE, initializationData, drmInitData, null, streamType);
-  }
-
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate,
       List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
@@ -269,23 +248,6 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
         sampleRate, NO_VALUE, initializationData, drmInitData, selectionFlags, language);
   }
 
-  public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
-                                               int bitrate, int maxInputSize, int channelCount, int sampleRate,
-                                               List<byte[]> initializationData, DrmInitData drmInitData,
-                                               @C.SelectionFlags int selectionFlags, String language, int streamType) {
-    return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
-            sampleRate, NO_VALUE, initializationData, drmInitData, selectionFlags, language, streamType);
-  }
-
-  public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
-                                               int bitrate, int maxInputSize, int channelCount, int sampleRate,
-                                               @C.PcmEncoding int pcmEncoding, List<byte[]> initializationData, DrmInitData drmInitData,
-                                               @C.SelectionFlags int selectionFlags, String language, int streamType) {
-    return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
-            sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
-            selectionFlags, language, null, streamType);
-  }
-
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int channelCount, int sampleRate,
       @C.PcmEncoding int pcmEncoding, List<byte[]> initializationData, DrmInitData drmInitData,
@@ -294,16 +256,7 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
         sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
         selectionFlags, language, null);
   }
-  public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
-                                               int bitrate, int maxInputSize, int channelCount, int sampleRate,
-                                               @C.PcmEncoding int pcmEncoding, int encoderDelay, int encoderPadding,
-                                               List<byte[]> initializationData, DrmInitData drmInitData,
-                                               @C.SelectionFlags int selectionFlags, String language, Metadata metadata, int streamType) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, NO_VALUE, NO_VALUE,
-            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, channelCount, sampleRate, pcmEncoding,
-            encoderDelay, encoderPadding, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
-            initializationData, drmInitData, metadata, streamType);
-  }
+
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int channelCount, int sampleRate,
       @C.PcmEncoding int pcmEncoding, int encoderDelay, int encoderPadding,
@@ -385,58 +338,19 @@ public static Format createContainerFormat(String id, String containerMimeType,
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType,
-                                          long subsampleOffsetUs) {
+      long subsampleOffsetUs) {
     return new Format(id, null, sampleMimeType, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-            NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
+        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
-                                          int bitrate, DrmInitData drmInitData) {
+      int bitrate, DrmInitData drmInitData) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
-            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-            NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, drmInitData, null);
-  }
-
-  /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
-                       int bitrate, int maxInputSize, int width, int height, float frameRate, int rotationDegrees,
-                       float pixelWidthHeightRatio, byte[] projectionData, @C.StereoMode int stereoMode,
-                       ColorInfo colorInfo, int channelCount, int sampleRate, @C.PcmEncoding int pcmEncoding,
-                       int encoderDelay, int encoderPadding, @C.SelectionFlags int selectionFlags, String language,
-                       int accessibilityChannel, long subsampleOffsetUs, List<byte[]> initializationData,
-                       DrmInitData drmInitData, Metadata metadata, int streamType) {
-    this.id = id;
-    this.containerMimeType = containerMimeType;
-    this.sampleMimeType = sampleMimeType;
-    this.codecs = codecs;
-    this.bitrate = bitrate;
-    this.maxInputSize = maxInputSize;
-    this.width = width;
-    this.height = height;
-    this.frameRate = frameRate;
-    this.rotationDegrees = rotationDegrees;
-    this.pixelWidthHeightRatio = pixelWidthHeightRatio;
-    this.projectionData = projectionData;
-    this.stereoMode = stereoMode;
-    this.colorInfo = colorInfo;
-    this.channelCount = channelCount;
-    this.sampleRate = sampleRate;
-    this.pcmEncoding = pcmEncoding;
-    this.encoderDelay = encoderDelay;
-    this.encoderPadding = encoderPadding;
-    this.selectionFlags = selectionFlags;
-    this.language = language;
-    this.accessibilityChannel = accessibilityChannel;
-    this.subsampleOffsetUs = subsampleOffsetUs;
-    this.initializationData = initializationData == null ? Collections.<byte[]>emptyList()
-            : initializationData;
-    this.drmInitData = drmInitData;
-    this.metadata = metadata;
-    this.streamType = streamType;
+        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, drmInitData, null);
   }
 
-
-
   /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate, int rotationDegrees,
       float pixelWidthHeightRatio, byte[] projectionData, @C.StereoMode int stereoMode,
@@ -471,7 +385,41 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
         : initializationData;
     this.drmInitData = drmInitData;
     this.metadata = metadata;
-    this.streamType = 0;
+  }
+
+  @SuppressWarnings("ResourceType")
+  /* package */ Format(Parcel in) {
+    id = in.readString();
+    containerMimeType = in.readString();
+    sampleMimeType = in.readString();
+    codecs = in.readString();
+    bitrate = in.readInt();
+    maxInputSize = in.readInt();
+    width = in.readInt();
+    height = in.readInt();
+    frameRate = in.readFloat();
+    rotationDegrees = in.readInt();
+    pixelWidthHeightRatio = in.readFloat();
+    boolean hasProjectionData = in.readInt() != 0;
+    projectionData = hasProjectionData ? in.createByteArray() : null;
+    stereoMode = in.readInt();
+    colorInfo = in.readParcelable(ColorInfo.class.getClassLoader());
+    channelCount = in.readInt();
+    sampleRate = in.readInt();
+    pcmEncoding = in.readInt();
+    encoderDelay = in.readInt();
+    encoderPadding = in.readInt();
+    selectionFlags = in.readInt();
+    language = in.readString();
+    accessibilityChannel = in.readInt();
+    subsampleOffsetUs = in.readLong();
+    int initializationDataSize = in.readInt();
+    initializationData = new ArrayList<>(initializationDataSize);
+    for (int i = 0; i < initializationDataSize; i++) {
+      initializationData.add(in.createByteArray());
+    }
+    drmInitData = in.readParcelable(DrmInitData.class.getClassLoader());
+    metadata = in.readParcelable(Metadata.class.getClassLoader());
   }
 
   public Format copyWithMaxInputSize(int maxInputSize) {
@@ -716,4 +664,60 @@ public static String toLogString(Format format) {
 
   // Parcelable implementation.
 
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeString(containerMimeType);
+    dest.writeString(sampleMimeType);
+    dest.writeString(codecs);
+    dest.writeInt(bitrate);
+    dest.writeInt(maxInputSize);
+    dest.writeInt(width);
+    dest.writeInt(height);
+    dest.writeFloat(frameRate);
+    dest.writeInt(rotationDegrees);
+    dest.writeFloat(pixelWidthHeightRatio);
+    dest.writeInt(projectionData != null ? 1 : 0);
+    if (projectionData != null) {
+      dest.writeByteArray(projectionData);
+    }
+    dest.writeInt(stereoMode);
+    dest.writeParcelable(colorInfo, flags);
+    dest.writeInt(channelCount);
+    dest.writeInt(sampleRate);
+    dest.writeInt(pcmEncoding);
+    dest.writeInt(encoderDelay);
+    dest.writeInt(encoderPadding);
+    dest.writeInt(selectionFlags);
+    dest.writeString(language);
+    dest.writeInt(accessibilityChannel);
+    dest.writeLong(subsampleOffsetUs);
+    int initializationDataSize = initializationData.size();
+    dest.writeInt(initializationDataSize);
+    for (int i = 0; i < initializationDataSize; i++) {
+      dest.writeByteArray(initializationData.get(i));
+    }
+    dest.writeParcelable(drmInitData, 0);
+    dest.writeParcelable(metadata, 0);
+  }
+
+  public static final Creator<Format> CREATOR = new Creator<Format>() {
+
+    @Override
+    public Format createFromParcel(Parcel in) {
+      return new Format(in);
+    }
+
+    @Override
+    public Format[] newArray(int size) {
+      return new Format[size];
+    }
+
+  };
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 1cf78f04f9..cd2bba5afe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -62,6 +62,7 @@
   private AdtsReader reader;
   private boolean startedPacket;
 
+
   private  int mMode = C.TS_STREAM_TYPE_AAC;
   private  String encryptionMethod;
   private  byte[] encryptionKey;
@@ -88,6 +89,7 @@ public AdtsExtractor(long firstSampleTimestampUs, HLSEncryptInfo hlsEncryptInfo)
 
   }
 
+
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     // Skip any ID3 headers.
@@ -145,7 +147,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
 
   @Override
   public void init(ExtractorOutput output) {
-
+    //support pure sample-aes aac content
     reader = new AdtsReader(true, mMode, encryptionKey, encryptionIv);
     reader.createTracks(output, new TrackIdGenerator(0, 1));
     output.endTracks();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index 8fe2ef198f..fe94acf3cd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -24,28 +24,14 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.security.SecureRandom;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.Vector;
-
-import javax.crypto.Cipher;
-import javax.crypto.KeyGenerator;
-import javax.crypto.SecretKey;
-import javax.crypto.spec.IvParameterSpec;
-import javax.crypto.spec.SecretKeySpec;
-
-import static java.lang.Math.min;
 
 /**
  * Parses a continuous ADTS byte stream and extracts individual frames.
@@ -100,13 +86,10 @@
     private TrackOutput currentOutput;
     private long currentSampleDuration;
 
-
     private int mMode = C.TS_STREAM_TYPE_AAC;
     private String encryptionMethod;
     private byte[] encryptionKey;
     private byte[] encryptionIv;
-
-
     private ParsableByteArray sampleData;
     private int writtenSampleSize;
     private boolean bMyCode;
@@ -121,24 +104,6 @@ public AdtsReader(boolean exposeId3) {
         this(exposeId3, null);
     }
 
-    public AdtsReader(boolean exposeId3, String language, int streamType, HLSEncryptInfo hlsEncryptInfo) {
-        this(exposeId3, language);
-
-
-        this.mMode = streamType;
-        this.encryptionKey = hlsEncryptInfo.encryptionKey;
-        this.encryptionIv = hlsEncryptInfo.encryptionIv;
-    }
-
-
-    public AdtsReader(boolean exposeId3, int streamType, byte[] encryptionKey, byte[] encryptionIv) {
-        this(exposeId3, null);
-
-        this.mMode = streamType;
-        this.encryptionKey = encryptionKey;
-        this.encryptionIv = encryptionIv;
-    }
-
     /**
      * @param exposeId3 True if the reader should expose ID3 information.
      * @param language  Track language.
@@ -150,15 +115,32 @@ public AdtsReader(boolean exposeId3, String language) {
         this.exposeId3 = exposeId3;
         this.language = language;
 
-
         bMyCode = false;//TODO:original code could handle AAC audio well, need further investigation here
         bParseID3 = false;
         bFirstSample = true;
-        sampleData = new ParsableByteArray();//TODO: it will "eat" huge memory, only used in dev stage, should use better mechnism
-        writtenSampleSize = 0;
+        sampleData = new ParsableByteArray();
         totalBytesWritten = 0;
     }
 
+    public AdtsReader(boolean exposeId3, String language, int streamType, HLSEncryptInfo hlsEncryptInfo) {
+        this(exposeId3, language);
+
+        this.mMode = streamType;
+        this.encryptionKey = hlsEncryptInfo.encryptionKey;
+        this.encryptionIv = hlsEncryptInfo.encryptionIv;
+    }
+
+    /*
+      support pure sample-aes aac audio content
+     */
+    public AdtsReader(boolean exposeId3, int streamType, byte[] encryptionKey, byte[] encryptionIv) {
+        this(exposeId3, null);
+
+        this.mMode = streamType;
+        this.encryptionKey = encryptionKey;
+        this.encryptionIv = encryptionIv;
+    }
+
     @Override
     public void seek() {
         setFindingSampleState();
@@ -186,33 +168,6 @@ public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
 
     @Override
     public void consume(ParsableByteArray data) {
-        int offset = data.getPosition();
-        int limit = data.limit();
-        int size = data.bytesLeft();
-
-        totalBytesWritten += data.bytesLeft();
-
-        if (bMyCode) {
-            if (bFirstSample) {
-                bFirstSample = false;
-                sampleData.reset((int) totalBytesWritten);
-                System.arraycopy(data.data, offset, sampleData.data, sampleData.getPosition(), size);
-
-            } else {
-                int curLeft = sampleData.bytesLeft();
-                byte[] leftData = new byte[curLeft];
-                if (curLeft > 0) {
-                    System.arraycopy(sampleData.data, sampleData.getPosition(), leftData, 0, curLeft);
-                }
-                sampleData.reset(curLeft + size);
-                if (curLeft > 0) {
-                    System.arraycopy(leftData, 0, sampleData.data, 0, curLeft);
-                }
-                System.arraycopy(data.data, offset, sampleData.data, curLeft, size);
-
-            }
-        }
-
         while (data.bytesLeft() > 0) {
             switch (state) {
                 case STATE_FINDING_SAMPLE:
@@ -273,7 +228,6 @@ private void setFindingSampleState() {
     private void setReadingId3HeaderState() {
         state = STATE_READING_ID3_HEADER;
         bytesRead = ID3_IDENTIFIER.length;
-        bParseID3 = true;
         sampleSize = 0;
         id3HeaderBuffer.setPosition(0);
     }
@@ -313,7 +267,6 @@ private void findNextSample(ParsableByteArray pesBuffer) {
         byte[] adtsData = pesBuffer.data;
         int position = pesBuffer.getPosition();
         int endOffset = pesBuffer.limit();
-        bParseID3 = false;
         while (position < endOffset) {
             int data = adtsData[position++] & 0xFF;
             if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
@@ -335,7 +288,6 @@ private void findNextSample(ParsableByteArray pesBuffer) {
                 case MATCH_STATE_ID | '3':
                     setReadingId3HeaderState();
                     pesBuffer.setPosition(position);
-                    bParseID3 = true;
                     return;
                 default:
                     if (matchState != MATCH_STATE_START) {
@@ -359,31 +311,6 @@ private void parseId3Header() {
         setReadingSampleState(id3Output, 0, ID3_HEADER_SIZE,
                 id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);
     }
-/**
- * ADTS
-
- header     body
-
- ADTS
-  	 	                  bits 	
- 1 	    Syncword 	                  12 	all bits must be 1
- 2 	    MPEG version 	              1 	0 for MPEG-4, 1 for MPEG-2
- 3 	    Layer 	                      2 	always 0
- 4 	    Protection Absent 	          1 	et to 1 if there is no CRC and 0 if there is CRC
- 5 	    Profile 	                  2 	the MPEG-4 Audio Object Type minus 1
- 6 	    MPEG-4 Sampling Frequency Index 	4 	MPEG-4 Sampling Frequency Index (15 is forbidden)
- 7 	    Private Stream 	              1 	set to 0 when encoding, ignore when decoding
- 8 	    MPEG-4 Channel Configuration  3 	MPEG-4 Channel Configuration (in the case of 0, the channel configuration is sent via an inband PCE)
- 9 	    Originality 	              1 	set to 0 when encoding, ignore when decoding
- 10 	Home 	                      1 	set to 0 when encoding, ignore when decoding
- 11 	Copyrighted Stream 	          1 	set to 0 when encoding, ignore when decoding
- 12 	Copyrighted Start 	          1 	set to 0 when encoding, ignore when decoding
- 13 	Frame Length 	              13 	this value must include 7 or 9 bytes of header length:
- FrameLength = (ProtectionAbsent == 1 ? 7 : 9) + size(AACFrame)
- 14 	Buffer Fullness 	          11 	buffer fullness
- 15 	Number of AAC Frames 	      2 	number of AAC frames (RDBs) in ADTS frame minus 1, for maximum compatibility always use 1 AAC frame per ADTS frame
- 16 	CRC 	                      16 	CRC if protection absent is 0
- */
 
     /**
      * Parses the sample header.
@@ -418,7 +345,7 @@ private void parseAdtsHeader() {
 
             Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
                     Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
-                    Collections.singletonList(audioSpecificConfig), null, 0, language, mMode);
+                    Collections.singletonList(audioSpecificConfig), null, 0, language);
             // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
             // number of PCM audio samples per second.
             sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;
@@ -441,11 +368,9 @@ private void parseAdtsHeader() {
      * Reads the rest of the sample
      */
     private void readSample(ParsableByteArray data) {
-
         int skipSize = 0;
         int realSampleSize = 0;
 
-
         int headerSize = 2 /* the sync word */ + HEADER_SIZE;
         if (hasCrc) {
             headerSize += CRC_SIZE;
@@ -453,7 +378,6 @@ private void readSample(ParsableByteArray data) {
 
         int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
 
-
         if (bMyCode) {
             //Assertions.checkArgument(data.getPosition() );
             if (bParseID3)
@@ -463,7 +387,6 @@ private void readSample(ParsableByteArray data) {
         }
 
         if (!bMyCode) {
-
             currentOutput.sampleData(data, bytesToRead);
             writtenSampleSize += bytesToRead;
         } else {
@@ -505,4 +428,6 @@ private void readSample(ParsableByteArray data) {
         }
 
     }
+
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index edd0539ebb..34f513a38e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -17,11 +17,11 @@
 
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
-
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
-import com.google.android.exoplayer2.util.HLSEncryptInfo;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.Factory;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.lang.annotation.Retention;
@@ -31,9 +31,9 @@
 import java.util.List;
 
 /**
- * Default implementation for {@link TsPayloadReader.Factory}.
+ * Default implementation for {@link Factory}.
  */
-public final class DefaultTsPayloadReaderFactory implements TsPayloadReader.Factory {
+public final class DefaultTsPayloadReaderFactory implements Factory {
 
   /**
    * Flags controlling elementary stream readers' behavior.
@@ -98,7 +98,7 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEnc
       case TsExtractor.TS_STREAM_TYPE_MPA_LSF:
         return new PesReader(new MpegAudioReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_AAC:
-      case C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES:
+          case C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES:
         return isSet(FLAG_IGNORE_AAC_STREAM)
             ? null : new PesReader(new AdtsReader(false, esInfo.language, streamType, hlsEncryptInfo));
       case TsExtractor.TS_STREAM_TYPE_AC3:
@@ -110,10 +110,10 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEnc
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader());
       case TsExtractor.TS_STREAM_TYPE_H264:
-      case C.TS_STREAM_TYPE_SAMPLE_AES_H264:
+        case C.TS_STREAM_TYPE_SAMPLE_AES_H264:
         return isSet(FLAG_IGNORE_H264_STREAM) ? null
             : new PesReader(new H264Reader(buildSeiReader(esInfo),
-                isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS), streamType, hlsEncryptInfo));
+                isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS),streamType,hlsEncryptInfo));
       case TsExtractor.TS_STREAM_TYPE_H265:
         return new PesReader(new H265Reader(buildSeiReader(esInfo)));
       case TsExtractor.TS_STREAM_TYPE_SPLICE_INFO:
@@ -135,7 +135,7 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEnc
    * {@link SeiReader} for the declared formats, or {@link #closedCaptionFormats} if the descriptor
    * is not present.
    *
-   * @param esInfo The {@link EsInfo} passed to {@link #createPayloadReader(int, EsInfo)}.
+   * @param esInfo The {@link EsInfo} passed to {@link #createPayloadReader(int, EsInfo, hlsEncryptInfo)}.
    * @return A {@link SeiReader} for closed caption tracks.
    */
   private SeiReader buildSeiReader(EsInfo esInfo) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index da2c2c7704..04ed9b12dc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.SparseArray;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -29,582 +28,560 @@
 import com.google.android.exoplayer2.util.NalUnitUtil.SpsData;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.ParsableNalUnitBitArray;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Vector;
-
-import android.util.Log;
 
 /**
  * Parses a continuous H264 byte stream and extracts individual frames.
  */
 public final class H264Reader implements ElementaryStreamReader {
-    private static final String TAG = "H264Reader";
-
-    private final SeiReader seiReader;
-    private final boolean allowNonIdrKeyframes;
-    private final boolean detectAccessUnits;
-    private final NalUnitTargetBuffer sps;
-    private final NalUnitTargetBuffer pps;
-    private final NalUnitTargetBuffer sei;
-    private long totalBytesWritten;
-    private final boolean[] prefixFlags;
-
-    private ParsableByteArray sampleData;
-    private int writtenSampleSize;
-    private int mMode = C.TS_STREAM_TYPE_H264;
-
-    private byte[] encryptionKey;
-    private byte[] encryptionIv;
-
-    private HLSEncryptInfo hlsEncryptInfo;
-
-    private boolean bFirstSample;
-    private String formatId;
-    private TrackOutput output;
-    private SampleReader sampleReader;
-
-    // State that should not be reset on seek.
-    private boolean hasOutputFormat;
-
-    // Per packet state that gets reset at the start of each packet.
-    private long pesTimeUs;
 
-    // Scratch variables to avoid allocations.
-    private final ParsableByteArray seiWrapper;
-
-    /**
-     * @param seiReader            An SEI reader for consuming closed caption channels.
-     * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
-     *                             synchronization samples (key-frames).
-     * @param detectAccessUnits    Whether to split the input stream into access units (samples) based on
-     *                             slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
-     */
-    public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
-        this.seiReader = seiReader;
-        this.allowNonIdrKeyframes = allowNonIdrKeyframes;
-        this.detectAccessUnits = detectAccessUnits;
-        prefixFlags = new boolean[3];
-        sps = new NalUnitTargetBuffer(C.NAL_UNIT_TYPE_SPS, 128);
-        pps = new NalUnitTargetBuffer(C.NAL_UNIT_TYPE_PPS, 128);
-        sei = new NalUnitTargetBuffer(C.NAL_UNIT_TYPE_SEI, 128);
-        seiWrapper = new ParsableByteArray();
-
-        bFirstSample = true;
-        sampleData = new ParsableByteArray();
-        writtenSampleSize = 0;
+  private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
+  private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
+  private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
+
+  private final SeiReader seiReader;
+  private final boolean allowNonIdrKeyframes;
+  private final boolean detectAccessUnits;
+  private final NalUnitTargetBuffer sps;
+  private final NalUnitTargetBuffer pps;
+  private final NalUnitTargetBuffer sei;
+  private long totalBytesWritten;
+  private final boolean[] prefixFlags;
+
+  private String formatId;
+  private TrackOutput output;
+  private SampleReader sampleReader;
+
+  // State that should not be reset on seek.
+  private boolean hasOutputFormat;
+
+  // Per packet state that gets reset at the start of each packet.
+  private long pesTimeUs;
+
+  // Scratch variables to avoid allocations.
+  private final ParsableByteArray seiWrapper;
+
+  private ParsableByteArray sampleData;
+  private int writtenSampleSize;
+  private int mMode = C.TS_STREAM_TYPE_H264;
+  private byte[] encryptionKey;
+  private byte[] encryptionIv;
+  private HLSEncryptInfo hlsEncryptInfo;
+
+  private boolean bFirstSample;
+
+  /**
+   * @param seiReader An SEI reader for consuming closed caption channels.
+   * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
+   *     synchronization samples (key-frames).
+   * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
+   *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
+   */
+  public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
+    this.seiReader = seiReader;
+    this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+    this.detectAccessUnits = detectAccessUnits;
+    prefixFlags = new boolean[3];
+    sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
+    pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
+    sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
+    seiWrapper = new ParsableByteArray();
+
+    bFirstSample = true;
+    sampleData = new ParsableByteArray();
+    writtenSampleSize = 0;
+  }
+
+  public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits, int streamType, HLSEncryptInfo hlsEncryptInfo) {
+    this(seiReader, allowNonIdrKeyframes, detectAccessUnits);
+    this.mMode = streamType;
+    this.hlsEncryptInfo = hlsEncryptInfo;
+    if (hlsEncryptInfo != null) {
+      this.encryptionIv = hlsEncryptInfo.encryptionIv;
+      this.encryptionKey = hlsEncryptInfo.encryptionKey;
+    }
+  }
+
+  @Override
+  public void seek() {
+    NalUnitUtil.clearPrefixFlags(prefixFlags);
+    sps.reset();
+    pps.reset();
+    sei.reset();
+    sampleReader.reset();
+    totalBytesWritten = 0;
+  }
+
+  @Override
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
+    sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
+    seiReader.createTracks(extractorOutput, idGenerator);
+  }
+
+  @Override
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    this.pesTimeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
+    int offset = data.getPosition();
+    int limit = data.limit();
+    byte[] dataArray = data.data;
+    int size = data.bytesLeft();
+
+    // Append the data to the buffer.
+    totalBytesWritten += data.bytesLeft();
+    data.setPosition(offset + size);
+
+    if (bFirstSample) {
+      bFirstSample = false;
+      sampleData.reset(size);
+      System.arraycopy(data.data, offset, sampleData.data, sampleData.getPosition(), size);
+    } else {
+      int curLeft = sampleData.bytesLeft();
+      byte[] leftData = new byte[curLeft];
+      if (curLeft > 0) {
+        System.arraycopy(sampleData.data, sampleData.getPosition(), leftData, 0, curLeft);
+      }
+      sampleData.reset(curLeft + size);
+      if (curLeft > 0) {
+        System.arraycopy(leftData, 0, sampleData.data, 0, curLeft);
+      }
+      System.arraycopy(data.data, offset, sampleData.data, curLeft, size);
+    }
 
+    // Scan the appended data, processing NAL units as they are encountered
+    while (true) {
+      int nalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
+
+      if (nalUnitOffset == limit) {
+        // We've scanned to the end of the data without finding the start of another NAL unit.
+        nalUnitData(dataArray, offset, limit);
+        return;
+      }
+
+      // We've seen the start of a NAL unit of the following type.
+      int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nalUnitOffset);
+
+      // This is the number of bytes from the current offset to the start of the next NAL unit.
+      // It may be negative if the NAL unit started in the previously consumed data.
+      int lengthToNalUnit = nalUnitOffset - offset;
+      if (lengthToNalUnit > 0) {
+        nalUnitData(dataArray, offset, nalUnitOffset);
+      }
+      int bytesWrittenPastPosition = limit - nalUnitOffset;
+      long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
+      // Indicate the end of the previous NAL unit. If the length to the start of the next unit
+      // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
+      // when notifying that the unit has ended.
+      endNalUnit(nalUnitType, absolutePosition, bytesWrittenPastPosition,
+          lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
+      // Indicate the start of the next NAL unit.
+      startNalUnit(absolutePosition, nalUnitType, pesTimeUs);
+      // Continue scanning the data.
+      offset = nalUnitOffset + 3;
     }
+  }
 
-    public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits, int streamType, HLSEncryptInfo hlsEncryptInfo) {
-        this(seiReader, allowNonIdrKeyframes, detectAccessUnits);
-        this.mMode = streamType;
-        this.hlsEncryptInfo = hlsEncryptInfo;
-        if (hlsEncryptInfo != null) {
-            this.encryptionIv = hlsEncryptInfo.encryptionIv;
-            this.encryptionKey = hlsEncryptInfo.encryptionKey;
-        }
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
 
+  private void startNalUnit(long position, int nalUnitType, long pesTimeUs) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+      sps.startNalUnit(nalUnitType);
+      pps.startNalUnit(nalUnitType);
     }
-
-    @Override
-    public void seek() {
-        NalUnitUtil.clearPrefixFlags(prefixFlags);
+    sei.startNalUnit(nalUnitType);
+    sampleReader.startNalUnit(position, nalUnitType, pesTimeUs);
+  }
+
+  private void nalUnitData(byte[] dataArray, int offset, int limit) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+      sps.appendToNalUnit(dataArray, offset, limit);
+      pps.appendToNalUnit(dataArray, offset, limit);
+    }
+    sei.appendToNalUnit(dataArray, offset, limit);
+    sampleReader.appendToNalUnit(dataArray, offset, limit);
+  }
+
+  private void endNalUnit(int curNALType, long position, int offset, int discardPadding, long pesTimeUs) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+      sps.endNalUnit(discardPadding);
+      pps.endNalUnit(discardPadding);
+      if (!hasOutputFormat) {
+        if (sps.isCompleted() && pps.isCompleted()) {
+          List<byte[]> initializationData = new ArrayList<>();
+          initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
+          initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
+          NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
+          NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
+          output.format(Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H264, null,
+              Format.NO_VALUE, Format.NO_VALUE, spsData.width, spsData.height, Format.NO_VALUE,
+              initializationData, Format.NO_VALUE, spsData.pixelWidthAspectRatio, null));
+          hasOutputFormat = true;
+          sampleReader.putSps(spsData);
+          sampleReader.putPps(ppsData);
+          sps.reset();
+          pps.reset();
+        }
+      } else if (sps.isCompleted()) {
+        NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
+        sampleReader.putSps(spsData);
         sps.reset();
+      } else if (pps.isCompleted()) {
+        NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
+        sampleReader.putPps(ppsData);
         pps.reset();
-        sei.reset();
-        sampleReader.reset();
-        totalBytesWritten = 0;
+      }
     }
-
-    @Override
-    public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-        idGenerator.generateNewId();
-        formatId = idGenerator.getFormatId();
-        output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
-        sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
-        seiReader.createTracks(extractorOutput, idGenerator);
+    if (sei.endNalUnit(discardPadding)) {
+      int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
+      seiWrapper.reset(sei.nalData, unescapedLength);
+      seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
+      seiReader.consume(pesTimeUs, seiWrapper);
     }
+    sampleReader.endNalUnit(curNALType, position, offset);
+  }
 
-    @Override
-    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-        this.pesTimeUs = pesTimeUs;
-    }
+  /**
+   * Consumes a stream of NAL units and outputs samples.
+   */
+  private final class SampleReader {
 
-    @Override
-    public void consume(ParsableByteArray data) {
-        int offset = data.getPosition();
-        int limit = data.limit();
-        byte[] dataArray = data.data;
-        int size = data.bytesLeft();
-
-        // Append the data to the buffer.
-        totalBytesWritten += data.bytesLeft();
-
-        data.setPosition(offset + size);
-
-
-        if (bFirstSample) {
-            bFirstSample = false;
-            sampleData.reset(size);
-            System.arraycopy(data.data, offset, sampleData.data, sampleData.getPosition(), size);
-        } else {
-
-            int curLeft = sampleData.bytesLeft();
-            byte[] leftData = new byte[curLeft];
-            if (curLeft > 0) {
-                System.arraycopy(sampleData.data, sampleData.getPosition(), leftData, 0, curLeft);
-            }
-            sampleData.reset(curLeft + size);
-            if (curLeft > 0) {
-                System.arraycopy(leftData, 0, sampleData.data, 0, curLeft);
-            }
-            System.arraycopy(data.data, offset, sampleData.data, curLeft, size);
-        }
+    private static final int DEFAULT_BUFFER_SIZE = 128;
 
+    private static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
+    private static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
+    private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
+    private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
-        // Scan the appended data, processing NAL units as they are encountered
-        while (true) {
-            int nalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
-
-            int mybytesWrittenPastPosition = limit - nalUnitOffset;
-            int myabsolutePosition = (int) (totalBytesWritten - mybytesWrittenPastPosition);
-
-            if (nalUnitOffset == limit) {
-                // We've scanned to the end of the data without finding the start of another NAL unit.
-                nalUnitData(dataArray, offset, limit, myabsolutePosition, mybytesWrittenPastPosition);
-                return;
-            }
-
-            // We've seen the start of a NAL unit of the following type.
-            int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nalUnitOffset);
-
-            // This is the number of bytes from the current offset to the start of the next NAL unit.
-            // It may be negative if the NAL unit started in the previously consumed data.
-            int lengthToNalUnit = nalUnitOffset - offset;
-            if (lengthToNalUnit > 0) {
-                nalUnitData(dataArray, offset, nalUnitOffset, -1, -1);
-            }
-
-            int bytesWrittenPastPosition = limit - nalUnitOffset;
-            long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
-            // Indicate the end of the previous NAL unit. If the length to the start of the next unit
-            // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
-            // when notifying that the unit has ended.
-            endNalUnit(nalUnitType, absolutePosition, bytesWrittenPastPosition,
-                    lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
-            // Indicate the start of the next NAL unit.
-            startNalUnit(absolutePosition, nalUnitType, pesTimeUs);
-            // Continue scanning the data.
-            offset = nalUnitOffset + 3;
-        }
+    private final TrackOutput output;
+    private final boolean allowNonIdrKeyframes;
+    private final boolean detectAccessUnits;
+    private final SparseArray<NalUnitUtil.SpsData> sps;
+    private final SparseArray<NalUnitUtil.PpsData> pps;
+    private final ParsableNalUnitBitArray bitArray;
+
+    private byte[] buffer;
+    private int bufferLength;
+
+    // Per NAL unit state. A sample consists of one or more NAL units.
+    private int nalUnitType;
+    private long nalUnitStartPosition;
+    private boolean isFilling;
+    private long nalUnitTimeUs;
+    private SliceHeaderData previousSliceHeader;
+    private SliceHeaderData sliceHeader;
+
+    // Per sample state that gets reset at the start of each sample.
+    private boolean readingSample;
+    private long samplePosition;
+    private long sampleTimeUs;
+    private boolean sampleIsKeyframe;
+
+    public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
+        boolean detectAccessUnits) {
+      this.output = output;
+      this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+      this.detectAccessUnits = detectAccessUnits;
+      sps = new SparseArray<>();
+      pps = new SparseArray<>();
+      previousSliceHeader = new SliceHeaderData();
+      sliceHeader = new SliceHeaderData();
+      buffer = new byte[DEFAULT_BUFFER_SIZE];
+      bitArray = new ParsableNalUnitBitArray(buffer, 0, 0);
+      reset();
     }
 
-    @Override
-    public void packetFinished() {
-        // Do nothing.
+    public boolean needsSpsPps() {
+      return detectAccessUnits;
     }
 
-    private void startNalUnit(long position, int nalUnitType, long pesTimeUs) {
-        if (!hasOutputFormat || sampleReader.needsSpsPps()) {
-            sps.startNalUnit(nalUnitType);
-            pps.startNalUnit(nalUnitType);
-        }
-        //  sei.startNalUnit(nalUnitType);
-        sampleReader.startNalUnit(position, nalUnitType, pesTimeUs);
+    public void putSps(NalUnitUtil.SpsData spsData) {
+      sps.append(spsData.seqParameterSetId, spsData);
     }
 
-    private void nalUnitData(byte[] dataArray, int offset, int limit, int mybytesWrittenPastPosition, int myabsolutePosition) {
-        if (!hasOutputFormat || sampleReader.needsSpsPps()) {
-            sps.appendToNalUnit(dataArray, offset, limit);
-            pps.appendToNalUnit(dataArray, offset, limit);
-        }
-        //sei.appendToNalUnit(dataArray, offset, limit);
-        sampleReader.appendToNalUnit(dataArray, offset, limit, mybytesWrittenPastPosition, myabsolutePosition);
+    public void putPps(NalUnitUtil.PpsData ppsData) {
+      pps.append(ppsData.picParameterSetId, ppsData);
     }
 
-    private void endNalUnit(int nalUnitType, long position, int offset, int discardPadding, long pesTimeUs) {
-        if (!hasOutputFormat || sampleReader.needsSpsPps()) {
-            sps.endNalUnit(discardPadding);
-            pps.endNalUnit(discardPadding);
-            if (!hasOutputFormat) {
-                if (sps.isCompleted() && pps.isCompleted()) {
-                    List<byte[]> initializationData = new ArrayList<>();
-                    initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
-                    initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
-                    NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
-                    NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
-
-
-                    output.format(Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H264, null,
-                            Format.NO_VALUE, Format.NO_VALUE, spsData.width, spsData.height, Format.NO_VALUE,
-                            initializationData, Format.NO_VALUE, spsData.pixelWidthAspectRatio, null, mMode));
-
-                    hasOutputFormat = true;
-                    sampleReader.putSps(spsData);
-                    sampleReader.putPps(ppsData);
-                    sps.reset();
-                    pps.reset();
-                }
-            } else if (sps.isCompleted()) {
-                NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
-                sampleReader.putSps(spsData);
-                sps.reset();
-            } else if (pps.isCompleted()) {
-                NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
-                sampleReader.putPps(ppsData);
-                pps.reset();
-            }
-        }
-
-        // if (sei.endNalUnit(discardPadding)) {
-        //  int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
-        // seiWrapper.reset(sei.nalData, unescapedLength);
-        //  seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
-        // seiReader.consume(pesTimeUs, seiWrapper);
-        //  }
-        sampleReader.endNalUnit(nalUnitType, position, offset);
+    public void reset() {
+      isFilling = false;
+      readingSample = false;
+      sliceHeader.clear();
     }
 
+    public void startNalUnit(long position, int type, long pesTimeUs) {
+      nalUnitType = type;
+      nalUnitTimeUs = pesTimeUs;
+      nalUnitStartPosition = position;
+      if ((allowNonIdrKeyframes && nalUnitType == NAL_UNIT_TYPE_NON_IDR)
+          || (detectAccessUnits && (nalUnitType == NAL_UNIT_TYPE_IDR
+              || nalUnitType == NAL_UNIT_TYPE_NON_IDR
+              || nalUnitType == NAL_UNIT_TYPE_PARTITION_A))) {
+        // Store the previous header and prepare to populate the new one.
+        SliceHeaderData newSliceHeader = previousSliceHeader;
+        previousSliceHeader = sliceHeader;
+        sliceHeader = newSliceHeader;
+        sliceHeader.clear();
+        bufferLength = 0;
+        isFilling = true;
+      }
+    }
 
     /**
-     * Consumes a stream of NAL units and outputs samples.
+     * Called to pass stream data. The data passed should not include the 3 byte start code.
+     *
+     * @param data Holds the data being passed.
+     * @param offset The offset of the data in {@code data}.
+     * @param limit The limit (exclusive) of the data in {@code data}.
      */
-    private final class SampleReader {
-        private static final int DEFAULT_BUFFER_SIZE = 128;
-
-        private final TrackOutput output;
-        private final boolean allowNonIdrKeyframes;
-        private final boolean detectAccessUnits;
-        private final SparseArray<NalUnitUtil.SpsData> sps;
-        private final SparseArray<NalUnitUtil.PpsData> pps;
-        private final ParsableNalUnitBitArray bitArray;
-
-        private byte[] buffer;
-        private int bufferLength;
-
-        // Per NAL unit state. A sample consists of one or more NAL units.
-        private int nalUnitType;
-        private long nalUnitStartPosition;
-        private boolean isFilling;
-        private long nalUnitTimeUs;
-        private SliceHeaderData previousSliceHeader;
-        private SliceHeaderData sliceHeader;
-
-        // Per sample state that gets reset at the start of each sample.
-        private boolean readingSample;
-        private long samplePosition;
-        private long sampleTimeUs;
-        private boolean sampleIsKeyframe;
-
-        public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
-                            boolean detectAccessUnits) {
-            this.output = output;
-            this.allowNonIdrKeyframes = allowNonIdrKeyframes;
-            this.detectAccessUnits = detectAccessUnits;
-            sps = new SparseArray<>();
-            pps = new SparseArray<>();
-            previousSliceHeader = new SliceHeaderData();
-            sliceHeader = new SliceHeaderData();
-            buffer = new byte[DEFAULT_BUFFER_SIZE];
-            bitArray = new ParsableNalUnitBitArray(buffer, 0, 0);
-            reset();
+    public void appendToNalUnit(byte[] data, int offset, int limit) {
+      if (!isFilling) {
+        return;
+      }
+      int readLength = limit - offset;
+      if (buffer.length < bufferLength + readLength) {
+        buffer = Arrays.copyOf(buffer, (bufferLength + readLength) * 2);
+      }
+      System.arraycopy(data, offset, buffer, bufferLength, readLength);
+      bufferLength += readLength;
+
+      bitArray.reset(buffer, 0, bufferLength);
+      if (!bitArray.canReadBits(8)) {
+        return;
+      }
+      bitArray.skipBits(1); // forbidden_zero_bit
+      int nalRefIdc = bitArray.readBits(2);
+      bitArray.skipBits(5); // nal_unit_type
+
+      // Read the slice header using the syntax defined in ITU-T Recommendation H.264 (2013)
+      // subsection 7.3.3.
+      if (!bitArray.canReadExpGolombCodedNum()) {
+        return;
+      }
+      bitArray.readUnsignedExpGolombCodedInt(); // first_mb_in_slice
+      if (!bitArray.canReadExpGolombCodedNum()) {
+        return;
+      }
+      int sliceType = bitArray.readUnsignedExpGolombCodedInt();
+      if (!detectAccessUnits) {
+        // There are AUDs in the stream so the rest of the header can be ignored.
+        isFilling = false;
+        sliceHeader.setSliceType(sliceType);
+        return;
+      }
+      if (!bitArray.canReadExpGolombCodedNum()) {
+        return;
+      }
+      int picParameterSetId = bitArray.readUnsignedExpGolombCodedInt();
+      if (pps.indexOfKey(picParameterSetId) < 0) {
+        // We have not seen the PPS yet, so don't try to decode the slice header.
+        isFilling = false;
+        return;
+      }
+      NalUnitUtil.PpsData ppsData = pps.get(picParameterSetId);
+      NalUnitUtil.SpsData spsData = sps.get(ppsData.seqParameterSetId);
+      if (spsData.separateColorPlaneFlag) {
+        if (!bitArray.canReadBits(2)) {
+          return;
         }
-
-        public boolean needsSpsPps() {
-            return detectAccessUnits;
+        bitArray.skipBits(2); // colour_plane_id
+      }
+      if (!bitArray.canReadBits(spsData.frameNumLength)) {
+        return;
+      }
+      boolean fieldPicFlag = false;
+      boolean bottomFieldFlagPresent = false;
+      boolean bottomFieldFlag = false;
+      int frameNum = bitArray.readBits(spsData.frameNumLength);
+      if (!spsData.frameMbsOnlyFlag) {
+        if (!bitArray.canReadBits(1)) {
+          return;
         }
-
-        public void putSps(NalUnitUtil.SpsData spsData) {
-            sps.append(spsData.seqParameterSetId, spsData);
+        fieldPicFlag = bitArray.readBit();
+        if (fieldPicFlag) {
+          if (!bitArray.canReadBits(1)) {
+            return;
+          }
+          bottomFieldFlag = bitArray.readBit();
+          bottomFieldFlagPresent = true;
         }
-
-        public void putPps(NalUnitUtil.PpsData ppsData) {
-            pps.append(ppsData.picParameterSetId, ppsData);
+      }
+      boolean idrPicFlag = nalUnitType == NAL_UNIT_TYPE_IDR;
+      int idrPicId = 0;
+      if (idrPicFlag) {
+        if (!bitArray.canReadExpGolombCodedNum()) {
+          return;
         }
-
-        public void reset() {
-            isFilling = false;
-            readingSample = false;
-            sliceHeader.clear();
+        idrPicId = bitArray.readUnsignedExpGolombCodedInt();
+      }
+      int picOrderCntLsb = 0;
+      int deltaPicOrderCntBottom = 0;
+      int deltaPicOrderCnt0 = 0;
+      int deltaPicOrderCnt1 = 0;
+      if (spsData.picOrderCountType == 0) {
+        if (!bitArray.canReadBits(spsData.picOrderCntLsbLength)) {
+          return;
         }
-
-        public void startNalUnit(long position, int type, long pesTimeUs) {
-            nalUnitType = type;
-            nalUnitTimeUs = pesTimeUs;
-            nalUnitStartPosition = position;
-
-            if ((allowNonIdrKeyframes && nalUnitType == C.NAL_UNIT_TYPE_NON_IDR)
-                    || (detectAccessUnits && (nalUnitType == C.NAL_UNIT_TYPE_IDR
-                    || nalUnitType == C.NAL_UNIT_TYPE_NON_IDR
-                    || nalUnitType == C.NAL_UNIT_TYPE_PARTITION_A))) {
-                // Store the previous header and prepare to populate the new one.
-                SliceHeaderData newSliceHeader = previousSliceHeader;
-                previousSliceHeader = sliceHeader;
-                sliceHeader = newSliceHeader;
-                sliceHeader.clear();
-                bufferLength = 0;
-                isFilling = true;
-            }
+        picOrderCntLsb = bitArray.readBits(spsData.picOrderCntLsbLength);
+        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+          if (!bitArray.canReadExpGolombCodedNum()) {
+            return;
+          }
+          deltaPicOrderCntBottom = bitArray.readSignedExpGolombCodedInt();
         }
-
-        /**
-         * Called to pass stream data. The data passed should not include the 3 byte start code.
-         *
-         * @param data   Holds the data being passed.
-         * @param offset The offset of the data in {@code data}.
-         * @param limit  The limit (exclusive) of the data in {@code data}.
-         */
-        public void appendToNalUnit(byte[] data, int offset, int limit, int mybytesWrittenPastPosition, int myabsolutePosition) {
-            if (!isFilling) {
-                return;
-            }
-            int readLength = limit - offset;
-            if (buffer.length < bufferLength + readLength) {
-                buffer = Arrays.copyOf(buffer, (bufferLength + readLength) * 2);
-            }
-            System.arraycopy(data, offset, buffer, bufferLength, readLength);
-            bufferLength += readLength;
-
-            bitArray.reset(buffer, 0, bufferLength);
-            if (!bitArray.canReadBits(8)) {
-                return;
-            }
-            bitArray.skipBits(1); // forbidden_zero_bit
-            int nalRefIdc = bitArray.readBits(2);
-            bitArray.skipBits(5); // nal_unit_type
-
-            // Read the slice header using the syntax defined in ITU-T Recommendation H.264 (2013)
-            // subsection 7.3.3.
-            if (!bitArray.canReadExpGolombCodedNum()) {
-                return;
-            }
-            bitArray.readUnsignedExpGolombCodedInt(); // first_mb_in_slice
-            if (!bitArray.canReadExpGolombCodedNum()) {
-                return;
-            }
-            int sliceType = bitArray.readUnsignedExpGolombCodedInt();
-            if (!detectAccessUnits) {
-                // There are AUDs in the stream so the rest of the header can be ignored.
-                isFilling = false;
-                sliceHeader.setSliceType(sliceType);
-                return;
-            }
-            if (!bitArray.canReadExpGolombCodedNum()) {
-                return;
-            }
-            int picParameterSetId = bitArray.readUnsignedExpGolombCodedInt();
-            if (pps.indexOfKey(picParameterSetId) < 0) {
-                // We have not seen the PPS yet, so don't try to decode the slice header.
-                isFilling = false;
-                return;
-            }
-            NalUnitUtil.PpsData ppsData = pps.get(picParameterSetId);
-            NalUnitUtil.SpsData spsData = sps.get(ppsData.seqParameterSetId);
-            if (spsData.separateColorPlaneFlag) {
-                if (!bitArray.canReadBits(2)) {
-                    return;
-                }
-                bitArray.skipBits(2); // colour_plane_id
-            }
-            if (!bitArray.canReadBits(spsData.frameNumLength)) {
-                return;
-            }
-            boolean fieldPicFlag = false;
-            boolean bottomFieldFlagPresent = false;
-            boolean bottomFieldFlag = false;
-            int frameNum = bitArray.readBits(spsData.frameNumLength);
-            if (!spsData.frameMbsOnlyFlag) {
-                if (!bitArray.canReadBits(1)) {
-                    return;
-                }
-                fieldPicFlag = bitArray.readBit();
-                if (fieldPicFlag) {
-                    if (!bitArray.canReadBits(1)) {
-                        return;
-                    }
-                    bottomFieldFlag = bitArray.readBit();
-                    bottomFieldFlagPresent = true;
-                }
-            }
-            boolean idrPicFlag = nalUnitType == C.NAL_UNIT_TYPE_IDR;
-            int idrPicId = 0;
-            if (idrPicFlag) {
-                if (!bitArray.canReadExpGolombCodedNum()) {
-                    return;
-                }
-                idrPicId = bitArray.readUnsignedExpGolombCodedInt();
-            }
-            int picOrderCntLsb = 0;
-            int deltaPicOrderCntBottom = 0;
-            int deltaPicOrderCnt0 = 0;
-            int deltaPicOrderCnt1 = 0;
-            if (spsData.picOrderCountType == 0) {
-                if (!bitArray.canReadBits(spsData.picOrderCntLsbLength)) {
-                    return;
-                }
-                picOrderCntLsb = bitArray.readBits(spsData.picOrderCntLsbLength);
-                if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
-                    if (!bitArray.canReadExpGolombCodedNum()) {
-                        return;
-                    }
-                    deltaPicOrderCntBottom = bitArray.readSignedExpGolombCodedInt();
-                }
-            } else if (spsData.picOrderCountType == 1
-                    && !spsData.deltaPicOrderAlwaysZeroFlag) {
-                if (!bitArray.canReadExpGolombCodedNum()) {
-                    return;
-                }
-                deltaPicOrderCnt0 = bitArray.readSignedExpGolombCodedInt();
-                if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
-                    if (!bitArray.canReadExpGolombCodedNum()) {
-                        return;
-                    }
-                    deltaPicOrderCnt1 = bitArray.readSignedExpGolombCodedInt();
-                }
-            }
-            sliceHeader.setAll(spsData, nalRefIdc, sliceType, frameNum, picParameterSetId, fieldPicFlag,
-                    bottomFieldFlagPresent, bottomFieldFlag, idrPicFlag, idrPicId, picOrderCntLsb,
-                    deltaPicOrderCntBottom, deltaPicOrderCnt0, deltaPicOrderCnt1);
-            isFilling = false;
+      } else if (spsData.picOrderCountType == 1
+          && !spsData.deltaPicOrderAlwaysZeroFlag) {
+        if (!bitArray.canReadExpGolombCodedNum()) {
+          return;
+        }
+        deltaPicOrderCnt0 = bitArray.readSignedExpGolombCodedInt();
+        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+          if (!bitArray.canReadExpGolombCodedNum()) {
+            return;
+          }
+          deltaPicOrderCnt1 = bitArray.readSignedExpGolombCodedInt();
         }
+      }
+      sliceHeader.setAll(spsData, nalRefIdc, sliceType, frameNum, picParameterSetId, fieldPicFlag,
+          bottomFieldFlagPresent, bottomFieldFlag, idrPicFlag, idrPicId, picOrderCntLsb,
+          deltaPicOrderCntBottom, deltaPicOrderCnt0, deltaPicOrderCnt1);
+      isFilling = false;
+    }
+
+    public void endNalUnit(int curNALUnitType, long position, int offset) {
 
+      int size = (int) (position - nalUnitStartPosition);
+      Assertions.checkArgument(size > 0);
 
-        public void endNalUnit(int curNALUnitType, long position, int offset) {
-            int size = (int) (position - nalUnitStartPosition);
-            Assertions.checkArgument(size > 0);
-
-            if (mMode == C.TS_STREAM_TYPE_SAMPLE_AES_H264) {
-                int previousNALUnitType = nalUnitType;
-
-                if (curNALUnitType == 5 && curNALUnitType == previousNALUnitType) {
-                    C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
-                }
-                if (curNALUnitType == 1 && curNALUnitType == previousNALUnitType) {
-                    C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
-                }
-
-                if (curNALUnitType == C.NAL_UNIT_TYPE_AUD) {
-                    if ((previousNALUnitType == C.NAL_UNIT_TYPE_IDR) || (previousNALUnitType == C.NAL_UNIT_TYPE_SLICE)) {
-                        C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
-                    }
-                }
-            }
-
-            output.sampleData(sampleData, size);
-            writtenSampleSize += size;
-
-            if (nalUnitType == C.NAL_UNIT_TYPE_AUD
-                    || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
-                // If the NAL unit ending is the start of a new sample, output the previous one.
-                if (readingSample) {
-                    int nalUnitLength = (int) (position - nalUnitStartPosition);
-                    @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
-
-                    int newsize = (int) (nalUnitStartPosition - samplePosition);
-                    int newOffset = 0;
-
-                    newOffset = (int) (writtenSampleSize - totalBytesWritten) + offset + nalUnitLength;
-                    output.sampleMetadata(sampleTimeUs, flags, newsize, newOffset, null);
-                }
-                samplePosition = nalUnitStartPosition;
-                sampleTimeUs = nalUnitTimeUs;
-                sampleIsKeyframe = false;
-                readingSample = true;
-            }
-            sampleIsKeyframe |= nalUnitType == C.NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
-                    && nalUnitType == C.NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
+      if (mMode == C.TS_STREAM_TYPE_SAMPLE_AES_H264) {
+        int previousNALUnitType = nalUnitType;
+        if (curNALUnitType == 5 && curNALUnitType == previousNALUnitType) {
+          C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
+        }
+        if (curNALUnitType == 1 && curNALUnitType == previousNALUnitType) {
+          C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
         }
 
+        if (curNALUnitType == C.NAL_UNIT_TYPE_AUD) {
+          if ((previousNALUnitType == C.NAL_UNIT_TYPE_IDR) || (previousNALUnitType == C.NAL_UNIT_TYPE_SLICE)) {
+            C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
+          }
+        }
+      }
 
-        /*
-            private void outputSample(int offset) {
-              @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
-              int size = (int) (nalUnitStartPosition - samplePosition);
-              output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
-            }
-            */
-        private final class SliceHeaderData {
-
-            private static final int SLICE_TYPE_I = 2;
-            private static final int SLICE_TYPE_ALL_I = 7;
-
-            private boolean isComplete;
-            private boolean hasSliceType;
-
-            private SpsData spsData;
-            private int nalRefIdc;
-            private int sliceType;
-            private int frameNum;
-            private int picParameterSetId;
-            private boolean fieldPicFlag;
-            private boolean bottomFieldFlagPresent;
-            private boolean bottomFieldFlag;
-            private boolean idrPicFlag;
-            private int idrPicId;
-            private int picOrderCntLsb;
-            private int deltaPicOrderCntBottom;
-            private int deltaPicOrderCnt0;
-            private int deltaPicOrderCnt1;
-
-            public void clear() {
-                hasSliceType = false;
-                isComplete = false;
-            }
-
-            public void setSliceType(int sliceType) {
-                this.sliceType = sliceType;
-                hasSliceType = true;
-            }
-
-            public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
-                               int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
-                               boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
-                               int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
-                this.spsData = spsData;
-                this.nalRefIdc = nalRefIdc;
-                this.sliceType = sliceType;
-                this.frameNum = frameNum;
-                this.picParameterSetId = picParameterSetId;
-                this.fieldPicFlag = fieldPicFlag;
-                this.bottomFieldFlagPresent = bottomFieldFlagPresent;
-                this.bottomFieldFlag = bottomFieldFlag;
-                this.idrPicFlag = idrPicFlag;
-                this.idrPicId = idrPicId;
-                this.picOrderCntLsb = picOrderCntLsb;
-                this.deltaPicOrderCntBottom = deltaPicOrderCntBottom;
-                this.deltaPicOrderCnt0 = deltaPicOrderCnt0;
-                this.deltaPicOrderCnt1 = deltaPicOrderCnt1;
-                isComplete = true;
-                hasSliceType = true;
-            }
-
-            public boolean isISlice() {
-                return hasSliceType && (sliceType == SLICE_TYPE_ALL_I || sliceType == SLICE_TYPE_I);
-            }
-
-            private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
-                // See ISO 14496-10 subsection 7.4.1.2.4.
-                return isComplete && (!other.isComplete || frameNum != other.frameNum
-                        || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
-                        || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
-                        && bottomFieldFlag != other.bottomFieldFlag)
-                        || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
-                        || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
-                        && (picOrderCntLsb != other.picOrderCntLsb
-                        || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
-                        || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
-                        && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
-                        || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
-                        || idrPicFlag != other.idrPicFlag
-                        || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
-            }
+      output.sampleData(sampleData, size);
+      writtenSampleSize += size;
 
+      if (nalUnitType == NAL_UNIT_TYPE_AUD
+          || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
+        // If the NAL unit ending is the start of a new sample, output the previous one.
+        if (readingSample) {
+          int nalUnitLength = (int) (position - nalUnitStartPosition);
+          outputSample((int) (writtenSampleSize - totalBytesWritten) + offset + nalUnitLength);
         }
+        samplePosition = nalUnitStartPosition;
+        sampleTimeUs = nalUnitTimeUs;
+        sampleIsKeyframe = false;
+        readingSample = true;
+      }
+      sampleIsKeyframe |= nalUnitType == NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
+          && nalUnitType == NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
+    }
+
+    private void outputSample(int offset) {
+      @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
+      int size = (int) (nalUnitStartPosition - samplePosition);
+      output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
+    }
+
+    private final class SliceHeaderData {
+
+      private static final int SLICE_TYPE_I = 2;
+      private static final int SLICE_TYPE_ALL_I = 7;
+
+      private boolean isComplete;
+      private boolean hasSliceType;
+
+      private SpsData spsData;
+      private int nalRefIdc;
+      private int sliceType;
+      private int frameNum;
+      private int picParameterSetId;
+      private boolean fieldPicFlag;
+      private boolean bottomFieldFlagPresent;
+      private boolean bottomFieldFlag;
+      private boolean idrPicFlag;
+      private int idrPicId;
+      private int picOrderCntLsb;
+      private int deltaPicOrderCntBottom;
+      private int deltaPicOrderCnt0;
+      private int deltaPicOrderCnt1;
+
+      public void clear() {
+        hasSliceType = false;
+        isComplete = false;
+      }
+
+      public void setSliceType(int sliceType) {
+        this.sliceType = sliceType;
+        hasSliceType = true;
+      }
+
+      public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
+          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
+          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
+          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+        this.spsData = spsData;
+        this.nalRefIdc = nalRefIdc;
+        this.sliceType = sliceType;
+        this.frameNum = frameNum;
+        this.picParameterSetId = picParameterSetId;
+        this.fieldPicFlag = fieldPicFlag;
+        this.bottomFieldFlagPresent = bottomFieldFlagPresent;
+        this.bottomFieldFlag = bottomFieldFlag;
+        this.idrPicFlag = idrPicFlag;
+        this.idrPicId = idrPicId;
+        this.picOrderCntLsb = picOrderCntLsb;
+        this.deltaPicOrderCntBottom = deltaPicOrderCntBottom;
+        this.deltaPicOrderCnt0 = deltaPicOrderCnt0;
+        this.deltaPicOrderCnt1 = deltaPicOrderCnt1;
+        isComplete = true;
+        hasSliceType = true;
+      }
+
+      public boolean isISlice() {
+        return hasSliceType && (sliceType == SLICE_TYPE_ALL_I || sliceType == SLICE_TYPE_I);
+      }
+
+      private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
+        // See ISO 14496-10 subsection 7.4.1.2.4.
+        return isComplete && (!other.isComplete || frameNum != other.frameNum
+            || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
+            || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
+                && bottomFieldFlag != other.bottomFieldFlag)
+            || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
+            || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
+                && (picOrderCntLsb != other.picOrderCntLsb
+                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+            || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
+                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+            || idrPicFlag != other.idrPicFlag
+            || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
+      }
 
     }
 
+  }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index c20dda2703..0e6d1f4d57 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -17,9 +17,9 @@
 
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
-import android.util.Log;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -38,6 +38,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -51,549 +52,512 @@
  */
 public final class TsExtractor implements Extractor {
 
-  /**
-   * Factory for {@link TsExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      Log.d("TsExtractor", "createExtractors");
-      return new Extractor[] {new TsExtractor()};
-    }
+    /**
+     * Factory for {@link TsExtractor} instances.
+     */
+    public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
 
-  };
-
-  /**
-   * Modes for the extractor.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({MODE_NORMAL, MODE_SINGLE_PMT, MODE_HLS})
-  public @interface Mode {}
-
-  /**
-   * Behave as defined in ISO/IEC 13818-1.
-   */
-  public static final int MODE_NORMAL = 0;
-  /**
-   * Assume only one PMT will be contained in the stream, even if more are declared by the PAT.
-   */
-  public static final int MODE_SINGLE_PMT = 1;
-  /**
-   * Enable single PMT mode, map {@link TrackOutput}s by their type (instead of PID) and ignore
-   * continuity counters.
-   */
-  public static final int MODE_HLS = 2;
-
-
-
-  public static final int TS_STREAM_TYPE_MPA = 0x03;
-  public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
-  public static final int TS_STREAM_TYPE_AAC = 0x0F;
-  public static final int TS_STREAM_TYPE_AC3 = 0x81;
-  public static final int TS_STREAM_TYPE_DTS = 0x8A;
-  public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
-  public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
-  public static final int TS_STREAM_TYPE_H262 = 0x02;
-  public static final int TS_STREAM_TYPE_H264 = 0x1B;
-  public static final int TS_STREAM_TYPE_H265 = 0x24;
-
-  public static final int TS_STREAM_TYPE_ID3 = 0x15;
-  public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
-  public static final int TS_STREAM_TYPE_DVBSUBS = 0x59;
-
-  private static final String TAG = "TsExtractor";
-  private static final int TS_PACKET_SIZE = 188;
-  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
-  private static final int TS_PAT_PID = 0;
-  private static final int MAX_PID_PLUS_ONE = 0x2000;
-
-  private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
-  private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
-  private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
-
-    private static final long ZAVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("ZAVC");
-
-  private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
-  private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
-
-  @Mode private final int mode;
-
-    private static int mMode = TS_STREAM_TYPE_H264;
-  //private  String encryptionMethod;
-  //2017-6-3,zhouwg, add it
- // private  byte[] encryptionKey;
-  //private  byte[] encryptionIv;
-  //2017-6-5,zhouwg, add it
- // private String encryptionKeyFormat;
-
-  //2017-6-7,zhouwg, add it
-  private HLSEncryptInfo hlsEncryptInfo;
-
-
-  private final List<TimestampAdjuster> timestampAdjusters;
-  private final ParsableByteArray tsPacketBuffer;
-  private final ParsableBitArray tsScratch;
-  private final SparseIntArray continuityCounters;
-  private final TsPayloadReader.Factory payloadReaderFactory;
-  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
-  private final SparseBooleanArray trackIds;
-
-  // Accessed only by the loading thread.
-  private ExtractorOutput output;
-  private int remainingPmts;
-  private boolean tracksEnded;
-  private TsPayloadReader id3Reader;
-
-  public TsExtractor() {
-    this(0);
-  }
-
-  public TsExtractor(int mode, int defaultTsPayloadReaderFlags) {
-    this(mode, new TimestampAdjuster(0),
-            new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
-  }
-  /**
-   * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
-   *     {@code FLAG_*} values that control the behavior of the payload readers.
-   */
-  public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
-    this(MODE_NORMAL, new TimestampAdjuster(0),
-        new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
-  }
-
-  //2017-6-3,zhouwg, add it
-  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
-                     TsPayloadReader.Factory payloadReaderFactory, HLSEncryptInfo hlsEncryptInfo) {
-    this(mode, timestampAdjuster, payloadReaderFactory);
-
-    //this.encryptionMethod = encryptionMethod;
-    //this.encryptionKeyFormat = encryptionKeyFormat;
-    //this.encryptionIv = encryptionIv;
-    //this.encryptionKey = encryptionKey;
-    this.hlsEncryptInfo = hlsEncryptInfo;
-
-  }
-  /**
-   * @param mode Mode for the extractor. One of {@link #MODE_NORMAL}, {@link #MODE_SINGLE_PMT}
-   *     and {@link #MODE_HLS}.
-   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
-   * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
-   */
-  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
-      TsPayloadReader.Factory payloadReaderFactory) {
-    this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
-    this.mode = mode;
-    if (mode == MODE_SINGLE_PMT || mode == MODE_HLS) {
-      timestampAdjusters = Collections.singletonList(timestampAdjuster);
-    } else {
-      timestampAdjusters = new ArrayList<>();
-      timestampAdjusters.add(timestampAdjuster);
-    }
-    tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
-    tsScratch = new ParsableBitArray(new byte[3]);
-    trackIds = new SparseBooleanArray();
-    tsPayloadReaders = new SparseArray<>();
-    continuityCounters = new SparseIntArray();
-    resetPayloadReaders();
-
-    //2017-6-3,zhouwg
-    //encryptionMethod = "";
-    //encryptionIv = new byte[16];
-    //encryptionKey = new byte[16];
-  }
-
-  // Extractor implementation.
-
-  @Override
-  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-    byte[] buffer = tsPacketBuffer.data;
-    input.peekFully(buffer, 0, BUFFER_SIZE);
-    for (int j = 0; j < TS_PACKET_SIZE; j++) {
-      for (int i = 0; true; i++) {
-        if (i == BUFFER_PACKET_COUNT) {
-          input.skipFully(j);
-          return true;
-        }
-        if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
-          break;
+        @Override
+        public Extractor[] createExtractors() {
+            return new Extractor[]{new TsExtractor()};
         }
-      }
-    }
-    return false;
-  }
-
-  @Override
-  public void init(ExtractorOutput output) {
-    this.output = output;
-    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
-  }
-
-  @Override
-  public void seek(long position, long timeUs) {
-    int timestampAdjustersCount = timestampAdjusters.size();
-    for (int i = 0; i < timestampAdjustersCount; i++) {
-      timestampAdjusters.get(i).reset();
-    }
-    tsPacketBuffer.reset();
-    continuityCounters.clear();
-    // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
-    resetPayloadReaders();
-  }
-
-  @Override
-  public void release() {
-    // Do nothing
-  }
-
-  @Override
-  public int read(ExtractorInput input, PositionHolder seekPosition)
-      throws IOException, InterruptedException {
-    byte[] data = tsPacketBuffer.data;
-    // Shift bytes to the start of the buffer if there isn't enough space left at the end
-    if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
-      int bytesLeft = tsPacketBuffer.bytesLeft();
-      if (bytesLeft > 0) {
-        System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
-      }
-      tsPacketBuffer.reset(data, bytesLeft);
-    }
-    // Read more bytes until there is at least one packet size
-    while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
-      int limit = tsPacketBuffer.limit();
-      int read = input.read(data, limit, BUFFER_SIZE - limit);
-      if (read == C.RESULT_END_OF_INPUT) {
-        return RESULT_END_OF_INPUT;
-      }
-      tsPacketBuffer.setLimit(limit + read);
-    }
 
-    // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
-    // the header.
-    final int limit = tsPacketBuffer.limit();
-    int position = tsPacketBuffer.getPosition();
-    while (position < limit && data[position] != TS_SYNC_BYTE) {
-      position++;
-    }
-    tsPacketBuffer.setPosition(position);
+    };
 
-    int endOfPacket = position + TS_PACKET_SIZE;
-    if (endOfPacket > limit) {
-      return RESULT_CONTINUE;
+    /**
+     * Modes for the extractor.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
+    public @interface Mode {
     }
 
-    tsPacketBuffer.skipBytes(1);
-    tsPacketBuffer.readBytes(tsScratch, 3);
-    if (tsScratch.readBit()) { // transport_error_indicator
-      // There are uncorrectable errors in this packet.
-      tsPacketBuffer.setPosition(endOfPacket);
-      return RESULT_CONTINUE;
+    /**
+     * Behave as defined in ISO/IEC 13818-1.
+     */
+    public static final int MODE_MULTI_PMT = 0;
+    /**
+     * Assume only one PMT will be contained in the stream, even if more are declared by the PAT.
+     */
+    public static final int MODE_SINGLE_PMT = 1;
+    /**
+     * Enable single PMT mode, map {@link TrackOutput}s by their type (instead of PID) and ignore
+     * continuity counters.
+     */
+    public static final int MODE_HLS = 2;
+
+    public static final int TS_STREAM_TYPE_MPA = 0x03;
+    public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
+    public static final int TS_STREAM_TYPE_AAC = 0x0F;
+    public static final int TS_STREAM_TYPE_AC3 = 0x81;
+    public static final int TS_STREAM_TYPE_DTS = 0x8A;
+    public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
+    public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
+    public static final int TS_STREAM_TYPE_H262 = 0x02;
+    public static final int TS_STREAM_TYPE_H264 = 0x1B;
+    public static final int TS_STREAM_TYPE_H265 = 0x24;
+    public static final int TS_STREAM_TYPE_ID3 = 0x15;
+    public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
+    public static final int TS_STREAM_TYPE_DVBSUBS = 0x59;
+
+    private static final int TS_PACKET_SIZE = 188;
+    private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
+    private static final int TS_PAT_PID = 0;
+    private static final int MAX_PID_PLUS_ONE = 0x2000;
+
+    private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
+    private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
+    private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
+
+    private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
+    private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
+
+    @Mode
+    private final int mode;
+    private final List<TimestampAdjuster> timestampAdjusters;
+    private final ParsableByteArray tsPacketBuffer;
+    private final ParsableBitArray tsScratch;
+    private final SparseIntArray continuityCounters;
+    private final TsPayloadReader.Factory payloadReaderFactory;
+    private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
+    private final SparseBooleanArray trackIds;
+
+    // Accessed only by the loading thread.
+    private ExtractorOutput output;
+    private int remainingPmts;
+    private boolean tracksEnded;
+    private TsPayloadReader id3Reader;
+
+    private HLSEncryptInfo hlsEncryptInfo;
+    private static int mMode = C.TS_STREAM_TYPE_H264;
+
+    public TsExtractor() {
+        this(0);
     }
-    boolean payloadUnitStartIndicator = tsScratch.readBit();
-    tsScratch.skipBits(1); // transport_priority
-    int pid = tsScratch.readBits(13);
-    tsScratch.skipBits(2); // transport_scrambling_control
-    boolean adaptationFieldExists = tsScratch.readBit();
-    boolean payloadExists = tsScratch.readBit();
-
-    // Discontinuity check.
-    boolean discontinuityFound = false;
-    int continuityCounter = tsScratch.readBits(4);
-    if (mode != MODE_HLS) {
-      int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
-      continuityCounters.put(pid, continuityCounter);
-      if (previousCounter == continuityCounter) {
-        if (payloadExists) {
-          // Duplicate packet found.
-          tsPacketBuffer.setPosition(endOfPacket);
-          return RESULT_CONTINUE;
-        }
-      } else if (continuityCounter != (previousCounter + 1) % 16) {
-        discontinuityFound = true;
-      }
+
+    /**
+     * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
+     *                                    {@code FLAG_*} values that control the behavior of the payload readers.
+     */
+    public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
+        this(MODE_SINGLE_PMT, defaultTsPayloadReaderFlags);
     }
 
-    // Skip the adaptation field.
-    if (adaptationFieldExists) {
-      int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
-      tsPacketBuffer.skipBytes(adaptationFieldLength);
+    /**
+     * @param mode                        Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+     *                                    and {@link #MODE_HLS}.
+     * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
+     *                                    {@code FLAG_*} values that control the behavior of the payload readers.
+     */
+    public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
+        this(mode, new TimestampAdjuster(0),
+                new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
     }
 
-    // Read the payload.
-    if (payloadExists) {
-      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
-      if (payloadReader != null) {
-        if (discontinuityFound) {
-          payloadReader.seek();
+
+    /**
+     * @param mode                 Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+     *                             and {@link #MODE_HLS}.
+     * @param timestampAdjuster    A timestamp adjuster for offsetting and scaling sample timestamps.
+     * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
+     */
+    public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+                       TsPayloadReader.Factory payloadReaderFactory) {
+        this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
+        this.mode = mode;
+        if (mode == MODE_SINGLE_PMT || mode == MODE_HLS) {
+            timestampAdjusters = Collections.singletonList(timestampAdjuster);
+        } else {
+            timestampAdjusters = new ArrayList<>();
+            timestampAdjusters.add(timestampAdjuster);
         }
-        tsPacketBuffer.setLimit(endOfPacket);
-        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
-        Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
-        tsPacketBuffer.setLimit(limit);
-      }
+        tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
+        tsScratch = new ParsableBitArray(new byte[3]);
+        trackIds = new SparseBooleanArray();
+        tsPayloadReaders = new SparseArray<>();
+        continuityCounters = new SparseIntArray();
+        resetPayloadReaders();
     }
 
-    tsPacketBuffer.setPosition(endOfPacket);
-    return RESULT_CONTINUE;
-  }
+    public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+                       TsPayloadReader.Factory payloadReaderFactory, HLSEncryptInfo hlsEncryptInfo) {
+        this(mode, timestampAdjuster, payloadReaderFactory);
+        this.hlsEncryptInfo = hlsEncryptInfo;
+    }
 
-  // Internals.
+    // Extractor implementation.
 
-  private void resetPayloadReaders() {
-    trackIds.clear();
-    tsPayloadReaders.clear();
-    SparseArray<TsPayloadReader> initialPayloadReaders =
-        payloadReaderFactory.createInitialPayloadReaders();
-    int initialPayloadReadersSize = initialPayloadReaders.size();
-    for (int i = 0; i < initialPayloadReadersSize; i++) {
-      tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
+    @Override
+    public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+        byte[] buffer = tsPacketBuffer.data;
+        input.peekFully(buffer, 0, BUFFER_SIZE);
+        for (int j = 0; j < TS_PACKET_SIZE; j++) {
+            for (int i = 0; true; i++) {
+                if (i == BUFFER_PACKET_COUNT) {
+                    input.skipFully(j);
+                    return true;
+                }
+                if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
+                    break;
+                }
+            }
+        }
+        return false;
     }
-    tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
-    id3Reader = null;
-  }
-
-  /**
-   * Parses Program Association Table data.
-   */
-  private class PatReader implements SectionPayloadReader {
 
-    private final ParsableBitArray patScratch;
+    @Override
+    public void init(ExtractorOutput output) {
+        this.output = output;
+        output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
+    }
 
-    public PatReader() {
-      patScratch = new ParsableBitArray(new byte[4]);
+    @Override
+    public void seek(long position, long timeUs) {
+        int timestampAdjustersCount = timestampAdjusters.size();
+        for (int i = 0; i < timestampAdjustersCount; i++) {
+            timestampAdjusters.get(i).reset();
+        }
+        tsPacketBuffer.reset();
+        continuityCounters.clear();
+        // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
+        resetPayloadReaders();
     }
 
     @Override
-    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-        TrackIdGenerator idGenerator) {
-      // Do nothing.
+    public void release() {
+        // Do nothing
     }
 
     @Override
-    public void consume(ParsableByteArray sectionData) {
-      int tableId = sectionData.readUnsignedByte();
-      if (tableId != 0x00 /* program_association_section */) {
-        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
-        return;
-      }
-      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
-      // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
-      // section_number (8), last_section_number (8)
-      sectionData.skipBytes(7);
-
-      int programCount = sectionData.bytesLeft() / 4;
-      for (int i = 0; i < programCount; i++) {
-        sectionData.readBytes(patScratch, 4);
-        int programNumber = patScratch.readBits(16);
-        patScratch.skipBits(3); // reserved (3)
-        if (programNumber == 0) {
-          patScratch.skipBits(13); // network_PID (13)
-        } else {
-          int pid = patScratch.readBits(13);
-          tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
-          remainingPmts++;
+    public int read(ExtractorInput input, PositionHolder seekPosition)
+            throws IOException, InterruptedException {
+        byte[] data = tsPacketBuffer.data;
+        // Shift bytes to the start of the buffer if there isn't enough space left at the end
+        if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
+            int bytesLeft = tsPacketBuffer.bytesLeft();
+            if (bytesLeft > 0) {
+                System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
+            }
+            tsPacketBuffer.reset(data, bytesLeft);
+        }
+        // Read more bytes until there is at least one packet size
+        while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
+            int limit = tsPacketBuffer.limit();
+            int read = input.read(data, limit, BUFFER_SIZE - limit);
+            if (read == C.RESULT_END_OF_INPUT) {
+                return RESULT_END_OF_INPUT;
+            }
+            tsPacketBuffer.setLimit(limit + read);
         }
-      }
-      if (mode != MODE_HLS) {
-        tsPayloadReaders.remove(TS_PAT_PID);
-      }
-    }
 
-  }
+        // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
+        // the header.
+        final int limit = tsPacketBuffer.limit();
+        int position = tsPacketBuffer.getPosition();
+        while (position < limit && data[position] != TS_SYNC_BYTE) {
+            position++;
+        }
+        tsPacketBuffer.setPosition(position);
 
-  /**
-   * Parses Program Map Table.
-   */
-  private class PmtReader implements SectionPayloadReader {
+        int endOfPacket = position + TS_PACKET_SIZE;
+        if (endOfPacket > limit) {
+            return RESULT_CONTINUE;
+        }
 
-    private static final int TS_PMT_DESC_REGISTRATION = 0x05;
-    private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
-    private static final int TS_PMT_DESC_AC3 = 0x6A;
-    private static final int TS_PMT_DESC_EAC3 = 0x7A;
-    private static final int TS_PMT_DESC_DTS = 0x7B;
-    private static final int TS_PMT_DESC_DVBSUBS = 0x59;
+        tsPacketBuffer.skipBytes(1);
+        tsPacketBuffer.readBytes(tsScratch, 3);
+        if (tsScratch.readBit()) { // transport_error_indicator
+            // There are uncorrectable errors in this packet.
+            tsPacketBuffer.setPosition(endOfPacket);
+            return RESULT_CONTINUE;
+        }
+        boolean payloadUnitStartIndicator = tsScratch.readBit();
+        tsScratch.skipBits(1); // transport_priority
+        int pid = tsScratch.readBits(13);
+        tsScratch.skipBits(2); // transport_scrambling_control
+        boolean adaptationFieldExists = tsScratch.readBit();
+        boolean payloadExists = tsScratch.readBit();
+
+        // Discontinuity check.
+        boolean discontinuityFound = false;
+        int continuityCounter = tsScratch.readBits(4);
+        if (mode != MODE_HLS) {
+            int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+            continuityCounters.put(pid, continuityCounter);
+            if (previousCounter == continuityCounter) {
+                if (payloadExists) {
+                    // Duplicate packet found.
+                    tsPacketBuffer.setPosition(endOfPacket);
+                    return RESULT_CONTINUE;
+                }
+            } else if (continuityCounter != (previousCounter + 1) % 16) {
+                discontinuityFound = true;
+            }
+        }
 
-      //2017-5-26,zhouwg, add it
-    private static final int TS_PMT_DESC_SAMPLE_AES_H264 = 15;
+        // Skip the adaptation field.
+        if (adaptationFieldExists) {
+            int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
+            tsPacketBuffer.skipBytes(adaptationFieldLength);
+        }
 
-    private final ParsableBitArray pmtScratch;
-    private final int pid;
+        // Read the payload.
+        if (payloadExists) {
+            TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
+            if (payloadReader != null) {
+                if (discontinuityFound) {
+                    payloadReader.seek();
+                }
+                tsPacketBuffer.setLimit(endOfPacket);
+                payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+                Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
+                tsPacketBuffer.setLimit(limit);
+            }
+        }
 
-    public PmtReader(int pid) {
-      pmtScratch = new ParsableBitArray(new byte[5]);
-      this.pid = pid;
+        tsPacketBuffer.setPosition(endOfPacket);
+        return RESULT_CONTINUE;
     }
 
-    @Override
-    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-        TrackIdGenerator idGenerator) {
-      // Do nothing.
-    }
+    // Internals.
 
-    @Override
-    public void consume(ParsableByteArray sectionData) {
-      int tableId = sectionData.readUnsignedByte();
-      if (tableId != 0x02 /* TS_program_map_section */) {
-        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
-        return;
-      }
-      // TimestampAdjuster assignment.
-      TimestampAdjuster timestampAdjuster;
-      if (mode == MODE_SINGLE_PMT || mode == MODE_HLS || remainingPmts == 1) {
-        timestampAdjuster = timestampAdjusters.get(0);
-      } else {
-        timestampAdjuster = new TimestampAdjuster(
-            timestampAdjusters.get(0).getFirstSampleTimestampUs());
-        timestampAdjusters.add(timestampAdjuster);
-      }
-
-      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12)
-      sectionData.skipBytes(2);
-      int programNumber = sectionData.readUnsignedShort();
-      // reserved (2), version_number (5), current_next_indicator (1), section_number (8),
-      // last_section_number (8), reserved (3), PCR_PID (13)
-      sectionData.skipBytes(5);
-
-      // Read program_info_length.
-      sectionData.readBytes(pmtScratch, 2);
-      pmtScratch.skipBits(4);
-      int programInfoLength = pmtScratch.readBits(12);
-
-      // Skip the descriptors.
-      sectionData.skipBytes(programInfoLength);
-
-      if (mode == MODE_HLS && id3Reader == null) {
-        // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
-        // appears intermittently during playback. See [Internal: b/20261500].
-        //EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
-        //id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
-       // id3Reader.init(timestampAdjuster, output,
-         //   new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
-      }
-
-      int remainingEntriesLength = sectionData.bytesLeft();
-      while (remainingEntriesLength > 0) {
-        sectionData.readBytes(pmtScratch, 5);
-        int streamType = pmtScratch.readBits(8);
-        pmtScratch.skipBits(3); // reserved
-        int elementaryPid = pmtScratch.readBits(13);
-        pmtScratch.skipBits(4); // reserved
-        int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
-        EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
-        if (streamType == 0x06) {//STREAMTYPE_EAC3_DVB
-          streamType = esInfo.streamType;
+    private void resetPayloadReaders() {
+        trackIds.clear();
+        tsPayloadReaders.clear();
+        SparseArray<TsPayloadReader> initialPayloadReaders =
+                payloadReaderFactory.createInitialPayloadReaders();
+        int initialPayloadReadersSize = initialPayloadReaders.size();
+        for (int i = 0; i < initialPayloadReadersSize; i++) {
+            tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
         }
+        tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
+        id3Reader = null;
+    }
 
-        if (streamType == C.TS_STREAM_TYPE_SAMPLE_AES_H264) {
-          Log.d(TAG, "SAMPLE_AES H264");
-            mMode = C.TS_STREAM_TYPE_SAMPLE_AES_H264;
+    /**
+     * Parses Program Association Table data.
+     */
+    private class PatReader implements SectionPayloadReader {
+
+        private final ParsableBitArray patScratch;
+
+        public PatReader() {
+            patScratch = new ParsableBitArray(new byte[4]);
         }
-        //2017-6-3,zhouwg
-        if (streamType == C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES) {
-          Log.d(TAG, "SAMPLE_AES AAC");
-          mMode = C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES;
+
+        @Override
+        public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+                         TrackIdGenerator idGenerator) {
+            // Do nothing.
         }
-        remainingEntriesLength -= esInfoLength + 5;
 
-        int trackId = mode == MODE_HLS ? streamType : elementaryPid;
-        if (trackIds.get(trackId)) {
-          continue;
+        @Override
+        public void consume(ParsableByteArray sectionData) {
+            int tableId = sectionData.readUnsignedByte();
+            if (tableId != 0x00 /* program_association_section */) {
+                // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
+                return;
+            }
+            // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
+            // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
+            // section_number (8), last_section_number (8)
+            sectionData.skipBytes(7);
+
+            int programCount = sectionData.bytesLeft() / 4;
+            for (int i = 0; i < programCount; i++) {
+                sectionData.readBytes(patScratch, 4);
+                int programNumber = patScratch.readBits(16);
+                patScratch.skipBits(3); // reserved (3)
+                if (programNumber == 0) {
+                    patScratch.skipBits(13); // network_PID (13)
+                } else {
+                    int pid = patScratch.readBits(13);
+                    tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
+                    remainingPmts++;
+                }
+            }
+            if (mode != MODE_HLS) {
+                tsPayloadReaders.remove(TS_PAT_PID);
+            }
         }
-        trackIds.put(trackId, true);
 
-        TsPayloadReader reader;
-        if (mode == MODE_HLS && streamType == TS_STREAM_TYPE_ID3) {
-          reader = id3Reader;
-        } else {
-          reader = payloadReaderFactory.createPayloadReader(streamType, esInfo, hlsEncryptInfo);
-          if (reader != null) {
-            reader.init(timestampAdjuster, output,
-                new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
-          }
+    }
+
+    /**
+     * Parses Program Map Table.
+     */
+    private class PmtReader implements SectionPayloadReader {
+
+        private static final int TS_PMT_DESC_REGISTRATION = 0x05;
+        private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
+        private static final int TS_PMT_DESC_AC3 = 0x6A;
+        private static final int TS_PMT_DESC_EAC3 = 0x7A;
+        private static final int TS_PMT_DESC_DTS = 0x7B;
+        private static final int TS_PMT_DESC_DVBSUBS = 0x59;
+
+        private final ParsableBitArray pmtScratch;
+        private final int pid;
+
+        public PmtReader(int pid) {
+            pmtScratch = new ParsableBitArray(new byte[5]);
+            this.pid = pid;
         }
 
-        if (reader != null) {
-          tsPayloadReaders.put(elementaryPid, reader);
+        @Override
+        public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+                         TrackIdGenerator idGenerator) {
+            // Do nothing.
         }
-      }
 
+        @Override
+        public void consume(ParsableByteArray sectionData) {
+            int tableId = sectionData.readUnsignedByte();
+            if (tableId != 0x02 /* TS_program_map_section */) {
+                // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
+                return;
+            }
+            // TimestampAdjuster assignment.
+            TimestampAdjuster timestampAdjuster;
+            if (mode == MODE_SINGLE_PMT || mode == MODE_HLS || remainingPmts == 1) {
+                timestampAdjuster = timestampAdjusters.get(0);
+            } else {
+                timestampAdjuster = new TimestampAdjuster(
+                        timestampAdjusters.get(0).getFirstSampleTimestampUs());
+                timestampAdjusters.add(timestampAdjuster);
+            }
 
+            // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12)
+            sectionData.skipBytes(2);
+            int programNumber = sectionData.readUnsignedShort();
+            // reserved (2), version_number (5), current_next_indicator (1), section_number (8),
+            // last_section_number (8), reserved (3), PCR_PID (13)
+            sectionData.skipBytes(5);
+
+            // Read program_info_length.
+            sectionData.readBytes(pmtScratch, 2);
+            pmtScratch.skipBits(4);
+            int programInfoLength = pmtScratch.readBits(12);
+
+            // Skip the descriptors.
+            sectionData.skipBytes(programInfoLength);
+
+            if (mode == MODE_HLS && id3Reader == null) {
+                // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
+                // appears intermittently during playback. See [Internal: b/20261500].
+                EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
+                id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo, null);
+                id3Reader.init(timestampAdjuster, output,
+                        new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
+            }
 
-      if (mode == MODE_HLS) {
-        if (!tracksEnded) {
-          output.endTracks();
-          remainingPmts = 0;
-          tracksEnded = true;
-        }
-      } else {
-        tsPayloadReaders.remove(pid);
-        remainingPmts = mode == MODE_SINGLE_PMT ? 0 : remainingPmts - 1;
-        if (remainingPmts == 0) {
-          output.endTracks();
-          tracksEnded = true;
+            int remainingEntriesLength = sectionData.bytesLeft();
+            while (remainingEntriesLength > 0) {
+                sectionData.readBytes(pmtScratch, 5);
+                int streamType = pmtScratch.readBits(8);
+                pmtScratch.skipBits(3); // reserved
+                int elementaryPid = pmtScratch.readBits(13);
+                pmtScratch.skipBits(4); // reserved
+                int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
+                EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
+                if (streamType == 0x06) {
+                    streamType = esInfo.streamType;
+                }
+                remainingEntriesLength -= esInfoLength + 5;
+
+                int trackId = mode == MODE_HLS ? streamType : elementaryPid;
+                if (trackIds.get(trackId)) {
+                    continue;
+                }
+                trackIds.put(trackId, true);
+
+                TsPayloadReader reader;
+                if (mode == MODE_HLS && streamType == TS_STREAM_TYPE_ID3) {
+                    reader = id3Reader;
+                } else {
+                    reader = payloadReaderFactory.createPayloadReader(streamType, esInfo, hlsEncryptInfo);
+                    if (reader != null) {
+                        reader.init(timestampAdjuster, output,
+                                new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
+                    }
+                }
+
+                if (reader != null) {
+                    tsPayloadReaders.put(elementaryPid, reader);
+                }
+            }
+            if (mode == MODE_HLS) {
+                if (!tracksEnded) {
+                    output.endTracks();
+                    remainingPmts = 0;
+                    tracksEnded = true;
+                }
+            } else {
+                tsPayloadReaders.remove(pid);
+                remainingPmts = mode == MODE_SINGLE_PMT ? 0 : remainingPmts - 1;
+                if (remainingPmts == 0) {
+                    output.endTracks();
+                    tracksEnded = true;
+                }
+            }
         }
-      }
-    }
 
-    /**
-     * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
-     * the end of the descriptors.
-     *
-     * @param data A buffer with its position set to the start of the first descriptor.
-     * @param length The length of descriptors to read from the current position in {@code data}.
-     * @return The stream info read from the available descriptors.
-     */
-    private EsInfo readEsInfo(ParsableByteArray data, int length) {
-      int descriptorsStartPosition = data.getPosition();
-      int descriptorsEndPosition = descriptorsStartPosition + length;
-      int streamType = -1;
-      String language = null;
-      List<DvbSubtitleInfo> dvbSubtitleInfos = null;
-      while (data.getPosition() < descriptorsEndPosition) {
-        int descriptorTag = data.readUnsignedByte();
-        int descriptorLength = data.readUnsignedByte();
-        int positionOfNextDescriptor = data.getPosition() + descriptorLength;
-        if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
-            long formatIdentifier = data.readUnsignedInt();
-            if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
-                streamType = TS_STREAM_TYPE_AC3;
-            } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
-                streamType = TS_STREAM_TYPE_E_AC3;
-            } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
-              streamType = TS_STREAM_TYPE_H265;
+        /**
+         * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
+         * the end of the descriptors.
+         *
+         * @param data   A buffer with its position set to the start of the first descriptor.
+         * @param length The length of descriptors to read from the current position in {@code data}.
+         * @return The stream info read from the available descriptors.
+         */
+        private EsInfo readEsInfo(ParsableByteArray data, int length) {
+            int descriptorsStartPosition = data.getPosition();
+            int descriptorsEndPosition = descriptorsStartPosition + length;
+            int streamType = -1;
+            String language = null;
+            List<DvbSubtitleInfo> dvbSubtitleInfos = null;
+            while (data.getPosition() < descriptorsEndPosition) {
+                int descriptorTag = data.readUnsignedByte();
+                int descriptorLength = data.readUnsignedByte();
+                int positionOfNextDescriptor = data.getPosition() + descriptorLength;
+                if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
+                    long formatIdentifier = data.readUnsignedInt();
+                    if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
+                        streamType = TS_STREAM_TYPE_AC3;
+                    } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
+                        streamType = TS_STREAM_TYPE_E_AC3;
+                    } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
+                        streamType = TS_STREAM_TYPE_H265;
+                    }
+                } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
+                    streamType = TS_STREAM_TYPE_AC3;
+                } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
+                    streamType = TS_STREAM_TYPE_E_AC3;
+                } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
+                    streamType = TS_STREAM_TYPE_DTS;
+                } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
+                    language = data.readString(3).trim();
+                    // Audio type is ignored.
+                } else if (descriptorTag == TS_PMT_DESC_DVBSUBS) {
+                    streamType = TS_STREAM_TYPE_DVBSUBS;
+                    dvbSubtitleInfos = new ArrayList<>();
+                    while (data.getPosition() < positionOfNextDescriptor) {
+                        String dvbLanguage = data.readString(3).trim();
+                        int dvbSubtitlingType = data.readUnsignedByte();
+                        byte[] initializationData = new byte[4];
+                        data.readBytes(initializationData, 0, 4);
+                        dvbSubtitleInfos.add(new DvbSubtitleInfo(dvbLanguage, dvbSubtitlingType,
+                                initializationData));
+                    }
+                }
+                // Skip unused bytes of current descriptor.
+                data.skipBytes(positionOfNextDescriptor - data.getPosition());
             }
-        //} else if (descriptorTag == TS_PMT_DESC_SAMPLE_AES_H264)  { //TODO:hardcode here
-        //    streamType = C.TS_STREAM_TYPE_SAMPLE_AES_H264;
-        } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
-          streamType = TS_STREAM_TYPE_AC3;
-        } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
-          streamType = TS_STREAM_TYPE_E_AC3;
-        } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
-          streamType = TS_STREAM_TYPE_DTS;
-        } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
-          language = data.readString(3).trim();
-          // Audio type is ignored.
-        } else if (descriptorTag == TS_PMT_DESC_DVBSUBS) {
-          streamType = TS_STREAM_TYPE_DVBSUBS;
-          dvbSubtitleInfos = new ArrayList<>();
-          while (data.getPosition() < positionOfNextDescriptor) {
-            String dvbLanguage = data.readString(3).trim();
-            int dvbSubtitlingType = data.readUnsignedByte();
-            byte[] initializationData = new byte[4];
-            data.readBytes(initializationData, 0, 4);
-            dvbSubtitleInfos.add(new DvbSubtitleInfo(dvbLanguage, dvbSubtitlingType,
-                initializationData));
-          }
+            data.setPosition(descriptorsEndPosition);
+            return new EsInfo(streamType, language, dvbSubtitleInfos,
+                    Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
         }
-        // Skip unused bytes of current descriptor.
-        data.skipBytes(positionOfNextDescriptor - data.getPosition());
-      }
-      data.setPosition(descriptorsEndPosition);
-      return new EsInfo(streamType, language, dvbSubtitleInfos,
-          Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
-    }
 
-  }
+    }
 
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
index b69265e2fb..7d95428050 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
@@ -1,11 +1,7 @@
 package com.google.android.exoplayer2.util;
 
-/**
- * Created by zhou.weiguo on 07-06-2017.
- */
 
 public final class HLSEncryptInfo {
-    private static final String TAG = "HLSEncryptInfo";
 
     public String encryptionMethod;
     public String encryptionKeyUri;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 9b3f10efea..f29a2d993d 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -32,7 +32,6 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -93,14 +92,13 @@ public void clear() {
   private boolean isTimestampMaster;
   private byte[] scratchSpace;
   private IOException fatalError;
+  private HlsUrl expectedPlaylistUrl;
 
   private Uri encryptionKeyUri;
   private byte[] encryptionKey;
   private String encryptionIvString;
   private byte[] encryptionIv;
 
-
-
   // Note: The track group in the selection is typically *not* equal to trackGroup. This is due to
   // the way in which HlsSampleStreamWrapper generates track groups. Use only index based methods
   // in TrackSelection to avoid unexpected behavior.
@@ -114,7 +112,8 @@ public void clear() {
    * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
+   *     information is available in the master playlist.
    */
   public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
       HlsDataSourceFactory dataSourceFactory, TimestampAdjusterProvider timestampAdjusterProvider,
@@ -145,6 +144,9 @@ public void maybeThrowError() throws IOException {
     if (fatalError != null) {
       throw fatalError;
     }
+    if (expectedPlaylistUrl != null) {
+      playlistTracker.maybeThrowPlaylistRefreshError(expectedPlaylistUrl);
+    }
   }
 
   /**
@@ -197,6 +199,7 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
   public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
     int oldVariantIndex = previous == null ? C.INDEX_UNSET
         : trackGroup.indexOf(previous.trackFormat);
+    expectedPlaylistUrl = null;
     // Use start time of the previous chunk rather than its end time because switching format will
     // require downloading overlapping segments.
     long bufferedDurationUs = previous == null ? 0
@@ -210,6 +213,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     HlsUrl selectedUrl = variants[selectedVariantIndex];
     if (!playlistTracker.isSnapshotValid(selectedUrl)) {
       out.playlist = selectedUrl;
+      expectedPlaylistUrl = selectedUrl;
       // Retry when playlist is refreshed.
       return;
     }
@@ -249,6 +253,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         out.endOfStream = true;
       } else /* Live */ {
         out.playlist = selectedUrl;
+        expectedPlaylistUrl = selectedUrl;
       }
       return;
     }
@@ -256,26 +261,28 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     // Handle encryption.
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
 
+
+
+
+
+
     // Check if encryption is specified.
     if (segment.isEncrypted) {
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
-
       if (
-              ((segment.hlsEncryptInfo.encryptionKeyFormat == null) && segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES))
-           || segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_AES_128)
-              ) {
-
-        if (!keyUri.equals(encryptionKeyUri)) {
-          // Encryption is specified and the key has changed.
-          out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
-                  trackSelection.getSelectionReason(), trackSelection.getSelectionData());
-          encryptionKeyUri = keyUri;
-          return;
-        }
+            ((segment.hlsEncryptInfo.encryptionKeyFormat == null) && segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES))
+                    || segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_AES_128)
+            ){
+            if(!keyUri.equals(encryptionKeyUri)){
+            // Encryption is specified and the key has changed.
+            out.chunk=newEncryptionKeyChunk(keyUri,segment.encryptionIV,selectedVariantIndex,
+            trackSelection.getSelectionReason(),trackSelection.getSelectionData());
+            encryptionKeyUri=keyUri;
+            return;
+            }
       }
-
       if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
-        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey, (segment.hlsEncryptInfo != null) ? segment.hlsEncryptInfo.encryptionMethod : null);
+        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey);
       }
     } else {
       clearEncryptionData();
@@ -359,6 +366,7 @@ private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int vari
     return new EncryptionKeyChunk(encryptionDataSource, dataSpec, variants[variantIndex].format,
         trackSelectionReason, trackSelectionData, scratchSpace, iv);
   }
+
   private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     String trimmedIv;
     if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
@@ -371,7 +379,7 @@ private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     byte[] ivDataWithPadding = new byte[16];
     int offset = ivData.length > 16 ? ivData.length - 16 : 0;
     System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
-            + offset, ivData.length - offset);
+        + offset, ivData.length - offset);
 
     encryptionKeyUri = keyUri;
     encryptionKey = secretKey;
@@ -379,12 +387,6 @@ private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     encryptionIv = ivDataWithPadding;
   }
 
-
-  private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey, String method) {
-    setEncryptionData(keyUri, iv, secretKey);
-
-  }
-
   private void clearEncryptionData() {
     encryptionKeyUri = null;
     encryptionKey = null;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index bb01a0327e..85b0826285 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -40,6 +40,7 @@
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -80,13 +81,6 @@
   private final DataSource initDataSource;
   private final DataSpec initDataSpec;
   private final boolean isEncrypted;
-
-
-  private final byte[] encryptionKey;
-  private final byte[] encryptionIv;
-
-  private final HLSEncryptInfo hlsEncryptInfo;
-
   private final boolean isMasterTimestampSource;
   private final TimestampAdjuster timestampAdjuster;
   private final String lastPathSegment;
@@ -107,12 +101,19 @@
   private volatile boolean loadCanceled;
   private volatile boolean loadCompleted;
 
+  private final byte[] encryptionKey;
+  private final byte[] encryptionIv;
+  private final HLSEncryptInfo hlsEncryptInfo;
+
+
+
   /**
    * @param dataSource The source from which the data should be loaded.
    * @param dataSpec Defines the data to be loaded.
    * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
    * @param hlsUrl The url of the playlist from which this chunk was obtained.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
+   *     information is available in the master playlist.
    * @param trackSelectionReason See {@link #trackSelectionReason}.
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param startTimeUs The start time of the chunk in microseconds.
@@ -140,14 +141,14 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
     // Note: this.dataSource and dataSource may be different.
-    this.isEncrypted = this.dataSource instanceof Aes128DataSource; //TODO: this.isEncrypted = hlsEncryptInfo.isEncrypted;
+    this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+
     this.encryptionKey = encryptionKey;
     this.encryptionIv = encryptionIv;
     hlsEncryptInfo.encryptionKey = encryptionKey;
     hlsEncryptInfo.encryptionIv = encryptionIv;
     this.hlsEncryptInfo = hlsEncryptInfo;
 
-
     lastPathSegment = dataSpec.uri.getLastPathSegment();
     isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
         || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
@@ -345,17 +346,9 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
    */
   private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
       byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
-   /*
-    if (encryptionKey == null || encryptionIv == null) {
-      return dataSource;
-    }
-    return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
-   */
-    if (encryptionKey == null || encryptionIv == null) {
-    } else {
-      if (hlsEncryptInfo.encryptionMethod != null && hlsEncryptInfo.encryptionMethod.equals("AES-128"))
-        return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
-    }
+
+    if (hlsEncryptInfo.encryptionMethod != null && hlsEncryptInfo.encryptionMethod.equals("AES-128"))
+      return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
 
     return dataSource;
   }
@@ -380,9 +373,12 @@ private Extractor createExtractor() {
       // This flag ensures the change of pid between streams does not affect the sample queues.
       @DefaultTsPayloadReaderFactory.Flags
       int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
-      if (!muxedCaptionFormats.isEmpty()) {
+      List<Format> closedCaptionFormats = muxedCaptionFormats;
+      if (closedCaptionFormats != null) {
         // The playlist declares closed caption renditions, we should ignore descriptors.
         esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
+      } else {
+        closedCaptionFormats = Collections.emptyList();
       }
       String codecs = trackFormat.codecs;
       if (!TextUtils.isEmpty(codecs)) {
@@ -396,10 +392,8 @@ private Extractor createExtractor() {
           esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
         }
       }
-
-
       extractor = new TsExtractor(TsExtractor.MODE_HLS, timestampAdjuster,
-          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats), hlsEncryptInfo);
+          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, closedCaptionFormats), hlsEncryptInfo);
     }
     if (usingNewExtractor) {
       extractor.init(extractorOutput);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 9371657bdc..18cca96401 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -42,32 +42,29 @@
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
     public final String encryptionIV;
-
     public final long byterangeOffset;
     public final long byterangeLength;
 
-
     public final HLSEncryptInfo hlsEncryptInfo;
 
 
-
-
-
     public Segment(String uri, long byterangeOffset, long byterangeLength) {
       this(uri, 0, -1, C.TIME_UNSET, null, byterangeOffset, byterangeLength);
     }
 
     public Segment(String uri, long durationUs, int relativeDiscontinuitySequence,
-                   long relativeStartTimeUs, HLSEncryptInfo hlsEncryptInfo, long byterangeOffset, long byterangeLength) {
+        long relativeStartTimeUs, HLSEncryptInfo hlsEncryptInfo,
+        long byterangeOffset, long byterangeLength) {
+
       this.url = uri;
       this.durationUs = durationUs;
       this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
       this.relativeStartTimeUs = relativeStartTimeUs;
+
       this.hlsEncryptInfo = hlsEncryptInfo;
       this.isEncrypted = (hlsEncryptInfo != null) ? hlsEncryptInfo.isEncrypted : false;
       this.encryptionKeyUri = (hlsEncryptInfo != null) ? hlsEncryptInfo.encryptionKeyUri : null;
       this.encryptionIV = (hlsEncryptInfo != null) ? hlsEncryptInfo.encryptionIvString : null;
-
       this.byterangeOffset = byterangeOffset;
       this.byterangeLength = byterangeLength;
     }
@@ -102,12 +99,14 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
   public final boolean hasProgramDateTime;
   public final Segment initializationSegment;
   public final List<Segment> segments;
+  public final List<String> dateRanges;
   public final long durationUs;
 
   public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long startOffsetUs,
       long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
       int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
-      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments) {
+      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments,
+      List<String> dateRanges) {
     super(baseUri);
     this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
@@ -128,6 +127,7 @@ public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long sta
     }
     this.startOffsetUs = startOffsetUs == C.TIME_UNSET ? C.TIME_UNSET
         : startOffsetUs >= 0 ? startOffsetUs : durationUs + startOffsetUs;
+    this.dateRanges = Collections.unmodifiableList(dateRanges);
   }
 
   /**
@@ -166,7 +166,7 @@ public long getEndTimeUs() {
   public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
     return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs, true,
         discontinuitySequence, mediaSequence, version, targetDurationUs, hasEndTag,
-        hasProgramDateTime, initializationSegment, segments);
+        hasProgramDateTime, initializationSegment, segments, dateRanges);
   }
 
   /**
@@ -181,7 +181,7 @@ public HlsMediaPlaylist copyWithEndTag() {
     }
     return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs,
         hasDiscontinuitySequence, discontinuitySequence, mediaSequence, version, targetDurationUs,
-        true, hasProgramDateTime, initializationSegment, segments);
+        true, hasProgramDateTime, initializationSegment, segments, dateRanges);
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 63d573606b..2a4c9265c3 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -30,20 +30,18 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import android.util.Log;
-
 
 /**
  * HLS playlists parsing logic.
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
-  private static final String TAG = "HlsPlaylistParser";
   private static final String PLAYLIST_HEADER = "#EXTM3U";
 
   private static final String TAG_VERSION = "#EXT-X-VERSION";
@@ -61,6 +59,7 @@
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
+  private static final String TAG_DATERANGE = "#EXT-X-DATERANGE";
 
   private static final String TYPE_AUDIO = "AUDIO";
   private static final String TYPE_VIDEO = "VIDEO";
@@ -74,6 +73,8 @@
   private static final String BOOLEAN_TRUE = "YES";
   private static final String BOOLEAN_FALSE = "NO";
 
+  private static final String ATTR_CLOSED_CAPTIONS_NONE = "CLOSED-CAPTIONS=NONE";
+
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("BANDWIDTH=(\\d+)\\b");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
@@ -90,16 +91,11 @@
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
   private static final Pattern REGEX_ATTR_BYTERANGE =
-          Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
-
+      Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
   private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
       + METHOD_AES128 + "|" + METHOD_SAMPLEAES + ")");
   private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
   private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
-
-  private static final Pattern REGEX_KEYID = Pattern.compile("KeyId=(.+?-.+?-.+?-.+?-.{12})");
-  private static final Pattern REGEX_KEYFORMAT = Pattern.compile("KEYFORMAT=\"(.+?)\"");
-
   private static final Pattern REGEX_TYPE = Pattern.compile("TYPE=(" + TYPE_AUDIO + "|" + TYPE_VIDEO
       + "|" + TYPE_SUBTITLES + "|" + TYPE_CLOSED_CAPTIONS + ")");
   private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
@@ -182,7 +178,8 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
     Format muxedAudioFormat = null;
-    ArrayList<Format> muxedCaptionFormats = new ArrayList<>();
+    List<Format> muxedCaptionFormats = null;
+    boolean noClosedCaptions = false;
 
     String line;
     while (iterator.hasNext()) {
@@ -219,6 +216,9 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
               mimeType = MimeTypes.APPLICATION_CEA708;
               accessibilityChannel = Integer.parseInt(instreamId.substring(7));
             }
+            if (muxedCaptionFormats == null) {
+              muxedCaptionFormats = new ArrayList<>();
+            }
             muxedCaptionFormats.add(Format.createTextContainerFormat(id, null, mimeType, null,
                 Format.NO_VALUE, selectionFlags, language, accessibilityChannel));
             break;
@@ -230,6 +230,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
         String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
         String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
+        noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int width;
         int height;
         if (resolutionString != null) {
@@ -252,6 +253,9 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
       }
     }
+    if (noClosedCaptions) {
+      muxedCaptionFormats = Collections.emptyList();
+    }
     return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioFormat,
         muxedCaptionFormats);
   }
@@ -273,6 +277,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     boolean hasEndTag = false;
     Segment initializationSegment = null;
     List<Segment> segments = new ArrayList<>();
+    List<String> dateRanges = new ArrayList<>();
 
     long segmentDurationUs = 0;
     boolean hasDiscontinuitySequence = false;
@@ -287,12 +292,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     boolean isEncrypted = false;
     String encryptionKeyUri = null;
     String encryptionIV = null;
-
-    String encryptionKeyId = null;
-    String encryptionKeyFormat = null;
     String encryptionMethod = null;
 
-
     HLSEncryptInfo hlsEncryptInfo;
 
     String line;
@@ -334,16 +335,15 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
             (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_KEY)) {
         String method = parseStringAttr(line, REGEX_METHOD);
-		//Log.e("HlsPlaylistParser" + method);
         isEncrypted = METHOD_AES128.equals(method) | METHOD_SAMPLEAES.equals(method);
         if (isEncrypted) {
           encryptionKeyUri = parseStringAttr(line, REGEX_URI);
           encryptionIV = parseOptionalStringAttr(line, REGEX_IV);
-          encryptionMethod = method;
         } else {
           encryptionKeyUri = null;
           encryptionIV = null;
         }
+        encryptionMethod = method;
       } else if (line.startsWith(TAG_BYTERANGE)) {
         String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
         String[] splitByteRange = byteRange.split("@");
@@ -362,6 +362,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
               C.msToUs(Util.parseXsDateTime(line.substring(line.indexOf(':') + 1)));
           playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
         }
+      } else if (line.startsWith(TAG_DATERANGE)) {
+        dateRanges.add(line);
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
         if (!isEncrypted) {
@@ -371,17 +373,13 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         } else {
           segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
         }
-
         segmentMediaSequence++;
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
-
-        hlsEncryptInfo = new HLSEncryptInfo(isEncrypted, encryptionMethod, encryptionKeyUri, segmentEncryptionIV, encryptionKeyFormat, encryptionKeyId);
-
+        hlsEncryptInfo = new HLSEncryptInfo(isEncrypted, encryptionMethod, encryptionKeyUri, segmentEncryptionIV, null, null);
         segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
-                segmentStartTimeUs, hlsEncryptInfo, segmentByteRangeOffset, segmentByteRangeLength));
-
+            segmentStartTimeUs, hlsEncryptInfo, segmentByteRangeOffset, segmentByteRangeLength));
         segmentStartTimeUs += segmentDurationUs;
         segmentDurationUs = 0;
         if (segmentByteRangeLength != C.LENGTH_UNSET) {
@@ -394,7 +392,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     }
     return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, playlistStartTimeUs,
         hasDiscontinuitySequence, playlistDiscontinuitySequence, mediaSequence, version,
-        targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
+        targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments,
+        dateRanges);
   }
 
   private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
