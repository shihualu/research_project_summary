diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
new file mode 100644
index 0000000000..056b47a1e8
--- /dev/null
+++ b/.idea/codeStyleSettings.xml
@@ -0,0 +1,495 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectCodeStyleSettingsManager">
+    <option name="PER_PROJECT_SETTINGS">
+      <value>
+        <option name="OTHER_INDENT_OPTIONS">
+          <value>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+            <option name="USE_TAB_CHARACTER" value="false" />
+            <option name="SMART_TABS" value="false" />
+            <option name="LABEL_INDENT_SIZE" value="0" />
+            <option name="LABEL_INDENT_ABSOLUTE" value="false" />
+            <option name="USE_RELATIVE_INDENTS" value="false" />
+          </value>
+        </option>
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
+        <option name="IMPORT_LAYOUT_TABLE">
+          <value>
+            <package name="" withSubpackages="true" static="true" />
+            <emptyLine />
+            <package name="" withSubpackages="true" static="false" />
+          </value>
+        </option>
+        <option name="RIGHT_MARGIN" value="100" />
+        <option name="JD_ALIGN_PARAM_COMMENTS" value="false" />
+        <option name="JD_ALIGN_EXCEPTION_COMMENTS" value="false" />
+        <option name="JD_P_AT_EMPTY_LINES" value="false" />
+        <option name="JD_KEEP_EMPTY_PARAMETER" value="false" />
+        <option name="JD_KEEP_EMPTY_EXCEPTION" value="false" />
+        <option name="JD_KEEP_EMPTY_RETURN" value="false" />
+        <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+        <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+        <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="0" />
+        <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+        <option name="ALIGN_MULTILINE_FOR" value="false" />
+        <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
+        <option name="CALL_PARAMETERS_WRAP" value="1" />
+        <option name="METHOD_PARAMETERS_WRAP" value="1" />
+        <option name="EXTENDS_LIST_WRAP" value="1" />
+        <option name="THROWS_KEYWORD_WRAP" value="1" />
+        <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+        <option name="BINARY_OPERATION_WRAP" value="1" />
+        <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+        <option name="TERNARY_OPERATION_WRAP" value="1" />
+        <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+        <option name="FOR_STATEMENT_WRAP" value="1" />
+        <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+        <option name="WRAP_COMMENTS" value="true" />
+        <option name="IF_BRACE_FORCE" value="3" />
+        <option name="DOWHILE_BRACE_FORCE" value="3" />
+        <option name="WHILE_BRACE_FORCE" value="3" />
+        <option name="FOR_BRACE_FORCE" value="3" />
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+          <option name="LAYOUT_SETTINGS">
+            <value>
+              <option name="INSERT_BLANK_LINE_BEFORE_TAG" value="false" />
+            </value>
+          </option>
+        </AndroidXmlCodeStyleSettings>
+        <Objective-C>
+          <option name="INDENT_NAMESPACE_MEMBERS" value="0" />
+          <option name="INDENT_C_STRUCT_MEMBERS" value="2" />
+          <option name="INDENT_CLASS_MEMBERS" value="2" />
+          <option name="INDENT_VISIBILITY_KEYWORDS" value="1" />
+          <option name="INDENT_INSIDE_CODE_BLOCK" value="2" />
+          <option name="KEEP_STRUCTURES_IN_ONE_LINE" value="true" />
+          <option name="FUNCTION_PARAMETERS_WRAP" value="5" />
+          <option name="FUNCTION_CALL_ARGUMENTS_WRAP" value="5" />
+          <option name="TEMPLATE_CALL_ARGUMENTS_WRAP" value="5" />
+          <option name="TEMPLATE_CALL_ARGUMENTS_ALIGN_MULTILINE" value="true" />
+          <option name="ALIGN_INIT_LIST_IN_COLUMNS" value="false" />
+          <option name="SPACE_BEFORE_SUPERCLASS_COLON" value="false" />
+        </Objective-C>
+        <Objective-C-extensions>
+          <file>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
+          </file>
+          <class>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
+          </class>
+          <extensions>
+            <pair source="cc" header="h" />
+            <pair source="c" header="h" />
+          </extensions>
+        </Objective-C-extensions>
+        <XML>
+          <option name="XML_ALIGN_ATTRIBUTES" value="false" />
+          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
+        </XML>
+        <codeStyleSettings language="HTML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JAVA">
+          <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_RESOURCES" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="THROWS_KEYWORD_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JSON">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ObjectiveC">
+          <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="1" />
+          <option name="BLANK_LINES_BEFORE_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AFTER_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AROUND_CLASS" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD_IN_INTERFACE" value="0" />
+          <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="false" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ASSIGNMENT_WRAP" value="1" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+          <arrangement>
+            <rules>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:android</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:id</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:.*Style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_width</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_height</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_weight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_margin</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:padding</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>.*</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+            </rules>
+          </arrangement>
+        </codeStyleSettings>
+      </value>
+    </option>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </component>
+</project>
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 43c4809480..94b349b217 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -16,9 +16,8 @@ all of the information requested in the issue template.
 ## Pull requests ##
 
 We will also consider high quality pull requests. These should normally merge
-into the `dev-vX` branch with the highest major version number. Bug fixes may
-be suitable for merging into older `dev-vX` branches. Before a pull request can
-be accepted you must submit a Contributor License Agreement, as described below.
+into the `dev-v2` branch. Before a pull request can be accepted you must submit
+a Contributor License Agreement, as described below.
 
 [dev]: https://github.com/google/ExoPlayer/tree/dev
 
diff --git a/README.md b/README.md
index 13dfaddab3..37967dd527 100644
--- a/README.md
+++ b/README.md
@@ -28,13 +28,13 @@ repository and depend on the modules locally.
 ### From JCenter ###
 
 The easiest way to get started using ExoPlayer is to add it as a gradle
-dependency. You need to make sure you have the JCenter and Google repositories
+dependency. You need to make sure you have the Google and JCenter repositories
 included in the `build.gradle` file in the root of your project:
 
 ```gradle
 repositories {
-    jcenter()
     google()
+    jcenter()
 }
 ```
 
@@ -45,10 +45,20 @@ following will add a dependency to the full library:
 implementation 'com.google.android.exoplayer:exoplayer:2.X.X'
 ```
 
-where `2.X.X` is your preferred version. Alternatively, you can depend on only
-the library modules that you actually need. For example the following will add
-dependencies on the Core, DASH and UI library modules, as might be required for
-an app that plays DASH content:
+where `2.X.X` is your preferred version. If not enabled already, you also need
+to turn on Java 8 support in all `build.gradle` files depending on ExoPlayer, by
+adding the following to the `android` section:
+
+```gradle
+compileOptions {
+    targetCompatibility JavaVersion.VERSION_1_8
+}
+```
+
+As an alternative to the full library, you can depend on only the library
+modules that you actually need. For example the following will add dependencies
+on the Core, DASH and UI library modules, as might be required for an app that
+plays DASH content:
 
 ```gradle
 implementation 'com.google.android.exoplayer:exoplayer-core:2.X.X'
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 2c3e1c78b0..1699f2c09b 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,9 +1,319 @@
 # Release notes #
 
+### 2.9.3 ###
+
+* Captions: Support PNG subtitles in SMPTE-TT
+  ([#1583](https://github.com/google/ExoPlayer/issues/1583)).
+* MPEG-TS: Use random access indicators to minimize the need for
+  `FLAG_ALLOW_NON_IDR_KEYFRAMES`.
+* Downloading: Reduce time taken to remove downloads
+  ([#5136](https://github.com/google/ExoPlayer/issues/5136)).
+* MP3:
+  * Use the true bitrate for constant-bitrate MP3 seeking.
+  * Fix issue where streams would play twice on some Samsung devices
+    ([#4519](https://github.com/google/ExoPlayer/issues/4519)).
+* Fix regression where some audio formats were incorrectly marked as being
+  unplayable due to under-reporting of platform decoder capabilities
+  ([#5145](https://github.com/google/ExoPlayer/issues/5145)).
+* Fix decode-only frame skipping on Nvidia Shield TV devices.
+* Workaround for MiTV (dangal) issue when swapping output surface
+  ([#5169](https://github.com/google/ExoPlayer/issues/5169)).
+
+### 2.9.2 ###
+
+* HLS:
+  * Fix issue causing unnecessary media playlist requests when playing live
+    streams ([#5059](https://github.com/google/ExoPlayer/issues/5059)).
+  * Fix decoder re-instantiation issue for packed audio streams
+    ([#5063](https://github.com/google/ExoPlayer/issues/5063)).
+* MP4: Support Opus and FLAC in the MP4 container, and in DASH
+  ([#4883](https://github.com/google/ExoPlayer/issues/4883)).
+* DASH: Fix detecting the end of live events
+  ([#4780](https://github.com/google/ExoPlayer/issues/4780)).
+* Spherical video: Fall back to `TYPE_ROTATION_VECTOR` if
+  `TYPE_GAME_ROTATION_VECTOR` is unavailable
+  ([#5119](https://github.com/google/ExoPlayer/issues/5119)).
+* Support seeking for a wider range of MPEG-TS streams
+  ([#5097](https://github.com/google/ExoPlayer/issues/5097)).
+* Include channel count in audio capabilities check
+  ([#4690](https://github.com/google/ExoPlayer/issues/4690)).
+* Fix issue with applying the `show_buffering` attribute in `PlayerView`
+  ([#5139](https://github.com/google/ExoPlayer/issues/5139)).
+* Fix issue where null `Metadata` was output when it failed to decode
+  ([#5149](https://github.com/google/ExoPlayer/issues/5149)).
+* Fix playback of some invalid but playable MP4 streams by replacing assertions
+  with logged warnings in sample table parsing code
+  ([#5162](https://github.com/google/ExoPlayer/issues/5162)).
+* Fix UUID passed to `MediaCrypto` when using `C.CLEARKEY_UUID` before API 27.
+
+### 2.9.1 ###
+
+* Add convenience methods `Player.next`, `Player.previous`, `Player.hasNext`
+  and `Player.hasPrevious`
+  ([#4863](https://github.com/google/ExoPlayer/issues/4863)).
+* Improve initial bandwidth meter estimates using the current country and
+  network type.
+* IMA extension:
+  * For preroll to live stream transitions, project forward the loading position
+    to avoid being behind the live window.
+  * Let apps specify whether to focus the skip button on ATV
+    ([#5019](https://github.com/google/ExoPlayer/issues/5019)).
+* MP3:
+  * Support seeking based on MLLT metadata
+    ([#3241](https://github.com/google/ExoPlayer/issues/3241)).
+  * Fix handling of streams with appended data
+    ([#4954](https://github.com/google/ExoPlayer/issues/4954)).
+* DASH: Parse ProgramInformation element if present in the manifest.
+* HLS:
+  * Add constructor to `DefaultHlsExtractorFactory` for adding TS payload
+    reader factory flags
+    ([#4861](https://github.com/google/ExoPlayer/issues/4861)).
+  * Fix bug in segment sniffing
+    ([#5039](https://github.com/google/ExoPlayer/issues/5039)).
+* SubRip: Add support for alignment tags, and remove tags from the displayed
+  captions ([#4306](https://github.com/google/ExoPlayer/issues/4306)).
+* Fix issue with blind seeking to windows with non-zero offset in a
+  `ConcatenatingMediaSource`
+  ([#4873](https://github.com/google/ExoPlayer/issues/4873)).
+* Fix logic for enabling next and previous actions in `TimelineQueueNavigator`
+  ([#5065](https://github.com/google/ExoPlayer/issues/5065)).
+* Fix issue where audio focus handling could not be disabled after enabling it
+  ([#5055](https://github.com/google/ExoPlayer/issues/5055)).
+* Fix issue where subtitles were positioned incorrectly if `SubtitleView` had a
+  non-zero position offset to its parent
+  ([#4788](https://github.com/google/ExoPlayer/issues/4788)).
+* Fix issue where the buffered position was not updated correctly when
+  transitioning between periods
+  ([#4899](https://github.com/google/ExoPlayer/issues/4899)).
+* Fix issue where a `NullPointerException` is thrown when removing an unprepared
+  media source from a `ConcatenatingMediaSource` with the `useLazyPreparation`
+  option enabled ([#4986](https://github.com/google/ExoPlayer/issues/4986)).
+* Work around an issue where a non-empty end-of-stream audio buffer would be
+  output with timestamp zero, causing the player position to jump backwards
+  ([#5045](https://github.com/google/ExoPlayer/issues/5045)).
+* Suppress a spurious assertion failure on some Samsung devices
+  ([#4532](https://github.com/google/ExoPlayer/issues/4532)).
+* Suppress spurious "references unknown class member" shrinking warning
+  ([#4890](https://github.com/google/ExoPlayer/issues/4890)).
+* Swap recommended order for google() and jcenter() in gradle config
+  ([#4997](https://github.com/google/ExoPlayer/issues/4997)).
+
+### 2.9.0 ###
+
+* Turn on Java 8 compiler support for the ExoPlayer library. Apps may need to
+  add `compileOptions { targetCompatibility JavaVersion.VERSION_1_8 }` to their
+  gradle settings to ensure bytecode compatibility.
+* Set `compileSdkVersion` and `targetSdkVersion` to 28.
+* Support for automatic audio focus handling via
+  `SimpleExoPlayer.setAudioAttributes`.
+* Add `ExoPlayer.retry` convenience method.
+* Add `AudioListener` for listening to changes in audio configuration during
+  playback ([#3994](https://github.com/google/ExoPlayer/issues/3994)).
+* Add `LoadErrorHandlingPolicy` to allow configuration of load error handling
+  across `MediaSource` implementations
+  ([#3370](https://github.com/google/ExoPlayer/issues/3370)).
+* Allow passing a `Looper`, which specifies the thread that must be used to
+  access the player, when instantiating player instances using
+  `ExoPlayerFactory` ([#4278](https://github.com/google/ExoPlayer/issues/4278)).
+* Allow setting log level for ExoPlayer logcat output
+  ([#4665](https://github.com/google/ExoPlayer/issues/4665)).
+* Simplify `BandwidthMeter` injection: The `BandwidthMeter` should now be
+  passed directly to `ExoPlayerFactory`, instead of to `TrackSelection.Factory`
+  and `DataSource.Factory`. The `BandwidthMeter` is passed to the components
+  that need it internally. The `BandwidthMeter` may also be omitted, in which
+  case a default instance will be used.
+* Spherical video:
+  * Support for spherical video by setting `surface_type="spherical_view"` on
+    `PlayerView`.
+  * Support for
+    [VR180](https://github.com/google/spatial-media/blob/master/docs/vr180.md).
+* HLS:
+  * Support PlayReady.
+  * Add container format sniffing
+    ([#2025](https://github.com/google/ExoPlayer/issues/2025)).
+  * Support alternative `EXT-X-KEY` tags.
+  * Support `EXT-X-INDEPENDENT-SEGMENTS` in the master playlist.
+  * Support variable substitution
+    ([#4422](https://github.com/google/ExoPlayer/issues/4422)).
+  * Fix the bitrate being unset on primary track sample formats
+    ([#3297](https://github.com/google/ExoPlayer/issues/3297)).
+  * Make `HlsMediaSource.Factory` take a factory of trackers instead of a
+    tracker instance ([#4814](https://github.com/google/ExoPlayer/issues/4814)).
+* DASH:
+  * Support `messageData` attribute for in-manifest event streams.
+  * Clip periods to their specified durations
+    ([#4185](https://github.com/google/ExoPlayer/issues/4185)).
+* Improve seeking support for progressive streams:
+  * Support seeking in MPEG-TS
+    ([#966](https://github.com/google/ExoPlayer/issues/966)).
+  * Support seeking in MPEG-PS
+    ([#4476](https://github.com/google/ExoPlayer/issues/4476)).
+  * Support approximate seeking in ADTS using a constant bitrate assumption
+    ([#4548](https://github.com/google/ExoPlayer/issues/4548)). The
+    `FLAG_ENABLE_CONSTANT_BITRATE_SEEKING` flag must be set on the extractor to
+    enable this functionality.
+  * Support approximate seeking in AMR using a constant bitrate assumption.
+    The `FLAG_ENABLE_CONSTANT_BITRATE_SEEKING` flag must be set on the extractor
+    to enable this functionality.
+  * Add `DefaultExtractorsFactory.setConstantBitrateSeekingEnabled` to enable
+    approximate seeking using a constant bitrate assumption on all extractors
+    that support it.
+* Video:
+  * Add callback to `VideoListener` to notify of surface size changes.
+  * Improve performance when playing high frame-rate content, and when playing
+    at greater than 1x speed
+    ([#2777](https://github.com/google/ExoPlayer/issues/2777)).
+  * Scale up the initial video decoder maximum input size so playlist
+    transitions with small increases in maximum sample size do not require
+    reinitialization ([#4510](https://github.com/google/ExoPlayer/issues/4510)).
+  * Fix a bug where the player would not transition to the ended state when
+    playing video in tunneled mode.
+* Audio:
+  * Support attaching auxiliary audio effects to the `AudioTrack` via
+    `Player.setAuxEffectInfo` and `Player.clearAuxEffectInfo`.
+  * Support seamless adaptation while playing xHE-AAC streams.
+    ([#4360](https://github.com/google/ExoPlayer/issues/4360)).
+  * Increase `AudioTrack` buffer sizes to the theoretical maximum required for
+    each encoding for passthrough playbacks
+    ([#3803](https://github.com/google/ExoPlayer/issues/3803)).
+  * WAV: Fix issue where white noise would be output at the end of playback
+    ([#4724](https://github.com/google/ExoPlayer/issues/4724)).
+  * MP3: Fix issue where streams would play twice on the SM-T530
+    ([#4519](https://github.com/google/ExoPlayer/issues/4519)).
+* Analytics:
+  * Add callbacks to `DefaultDrmSessionEventListener` and `AnalyticsListener` to
+    be notified of acquired and released DRM sessions.
+  * Add uri field to `LoadEventInfo` in `MediaSourceEventListener` and
+    `AnalyticsListener` callbacks. This uri is the redirected uri if redirection
+    occurred ([#2054](https://github.com/google/ExoPlayer/issues/2054)).
+  * Add response headers field to `LoadEventInfo` in `MediaSourceEventListener`
+    and `AnalyticsListener` callbacks
+    ([#4361](https://github.com/google/ExoPlayer/issues/4361) and
+    [#4615](https://github.com/google/ExoPlayer/issues/4615)).
+* UI components:
+  * Add option to `PlayerView` to show buffering view when playWhenReady is
+    false ([#4304](https://github.com/google/ExoPlayer/issues/4304)).
+  * Allow any `Drawable` to be used as `PlayerView` default artwork.
+* ConcatenatingMediaSource:
+  * Support lazy preparation of playlist media sources
+    ([#3972](https://github.com/google/ExoPlayer/issues/3972)).
+  * Support range removal with `removeMediaSourceRange` methods
+    ([#4542](https://github.com/google/ExoPlayer/issues/4542)).
+  * Support setting a new shuffle order with `setShuffleOrder`
+    ([#4791](https://github.com/google/ExoPlayer/issues/4791)).
+* MPEG-TS: Support CEA-608/708 in H262
+  ([#2565](https://github.com/google/ExoPlayer/issues/2565)).
+* Allow configuration of the back buffer in `DefaultLoadControl.Builder`
+  ([#4857](https://github.com/google/ExoPlayer/issues/4857)).
+* Allow apps to pass a `CacheKeyFactory` for setting custom cache keys when
+  creating a `CacheDataSource`.
+* Provide additional information for adaptive track selection.
+  `TrackSelection.updateSelectedTrack` has two new parameters for the current
+  queue of media chunks and iterators for information about upcoming chunks.
+* Allow `MediaCodecSelector`s to return multiple compatible decoders for
+  `MediaCodecRenderer`, and provide an (optional) `MediaCodecSelector` that
+  falls back to less preferred decoders like `MediaCodec.createDecoderByType`
+  ([#273](https://github.com/google/ExoPlayer/issues/273)).
+* Enable gzip for requests made by `SingleSampleMediaSource`
+  ([#4771](https://github.com/google/ExoPlayer/issues/4771)).
+* Fix bug reporting buffered position for multi-period windows, and add
+  convenience methods `Player.getTotalBufferedDuration` and
+  `Player.getContentBufferedDuration`
+  ([#4023](https://github.com/google/ExoPlayer/issues/4023)).
+* Fix bug where transitions to clipped media sources would happen too early
+  ([#4583](https://github.com/google/ExoPlayer/issues/4583)).
+* Fix bugs reporting events for multi-period media sources
+  ([#4492](https://github.com/google/ExoPlayer/issues/4492) and
+  [#4634](https://github.com/google/ExoPlayer/issues/4634)).
+* Fix issue where removing looping media from a playlist throws an exception
+  ([#4871](https://github.com/google/ExoPlayer/issues/4871).
+* Fix issue where the preferred audio or text track would not be selected if
+  mapped onto a secondary renderer of the corresponding type
+  ([#4711](http://github.com/google/ExoPlayer/issues/4711)).
+* Fix issue where errors of upcoming playlist items are thrown too early
+  ([#4661](https://github.com/google/ExoPlayer/issues/4661)).
+* Allow edit lists which do not start with a sync sample.
+  ([#4774](https://github.com/google/ExoPlayer/issues/4774)).
+* Fix issue with audio discontinuities at period transitions, e.g. when
+  looping ([#3829](https://github.com/google/ExoPlayer/issues/3829)).
+* Fix issue where `player.getCurrentTag()` throws an `IndexOutOfBoundsException`
+  ([#4822](https://github.com/google/ExoPlayer/issues/4822)).
+* Fix bug preventing use of multiple key session support (`multiSession=true`)
+  for non-Widevine `DefaultDrmSessionManager` instances
+  ([#4834](https://github.com/google/ExoPlayer/issues/4834)).
+* Fix issue where audio and video would desynchronize when playing
+  concatenations of gapless content
+  ([#4559](https://github.com/google/ExoPlayer/issues/4559)).
+* IMA extension:
+  * Refine the previous fix for empty ad groups to avoid discarding ad breaks
+    unnecessarily ([#4030](https://github.com/google/ExoPlayer/issues/4030) and
+    [#4280](https://github.com/google/ExoPlayer/issues/4280)).
+  * Fix handling of empty postrolls
+    ([#4681](https://github.com/google/ExoPlayer/issues/4681)).
+  * Fix handling of postrolls with multiple ads
+    ([#4710](https://github.com/google/ExoPlayer/issues/4710)).
+* MediaSession extension:
+  * Add `MediaSessionConnector.setCustomErrorMessage` to support setting custom
+    error messages.
+  * Add `MediaMetadataProvider` to support setting custom metadata
+    ([#3497](https://github.com/google/ExoPlayer/issues/3497)).
+* Cronet extension: Now distributed via jCenter.
+* FFmpeg extension: Support mu-law and A-law PCM.
+
+### 2.8.4 ###
+
+* IMA extension: Improve handling of consecutive empty ad groups
+  ([#4030](https://github.com/google/ExoPlayer/issues/4030)),
+  ([#4280](https://github.com/google/ExoPlayer/issues/4280)).
+
+### 2.8.3 ###
+
+* IMA extension:
+  * Fix behavior when creating/releasing the player then releasing
+    `ImaAdsLoader` ([#3879](https://github.com/google/ExoPlayer/issues/3879)).
+  * Add support for setting slots for companion ads.
+* Captions:
+  * TTML: Fix an issue with TTML using font size as % of cell resolution that
+    makes `SubtitleView.setApplyEmbeddedFontSizes()` not work correctly.
+    ([#4491](https://github.com/google/ExoPlayer/issues/4491)).
+  * CEA-608: Improve handling of embedded styles
+    ([#4321](https://github.com/google/ExoPlayer/issues/4321)).
+* DASH:
+  * Exclude text streams from duration calculations
+    ([#4029](https://github.com/google/ExoPlayer/issues/4029)).
+  * Fix freezing when playing multi-period manifests with `EventStream`s
+    ([#4492](https://github.com/google/ExoPlayer/issues/4492)).
+* DRM: Allow DrmInitData to carry a license server URL
+  ([#3393](https://github.com/google/ExoPlayer/issues/3393)).
+* MPEG-TS: Fix bug preventing SCTE-35 cues from being output
+  ([#4573](https://github.com/google/ExoPlayer/issues/4573)).
+* Expose all internal ID3 data stored in MP4 udta boxes, and switch from using
+  CommentFrame to InternalFrame for frames with gapless metadata in MP4.
+* Add `PlayerView.isControllerVisible`
+  ([#4385](https://github.com/google/ExoPlayer/issues/4385)).
+* Fix issue playing DRM protected streams on Asus Zenfone 2
+  ([#4403](https://github.com/google/ExoPlayer/issues/4413)).
+* Add support for multiple audio and video tracks in MPEG-PS streams
+  ([#4406](https://github.com/google/ExoPlayer/issues/4406)).
+* Add workaround for track index mismatches between trex and tkhd boxes in
+  fragmented MP4 files
+  ([#4477](https://github.com/google/ExoPlayer/issues/4477)).
+* Add workaround for track index mismatches between tfhd and tkhd boxes in
+  fragmented MP4 files
+  ([#4083](https://github.com/google/ExoPlayer/issues/4083)).
+* Ignore all MP4 edit lists if one edit list couldn't be handled
+  ([#4348](https://github.com/google/ExoPlayer/issues/4348)).
+* Fix issue when switching track selection from an embedded track to a primary
+  track in DASH ([#4477](https://github.com/google/ExoPlayer/issues/4477)).
+* Fix accessibility class name for `DefaultTimeBar`
+  ([#4611](https://github.com/google/ExoPlayer/issues/4611)).
+* Improved compatibility with FireOS devices.
+
 ### 2.8.2 ###
 
-* IMA: Don't advertise support for video/mpeg ad media, as we don't have an
-  extractor for this ([#4297](https://github.com/google/ExoPlayer/issues/4297)).
+* IMA extension: Don't advertise support for video/mpeg ad media, as we don't
+  have an extractor for this
+  ([#4297](https://github.com/google/ExoPlayer/issues/4297)).
 * DASH: Fix playback getting stuck when playing representations that have both
   sidx atoms and non-zero presentationTimeOffset values.
 * HLS:
@@ -113,18 +423,18 @@
     begins, and poll the audio timestamp less frequently once it starts
     advancing ([#3841](https://github.com/google/ExoPlayer/issues/3841)).
   * Add an option to skip silent audio in `PlaybackParameters`
-    ((#2635)[https://github.com/google/ExoPlayer/issues/2635]).
+    ([#2635](https://github.com/google/ExoPlayer/issues/2635)).
   * Fix an issue where playback of TrueHD streams would get stuck after seeking
     due to not finding a syncframe
-    ((#3845)[https://github.com/google/ExoPlayer/issues/3845]).
+    ([#3845](https://github.com/google/ExoPlayer/issues/3845)).
   * Fix an issue with eac3-joc playback where a codec would fail to configure
-    ((#4165)[https://github.com/google/ExoPlayer/issues/4165]).
+    ([#4165](https://github.com/google/ExoPlayer/issues/4165)).
   * Handle non-empty end-of-stream buffers, to fix gapless playback of streams
     with encoder padding when the decoder returns a non-empty final buffer.
   * Allow trimming more than one sample when applying an elst audio edit via
     gapless playback info.
   * Allow overriding skipping/scaling with custom `AudioProcessor`s
-    ((#3142)[https://github.com/google/ExoPlayer/issues/3142]).
+    ([#3142](https://github.com/google/ExoPlayer/issues/3142)).
 * Caching:
   * Add release method to the `Cache` interface, and prevent multiple instances
     of `SimpleCache` using the same folder at the same time.
@@ -148,7 +458,7 @@
     ([#4164](https://github.com/google/ExoPlayer/issues/4182)).
   * Fix seeking in live streams
     ([#4187](https://github.com/google/ExoPlayer/issues/4187)).
-* IMA:
+* IMA extension:
   * Allow setting the ad media load timeout
     ([#3691](https://github.com/google/ExoPlayer/issues/3691)).
   * Expose ad load errors via `MediaSourceEventListener` on `AdsMediaSource`,
diff --git a/build.gradle b/build.gradle
index b4389de8e0..96eade1aa3 100644
--- a/build.gradle
+++ b/build.gradle
@@ -13,12 +13,13 @@
 // limitations under the License.
 buildscript {
     repositories {
-        jcenter()
         google()
+        jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.2.1'
+        classpath 'com.android.tools.build:gradle:3.1.4'
         classpath 'com.novoda:bintray-release:0.8.1'
+        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.0.3'
     }
     // Workaround for the following test coverage issue. Remove when fixed:
     // https://code.google.com/p/android/issues/detail?id=226070
@@ -31,8 +32,8 @@ buildscript {
 }
 allprojects {
     repositories {
-        jcenter()
         google()
+        jcenter()
     }
     project.ext {
         exoplayerPublishEnabled = true
diff --git a/constants.gradle b/constants.gradle
index 614244c2b0..ac801d2d3b 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,19 +13,18 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.8.2'
-    releaseVersionCode = 2802
+    releaseVersion = '2.9.3'
+    releaseVersionCode = 2009003
     // Important: ExoPlayer specifies a minSdkVersion of 14 because various
     // components provided by the library may be of use on older devices.
     // However, please note that the core media playback functionality provided
     // by the library requires API level 16 or greater.
     minSdkVersion = 14
-    targetSdkVersion = 27
-    compileSdkVersion = 27
+    targetSdkVersion = 28
+    compileSdkVersion = 28
     buildToolsVersion = '28.0.2'
     testSupportLibraryVersion = '0.5'
-    supportLibraryVersion = '27.0.0'
-    playServicesLibraryVersion = '15.0.1'
+    supportLibraryVersion = '27.1.1'
     dexmakerVersion = '1.2'
     mockitoVersion = '1.9.5'
     junitVersion = '4.12'
@@ -33,7 +32,7 @@ project.ext {
     robolectricVersion = '3.7.1'
     autoValueVersion = '1.6'
     checkerframeworkVersion = '2.5.0'
-    testRunnerVersion = '1.0.2'
+    testRunnerVersion = '1.1.0-alpha3'
     modulePrefix = ':'
     if (gradle.ext.has('exoplayerModulePrefix')) {
         modulePrefix += gradle.ext.exoplayerModulePrefix
diff --git a/core_settings.gradle b/core_settings.gradle
index 868928e61c..2414fb869e 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -30,6 +30,7 @@ include modulePrefix + 'library-ui'
 // include modulePrefix + 'extension-gvr'
 // include modulePrefix + 'extension-ima'
 // include modulePrefix + 'extension-cast'
+// include modulePrefix + 'extension-cronet'
 // include modulePrefix + 'extension-mediasession'
 // include modulePrefix + 'extension-okhttp'
 // include modulePrefix + 'extension-opus'
@@ -44,6 +45,7 @@ project(modulePrefix + 'library-core').projectDir = new File(rootDir, 'library/c
 project(modulePrefix + 'library-hls').projectDir = new File(rootDir, 'library/hls')
 //project(modulePrefix + 'library-smoothstreaming').projectDir = new File(rootDir, 'library/smoothstreaming')
 project(modulePrefix + 'library-ui').projectDir = new File(rootDir, 'library/ui')
+
 // project(modulePrefix + 'testutils').projectDir = new File(rootDir, 'testutils')
 // project(modulePrefix + 'testutils-robolectric').projectDir = new File(rootDir, 'testutils_robolectric')
 // project(modulePrefix + 'extension-ffmpeg').projectDir = new File(rootDir, 'extensions/ffmpeg')
@@ -51,6 +53,7 @@ project(modulePrefix + 'library-ui').projectDir = new File(rootDir, 'library/ui'
 // project(modulePrefix + 'extension-gvr').projectDir = new File(rootDir, 'extensions/gvr')
 // project(modulePrefix + 'extension-ima').projectDir = new File(rootDir, 'extensions/ima')
 // project(modulePrefix + 'extension-cast').projectDir = new File(rootDir, 'extensions/cast')
+// project(modulePrefix + 'extension-cronet').projectDir = new File(rootDir, 'extensions/cronet')
 // project(modulePrefix + 'extension-mediasession').projectDir = new File(rootDir, 'extensions/mediasession')
 // project(modulePrefix + 'extension-okhttp').projectDir = new File(rootDir, 'extensions/okhttp')
 // project(modulePrefix + 'extension-opus').projectDir = new File(rootDir, 'extensions/opus')
@@ -58,9 +61,3 @@ project(modulePrefix + 'library-ui').projectDir = new File(rootDir, 'library/ui'
 // project(modulePrefix + 'extension-rtmp').projectDir = new File(rootDir, 'extensions/rtmp')
 // project(modulePrefix + 'extension-leanback').projectDir = new File(rootDir, 'extensions/leanback')
 // project(modulePrefix + 'extension-jobdispatcher').projectDir = new File(rootDir, 'extensions/jobdispatcher')
-
-if (gradle.ext.has('exoplayerIncludeCronetExtension')
-        && gradle.ext.exoplayerIncludeCronetExtension) {
-    include modulePrefix + 'extension-cronet'
-    project(modulePrefix + 'extension-cronet').projectDir = new File(rootDir, 'extensions/cronet')
-}
diff --git a/demos/cast/build.gradle b/demos/cast/build.gradle
index ae6bdd1d94..915bc10b7c 100644
--- a/demos/cast/build.gradle
+++ b/demos/cast/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         versionName project.ext.releaseVersion
         versionCode project.ext.releaseVersionCode
@@ -57,3 +62,5 @@ dependencies {
     implementation 'com.android.support:appcompat-v7:' + supportLibraryVersion
     implementation 'com.android.support:recyclerview-v7:' + supportLibraryVersion
 }
+
+apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
index 26ab5eb0dd..77f6a6fc1a 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
@@ -81,8 +81,6 @@ public String toString() {
         + "hls/TearsOfSteel.m3u8", "Tears of Steel (HLS)", MIME_TYPE_HLS));
     samples.add(new Sample("https://html5demos.com/assets/dizzy.mp4", "Dizzy (MP4)",
         MIME_TYPE_VIDEO_MP4));
-
-
     SAMPLES = Collections.unmodifiableList(samples);
 
   }
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
index 3e48ab2ab4..30968b8f85 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
@@ -30,8 +30,6 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
@@ -145,13 +143,9 @@ private View buildSampleListView() {
     ListView sampleList = dialogList.findViewById(R.id.sample_list);
     sampleList.setAdapter(new SampleListAdapter(this));
     sampleList.setOnItemClickListener(
-        new OnItemClickListener() {
-
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            playerManager.addItem(DemoUtil.SAMPLES.get(position));
-            mediaQueueListAdapter.notifyItemInserted(playerManager.getMediaQueueSize() - 1);
-          }
+        (parent, view, position, id) -> {
+          playerManager.addItem(DemoUtil.SAMPLES.get(position));
+          mediaQueueListAdapter.notifyItemInserted(playerManager.getMediaQueueSize() - 1);
         });
     return dialogList;
   }
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
index 63b18b0aa7..d188469de8 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
@@ -17,14 +17,15 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.view.KeyEvent;
 import android.view.View;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Player.DefaultEventListener;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.Player.EventListener;
 import com.google.android.exoplayer2.Player.TimelineChangeReason;
 import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
@@ -36,14 +37,11 @@
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.ui.PlayerControlView;
 import com.google.android.exoplayer2.ui.PlayerView;
-import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
 import com.google.android.gms.cast.MediaInfo;
 import com.google.android.gms.cast.MediaMetadata;
@@ -51,11 +49,9 @@
 import com.google.android.gms.cast.framework.CastContext;
 import java.util.ArrayList;
 
-/**
- * Manages players and an internal media queue for the ExoPlayer/Cast demo app.
- */
-/* package */ final class PlayerManager extends DefaultEventListener
-    implements CastPlayer.SessionAvailabilityListener {
+/** Manages players and an internal media queue for the ExoPlayer/Cast demo app. */
+/* package */ final class PlayerManager
+    implements EventListener, CastPlayer.SessionAvailabilityListener {
 
   /**
    * Listener for changes in the media queue playback position.
@@ -70,9 +66,8 @@
   }
 
   private static final String USER_AGENT = "ExoCastDemoPlayer";
-  private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
   private static final DefaultHttpDataSourceFactory DATA_SOURCE_FACTORY =
-      new DefaultHttpDataSourceFactory(USER_AGENT, BANDWIDTH_METER);
+      new DefaultHttpDataSourceFactory(USER_AGENT);
 
   private final PlayerView localPlayerView;
   private final PlayerControlView castControlView;
@@ -119,9 +114,9 @@ private PlayerManager(
     currentItemIndex = C.INDEX_UNSET;
     concatenatingMediaSource = new ConcatenatingMediaSource();
 
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector(BANDWIDTH_METER);
+    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
-    exoPlayer = ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector);
+    exoPlayer = ExoPlayerFactory.newSimpleInstance(context, renderersFactory, trackSelector);
     exoPlayer.addListener(this);
     localPlayerView.setPlayer(exoPlayer);
 
@@ -282,7 +277,7 @@ public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
 
   @Override
   public void onTimelineChanged(
-      Timeline timeline, Object manifest, @TimelineChangeReason int reason) {
+      Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
     updateCurrentItemIndex();
     if (timeline.isEmpty()) {
       castMediaQueueCreationPending = true;
@@ -396,13 +391,9 @@ private static MediaSource buildMediaSource(DemoUtil.Sample sample) {
     Uri uri = Uri.parse(sample.uri);
     switch (sample.mimeType) {
       case DemoUtil.MIME_TYPE_SS:
-        return new SsMediaSource.Factory(
-                new DefaultSsChunkSource.Factory(DATA_SOURCE_FACTORY), DATA_SOURCE_FACTORY)
-            .createMediaSource(uri);
+        return new SsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
       case DemoUtil.MIME_TYPE_DASH:
-        return new DashMediaSource.Factory(
-                new DefaultDashChunkSource.Factory(DATA_SOURCE_FACTORY), DATA_SOURCE_FACTORY)
-            .createMediaSource(uri);
+        return new DashMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
       case DemoUtil.MIME_TYPE_HLS:
         return new HlsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
       case DemoUtil.MIME_TYPE_VIDEO_MP4:
diff --git a/demos/ima/build.gradle b/demos/ima/build.gradle
index 35c2daf88e..33cca6ef46 100644
--- a/demos/ima/build.gradle
+++ b/demos/ima/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         versionName project.ext.releaseVersion
         versionCode project.ext.releaseVersionCode
@@ -51,3 +56,5 @@ dependencies {
     implementation project(modulePrefix + 'extension-ima')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
 }
+
+apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
index 4fab1966fe..d67c4549d8 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -27,18 +27,14 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.ui.PlayerView;
-import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.util.Util;
 
@@ -46,8 +42,7 @@
 /* package */ final class PlayerManager implements AdsMediaSource.MediaSourceFactory {
 
   private final ImaAdsLoader adsLoader;
-  private final DataSource.Factory manifestDataSourceFactory;
-  private final DataSource.Factory mediaDataSourceFactory;
+  private final DataSource.Factory dataSourceFactory;
 
   private SimpleExoPlayer player;
   private long contentPosition;
@@ -55,21 +50,14 @@
   public PlayerManager(Context context) {
     String adTag = context.getString(R.string.ad_tag_url);
     adsLoader = new ImaAdsLoader(context, Uri.parse(adTag));
-    manifestDataSourceFactory =
+    dataSourceFactory =
         new DefaultDataSourceFactory(
             context, Util.getUserAgent(context, context.getString(R.string.application_name)));
-    mediaDataSourceFactory =
-        new DefaultDataSourceFactory(
-            context,
-            Util.getUserAgent(context, context.getString(R.string.application_name)),
-            new DefaultBandwidthMeter());
   }
 
   public void init(Context context, PlayerView playerView) {
     // Create a default track selector.
-    BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
-    TrackSelection.Factory videoTrackSelectionFactory =
-        new AdaptiveTrackSelection.Factory(bandwidthMeter);
+    TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory();
     TrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
 
     // Create a player instance.
@@ -88,9 +76,7 @@ public void init(Context context, PlayerView playerView) {
             contentMediaSource,
             /* adMediaSourceFactory= */ this,
             adsLoader,
-            playerView.getOverlayFrameLayout(),
-            /* eventHandler= */ null,
-            /* eventListener= */ null);
+            playerView.getOverlayFrameLayout());
 
     // Prepare the player with the source.
     player.seekTo(contentPosition);
@@ -133,18 +119,13 @@ private MediaSource buildMediaSource(Uri uri) {
     @ContentType int type = Util.inferContentType(uri);
     switch (type) {
       case C.TYPE_DASH:
-        return new DashMediaSource.Factory(
-                new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
-                manifestDataSourceFactory)
-            .createMediaSource(uri);
+        return new DashMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_SS:
-        return new SsMediaSource.Factory(
-                new DefaultSsChunkSource.Factory(mediaDataSourceFactory), manifestDataSourceFactory)
-            .createMediaSource(uri);
+        return new SsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_HLS:
-        return new HlsMediaSource.Factory(mediaDataSourceFactory).createMediaSource(uri);
+        return new HlsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_OTHER:
-        return new ExtractorMediaSource.Factory(mediaDataSourceFactory).createMediaSource(uri);
+        return new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       default:
         throw new IllegalStateException("Unsupported type: " + type);
     }
diff --git a/demos/ima/src/main/res/values/strings.xml b/demos/ima/src/main/res/values/strings.xml
index 67a7f06f8b..2eb5700bf0 100644
--- a/demos/ima/src/main/res/values/strings.xml
+++ b/demos/ima/src/main/res/values/strings.xml
@@ -17,7 +17,7 @@
 
   <string name="application_name">Exo IMA Demo</string>
 
-  <string name="content_url"><![CDATA[http://rmcdn.2mdn.net/MotifFiles/html/1248596/android_1330378998288.mp4]]></string>
+  <string name="content_url"><![CDATA[https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv]]></string>
 
   <string name="ad_tag_url"><![CDATA[https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dlinear&correlator=]]></string>
 
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index ce0992eb7a..c516ba297f 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         versionName project.ext.releaseVersion
         versionCode project.ext.releaseVersionCode
@@ -70,3 +75,5 @@ dependencies {
     withExtensionsImplementation project(path: modulePrefix + 'extension-vp9')
     withExtensionsImplementation project(path: modulePrefix + 'extension-rtmp')
 }
+
+apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/main/src/main/AndroidManifest.xml b/demos/main/src/main/AndroidManifest.xml
index 2232a8b3eb..e80e37688d 100644
--- a/demos/main/src/main/AndroidManifest.xml
+++ b/demos/main/src/main/AndroidManifest.xml
@@ -21,6 +21,7 @@
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
   <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+  <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
 
   <uses-feature android:name="android.software.leanback" android:required="false"/>
   <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
@@ -79,7 +80,7 @@
     <service android:name="com.google.android.exoplayer2.demo.DemoDownloadService"
         android:exported="false">
       <intent-filter>
-        <action android:name="com.google.android.exoplayer.downloadService.action.INIT"/>
+        <action android:name="com.google.android.exoplayer.downloadService.action.RESTART"/>
         <category android:name="android.intent.category.DEFAULT"/>
       </intent-filter>
     </service>
diff --git a/demos/main/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
index 0d26f196c1..c2acf3990b 100644
--- a/demos/main/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -4,22 +4,22 @@
     "samples": [
       {
         "name": "Google Glass (MP4,H264)",
-        "uri": "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7.8506521BFC350652163895D4C26DEE124209AA9E&key=ik0",
+        "uri": "https://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7.8506521BFC350652163895D4C26DEE124209AA9E&key=ik0",
         "extension": "mpd"
       },
       {
         "name": "Google Play (MP4,H264)",
-        "uri": "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=A2716F75795F5D2AF0E88962FFCD10DB79384F29.84308FF04844498CE6FBCE4731507882B8307798&key=ik0",
+        "uri": "https://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=A2716F75795F5D2AF0E88962FFCD10DB79384F29.84308FF04844498CE6FBCE4731507882B8307798&key=ik0",
         "extension": "mpd"
       },
       {
         "name": "Google Glass (WebM,VP9)",
-        "uri": "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=249B04F79E984D7F86B4D8DB48AE6FAF41C17AB3.7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0",
+        "uri": "https://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=249B04F79E984D7F86B4D8DB48AE6FAF41C17AB3.7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0",
         "extension": "mpd"
       },
       {
         "name": "Google Play (WebM,VP9)",
-        "uri": "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=B1C2A74783AC1CC4865EB312D7DD2D48230CC9FD.BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0",
+        "uri": "https://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=B1C2A74783AC1CC4865EB312D7DD2D48230CC9FD.BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0",
         "extension": "mpd"
       }
     ]
@@ -330,11 +330,11 @@
     "samples": [
       {
         "name": "Super speed",
-        "uri": "http://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism"
+        "uri": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism"
       },
       {
         "name": "Super speed (PlayReady)",
-        "uri": "http://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
+        "uri": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
         "drm_scheme": "playready"
       }
     ]
@@ -352,11 +352,11 @@
       },
       {
         "name": "Apple master playlist advanced (TS)",
-        "uri": "https://tungsten.aaplimg.com/VOD/bipbop_adv_example_v2/master.m3u8"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_ts/master.m3u8"
       },
       {
         "name": "Apple master playlist advanced (fMP4)",
-        "uri": "https://tungsten.aaplimg.com/VOD/bipbop_adv_fmp4_example/master.m3u8"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8"
       },
       {
         "name": "Apple TS media playlist",
@@ -365,10 +365,6 @@
       {
         "name": "Apple AAC media playlist",
         "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear0/prog_index.m3u8"
-      },
-      {
-        "name": "Apple ID3 metadata",
-        "uri": "http://devimages.apple.com/samplecode/adDemo/ad.m3u8"
       }
     ]
   },
@@ -376,7 +372,7 @@
     "name": "Misc",
     "samples": [
       {
-        "name": "Dizzy",
+        "name": "Dizzy (MP4)",
         "uri": "https://html5demos.com/assets/dizzy.mp4"
       },
       {
@@ -391,10 +387,6 @@
         "name": "Android screens (Matroska)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv"
       },
-      {
-        "name": "Big Buck Bunny (MP4 Video)",
-        "uri": "http://redirector.c.youtube.com/videoplayback?id=604ed5ce52eda7ee&itag=22&source=youtube&sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300&key=ik0"
-      },
       {
         "name": "Screens 360P (WebM,VP9,No Audio)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-vp9-360.webm"
@@ -419,21 +411,9 @@
         "name": "Google Play (Ogg/Vorbis Audio)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/ogg/play.ogg"
       },
-      {
-        "name": "Google Glass (WebM Video with Vorbis Audio)",
-        "uri": "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm"
-      },
-      {
-        "name": "Google Glass (VP9 in MP4/ISO-BMFF)",
-        "uri": "http://demos.webmproject.org/exoplayer/glass.mp4"
-      },
-      {
-        "name": "Google Glass DASH - VP9 and Opus",
-        "uri": "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_opus.mpd"
-      },
       {
         "name": "Big Buck Bunny (FLV Video)",
-        "uri": "http://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0"
+        "uri": "https://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0"
       }
     ]
   },
@@ -570,23 +550,32 @@
       {
         "name": "VMAP empty midroll",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
-        "ad_tag_uri": "http://vastsynthesizer.appspot.com/empty-midroll"
+        "ad_tag_uri": "https://vastsynthesizer.appspot.com/empty-midroll"
       },
       {
         "name": "VMAP full, empty, full midrolls",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
-        "ad_tag_uri": "http://vastsynthesizer.appspot.com/empty-midroll-2"
+        "ad_tag_uri": "https://vastsynthesizer.appspot.com/empty-midroll-2"
       }
     ]
   },
   {
-    "name": "ABR",
+    "name": "360",
     "samples": [
       {
-        "name": "Random ABR - Google Glass (MP4,H264)",
-        "uri": "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7.8506521BFC350652163895D4C26DEE124209AA9E&key=ik0",
-        "extension": "mpd",
-        "abr_algorithm": "random"
+        "name": "Congo (360 top-bottom stereo)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/360/congo.mp4",
+        "spherical_stereo_mode": "top_bottom"
+      },
+      {
+        "name": "Sphericalv2 (180 top-bottom stereo)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/360/sphericalv2.mp4",
+        "spherical_stereo_mode": "top_bottom"
+      },
+      {
+        "name": "Iceland (360 top-bottom stereo ts)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/360/iceland0.ts",
+        "spherical_stereo_mode": "top_bottom"
       }
     ]
   }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index b5c127d2e3..ac8be7dc16 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -16,19 +16,13 @@
 package com.google.android.exoplayer2.demo;
 
 import android.app.Application;
-import com.google.android.exoplayer2.offline.DownloadAction.Deserializer;
 import com.google.android.exoplayer2.offline.DownloadManager;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.ProgressiveDownloadAction;
-import com.google.android.exoplayer2.source.dash.offline.DashDownloadAction;
-import com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction;
-import com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
 import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
-import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSourceFactory;
@@ -46,13 +40,6 @@
   private static final String DOWNLOAD_TRACKER_ACTION_FILE = "tracked_actions";
   private static final String DOWNLOAD_CONTENT_DIRECTORY = "downloads";
   private static final int MAX_SIMULTANEOUS_DOWNLOADS = 2;
-  private static final Deserializer[] DOWNLOAD_DESERIALIZERS =
-      new Deserializer[] {
-        DashDownloadAction.DESERIALIZER,
-        HlsDownloadAction.DESERIALIZER,
-        SsDownloadAction.DESERIALIZER,
-        ProgressiveDownloadAction.DESERIALIZER
-      };
 
   protected String userAgent;
 
@@ -68,16 +55,15 @@ public void onCreate() {
   }
 
   /** Returns a {@link DataSource.Factory}. */
-  public DataSource.Factory buildDataSourceFactory(TransferListener<? super DataSource> listener) {
+  public DataSource.Factory buildDataSourceFactory() {
     DefaultDataSourceFactory upstreamFactory =
-        new DefaultDataSourceFactory(this, listener, buildHttpDataSourceFactory(listener));
+        new DefaultDataSourceFactory(this, buildHttpDataSourceFactory());
     return buildReadOnlyCacheDataSource(upstreamFactory, getDownloadCache());
   }
 
   /** Returns a {@link HttpDataSource.Factory}. */
-  public HttpDataSource.Factory buildHttpDataSourceFactory(
-      TransferListener<? super DataSource> listener) {
-    return new DefaultHttpDataSourceFactory(userAgent, listener);
+  public HttpDataSource.Factory buildHttpDataSourceFactory() {
+    return new DefaultHttpDataSourceFactory(userAgent);
   }
 
   /** Returns whether extension renderers should be used. */
@@ -98,21 +84,18 @@ public DownloadTracker getDownloadTracker() {
   private synchronized void initDownloadManager() {
     if (downloadManager == null) {
       DownloaderConstructorHelper downloaderConstructorHelper =
-          new DownloaderConstructorHelper(
-              getDownloadCache(), buildHttpDataSourceFactory(/* listener= */ null));
+          new DownloaderConstructorHelper(getDownloadCache(), buildHttpDataSourceFactory());
       downloadManager =
           new DownloadManager(
               downloaderConstructorHelper,
               MAX_SIMULTANEOUS_DOWNLOADS,
               DownloadManager.DEFAULT_MIN_RETRY_COUNT,
-              new File(getDownloadDirectory(), DOWNLOAD_ACTION_FILE),
-              DOWNLOAD_DESERIALIZERS);
+              new File(getDownloadDirectory(), DOWNLOAD_ACTION_FILE));
       downloadTracker =
           new DownloadTracker(
               /* context= */ this,
-              buildDataSourceFactory(/* listener= */ null),
-              new File(getDownloadDirectory(), DOWNLOAD_TRACKER_ACTION_FILE),
-              DOWNLOAD_DESERIALIZERS);
+              buildDataSourceFactory(),
+              new File(getDownloadDirectory(), DOWNLOAD_TRACKER_ACTION_FILE));
       downloadManager.addListener(downloadTracker);
     }
   }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
index b4bce01c7a..b0619a82fd 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
@@ -22,7 +22,6 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.ArrayAdapter;
@@ -36,7 +35,7 @@
 import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
 import com.google.android.exoplayer2.offline.DownloadService;
 import com.google.android.exoplayer2.offline.ProgressiveDownloadHelper;
-import com.google.android.exoplayer2.offline.SegmentDownloadAction;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.offline.TrackKey;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -46,6 +45,7 @@
 import com.google.android.exoplayer2.ui.DefaultTrackNameProvider;
 import com.google.android.exoplayer2.ui.TrackNameProvider;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.IOException;
@@ -85,7 +85,7 @@ public DownloadTracker(
       Context context,
       DataSource.Factory dataSourceFactory,
       File actionFile,
-      DownloadAction.Deserializer[] deserializers) {
+      DownloadAction.Deserializer... deserializers) {
     this.context = context.getApplicationContext();
     this.dataSourceFactory = dataSourceFactory;
     this.actionFile = new ActionFile(actionFile);
@@ -95,7 +95,8 @@ public DownloadTracker(
     HandlerThread actionFileWriteThread = new HandlerThread("DownloadTracker");
     actionFileWriteThread.start();
     actionFileWriteHandler = new Handler(actionFileWriteThread.getLooper());
-    loadTrackedActions(deserializers);
+    loadTrackedActions(
+        deserializers.length > 0 ? deserializers : DownloadAction.getDefaultDeserializers());
   }
 
   public void addListener(Listener listener) {
@@ -111,15 +112,11 @@ public boolean isDownloaded(Uri uri) {
   }
 
   @SuppressWarnings("unchecked")
-  public <K> List<K> getOfflineStreamKeys(Uri uri) {
+  public List<StreamKey> getOfflineStreamKeys(Uri uri) {
     if (!trackedDownloadStates.containsKey(uri)) {
       return Collections.emptyList();
     }
-    DownloadAction action = trackedDownloadStates.get(uri);
-    if (action instanceof SegmentDownloadAction) {
-      return ((SegmentDownloadAction) action).keys;
-    }
-    return Collections.emptyList();
+    return trackedDownloadStates.get(uri).getKeys();
   }
 
   public void toggleDownload(Activity activity, String name, Uri uri, String extension) {
@@ -178,14 +175,11 @@ private void handleTrackedDownloadStatesChanged() {
     }
     final DownloadAction[] actions = trackedDownloadStates.values().toArray(new DownloadAction[0]);
     actionFileWriteHandler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            try {
-              actionFile.store(actions);
-            } catch (IOException e) {
-              Log.e(TAG, "Failed to store tracked actions", e);
-            }
+        () -> {
+          try {
+            actionFile.store(actions);
+          } catch (IOException e) {
+            Log.e(TAG, "Failed to store tracked actions", e);
           }
         });
   }
@@ -270,11 +264,11 @@ public void onPrepared(DownloadHelper helper) {
             trackTitles.add(trackNameProvider.getTrackName(trackGroup.getFormat(k)));
           }
         }
-        if (!trackKeys.isEmpty()) {
-          builder.setView(dialogView);
-        }
-        builder.create().show();
       }
+      if (!trackKeys.isEmpty()) {
+        builder.setView(dialogView);
+      }
+      builder.create().show();
     }
 
     @Override
@@ -282,6 +276,7 @@ public void onPrepareError(DownloadHelper helper, IOException e) {
       Toast.makeText(
               context.getApplicationContext(), R.string.download_start_error, Toast.LENGTH_LONG)
           .show();
+      Log.e(TAG, "Failed to start download", e);
     }
 
     @Override
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 565f7e300a..ffa9bafa4f 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -49,6 +49,7 @@
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.offline.FilteringManifestParser;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
@@ -57,16 +58,11 @@
 import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
-import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;
-import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
+import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.StreamKey;
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
@@ -77,8 +73,8 @@
 import com.google.android.exoplayer2.ui.PlayerControlView;
 import com.google.android.exoplayer2.ui.PlayerView;
 import com.google.android.exoplayer2.ui.TrackSelectionView;
+import com.google.android.exoplayer2.ui.spherical.SphericalSurfaceView;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
 import com.google.android.exoplayer2.util.EventLogger;
@@ -111,8 +107,13 @@
   public static final String AD_TAG_URI_EXTRA = "ad_tag_uri";
 
   public static final String ABR_ALGORITHM_EXTRA = "abr_algorithm";
-  private static final String ABR_ALGORITHM_DEFAULT = "default";
-  private static final String ABR_ALGORITHM_RANDOM = "random";
+  public static final String ABR_ALGORITHM_DEFAULT = "default";
+  public static final String ABR_ALGORITHM_RANDOM = "random";
+
+  public static final String SPHERICAL_STEREO_MODE_EXTRA = "spherical_stereo_mode";
+  public static final String SPHERICAL_STEREO_MODE_MONO = "mono";
+  public static final String SPHERICAL_STEREO_MODE_TOP_BOTTOM = "top_bottom";
+  public static final String SPHERICAL_STEREO_MODE_LEFT_RIGHT = "left_right";
 
   // For backwards compatibility only.
   private static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
@@ -123,7 +124,6 @@
   private static final String KEY_POSITION = "position";
   private static final String KEY_AUTO_PLAY = "auto_play";
 
-  private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
   private static final CookieManager DEFAULT_COOKIE_MANAGER;
   static {
     DEFAULT_COOKIE_MANAGER = new CookieManager();
@@ -134,7 +134,7 @@
   private LinearLayout debugRootView;
   private TextView debugTextView;
 
-  private DataSource.Factory mediaDataSourceFactory;
+  private DataSource.Factory dataSourceFactory;
   private SimpleExoPlayer player;
   private FrameworkMediaDrm mediaDrm;
   private MediaSource mediaSource;
@@ -157,8 +157,12 @@
 
   @Override
   public void onCreate(Bundle savedInstanceState) {
+    String sphericalStereoMode = getIntent().getStringExtra(SPHERICAL_STEREO_MODE_EXTRA);
+    if (sphericalStereoMode != null) {
+      setTheme(R.style.PlayerTheme_Spherical);
+    }
     super.onCreate(savedInstanceState);
-    mediaDataSourceFactory = buildDataSourceFactory(true);
+    dataSourceFactory = buildDataSourceFactory();
     if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
       CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
     }
@@ -173,6 +177,21 @@ public void onCreate(Bundle savedInstanceState) {
     playerView.setControllerVisibilityListener(this);
     playerView.setErrorMessageProvider(new PlayerErrorMessageProvider());
     playerView.requestFocus();
+    if (sphericalStereoMode != null) {
+      int stereoMode;
+      if (SPHERICAL_STEREO_MODE_MONO.equals(sphericalStereoMode)) {
+        stereoMode = C.STEREO_MODE_MONO;
+      } else if (SPHERICAL_STEREO_MODE_TOP_BOTTOM.equals(sphericalStereoMode)) {
+        stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+      } else if (SPHERICAL_STEREO_MODE_LEFT_RIGHT.equals(sphericalStereoMode)) {
+        stereoMode = C.STEREO_MODE_LEFT_RIGHT;
+      } else {
+        showToast(R.string.error_unrecognized_stereo_mode);
+        finish();
+        return;
+      }
+      ((SphericalSurfaceView) playerView.getVideoSurfaceView()).setDefaultStereoMode(stereoMode);
+    }
 
     if (savedInstanceState != null) {
       trackSelectorParameters = savedInstanceState.getParcelable(KEY_TRACK_SELECTOR_PARAMETERS);
@@ -188,6 +207,7 @@ public void onCreate(Bundle savedInstanceState) {
   @Override
   public void onNewIntent(Intent intent) {
     releasePlayer();
+    releaseAdsLoader();
     clearStartPosition();
     setIntent(intent);
   }
@@ -197,6 +217,9 @@ public void onStart() {
     super.onStart();
     if (Util.SDK_INT > 23) {
       initializePlayer();
+      if (playerView != null) {
+        playerView.onResume();
+      }
     }
   }
 
@@ -205,6 +228,9 @@ public void onResume() {
     super.onResume();
     if (Util.SDK_INT <= 23 || player == null) {
       initializePlayer();
+      if (playerView != null) {
+        playerView.onResume();
+      }
     }
   }
 
@@ -212,6 +238,9 @@ public void onResume() {
   public void onPause() {
     super.onPause();
     if (Util.SDK_INT <= 23) {
+      if (playerView != null) {
+        playerView.onPause();
+      }
       releasePlayer();
     }
   }
@@ -220,6 +249,9 @@ public void onPause() {
   public void onStop() {
     super.onStop();
     if (Util.SDK_INT > 23) {
+      if (playerView != null) {
+        playerView.onPause();
+      }
       releasePlayer();
     }
   }
@@ -328,7 +360,11 @@ private void initializePlayer() {
         finish();
         return;
       }
-      if (Util.maybeRequestReadExternalStoragePermission(this, uris)) {
+      if (!Util.checkCleartextTrafficPermitted(uris)) {
+        showToast(R.string.error_cleartext_not_permitted);
+        return;
+      }
+      if (Util.maybeRequestReadExternalStoragePermission(/* activity= */ this, uris)) {
         // The player will be reinitialized if the permission is granted.
         return;
       }
@@ -369,7 +405,7 @@ private void initializePlayer() {
       TrackSelection.Factory trackSelectionFactory;
       String abrAlgorithm = intent.getStringExtra(ABR_ALGORITHM_EXTRA);
       if (abrAlgorithm == null || ABR_ALGORITHM_DEFAULT.equals(abrAlgorithm)) {
-        trackSelectionFactory = new AdaptiveTrackSelection.Factory(BANDWIDTH_METER);
+        trackSelectionFactory = new AdaptiveTrackSelection.Factory();
       } else if (ABR_ALGORITHM_RANDOM.equals(abrAlgorithm)) {
         trackSelectionFactory = new RandomTrackSelection.Factory();
       } else {
@@ -393,7 +429,8 @@ private void initializePlayer() {
       lastSeenTrackGroupArray = null;
 
       player =
-          ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector, drmSessionManager);
+          ExoPlayerFactory.newSimpleInstance(
+              /* context= */ this, renderersFactory, trackSelector, drmSessionManager);
       player.addListener(new PlayerEventListener());
       player.setPlayWhenReady(startAutoPlay);
       player.addAnalyticsListener(new EventLogger(trackSelector));
@@ -442,36 +479,29 @@ private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension
     @ContentType int type = Util.inferContentType(uri, overrideExtension);
     switch (type) {
       case C.TYPE_DASH:
-        return new DashMediaSource.Factory(
-                new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
-                buildDataSourceFactory(false))
+        return new DashMediaSource.Factory(dataSourceFactory)
             .setManifestParser(
-                new FilteringManifestParser<>(
-                    new DashManifestParser(), (List<RepresentationKey>) getOfflineStreamKeys(uri)))
+                new FilteringManifestParser<>(new DashManifestParser(), getOfflineStreamKeys(uri)))
             .createMediaSource(uri);
       case C.TYPE_SS:
-        return new SsMediaSource.Factory(
-                new DefaultSsChunkSource.Factory(mediaDataSourceFactory),
-                buildDataSourceFactory(false))
+        return new SsMediaSource.Factory(dataSourceFactory)
             .setManifestParser(
-                new FilteringManifestParser<>(
-                    new SsManifestParser(), (List<StreamKey>) getOfflineStreamKeys(uri)))
+                new FilteringManifestParser<>(new SsManifestParser(), getOfflineStreamKeys(uri)))
             .createMediaSource(uri);
       case C.TYPE_HLS:
-        return new HlsMediaSource.Factory(mediaDataSourceFactory)
-            .setPlaylistParser(
-                new FilteringManifestParser<>(
-                    new HlsPlaylistParser(), (List<RenditionKey>) getOfflineStreamKeys(uri)))
+        return new HlsMediaSource.Factory(dataSourceFactory)
+            .setPlaylistParserFactory(
+                new DefaultHlsPlaylistParserFactory(getOfflineStreamKeys(uri)))
             .createMediaSource(uri);
       case C.TYPE_OTHER:
-        return new ExtractorMediaSource.Factory(mediaDataSourceFactory).createMediaSource(uri);
+        return new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       default: {
         throw new IllegalStateException("Unsupported type: " + type);
       }
     }
   }
 
-  private List<?> getOfflineStreamKeys(Uri uri) {
+  private List<StreamKey> getOfflineStreamKeys(Uri uri) {
     return ((DemoApplication) getApplication()).getDownloadTracker().getOfflineStreamKeys(uri);
   }
 
@@ -479,7 +509,7 @@ private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension
       UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
       throws UnsupportedDrmException {
     HttpDataSource.Factory licenseDataSourceFactory =
-        ((DemoApplication) getApplication()).buildHttpDataSourceFactory(/* listener= */ null);
+        ((DemoApplication) getApplication()).buildHttpDataSourceFactory();
     HttpMediaDrmCallback drmCallback =
         new HttpMediaDrmCallback(licenseUrl, licenseDataSourceFactory);
     if (keyRequestPropertiesArray != null) {
@@ -543,16 +573,9 @@ private void clearStartPosition() {
     startPosition = C.TIME_UNSET;
   }
 
-  /**
-   * Returns a new DataSource factory.
-   *
-   * @param useBandwidthMeter Whether to set {@link #BANDWIDTH_METER} as a listener to the new
-   *     DataSource factory.
-   * @return A new DataSource factory.
-   */
-  private DataSource.Factory buildDataSourceFactory(boolean useBandwidthMeter) {
-    return ((DemoApplication) getApplication())
-        .buildDataSourceFactory(useBandwidthMeter ? BANDWIDTH_METER : null);
+  /** Returns a new DataSource factory. */
+  private DataSource.Factory buildDataSourceFactory() {
+    return ((DemoApplication) getApplication()).buildDataSourceFactory();
   }
 
   /** Returns an ads media source, reusing the ads loader if one exists. */
@@ -660,7 +683,7 @@ private static boolean isBehindLiveWindow(ExoPlaybackException e) {
     return false;
   }
 
-  private class PlayerEventListener extends Player.DefaultEventListener {
+  private class PlayerEventListener implements Player.EventListener {
 
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index d87fca8e58..6395ea4c24 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -22,8 +22,11 @@
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.util.JsonReader;
-import android.util.Log;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.ViewGroup;
@@ -40,6 +43,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.DefaultDataSource;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.io.InputStream;
@@ -55,8 +59,11 @@
 
   private static final String TAG = "SampleChooserActivity";
 
+  private boolean useExtensionRenderers;
   private DownloadTracker downloadTracker;
   private SampleAdapter sampleAdapter;
+  private MenuItem preferExtensionDecodersMenuItem;
+  private MenuItem randomAbrMenuItem;
 
   @Override
   public void onCreate(Bundle savedInstanceState) {
@@ -90,7 +97,9 @@ public void onCreate(Bundle savedInstanceState) {
       Arrays.sort(uris);
     }
 
-    downloadTracker = ((DemoApplication) getApplication()).getDownloadTracker();
+    DemoApplication application = (DemoApplication) getApplication();
+    useExtensionRenderers = application.useExtensionRenderers();
+    downloadTracker = application.getDownloadTracker();
     SampleListLoader loaderTask = new SampleListLoader();
     loaderTask.execute(uris);
 
@@ -105,6 +114,22 @@ public void onCreate(Bundle savedInstanceState) {
     }
   }
 
+  @Override
+  public boolean onCreateOptionsMenu(Menu menu) {
+    MenuInflater inflater = getMenuInflater();
+    inflater.inflate(R.menu.sample_chooser_menu, menu);
+    preferExtensionDecodersMenuItem = menu.findItem(R.id.prefer_extension_decoders);
+    preferExtensionDecodersMenuItem.setVisible(useExtensionRenderers);
+    randomAbrMenuItem = menu.findItem(R.id.random_abr);
+    return true;
+  }
+
+  @Override
+  public boolean onOptionsItemSelected(MenuItem item) {
+    item.setChecked(!item.isChecked());
+    return true;
+  }
+
   @Override
   public void onStart() {
     super.onStart();
@@ -135,7 +160,13 @@ private void onSampleGroups(final List<SampleGroup> groups, boolean sawError) {
   public boolean onChildClick(
       ExpandableListView parent, View view, int groupPosition, int childPosition, long id) {
     Sample sample = (Sample) view.getTag();
-    startActivity(sample.buildIntent(this));
+    startActivity(
+        sample.buildIntent(
+            /* context= */ this,
+            isNonNullAndChecked(preferExtensionDecodersMenuItem),
+            isNonNullAndChecked(randomAbrMenuItem)
+                ? PlayerActivity.ABR_ALGORITHM_RANDOM
+                : PlayerActivity.ABR_ALGORITHM_DEFAULT));
     return true;
   }
 
@@ -168,6 +199,11 @@ private int getDownloadUnsupportedStringId(Sample sample) {
     return 0;
   }
 
+  private static boolean isNonNullAndChecked(@Nullable MenuItem menuItem) {
+    // Temporary workaround for layouts that do not inflate the options menu.
+    return menuItem != null && menuItem.isChecked();
+  }
+
   private final class SampleListLoader extends AsyncTask<String, Void, List<SampleGroup>> {
 
     private boolean sawError;
@@ -177,7 +213,8 @@ private int getDownloadUnsupportedStringId(Sample sample) {
       List<SampleGroup> result = new ArrayList<>();
       Context context = getApplicationContext();
       String userAgent = Util.getUserAgent(context, "ExoPlayerDemo");
-      DataSource dataSource = new DefaultDataSource(context, null, userAgent, false);
+      DataSource dataSource =
+          new DefaultDataSource(context, userAgent, /* allowCrossProtocolRedirects= */ false);
       for (String uri : uris) {
         DataSpec dataSpec = new DataSpec(Uri.parse(uri));
         InputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
@@ -245,10 +282,9 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
       String drmLicenseUrl = null;
       String[] drmKeyRequestProperties = null;
       boolean drmMultiSession = false;
-      boolean preferExtensionDecoders = false;
       ArrayList<UriSample> playlistSamples = null;
       String adTagUri = null;
-      String abrAlgorithm = null;
+      String sphericalStereoMode = null;
 
       reader.beginObject();
       while (reader.hasNext()) {
@@ -287,11 +323,6 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
           case "drm_multi_session":
             drmMultiSession = reader.nextBoolean();
             break;
-          case "prefer_extension_decoders":
-            Assertions.checkState(!insidePlaylist,
-                "Invalid attribute on nested item: prefer_extension_decoders");
-            preferExtensionDecoders = reader.nextBoolean();
-            break;
           case "playlist":
             Assertions.checkState(!insidePlaylist, "Invalid nesting of playlists");
             playlistSamples = new ArrayList<>();
@@ -304,10 +335,10 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
           case "ad_tag_uri":
             adTagUri = reader.nextString();
             break;
-          case "abr_algorithm":
+          case "spherical_stereo_mode":
             Assertions.checkState(
-                !insidePlaylist, "Invalid attribute on nested item: abr_algorithm");
-            abrAlgorithm = reader.nextString();
+                !insidePlaylist, "Invalid attribute on nested item: spherical_stereo_mode");
+            sphericalStereoMode = reader.nextString();
             break;
           default:
             throw new ParserException("Unsupported attribute name: " + name);
@@ -321,11 +352,15 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
       if (playlistSamples != null) {
         UriSample[] playlistSamplesArray = playlistSamples.toArray(
             new UriSample[playlistSamples.size()]);
-        return new PlaylistSample(
-            sampleName, preferExtensionDecoders, abrAlgorithm, drmInfo, playlistSamplesArray);
+        return new PlaylistSample(sampleName, drmInfo, playlistSamplesArray);
       } else {
         return new UriSample(
-            sampleName, preferExtensionDecoders, abrAlgorithm, drmInfo, uri, extension, adTagUri);
+            sampleName,
+            drmInfo,
+            uri,
+            extension,
+            adTagUri,
+            sphericalStereoMode);
       }
     }
 
@@ -483,19 +518,15 @@ public void updateIntent(Intent intent) {
 
   private abstract static class Sample {
     public final String name;
-    public final boolean preferExtensionDecoders;
-    public final String abrAlgorithm;
     public final DrmInfo drmInfo;
 
-    public Sample(
-        String name, boolean preferExtensionDecoders, String abrAlgorithm, DrmInfo drmInfo) {
+    public Sample(String name, DrmInfo drmInfo) {
       this.name = name;
-      this.preferExtensionDecoders = preferExtensionDecoders;
-      this.abrAlgorithm = abrAlgorithm;
       this.drmInfo = drmInfo;
     }
 
-    public Intent buildIntent(Context context) {
+    public Intent buildIntent(
+        Context context, boolean preferExtensionDecoders, String abrAlgorithm) {
       Intent intent = new Intent(context, PlayerActivity.class);
       intent.putExtra(PlayerActivity.PREFER_EXTENSION_DECODERS_EXTRA, preferExtensionDecoders);
       intent.putExtra(PlayerActivity.ABR_ALGORITHM_EXTRA, abrAlgorithm);
@@ -512,27 +543,30 @@ public Intent buildIntent(Context context) {
     public final Uri uri;
     public final String extension;
     public final String adTagUri;
+    public final String sphericalStereoMode;
 
     public UriSample(
         String name,
-        boolean preferExtensionDecoders,
-        String abrAlgorithm,
         DrmInfo drmInfo,
         Uri uri,
         String extension,
-        String adTagUri) {
-      super(name, preferExtensionDecoders, abrAlgorithm, drmInfo);
+        String adTagUri,
+        String sphericalStereoMode) {
+      super(name, drmInfo);
       this.uri = uri;
       this.extension = extension;
       this.adTagUri = adTagUri;
+      this.sphericalStereoMode = sphericalStereoMode;
     }
 
     @Override
-    public Intent buildIntent(Context context) {
-      return super.buildIntent(context)
+    public Intent buildIntent(
+        Context context, boolean preferExtensionDecoders, String abrAlgorithm) {
+      return super.buildIntent(context, preferExtensionDecoders, abrAlgorithm)
           .setData(uri)
           .putExtra(PlayerActivity.EXTENSION_EXTRA, extension)
           .putExtra(PlayerActivity.AD_TAG_URI_EXTRA, adTagUri)
+          .putExtra(PlayerActivity.SPHERICAL_STEREO_MODE_EXTRA, sphericalStereoMode)
           .setAction(PlayerActivity.ACTION_VIEW);
     }
 
@@ -544,23 +578,22 @@ public Intent buildIntent(Context context) {
 
     public PlaylistSample(
         String name,
-        boolean preferExtensionDecoders,
-        String abrAlgorithm,
         DrmInfo drmInfo,
         UriSample... children) {
-      super(name, preferExtensionDecoders, abrAlgorithm, drmInfo);
+      super(name, drmInfo);
       this.children = children;
     }
 
     @Override
-    public Intent buildIntent(Context context) {
+    public Intent buildIntent(
+        Context context, boolean preferExtensionDecoders, String abrAlgorithm) {
       String[] uris = new String[children.length];
       String[] extensions = new String[children.length];
       for (int i = 0; i < children.length; i++) {
         uris[i] = children[i].uri.toString();
         extensions[i] = children[i].extension;
       }
-      return super.buildIntent(context)
+      return super.buildIntent(context, preferExtensionDecoders, abrAlgorithm)
           .putExtra(PlayerActivity.URI_LIST_EXTRA, uris)
           .putExtra(PlayerActivity.EXTENSION_LIST_EXTRA, extensions)
           .setAction(PlayerActivity.ACTION_VIEW_LIST);
diff --git a/demos/main/src/main/res/drawable-xxhdpi/ic_download.png b/demos/main/src/main/res/drawable-xxhdpi/ic_download.png
index f02715177a..4e04a30198 100644
Binary files a/demos/main/src/main/res/drawable-xxhdpi/ic_download.png and b/demos/main/src/main/res/drawable-xxhdpi/ic_download.png differ
diff --git a/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png b/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png
index 6602791545..f9bfb5edba 100644
Binary files a/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png and b/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png differ
diff --git a/demos/main/src/main/res/menu/sample_chooser_menu.xml b/demos/main/src/main/res/menu/sample_chooser_menu.xml
new file mode 100644
index 0000000000..566b23a0d5
--- /dev/null
+++ b/demos/main/src/main/res/menu/sample_chooser_menu.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:id="@+id/prefer_extension_decoders"
+    android:title="@string/prefer_extension_decoders"
+    android:showAsAction="never"
+    android:checkable="true"/>
+  <item android:id="@+id/random_abr"
+    android:title="@string/random_abr"
+    android:showAsAction="never"
+    android:checkable="true"/>
+</menu>
diff --git a/demos/main/src/main/res/values/strings.xml b/demos/main/src/main/res/values/strings.xml
index eb260e6ffc..40f065b18e 100644
--- a/demos/main/src/main/res/values/strings.xml
+++ b/demos/main/src/main/res/values/strings.xml
@@ -19,10 +19,14 @@
 
   <string name="unexpected_intent_action">Unexpected intent action: <xliff:g id="action">%1$s</xliff:g></string>
 
+  <string name="error_cleartext_not_permitted">Cleartext traffic not permitted</string>
+
   <string name="error_generic">Playback failed</string>
 
   <string name="error_unrecognized_abr_algorithm">Unrecognized ABR algorithm</string>
 
+  <string name="error_unrecognized_stereo_mode">Unrecognized stereo mode</string>
+
   <string name="error_drm_not_supported">Protected content not supported on API levels below 18</string>
 
   <string name="error_drm_unsupported_scheme">This device does not support the required DRM scheme</string>
@@ -57,4 +61,8 @@
 
   <string name="download_ads_unsupported">IMA does not support offline ads</string>
 
+  <string name="prefer_extension_decoders">Prefer extension decoders</string>
+
+  <string name="random_abr">Enable random ABR</string>
+
 </resources>
diff --git a/demos/main/src/main/res/values/styles.xml b/demos/main/src/main/res/values/styles.xml
index 5616bb9869..25d826bdf6 100644
--- a/demos/main/src/main/res/values/styles.xml
+++ b/demos/main/src/main/res/values/styles.xml
@@ -20,4 +20,8 @@
     <item name="android:windowBackground">@android:color/black</item>
   </style>
 
+  <style name="PlayerTheme.Spherical">
+    <item name="surface_type">spherical_view</item>
+  </style>
+
 </resources>
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index fa348aaf17..30fe10085f 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion 14
         targetSdkVersion project.ext.targetSdkVersion
@@ -26,7 +31,7 @@ android {
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:' + playServicesLibraryVersion
+    api 'com.google.android.gms:play-services-cast-framework:16.0.3'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
     testImplementation project(modulePrefix + 'testutils')
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 84724cbb47..71322de87e 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -15,9 +15,10 @@
  */
 package com.google.android.exoplayer2.ext.cast;
 
+import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.util.Log;
+import com.google.android.exoplayer2.BasePlayer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -29,8 +30,8 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
-import com.google.android.exoplayer2.util.Util;
 import com.google.android.gms.cast.CastStatusCodes;
 import com.google.android.gms.cast.MediaInfo;
 import com.google.android.gms.cast.MediaQueueItem;
@@ -61,7 +62,7 @@
  *
  * <p>Methods should be called on the application's main thread.</p>
  */
-public final class CastPlayer implements Player {
+public final class CastPlayer extends BasePlayer {
 
   /**
    * Listener of changes in the cast session availability.
@@ -94,7 +95,6 @@
   private final CastContext castContext;
   // TODO: Allow custom implementations of CastTimelineTracker.
   private final CastTimelineTracker timelineTracker;
-  private final Timeline.Window window;
   private final Timeline.Period period;
 
   private RemoteMediaClient remoteMediaClient;
@@ -127,7 +127,6 @@
   public CastPlayer(CastContext castContext) {
     this.castContext = castContext;
     timelineTracker = new CastTimelineTracker();
-    window = new Timeline.Window();
     period = new Timeline.Period();
     statusListener = new StatusListener();
     seekResultCallback = new SeekResultCallback();
@@ -284,15 +283,34 @@ public void setSessionAvailabilityListener(SessionAvailabilityListener listener)
   // Player implementation.
 
   @Override
+  @Nullable
+  public AudioComponent getAudioComponent() {
+    return null;
+  }
+
+  @Override
+  @Nullable
   public VideoComponent getVideoComponent() {
     return null;
   }
 
   @Override
+  @Nullable
   public TextComponent getTextComponent() {
     return null;
   }
 
+  @Override
+  @Nullable
+  public MetadataComponent getMetadataComponent() {
+    return null;
+  }
+
+  @Override
+  public Looper getApplicationLooper() {
+    return Looper.getMainLooper();
+  }
+
   @Override
   public void addListener(EventListener listener) {
     listeners.add(listener);
@@ -330,21 +348,6 @@ public boolean getPlayWhenReady() {
     return playWhenReady;
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    seekTo(0);
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    seekTo(windowIndex, 0);
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    seekTo(getCurrentWindowIndex(), positionMs);
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     MediaStatus mediaStatus = getMediaStatus();
@@ -381,11 +384,6 @@ public PlaybackParameters getPlaybackParameters() {
     return PlaybackParameters.DEFAULT;
   }
 
-  @Override
-  public void stop() {
-    stop(/* reset= */ false);
-  }
-
   @Override
   public void stop(boolean reset) {
     playbackState = STATE_IDLE;
@@ -475,32 +473,11 @@ public int getCurrentWindowIndex() {
     return pendingSeekWindowIndex != C.INDEX_UNSET ? pendingSeekWindowIndex : currentWindowIndex;
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    return currentTimeline.isEmpty() ? C.INDEX_UNSET
-        : currentTimeline.getNextWindowIndex(getCurrentWindowIndex(), repeatMode, false);
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    return currentTimeline.isEmpty() ? C.INDEX_UNSET
-        : currentTimeline.getPreviousWindowIndex(getCurrentWindowIndex(), repeatMode, false);
-  }
-
-  @Override
-  public @Nullable Object getCurrentTag() {
-    int windowIndex = getCurrentWindowIndex();
-    return windowIndex > currentTimeline.getWindowCount()
-        ? null
-        : currentTimeline.getWindow(windowIndex, window, /* setTag= */ true).tag;
-  }
-
   // TODO: Fill the cast timeline information with ProgressListener's duration updates.
   // See [Internal: b/65152553].
   @Override
   public long getDuration() {
-    return currentTimeline.isEmpty() ? C.TIME_UNSET
-        : currentTimeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+    return getContentDuration();
   }
 
   @Override
@@ -518,24 +495,12 @@ public long getBufferedPosition() {
   }
 
   @Override
-  public int getBufferedPercentage() {
-    long position = getBufferedPosition();
-    long duration = getDuration();
-    return position == C.TIME_UNSET || duration == C.TIME_UNSET
+  public long getTotalBufferedDuration() {
+    long bufferedPosition = getBufferedPosition();
+    long currentPosition = getCurrentPosition();
+    return bufferedPosition == C.TIME_UNSET || currentPosition == C.TIME_UNSET
         ? 0
-        : duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100);
-  }
-
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    return !currentTimeline.isEmpty()
-        && currentTimeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    return !currentTimeline.isEmpty()
-        && currentTimeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+        : bufferedPosition - currentPosition;
   }
 
   @Override
@@ -563,6 +528,11 @@ public long getContentPosition() {
     return getCurrentPosition();
   }
 
+  @Override
+  public long getContentBufferedPosition() {
+    return getBufferedPosition();
+  }
+
   // Internal methods.
 
   public void updateInternalState() {
@@ -820,7 +790,6 @@ public void onSendingRemoteMediaRequest() {}
     @Override
     public void onAdBreakStatusUpdated() {}
 
-
     // SessionManagerListener implementation.
 
     @Override
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
index 396f6f8769..4939e62a2b 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
@@ -32,8 +32,7 @@
 /* package */ final class CastTimeline extends Timeline {
 
   public static final CastTimeline EMPTY_CAST_TIMELINE =
-      new CastTimeline(
-          Collections.<MediaQueueItem>emptyList(), Collections.<String, Long>emptyMap());
+      new CastTimeline(Collections.emptyList(), Collections.emptyMap());
 
   private final SparseIntArray idsToIndex;
   private final int[] ids;
@@ -108,6 +107,11 @@ public int getIndexOfPeriod(Object uid) {
     return uid instanceof Integer ? idsToIndex.get((int) uid, C.INDEX_UNSET) : C.INDEX_UNSET;
   }
 
+  @Override
+  public Object getUidOfPeriod(int periodIndex) {
+    return ids[periodIndex];
+  }
+
   // equals and hashCode implementations.
 
   @Override
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
index d2154eec1b..997857f6b5 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
@@ -101,8 +101,15 @@ public static String getLogString(int statusCode) {
    * @return The equivalent {@link Format}.
    */
   public static Format mediaTrackToFormat(MediaTrack mediaTrack) {
-    return Format.createContainerFormat(mediaTrack.getContentId(), mediaTrack.getContentType(),
-        null, null, Format.NO_VALUE, 0, mediaTrack.getLanguage());
+    return Format.createContainerFormat(
+        mediaTrack.getContentId(),
+        /* label= */ null,
+        mediaTrack.getContentType(),
+        /* sampleMimeType= */ null,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* selectionFlags= */ 0,
+        mediaTrack.getLanguage());
   }
 
   private CastUtils() {}
diff --git a/extensions/cronet/README.md b/extensions/cronet/README.md
index ea84b602db..f1f6d68c81 100644
--- a/extensions/cronet/README.md
+++ b/extensions/cronet/README.md
@@ -5,37 +5,22 @@ The Cronet extension is an [HttpDataSource][] implementation using [Cronet][].
 [HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
 [Cronet]: https://chromium.googlesource.com/chromium/src/+/master/components/cronet?autodive=0%2F%2F
 
-## Build instructions ##
+## Getting the extension ##
 
-To use this extension you need to clone the ExoPlayer repository and depend on
-its modules locally. Instructions for doing this can be found in ExoPlayer's
-[top level README][]. In addition, it's necessary to get the Cronet libraries
-and enable the extension:
+The easiest way to use the extension is to add it as a gradle dependency:
 
-1. Find the latest Cronet release [here][] and navigate to its `Release/cronet`
-   directory
-1. Download `cronet_api.jar`, `cronet_impl_common_java.jar`,
-   `cronet_impl_native_java.jar` and the `libs` directory
-1. Copy the three jar files into the `libs` directory of this extension
-1. Copy the content of the downloaded `libs` directory into the `jniLibs`
-   directory of this extension
-1. In your `settings.gradle` file, add
-   `gradle.ext.exoplayerIncludeCronetExtension = true` before the line that
-   applies `core_settings.gradle`.
-1. In all `build.gradle` files where this extension is linked as a dependency,
-   add
-   ```
-   android {
-    compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_8
-        targetCompatibility JavaVersion.VERSION_1_8
-    }
-   }
-   ```
-   to enable Java 8 features required by the Cronet library.
+```gradle
+implementation 'com.google.android.exoplayer:extension-cronet:2.X.X'
+```
+
+where `2.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
+
+Alternatively, you can clone the ExoPlayer repository and depend on the module
+locally. Instructions for doing this can be found in ExoPlayer's
+[top level README][].
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
-[here]: https://console.cloud.google.com/storage/browser/chromium-cronet/android
 
 ## Using the extension ##
 
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 0a52344464..7d8c217b58 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -19,14 +19,10 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion project.ext.minSdkVersion
+        minSdkVersion 16
         targetSdkVersion project.ext.targetSdkVersion
     }
 
-    sourceSets.main {
-        jniLibs.srcDirs = ['jniLibs']
-    }
-
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
         targetCompatibility JavaVersion.VERSION_1_8
@@ -34,9 +30,7 @@ android {
 }
 
 dependencies {
-    api files('libs/cronet_api.jar')
-    implementation files('libs/cronet_impl_common_java.jar')
-    implementation files('libs/cronet_impl_native_java.jar')
+    api 'org.chromium.net:cronet-embedded:66.3359.158'
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     testImplementation project(modulePrefix + 'library')
@@ -47,3 +41,9 @@ ext {
     javadocTitle = 'Cronet extension'
 }
 apply from: '../../javadoc_library.gradle'
+
+ext {
+    releaseArtifact = 'extension-cronet'
+    releaseDescription = 'Cronet extension for ExoPlayer.'
+}
+apply from: '../../publish.gradle'
diff --git a/extensions/cronet/jniLibs/README.md b/extensions/cronet/jniLibs/README.md
deleted file mode 100644
index e9f0717ae6..0000000000
--- a/extensions/cronet/jniLibs/README.md
+++ /dev/null
@@ -1 +0,0 @@
-Copy folders containing architecture specific .so files here.
diff --git a/extensions/cronet/libs/README.md b/extensions/cronet/libs/README.md
deleted file mode 100644
index 641a80db18..0000000000
--- a/extensions/cronet/libs/README.md
+++ /dev/null
@@ -1 +0,0 @@
-Copy cronet.jar and cronet_api.jar here.
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index db980aa72b..ab10f41d8f 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -16,22 +16,24 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
-import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.ConditionVariable;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Predicate;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -47,9 +49,10 @@
 
 /**
  * DataSource without intermediate buffer based on Cronet API set using UrlRequest.
+ *
  * <p>This class's methods are organized in the sequence of expected calls.
  */
-public class CronetDataSource extends UrlRequest.Callback implements HttpDataSource {
+public class CronetDataSource extends BaseDataSource implements HttpDataSource {
 
   /**
    * Thrown when an error is encountered when trying to open a {@link CronetDataSource}.
@@ -95,6 +98,8 @@ public InterruptedIOException(InterruptedException e) {
    */
   public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
 
+  /* package */ final UrlRequest.Callback urlRequestCallback;
+
   private static final String TAG = "CronetDataSource";
   private static final String CONTENT_TYPE = "Content-Type";
   private static final String SET_COOKIE = "Set-Cookie";
@@ -108,7 +113,6 @@ public InterruptedIOException(InterruptedException e) {
   private final CronetEngine cronetEngine;
   private final Executor executor;
   private final Predicate<String> contentTypePredicate;
-  private final TransferListener<? super CronetDataSource> listener;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
@@ -143,57 +147,73 @@ public InterruptedIOException(InterruptedException e) {
 
   /**
    * @param cronetEngine A CronetEngine.
-   * @param executor The {@link java.util.concurrent.Executor} that will handle responses.
-   *     This may be a direct executor (i.e. executes tasks on the calling thread) in order
-   *     to avoid a thread hop from Cronet's internal network thread to the response handling
-   *     thread. However, to avoid slowing down overall network performance, care must be taken
-   *     to make sure response handling is a fast operation when using a direct executor.
+   * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
+   *     be a direct executor (i.e. executes tasks on the calling thread) in order to avoid a thread
+   *     hop from Cronet's internal network thread to the response handling thread. However, to
+   *     avoid slowing down overall network performance, care must be taken to make sure response
+   *     handling is a fast operation when using a direct executor.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    */
-  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener) {
-    this(cronetEngine, executor, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
-        DEFAULT_READ_TIMEOUT_MILLIS, false, null, false);
+  public CronetDataSource(
+      CronetEngine cronetEngine, Executor executor, Predicate<String> contentTypePredicate) {
+    this(
+        cronetEngine,
+        executor,
+        contentTypePredicate,
+        DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS,
+        false,
+        null,
+        false);
   }
 
   /**
    * @param cronetEngine A CronetEngine.
-   * @param executor The {@link java.util.concurrent.Executor} that will handle responses.
-   *     This may be a direct executor (i.e. executes tasks on the calling thread) in order
-   *     to avoid a thread hop from Cronet's internal network thread to the response handling
-   *     thread. However, to avoid slowing down overall network performance, care must be taken
-   *     to make sure response handling is a fast operation when using a direct executor.
+   * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
+   *     be a direct executor (i.e. executes tasks on the calling thread) in order to avoid a thread
+   *     hop from Cronet's internal network thread to the response handling thread. However, to
+   *     avoid slowing down overall network performance, care must be taken to make sure response
+   *     handling is a fast operation when using a direct executor.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    * @param connectTimeoutMs The connection timeout, in milliseconds.
    * @param readTimeoutMs The read timeout, in milliseconds.
    * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
    * @param defaultRequestProperties The default request properties to be used.
    */
-  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects,
+  public CronetDataSource(
+      CronetEngine cronetEngine,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
       RequestProperties defaultRequestProperties) {
-    this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
-        readTimeoutMs, resetTimeoutOnRedirects, Clock.DEFAULT, defaultRequestProperties, false);
+    this(
+        cronetEngine,
+        executor,
+        contentTypePredicate,
+        connectTimeoutMs,
+        readTimeoutMs,
+        resetTimeoutOnRedirects,
+        Clock.DEFAULT,
+        defaultRequestProperties,
+        false);
   }
 
   /**
    * @param cronetEngine A CronetEngine.
-   * @param executor The {@link java.util.concurrent.Executor} that will handle responses.
-   *     This may be a direct executor (i.e. executes tasks on the calling thread) in order
-   *     to avoid a thread hop from Cronet's internal network thread to the response handling
-   *     thread. However, to avoid slowing down overall network performance, care must be taken
-   *     to make sure response handling is a fast operation when using a direct executor.
+   * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
+   *     be a direct executor (i.e. executes tasks on the calling thread) in order to avoid a thread
+   *     hop from Cronet's internal network thread to the response handling thread. However, to
+   *     avoid slowing down overall network performance, care must be taken to make sure response
+   *     handling is a fast operation when using a direct executor.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    * @param connectTimeoutMs The connection timeout, in milliseconds.
    * @param readTimeoutMs The read timeout, in milliseconds.
    * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
@@ -201,23 +221,42 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
    * @param handleSetCookieRequests Whether "Set-Cookie" requests on redirect should be forwarded to
    *     the redirect url in the "Cookie" header.
    */
-  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects,
-      RequestProperties defaultRequestProperties, boolean handleSetCookieRequests) {
-    this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
-        readTimeoutMs, resetTimeoutOnRedirects, Clock.DEFAULT, defaultRequestProperties,
+  public CronetDataSource(
+      CronetEngine cronetEngine,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
+      RequestProperties defaultRequestProperties,
+      boolean handleSetCookieRequests) {
+    this(
+        cronetEngine,
+        executor,
+        contentTypePredicate,
+        connectTimeoutMs,
+        readTimeoutMs,
+        resetTimeoutOnRedirects,
+        Clock.DEFAULT,
+        defaultRequestProperties,
         handleSetCookieRequests);
   }
 
-  /* package */ CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock,
-      RequestProperties defaultRequestProperties, boolean handleSetCookieRequests) {
+  /* package */ CronetDataSource(
+      CronetEngine cronetEngine,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
+      Clock clock,
+      RequestProperties defaultRequestProperties,
+      boolean handleSetCookieRequests) {
+    super(/* isNetwork= */ true);
+    this.urlRequestCallback = new UrlRequestCallback();
     this.cronetEngine = Assertions.checkNotNull(cronetEngine);
     this.executor = Assertions.checkNotNull(executor);
     this.contentTypePredicate = contentTypePredicate;
-    this.listener = listener;
     this.connectTimeoutMs = connectTimeoutMs;
     this.readTimeoutMs = readTimeoutMs;
     this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
@@ -247,7 +286,7 @@ public void clearAllRequestProperties() {
 
   @Override
   public Map<String, List<String>> getResponseHeaders() {
-    return responseInfo == null ? null : responseInfo.getAllHeaders();
+    return responseInfo == null ? Collections.emptyMap() : responseInfo.getAllHeaders();
   }
 
   @Override
@@ -270,6 +309,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
     currentUrlRequest.start();
 
+    transferInitializing(dataSpec);
     try {
       boolean connectionOpened = blockUntilConnectTimeout();
       if (exception != null) {
@@ -287,8 +327,12 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     // Check for a valid response code.
     int responseCode = responseInfo.getHttpStatusCode();
     if (responseCode < 200 || responseCode > 299) {
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode,
-          responseInfo.getAllHeaders(), currentDataSpec);
+      InvalidResponseCodeException exception =
+          new InvalidResponseCodeException(
+              responseCode,
+              responseInfo.getHttpStatusText(),
+              responseInfo.getAllHeaders(),
+              currentDataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
@@ -323,9 +367,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
 
     return bytesRemaining;
   }
@@ -391,9 +433,7 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
     if (bytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining -= bytesRead;
     }
-    if (listener != null) {
-      listener.onBytesTransferred(this, bytesRead);
-    }
+    bytesTransferred(bytesRead);
     return bytesRead;
   }
 
@@ -412,107 +452,29 @@ public synchronized void close() {
     finished = false;
     if (opened) {
       opened = false;
-      if (listener != null) {
-        listener.onTransferEnd(this);
-      }
+      transferEnded();
     }
   }
 
-  // UrlRequest.Callback implementation
-
-  @Override
-  public synchronized void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
-      String newLocationUrl) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    if (currentDataSpec.postBody != null) {
-      int responseCode = info.getHttpStatusCode();
-      // The industry standard is to disregard POST redirects when the status code is 307 or 308.
-      // For other redirect response codes the POST request is converted to a GET request and the
-      // redirect is followed.
-      if (responseCode == 307 || responseCode == 308) {
-        exception = new InvalidResponseCodeException(responseCode, info.getAllHeaders(),
-            currentDataSpec);
-        operation.open();
-        return;
-      }
-    }
-    if (resetTimeoutOnRedirects) {
-      resetConnectTimeout();
-    }
-
-    Map<String, List<String>> headers = info.getAllHeaders();
-    if (!handleSetCookieRequests || isEmpty(headers.get(SET_COOKIE))) {
-      request.followRedirect();
-    } else {
-      currentUrlRequest.cancel();
-      DataSpec redirectUrlDataSpec = new DataSpec(Uri.parse(newLocationUrl),
-          currentDataSpec.postBody, currentDataSpec.absoluteStreamPosition,
-          currentDataSpec.position, currentDataSpec.length, currentDataSpec.key,
-          currentDataSpec.flags);
-      UrlRequest.Builder requestBuilder;
-      try {
-        requestBuilder = buildRequestBuilder(redirectUrlDataSpec);
-      } catch (IOException e) {
-        exception = e;
-        return;
-      }
-      String cookieHeadersValue = parseCookies(headers.get(SET_COOKIE));
-      attachCookies(requestBuilder, cookieHeadersValue);
-      currentUrlRequest = requestBuilder.build();
-      currentUrlRequest.start();
-    }
-  }
-
-  @Override
-  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    responseInfo = info;
-    operation.open();
-  }
-
-  @Override
-  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
-      ByteBuffer buffer) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    operation.open();
+  /** Returns current {@link UrlRequest}. May be null if the data source is not opened. */
+  @Nullable
+  protected UrlRequest getCurrentUrlRequest() {
+    return currentUrlRequest;
   }
 
-  @Override
-  public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    finished = true;
-    operation.open();
-  }
-
-  @Override
-  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
-      CronetException error) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    if (error instanceof NetworkException
-        && ((NetworkException) error).getErrorCode()
-            == NetworkException.ERROR_HOSTNAME_NOT_RESOLVED) {
-      exception = new UnknownHostException();
-    } else {
-      exception = error;
-    }
-    operation.open();
+  /** Returns current {@link UrlResponseInfo}. May be null if the data source is not opened. */
+  @Nullable
+  protected UrlResponseInfo getCurrentUrlResponseInfo() {
+    return responseInfo;
   }
 
   // Internal methods.
 
   private UrlRequest.Builder buildRequestBuilder(DataSpec dataSpec) throws IOException {
-    UrlRequest.Builder requestBuilder = cronetEngine.newUrlRequestBuilder(
-        dataSpec.uri.toString(), this, executor).allowDirectExecutor();
+    UrlRequest.Builder requestBuilder =
+        cronetEngine
+            .newUrlRequestBuilder(dataSpec.uri.toString(), urlRequestCallback, executor)
+            .allowDirectExecutor();
     // Set the headers.
     boolean isContentTypeHeaderSet = false;
     if (defaultRequestProperties != null) {
@@ -528,8 +490,8 @@ public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
       isContentTypeHeaderSet = isContentTypeHeaderSet || CONTENT_TYPE.equals(key);
       requestBuilder.addHeader(key, headerEntry.getValue());
     }
-    if (dataSpec.postBody != null && dataSpec.postBody.length != 0 && !isContentTypeHeaderSet) {
-      throw new IOException("POST request with non-empty body must set Content-Type");
+    if (dataSpec.httpBody != null && !isContentTypeHeaderSet) {
+      throw new IOException("HTTP request with non-empty body must set Content-Type");
     }
     // Set the Range header.
     if (dataSpec.position != 0 || dataSpec.length != C.LENGTH_UNSET) {
@@ -549,12 +511,10 @@ public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
     //   requestBuilder.addHeader("Accept-Encoding", "identity");
     // }
     // Set the method and (if non-empty) the body.
-    if (dataSpec.postBody != null) {
-      requestBuilder.setHttpMethod("POST");
-      if (dataSpec.postBody.length != 0) {
-        requestBuilder.setUploadDataProvider(new ByteArrayUploadDataProvider(dataSpec.postBody),
-            executor);
-      }
+    requestBuilder.setHttpMethod(dataSpec.getHttpMethodString());
+    if (dataSpec.httpBody != null) {
+      requestBuilder.setUploadDataProvider(
+          new ByteArrayUploadDataProvider(dataSpec.httpBody), executor);
     }
     return requestBuilder;
   }
@@ -655,4 +615,106 @@ private static boolean isEmpty(List<?> list) {
     return list == null || list.isEmpty();
   }
 
+  private final class UrlRequestCallback extends UrlRequest.Callback {
+
+    @Override
+    public synchronized void onRedirectReceived(
+        UrlRequest request, UrlResponseInfo info, String newLocationUrl) {
+      if (request != currentUrlRequest) {
+        return;
+      }
+      if (currentDataSpec.httpMethod == DataSpec.HTTP_METHOD_POST) {
+        int responseCode = info.getHttpStatusCode();
+        // The industry standard is to disregard POST redirects when the status code is 307 or 308.
+        if (responseCode == 307 || responseCode == 308) {
+          exception =
+              new InvalidResponseCodeException(
+                  responseCode, info.getHttpStatusText(), info.getAllHeaders(), currentDataSpec);
+          operation.open();
+          return;
+        }
+      }
+      if (resetTimeoutOnRedirects) {
+        resetConnectTimeout();
+      }
+
+      Map<String, List<String>> headers = info.getAllHeaders();
+      if (!handleSetCookieRequests || isEmpty(headers.get(SET_COOKIE))) {
+        request.followRedirect();
+      } else {
+        currentUrlRequest.cancel();
+        DataSpec redirectUrlDataSpec;
+        if (currentDataSpec.httpMethod == DataSpec.HTTP_METHOD_POST) {
+          // For POST redirects that aren't 307 or 308, the redirect is followed but request is
+          // transformed into a GET.
+          redirectUrlDataSpec =
+              new DataSpec(
+                  Uri.parse(newLocationUrl),
+                  DataSpec.HTTP_METHOD_GET,
+                  /* httpBody= */ null,
+                  currentDataSpec.absoluteStreamPosition,
+                  currentDataSpec.position,
+                  currentDataSpec.length,
+                  currentDataSpec.key,
+                  currentDataSpec.flags);
+        } else {
+          redirectUrlDataSpec = currentDataSpec.withUri(Uri.parse(newLocationUrl));
+        }
+        UrlRequest.Builder requestBuilder;
+        try {
+          requestBuilder = buildRequestBuilder(redirectUrlDataSpec);
+        } catch (IOException e) {
+          exception = e;
+          return;
+        }
+        String cookieHeadersValue = parseCookies(headers.get(SET_COOKIE));
+        attachCookies(requestBuilder, cookieHeadersValue);
+        currentUrlRequest = requestBuilder.build();
+        currentUrlRequest.start();
+      }
+    }
+
+    @Override
+    public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
+      if (request != currentUrlRequest) {
+        return;
+      }
+      responseInfo = info;
+      operation.open();
+    }
+
+    @Override
+    public synchronized void onReadCompleted(
+        UrlRequest request, UrlResponseInfo info, ByteBuffer buffer) {
+      if (request != currentUrlRequest) {
+        return;
+      }
+      operation.open();
+    }
+
+    @Override
+    public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+      if (request != currentUrlRequest) {
+        return;
+      }
+      finished = true;
+      operation.open();
+    }
+
+    @Override
+    public synchronized void onFailed(
+        UrlRequest request, UrlResponseInfo info, CronetException error) {
+      if (request != currentUrlRequest) {
+        return;
+      }
+      if (error instanceof NetworkException
+          && ((NetworkException) error).getErrorCode()
+              == NetworkException.ERROR_HOSTNAME_NOT_RESOLVED) {
+        exception = new UnknownHostException();
+      } else {
+        exception = error;
+      }
+      operation.open();
+    }
+  }
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
index d6237fc988..d832e4625d 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.cronet;
 
-import com.google.android.exoplayer2.upstream.DataSource;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
@@ -46,7 +46,7 @@
   private final CronetEngineWrapper cronetEngineWrapper;
   private final Executor executor;
   private final Predicate<String> contentTypePredicate;
-  private final TransferListener<? super DataSource> transferListener;
+  private final @Nullable TransferListener transferListener;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
@@ -54,26 +54,176 @@
 
   /**
    * Constructs a CronetDataSourceFactory.
-   * <p>
-   * If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, the provided
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, the provided
    * fallback {@link HttpDataSource.Factory} will be used instead.
    *
-   * Sets {@link CronetDataSource#DEFAULT_CONNECT_TIMEOUT_MILLIS} as the connection timeout, {@link
-   * CronetDataSource#DEFAULT_READ_TIMEOUT_MILLIS} as the read timeout and disables
+   * <p>Sets {@link CronetDataSource#DEFAULT_CONNECT_TIMEOUT_MILLIS} as the connection timeout,
+   * {@link CronetDataSource#DEFAULT_READ_TIMEOUT_MILLIS} as the read timeout and disables
+   * cross-protocol redirects.
+   *
+   * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
+   * @param fallbackFactory A {@link HttpDataSource.Factory} which is used as a fallback in case no
+   *     suitable CronetEngine can be build.
+   */
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      HttpDataSource.Factory fallbackFactory) {
+    this(
+        cronetEngineWrapper,
+        executor,
+        contentTypePredicate,
+        /* transferListener= */ null,
+        DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS,
+        false,
+        fallbackFactory);
+  }
+
+  /**
+   * Constructs a CronetDataSourceFactory.
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, a {@link
+   * DefaultHttpDataSourceFactory} will be used instead.
+   *
+   * <p>Sets {@link CronetDataSource#DEFAULT_CONNECT_TIMEOUT_MILLIS} as the connection timeout,
+   * {@link CronetDataSource#DEFAULT_READ_TIMEOUT_MILLIS} as the read timeout and disables
    * cross-protocol redirects.
    *
    * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
    * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link CronetDataSource#open}.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
+   * @param userAgent A user agent used to create a fallback HttpDataSource if needed.
+   */
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      String userAgent) {
+    this(
+        cronetEngineWrapper,
+        executor,
+        contentTypePredicate,
+        /* transferListener= */ null,
+        DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS,
+        false,
+        new DefaultHttpDataSourceFactory(
+            userAgent,
+            /* listener= */ null,
+            DEFAULT_CONNECT_TIMEOUT_MILLIS,
+            DEFAULT_READ_TIMEOUT_MILLIS,
+            false));
+  }
+
+  /**
+   * Constructs a CronetDataSourceFactory.
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, a {@link
+   * DefaultHttpDataSourceFactory} will be used instead.
+   *
+   * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
+   * @param connectTimeoutMs The connection timeout, in milliseconds.
+   * @param readTimeoutMs The read timeout, in milliseconds.
+   * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
+   * @param userAgent A user agent used to create a fallback HttpDataSource if needed.
+   */
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
+      String userAgent) {
+    this(
+        cronetEngineWrapper,
+        executor,
+        contentTypePredicate,
+        /* transferListener= */ null,
+        DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS,
+        resetTimeoutOnRedirects,
+        new DefaultHttpDataSourceFactory(
+            userAgent,
+            /* listener= */ null,
+            connectTimeoutMs,
+            readTimeoutMs,
+            resetTimeoutOnRedirects));
+  }
+
+  /**
+   * Constructs a CronetDataSourceFactory.
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, the provided
+   * fallback {@link HttpDataSource.Factory} will be used instead.
+   *
+   * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
+   * @param connectTimeoutMs The connection timeout, in milliseconds.
+   * @param readTimeoutMs The read timeout, in milliseconds.
+   * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
+   * @param fallbackFactory A {@link HttpDataSource.Factory} which is used as a fallback in case no
+   *     suitable CronetEngine can be build.
+   */
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
+      HttpDataSource.Factory fallbackFactory) {
+    this(
+        cronetEngineWrapper,
+        executor,
+        contentTypePredicate,
+        /* transferListener= */ null,
+        connectTimeoutMs,
+        readTimeoutMs,
+        resetTimeoutOnRedirects,
+        fallbackFactory);
+  }
+
+  /**
+   * Constructs a CronetDataSourceFactory.
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, the provided
+   * fallback {@link HttpDataSource.Factory} will be used instead.
+   *
+   * <p>Sets {@link CronetDataSource#DEFAULT_CONNECT_TIMEOUT_MILLIS} as the connection timeout,
+   * {@link CronetDataSource#DEFAULT_READ_TIMEOUT_MILLIS} as the read timeout and disables
+   * cross-protocol redirects.
+   *
+   * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
    * @param transferListener An optional listener.
-   * @param fallbackFactory A {@link HttpDataSource.Factory} which is used as a fallback in case
-   *     no suitable CronetEngine can be build.
+   * @param fallbackFactory A {@link HttpDataSource.Factory} which is used as a fallback in case no
+   *     suitable CronetEngine can be build.
    */
-  public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
-      Executor executor, Predicate<String> contentTypePredicate,
-      TransferListener<? super DataSource> transferListener,
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      @Nullable TransferListener transferListener,
       HttpDataSource.Factory fallbackFactory) {
     this(cronetEngineWrapper, executor, contentTypePredicate, transferListener,
         DEFAULT_CONNECT_TIMEOUT_MILLIS, DEFAULT_READ_TIMEOUT_MILLIS, false, fallbackFactory);
@@ -81,25 +231,28 @@ public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
 
   /**
    * Constructs a CronetDataSourceFactory.
-   * <p>
-   * If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, a
-   * {@link DefaultHttpDataSourceFactory} will be used instead.
    *
-   * Sets {@link CronetDataSource#DEFAULT_CONNECT_TIMEOUT_MILLIS} as the connection timeout, {@link
-   * CronetDataSource#DEFAULT_READ_TIMEOUT_MILLIS} as the read timeout and disables
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, a {@link
+   * DefaultHttpDataSourceFactory} will be used instead.
+   *
+   * <p>Sets {@link CronetDataSource#DEFAULT_CONNECT_TIMEOUT_MILLIS} as the connection timeout,
+   * {@link CronetDataSource#DEFAULT_READ_TIMEOUT_MILLIS} as the read timeout and disables
    * cross-protocol redirects.
    *
    * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
    * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link CronetDataSource#open}.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
    * @param transferListener An optional listener.
    * @param userAgent A user agent used to create a fallback HttpDataSource if needed.
    */
-  public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
-      Executor executor, Predicate<String> contentTypePredicate,
-      TransferListener<? super DataSource> transferListener, String userAgent) {
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      @Nullable TransferListener transferListener,
+      String userAgent) {
     this(cronetEngineWrapper, executor, contentTypePredicate, transferListener,
         DEFAULT_CONNECT_TIMEOUT_MILLIS, DEFAULT_READ_TIMEOUT_MILLIS, false,
         new DefaultHttpDataSourceFactory(userAgent, transferListener,
@@ -108,25 +261,30 @@ public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
 
   /**
    * Constructs a CronetDataSourceFactory.
-   * <p>
-   * If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, a
-   * {@link DefaultHttpDataSourceFactory} will be used instead.
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, a {@link
+   * DefaultHttpDataSourceFactory} will be used instead.
    *
    * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
    * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link CronetDataSource#open}.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
    * @param transferListener An optional listener.
    * @param connectTimeoutMs The connection timeout, in milliseconds.
    * @param readTimeoutMs The read timeout, in milliseconds.
    * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
    * @param userAgent A user agent used to create a fallback HttpDataSource if needed.
    */
-  public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
-      Executor executor, Predicate<String> contentTypePredicate,
-      TransferListener<? super DataSource> transferListener, int connectTimeoutMs,
-      int readTimeoutMs, boolean resetTimeoutOnRedirects, String userAgent) {
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      @Nullable TransferListener transferListener,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
+      String userAgent) {
     this(cronetEngineWrapper, executor, contentTypePredicate, transferListener,
         DEFAULT_CONNECT_TIMEOUT_MILLIS, DEFAULT_READ_TIMEOUT_MILLIS, resetTimeoutOnRedirects,
         new DefaultHttpDataSourceFactory(userAgent, transferListener, connectTimeoutMs,
@@ -135,26 +293,30 @@ public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
 
   /**
    * Constructs a CronetDataSourceFactory.
-   * <p>
-   * If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, the provided
+   *
+   * <p>If the {@link CronetEngineWrapper} fails to provide a {@link CronetEngine}, the provided
    * fallback {@link HttpDataSource.Factory} will be used instead.
    *
    * @param cronetEngineWrapper A {@link CronetEngineWrapper}.
    * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then an {@link InvalidContentTypeException} is thrown from
-   *     {@link CronetDataSource#open}.
+   *     predicate then an {@link InvalidContentTypeException} is thrown from {@link
+   *     CronetDataSource#open}.
    * @param transferListener An optional listener.
    * @param connectTimeoutMs The connection timeout, in milliseconds.
    * @param readTimeoutMs The read timeout, in milliseconds.
    * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
-   * @param fallbackFactory A {@link HttpDataSource.Factory} which is used as a fallback in case
-   *     no suitable CronetEngine can be build.
+   * @param fallbackFactory A {@link HttpDataSource.Factory} which is used as a fallback in case no
+   *     suitable CronetEngine can be build.
    */
-  public CronetDataSourceFactory(CronetEngineWrapper cronetEngineWrapper,
-      Executor executor, Predicate<String> contentTypePredicate,
-      TransferListener<? super DataSource> transferListener, int connectTimeoutMs,
-      int readTimeoutMs, boolean resetTimeoutOnRedirects,
+  public CronetDataSourceFactory(
+      CronetEngineWrapper cronetEngineWrapper,
+      Executor executor,
+      Predicate<String> contentTypePredicate,
+      @Nullable TransferListener transferListener,
+      int connectTimeoutMs,
+      int readTimeoutMs,
+      boolean resetTimeoutOnRedirects,
       HttpDataSource.Factory fallbackFactory) {
     this.cronetEngineWrapper = cronetEngineWrapper;
     this.executor = executor;
@@ -173,8 +335,19 @@ protected HttpDataSource createDataSourceInternal(HttpDataSource.RequestProperti
     if (cronetEngine == null) {
       return fallbackFactory.createDataSource();
     }
-    return new CronetDataSource(cronetEngine, executor, contentTypePredicate, transferListener,
-        connectTimeoutMs, readTimeoutMs, resetTimeoutOnRedirects, defaultRequestProperties);
+    CronetDataSource dataSource =
+        new CronetDataSource(
+            cronetEngine,
+            executor,
+            contentTypePredicate,
+            connectTimeoutMs,
+            readTimeoutMs,
+            resetTimeoutOnRedirects,
+            defaultRequestProperties);
+    if (transferListener != null) {
+      dataSource.addTransferListener(transferListener);
+    }
+    return dataSource;
   }
 
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
index db1394c1d6..829b53f863 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
@@ -17,7 +17,9 @@
 
 import android.content.Context;
 import android.support.annotation.IntDef;
-import android.util.Log;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Field;
@@ -39,8 +41,10 @@
   private final @CronetEngineSource int cronetEngineSource;
 
   /**
-   * Source of {@link CronetEngine}.
+   * Source of {@link CronetEngine}. One of {@link #SOURCE_NATIVE}, {@link #SOURCE_GMS}, {@link
+   * #SOURCE_UNKNOWN}, {@link #SOURCE_USER_PROVIDED} or {@link #SOURCE_UNAVAILABLE}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({SOURCE_NATIVE, SOURCE_GMS, SOURCE_UNKNOWN, SOURCE_USER_PROVIDED, SOURCE_UNAVAILABLE})
   public @interface CronetEngineSource {}
@@ -158,6 +162,8 @@ public CronetEngineWrapper(CronetEngine cronetEngine) {
     private final String gmsCoreCronetName;
     private final boolean preferGMSCoreCronet;
 
+    // Multi-catch can only be used for API 19+ in this case.
+    @SuppressWarnings("UseMultiCatch")
     public CronetProviderComparator(boolean preferGMSCoreCronet) {
       // GMSCore CronetProvider classes are only available in some configurations.
       // Thus, we use reflection to copy static name.
@@ -218,8 +224,8 @@ private static int compareVersionStrings(String versionLeft, String versionRight
       if (versionLeft == null || versionRight == null) {
         return 0;
       }
-      String[] versionStringsLeft = versionLeft.split("\\.");
-      String[] versionStringsRight = versionRight.split("\\.");
+      String[] versionStringsLeft = Util.split(versionLeft, "\\.");
+      String[] versionStringsRight = Util.split(versionRight, "\\.");
       int minLength = Math.min(versionStringsLeft.length, versionStringsRight.length);
       for (int i = 0; i < minLength; i++) {
         if (!versionStringsLeft[i].equals(versionStringsRight[i])) {
diff --git a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
index 291e73fcc1..117518a1eb 100644
--- a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
+++ b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
@@ -60,7 +60,7 @@ public void testReadFullBuffer() throws IOException {
 
   @Test
   public void testReadPartialBuffer() throws IOException {
-    byte[] firstHalf = Arrays.copyOfRange(TEST_DATA, 0, TEST_DATA.length / 2);
+    byte[] firstHalf = Arrays.copyOf(TEST_DATA, TEST_DATA.length / 2);
     byte[] secondHalf = Arrays.copyOfRange(TEST_DATA, TEST_DATA.length / 2, TEST_DATA.length);
     byteBuffer = ByteBuffer.allocate(TEST_DATA.length / 2);
     // Read half of the data.
diff --git a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index 4e990cd027..7d47b0da64 100644
--- a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -24,7 +24,6 @@
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -39,6 +38,7 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Predicate;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -51,6 +51,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import org.chromium.net.CronetEngine;
 import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
@@ -61,10 +62,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.shadows.ShadowSystemClock;
 
 /** Tests for {@link CronetDataSource}. */
 @RunWith(RobolectricTestRunner.class)
@@ -74,20 +72,21 @@
   private static final int TEST_READ_TIMEOUT_MS = 100;
   private static final String TEST_URL = "http://google.com";
   private static final String TEST_CONTENT_TYPE = "test/test";
-  private static final byte[] TEST_POST_BODY = "test post body".getBytes();
+  private static final byte[] TEST_POST_BODY = Util.getUtf8Bytes("test post body");
   private static final long TEST_CONTENT_LENGTH = 16000L;
   private static final int TEST_CONNECTION_STATUS = 5;
   private static final int TEST_INVALID_CONNECTION_STATUS = -1;
 
   private DataSpec testDataSpec;
   private DataSpec testPostDataSpec;
+  private DataSpec testHeadDataSpec;
   private Map<String, String> testResponseHeader;
   private UrlResponseInfo testUrlResponseInfo;
 
   @Mock private UrlRequest.Builder mockUrlRequestBuilder;
   @Mock private UrlRequest mockUrlRequest;
   @Mock private Predicate<String> mockContentTypePredicate;
-  @Mock private TransferListener<CronetDataSource> mockTransferListener;
+  @Mock private TransferListener mockTransferListener;
   @Mock private Executor mockExecutor;
   @Mock private NetworkException mockNetworkException;
   @Mock private CronetEngine mockCronetEngine;
@@ -99,18 +98,17 @@
   public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     dataSourceUnderTest =
-        spy(
-            new CronetDataSource(
-                mockCronetEngine,
-                mockExecutor,
-                mockContentTypePredicate,
-                mockTransferListener,
-                TEST_CONNECT_TIMEOUT_MS,
-                TEST_READ_TIMEOUT_MS,
-                true, // resetTimeoutOnRedirects
-                Clock.DEFAULT,
-                null,
-                false));
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            Clock.DEFAULT,
+            null,
+            false);
+    dataSourceUnderTest.addTransferListener(mockTransferListener);
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
     when(mockCronetEngine.newUrlRequestBuilder(
             anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
@@ -122,6 +120,9 @@ public void setUp() throws Exception {
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, C.LENGTH_UNSET, null);
     testPostDataSpec =
         new DataSpec(Uri.parse(TEST_URL), TEST_POST_BODY, 0, 0, C.LENGTH_UNSET, null, 0);
+    testHeadDataSpec =
+        new DataSpec(
+            Uri.parse(TEST_URL), DataSpec.HTTP_METHOD_HEAD, null, 0, 0, C.LENGTH_UNSET, null, 0);
     testResponseHeader = new HashMap<>();
     testResponseHeader.put("Content-Type", TEST_CONTENT_TYPE);
     // This value can be anything since the DataSpec is unset.
@@ -168,15 +169,13 @@ public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
     final UrlRequest mockUrlRequest2 = mock(UrlRequest.class);
     when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest2);
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                // Invoke the callback for the previous request.
-                dataSourceUnderTest.onFailed(
-                    mockUrlRequest, testUrlResponseInfo, mockNetworkException);
-                dataSourceUnderTest.onResponseStarted(mockUrlRequest2, testUrlResponseInfo);
-                return null;
-              }
+            invocation -> {
+              // Invoke the callback for the previous request.
+              dataSourceUnderTest.urlRequestCallback.onFailed(
+                  mockUrlRequest, testUrlResponseInfo, mockNetworkException);
+              dataSourceUnderTest.urlRequestCallback.onResponseStarted(
+                  mockUrlRequest2, testUrlResponseInfo);
+              return null;
             })
         .when(mockUrlRequest2)
         .start();
@@ -213,7 +212,8 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
   public void testRequestOpen() throws HttpDataSourceException {
     mockResponseStartSuccess();
     assertThat(dataSourceUnderTest.open(testDataSpec)).isEqualTo(TEST_CONTENT_LENGTH);
-    verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testDataSpec);
+    verify(mockTransferListener)
+        .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
   }
 
   @Test
@@ -225,7 +225,8 @@ public void testRequestOpenGzippedCompressedReturnsDataSpecLength()
     mockResponseStartSuccess();
 
     assertThat(dataSourceUnderTest.open(testDataSpec)).isEqualTo(5000 /* contentLength */);
-    verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testDataSpec);
+    verify(mockTransferListener)
+        .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
   }
 
   @Test
@@ -239,7 +240,8 @@ public void testRequestOpenFail() {
       // Check for connection not automatically closed.
       assertThat(e.getCause() instanceof UnknownHostException).isFalse();
       verify(mockUrlRequest, never()).cancel();
-      verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+      verify(mockTransferListener, never())
+          .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
     }
   }
 
@@ -256,7 +258,8 @@ public void testRequestOpenFailDueToDnsFailure() {
       // Check for connection not automatically closed.
       assertThat(e.getCause() instanceof UnknownHostException).isTrue();
       verify(mockUrlRequest, never()).cancel();
-      verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+      verify(mockTransferListener, never())
+          .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
     }
   }
 
@@ -272,7 +275,8 @@ public void testRequestOpenValidatesStatusCode() {
       assertThat(e instanceof HttpDataSource.InvalidResponseCodeException).isTrue();
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+      verify(mockTransferListener, never())
+          .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
     }
   }
 
@@ -298,7 +302,8 @@ public void testPostRequestOpen() throws HttpDataSourceException {
 
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
     assertThat(dataSourceUnderTest.open(testPostDataSpec)).isEqualTo(TEST_CONTENT_LENGTH);
-    verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testPostDataSpec);
+    verify(mockTransferListener)
+        .onTransferStart(dataSourceUnderTest, testPostDataSpec, /* isNetwork= */ true);
   }
 
   @Test
@@ -327,6 +332,15 @@ public void testPostRequestOpenRejects307Redirects() {
     }
   }
 
+  @Test
+  public void testHeadRequestOpen() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    dataSourceUnderTest.open(testHeadDataSpec);
+    verify(mockTransferListener)
+        .onTransferStart(dataSourceUnderTest, testHeadDataSpec, /* isNetwork= */ true);
+    dataSourceUnderTest.close();
+  }
+
   @Test
   public void testRequestReadTwice() throws HttpDataSourceException {
     mockResponseStartSuccess();
@@ -346,7 +360,8 @@ public void testRequestReadTwice() throws HttpDataSourceException {
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
-    verify(mockTransferListener, times(2)).onBytesTransferred(dataSourceUnderTest, 8);
+    verify(mockTransferListener, times(2))
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 8);
   }
 
   @Test
@@ -386,7 +401,8 @@ public void testReadWithOffset() throws HttpDataSourceException {
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
     assertThat(bytesRead).isEqualTo(8);
     assertThat(returnedBuffer).isEqualTo(prefixZeros(buildTestDataArray(0, 8), 16));
-    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 8);
+    verify(mockTransferListener)
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 8);
   }
 
   @Test
@@ -402,7 +418,8 @@ public void testRangeRequestWith206Response() throws HttpDataSourceException {
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
     assertThat(bytesRead).isEqualTo(16);
     assertThat(returnedBuffer).isEqualTo(buildTestDataArray(1000, 16));
-    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
+    verify(mockTransferListener)
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 16);
   }
 
   @Test
@@ -418,7 +435,8 @@ public void testRangeRequestWith200Response() throws HttpDataSourceException {
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
     assertThat(bytesRead).isEqualTo(16);
     assertThat(returnedBuffer).isEqualTo(buildTestDataArray(1000, 16));
-    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
+    verify(mockTransferListener)
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 16);
   }
 
   @Test
@@ -433,7 +451,8 @@ public void testReadWithUnsetLength() throws HttpDataSourceException {
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
     assertThat(returnedBuffer).isEqualTo(prefixZeros(buildTestDataArray(0, 8), 16));
     assertThat(bytesRead).isEqualTo(8);
-    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 8);
+    verify(mockTransferListener)
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 8);
   }
 
   @Test
@@ -447,7 +466,8 @@ public void testReadReturnsWhatItCan() throws HttpDataSourceException {
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 24);
     assertThat(returnedBuffer).isEqualTo(suffixZeros(buildTestDataArray(0, 16), 24));
     assertThat(bytesRead).isEqualTo(16);
-    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
+    verify(mockTransferListener)
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 16);
   }
 
   @Test
@@ -464,7 +484,8 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
     assertThat(bytesRead).isEqualTo(8);
 
     dataSourceUnderTest.close();
-    verify(mockTransferListener).onTransferEnd(dataSourceUnderTest);
+    verify(mockTransferListener)
+        .onTransferEnd(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
 
     try {
       bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
@@ -505,9 +526,12 @@ public void testOverread() throws HttpDataSourceException {
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
-    verify(mockTransferListener, times(1)).onBytesTransferred(dataSourceUnderTest, 8);
-    verify(mockTransferListener, times(1)).onBytesTransferred(dataSourceUnderTest, 6);
-    verify(mockTransferListener, times(1)).onBytesTransferred(dataSourceUnderTest, 2);
+    verify(mockTransferListener, times(1))
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 8);
+    verify(mockTransferListener, times(1))
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 6);
+    verify(mockTransferListener, times(1))
+        .onBytesTransferred(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, 2);
 
     // Now we already returned the 16 bytes initially asked.
     // Try to read again even though all requested 16 bytes are already returned.
@@ -518,7 +542,8 @@ public void testOverread() throws HttpDataSourceException {
     assertThat(returnedBuffer).isEqualTo(new byte[16]);
     // C.RESULT_END_OF_INPUT should not be reported though the TransferListener.
     verify(mockTransferListener, never())
-        .onBytesTransferred(dataSourceUnderTest, C.RESULT_END_OF_INPUT);
+        .onBytesTransferred(
+            dataSourceUnderTest, testDataSpec, /* isNetwork= */ true, C.RESULT_END_OF_INPUT);
     // There should still be only one call to read on cronet.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
     // Check for connection not automatically closed.
@@ -553,13 +578,14 @@ public void run() {
     // We should still be trying to open.
     assertNotCountedDown(timedOutLatch);
     // We should still be trying to open as we approach the timeout.
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    SystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
     assertNotCountedDown(timedOutLatch);
     // Now we timeout.
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS + 10);
+    SystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS + 10);
     timedOutLatch.await();
 
-    verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+    verify(mockTransferListener, never())
+        .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
   }
 
   @Test
@@ -591,29 +617,32 @@ public void run() {
     // We should still be trying to open.
     assertNotCountedDown(timedOutLatch);
     // We should still be trying to open as we approach the timeout.
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    SystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
     assertNotCountedDown(timedOutLatch);
     // Now we interrupt.
     thread.interrupt();
     timedOutLatch.await();
 
-    verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+    verify(mockTransferListener, never())
+        .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
   }
 
   @Test
-  public void testConnectResponseBeforeTimeout() throws InterruptedException {
+  public void testConnectResponseBeforeTimeout() throws Exception {
     long startTimeMs = SystemClock.elapsedRealtime();
     final ConditionVariable startCondition = buildUrlRequestStartedCondition();
     final CountDownLatch openLatch = new CountDownLatch(1);
 
+    AtomicReference<Exception> exceptionOnTestThread = new AtomicReference<>();
     new Thread() {
       @Override
       public void run() {
         try {
           dataSourceUnderTest.open(testDataSpec);
-          openLatch.countDown();
         } catch (HttpDataSourceException e) {
-          fail();
+          exceptionOnTestThread.set(e);
+        } finally {
+          openLatch.countDown();
         }
       }
     }.start();
@@ -622,15 +651,16 @@ public void run() {
     // We should still be trying to open.
     assertNotCountedDown(openLatch);
     // We should still be trying to open as we approach the timeout.
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    SystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
     assertNotCountedDown(openLatch);
     // The response arrives just in time.
-    dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
+    dataSourceUnderTest.urlRequestCallback.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
     openLatch.await();
+    assertThat(exceptionOnTestThread.get()).isNull();
   }
 
   @Test
-  public void testRedirectIncreasesConnectionTimeout() throws InterruptedException {
+  public void testRedirectIncreasesConnectionTimeout() throws Exception {
     long startTimeMs = SystemClock.elapsedRealtime();
     final ConditionVariable startCondition = buildUrlRequestStartedCondition();
     final CountDownLatch timedOutLatch = new CountDownLatch(1);
@@ -656,29 +686,30 @@ public void run() {
     // We should still be trying to open.
     assertNotCountedDown(timedOutLatch);
     // We should still be trying to open as we approach the timeout.
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    SystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
     assertNotCountedDown(timedOutLatch);
     // A redirect arrives just in time.
-    dataSourceUnderTest.onRedirectReceived(
+    dataSourceUnderTest.urlRequestCallback.onRedirectReceived(
         mockUrlRequest, testUrlResponseInfo, "RandomRedirectedUrl1");
 
     long newTimeoutMs = 2 * TEST_CONNECT_TIMEOUT_MS - 1;
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs - 1);
+    SystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs - 1);
     // We should still be trying to open as we approach the new timeout.
     assertNotCountedDown(timedOutLatch);
     // A redirect arrives just in time.
-    dataSourceUnderTest.onRedirectReceived(
+    dataSourceUnderTest.urlRequestCallback.onRedirectReceived(
         mockUrlRequest, testUrlResponseInfo, "RandomRedirectedUrl2");
 
     newTimeoutMs = 3 * TEST_CONNECT_TIMEOUT_MS - 2;
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs - 1);
+    SystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs - 1);
     // We should still be trying to open as we approach the new timeout.
     assertNotCountedDown(timedOutLatch);
     // Now we timeout.
-    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs + 10);
+    SystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs + 10);
     timedOutLatch.await();
 
-    verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+    verify(mockTransferListener, never())
+        .onTransferStart(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
     assertThat(openExceptions.get()).isEqualTo(1);
   }
 
@@ -700,18 +731,17 @@ public void testRedirectParseAndAttachCookie_dataSourceDoesNotHandleSetCookie_fo
       testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeaders()
           throws HttpDataSourceException {
     dataSourceUnderTest =
-        spy(
-            new CronetDataSource(
-                mockCronetEngine,
-                mockExecutor,
-                mockContentTypePredicate,
-                mockTransferListener,
-                TEST_CONNECT_TIMEOUT_MS,
-                TEST_READ_TIMEOUT_MS,
-                true, // resetTimeoutOnRedirects
-                Clock.DEFAULT,
-                null,
-                true));
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            Clock.DEFAULT,
+            null,
+            true);
+    dataSourceUnderTest.addTransferListener(mockTransferListener);
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
 
     mockSingleRedirectSuccess();
@@ -732,18 +762,17 @@ public void testRedirectParseAndAttachCookie_dataSourceDoesNotHandleSetCookie_fo
           throws HttpDataSourceException {
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
     dataSourceUnderTest =
-        spy(
-            new CronetDataSource(
-                mockCronetEngine,
-                mockExecutor,
-                mockContentTypePredicate,
-                mockTransferListener,
-                TEST_CONNECT_TIMEOUT_MS,
-                TEST_READ_TIMEOUT_MS,
-                true, // resetTimeoutOnRedirects
-                Clock.DEFAULT,
-                null,
-                true));
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            Clock.DEFAULT,
+            null,
+            true);
+    dataSourceUnderTest.addTransferListener(mockTransferListener);
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
 
     mockSingleRedirectSuccess();
@@ -772,18 +801,17 @@ public void testRedirectNoSetCookieFollowsRedirect() throws HttpDataSourceExcept
   public void testRedirectNoSetCookieFollowsRedirect_dataSourceHandlesSetCookie()
       throws HttpDataSourceException {
     dataSourceUnderTest =
-        spy(
-            new CronetDataSource(
-                mockCronetEngine,
-                mockExecutor,
-                mockContentTypePredicate,
-                mockTransferListener,
-                TEST_CONNECT_TIMEOUT_MS,
-                TEST_READ_TIMEOUT_MS,
-                true, // resetTimeoutOnRedirects
-                Clock.DEFAULT,
-                null,
-                true));
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            Clock.DEFAULT,
+            null,
+            true);
+    dataSourceUnderTest.addTransferListener(mockTransferListener);
     mockSingleRedirectSuccess();
     mockFollowRedirectSuccess();
 
@@ -800,7 +828,7 @@ public void testExceptionFromTransferListener() throws HttpDataSourceException {
     // the subsequent open() call succeeds.
     doThrow(new NullPointerException())
         .when(mockTransferListener)
-        .onTransferEnd(dataSourceUnderTest);
+        .onTransferEnd(dataSourceUnderTest, testDataSpec, /* isNetwork= */ true);
     dataSourceUnderTest.open(testDataSpec);
     try {
       dataSourceUnderTest.close();
@@ -871,14 +899,11 @@ public void testAllowDirectExecutor() throws HttpDataSourceException {
 
   private void mockStatusResponse() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                UrlRequest.StatusListener statusListener =
-                    (UrlRequest.StatusListener) invocation.getArguments()[0];
-                statusListener.onStatus(TEST_CONNECTION_STATUS);
-                return null;
-              }
+            invocation -> {
+              UrlRequest.StatusListener statusListener =
+                  (UrlRequest.StatusListener) invocation.getArguments()[0];
+              statusListener.onStatus(TEST_CONNECTION_STATUS);
+              return null;
             })
         .when(mockUrlRequest)
         .getStatus(any(UrlRequest.StatusListener.class));
@@ -886,12 +911,10 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   private void mockResponseStartSuccess() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
-                return null;
-              }
+            invocation -> {
+              dataSourceUnderTest.urlRequestCallback.onResponseStarted(
+                  mockUrlRequest, testUrlResponseInfo);
+              return null;
             })
         .when(mockUrlRequest)
         .start();
@@ -899,15 +922,12 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   private void mockResponseStartRedirect() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                dataSourceUnderTest.onRedirectReceived(
-                    mockUrlRequest,
-                    createUrlResponseInfo(307), // statusCode
-                    "http://redirect.location.com");
-                return null;
-              }
+            invocation -> {
+              dataSourceUnderTest.urlRequestCallback.onRedirectReceived(
+                  mockUrlRequest,
+                  createUrlResponseInfo(307), // statusCode
+                  "http://redirect.location.com");
+              return null;
             })
         .when(mockUrlRequest)
         .start();
@@ -915,20 +935,18 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   private void mockSingleRedirectSuccess() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                if (!redirectCalled) {
-                  redirectCalled = true;
-                  dataSourceUnderTest.onRedirectReceived(
-                      mockUrlRequest,
-                      createUrlResponseInfoWithUrl("http://example.com/video", 300),
-                      "http://example.com/video/redirect");
-                } else {
-                  dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
-                }
-                return null;
+            invocation -> {
+              if (!redirectCalled) {
+                redirectCalled = true;
+                dataSourceUnderTest.urlRequestCallback.onRedirectReceived(
+                    mockUrlRequest,
+                    createUrlResponseInfoWithUrl("http://example.com/video", 300),
+                    "http://example.com/video/redirect");
+              } else {
+                dataSourceUnderTest.urlRequestCallback.onResponseStarted(
+                    mockUrlRequest, testUrlResponseInfo);
               }
+              return null;
             })
         .when(mockUrlRequest)
         .start();
@@ -936,12 +954,10 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   private void mockFollowRedirectSuccess() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
-                return null;
-              }
+            invocation -> {
+              dataSourceUnderTest.urlRequestCallback.onResponseStarted(
+                  mockUrlRequest, testUrlResponseInfo);
+              return null;
             })
         .when(mockUrlRequest)
         .followRedirect();
@@ -949,15 +965,12 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   private void mockResponseStartFailure() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                dataSourceUnderTest.onFailed(
-                    mockUrlRequest,
-                    createUrlResponseInfo(500), // statusCode
-                    mockNetworkException);
-                return null;
-              }
+            invocation -> {
+              dataSourceUnderTest.urlRequestCallback.onFailed(
+                  mockUrlRequest,
+                  createUrlResponseInfo(500), // statusCode
+                  mockNetworkException);
+              return null;
             })
         .when(mockUrlRequest)
         .start();
@@ -966,22 +979,20 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
   private void mockReadSuccess(int position, int length) {
     final int[] positionAndRemaining = new int[] {position, length};
     doAnswer(
-            new Answer<Void>() {
-              @Override
-              public Void answer(InvocationOnMock invocation) throws Throwable {
-                if (positionAndRemaining[1] == 0) {
-                  dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
-                } else {
-                  ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
-                  int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
-                  inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
-                  positionAndRemaining[0] += readLength;
-                  positionAndRemaining[1] -= readLength;
-                  dataSourceUnderTest.onReadCompleted(
-                      mockUrlRequest, testUrlResponseInfo, inputBuffer);
-                }
-                return null;
+            invocation -> {
+              if (positionAndRemaining[1] == 0) {
+                dataSourceUnderTest.urlRequestCallback.onSucceeded(
+                    mockUrlRequest, testUrlResponseInfo);
+              } else {
+                ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
+                int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
+                inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
+                positionAndRemaining[0] += readLength;
+                positionAndRemaining[1] -= readLength;
+                dataSourceUnderTest.urlRequestCallback.onReadCompleted(
+                    mockUrlRequest, testUrlResponseInfo, inputBuffer);
               }
+              return null;
             })
         .when(mockUrlRequest)
         .read(any(ByteBuffer.class));
@@ -989,15 +1000,12 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
 
   private void mockReadFailure() {
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                dataSourceUnderTest.onFailed(
-                    mockUrlRequest,
-                    createUrlResponseInfo(500), // statusCode
-                    mockNetworkException);
-                return null;
-              }
+            invocation -> {
+              dataSourceUnderTest.urlRequestCallback.onFailed(
+                  mockUrlRequest,
+                  createUrlResponseInfo(500), // statusCode
+                  mockNetworkException);
+              return null;
             })
         .when(mockUrlRequest)
         .read(any(ByteBuffer.class));
@@ -1006,12 +1014,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
   private ConditionVariable buildReadStartedCondition() {
     final ConditionVariable startedCondition = new ConditionVariable();
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                startedCondition.open();
-                return null;
-              }
+            invocation -> {
+              startedCondition.open();
+              return null;
             })
         .when(mockUrlRequest)
         .read(any(ByteBuffer.class));
@@ -1021,12 +1026,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
   private ConditionVariable buildUrlRequestStartedCondition() {
     final ConditionVariable startedCondition = new ConditionVariable();
     doAnswer(
-            new Answer<Object>() {
-              @Override
-              public Object answer(InvocationOnMock invocation) throws Throwable {
-                startedCondition.open();
-                return null;
-              }
+            invocation -> {
+              startedCondition.open();
+              return null;
             })
         .when(mockUrlRequest)
         .start();
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index d5a37db013..52dacf8166 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -46,7 +46,7 @@ HOST_PLATFORM="linux-x86_64"
   be supported. See the [Supported formats][] page for more details of the
   available flags.
 
-For example, to fetch and build for armeabi-v7a,
+For example, to fetch and build FFmpeg release 4.0 for armeabi-v7a,
   arm64-v8a and x86 on Linux x86_64:
 
 ```
@@ -71,7 +71,7 @@ COMMON_OPTIONS="\
     " && \
 cd "${FFMPEG_EXT_PATH}/jni" && \
 (git -C ffmpeg pull || git clone git://source.ffmpeg.org/ffmpeg ffmpeg) && \
-cd ffmpeg && \
+cd ffmpeg && git checkout release/4.0 && \
 ./configure \
     --libdir=android-libs/armeabi-v7a \
     --arch=arm \
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index e2d3a08e36..1630b6f775 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
@@ -32,6 +37,8 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
 }
 
 ext {
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index d7687e42ac..f0b30baa8a 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.ffmpeg;
 
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -26,29 +27,27 @@
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Collections;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
  * Decodes and renders audio using FFmpeg.
  */
 public final class FfmpegAudioRenderer extends SimpleDecoderAudioRenderer {
 
-  /**
-   * The number of input and output buffers.
-   */
+  /** The number of input and output buffers. */
   private static final int NUM_BUFFERS = 16;
-  /**
-   * The initial input buffer size. Input buffers are reallocated dynamically if this value is
-   * insufficient.
-   */
-  private static final int INITIAL_INPUT_BUFFER_SIZE = 960 * 6;
+  /** The default input buffer size. */
+  private static final int DEFAULT_INPUT_BUFFER_SIZE = 960 * 6;
 
   private final boolean enableFloatOutput;
 
-  private FfmpegDecoder decoder;
+  private @MonotonicNonNull FfmpegDecoder decoder;
 
   public FfmpegAudioRenderer() {
-    this(null, null);
+    this(/* eventHandler= */ null, /* eventListener= */ null);
   }
 
   /**
@@ -57,9 +56,15 @@ public FfmpegAudioRenderer() {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+  public FfmpegAudioRenderer(
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
       AudioProcessor... audioProcessors) {
-    this(eventHandler, eventListener, new DefaultAudioSink(null, audioProcessors), false);
+    this(
+        eventHandler,
+        eventListener,
+        new DefaultAudioSink(/* audioCapabilities= */ null, audioProcessors),
+        /* enableFloatOutput= */ false);
   }
 
   /**
@@ -72,8 +77,11 @@ public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener even
    *     32-bit float output, any audio processing will be disabled, including playback speed/pitch
    *     adjustment.
    */
-  public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioSink audioSink, boolean enableFloatOutput) {
+  public FfmpegAudioRenderer(
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      AudioSink audioSink,
+      boolean enableFloatOutput) {
     super(
         eventHandler,
         eventListener,
@@ -86,10 +94,11 @@ public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener even
   @Override
   protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
       Format format) {
-    String sampleMimeType = format.sampleMimeType;
-    if (!FfmpegLibrary.isAvailable() || !MimeTypes.isAudio(sampleMimeType)) {
+    Assertions.checkNotNull(format.sampleMimeType);
+    if (!FfmpegLibrary.isAvailable()) {
       return FORMAT_UNSUPPORTED_TYPE;
-    } else if (!FfmpegLibrary.supportsFormat(sampleMimeType) || !isOutputSupported(format)) {
+    } else if (!FfmpegLibrary.supportsFormat(format.sampleMimeType, format.pcmEncoding)
+        || !isOutputSupported(format)) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
@@ -106,26 +115,43 @@ public final int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
   @Override
   protected FfmpegDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
       throws FfmpegDecoderException {
-    decoder = new FfmpegDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
-        format.sampleMimeType, format.initializationData, shouldUseFloatOutput(format));
+    int initialInputBufferSize =
+        format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
+    decoder =
+        new FfmpegDecoder(
+            NUM_BUFFERS, NUM_BUFFERS, initialInputBufferSize, format, shouldUseFloatOutput(format));
     return decoder;
   }
 
   @Override
   public Format getOutputFormat() {
+    Assertions.checkNotNull(decoder);
     int channelCount = decoder.getChannelCount();
     int sampleRate = decoder.getSampleRate();
     @C.PcmEncoding int encoding = decoder.getEncoding();
-    return Format.createAudioSampleFormat(null, MimeTypes.AUDIO_RAW, null, Format.NO_VALUE,
-        Format.NO_VALUE, channelCount, sampleRate, encoding, null, null, 0, null);
+    return Format.createAudioSampleFormat(
+        /* id= */ null,
+        MimeTypes.AUDIO_RAW,
+        /* codecs= */ null,
+        Format.NO_VALUE,
+        Format.NO_VALUE,
+        channelCount,
+        sampleRate,
+        encoding,
+        Collections.emptyList(),
+        /* drmInitData= */ null,
+        /* selectionFlags= */ 0,
+        /* language= */ null);
   }
 
   private boolean isOutputSupported(Format inputFormat) {
-    return shouldUseFloatOutput(inputFormat) || supportsOutputEncoding(C.ENCODING_PCM_16BIT);
+    return shouldUseFloatOutput(inputFormat)
+        || supportsOutput(inputFormat.channelCount, C.ENCODING_PCM_16BIT);
   }
 
   private boolean shouldUseFloatOutput(Format inputFormat) {
-    if (!enableFloatOutput || !supportsOutputEncoding(C.ENCODING_PCM_FLOAT)) {
+    Assertions.checkNotNull(inputFormat.sampleMimeType);
+    if (!enableFloatOutput || !supportsOutput(inputFormat.channelCount, C.ENCODING_PCM_FLOAT)) {
       return false;
     }
     switch (inputFormat.sampleMimeType) {
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 91bd82ab2a..6f3c623f3f 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -15,10 +15,13 @@
  */
 package com.google.android.exoplayer2.ext.ffmpeg;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
@@ -30,13 +33,12 @@
 /* package */ final class FfmpegDecoder extends
     SimpleDecoder<DecoderInputBuffer, SimpleOutputBuffer, FfmpegDecoderException> {
 
-  // Space for 64 ms of 48 kHz 8 channel 16-bit PCM audio.
-  private static final int OUTPUT_BUFFER_SIZE_16BIT = 64 * 48  * 8 * 2;
-  // Space for 64 ms of 48 KhZ 8 channel 32-bit PCM audio.
+  // Output buffer sizes when decoding PCM mu-law streams, which is the maximum FFmpeg outputs.
+  private static final int OUTPUT_BUFFER_SIZE_16BIT = 65536;
   private static final int OUTPUT_BUFFER_SIZE_32BIT = OUTPUT_BUFFER_SIZE_16BIT * 2;
 
   private final String codecName;
-  private final byte[] extraData;
+  private final @Nullable byte[] extraData;
   private final @C.Encoding int encoding;
   private final int outputBufferSize;
 
@@ -45,18 +47,26 @@
   private volatile int channelCount;
   private volatile int sampleRate;
 
-  public FfmpegDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
-      String mimeType, List<byte[]> initializationData, boolean outputFloat)
+  public FfmpegDecoder(
+      int numInputBuffers,
+      int numOutputBuffers,
+      int initialInputBufferSize,
+      Format format,
+      boolean outputFloat)
       throws FfmpegDecoderException {
     super(new DecoderInputBuffer[numInputBuffers], new SimpleOutputBuffer[numOutputBuffers]);
     if (!FfmpegLibrary.isAvailable()) {
       throw new FfmpegDecoderException("Failed to load decoder native libraries.");
     }
-    codecName = FfmpegLibrary.getCodecName(mimeType);
-    extraData = getExtraData(mimeType, initializationData);
+    Assertions.checkNotNull(format.sampleMimeType);
+    codecName =
+        Assertions.checkNotNull(
+            FfmpegLibrary.getCodecName(format.sampleMimeType, format.pcmEncoding));
+    extraData = getExtraData(format.sampleMimeType, format.initializationData);
     encoding = outputFloat ? C.ENCODING_PCM_FLOAT : C.ENCODING_PCM_16BIT;
     outputBufferSize = outputFloat ? OUTPUT_BUFFER_SIZE_32BIT : OUTPUT_BUFFER_SIZE_16BIT;
-    nativeContext = ffmpegInitialize(codecName, extraData, outputFloat);
+    nativeContext =
+        ffmpegInitialize(codecName, extraData, outputFloat, format.sampleRate, format.channelCount);
     if (nativeContext == 0) {
       throw new FfmpegDecoderException("Initialization failed.");
     }
@@ -84,7 +94,7 @@ protected FfmpegDecoderException createUnexpectedDecodeException(Throwable error
   }
 
   @Override
-  protected FfmpegDecoderException decode(
+  protected @Nullable FfmpegDecoderException decode(
       DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
       nativeContext = ffmpegReset(nativeContext, extraData);
@@ -103,6 +113,7 @@ protected FfmpegDecoderException decode(
       channelCount = ffmpegGetChannelCount(nativeContext);
       sampleRate = ffmpegGetSampleRate(nativeContext);
       if (sampleRate == 0 && "alac".equals(codecName)) {
+        Assertions.checkNotNull(extraData);
         // ALAC decoder did not set the sample rate in earlier versions of FFMPEG.
         // See https://trac.ffmpeg.org/ticket/6096
         ParsableByteArray parsableExtraData = new ParsableByteArray(extraData);
@@ -148,7 +159,7 @@ public int getSampleRate() {
    * Returns FFmpeg-compatible codec-specific initialization data ("extra data"), or {@code null} if
    * not required.
    */
-  private static byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
+  private static @Nullable byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
       case MimeTypes.AUDIO_ALAC:
@@ -173,12 +184,20 @@ public int getSampleRate() {
     }
   }
 
-  private native long ffmpegInitialize(String codecName, byte[] extraData, boolean outputFloat);
+  private native long ffmpegInitialize(
+      String codecName,
+      @Nullable byte[] extraData,
+      boolean outputFloat,
+      int rawSampleRate,
+      int rawChannelCount);
+
   private native int ffmpegDecode(long context, ByteBuffer inputData, int inputSize,
       ByteBuffer outputData, int outputSize);
   private native int ffmpegGetChannelCount(long context);
   private native int ffmpegGetSampleRate(long context);
-  private native long ffmpegReset(long context, byte[] extraData);
+
+  private native long ffmpegReset(long context, @Nullable byte[] extraData);
+
   private native void ffmpegRelease(long context);
 
 }
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
index 9b3bbbb6ab..e5018a49b3 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.ext.ffmpeg;
 
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.util.LibraryLoader;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -51,10 +53,8 @@ public static boolean isAvailable() {
     return LOADER.isAvailable();
   }
 
-  /**
-   * Returns the version of the underlying library if available, or null otherwise.
-   */
-  public static String getVersion() {
+  /** Returns the version of the underlying library if available, or null otherwise. */
+  public static @Nullable String getVersion() {
     return isAvailable() ? ffmpegGetVersion() : null;
   }
 
@@ -62,19 +62,21 @@ public static String getVersion() {
    * Returns whether the underlying library supports the specified MIME type.
    *
    * @param mimeType The MIME type to check.
+   * @param encoding The PCM encoding for raw audio.
    */
-  public static boolean supportsFormat(String mimeType) {
+  public static boolean supportsFormat(String mimeType, @C.PcmEncoding int encoding) {
     if (!isAvailable()) {
       return false;
     }
-    String codecName = getCodecName(mimeType);
+    String codecName = getCodecName(mimeType, encoding);
     return codecName != null && ffmpegHasDecoder(codecName);
   }
 
   /**
-   * Returns the name of the FFmpeg decoder that could be used to decode {@code mimeType}.
+   * Returns the name of the FFmpeg decoder that could be used to decode the format, or {@code null}
+   * if it's unsupported.
    */
-  /* package */ static String getCodecName(String mimeType) {
+  /* package */ static @Nullable String getCodecName(String mimeType, @C.PcmEncoding int encoding) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
         return "aac";
@@ -85,6 +87,7 @@ public static boolean supportsFormat(String mimeType) {
       case MimeTypes.AUDIO_AC3:
         return "ac3";
       case MimeTypes.AUDIO_E_AC3:
+      case MimeTypes.AUDIO_E_AC3_JOC:
         return "eac3";
       case MimeTypes.AUDIO_TRUEHD:
         return "truehd";
@@ -103,6 +106,14 @@ public static boolean supportsFormat(String mimeType) {
         return "flac";
       case MimeTypes.AUDIO_ALAC:
         return "alac";
+      case MimeTypes.AUDIO_RAW:
+        if (encoding == C.ENCODING_PCM_MU_LAW) {
+          return "pcm_mulaw";
+        } else if (encoding == C.ENCODING_PCM_A_LAW) {
+          return "pcm_alaw";
+        } else {
+          return null;
+        }
       default:
         return null;
     }
diff --git a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
index d077c819ab..87579ebb9a 100644
--- a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
+++ b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
@@ -27,6 +27,7 @@ extern "C" {
 #endif
 #include <libavcodec/avcodec.h>
 #include <libavresample/avresample.h>
+#include <libavutil/channel_layout.h>
 #include <libavutil/error.h>
 #include <libavutil/opt.h>
 }
@@ -72,8 +73,9 @@ AVCodec *getCodecByName(JNIEnv* env, jstring codecName);
  * provided extraData as initialization data for the decoder if it is non-NULL.
  * Returns the created context.
  */
-AVCodecContext *createContext(JNIEnv *env, AVCodec *codec,
-                              jbyteArray extraData, jboolean outputFloat);
+AVCodecContext *createContext(JNIEnv *env, AVCodec *codec, jbyteArray extraData,
+                              jboolean outputFloat, jint rawSampleRate,
+                              jint rawChannelCount);
 
 /**
  * Decodes the packet into the output buffer, returning the number of bytes
@@ -110,13 +112,14 @@ LIBRARY_FUNC(jboolean, ffmpegHasDecoder, jstring codecName) {
 }
 
 DECODER_FUNC(jlong, ffmpegInitialize, jstring codecName, jbyteArray extraData,
-    jboolean outputFloat) {
+             jboolean outputFloat, jint rawSampleRate, jint rawChannelCount) {
   AVCodec *codec = getCodecByName(env, codecName);
   if (!codec) {
     LOGE("Codec not found.");
     return 0L;
   }
-  return (jlong) createContext(env, codec, extraData, outputFloat);
+  return (jlong)createContext(env, codec, extraData, outputFloat, rawSampleRate,
+                              rawChannelCount);
 }
 
 DECODER_FUNC(jint, ffmpegDecode, jlong context, jobject inputData,
@@ -180,8 +183,11 @@ DECODER_FUNC(jlong, ffmpegReset, jlong jContext, jbyteArray extraData) {
       LOGE("Unexpected error finding codec %d.", codecId);
       return 0L;
     }
-    return (jlong) createContext(env, codec, extraData,
-        context->request_sample_fmt == OUTPUT_FORMAT_PCM_FLOAT);
+    jboolean outputFloat =
+        (jboolean)(context->request_sample_fmt == OUTPUT_FORMAT_PCM_FLOAT);
+    return (jlong)createContext(env, codec, extraData, outputFloat,
+                                /* rawSampleRate= */ -1,
+                                /* rawChannelCount= */ -1);
   }
 
   avcodec_flush_buffers(context);
@@ -204,8 +210,9 @@ AVCodec *getCodecByName(JNIEnv* env, jstring codecName) {
   return codec;
 }
 
-AVCodecContext *createContext(JNIEnv *env, AVCodec *codec,
-                              jbyteArray extraData, jboolean outputFloat) {
+AVCodecContext *createContext(JNIEnv *env, AVCodec *codec, jbyteArray extraData,
+                              jboolean outputFloat, jint rawSampleRate,
+                              jint rawChannelCount) {
   AVCodecContext *context = avcodec_alloc_context3(codec);
   if (!context) {
     LOGE("Failed to allocate context.");
@@ -225,6 +232,12 @@ AVCodecContext *createContext(JNIEnv *env, AVCodec *codec,
     }
     env->GetByteArrayRegion(extraData, 0, size, (jbyte *) context->extradata);
   }
+  if (context->codec_id == AV_CODEC_ID_PCM_MULAW ||
+      context->codec_id == AV_CODEC_ID_PCM_ALAW) {
+    context->sample_rate = rawSampleRate;
+    context->channels = rawChannelCount;
+    context->channel_layout = av_get_default_channel_layout(rawChannelCount);
+  }
   int result = avcodec_open2(context, codec, NULL);
   if (result < 0) {
     logError("avcodec_open2", result);
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
index fda5f0085d..54701eea1d 100644
--- a/extensions/flac/README.md
+++ b/extensions/flac/README.md
@@ -28,18 +28,19 @@ EXOPLAYER_ROOT="$(pwd)"
 FLAC_EXT_PATH="${EXOPLAYER_ROOT}/extensions/flac/src/main"
 ```
 
-* Download the [Android NDK][] and set its location in an environment variable:
+* Download the [Android NDK][] (version <= 17c) and set its location in an
+  environment variable:
 
 ```
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Download and extract flac-1.3.1 as "${FLAC_EXT_PATH}/jni/flac" folder:
+* Download and extract flac-1.3.2 as "${FLAC_EXT_PATH}/jni/flac" folder:
 
 ```
 cd "${FLAC_EXT_PATH}/jni" && \
-curl https://ftp.osuosl.org/pub/xiph/releases/flac/flac-1.3.1.tar.xz | tar xJ && \
-mv flac-1.3.1 flac
+curl https://ftp.osuosl.org/pub/xiph/releases/flac/flac-1.3.2.tar.xz | tar xJ && \
+mv flac-1.3.2 flac
 ```
 
 * Build the JNI native libraries from the command line:
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index 609953130b..e5261902c6 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -18,10 +18,16 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
         consumerProguardFiles 'proguard-rules.txt'
+        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
     }
 
     sourceSets.main {
@@ -33,6 +39,7 @@ android {
 dependencies {
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     implementation project(modulePrefix + 'library-core')
+    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
     androidTestImplementation project(modulePrefix + 'testutils')
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/flac/src/androidTest/AndroidManifest.xml b/extensions/flac/src/androidTest/AndroidManifest.xml
index 4e3925d8e3..cfc90117ac 100644
--- a/extensions/flac/src/androidTest/AndroidManifest.xml
+++ b/extensions/flac/src/androidTest/AndroidManifest.xml
@@ -26,6 +26,6 @@
 
   <instrumentation
       android:targetPackage="com.google.android.exoplayer2.ext.flac.test"
-      android:name="android.test.InstrumentationTestRunner"/>
+      android:name="androidx.test.runner.AndroidJUnitRunner"/>
 
 </manifest>
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
index 8124f1958a..f8e61a0609 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
@@ -67,6 +67,6 @@ public void testSetSeekTargetUs_returnsSeekPending()
             decoderJni.decodeMetadata(), /* firstFramePosition= */ 0, data.length, decoderJni);
 
     seeker.setSeekTargetUs(/* timeUs= */ 1000);
-    assertThat(seeker.hasPendingSeek()).isTrue();
+    assertThat(seeker.isSeeking()).isTrue();
   }
 }
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
index fc9bdac2ea..29a597daa4 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
@@ -16,9 +16,7 @@
 package com.google.android.exoplayer2.ext.flac;
 
 import android.test.InstrumentationTestCase;
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 
 /**
  * Unit test for {@link FlacExtractor}.
@@ -35,25 +33,11 @@ protected void setUp() throws Exception {
 
   public void testExtractFlacSample() throws Exception {
     ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new FlacExtractor();
-          }
-        },
-        "bear.flac",
-        getInstrumentation().getContext());
+        FlacExtractor::new, "bear.flac", getInstrumentation().getContext());
   }
 
   public void testExtractFlacSampleWithId3Header() throws Exception {
     ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new FlacExtractor();
-          }
-        },
-        "bear_with_id3.flac",
-        getInstrumentation().getContext());
+        FlacExtractor::new, "bear_with_id3.flac", getInstrumentation().getContext());
   }
 }
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index b236b706b8..99ddba55c4 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -15,10 +15,13 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
+import static androidx.test.InstrumentationRegistry.getContext;
+import static org.junit.Assert.fail;
+
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
-import android.test.InstrumentationTestCase;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
@@ -29,43 +32,40 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Playback tests using {@link LibflacAudioRenderer}.
- */
-public class FlacPlaybackTest extends InstrumentationTestCase {
+/** Playback tests using {@link LibflacAudioRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public class FlacPlaybackTest {
 
   private static final String BEAR_FLAC_URI = "asset:///bear-flac.mka";
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  @Before
+  public void setUp() {
     if (!FlacLibrary.isAvailable()) {
       fail("Flac library not available.");
     }
   }
 
-  public void testBasicPlayback() throws ExoPlaybackException {
+  @Test
+  public void testBasicPlayback() throws Exception {
     playUri(BEAR_FLAC_URI);
   }
 
-  private void playUri(String uri) throws ExoPlaybackException {
-    TestPlaybackRunnable testPlaybackRunnable = new TestPlaybackRunnable(Uri.parse(uri),
-        getInstrumentation().getContext());
+  private void playUri(String uri) throws Exception {
+    TestPlaybackRunnable testPlaybackRunnable =
+        new TestPlaybackRunnable(Uri.parse(uri), getContext());
     Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
-    try {
-      thread.join();
-    } catch (InterruptedException e) {
-      fail(); // Should never happen.
-    }
+    thread.join();
     if (testPlaybackRunnable.playbackException != null) {
       throw testPlaybackRunnable.playbackException;
     }
   }
 
-  private static class TestPlaybackRunnable extends Player.DefaultEventListener
-      implements Runnable {
+  private static class TestPlaybackRunnable implements Player.EventListener, Runnable {
 
     private final Context context;
     private final Uri uri;
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java
index 0bbee1ea30..b9c6ea06dd 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java
@@ -15,15 +15,11 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.FlacStreamInfo;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
@@ -33,111 +29,51 @@
  * <p>This seeker performs seeking by using binary search within the stream, until it finds the
  * frame that contains the target sample.
  */
-/* package */ final class FlacBinarySearchSeeker {
+/* package */ final class FlacBinarySearchSeeker extends BinarySearchSeeker {
 
-  /**
-   * When seeking within the source, if the offset is smaller than or equal to this value, the seek
-   * operation will be performed using a skip operation. Otherwise, the source will be reloaded at
-   * the new seek position.
-   */
-  private static final long MAX_SKIP_BYTES = 256 * 1024;
-
-  private final FlacStreamInfo streamInfo;
-  private final FlacBinarySearchSeekMap seekMap;
   private final FlacDecoderJni decoderJni;
 
-  private final long firstFramePosition;
-  private final long inputLength;
-  private final long approxBytesPerFrame;
-
-  private @Nullable SeekOperationParams pendingSeekOperationParams;
-
   public FlacBinarySearchSeeker(
       FlacStreamInfo streamInfo,
       long firstFramePosition,
       long inputLength,
       FlacDecoderJni decoderJni) {
-    this.streamInfo = Assertions.checkNotNull(streamInfo);
+    super(
+        new FlacSeekTimestampConverter(streamInfo),
+        new FlacTimestampSeeker(decoderJni),
+        streamInfo.durationUs(),
+        /* floorTimePosition= */ 0,
+        /* ceilingTimePosition= */ streamInfo.totalSamples,
+        /* floorBytePosition= */ firstFramePosition,
+        /* ceilingBytePosition= */ inputLength,
+        /* approxBytesPerFrame= */ streamInfo.getApproxBytesPerFrame(),
+        /* minimumSearchRange= */ Math.max(1, streamInfo.minFrameSize));
     this.decoderJni = Assertions.checkNotNull(decoderJni);
-    this.firstFramePosition = firstFramePosition;
-    this.inputLength = inputLength;
-    this.approxBytesPerFrame = streamInfo.getApproxBytesPerFrame();
-
-    pendingSeekOperationParams = null;
-    seekMap =
-        new FlacBinarySearchSeekMap(
-            streamInfo,
-            firstFramePosition,
-            inputLength,
-            streamInfo.durationUs(),
-            approxBytesPerFrame);
   }
 
-  /** Returns the seek map for the wrapped FLAC stream. */
-  public SeekMap getSeekMap() {
-    return seekMap;
-  }
-
-  /** Sets the target time in microseconds within the stream to seek to. */
-  public void setSeekTargetUs(long timeUs) {
-    if (pendingSeekOperationParams != null && pendingSeekOperationParams.seekTimeUs == timeUs) {
-      return;
+  @Override
+  protected void onSeekOperationFinished(boolean foundTargetFrame, long resultPosition) {
+    if (!foundTargetFrame) {
+      // If we can't find the target frame (sample), we need to reset the decoder jni so that
+      // it can continue from the result position.
+      decoderJni.reset(resultPosition);
     }
-
-    pendingSeekOperationParams =
-        new SeekOperationParams(
-            timeUs,
-            streamInfo.getSampleIndex(timeUs),
-            /* floorSample= */ 0,
-            /* ceilingSample= */ streamInfo.totalSamples,
-            /* floorPosition= */ firstFramePosition,
-            /* ceilingPosition= */ inputLength,
-            approxBytesPerFrame);
   }
 
-  /** Returns whether the last operation set by {@link #setSeekTargetUs(long)} is still pending. */
-  public boolean hasPendingSeek() {
-    return pendingSeekOperationParams != null;
-  }
-
-  /**
-   * Continues to handle the pending seek operation. Returns one of the {@code RESULT_} values from
-   * {@link Extractor}.
-   *
-   * @param input The {@link ExtractorInput} from which data should be read.
-   * @param seekPositionHolder If {@link Extractor#RESULT_SEEK} is returned, this holder is updated
-   *     to hold the position of the required seek.
-   * @param outputBuffer If {@link Extractor#RESULT_CONTINUE} is returned, this byte buffer maybe
-   *     updated to hold the extracted frame that contains the target sample. The caller needs to
-   *     check the byte buffer limit to see if an extracted frame is available.
-   * @return One of the {@code RESULT_} values defined in {@link Extractor}.
-   * @throws IOException If an error occurred reading from the input.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public int handlePendingSeek(
-      ExtractorInput input, PositionHolder seekPositionHolder, ByteBuffer outputBuffer)
-      throws InterruptedException, IOException {
-    outputBuffer.position(0);
-    outputBuffer.limit(0);
-    while (true) {
-      long floorPosition = pendingSeekOperationParams.floorPosition;
-      long ceilingPosition = pendingSeekOperationParams.ceilingPosition;
-      long searchPosition = pendingSeekOperationParams.nextSearchPosition;
+  private static final class FlacTimestampSeeker implements TimestampSeeker {
 
-      // streamInfo may not contain minFrameSize, in which case this value will be 0.
-      int minFrameSize = Math.max(1, streamInfo.minFrameSize);
-      if (floorPosition + minFrameSize >= ceilingPosition) {
-        // The seeking range is too small for more than 1 frame, so we can just continue from
-        // the floor position.
-        pendingSeekOperationParams = null;
-        decoderJni.reset(floorPosition);
-        return seekToPosition(input, floorPosition, seekPositionHolder);
-      }
+    private final FlacDecoderJni decoderJni;
 
-      if (!skipInputUntilPosition(input, searchPosition)) {
-        return seekToPosition(input, searchPosition, seekPositionHolder);
-      }
+    private FlacTimestampSeeker(FlacDecoderJni decoderJni) {
+      this.decoderJni = decoderJni;
+    }
 
+    @Override
+    public TimestampSearchResult searchForTimestamp(
+        ExtractorInput input, long targetSampleIndex, OutputFrameHolder outputFrameHolder)
+        throws IOException, InterruptedException {
+      ByteBuffer outputBuffer = outputFrameHolder.byteBuffer;
+      long searchPosition = input.getPosition();
       decoderJni.reset(searchPosition);
       try {
         decoderJni.decodeSampleWithBacktrackPosition(
@@ -145,11 +81,10 @@ public int handlePendingSeek(
       } catch (FlacDecoderJni.FlacFrameDecodeException e) {
         // For some reasons, the extractor can't find a frame mid-stream.
         // Stop the seeking and let it re-try playing at the last search position.
-        pendingSeekOperationParams = null;
-        throw new IOException("Cannot read frame at position " + searchPosition, e);
+        return TimestampSearchResult.NO_TIMESTAMP_IN_RANGE_RESULT;
       }
       if (outputBuffer.limit() == 0) {
-        return Extractor.RESULT_END_OF_INPUT;
+        return TimestampSearchResult.NO_TIMESTAMP_IN_RANGE_RESULT;
       }
 
       long lastFrameSampleIndex = decoderJni.getLastFrameFirstSampleIndex();
@@ -157,184 +92,35 @@ public int handlePendingSeek(
       long nextFrameSamplePosition = decoderJni.getDecodePosition();
 
       boolean targetSampleInLastFrame =
-          lastFrameSampleIndex <= pendingSeekOperationParams.targetSample
-              && nextFrameSampleIndex > pendingSeekOperationParams.targetSample;
+          lastFrameSampleIndex <= targetSampleIndex && nextFrameSampleIndex > targetSampleIndex;
 
       if (targetSampleInLastFrame) {
-        pendingSeekOperationParams = null;
-        return Extractor.RESULT_CONTINUE;
-      }
-
-      if (nextFrameSampleIndex <= pendingSeekOperationParams.targetSample) {
-        pendingSeekOperationParams.updateSeekFloor(nextFrameSampleIndex, nextFrameSamplePosition);
+        // We are holding the target frame in outputFrameHolder. Set its presentation time now.
+        outputFrameHolder.timeUs = decoderJni.getLastFrameTimestamp();
+        return TimestampSearchResult.targetFoundResult(input.getPosition());
+      } else if (nextFrameSampleIndex <= targetSampleIndex) {
+        return TimestampSearchResult.underestimatedResult(
+            nextFrameSampleIndex, nextFrameSamplePosition);
       } else {
-        pendingSeekOperationParams.updateSeekCeiling(lastFrameSampleIndex, searchPosition);
-      }
-    }
-  }
-
-  private boolean skipInputUntilPosition(ExtractorInput input, long position)
-      throws IOException, InterruptedException {
-    long bytesToSkip = position - input.getPosition();
-    if (bytesToSkip >= 0 && bytesToSkip <= MAX_SKIP_BYTES) {
-      input.skipFully((int) bytesToSkip);
-      return true;
-    }
-    return false;
-  }
-
-  private int seekToPosition(
-      ExtractorInput input, long position, PositionHolder seekPositionHolder) {
-    if (position == input.getPosition()) {
-      return Extractor.RESULT_CONTINUE;
-    } else {
-      seekPositionHolder.position = position;
-      return Extractor.RESULT_SEEK;
-    }
-  }
-
-  /**
-   * Contains parameters for a pending seek operation by {@link FlacBinarySearchSeeker}.
-   *
-   * <p>This class holds parameters for a binary-search for the {@code targetSample} in the range
-   * [floorPosition, ceilingPosition).
-   */
-  private static final class SeekOperationParams {
-    private final long seekTimeUs;
-    private final long targetSample;
-    private final long approxBytesPerFrame;
-    private long floorSample;
-    private long ceilingSample;
-    private long floorPosition;
-    private long ceilingPosition;
-    private long nextSearchPosition;
-
-    private SeekOperationParams(
-        long seekTimeUs,
-        long targetSample,
-        long floorSample,
-        long ceilingSample,
-        long floorPosition,
-        long ceilingPosition,
-        long approxBytesPerFrame) {
-      this.seekTimeUs = seekTimeUs;
-      this.floorSample = floorSample;
-      this.ceilingSample = ceilingSample;
-      this.floorPosition = floorPosition;
-      this.ceilingPosition = ceilingPosition;
-      this.targetSample = targetSample;
-      this.approxBytesPerFrame = approxBytesPerFrame;
-      updateNextSearchPosition();
-    }
-
-    /** Updates the floor constraints (inclusive) of the seek operation. */
-    private void updateSeekFloor(long floorSample, long floorPosition) {
-      this.floorSample = floorSample;
-      this.floorPosition = floorPosition;
-      updateNextSearchPosition();
-    }
-
-    /** Updates the ceiling constraints (exclusive) of the seek operation. */
-    private void updateSeekCeiling(long ceilingSample, long ceilingPosition) {
-      this.ceilingSample = ceilingSample;
-      this.ceilingPosition = ceilingPosition;
-      updateNextSearchPosition();
-    }
-
-    private void updateNextSearchPosition() {
-      this.nextSearchPosition =
-          getNextSearchPosition(
-              targetSample,
-              floorSample,
-              ceilingSample,
-              floorPosition,
-              ceilingPosition,
-              approxBytesPerFrame);
-    }
-
-    /**
-     * Returns the next position in FLAC stream to search for target sample, given [floorPosition,
-     * ceilingPosition).
-     */
-    private static long getNextSearchPosition(
-        long targetSample,
-        long floorSample,
-        long ceilingSample,
-        long floorPosition,
-        long ceilingPosition,
-        long approxBytesPerFrame) {
-      if (floorPosition + 1 >= ceilingPosition || floorSample + 1 >= ceilingSample) {
-        return floorPosition;
+        return TimestampSearchResult.overestimatedResult(lastFrameSampleIndex, searchPosition);
       }
-      long samplesToSkip = targetSample - floorSample;
-      long estimatedBytesPerSample =
-          Math.max(1, (ceilingPosition - floorPosition) / (ceilingSample - floorSample));
-      // In the stream, the samples are accessed in a group of frame. Given a stream position, the
-      // seeker will be able to find the first frame following that position.
-      // Hence, if our target sample is in the middle of a frame, and our estimate position is
-      // correct, or very near the actual sample position, the seeker will keep accessing the next
-      // frame, rather than the frame that contains the target sample.
-      // Moreover, it's better to under-estimate rather than over-estimate, because the extractor
-      // input can skip forward easily, but cannot rewind easily (it may require a new connection
-      // to be made).
-      // Therefore, we should reduce the estimated position by some amount, so it will converge to
-      // the correct frame earlier.
-      long bytesToSkip = samplesToSkip * estimatedBytesPerSample;
-      long confidenceInterval = bytesToSkip / 20;
-
-      long estimatedFramePosition = floorPosition + bytesToSkip - (approxBytesPerFrame - 1);
-      long estimatedPosition = estimatedFramePosition - confidenceInterval;
-
-      return Util.constrainValue(estimatedPosition, floorPosition, ceilingPosition - 1);
     }
   }
 
   /**
-   * A {@link SeekMap} implementation that returns the estimated byte location from {@link
-   * SeekOperationParams#getNextSearchPosition(long, long, long, long, long, long)} for each {@link
-   * #getSeekPoints(long)} query.
+   * A {@link SeekTimestampConverter} implementation that returns the frame index (sample index) as
+   * the timestamp for a stream seek time position.
    */
-  private static final class FlacBinarySearchSeekMap implements SeekMap {
+  private static final class FlacSeekTimestampConverter implements SeekTimestampConverter {
     private final FlacStreamInfo streamInfo;
-    private final long firstFramePosition;
-    private final long inputLength;
-    private final long approxBytesPerFrame;
-    private final long durationUs;
 
-    private FlacBinarySearchSeekMap(
-        FlacStreamInfo streamInfo,
-        long firstFramePosition,
-        long inputLength,
-        long durationUs,
-        long approxBytesPerFrame) {
+    public FlacSeekTimestampConverter(FlacStreamInfo streamInfo) {
       this.streamInfo = streamInfo;
-      this.firstFramePosition = firstFramePosition;
-      this.inputLength = inputLength;
-      this.approxBytesPerFrame = approxBytesPerFrame;
-      this.durationUs = durationUs;
-    }
-
-    @Override
-    public boolean isSeekable() {
-      return true;
-    }
-
-    @Override
-    public SeekPoints getSeekPoints(long timeUs) {
-      long nextSearchPosition =
-          SeekOperationParams.getNextSearchPosition(
-              streamInfo.getSampleIndex(timeUs),
-              /* floorSample= */ 0,
-              /* ceilingSample= */ streamInfo.totalSamples,
-              /* floorPosition= */ firstFramePosition,
-              /* ceilingPosition= */ inputLength,
-              approxBytesPerFrame);
-      return new SeekPoints(new SeekPoint(timeUs, nextSearchPosition));
     }
 
     @Override
-    public long getDurationUs() {
-      return durationUs;
+    public long timeUsToTargetTime(long timeUs) {
+      return Assertions.checkNotNull(streamInfo).getSampleIndex(timeUs);
     }
   }
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
index e8a04e06ae..2d74bce5f1 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
@@ -37,11 +38,17 @@
    *
    * @param numInputBuffers The number of input buffers.
    * @param numOutputBuffers The number of output buffers.
+   * @param maxInputBufferSize The maximum required input buffer size if known, or {@link
+   *     Format#NO_VALUE} otherwise.
    * @param initializationData Codec-specific initialization data. It should contain only one entry
-   *    which is the flac file header.
+   *     which is the flac file header.
    * @throws FlacDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public FlacDecoder(int numInputBuffers, int numOutputBuffers, List<byte[]> initializationData)
+  public FlacDecoder(
+      int numInputBuffers,
+      int numOutputBuffers,
+      int maxInputBufferSize,
+      List<byte[]> initializationData)
       throws FlacDecoderException {
     super(new DecoderInputBuffer[numInputBuffers], new SimpleOutputBuffer[numOutputBuffers]);
     if (initializationData.size() != 1) {
@@ -60,7 +67,9 @@ public FlacDecoder(int numInputBuffers, int numOutputBuffers, List<byte[]> initi
       throw new FlacDecoderException("Metadata decoding failed");
     }
 
-    setInitialInputBufferSize(streamInfo.maxFrameSize);
+    int initialInputBufferSize =
+        maxInputBufferSize != Format.NO_VALUE ? maxInputBufferSize : streamInfo.maxFrameSize;
+    setInitialInputBufferSize(initialInputBufferSize);
     maxOutputBufferSize = streamInfo.maxDecodedFrameSize();
   }
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
index 69c0d082ee..de038921aa 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
@@ -155,6 +155,7 @@ public void decodeSampleWithBacktrackPosition(ByteBuffer output, long retryPosit
   }
 
   /** Decodes and consumes the next sample from the FLAC stream into the given byte buffer. */
+  @SuppressWarnings("ByteBufferBackingArray")
   public void decodeSample(ByteBuffer output)
       throws IOException, InterruptedException, FlacFrameDecodeException {
     output.clear();
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index a5efeb69f9..8f5dcef16b 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -21,6 +21,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -36,6 +37,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -46,24 +48,18 @@
  */
 public final class FlacExtractor implements Extractor {
 
+  /** Factory that returns one extractor which is a {@link FlacExtractor}. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new FlacExtractor()};
+
   /**
-   * Factory that returns one extractor which is a {@link FlacExtractor}.
+   * Flags controlling the behavior of the extractor. Possible flag value is {@link
+   * #FLAG_DISABLE_ID3_METADATA}.
    */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new FlacExtractor()};
-    }
-
-  };
-
-  /** Flags controlling the behavior of the extractor. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
-    flag = true,
-    value = {FLAG_DISABLE_ID3_METADATA}
-  )
+      flag = true,
+      value = {FLAG_DISABLE_ID3_METADATA})
   public @interface Flags {}
 
   /**
@@ -88,6 +84,7 @@
 
   private ParsableByteArray outputBuffer;
   private ByteBuffer outputByteBuffer;
+  private BinarySearchSeeker.OutputFrameHolder outputFrameHolder;
   private FlacStreamInfo streamInfo;
 
   private Metadata id3Metadata;
@@ -140,7 +137,7 @@ public int read(final ExtractorInput input, PositionHolder seekPosition)
     decoderJni.setData(input);
     readPastStreamInfo(input);
 
-    if (flacBinarySearchSeeker != null && flacBinarySearchSeeker.hasPendingSeek()) {
+    if (flacBinarySearchSeeker != null && flacBinarySearchSeeker.isSeeking()) {
       return handlePendingSeek(input, seekPosition);
     }
 
@@ -224,6 +221,7 @@ private void updateFlacStreamInfo(ExtractorInput input, FlacStreamInfo streamInf
     outputFormat(streamInfo);
     outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
     outputByteBuffer = ByteBuffer.wrap(outputBuffer.data);
+    outputFrameHolder = new BinarySearchSeeker.OutputFrameHolder(outputByteBuffer);
   }
 
   private FlacStreamInfo decodeStreamInfo(ExtractorInput input)
@@ -286,9 +284,10 @@ private void outputFormat(FlacStreamInfo streamInfo) {
   private int handlePendingSeek(ExtractorInput input, PositionHolder seekPosition)
       throws InterruptedException, IOException {
     int seekResult =
-        flacBinarySearchSeeker.handlePendingSeek(input, seekPosition, outputByteBuffer);
+        flacBinarySearchSeeker.handlePendingSeek(input, seekPosition, outputFrameHolder);
+    ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
     if (seekResult == RESULT_CONTINUE && outputByteBuffer.limit() > 0) {
-      writeLastSampleToOutput(outputByteBuffer.limit(), decoderJni.getLastFrameTimestamp());
+      writeLastSampleToOutput(outputByteBuffer.limit(), outputFrameHolder.timeUs);
     }
     return seekResult;
   }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index a72b03cd44..424fcbb285 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -53,7 +53,7 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     if (!FlacLibrary.isAvailable()
         || !MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
-    } else if (!supportsOutputEncoding(C.ENCODING_PCM_16BIT)) {
+    } else if (!supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
@@ -65,7 +65,8 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
   @Override
   protected FlacDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
       throws FlacDecoderException {
-    return new FlacDecoder(NUM_BUFFERS, NUM_BUFFERS, format.initializationData);
+    return new FlacDecoder(
+        NUM_BUFFERS, NUM_BUFFERS, format.maxInputSize, format.initializationData);
   }
 
 }
diff --git a/extensions/flac/src/main/jni/Android.mk b/extensions/flac/src/main/jni/Android.mk
index ff54c1b3c0..69520a16e5 100644
--- a/extensions/flac/src/main/jni/Android.mk
+++ b/extensions/flac/src/main/jni/Android.mk
@@ -30,9 +30,9 @@ LOCAL_C_INCLUDES := \
     $(LOCAL_PATH)/flac/src/libFLAC/include
 LOCAL_SRC_FILES := $(FLAC_SOURCES)
 
-LOCAL_CFLAGS += '-DVERSION="1.3.1"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY -DFLAC__NO_ASM
+LOCAL_CFLAGS += '-DPACKAGE_VERSION="1.3.2"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY
 LOCAL_CFLAGS += -D_REENTRANT -DPIC -DU_COMMON_IMPLEMENTATION -fPIC -DHAVE_SYS_PARAM_H
-LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions
+LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions -DFLAC__NO_ASM '-DFLAC__HAS_OGG=0'
 
 LOCAL_LDLIBS := -llog -lz -lm
 include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/flac/src/main/jni/Application.mk b/extensions/flac/src/main/jni/Application.mk
index 59bf5f8f87..eba20352f4 100644
--- a/extensions/flac/src/main/jni/Application.mk
+++ b/extensions/flac/src/main/jni/Application.mk
@@ -17,4 +17,4 @@
 APP_OPTIM := release
 APP_STL := gnustl_static
 APP_CPPFLAGS := -frtti
-APP_PLATFORM := android-9
+APP_PLATFORM := android-14
diff --git a/extensions/flac/src/test/AndroidManifest.xml b/extensions/flac/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..1d68b376ac
--- /dev/null
+++ b/extensions/flac/src/test/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.flac"/>
diff --git a/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java b/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java
new file mode 100644
index 0000000000..79c4452928
--- /dev/null
+++ b/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.flac;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.amr.AmrExtractor;
+import com.google.android.exoplayer2.extractor.flv.FlvExtractor;
+import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
+import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
+import com.google.android.exoplayer2.extractor.ogg.OggExtractor;
+import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
+import com.google.android.exoplayer2.extractor.ts.PsExtractor;
+import com.google.android.exoplayer2.extractor.ts.TsExtractor;
+import com.google.android.exoplayer2.extractor.wav.WavExtractor;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link DefaultExtractorsFactory}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultExtractorsFactoryTest {
+
+  @Test
+  public void testCreateExtractors_returnExpectedClasses() {
+    DefaultExtractorsFactory defaultExtractorsFactory = new DefaultExtractorsFactory();
+
+    Extractor[] extractors = defaultExtractorsFactory.createExtractors();
+    List<Class<?>> listCreatedExtractorClasses = new ArrayList<>();
+    for (Extractor extractor : extractors) {
+      listCreatedExtractorClasses.add(extractor.getClass());
+    }
+
+    Class<?>[] expectedExtractorClassses =
+        new Class<?>[] {
+          MatroskaExtractor.class,
+          FragmentedMp4Extractor.class,
+          Mp4Extractor.class,
+          Mp3Extractor.class,
+          AdtsExtractor.class,
+          Ac3Extractor.class,
+          TsExtractor.class,
+          FlvExtractor.class,
+          OggExtractor.class,
+          PsExtractor.class,
+          WavExtractor.class,
+          AmrExtractor.class,
+          FlacExtractor.class
+        };
+
+    assertThat(listCreatedExtractorClasses).containsNoDuplicates();
+    assertThat(listCreatedExtractorClasses).containsExactlyElementsIn(expectedExtractorClassses);
+  }
+}
diff --git a/extensions/flac/src/test/resources/robolectric.properties b/extensions/flac/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/extensions/flac/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index 87e72939c5..af973e1345 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion 19
         targetSdkVersion project.ext.targetSdkVersion
diff --git a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
index 1b595d6886..eca31c98e4 100644
--- a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
+++ b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioProcessor;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.vr.sdk.audio.GvrAudioSurround;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -148,18 +149,21 @@ public int getOutputSampleRateHz() {
   @Override
   public void queueInput(ByteBuffer input) {
     int position = input.position();
+    Assertions.checkNotNull(gvrAudioSurround);
     int readBytes = gvrAudioSurround.addInput(input, position, input.limit() - position);
     input.position(position + readBytes);
   }
 
   @Override
   public void queueEndOfStream() {
+    Assertions.checkNotNull(gvrAudioSurround);
     inputEnded = true;
     gvrAudioSurround.triggerProcessing();
   }
 
   @Override
   public ByteBuffer getOutput() {
+    Assertions.checkNotNull(gvrAudioSurround);
     int writtenBytes = gvrAudioSurround.getOutput(buffer, 0, buffer.capacity());
     buffer.position(0).limit(writtenBytes);
     return buffer;
@@ -167,6 +171,7 @@ public ByteBuffer getOutput() {
 
   @Override
   public boolean isEnded() {
+    Assertions.checkNotNull(gvrAudioSurround);
     return inputEnded && gvrAudioSurround.getAvailableOutputSize() == 0;
   }
 
diff --git a/extensions/ima/README.md b/extensions/ima/README.md
index c5ef1af35f..e13cd85590 100644
--- a/extensions/ima/README.md
+++ b/extensions/ima/README.md
@@ -30,7 +30,9 @@ To play ads alongside a single-window content `MediaSource`, prepare the player
 with an `AdsMediaSource` constructed using an `ImaAdsLoader`, the content
 `MediaSource` and an overlay `ViewGroup` on top of the player. Pass an ad tag
 URI from your ad campaign when creating the `ImaAdsLoader`. The IMA
-documentation includes some [sample ad tags][] for testing.
+documentation includes some [sample ad tags][] for testing. Note that the IMA
+extension only supports players which are accessed on the application's main
+thread.
 
 Resuming the player after entering the background requires some special handling
 when playing ads. The player and its media source are released on entering the
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index cec6b8a495..22196ff3ab 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
@@ -26,16 +31,21 @@ android {
 }
 
 dependencies {
-    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.8.7'
+    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.10.2'
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.google.android.gms:play-services-ads:' + playServicesLibraryVersion
+    implementation 'com.google.android.gms:play-services-ads:17.1.1'
     // These dependencies are necessary to force the supportLibraryVersion of
     // com.android.support:support-v4 and com.android.support:customtabs to be
     // used. Else older versions are used, for example via:
-    // com.google.android.gms:play-services-ads:15.0.1
+    // com.google.android.gms:play-services-ads:17.1.1
     // |-- com.android.support:customtabs:26.1.0
     implementation 'com.android.support:support-v4:' + supportLibraryVersion
     implementation 'com.android.support:customtabs:' + supportLibraryVersion
+    testImplementation 'com.google.truth:truth:' + truthVersion
+    testImplementation 'junit:junit:' + junitVersion
+    testImplementation 'org.mockito:mockito-core:' + mockitoVersion
+    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/extensions/ima/src/main/AndroidManifest.xml b/extensions/ima/src/main/AndroidManifest.xml
index 1bb79ff21d..226b15cb34 100644
--- a/extensions/ima/src/main/AndroidManifest.xml
+++ b/extensions/ima/src/main/AndroidManifest.xml
@@ -15,6 +15,10 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.ext.ima">
-  <meta-data android:name="com.google.android.gms.version"
-      android:value="@integer/google_play_services_version"/>
+  <application>
+    <meta-data android:name="com.google.android.gms.ads.AD_MANAGER_APP"
+        android:value="true"/>
+    <meta-data android:name="com.google.android.gms.version"
+        android:value="@integer/google_play_services_version"/>
+  </application>
 </manifest>
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 3256da21dd..6ca3bfd881 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -17,12 +17,11 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.os.Looper;
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.ViewGroup;
-import android.webkit.WebView;
 import com.google.ads.interactivemedia.v3.api.Ad;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
 import com.google.ads.interactivemedia.v3.api.AdError;
@@ -38,8 +37,10 @@
 import com.google.ads.interactivemedia.v3.api.AdsManagerLoadedEvent;
 import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
 import com.google.ads.interactivemedia.v3.api.AdsRequest;
+import com.google.ads.interactivemedia.v3.api.CompanionAdSlot;
 import com.google.ads.interactivemedia.v3.api.ImaSdkFactory;
 import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
+import com.google.ads.interactivemedia.v3.api.UiElement;
 import com.google.ads.interactivemedia.v3.api.player.ContentProgressProvider;
 import com.google.ads.interactivemedia.v3.api.player.VideoAdPlayer;
 import com.google.ads.interactivemedia.v3.api.player.VideoProgressUpdate;
@@ -53,24 +54,34 @@
 import com.google.android.exoplayer2.source.ads.AdPlaybackState.AdState;
 import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource.AdLoadException;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-
-/**
- * Loads ads using the IMA SDK. All methods are called on the main thread.
- */
-public final class ImaAdsLoader extends Player.DefaultEventListener implements AdsLoader,
-    VideoAdPlayer, ContentProgressProvider, AdErrorListener, AdsLoadedListener, AdEventListener {
+import java.util.Set;
+
+/** Loads ads using the IMA SDK. All methods are called on the main thread. */
+public final class ImaAdsLoader
+    implements Player.EventListener,
+        AdsLoader,
+        VideoAdPlayer,
+        ContentProgressProvider,
+        AdErrorListener,
+        AdsLoadedListener,
+        AdEventListener {
 
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.ima");
@@ -83,8 +94,12 @@
 
     private @Nullable ImaSdkSettings imaSdkSettings;
     private @Nullable AdEventListener adEventListener;
+    private @Nullable Set<UiElement> adUiElements;
     private int vastLoadTimeoutMs;
     private int mediaLoadTimeoutMs;
+    private int mediaBitrate;
+    private boolean focusSkipButtonWhenAvailable;
+    private ImaFactory imaFactory;
 
     /**
      * Creates a new builder for {@link ImaAdsLoader}.
@@ -95,6 +110,9 @@ public Builder(Context context) {
       this.context = Assertions.checkNotNull(context);
       vastLoadTimeoutMs = TIMEOUT_UNSET;
       mediaLoadTimeoutMs = TIMEOUT_UNSET;
+      mediaBitrate = BITRATE_UNSET;
+      focusSkipButtonWhenAvailable = true;
+      imaFactory = new DefaultImaFactory();
     }
 
     /**
@@ -123,6 +141,18 @@ public Builder setAdEventListener(AdEventListener adEventListener) {
       return this;
     }
 
+    /**
+     * Sets the ad UI elements to be rendered by the IMA SDK.
+     *
+     * @param adUiElements The ad UI elements to be rendered by the IMA SDK.
+     * @return This builder, for convenience.
+     * @see AdsRenderingSettings#setUiElements(Set)
+     */
+    public Builder setAdUiElements(Set<UiElement> adUiElements) {
+      this.adUiElements = new HashSet<>(Assertions.checkNotNull(adUiElements));
+      return this;
+    }
+
     /**
      * Sets the VAST load timeout, in milliseconds.
      *
@@ -131,7 +161,7 @@ public Builder setAdEventListener(AdEventListener adEventListener) {
      * @see AdsRequest#setVastLoadTimeout(float)
      */
     public Builder setVastLoadTimeoutMs(int vastLoadTimeoutMs) {
-      Assertions.checkArgument(vastLoadTimeoutMs >= 0);
+      Assertions.checkArgument(vastLoadTimeoutMs > 0);
       this.vastLoadTimeoutMs = vastLoadTimeoutMs;
       return this;
     }
@@ -144,11 +174,44 @@ public Builder setVastLoadTimeoutMs(int vastLoadTimeoutMs) {
      * @see AdsRenderingSettings#setLoadVideoTimeout(int)
      */
     public Builder setMediaLoadTimeoutMs(int mediaLoadTimeoutMs) {
-      Assertions.checkArgument(mediaLoadTimeoutMs >= 0);
+      Assertions.checkArgument(mediaLoadTimeoutMs > 0);
       this.mediaLoadTimeoutMs = mediaLoadTimeoutMs;
       return this;
     }
 
+    /**
+     * Sets the media maximum recommended bitrate for ads, in bps.
+     *
+     * @param bitrate The media maximum recommended bitrate for ads, in bps.
+     * @return This builder, for convenience.
+     * @see AdsRenderingSettings#setBitrateKbps(int)
+     */
+    public Builder setMaxMediaBitrate(int bitrate) {
+      Assertions.checkArgument(bitrate > 0);
+      this.mediaBitrate = bitrate;
+      return this;
+    }
+
+    /**
+     * Sets whether to focus the skip button (when available) on Android TV devices. The default
+     * setting is {@code true}.
+     *
+     * @param focusSkipButtonWhenAvailable Whether to focus the skip button (when available) on
+     *     Android TV devices.
+     * @return This builder, for convenience.
+     * @see AdsRenderingSettings#setFocusSkipButtonWhenAvailable(boolean)
+     */
+    public Builder setFocusSkipButtonWhenAvailable(boolean focusSkipButtonWhenAvailable) {
+      this.focusSkipButtonWhenAvailable = focusSkipButtonWhenAvailable;
+      return this;
+    }
+
+    // @VisibleForTesting
+    /* package */ Builder setImaFactory(ImaFactory imaFactory) {
+      this.imaFactory = Assertions.checkNotNull(imaFactory);
+      return this;
+    }
+
     /**
      * Returns a new {@link ImaAdsLoader} for the specified ad tag.
      *
@@ -165,7 +228,11 @@ public ImaAdsLoader buildForAdTag(Uri adTagUri) {
           null,
           vastLoadTimeoutMs,
           mediaLoadTimeoutMs,
-          adEventListener);
+          mediaBitrate,
+          focusSkipButtonWhenAvailable,
+          adUiElements,
+          adEventListener,
+          imaFactory);
     }
 
     /**
@@ -183,7 +250,11 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
           adsResponse,
           vastLoadTimeoutMs,
           mediaLoadTimeoutMs,
-          adEventListener);
+          mediaBitrate,
+          focusSkipButtonWhenAvailable,
+          adUiElements,
+          adEventListener,
+          imaFactory);
     }
   }
 
@@ -210,17 +281,11 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   /** The maximum duration before an ad break that IMA may start preloading the next ad. */
   private static final long MAXIMUM_PRELOAD_DURATION_MS = 8000;
 
-  /**
-   * The "Skip ad" button rendered in the IMA WebView does not gain focus by default and cannot be
-   * clicked via a keypress event. Workaround this issue by calling focus() on the HTML element in
-   * the WebView directly when an ad starts. See [Internal: b/62371030].
-   */
-  private static final String FOCUS_SKIP_BUTTON_WORKAROUND_JS = "javascript:"
-      + "try{ document.getElementsByClassName(\"videoAdUiSkipButton\")[0].focus(); } catch (e) {}";
-
   private static final int TIMEOUT_UNSET = -1;
+  private static final int BITRATE_UNSET = -1;
 
   /** The state of ad playback. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({IMA_AD_STATE_NONE, IMA_AD_STATE_PLAYING, IMA_AD_STATE_PAUSED})
   private @interface ImaAdState {}
@@ -241,10 +306,13 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private final @Nullable String adsResponse;
   private final int vastLoadTimeoutMs;
   private final int mediaLoadTimeoutMs;
+  private final boolean focusSkipButtonWhenAvailable;
+  private final int mediaBitrate;
+  private final @Nullable Set<UiElement> adUiElements;
   private final @Nullable AdEventListener adEventListener;
+  private final ImaFactory imaFactory;
   private final Timeline.Period period;
   private final List<VideoAdPlayerCallback> adCallbacks;
-  private final ImaSdkFactory imaSdkFactory;
   private final AdDisplayContainer adDisplayContainer;
   private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
@@ -252,9 +320,9 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private List<String> supportedMimeTypes;
   private EventListener eventListener;
   private Player player;
-  private ViewGroup adUiViewGroup;
   private VideoProgressUpdate lastContentProgress;
   private VideoProgressUpdate lastAdProgress;
+  private int lastVolumePercentage;
 
   private AdsManager adsManager;
   private AdLoadException pendingAdLoadError;
@@ -267,13 +335,9 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
 
   /** The expected ad group index that IMA should load next. */
   private int expectedAdGroupIndex;
-  /**
-   * The index of the current ad group that IMA is loading.
-   */
+  /** The index of the current ad group that IMA is loading. */
   private int adGroupIndex;
-  /**
-   * Whether IMA has sent an ad event to pause content since the last resume content event.
-   */
+  /** Whether IMA has sent an ad event to pause content since the last resume content event. */
   private boolean imaPausedContent;
   /** The current ad playback state. */
   private @ImaAdState int imaAdState;
@@ -285,9 +349,7 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
 
   // Fields tracking the player/loader state.
 
-  /**
-   * Whether the player is playing an ad.
-   */
+  /** Whether the player is playing an ad. */
   private boolean playingAd;
   /**
    * If the player is playing an ad, stores the ad index in its ad group. {@link C#INDEX_UNSET}
@@ -310,13 +372,9 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
    * content progress should increase. {@link C#TIME_UNSET} otherwise.
    */
   private long fakeContentProgressOffsetMs;
-  /**
-   * Stores the pending content position when a seek operation was intercepted to play an ad.
-   */
+  /** Stores the pending content position when a seek operation was intercepted to play an ad. */
   private long pendingContentPositionMs;
-  /**
-   * Whether {@link #getContentProgress()} has sent {@link #pendingContentPositionMs} to IMA.
-   */
+  /** Whether {@link #getContentProgress()} has sent {@link #pendingContentPositionMs} to IMA. */
   private boolean sentPendingContentPositionMs;
 
   /**
@@ -337,7 +395,11 @@ public ImaAdsLoader(Context context, Uri adTagUri) {
         /* adsResponse= */ null,
         /* vastLoadTimeoutMs= */ TIMEOUT_UNSET,
         /* mediaLoadTimeoutMs= */ TIMEOUT_UNSET,
-        /* adEventListener= */ null);
+        /* mediaBitrate= */ BITRATE_UNSET,
+        /* focusSkipButtonWhenAvailable= */ true,
+        /* adUiElements= */ null,
+        /* adEventListener= */ null,
+        /* imaFactory= */ new DefaultImaFactory());
   }
 
   /**
@@ -360,7 +422,11 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
         /* adsResponse= */ null,
         /* vastLoadTimeoutMs= */ TIMEOUT_UNSET,
         /* mediaLoadTimeoutMs= */ TIMEOUT_UNSET,
-        /* adEventListener= */ null);
+        /* mediaBitrate= */ BITRATE_UNSET,
+        /* focusSkipButtonWhenAvailable= */ true,
+        /* adUiElements= */ null,
+        /* adEventListener= */ null,
+        /* imaFactory= */ new DefaultImaFactory());
   }
 
   private ImaAdsLoader(
@@ -370,26 +436,36 @@ private ImaAdsLoader(
       @Nullable String adsResponse,
       int vastLoadTimeoutMs,
       int mediaLoadTimeoutMs,
-      @Nullable AdEventListener adEventListener) {
+      int mediaBitrate,
+      boolean focusSkipButtonWhenAvailable,
+      @Nullable Set<UiElement> adUiElements,
+      @Nullable AdEventListener adEventListener,
+      ImaFactory imaFactory) {
     Assertions.checkArgument(adTagUri != null || adsResponse != null);
     this.adTagUri = adTagUri;
     this.adsResponse = adsResponse;
     this.vastLoadTimeoutMs = vastLoadTimeoutMs;
     this.mediaLoadTimeoutMs = mediaLoadTimeoutMs;
+    this.mediaBitrate = mediaBitrate;
+    this.focusSkipButtonWhenAvailable = focusSkipButtonWhenAvailable;
+    this.adUiElements = adUiElements;
     this.adEventListener = adEventListener;
-    period = new Timeline.Period();
-    adCallbacks = new ArrayList<>(1);
-    imaSdkFactory = ImaSdkFactory.getInstance();
-    adDisplayContainer = imaSdkFactory.createAdDisplayContainer();
-    adDisplayContainer.setPlayer(this);
+    this.imaFactory = imaFactory;
     if (imaSdkSettings == null) {
-      imaSdkSettings = imaSdkFactory.createImaSdkSettings();
+      imaSdkSettings = imaFactory.createImaSdkSettings();
+      if (DEBUG) {
+        imaSdkSettings.setDebugMode(true);
+      }
     }
     imaSdkSettings.setPlayerType(IMA_SDK_SETTINGS_PLAYER_TYPE);
     imaSdkSettings.setPlayerVersion(IMA_SDK_SETTINGS_PLAYER_VERSION);
-    adsLoader = imaSdkFactory.createAdsLoader(context, imaSdkSettings);
-    adsLoader.addAdErrorListener(this);
-    adsLoader.addAdsLoadedListener(this);
+    adsLoader = imaFactory.createAdsLoader(context, imaSdkSettings);
+    period = new Timeline.Period();
+    adCallbacks = new ArrayList<>(/* initialCapacity= */ 1);
+    adDisplayContainer = imaFactory.createAdDisplayContainer();
+    adDisplayContainer.setPlayer(/* videoAdPlayer= */ this);
+    adsLoader.addAdErrorListener(/* adErrorListener= */ this);
+    adsLoader.addAdsLoadedListener(/* adsLoadedListener= */ this);
     fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
     fakeContentProgressOffsetMs = C.TIME_UNSET;
     pendingContentPositionMs = C.TIME_UNSET;
@@ -405,6 +481,17 @@ private ImaAdsLoader(
     return adsLoader;
   }
 
+  /**
+   * Sets the slots for displaying companion ads. Individual slots can be created using {@link
+   * ImaSdkFactory#createCompanionAdSlot()}.
+   *
+   * @param companionSlots Slots for displaying companion ads.
+   * @see AdDisplayContainer#setCompanionSlots(Collection)
+   */
+  public void setCompanionSlots(Collection<CompanionAdSlot> companionSlots) {
+    adDisplayContainer.setCompanionSlots(companionSlots);
+  }
+
   /**
    * Requests ads, if they have not already been requested. Must be called on the main thread.
    *
@@ -421,7 +508,7 @@ public void requestAds(ViewGroup adUiViewGroup) {
     }
     adDisplayContainer.setAdContainer(adUiViewGroup);
     pendingAdRequestContext = new Object();
-    AdsRequest request = imaSdkFactory.createAdsRequest();
+    AdsRequest request = imaFactory.createAdsRequest();
     if (adTagUri != null) {
       request.setAdTagUrl(adTagUri.toString());
     } else /* adsResponse != null */ {
@@ -463,9 +550,10 @@ public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
 
   @Override
   public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup) {
+    Assertions.checkArgument(player.getApplicationLooper() == Looper.getMainLooper());
     this.player = player;
     this.eventListener = eventListener;
-    this.adUiViewGroup = adUiViewGroup;
+    lastVolumePercentage = 0;
     lastAdProgress = null;
     lastContentProgress = null;
     adDisplayContainer.setAdContainer(adUiViewGroup);
@@ -494,12 +582,12 @@ public void detachPlayer() {
               playingAd ? C.msToUs(player.getCurrentPosition()) : 0);
       adsManager.pause();
     }
+    lastVolumePercentage = getVolume();
     lastAdProgress = getAdProgress();
     lastContentProgress = getContentProgress();
     player.removeListener(this);
     player = null;
     eventListener = null;
-    adUiViewGroup = null;
   }
 
   @Override
@@ -509,6 +597,11 @@ public void release() {
       adsManager.destroy();
       adsManager = null;
     }
+    imaPausedContent = false;
+    imaAdState = IMA_AD_STATE_NONE;
+    pendingAdLoadError = null;
+    adPlaybackState = AdPlaybackState.NONE;
+    updateAdPlaybackState();
   }
 
   @Override
@@ -558,7 +651,7 @@ public void onAdEvent(AdEvent adEvent) {
       Log.d(TAG, "onAdEvent: " + adEventType);
     }
     if (adsManager == null) {
-      Log.w(TAG, "Dropping ad event after release: " + adEvent);
+      Log.w(TAG, "Ignoring AdEvent after release: " + adEvent);
       return;
     }
     try {
@@ -651,9 +744,37 @@ public VideoProgressUpdate getAdProgress() {
     }
   }
 
+  @Override
+  public int getVolume() {
+    if (player == null) {
+      return lastVolumePercentage;
+    }
+
+    Player.AudioComponent audioComponent = player.getAudioComponent();
+    if (audioComponent != null) {
+      return (int) (audioComponent.getVolume() * 100);
+    }
+
+    // Check for a selected track using an audio renderer.
+    TrackSelectionArray trackSelections = player.getCurrentTrackSelections();
+    for (int i = 0; i < player.getRendererCount() && i < trackSelections.length; i++) {
+      if (player.getRendererType(i) == C.TRACK_TYPE_AUDIO && trackSelections.get(i) != null) {
+        return 100;
+      }
+    }
+    return 0;
+  }
+
   @Override
   public void loadAd(String adUriString) {
     try {
+      if (DEBUG) {
+        Log.d(TAG, "loadAd in ad group " + adGroupIndex);
+      }
+      if (adsManager == null) {
+        Log.w(TAG, "Ignoring loadAd after release");
+        return;
+      }
       if (adGroupIndex == C.INDEX_UNSET) {
         Log.w(
             TAG,
@@ -662,9 +783,6 @@ public void loadAd(String adUriString) {
         adGroupIndex = expectedAdGroupIndex;
         adsManager.start();
       }
-      if (DEBUG) {
-        Log.d(TAG, "loadAd in ad group " + adGroupIndex);
-      }
       int adIndexInAdGroup = getAdIndexInAdGroupToLoad(adGroupIndex);
       if (adIndexInAdGroup == C.INDEX_UNSET) {
         Log.w(TAG, "Unexpected loadAd in an ad group with no remaining unavailable ads");
@@ -693,6 +811,10 @@ public void playAd() {
     if (DEBUG) {
       Log.d(TAG, "playAd");
     }
+    if (adsManager == null) {
+      Log.w(TAG, "Ignoring playAd after release");
+      return;
+    }
     switch (imaAdState) {
       case IMA_AD_STATE_PLAYING:
         // IMA does not always call stopAd before resuming content.
@@ -736,6 +858,10 @@ public void stopAd() {
     if (DEBUG) {
       Log.d(TAG, "stopAd");
     }
+    if (adsManager == null) {
+      Log.w(TAG, "Ignoring stopAd after release");
+      return;
+    }
     if (player == null) {
       // Sometimes messages from IMA arrive after detaching the player. See [Internal: b/63801642].
       Log.w(TAG, "Unexpected stopAd while detached");
@@ -775,8 +901,8 @@ public void resumeAd() {
   // Player.EventListener implementation.
 
   @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest,
-      @Player.TimelineChangeReason int reason) {
+  public void onTimelineChanged(
+      Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
     if (reason == Player.TIMELINE_CHANGE_REASON_RESET) {
       // The player is being reset and this source will be released.
       return;
@@ -811,8 +937,6 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
         && playWhenReady) {
       checkForContentComplete();
     } else if (imaAdState != IMA_AD_STATE_NONE && playbackState == Player.STATE_ENDED) {
-      // IMA is waiting for the ad playback to finish so invoke the callback now.
-      // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
       for (int i = 0; i < adCallbacks.size(); i++) {
         adCallbacks.get(i).onEnded();
       }
@@ -865,13 +989,19 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
   // Internal methods.
 
   private void startAdPlayback() {
-    ImaSdkFactory imaSdkFactory = ImaSdkFactory.getInstance();
-    AdsRenderingSettings adsRenderingSettings = imaSdkFactory.createAdsRenderingSettings();
+    AdsRenderingSettings adsRenderingSettings = imaFactory.createAdsRenderingSettings();
     adsRenderingSettings.setEnablePreloading(ENABLE_PRELOADING);
     adsRenderingSettings.setMimeTypes(supportedMimeTypes);
     if (mediaLoadTimeoutMs != TIMEOUT_UNSET) {
       adsRenderingSettings.setLoadVideoTimeout(mediaLoadTimeoutMs);
     }
+    if (mediaBitrate != BITRATE_UNSET) {
+      adsRenderingSettings.setBitrateKbps(mediaBitrate / 1000);
+    }
+    adsRenderingSettings.setFocusSkipButtonWhenAvailable(focusSkipButtonWhenAvailable);
+    if (adUiElements != null) {
+      adsRenderingSettings.setUiElements(adUiElements);
+    }
 
     // Set up the ad playback state, skipping ads based on the start position as required.
     long[] adGroupTimesUs = getAdGroupTimesUs(adsManager.getAdCuePoints());
@@ -955,11 +1085,6 @@ private void handleAdEvent(AdEvent adEvent) {
         imaPausedContent = true;
         pauseContentInternal();
         break;
-      case STARTED:
-        if (ad.isSkippable()) {
-          focusSkipButton();
-        }
-        break;
       case TAPPED:
         if (eventListener != null) {
           eventListener.onAdTapped();
@@ -982,6 +1107,7 @@ private void handleAdEvent(AdEvent adEvent) {
           handleAdGroupLoadError(new IOException(message));
         }
         break;
+      case STARTED:
       case ALL_ADS_COMPLETED:
       default:
         break;
@@ -993,26 +1119,24 @@ private void updateImaStateForPlayerState() {
     int oldPlayingAdIndexInAdGroup = playingAdIndexInAdGroup;
     playingAd = player.isPlayingAd();
     playingAdIndexInAdGroup = playingAd ? player.getCurrentAdIndexInAdGroup() : C.INDEX_UNSET;
-    if (!sentContentComplete) {
-      boolean adFinished = wasPlayingAd && playingAdIndexInAdGroup != oldPlayingAdIndexInAdGroup;
-      if (adFinished) {
-        // IMA is waiting for the ad playback to finish so invoke the callback now.
-        // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
-        for (int i = 0; i < adCallbacks.size(); i++) {
-          adCallbacks.get(i).onEnded();
-        }
-        if (DEBUG) {
-          Log.d(TAG, "VideoAdPlayerCallback.onEnded in onTimelineChanged/onPositionDiscontinuity");
-        }
+    boolean adFinished = wasPlayingAd && playingAdIndexInAdGroup != oldPlayingAdIndexInAdGroup;
+    if (adFinished) {
+      // IMA is waiting for the ad playback to finish so invoke the callback now.
+      // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
+      for (int i = 0; i < adCallbacks.size(); i++) {
+        adCallbacks.get(i).onEnded();
       }
-      if (!wasPlayingAd && playingAd && imaAdState == IMA_AD_STATE_NONE) {
-        int adGroupIndex = player.getCurrentAdGroupIndex();
-        // IMA hasn't called playAd yet, so fake the content position.
-        fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
-        fakeContentProgressOffsetMs = C.usToMs(adPlaybackState.adGroupTimesUs[adGroupIndex]);
-        if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
-          fakeContentProgressOffsetMs = contentDurationMs;
-        }
+      if (DEBUG) {
+        Log.d(TAG, "VideoAdPlayerCallback.onEnded in onTimelineChanged/onPositionDiscontinuity");
+      }
+    }
+    if (!sentContentComplete && !wasPlayingAd && playingAd && imaAdState == IMA_AD_STATE_NONE) {
+      int adGroupIndex = player.getCurrentAdGroupIndex();
+      // IMA hasn't called playAd yet, so fake the content position.
+      fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
+      fakeContentProgressOffsetMs = C.usToMs(adPlaybackState.adGroupTimesUs[adGroupIndex]);
+      if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
+        fakeContentProgressOffsetMs = contentDurationMs;
       }
     }
   }
@@ -1076,6 +1200,8 @@ private void handleAdGroupLoadError(Exception error) {
     if (pendingAdLoadError == null) {
       pendingAdLoadError = AdLoadException.createForAdGroup(error, adGroupIndex);
     }
+    pendingContentPositionMs = C.TIME_UNSET;
+    fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
   }
 
   private void handleAdPrepareError(int adGroupIndex, int adIndexInAdGroup, Exception exception) {
@@ -1083,6 +1209,10 @@ private void handleAdPrepareError(int adGroupIndex, int adIndexInAdGroup, Except
       Log.d(
           TAG, "Prepare error for ad " + adIndexInAdGroup + " in group " + adGroupIndex, exception);
     }
+    if (adsManager == null) {
+      Log.w(TAG, "Ignoring ad prepare error after release");
+      return;
+    }
     if (imaAdState == IMA_AD_STATE_NONE) {
       // Send IMA a content position at the ad group so that it will try to play it, at which point
       // we can notify that it failed to load.
@@ -1119,6 +1249,10 @@ private void checkForContentComplete() {
         Log.d(TAG, "adsLoader.contentComplete");
       }
       sentContentComplete = true;
+      // After sending content complete IMA will not poll the content position, so set the expected
+      // ad group index.
+      expectedAdGroupIndex =
+          adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentDurationMs));
     }
   }
 
@@ -1129,15 +1263,6 @@ private void updateAdPlaybackState() {
     }
   }
 
-  private void focusSkipButton() {
-    if (playingAd && adUiViewGroup != null && adUiViewGroup.getChildCount() > 0
-        && adUiViewGroup.getChildAt(0) instanceof WebView) {
-      WebView webView = (WebView) (adUiViewGroup.getChildAt(0));
-      webView.requestFocus();
-      webView.loadUrl(FOCUS_SKIP_BUTTON_WORKAROUND_JS);
-    }
-  }
-
   /**
    * Returns the next ad index in the specified ad group to load, or {@link C#INDEX_UNSET} if all
    * ads in the ad group have loaded.
@@ -1165,7 +1290,7 @@ private void maybeNotifyInternalError(String name, Exception cause) {
     Log.e(TAG, message, cause);
     // We can't recover from an unexpected error in general, so skip all remaining ads.
     if (adPlaybackState == null) {
-      adPlaybackState = new AdPlaybackState();
+      adPlaybackState = AdPlaybackState.NONE;
     } else {
       for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
         adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
@@ -1218,4 +1343,49 @@ private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
       return true;
     }
   }
+
+  /** Factory for objects provided by the IMA SDK. */
+  // @VisibleForTesting
+  /* package */ interface ImaFactory {
+    /** @see ImaSdkSettings */
+    ImaSdkSettings createImaSdkSettings();
+    /** @see com.google.ads.interactivemedia.v3.api.ImaSdkFactory#createAdsRenderingSettings() */
+    AdsRenderingSettings createAdsRenderingSettings();
+    /** @see com.google.ads.interactivemedia.v3.api.ImaSdkFactory#createAdDisplayContainer() */
+    AdDisplayContainer createAdDisplayContainer();
+    /** @see com.google.ads.interactivemedia.v3.api.ImaSdkFactory#createAdsRequest() */
+    AdsRequest createAdsRequest();
+    /** @see ImaSdkFactory#createAdsLoader(Context, ImaSdkSettings) */
+    com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
+        Context context, ImaSdkSettings imaSdkSettings);
+  }
+
+  /** Default {@link ImaFactory} for non-test usage, which delegates to {@link ImaSdkFactory}. */
+  private static final class DefaultImaFactory implements ImaFactory {
+    @Override
+    public ImaSdkSettings createImaSdkSettings() {
+      return ImaSdkFactory.getInstance().createImaSdkSettings();
+    }
+
+    @Override
+    public AdsRenderingSettings createAdsRenderingSettings() {
+      return ImaSdkFactory.getInstance().createAdsRenderingSettings();
+    }
+
+    @Override
+    public AdDisplayContainer createAdDisplayContainer() {
+      return ImaSdkFactory.getInstance().createAdDisplayContainer();
+    }
+
+    @Override
+    public AdsRequest createAdsRequest() {
+      return ImaSdkFactory.getInstance().createAdsRequest();
+    }
+
+    @Override
+    public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
+        Context context, ImaSdkSettings imaSdkSettings) {
+      return ImaSdkFactory.getInstance().createAdsLoader(context, imaSdkSettings);
+    }
+  }
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
index d3e1d9725e..85042c4354 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
@@ -23,9 +23,11 @@
 import com.google.android.exoplayer2.source.BaseMediaSource;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.SourceInfoRefreshListener;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
 
 /**
@@ -34,12 +36,10 @@
  * @deprecated Use com.google.android.exoplayer2.source.ads.AdsMediaSource with ImaAdsLoader.
  */
 @Deprecated
-public final class ImaAdsMediaSource extends BaseMediaSource {
+public final class ImaAdsMediaSource extends BaseMediaSource implements SourceInfoRefreshListener {
 
   private final AdsMediaSource adsMediaSource;
 
-  private SourceInfoRefreshListener adsMediaSourceListener;
-
   /**
    * Constructs a new source that inserts ads linearly with the content specified by
    * {@code contentMediaSource}.
@@ -77,16 +77,18 @@ public ImaAdsMediaSource(
   }
 
   @Override
-  public void prepareSourceInternal(final ExoPlayer player, boolean isTopLevelSource) {
-    adsMediaSourceListener =
-        new SourceInfoRefreshListener() {
-          @Override
-          public void onSourceInfoRefreshed(
-              MediaSource source, Timeline timeline, @Nullable Object manifest) {
-            refreshSourceInfo(timeline, manifest);
-          }
-        };
-    adsMediaSource.prepareSource(player, isTopLevelSource, adsMediaSourceListener);
+  @Nullable
+  public Object getTag() {
+    return adsMediaSource.getTag();
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      final ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    adsMediaSource.prepareSource(
+        player, isTopLevelSource, /* listener= */ this, mediaTransferListener);
   }
 
   @Override
@@ -106,6 +108,12 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSourceInternal() {
-    adsMediaSource.releaseSource(adsMediaSourceListener);
+    adsMediaSource.releaseSource(/* listener= */ this);
+  }
+
+  @Override
+  public void onSourceInfoRefreshed(
+      MediaSource source, Timeline timeline, @Nullable Object manifest) {
+    refreshSourceInfo(timeline, manifest);
   }
 }
diff --git a/extensions/ima/src/main/proguard-rules.txt b/extensions/ima/src/main/proguard-rules.txt
deleted file mode 100644
index feef3daf7a..0000000000
--- a/extensions/ima/src/main/proguard-rules.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-# Proguard rules specific to the IMA extension.
-
--keep class com.google.ads.interactivemedia.** { *; }
--keep interface com.google.ads.interactivemedia.** { *; }
--keep class com.google.obf.** { *; }
--keep interface com.google.obf.** { *; }
diff --git a/extensions/ima/src/test/AndroidManifest.xml b/extensions/ima/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..9a4e33189e
--- /dev/null
+++ b/extensions/ima/src/test/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest package="com.google.android.exoplayer2.ext.ima.test" />
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
new file mode 100644
index 0000000000..b626a08780
--- /dev/null
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ima;
+
+import com.google.ads.interactivemedia.v3.api.Ad;
+import com.google.ads.interactivemedia.v3.api.AdPodInfo;
+import com.google.ads.interactivemedia.v3.api.CompanionAd;
+import com.google.ads.interactivemedia.v3.api.UiElement;
+import java.util.List;
+import java.util.Set;
+
+/** A fake ad for testing. */
+/* package */ final class FakeAd implements Ad {
+
+  private final boolean skippable;
+  private final AdPodInfo adPodInfo;
+
+  public FakeAd(boolean skippable, int podIndex, int totalAds, int adPosition) {
+    this.skippable = skippable;
+    adPodInfo =
+        new AdPodInfo() {
+          @Override
+          public int getTotalAds() {
+            return totalAds;
+          }
+
+          @Override
+          public int getAdPosition() {
+            return adPosition;
+          }
+
+          @Override
+          public int getPodIndex() {
+            return podIndex;
+          }
+
+          @Override
+          public boolean isBumper() {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public double getMaxDuration() {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public double getTimeOffset() {
+            throw new UnsupportedOperationException();
+          }
+        };
+  }
+
+  public int getVastMediaWidth() {
+    throw new UnsupportedOperationException();
+  }
+
+  public int getVastMediaHeight() {
+    throw new UnsupportedOperationException();
+  }
+
+  public int getVastMediaBitrate() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isSkippable() {
+    return skippable;
+  }
+
+  @Override
+  public AdPodInfo getAdPodInfo() {
+    return adPodInfo;
+  }
+
+  @Override
+  public String getAdId() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getCreativeId() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getCreativeAdId() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getUniversalAdIdValue() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getUniversalAdIdRegistry() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getAdSystem() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String[] getAdWrapperIds() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String[] getAdWrapperSystems() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String[] getAdWrapperCreativeIds() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isLinear() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public double getSkipTimeOffset() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isUiDisabled() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getDescription() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getTitle() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getContentType() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getAdvertiserName() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getSurveyUrl() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getDealId() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getWidth() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getHeight() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getTraffickingParameters() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public double getDuration() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Set<UiElement> getUiElements() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public List<CompanionAd> getCompanionAds() {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAdsLoader.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAdsLoader.java
new file mode 100644
index 0000000000..a8f3daae33
--- /dev/null
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAdsLoader.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ima;
+
+import com.google.ads.interactivemedia.v3.api.AdErrorEvent.AdErrorListener;
+import com.google.ads.interactivemedia.v3.api.AdsManager;
+import com.google.ads.interactivemedia.v3.api.AdsManagerLoadedEvent;
+import com.google.ads.interactivemedia.v3.api.AdsRequest;
+import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
+import com.google.ads.interactivemedia.v3.api.StreamManager;
+import com.google.ads.interactivemedia.v3.api.StreamRequest;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.ArrayList;
+
+/** Fake {@link com.google.ads.interactivemedia.v3.api.AdsLoader} implementation for tests. */
+public final class FakeAdsLoader implements com.google.ads.interactivemedia.v3.api.AdsLoader {
+
+  private final ImaSdkSettings imaSdkSettings;
+  private final AdsManager adsManager;
+  private final ArrayList<AdsLoadedListener> adsLoadedListeners;
+  private final ArrayList<AdErrorListener> adErrorListeners;
+
+  public FakeAdsLoader(ImaSdkSettings imaSdkSettings, AdsManager adsManager) {
+    this.imaSdkSettings = Assertions.checkNotNull(imaSdkSettings);
+    this.adsManager = Assertions.checkNotNull(adsManager);
+    adsLoadedListeners = new ArrayList<>();
+    adErrorListeners = new ArrayList<>();
+  }
+
+  @Override
+  public void contentComplete() {
+    // Do nothing.
+  }
+
+  @Override
+  public ImaSdkSettings getSettings() {
+    return imaSdkSettings;
+  }
+
+  @Override
+  public void requestAds(AdsRequest adsRequest) {
+    for (AdsLoadedListener listener : adsLoadedListeners) {
+      listener.onAdsManagerLoaded(
+          new AdsManagerLoadedEvent() {
+            @Override
+            public AdsManager getAdsManager() {
+              return adsManager;
+            }
+
+            @Override
+            public StreamManager getStreamManager() {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public Object getUserRequestContext() {
+              return adsRequest.getUserRequestContext();
+            }
+          });
+    }
+  }
+
+  @Override
+  public String requestStream(StreamRequest streamRequest) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void addAdsLoadedListener(AdsLoadedListener adsLoadedListener) {
+    adsLoadedListeners.add(adsLoadedListener);
+  }
+
+  @Override
+  public void removeAdsLoadedListener(AdsLoadedListener adsLoadedListener) {
+    adsLoadedListeners.remove(adsLoadedListener);
+  }
+
+  @Override
+  public void addAdErrorListener(AdErrorListener adErrorListener) {
+    adErrorListeners.add(adErrorListener);
+  }
+
+  @Override
+  public void removeAdErrorListener(AdErrorListener adErrorListener) {
+    adErrorListeners.remove(adErrorListener);
+  }
+}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAdsRequest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAdsRequest.java
new file mode 100644
index 0000000000..7c2c8a6e0b
--- /dev/null
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAdsRequest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ima;
+
+import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
+import com.google.ads.interactivemedia.v3.api.AdsRequest;
+import com.google.ads.interactivemedia.v3.api.player.ContentProgressProvider;
+import java.util.List;
+import java.util.Map;
+
+/** Fake {@link AdsRequest} implementation for tests. */
+public final class FakeAdsRequest implements AdsRequest {
+
+  private String adTagUrl;
+  private String adsResponse;
+  private Object userRequestContext;
+  private AdDisplayContainer adDisplayContainer;
+  private ContentProgressProvider contentProgressProvider;
+
+  @Override
+  public void setAdTagUrl(String adTagUrl) {
+    this.adTagUrl = adTagUrl;
+  }
+
+  @Override
+  public String getAdTagUrl() {
+    return adTagUrl;
+  }
+
+  @Override
+  public void setExtraParameter(String s, String s1) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public String getExtraParameter(String s) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Map<String, String> getExtraParameters() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setUserRequestContext(Object userRequestContext) {
+    this.userRequestContext = userRequestContext;
+  }
+
+  @Override
+  public Object getUserRequestContext() {
+    return userRequestContext;
+  }
+
+  @Override
+  public AdDisplayContainer getAdDisplayContainer() {
+    return adDisplayContainer;
+  }
+
+  @Override
+  public void setAdDisplayContainer(AdDisplayContainer adDisplayContainer) {
+    this.adDisplayContainer = adDisplayContainer;
+  }
+
+  @Override
+  public ContentProgressProvider getContentProgressProvider() {
+    return contentProgressProvider;
+  }
+
+  @Override
+  public void setContentProgressProvider(ContentProgressProvider contentProgressProvider) {
+    this.contentProgressProvider = contentProgressProvider;
+  }
+
+  @Override
+  public String getAdsResponse() {
+    return adsResponse;
+  }
+
+  @Override
+  public void setAdsResponse(String adsResponse) {
+    this.adsResponse = adsResponse;
+  }
+
+  @Override
+  public void setAdWillAutoPlay(boolean b) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setAdWillPlayMuted(boolean b) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setContentDuration(float v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setContentKeywords(List<String> list) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setContentTitle(String s) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setVastLoadTimeout(float v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setLiveStreamPrefetchSeconds(float v) {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
new file mode 100644
index 0000000000..b8024d6534
--- /dev/null
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ima;
+
+import android.os.Looper;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.testutil.StubExoPlayer;
+import java.util.ArrayList;
+
+/** A fake player for testing content/ad playback. */
+/* package */ final class FakePlayer extends StubExoPlayer {
+
+  private final ArrayList<Player.EventListener> listeners;
+  private final Timeline.Period period;
+  private final Timeline timeline;
+
+  private boolean prepared;
+  private int state;
+  private boolean playWhenReady;
+  private long position;
+  private long contentPosition;
+  private boolean isPlayingAd;
+  private int adGroupIndex;
+  private int adIndexInAdGroup;
+
+  public FakePlayer() {
+    listeners = new ArrayList<>();
+    period = new Timeline.Period();
+    state = Player.STATE_IDLE;
+    playWhenReady = true;
+    timeline = Timeline.EMPTY;
+  }
+
+  /** Sets the timeline on this fake player, which notifies listeners with the changed timeline. */
+  public void updateTimeline(Timeline timeline) {
+    for (Player.EventListener listener : listeners) {
+      listener.onTimelineChanged(
+          timeline,
+          null,
+          prepared ? TIMELINE_CHANGE_REASON_DYNAMIC : TIMELINE_CHANGE_REASON_PREPARED);
+    }
+    prepared = true;
+  }
+
+  /**
+   * Sets the state of this player as if it were playing content at the given {@code position}. If
+   * an ad is currently playing, this will trigger a position discontinuity.
+   */
+  public void setPlayingContentPosition(long position) {
+    boolean notify = isPlayingAd;
+    isPlayingAd = false;
+    adGroupIndex = C.INDEX_UNSET;
+    adIndexInAdGroup = C.INDEX_UNSET;
+    this.position = position;
+    contentPosition = position;
+    if (notify) {
+      for (Player.EventListener listener : listeners) {
+        listener.onPositionDiscontinuity(DISCONTINUITY_REASON_AD_INSERTION);
+      }
+    }
+  }
+
+  /**
+   * Sets the state of this player as if it were playing an ad with the given indices at the given
+   * {@code position}. If the player is playing a different ad or content, this will trigger a
+   * position discontinuity.
+   */
+  public void setPlayingAdPosition(
+      int adGroupIndex, int adIndexInAdGroup, long position, long contentPosition) {
+    boolean notify = !isPlayingAd || this.adIndexInAdGroup != adIndexInAdGroup;
+    isPlayingAd = true;
+    this.adGroupIndex = adGroupIndex;
+    this.adIndexInAdGroup = adIndexInAdGroup;
+    this.position = position;
+    this.contentPosition = contentPosition;
+    if (notify) {
+      for (Player.EventListener listener : listeners) {
+        listener.onPositionDiscontinuity(DISCONTINUITY_REASON_AD_INSERTION);
+      }
+    }
+  }
+
+  /** Sets the state of this player with the given {@code STATE} constant. */
+  public void setState(int state, boolean playWhenReady) {
+    boolean notify = this.state != state || this.playWhenReady != playWhenReady;
+    this.state = state;
+    this.playWhenReady = playWhenReady;
+    if (notify) {
+      for (Player.EventListener listener : listeners) {
+        listener.onPlayerStateChanged(playWhenReady, state);
+      }
+    }
+  }
+
+  // ExoPlayer methods. Other methods are unsupported.
+
+  @Override
+  public Looper getApplicationLooper() {
+    return Looper.getMainLooper();
+  }
+
+  @Override
+  public void addListener(Player.EventListener listener) {
+    listeners.add(listener);
+  }
+
+  @Override
+  public void removeListener(Player.EventListener listener) {
+    listeners.remove(listener);
+  }
+
+  @Override
+  public int getPlaybackState() {
+    return state;
+  }
+
+  @Override
+  public boolean getPlayWhenReady() {
+    return playWhenReady;
+  }
+
+  @Override
+  public Timeline getCurrentTimeline() {
+    return timeline;
+  }
+
+  @Override
+  public int getCurrentPeriodIndex() {
+    return 0;
+  }
+
+  @Override
+  public int getCurrentWindowIndex() {
+    return 0;
+  }
+
+  @Override
+  public long getDuration() {
+    if (timeline.isEmpty()) {
+      return C.INDEX_UNSET;
+    }
+    if (isPlayingAd()) {
+      long adDurationUs =
+          timeline.getPeriod(0, period).getAdDurationUs(adGroupIndex, adIndexInAdGroup);
+      return C.usToMs(adDurationUs);
+    } else {
+      return timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+    }
+  }
+
+  @Override
+  public long getCurrentPosition() {
+    return position;
+  }
+
+  @Override
+  public boolean isPlayingAd() {
+    return isPlayingAd;
+  }
+
+  @Override
+  public int getCurrentAdGroupIndex() {
+    return adGroupIndex;
+  }
+
+  @Override
+  public int getCurrentAdIndexInAdGroup() {
+    return adIndexInAdGroup;
+  }
+
+  @Override
+  public long getContentPosition() {
+    return contentPosition;
+  }
+}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
new file mode 100644
index 0000000000..b0fe731480
--- /dev/null
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ima;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import com.google.ads.interactivemedia.v3.api.Ad;
+import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
+import com.google.ads.interactivemedia.v3.api.AdEvent;
+import com.google.ads.interactivemedia.v3.api.AdEvent.AdEventType;
+import com.google.ads.interactivemedia.v3.api.AdsManager;
+import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
+import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.SinglePeriodTimeline;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource.AdLoadException;
+import com.google.android.exoplayer2.source.ads.SinglePeriodAdTimeline;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Test for {@link ImaAdsLoader}. */
+@RunWith(RobolectricTestRunner.class)
+public class ImaAdsLoaderTest {
+
+  private static final long CONTENT_DURATION_US = 10 * C.MICROS_PER_SECOND;
+  private static final Timeline CONTENT_TIMELINE =
+      new SinglePeriodTimeline(CONTENT_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false);
+  private static final Uri TEST_URI = Uri.EMPTY;
+  private static final long TEST_AD_DURATION_US = 5 * C.MICROS_PER_SECOND;
+  private static final long[][] PREROLL_ADS_DURATIONS_US = new long[][] {{TEST_AD_DURATION_US}};
+  private static final Float[] PREROLL_CUE_POINTS_SECONDS = new Float[] {0f};
+  private static final FakeAd UNSKIPPABLE_AD =
+      new FakeAd(/* skippable= */ false, /* podIndex= */ 0, /* totalAds= */ 1, /* adPosition= */ 1);
+
+  private @Mock ImaSdkSettings imaSdkSettings;
+  private @Mock AdsRenderingSettings adsRenderingSettings;
+  private @Mock AdDisplayContainer adDisplayContainer;
+  private @Mock AdsManager adsManager;
+  private SingletonImaFactory testImaFactory;
+  private ViewGroup adUiViewGroup;
+  private TestAdsLoaderListener adsLoaderListener;
+  private FakePlayer fakeExoPlayer;
+  private ImaAdsLoader imaAdsLoader;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    FakeAdsRequest fakeAdsRequest = new FakeAdsRequest();
+    FakeAdsLoader fakeAdsLoader = new FakeAdsLoader(imaSdkSettings, adsManager);
+    testImaFactory =
+        new SingletonImaFactory(
+            imaSdkSettings,
+            adsRenderingSettings,
+            adDisplayContainer,
+            fakeAdsRequest,
+            fakeAdsLoader);
+    adUiViewGroup = new FrameLayout(RuntimeEnvironment.application);
+  }
+
+  @After
+  public void teardown() {
+    if (imaAdsLoader != null) {
+      imaAdsLoader.release();
+    }
+  }
+
+  @Test
+  public void testBuilder_overridesPlayerType() {
+    when(imaSdkSettings.getPlayerType()).thenReturn("test player type");
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+
+    verify(imaSdkSettings).setPlayerType("google/exo.ext.ima");
+  }
+
+  @Test
+  public void testAttachPlayer_setsAdUiViewGroup() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+
+    verify(adDisplayContainer, atLeastOnce()).setAdContainer(adUiViewGroup);
+  }
+
+  @Test
+  public void testAttachPlayer_updatesAdPlaybackState() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+
+    assertThat(adsLoaderListener.adPlaybackState)
+        .isEqualTo(
+            new AdPlaybackState(/* adGroupTimesUs= */ 0)
+                .withAdDurationsUs(PREROLL_ADS_DURATIONS_US));
+  }
+
+  @Test
+  public void testAttachAfterRelease() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+    imaAdsLoader.release();
+    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+  }
+
+  @Test
+  public void testAttachAndCallbacksAfterRelease() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+    imaAdsLoader.release();
+    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    fakeExoPlayer.setPlayingContentPosition(/* position= */ 0);
+    fakeExoPlayer.setState(Player.STATE_READY, true);
+
+    // If callbacks are invoked there is no crash.
+    // Note: we can't currently call getContentProgress/getAdProgress as a VerifyError is thrown
+    // when using Robolectric and accessing VideoProgressUpdate.VIDEO_TIME_NOT_READY, due to the IMA
+    // SDK being proguarded.
+    imaAdsLoader.requestAds(adUiViewGroup);
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.LOADED, UNSKIPPABLE_AD));
+    imaAdsLoader.loadAd(TEST_URI.toString());
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_PAUSE_REQUESTED, UNSKIPPABLE_AD));
+    imaAdsLoader.playAd();
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.STARTED, UNSKIPPABLE_AD));
+    imaAdsLoader.pauseAd();
+    imaAdsLoader.stopAd();
+    imaAdsLoader.onPlayerError(ExoPlaybackException.createForSource(new IOException()));
+    imaAdsLoader.onPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK);
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_RESUME_REQUESTED, /* ad= */ null));
+    imaAdsLoader.handlePrepareError(
+        /* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, new IOException());
+  }
+
+  @Test
+  public void testPlayback_withPrerollAd_marksAdAsPlayed() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+
+    // Load the preroll ad.
+    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.LOADED, UNSKIPPABLE_AD));
+    imaAdsLoader.loadAd(TEST_URI.toString());
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_PAUSE_REQUESTED, UNSKIPPABLE_AD));
+
+    // Play the preroll ad.
+    imaAdsLoader.playAd();
+    fakeExoPlayer.setPlayingAdPosition(
+        /* adGroupIndex= */ 0,
+        /* adIndexInAdGroup= */ 0,
+        /* position= */ 0,
+        /* contentPosition= */ 0);
+    fakeExoPlayer.setState(Player.STATE_READY, true);
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.STARTED, UNSKIPPABLE_AD));
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.FIRST_QUARTILE, UNSKIPPABLE_AD));
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.MIDPOINT, UNSKIPPABLE_AD));
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.THIRD_QUARTILE, UNSKIPPABLE_AD));
+
+    // Play the content.
+    fakeExoPlayer.setPlayingContentPosition(0);
+    imaAdsLoader.stopAd();
+    imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_RESUME_REQUESTED, /* ad= */ null));
+
+    // Verify that the preroll ad has been marked as played.
+    assertThat(adsLoaderListener.adPlaybackState)
+        .isEqualTo(
+            new AdPlaybackState(/* adGroupTimesUs= */ 0)
+                .withContentDurationUs(CONTENT_DURATION_US)
+                .withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 1)
+                .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, /* uri= */ TEST_URI)
+                .withAdDurationsUs(PREROLL_ADS_DURATIONS_US)
+                .withPlayedAd(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0)
+                .withAdResumePositionUs(/* adResumePositionUs= */ 0));
+  }
+
+  private void setupPlayback(Timeline contentTimeline, long[][] adDurationsUs, Float[] cuePoints) {
+    fakeExoPlayer = new FakePlayer();
+    adsLoaderListener = new TestAdsLoaderListener(fakeExoPlayer, contentTimeline, adDurationsUs);
+    when(adsManager.getAdCuePoints()).thenReturn(Arrays.asList(cuePoints));
+    imaAdsLoader =
+        new ImaAdsLoader.Builder(RuntimeEnvironment.application)
+            .setImaFactory(testImaFactory)
+            .setImaSdkSettings(imaSdkSettings)
+            .buildForAdTag(TEST_URI);
+  }
+
+  private static AdEvent getAdEvent(AdEventType adEventType, @Nullable Ad ad) {
+    return new AdEvent() {
+      @Override
+      public AdEventType getType() {
+        return adEventType;
+      }
+
+      @Override
+      public @Nullable Ad getAd() {
+        return ad;
+      }
+
+      @Override
+      public Map<String, String> getAdData() {
+        return Collections.emptyMap();
+      }
+    };
+  }
+
+  /** Ad loader event listener that forwards ad playback state to a fake player. */
+  private static final class TestAdsLoaderListener implements AdsLoader.EventListener {
+
+    private final FakePlayer fakeExoPlayer;
+    private final Timeline contentTimeline;
+    private final long[][] adDurationsUs;
+
+    public AdPlaybackState adPlaybackState;
+
+    public TestAdsLoaderListener(
+        FakePlayer fakeExoPlayer, Timeline contentTimeline, long[][] adDurationsUs) {
+      this.fakeExoPlayer = fakeExoPlayer;
+      this.contentTimeline = contentTimeline;
+      this.adDurationsUs = adDurationsUs;
+    }
+
+    @Override
+    public void onAdPlaybackState(AdPlaybackState adPlaybackState) {
+      adPlaybackState = adPlaybackState.withAdDurationsUs(adDurationsUs);
+      this.adPlaybackState = adPlaybackState;
+      fakeExoPlayer.updateTimeline(new SinglePeriodAdTimeline(contentTimeline, adPlaybackState));
+    }
+
+    @Override
+    public void onAdLoadError(AdLoadException error, DataSpec dataSpec) {
+      assertThat(error.type).isNotEqualTo(AdLoadException.TYPE_UNEXPECTED);
+    }
+
+    @Override
+    public void onAdClicked() {
+      // Do nothing.
+    }
+
+    @Override
+    public void onAdTapped() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
new file mode 100644
index 0000000000..dd46d8a68b
--- /dev/null
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ima;
+
+import android.content.Context;
+import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
+import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
+import com.google.ads.interactivemedia.v3.api.AdsRequest;
+import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
+
+/** {@link ImaAdsLoader.ImaFactory} that returns provided instances from each getter, for tests. */
+final class SingletonImaFactory implements ImaAdsLoader.ImaFactory {
+
+  private final ImaSdkSettings imaSdkSettings;
+  private final AdsRenderingSettings adsRenderingSettings;
+  private final AdDisplayContainer adDisplayContainer;
+  private final AdsRequest adsRequest;
+  private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
+
+  public SingletonImaFactory(
+      ImaSdkSettings imaSdkSettings,
+      AdsRenderingSettings adsRenderingSettings,
+      AdDisplayContainer adDisplayContainer,
+      AdsRequest adsRequest,
+      com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader) {
+    this.imaSdkSettings = imaSdkSettings;
+    this.adsRenderingSettings = adsRenderingSettings;
+    this.adDisplayContainer = adDisplayContainer;
+    this.adsRequest = adsRequest;
+    this.adsLoader = adsLoader;
+  }
+
+  @Override
+  public ImaSdkSettings createImaSdkSettings() {
+    return imaSdkSettings;
+  }
+
+  @Override
+  public AdsRenderingSettings createAdsRenderingSettings() {
+    return adsRenderingSettings;
+  }
+
+  @Override
+  public AdDisplayContainer createAdDisplayContainer() {
+    return adDisplayContainer;
+  }
+
+  @Override
+  public AdsRequest createAdsRequest() {
+    return adsRequest;
+  }
+
+  @Override
+  public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
+      Context context, ImaSdkSettings imaSdkSettings) {
+    return adsLoader;
+  }
+}
diff --git a/extensions/ima/src/test/resources/robolectric.properties b/extensions/ima/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/extensions/ima/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/extensions/jobdispatcher/build.gradle b/extensions/jobdispatcher/build.gradle
index f4a8751c67..a0e3f8e0c8 100644
--- a/extensions/jobdispatcher/build.gradle
+++ b/extensions/jobdispatcher/build.gradle
@@ -20,6 +20,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
diff --git a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
index c6701da964..b7818546f9 100644
--- a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
+++ b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
@@ -18,17 +18,17 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
-import android.util.Log;
 import com.firebase.jobdispatcher.Constraint;
 import com.firebase.jobdispatcher.FirebaseJobDispatcher;
 import com.firebase.jobdispatcher.GooglePlayDriver;
 import com.firebase.jobdispatcher.Job;
-import com.firebase.jobdispatcher.Job.Builder;
 import com.firebase.jobdispatcher.JobParameters;
 import com.firebase.jobdispatcher.JobService;
 import com.firebase.jobdispatcher.Lifetime;
 import com.google.android.exoplayer2.scheduler.Requirements;
 import com.google.android.exoplayer2.scheduler.Scheduler;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -37,6 +37,7 @@
  *
  * <pre>{@literal
  * <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+ * <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
  *
  * <service
  *     android:name="com.google.android.exoplayer2.ext.jobdispatcher.JobDispatcherScheduler$JobDispatcherSchedulerService"
@@ -97,7 +98,7 @@ private static Job buildJob(
       String tag,
       String serviceAction,
       String servicePackage) {
-    Builder builder =
+    Job.Builder builder =
         dispatcher
             .newJobBuilder()
             .setService(JobDispatcherSchedulerService.class) // the JobService that will be called
@@ -146,11 +147,14 @@ private static void logd(String message) {
     public boolean onStartJob(JobParameters params) {
       logd("JobDispatcherSchedulerService is started");
       Bundle extras = params.getExtras();
+      Assertions.checkNotNull(extras, "Service started without extras.");
       Requirements requirements = new Requirements(extras.getInt(KEY_REQUIREMENTS));
       if (requirements.checkRequirements(this)) {
         logd("Requirements are met");
         String serviceAction = extras.getString(KEY_SERVICE_ACTION);
         String servicePackage = extras.getString(KEY_SERVICE_PACKAGE);
+        Assertions.checkNotNull(serviceAction, "Service action missing.");
+        Assertions.checkNotNull(servicePackage, "Service package missing.");
         Intent intent = new Intent(serviceAction).setPackage(servicePackage);
         logd("Starting service action: " + serviceAction + " package: " + servicePackage);
         Util.startForegroundService(this, intent);
diff --git a/extensions/leanback/build.gradle b/extensions/leanback/build.gradle
index dc187a5709..10bfef8e7c 100644
--- a/extensions/leanback/build.gradle
+++ b/extensions/leanback/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion 17
         targetSdkVersion project.ext.targetSdkVersion
diff --git a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
index 03f53c263f..0c9491bb1a 100644
--- a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
+++ b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
@@ -39,7 +39,7 @@
 import com.google.android.exoplayer2.video.VideoListener;
 
 /** Leanback {@code PlayerAdapter} implementation for {@link Player}. */
-public final class LeanbackPlayerAdapter extends PlayerAdapter {
+public final class LeanbackPlayerAdapter extends PlayerAdapter implements Runnable {
 
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.leanback");
@@ -49,12 +49,12 @@
   private final Player player;
   private final Handler handler;
   private final ComponentListener componentListener;
-  private final Runnable updateProgressRunnable;
+  private final int updatePeriodMs;
 
   private @Nullable PlaybackPreparer playbackPreparer;
   private ControlDispatcher controlDispatcher;
   private @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
-  private SurfaceHolderGlueHost surfaceHolderGlueHost;
+  private @Nullable SurfaceHolderGlueHost surfaceHolderGlueHost;
   private boolean hasSurface;
   private boolean lastNotifiedPreparedState;
 
@@ -70,18 +70,10 @@
   public LeanbackPlayerAdapter(Context context, Player player, final int updatePeriodMs) {
     this.context = context;
     this.player = player;
+    this.updatePeriodMs = updatePeriodMs;
     handler = new Handler();
     componentListener = new ComponentListener();
     controlDispatcher = new DefaultControlDispatcher();
-    updateProgressRunnable = new Runnable() {
-      @Override
-      public void run() {
-        Callback callback = getCallback();
-        callback.onCurrentPositionChanged(LeanbackPlayerAdapter.this);
-        callback.onBufferedPositionChanged(LeanbackPlayerAdapter.this);
-        handler.postDelayed(this, updatePeriodMs);
-      }
-    };
   }
 
   /**
@@ -138,7 +130,7 @@ public void onDetachedFromHost() {
       videoComponent.removeVideoListener(componentListener);
     }
     if (surfaceHolderGlueHost != null) {
-      surfaceHolderGlueHost.setSurfaceHolderCallback(null);
+      removeSurfaceHolderCallback(surfaceHolderGlueHost);
       surfaceHolderGlueHost = null;
     }
     hasSurface = false;
@@ -150,9 +142,9 @@ public void onDetachedFromHost() {
 
   @Override
   public void setProgressUpdatingEnabled(boolean enabled) {
-    handler.removeCallbacks(updateProgressRunnable);
+    handler.removeCallbacks(this);
     if (enabled) {
-      handler.post(updateProgressRunnable);
+      handler.post(this);
     }
   }
 
@@ -211,9 +203,19 @@ public boolean isPrepared() {
         && (surfaceHolderGlueHost == null || hasSurface);
   }
 
+  // Runnable implementation.
+
+  @Override
+  public void run() {
+    Callback callback = getCallback();
+    callback.onCurrentPositionChanged(this);
+    callback.onBufferedPositionChanged(this);
+    handler.postDelayed(this, updatePeriodMs);
+  }
+
   // Internal methods.
 
-  /* package */ void setVideoSurface(Surface surface) {
+  /* package */ void setVideoSurface(@Nullable Surface surface) {
     hasSurface = surface != null;
     Player.VideoComponent videoComponent = player.getVideoComponent();
     if (videoComponent != null) {
@@ -241,8 +243,13 @@ private void maybeNotifyPreparedStateChanged(Callback callback) {
     }
   }
 
-  private final class ComponentListener extends Player.DefaultEventListener
-      implements SurfaceHolder.Callback, VideoListener {
+  @SuppressWarnings("nullness:argument.type.incompatible")
+  private static void removeSurfaceHolderCallback(SurfaceHolderGlueHost surfaceHolderGlueHost) {
+    surfaceHolderGlueHost.setSurfaceHolderCallback(null);
+  }
+
+  private final class ComponentListener
+      implements Player.EventListener, SurfaceHolder.Callback, VideoListener {
 
     // SurfaceHolder.Callback implementation.
 
@@ -281,8 +288,8 @@ public void onPlayerError(ExoPlaybackException exception) {
     }
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest,
-        @TimelineChangeReason int reason) {
+    public void onTimelineChanged(
+        Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
       Callback callback = getCallback();
       callback.onDurationChanged(LeanbackPlayerAdapter.this);
       callback.onCurrentPositionChanged(LeanbackPlayerAdapter.this);
diff --git a/extensions/mediasession/build.gradle b/extensions/mediasession/build.gradle
index eaaf078b5c..5fb25c6382 100644
--- a/extensions/mediasession/build.gradle
+++ b/extensions/mediasession/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
@@ -26,7 +31,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-media-compat:' + supportLibraryVersion
+    api 'com.android.support:support-media-compat:' + supportLibraryVersion
 }
 
 ext {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
index ce597b45cd..7d983e14e9 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -127,7 +127,7 @@ public void onRewind(Player player) {
 
   @Override
   public void onStop(Player player) {
-    player.stop();
+    player.stop(true);
   }
 
   @Override
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 4bafaa4326..9323723601 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -37,8 +37,10 @@
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -46,25 +48,31 @@
 
 /**
  * Connects a {@link MediaSessionCompat} to a {@link Player}.
- * <p>
- * The connector listens for actions sent by the media session's controller and implements these
+ *
+ * <p>This connector does <em>not</em> call {@link MediaSessionCompat#setActive(boolean)}, and so
+ * application code is responsible for making the session active when desired. A session must be
+ * active for transport controls to be displayed (e.g. on the lock screen) and for it to receive
+ * media button events.
+ *
+ * <p>The connector listens for actions sent by the media session's controller and implements these
  * actions by calling appropriate player methods. The playback state of the media session is
  * automatically synced with the player. The connector can also be optionally extended by providing
  * various collaborators:
+ *
  * <ul>
- *   <li>Actions to initiate media playback ({@code PlaybackStateCompat#ACTION_PREPARE_*} and
- *   {@code PlaybackStateCompat#ACTION_PLAY_*}) can be handled by a {@link PlaybackPreparer} passed
- *   when calling {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}. Custom
- *   actions can be handled by passing one or more {@link CustomActionProvider}s in a similar way.
- *   </li>
+ *   <li>Actions to initiate media playback ({@code PlaybackStateCompat#ACTION_PREPARE_*} and {@code
+ *       PlaybackStateCompat#ACTION_PLAY_*}) can be handled by a {@link PlaybackPreparer} passed
+ *       when calling {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}. Custom
+ *       actions can be handled by passing one or more {@link CustomActionProvider}s in a similar
+ *       way.
  *   <li>To enable a media queue and navigation within it, you can set a {@link QueueNavigator} by
- *   calling {@link #setQueueNavigator(QueueNavigator)}. Use of {@link TimelineQueueNavigator} is
- *   recommended for most use cases.</li>
- *   <li>To enable editing of the media queue, you can set a {@link QueueEditor} by calling
- *   {@link #setQueueEditor(QueueEditor)}.</li>
+ *       calling {@link #setQueueNavigator(QueueNavigator)}. Use of {@link TimelineQueueNavigator}
+ *       is recommended for most use cases.
+ *   <li>To enable editing of the media queue, you can set a {@link QueueEditor} by calling {@link
+ *       #setQueueEditor(QueueEditor)}.
  *   <li>An {@link ErrorMessageProvider} for providing human readable error messages and
- *   corresponding error codes can be set by calling
- *   {@link #setErrorMessageProvider(ErrorMessageProvider)}.</li>
+ *       corresponding error codes can be set by calling {@link
+ *       #setErrorMessageProvider(ErrorMessageProvider)}.
  * </ul>
  */
 public final class MediaSessionConnector {
@@ -74,35 +82,30 @@
   }
 
   /**
-   * The default repeat toggle modes which is the bitmask of
-   * {@link RepeatModeUtil#REPEAT_TOGGLE_MODE_ONE} and
-   * {@link RepeatModeUtil#REPEAT_TOGGLE_MODE_ALL}.
+   * The default repeat toggle modes which is the bitmask of {@link
+   * RepeatModeUtil#REPEAT_TOGGLE_MODE_ONE} and {@link RepeatModeUtil#REPEAT_TOGGLE_MODE_ALL}.
    */
   public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
       RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE | RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL;
+
   public static final String EXTRAS_PITCH = "EXO_PITCH";
-  private static final int BASE_MEDIA_SESSION_FLAGS = MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS
-      | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS;
-  private static final int EDITOR_MEDIA_SESSION_FLAGS = BASE_MEDIA_SESSION_FLAGS
-      | MediaSessionCompat.FLAG_HANDLES_QUEUE_COMMANDS;
+  private static final int BASE_MEDIA_SESSION_FLAGS =
+      MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS
+          | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS;
+  private static final int EDITOR_MEDIA_SESSION_FLAGS =
+      BASE_MEDIA_SESSION_FLAGS | MediaSessionCompat.FLAG_HANDLES_QUEUE_COMMANDS;
 
-  /**
-   * Receiver of media commands sent by a media controller.
-   */
+  /** Receiver of media commands sent by a media controller. */
   public interface CommandReceiver {
     /**
      * Returns the commands the receiver handles, or {@code null} if no commands need to be handled.
      */
     String[] getCommands();
-    /**
-     * See {@link MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}. */
     void onCommand(Player player, String command, Bundle extras, ResultReceiver cb);
   }
 
-  /**
-   * Interface to which playback preparation actions are delegated.
-   */
+  /** Interface to which playback preparation actions are delegated. */
   public interface PlaybackPreparer extends CommandReceiver {
 
     long ACTIONS =
@@ -127,96 +130,77 @@
      * @return The bitmask of the supported media actions.
      */
     long getSupportedPrepareActions();
-    /**
-     * See {@link MediaSessionCompat.Callback#onPrepare()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onPrepare()}. */
     void onPrepare();
-    /**
-     * See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}. */
     void onPrepareFromMediaId(String mediaId, Bundle extras);
-    /**
-     * See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}. */
     void onPrepareFromSearch(String query, Bundle extras);
-    /**
-     * See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}. */
     void onPrepareFromUri(Uri uri, Bundle extras);
   }
 
-  /**
-   * Interface to which playback actions are delegated.
-   */
+  /** Interface to which playback actions are delegated. */
   public interface PlaybackController extends CommandReceiver {
 
-    long ACTIONS = PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PLAY
-        | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_SEEK_TO
-        | PlaybackStateCompat.ACTION_FAST_FORWARD | PlaybackStateCompat.ACTION_REWIND
-        | PlaybackStateCompat.ACTION_STOP | PlaybackStateCompat.ACTION_SET_REPEAT_MODE
-        | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE;
+    long ACTIONS =
+        PlaybackStateCompat.ACTION_PLAY_PAUSE
+            | PlaybackStateCompat.ACTION_PLAY
+            | PlaybackStateCompat.ACTION_PAUSE
+            | PlaybackStateCompat.ACTION_SEEK_TO
+            | PlaybackStateCompat.ACTION_FAST_FORWARD
+            | PlaybackStateCompat.ACTION_REWIND
+            | PlaybackStateCompat.ACTION_STOP
+            | PlaybackStateCompat.ACTION_SET_REPEAT_MODE
+            | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE;
 
     /**
      * Returns the actions which are supported by the controller. The supported actions must be a
-     * bitmask combined out of {@link PlaybackStateCompat#ACTION_PLAY_PAUSE},
-     * {@link PlaybackStateCompat#ACTION_PLAY}, {@link PlaybackStateCompat#ACTION_PAUSE},
-     * {@link PlaybackStateCompat#ACTION_SEEK_TO}, {@link PlaybackStateCompat#ACTION_FAST_FORWARD},
-     * {@link PlaybackStateCompat#ACTION_REWIND}, {@link PlaybackStateCompat#ACTION_STOP},
-     * {@link PlaybackStateCompat#ACTION_SET_REPEAT_MODE} and
-     * {@link PlaybackStateCompat#ACTION_SET_SHUFFLE_MODE}.
+     * bitmask combined out of {@link PlaybackStateCompat#ACTION_PLAY_PAUSE}, {@link
+     * PlaybackStateCompat#ACTION_PLAY}, {@link PlaybackStateCompat#ACTION_PAUSE}, {@link
+     * PlaybackStateCompat#ACTION_SEEK_TO}, {@link PlaybackStateCompat#ACTION_FAST_FORWARD}, {@link
+     * PlaybackStateCompat#ACTION_REWIND}, {@link PlaybackStateCompat#ACTION_STOP}, {@link
+     * PlaybackStateCompat#ACTION_SET_REPEAT_MODE} and {@link
+     * PlaybackStateCompat#ACTION_SET_SHUFFLE_MODE}.
      *
      * @param player The player.
      * @return The bitmask of the supported media actions.
      */
     long getSupportedPlaybackActions(@Nullable Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onPlay()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onPlay()}. */
     void onPlay(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onPause()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onPause()}. */
     void onPause(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSeekTo(long)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onSeekTo(long)}. */
     void onSeekTo(Player player, long position);
-    /**
-     * See {@link MediaSessionCompat.Callback#onFastForward()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onFastForward()}. */
     void onFastForward(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onRewind()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onRewind()}. */
     void onRewind(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onStop()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onStop()}. */
     void onStop(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSetShuffleMode(int)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onSetShuffleMode(int)}. */
     void onSetShuffleMode(Player player, int shuffleMode);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSetRepeatMode(int)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onSetRepeatMode(int)}. */
     void onSetRepeatMode(Player player, int repeatMode);
   }
 
   /**
-   * Handles queue navigation actions, and updates the media session queue by calling
-   * {@code MediaSessionCompat.setQueue()}.
+   * Handles queue navigation actions, and updates the media session queue by calling {@code
+   * MediaSessionCompat.setQueue()}.
    */
   public interface QueueNavigator extends CommandReceiver {
 
-    long ACTIONS = PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM
-        | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
+    long ACTIONS =
+        PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM
+            | PlaybackStateCompat.ACTION_SKIP_TO_NEXT
+            | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
 
     /**
      * Returns the actions which are supported by the navigator. The supported actions must be a
-     * bitmask combined out of {@link PlaybackStateCompat#ACTION_SKIP_TO_QUEUE_ITEM},
-     * {@link PlaybackStateCompat#ACTION_SKIP_TO_NEXT},
-     * {@link PlaybackStateCompat#ACTION_SKIP_TO_PREVIOUS}.
+     * bitmask combined out of {@link PlaybackStateCompat#ACTION_SKIP_TO_QUEUE_ITEM}, {@link
+     * PlaybackStateCompat#ACTION_SKIP_TO_NEXT}, {@link
+     * PlaybackStateCompat#ACTION_SKIP_TO_PREVIOUS}.
      *
      * @param player The {@link Player}.
      * @return The bitmask of the supported media actions.
@@ -235,34 +219,26 @@
      */
     void onCurrentWindowIndexChanged(Player player);
     /**
-     * Gets the id of the currently active queue item, or
-     * {@link MediaSessionCompat.QueueItem#UNKNOWN_ID} if the active item is unknown.
-     * <p>
-     * To let the connector publish metadata for the active queue item, the queue item with the
-     * returned id must be available in the list of items returned by
-     * {@link MediaControllerCompat#getQueue()}.
+     * Gets the id of the currently active queue item, or {@link
+     * MediaSessionCompat.QueueItem#UNKNOWN_ID} if the active item is unknown.
+     *
+     * <p>To let the connector publish metadata for the active queue item, the queue item with the
+     * returned id must be available in the list of items returned by {@link
+     * MediaControllerCompat#getQueue()}.
      *
      * @param player The player connected to the media session.
      * @return The id of the active queue item.
      */
     long getActiveQueueItemId(@Nullable Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSkipToPrevious()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onSkipToPrevious()}. */
     void onSkipToPrevious(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSkipToQueueItem(long)}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onSkipToQueueItem(long)}. */
     void onSkipToQueueItem(Player player, long id);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSkipToNext()}.
-     */
+    /** See {@link MediaSessionCompat.Callback#onSkipToNext()}. */
     void onSkipToNext(Player player);
   }
 
-  /**
-   * Handles media session queue edits.
-   */
+  /** Handles media session queue edits. */
   public interface QueueEditor extends CommandReceiver {
 
     /**
@@ -270,8 +246,8 @@
      */
     void onAddQueueItem(Player player, MediaDescriptionCompat description);
     /**
-     * See {@link MediaSessionCompat.Callback#onAddQueueItem(MediaDescriptionCompat description,
-     * int index)}.
+     * See {@link MediaSessionCompat.Callback#onAddQueueItem(MediaDescriptionCompat description, int
+     * index)}.
      */
     void onAddQueueItem(Player player, MediaDescriptionCompat description, int index);
     /**
@@ -279,10 +255,6 @@
      * description)}.
      */
     void onRemoveQueueItem(Player player, MediaDescriptionCompat description);
-    /**
-     * See {@link MediaSessionCompat.Callback#onRemoveQueueItemAt(int index)}.
-     */
-    void onRemoveQueueItemAt(Player player, int index);
   }
 
   /** Callback receiving a user rating for the active media item. */
@@ -292,6 +264,9 @@
 
     /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat)}. */
     void onSetRating(Player player, RatingCompat rating);
+    
+    /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat, Bundle)}. */
+    void onSetRating(Player player, RatingCompat rating, Bundle extras);
   }
 
   /**
@@ -308,43 +283,49 @@
     void onCustomAction(String action, Bundle extras);
 
     /**
-     * Returns a {@link PlaybackStateCompat.CustomAction} which will be published to the
-     * media session by the connector or {@code null} if this action should not be published at the
-     * given player state.
+     * Returns a {@link PlaybackStateCompat.CustomAction} which will be published to the media
+     * session by the connector or {@code null} if this action should not be published at the given
+     * player state.
      *
      * @return The custom action to be included in the session playback state or {@code null}.
      */
     PlaybackStateCompat.CustomAction getCustomAction();
   }
 
-  /**
-   * The wrapped {@link MediaSessionCompat}.
-   */
+  /** Provides a {@link MediaMetadataCompat} for a given player state. */
+  public interface MediaMetadataProvider {
+    /**
+     * Gets the {@link MediaMetadataCompat} to be published to the session.
+     *
+     * @param player The player for which to provide metadata.
+     * @return The {@link MediaMetadataCompat} to be published to the session.
+     */
+    MediaMetadataCompat getMetadata(Player player);
+  }
+
+  /** The wrapped {@link MediaSessionCompat}. */
   public final MediaSessionCompat mediaSession;
 
-  private final MediaControllerCompat mediaController;
-  private final Handler handler;
-  private final boolean doMaintainMetadata;
+  private @Nullable final MediaMetadataProvider mediaMetadataProvider;
   private final ExoPlayerEventListener exoPlayerEventListener;
   private final MediaSessionCallback mediaSessionCallback;
   private final PlaybackController playbackController;
-  private final String metadataExtrasPrefix;
   private final Map<String, CommandReceiver> commandMap;
 
   private Player player;
   private CustomActionProvider[] customActionProviders;
   private Map<String, CustomActionProvider> customActionMap;
   private @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
+  private @Nullable Pair<Integer, CharSequence> customError;
   private PlaybackPreparer playbackPreparer;
   private QueueNavigator queueNavigator;
   private QueueEditor queueEditor;
   private RatingCallback ratingCallback;
 
   /**
-   * Creates an instance. Must be called on the same thread that is used to construct the player
-   * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.
-   * <p>
-   * Equivalent to {@code MediaSessionConnector(mediaSession, new DefaultPlaybackController())}.
+   * Creates an instance.
+   *
+   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, new DefaultPlaybackController())}.
    *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
    */
@@ -353,46 +334,67 @@ public MediaSessionConnector(MediaSessionCompat mediaSession) {
   }
 
   /**
-   * Creates an instance. Must be called on the same thread that is used to construct the player
-   * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.
+   * Creates an instance.
    *
-   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, true, null)}.
+   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, new
+   * DefaultMediaMetadataProvider(mediaSession.getController(), null))}.
    *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
    * @param playbackController A {@link PlaybackController} for handling playback actions.
    */
   public MediaSessionConnector(
       MediaSessionCompat mediaSession, PlaybackController playbackController) {
-    this(mediaSession, playbackController, true, null);
+    this(
+        mediaSession,
+        playbackController,
+        new DefaultMediaMetadataProvider(mediaSession.getController(), null));
   }
 
   /**
-   * Creates an instance. Must be called on the same thread that is used to construct the player
-   * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.
+   * Creates an instance.
    *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
    * @param playbackController A {@link PlaybackController} for handling playback actions, or {@code
    *     null} if the connector should handle playback actions directly.
-   * @param doMaintainMetadata Whether the connector should maintain the metadata of the session. If
-   *     {@code false}, you need to maintain the metadata of the media session yourself (provide at
-   *     least the duration to allow clients to show a progress bar).
+   * @param doMaintainMetadata Whether the connector should maintain the metadata of the session.
    * @param metadataExtrasPrefix A string to prefix extra keys which are propagated from the active
    *     queue item to the session metadata.
+   * @deprecated Use {@link MediaSessionConnector#MediaSessionConnector(MediaSessionCompat,
+   *     PlaybackController, MediaMetadataProvider)}.
    */
+  @Deprecated
   public MediaSessionConnector(
       MediaSessionCompat mediaSession,
-      PlaybackController playbackController,
+      @Nullable PlaybackController playbackController,
       boolean doMaintainMetadata,
       @Nullable String metadataExtrasPrefix) {
+    this(
+        mediaSession,
+        playbackController,
+        doMaintainMetadata
+            ? new DefaultMediaMetadataProvider(mediaSession.getController(), metadataExtrasPrefix)
+            : null);
+  }
+
+  /**
+   * Creates an instance.
+   *
+   * @param mediaSession The {@link MediaSessionCompat} to connect to.
+   * @param playbackController A {@link PlaybackController} for handling playback actions, or {@code
+   *     null} if the connector should handle playback actions directly.
+   * @param mediaMetadataProvider A {@link MediaMetadataProvider} for providing a custom metadata
+   *     object to be published to the media session, or {@code null} if metadata shouldn't be
+   *     published.
+   */
+  public MediaSessionConnector(
+      MediaSessionCompat mediaSession,
+      @Nullable PlaybackController playbackController,
+      @Nullable MediaMetadataProvider mediaMetadataProvider) {
     this.mediaSession = mediaSession;
-    this.playbackController = playbackController != null ? playbackController
-        : new DefaultPlaybackController();
-    this.metadataExtrasPrefix = metadataExtrasPrefix != null ? metadataExtrasPrefix : "";
-    this.handler = new Handler(Looper.myLooper() != null ? Looper.myLooper()
-        : Looper.getMainLooper());
-    this.doMaintainMetadata = doMaintainMetadata;
+    this.playbackController =
+        playbackController != null ? playbackController : new DefaultPlaybackController();
+    this.mediaMetadataProvider = mediaMetadataProvider;
     mediaSession.setFlags(BASE_MEDIA_SESSION_FLAGS);
-    mediaController = mediaSession.getController();
     mediaSessionCallback = new MediaSessionCallback();
     exoPlayerEventListener = new ExoPlayerEventListener();
     customActionMap = Collections.emptyMap();
@@ -401,20 +403,23 @@ public MediaSessionConnector(
   }
 
   /**
-   * Sets the player to be connected to the media session.
+   * Sets the player to be connected to the media session. Must be called on the same thread that is
+   * used to access the player.
    *
    * <p>The order in which any {@link CustomActionProvider}s are passed determines the order of the
    * actions published with the playback state of the session.
    *
-   * @param player The player to be connected to the {@code MediaSession}.
+   * @param player The player to be connected to the {@code MediaSession}, or {@code null} to
+   *     disconnect the current player.
    * @param playbackPreparer An optional {@link PlaybackPreparer} for preparing the player.
    * @param customActionProviders Optional {@link CustomActionProvider}s to publish and handle
    *     custom actions.
    */
   public void setPlayer(
-      Player player,
+      @Nullable Player player,
       @Nullable PlaybackPreparer playbackPreparer,
       CustomActionProvider... customActionProviders) {
+    Assertions.checkArgument(player == null || player.getApplicationLooper() == Looper.myLooper());
     if (this.player != null) {
       this.player.removeListener(exoPlayerEventListener);
       mediaSession.setCallback(null);
@@ -425,14 +430,17 @@ public void setPlayer(
     this.playbackPreparer = playbackPreparer;
     registerCommandReceiver(playbackPreparer);
 
-    this.customActionProviders = (player != null && customActionProviders != null)
-        ? customActionProviders : new CustomActionProvider[0];
+    this.customActionProviders =
+        (player != null && customActionProviders != null)
+            ? customActionProviders
+            : new CustomActionProvider[0];
     if (player != null) {
+      Handler handler = new Handler(Util.getLooper());
       mediaSession.setCallback(mediaSessionCallback, handler);
       player.addListener(exoPlayerEventListener);
     }
-    updateMediaSessionPlaybackState();
-    updateMediaSessionMetadata();
+    invalidateMediaSessionPlaybackState();
+    invalidateMediaSessionMetadata();
   }
 
   /**
@@ -444,7 +452,7 @@ public void setErrorMessageProvider(
       @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider) {
     if (this.errorMessageProvider != errorMessageProvider) {
       this.errorMessageProvider = errorMessageProvider;
-      updateMediaSessionPlaybackState();
+      invalidateMediaSessionPlaybackState();
     }
   }
 
@@ -490,23 +498,50 @@ public void setRatingCallback(RatingCallback ratingCallback) {
     }
   }
 
-  private void registerCommandReceiver(CommandReceiver commandReceiver) {
-    if (commandReceiver != null && commandReceiver.getCommands() != null) {
-      for (String command : commandReceiver.getCommands()) {
-        commandMap.put(command, commandReceiver);
-      }
-    }
+  /**
+   * Sets a custom error on the session.
+   *
+   * <p>This sets the error code via {@link PlaybackStateCompat.Builder#setErrorMessage(int,
+   * CharSequence)}. By default, the error code will be set to {@link
+   * PlaybackStateCompat#ERROR_CODE_APP_ERROR}.
+   *
+   * @param message The error string to report or {@code null} to clear the error.
+   */
+  public void setCustomErrorMessage(@Nullable CharSequence message) {
+    int code = (message == null) ? 0 : PlaybackStateCompat.ERROR_CODE_APP_ERROR;
+    setCustomErrorMessage(message, code);
   }
 
-  private void unregisterCommandReceiver(CommandReceiver commandReceiver) {
-    if (commandReceiver != null && commandReceiver.getCommands() != null) {
-      for (String command : commandReceiver.getCommands()) {
-        commandMap.remove(command);
-      }
+  /**
+   * Sets a custom error on the session.
+   *
+   * @param message The error string to report or {@code null} to clear the error.
+   * @param code The error code to report. Ignored when {@code message} is {@code null}.
+   */
+  public void setCustomErrorMessage(@Nullable CharSequence message, int code) {
+    customError = (message == null) ? null : new Pair<>(code, message);
+    invalidateMediaSessionPlaybackState();
+  }
+
+  /**
+   * Updates the metadata of the media session.
+   *
+   * <p>Apps normally only need to call this method when the backing data for a given media item has
+   * changed and the metadata should be updated immediately.
+   */
+  public final void invalidateMediaSessionMetadata() {
+    if (mediaMetadataProvider != null && player != null) {
+      mediaSession.setMetadata(mediaMetadataProvider.getMetadata(player));
     }
   }
 
-  private void updateMediaSessionPlaybackState() {
+  /**
+   * Updates the playback state of the media session.
+   *
+   * <p>Apps normally only need to call this method when the custom actions provided by a {@link
+   * CustomActionProvider} changed and the playback state needs to be updated immediately.
+   */
+  public final void invalidateMediaSessionPlaybackState() {
     PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
     if (player == null) {
       builder.setActions(buildPlaybackActions()).setState(PlaybackStateCompat.STATE_NONE, 0, 0, 0);
@@ -527,36 +562,74 @@ private void updateMediaSessionPlaybackState() {
     int playbackState = player.getPlaybackState();
     ExoPlaybackException playbackError =
         playbackState == Player.STATE_IDLE ? player.getPlaybackError() : null;
+    boolean reportError = playbackError != null || customError != null;
     int sessionPlaybackState =
-        playbackError != null
+        reportError
             ? PlaybackStateCompat.STATE_ERROR
             : mapPlaybackState(player.getPlaybackState(), player.getPlayWhenReady());
-    if (playbackError != null && errorMessageProvider != null) {
+    if (customError != null) {
+      builder.setErrorMessage(customError.first, customError.second);
+    } else if (playbackError != null && errorMessageProvider != null) {
       Pair<Integer, String> message = errorMessageProvider.getErrorMessage(playbackError);
       builder.setErrorMessage(message.first, message.second);
     }
-    long activeQueueItemId = queueNavigator != null ? queueNavigator.getActiveQueueItemId(player)
-        : MediaSessionCompat.QueueItem.UNKNOWN_ID;
+    long activeQueueItemId =
+        queueNavigator != null
+            ? queueNavigator.getActiveQueueItemId(player)
+            : MediaSessionCompat.QueueItem.UNKNOWN_ID;
     Bundle extras = new Bundle();
     extras.putFloat(EXTRAS_PITCH, player.getPlaybackParameters().pitch);
-    builder.setActions(buildPlaybackActions())
+    builder
+        .setActions(buildPlaybackActions())
         .setActiveQueueItemId(activeQueueItemId)
         .setBufferedPosition(player.getBufferedPosition())
-        .setState(sessionPlaybackState, player.getCurrentPosition(),
-            player.getPlaybackParameters().speed, SystemClock.elapsedRealtime())
+        .setState(
+            sessionPlaybackState,
+            player.getCurrentPosition(),
+            player.getPlaybackParameters().speed,
+            SystemClock.elapsedRealtime())
         .setExtras(extras);
     mediaSession.setPlaybackState(builder.build());
   }
 
+  /**
+   * Updates the queue of the media session by calling {@link
+   * QueueNavigator#onTimelineChanged(Player)}.
+   *
+   * <p>Apps normally only need to call this method when the backing data for a given queue item has
+   * changed and the queue should be updated immediately.
+   */
+  public final void invalidateMediaSessionQueue() {
+    if (queueNavigator != null && player != null) {
+      queueNavigator.onTimelineChanged(player);
+    }
+  }
+
+  private void registerCommandReceiver(CommandReceiver commandReceiver) {
+    if (commandReceiver != null && commandReceiver.getCommands() != null) {
+      for (String command : commandReceiver.getCommands()) {
+        commandMap.put(command, commandReceiver);
+      }
+    }
+  }
+
+  private void unregisterCommandReceiver(CommandReceiver commandReceiver) {
+    if (commandReceiver != null && commandReceiver.getCommands() != null) {
+      for (String command : commandReceiver.getCommands()) {
+        commandMap.remove(command);
+      }
+    }
+  }
+
   private long buildPlaybackActions() {
-    long actions = (PlaybackController.ACTIONS
-        & playbackController.getSupportedPlaybackActions(player));
+    long actions =
+        (PlaybackController.ACTIONS & playbackController.getSupportedPlaybackActions(player));
     if (playbackPreparer != null) {
       actions |= (PlaybackPreparer.ACTIONS & playbackPreparer.getSupportedPrepareActions());
     }
     if (queueNavigator != null) {
-      actions |= (QueueNavigator.ACTIONS & queueNavigator.getSupportedQueueNavigatorActions(
-          player));
+      actions |=
+          (QueueNavigator.ACTIONS & queueNavigator.getSupportedQueueNavigatorActions(player));
     }
     if (ratingCallback != null) {
       actions |= RatingCallback.ACTIONS;
@@ -564,17 +637,79 @@ private long buildPlaybackActions() {
     return actions;
   }
 
-  private void updateMediaSessionMetadata() {
-    if (doMaintainMetadata) {
+  private int mapPlaybackState(int exoPlayerPlaybackState, boolean playWhenReady) {
+    switch (exoPlayerPlaybackState) {
+      case Player.STATE_BUFFERING:
+        return PlaybackStateCompat.STATE_BUFFERING;
+      case Player.STATE_READY:
+        return playWhenReady ? PlaybackStateCompat.STATE_PLAYING : PlaybackStateCompat.STATE_PAUSED;
+      case Player.STATE_ENDED:
+        return PlaybackStateCompat.STATE_PAUSED;
+      default:
+        return PlaybackStateCompat.STATE_NONE;
+    }
+  }
+
+  private boolean canDispatchToPlaybackPreparer(long action) {
+    return playbackPreparer != null
+        && (playbackPreparer.getSupportedPrepareActions() & PlaybackPreparer.ACTIONS & action) != 0;
+  }
+
+  private boolean canDispatchToRatingCallback(long action) {
+    return ratingCallback != null && (RatingCallback.ACTIONS & action) != 0;
+  }
+
+  private boolean canDispatchToPlaybackController(long action) {
+    return (playbackController.getSupportedPlaybackActions(player)
+            & PlaybackController.ACTIONS
+            & action)
+        != 0;
+  }
+
+  private boolean canDispatchToQueueNavigator(long action) {
+    return queueNavigator != null
+        && (queueNavigator.getSupportedQueueNavigatorActions(player)
+                & QueueNavigator.ACTIONS
+                & action)
+            != 0;
+  }
+
+  /**
+   * Provides a default {@link MediaMetadataCompat} with properties and extras propagated from the
+   * active queue item to the session metadata.
+   */
+  public static final class DefaultMediaMetadataProvider implements MediaMetadataProvider {
+
+    private final MediaControllerCompat mediaController;
+    private final String metadataExtrasPrefix;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param mediaController The {@link MediaControllerCompat}.
+     * @param metadataExtrasPrefix A string to prefix extra keys which are propagated from the
+     *     active queue item to the session metadata.
+     */
+    public DefaultMediaMetadataProvider(
+        MediaControllerCompat mediaController, @Nullable String metadataExtrasPrefix) {
+      this.mediaController = mediaController;
+      this.metadataExtrasPrefix = metadataExtrasPrefix != null ? metadataExtrasPrefix : "";
+    }
+
+    @Override
+    public MediaMetadataCompat getMetadata(Player player) {
+      if (player.getCurrentTimeline().isEmpty()) {
+        return null;
+      }
       MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
-      if (player != null && player.isPlayingAd()) {
+      if (player.isPlayingAd()) {
         builder.putLong(MediaMetadataCompat.METADATA_KEY_ADVERTISEMENT, 1);
       }
-      builder.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, player == null ? 0
-          : player.getDuration() == C.TIME_UNSET ? -1 : player.getDuration());
-
-      if (queueNavigator != null) {
-        long activeQueueItemId = queueNavigator.getActiveQueueItemId(player);
+      builder.putLong(
+          MediaMetadataCompat.METADATA_KEY_DURATION,
+          player.getDuration() == C.TIME_UNSET ? -1 : player.getDuration());
+      long activeQueueItemId = mediaController.getPlaybackState().getActiveQueueItemId();
+      if (activeQueueItemId != MediaSessionCompat.QueueItem.UNKNOWN_ID) {
         List<MediaSessionCompat.QueueItem> queue = mediaController.getQueue();
         for (int i = 0; queue != null && i < queue.size(); i++) {
           MediaSessionCompat.QueueItem queueItem = queue.get(i);
@@ -605,109 +740,87 @@ private void updateMediaSessionMetadata() {
               builder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_TITLE, title);
             }
             if (description.getSubtitle() != null) {
-              builder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_SUBTITLE,
+              builder.putString(
+                  MediaMetadataCompat.METADATA_KEY_DISPLAY_SUBTITLE,
                   String.valueOf(description.getSubtitle()));
             }
             if (description.getDescription() != null) {
-              builder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_DESCRIPTION,
+              builder.putString(
+                  MediaMetadataCompat.METADATA_KEY_DISPLAY_DESCRIPTION,
                   String.valueOf(description.getDescription()));
             }
             if (description.getIconBitmap() != null) {
-              builder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON,
-                  description.getIconBitmap());
+              builder.putBitmap(
+                  MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, description.getIconBitmap());
             }
             if (description.getIconUri() != null) {
-              builder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON_URI,
+              builder.putString(
+                  MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON_URI,
                   String.valueOf(description.getIconUri()));
             }
             if (description.getMediaId() != null) {
-              builder.putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID,
+              builder.putString(
+                  MediaMetadataCompat.METADATA_KEY_MEDIA_ID,
                   String.valueOf(description.getMediaId()));
             }
             if (description.getMediaUri() != null) {
-              builder.putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI,
+              builder.putString(
+                  MediaMetadataCompat.METADATA_KEY_MEDIA_URI,
                   String.valueOf(description.getMediaUri()));
             }
             break;
           }
         }
       }
-      mediaSession.setMetadata(builder.build());
-    }
-  }
-
-  private int mapPlaybackState(int exoPlayerPlaybackState, boolean playWhenReady) {
-    switch (exoPlayerPlaybackState) {
-      case Player.STATE_BUFFERING:
-        return PlaybackStateCompat.STATE_BUFFERING;
-      case Player.STATE_READY:
-        return playWhenReady ? PlaybackStateCompat.STATE_PLAYING : PlaybackStateCompat.STATE_PAUSED;
-      case Player.STATE_ENDED:
-        return PlaybackStateCompat.STATE_PAUSED;
-      default:
-        return PlaybackStateCompat.STATE_NONE;
+      return builder.build();
     }
   }
 
-  private boolean canDispatchToPlaybackPreparer(long action) {
-    return playbackPreparer != null && (playbackPreparer.getSupportedPrepareActions()
-        & PlaybackPreparer.ACTIONS & action) != 0;
-  }
-
-  private boolean canDispatchToRatingCallback(long action) {
-    return ratingCallback != null && (RatingCallback.ACTIONS & action) != 0;
-  }
-
-  private boolean canDispatchToPlaybackController(long action) {
-    return (playbackController.getSupportedPlaybackActions(player)
-        & PlaybackController.ACTIONS & action) != 0;
-  }
-
-  private boolean canDispatchToQueueNavigator(long action) {
-    return queueNavigator != null && (queueNavigator.getSupportedQueueNavigatorActions(player)
-        & QueueNavigator.ACTIONS & action) != 0;
-  }
-
-  private class ExoPlayerEventListener extends Player.DefaultEventListener {
+  private class ExoPlayerEventListener implements Player.EventListener {
 
     private int currentWindowIndex;
     private int currentWindowCount;
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest,
-        @Player.TimelineChangeReason int reason) {
+    public void onTimelineChanged(
+        Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
       int windowCount = player.getCurrentTimeline().getWindowCount();
       int windowIndex = player.getCurrentWindowIndex();
       if (queueNavigator != null) {
         queueNavigator.onTimelineChanged(player);
-        updateMediaSessionPlaybackState();
+        invalidateMediaSessionPlaybackState();
       } else if (currentWindowCount != windowCount || currentWindowIndex != windowIndex) {
         // active queue item and queue navigation actions may need to be updated
-        updateMediaSessionPlaybackState();
+        invalidateMediaSessionPlaybackState();
       }
       currentWindowCount = windowCount;
       currentWindowIndex = windowIndex;
-      updateMediaSessionMetadata();
+      invalidateMediaSessionMetadata();
     }
 
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      updateMediaSessionPlaybackState();
+      invalidateMediaSessionPlaybackState();
     }
 
     @Override
     public void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
-      mediaSession.setRepeatMode(repeatMode == Player.REPEAT_MODE_ONE
-          ? PlaybackStateCompat.REPEAT_MODE_ONE : repeatMode == Player.REPEAT_MODE_ALL
-          ? PlaybackStateCompat.REPEAT_MODE_ALL : PlaybackStateCompat.REPEAT_MODE_NONE);
-      updateMediaSessionPlaybackState();
+      mediaSession.setRepeatMode(
+          repeatMode == Player.REPEAT_MODE_ONE
+              ? PlaybackStateCompat.REPEAT_MODE_ONE
+              : repeatMode == Player.REPEAT_MODE_ALL
+                  ? PlaybackStateCompat.REPEAT_MODE_ALL
+                  : PlaybackStateCompat.REPEAT_MODE_NONE);
+      invalidateMediaSessionPlaybackState();
     }
 
     @Override
     public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
-      mediaSession.setShuffleMode(shuffleModeEnabled ? PlaybackStateCompat.SHUFFLE_MODE_ALL
-          : PlaybackStateCompat.SHUFFLE_MODE_NONE);
-      updateMediaSessionPlaybackState();
+      mediaSession.setShuffleMode(
+          shuffleModeEnabled
+              ? PlaybackStateCompat.SHUFFLE_MODE_ALL
+              : PlaybackStateCompat.SHUFFLE_MODE_NONE);
+      invalidateMediaSessionPlaybackState();
     }
 
     @Override
@@ -717,16 +830,19 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
           queueNavigator.onCurrentWindowIndexChanged(player);
         }
         currentWindowIndex = player.getCurrentWindowIndex();
-        updateMediaSessionMetadata();
+        // Update playback state after queueNavigator.onCurrentWindowIndexChanged has been called
+        // and before updating metadata.
+        invalidateMediaSessionPlaybackState();
+        invalidateMediaSessionMetadata();
+        return;
       }
-      updateMediaSessionPlaybackState();
+      invalidateMediaSessionPlaybackState();
     }
 
     @Override
     public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      updateMediaSessionPlaybackState();
+      invalidateMediaSessionPlaybackState();
     }
-
   }
 
   private class MediaSessionCallback extends MediaSessionCompat.Callback {
@@ -813,7 +929,7 @@ public void onCustomAction(@NonNull String action, @Nullable Bundle extras) {
       Map<String, CustomActionProvider> actionMap = customActionMap;
       if (actionMap.containsKey(action)) {
         actionMap.get(action).onCustomAction(action, extras);
-        updateMediaSessionPlaybackState();
+        invalidateMediaSessionPlaybackState();
       }
     }
 
@@ -894,6 +1010,13 @@ public void onSetRating(RatingCompat rating) {
         ratingCallback.onSetRating(player, rating);
       }
     }
+    
+    @Override
+    public void onSetRating(RatingCompat rating, Bundle extras) {
+      if (canDispatchToRatingCallback(PlaybackStateCompat.ACTION_SET_RATING)) {
+        ratingCallback.onSetRating(player, rating, extras);
+      }
+    }
 
     @Override
     public void onAddQueueItem(MediaDescriptionCompat description) {
@@ -915,14 +1038,5 @@ public void onRemoveQueueItem(MediaDescriptionCompat description) {
         queueEditor.onRemoveQueueItem(player, description);
       }
     }
-
-    @Override
-    public void onRemoveQueueItemAt(int index) {
-      if (queueEditor != null) {
-        queueEditor.onRemoveQueueItemAt(player, index);
-      }
-    }
-
   }
-
 }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
index 1db5889e00..057f59f62c 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
index 853750077d..7c00fcdf17 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,13 +64,6 @@
    * {@link MediaSessionConnector}.
    */
   public interface QueueDataAdapter {
-    /**
-     * Gets the {@link MediaDescriptionCompat} for a {@code position}.
-     *
-     * @param position The position in the queue for which to provide a description.
-     * @return A {@link MediaDescriptionCompat}.
-     */
-    MediaDescriptionCompat getMediaDescription(int position);
     /**
      * Adds a {@link MediaDescriptionCompat} at the given {@code position}.
      *
@@ -184,18 +177,13 @@ public void onRemoveQueueItem(Player player, MediaDescriptionCompat description)
     List<MediaSessionCompat.QueueItem> queue = mediaController.getQueue();
     for (int i = 0; i < queue.size(); i++) {
       if (equalityChecker.equals(queue.get(i).getDescription(), description)) {
-        onRemoveQueueItemAt(player, i);
+        queueDataAdapter.remove(i);
+        queueMediaSource.removeMediaSource(i);
         return;
       }
     }
   }
 
-  @Override
-  public void onRemoveQueueItemAt(Player player, int index) {
-    queueDataAdapter.remove(index);
-    queueMediaSource.removeMediaSource(index);
-  }
-
   // CommandReceiver implementation.
 
   @NonNull
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
index 26a7b6150a..d55f8e04f0 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
@@ -39,6 +39,7 @@
   public static final int DEFAULT_MAX_QUEUE_SIZE = 10;
 
   private final MediaSessionCompat mediaSession;
+  private final Timeline.Window window;
   protected final int maxQueueSize;
 
   private long activeQueueItemId;
@@ -68,6 +69,7 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize)
     this.mediaSession = mediaSession;
     this.maxQueueSize = maxQueueSize;
     activeQueueItemId = MediaSessionCompat.QueueItem.UNKNOWN_ID;
+    window = new Timeline.Window();
   }
 
   /**
@@ -81,25 +83,24 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize)
 
   @Override
   public long getSupportedQueueNavigatorActions(Player player) {
-    if (player == null || player.getCurrentTimeline().getWindowCount() < 2) {
+    if (player == null) {
       return 0;
     }
-    if (player.getRepeatMode() != Player.REPEAT_MODE_OFF) {
-      return PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS
-          | PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty() || player.isPlayingAd()) {
+      return 0;
     }
-
-    int currentWindowIndex = player.getCurrentWindowIndex();
-    long actions;
-    if (currentWindowIndex == 0) {
-      actions = PlaybackStateCompat.ACTION_SKIP_TO_NEXT;
-    } else if (currentWindowIndex == player.getCurrentTimeline().getWindowCount() - 1) {
-      actions = PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
-    } else {
-      actions = PlaybackStateCompat.ACTION_SKIP_TO_NEXT
-          | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
+    long actions = 0;
+    if (timeline.getWindowCount() > 1) {
+      actions |= PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
+    }
+    if (window.isSeekable || !window.isDynamic || player.hasPrevious()) {
+      actions |= PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
     }
-    return actions | PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
+    if (window.isDynamic || player.hasNext()) {
+      actions |= PlaybackStateCompat.ACTION_SKIP_TO_NEXT;
+    }
+    return actions;
   }
 
   @Override
@@ -125,22 +126,25 @@ public final long getActiveQueueItemId(@Nullable Player player) {
   @Override
   public void onSkipToPrevious(Player player) {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
+    int windowIndex = player.getCurrentWindowIndex();
+    timeline.getWindow(windowIndex, window);
     int previousWindowIndex = player.getPreviousWindowIndex();
-    if (player.getCurrentPosition() > MAX_POSITION_FOR_SEEK_TO_PREVIOUS
-        || previousWindowIndex == C.INDEX_UNSET) {
-      player.seekTo(0);
-    } else {
+    if (previousWindowIndex != C.INDEX_UNSET
+        && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
+            || (window.isDynamic && !window.isSeekable))) {
       player.seekTo(previousWindowIndex, C.TIME_UNSET);
+    } else {
+      player.seekTo(0);
     }
   }
 
   @Override
   public void onSkipToQueueItem(Player player, long id) {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = (int) id;
@@ -152,12 +156,15 @@ public void onSkipToQueueItem(Player player, long id) {
   @Override
   public void onSkipToNext(Player player) {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
+    int windowIndex = player.getCurrentWindowIndex();
     int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
       player.seekTo(nextWindowIndex, C.TIME_UNSET);
+    } else if (timeline.getWindow(windowIndex, window).isDynamic) {
+      player.seekTo(windowIndex, C.TIME_UNSET);
     }
   }
 
@@ -175,7 +182,7 @@ public void onCommand(Player player, String command, Bundle extras, ResultReceiv
 
   private void publishFloatingQueueWindow(Player player) {
     if (player.getCurrentTimeline().isEmpty()) {
-      mediaSession.setQueue(Collections.<MediaSessionCompat.QueueItem>emptyList());
+      mediaSession.setQueue(Collections.emptyList());
       activeQueueItemId = MediaSessionCompat.QueueItem.UNKNOWN_ID;
       return;
     }
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 2b653c3f0e..4e6b11c495 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
@@ -28,7 +33,8 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
-    api 'com.squareup.okhttp3:okhttp:3.10.0'
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
+    api 'com.squareup.okhttp3:okhttp:3.11.0'
 }
 
 ext {
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index f2898005c1..778277fdbc 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -15,24 +15,26 @@
  */
 package com.google.android.exoplayer2.ext.okhttp;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.net.Uri;
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
-import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Predicate;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.CacheControl;
 import okhttp3.Call;
 import okhttp3.HttpUrl;
@@ -40,30 +42,28 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.ResponseBody;
 
-/**
- * An {@link HttpDataSource} that delegates to Square's {@link Call.Factory}.
- */
-public class OkHttpDataSource implements HttpDataSource {
+/** An {@link HttpDataSource} that delegates to Square's {@link Call.Factory}. */
+public class OkHttpDataSource extends BaseDataSource implements HttpDataSource {
 
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.okhttp");
   }
 
-  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
+  private static final byte[] SKIP_BUFFER = new byte[4096];
 
-  @NonNull private final Call.Factory callFactory;
-  @NonNull private final RequestProperties requestProperties;
+  private final Call.Factory callFactory;
+  private final RequestProperties requestProperties;
 
-  @Nullable private final String userAgent;
-  @Nullable private final Predicate<String> contentTypePredicate;
-  @Nullable private final TransferListener<? super OkHttpDataSource> listener;
-  @Nullable private final CacheControl cacheControl;
-  @Nullable private final RequestProperties defaultRequestProperties;
+  private final @Nullable String userAgent;
+  private final @Nullable Predicate<String> contentTypePredicate;
+  private final @Nullable CacheControl cacheControl;
+  private final @Nullable RequestProperties defaultRequestProperties;
 
-  private DataSpec dataSpec;
-  private Response response;
-  private InputStream responseByteStream;
+  private @Nullable DataSpec dataSpec;
+  private @Nullable Response response;
+  private @Nullable InputStream responseByteStream;
   private boolean opened;
 
   private long bytesToSkip;
@@ -77,26 +77,19 @@
    *     by the source.
    * @param userAgent An optional User-Agent string.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a InvalidContentTypeException} is thrown from {@link #open(DataSpec)}.
+   *     predicate then a {@link InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    */
-  public OkHttpDataSource(@NonNull Call.Factory callFactory, @Nullable String userAgent,
+  public OkHttpDataSource(
+      Call.Factory callFactory,
+      @Nullable String userAgent,
       @Nullable Predicate<String> contentTypePredicate) {
-    this(callFactory, userAgent, contentTypePredicate, null);
-  }
-
-  /**
-   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
-   *     by the source.
-   * @param userAgent An optional User-Agent string.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
-   */
-  public OkHttpDataSource(@NonNull Call.Factory callFactory, @Nullable String userAgent,
-      @Nullable Predicate<String> contentTypePredicate,
-      @Nullable TransferListener<? super OkHttpDataSource> listener) {
-    this(callFactory, userAgent, contentTypePredicate, listener, null, null);
+    this(
+        callFactory,
+        userAgent,
+        contentTypePredicate,
+        /* cacheControl= */ null,
+        /* defaultRequestProperties= */ null);
   }
 
   /**
@@ -104,34 +97,35 @@ public OkHttpDataSource(@NonNull Call.Factory callFactory, @Nullable String user
    *     by the source.
    * @param userAgent An optional User-Agent string.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
+   *     predicate then a {@link InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
    * @param defaultRequestProperties The optional default {@link RequestProperties} to be sent to
-   *    the server as HTTP headers on every request.
+   *     the server as HTTP headers on every request.
    */
-  public OkHttpDataSource(@NonNull Call.Factory callFactory, @Nullable String userAgent,
+  public OkHttpDataSource(
+      Call.Factory callFactory,
+      @Nullable String userAgent,
       @Nullable Predicate<String> contentTypePredicate,
-      @Nullable TransferListener<? super OkHttpDataSource> listener,
-      @Nullable CacheControl cacheControl, @Nullable RequestProperties defaultRequestProperties) {
+      @Nullable CacheControl cacheControl,
+      @Nullable RequestProperties defaultRequestProperties) {
+    super(/* isNetwork= */ true);
     this.callFactory = Assertions.checkNotNull(callFactory);
     this.userAgent = userAgent;
     this.contentTypePredicate = contentTypePredicate;
-    this.listener = listener;
     this.cacheControl = cacheControl;
     this.defaultRequestProperties = defaultRequestProperties;
     this.requestProperties = new RequestProperties();
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return response == null ? null : Uri.parse(response.request().url().toString());
   }
 
   @Override
   public Map<String, List<String>> getResponseHeaders() {
-    return response == null ? null : response.headers().toMultimap();
+    return response == null ? Collections.emptyMap() : response.headers().toMultimap();
   }
 
   @Override
@@ -157,13 +151,19 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.dataSpec = dataSpec;
     this.bytesRead = 0;
     this.bytesSkipped = 0;
+    transferInitializing(dataSpec);
+
     Request request = makeRequest(dataSpec);
+    Response response;
+    ResponseBody responseBody;
     try {
-      response = callFactory.newCall(request).execute();
-      responseByteStream = response.body().byteStream();
+      this.response = callFactory.newCall(request).execute();
+      response = this.response;
+      responseBody = Assertions.checkNotNull(response.body());
+      responseByteStream = responseBody.byteStream();
     } catch (IOException e) {
-      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec, HttpDataSourceException.TYPE_OPEN);
+      throw new HttpDataSourceException(
+          "Unable to connect to " + dataSpec.uri, e, dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     int responseCode = response.code();
@@ -172,8 +172,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     if (!response.isSuccessful()) {
       Map<String, List<String>> headers = response.headers().toMultimap();
       closeConnectionQuietly();
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(
-          responseCode, headers, dataSpec);
+      InvalidResponseCodeException exception =
+          new InvalidResponseCodeException(responseCode, response.message(), headers, dataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
@@ -181,8 +181,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
 
     // Check for a valid content type.
-    MediaType mediaType = response.body().contentType();
-    String contentType = mediaType != null ? mediaType.toString() : null;
+    MediaType mediaType = responseBody.contentType();
+    String contentType = mediaType != null ? mediaType.toString() : "";
     if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
       closeConnectionQuietly();
       throw new InvalidContentTypeException(contentType, dataSpec);
@@ -197,14 +197,12 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     if (dataSpec.length != C.LENGTH_UNSET) {
       bytesToRead = dataSpec.length;
     } else {
-      long contentLength = response.body().contentLength();
+      long contentLength = responseBody.contentLength();
       bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
 
     return bytesToRead;
   }
@@ -215,7 +213,8 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
       skipInternal();
       return readInternal(buffer, offset, readLength);
     } catch (IOException e) {
-      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
+      throw new HttpDataSourceException(
+          e, Assertions.checkNotNull(dataSpec), HttpDataSourceException.TYPE_READ);
     }
   }
 
@@ -223,9 +222,7 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
   public void close() throws HttpDataSourceException {
     if (opened) {
       opened = false;
-      if (listener != null) {
-        listener.onTransferEnd(this);
-      }
+      transferEnded();
       closeConnectionQuietly();
     }
   }
@@ -262,15 +259,18 @@ protected final long bytesRemaining() {
     return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
   }
 
-  /**
-   * Establishes a connection.
-   */
-  private Request makeRequest(DataSpec dataSpec) {
+  /** Establishes a connection. */
+  private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
+    if (url == null) {
+      throw new HttpDataSourceException(
+          "Malformed URL", dataSpec, HttpDataSourceException.TYPE_OPEN);
+    }
+
     Request.Builder builder = new Request.Builder().url(url);
     if (cacheControl != null) {
       builder.cacheControl(cacheControl);
@@ -297,9 +297,14 @@ private Request makeRequest(DataSpec dataSpec) {
     if (!allowGzip) {
       builder.addHeader("Accept-Encoding", "identity");
     }
-    if (dataSpec.postBody != null) {
-      builder.post(RequestBody.create(null, dataSpec.postBody));
+    RequestBody requestBody = null;
+    if (dataSpec.httpBody != null) {
+      requestBody = RequestBody.create(null, dataSpec.httpBody);
+    } else if (dataSpec.httpMethod == DataSpec.HTTP_METHOD_POST) {
+      // OkHttp requires a non-null body for POST requests.
+      requestBody = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
     }
+    builder.method(dataSpec.getHttpMethodString(), requestBody);
     return builder.build();
   }
 
@@ -316,15 +321,9 @@ private void skipInternal() throws IOException {
       return;
     }
 
-    // Acquire the shared skip buffer.
-    byte[] skipBuffer = skipBufferReference.getAndSet(null);
-    if (skipBuffer == null) {
-      skipBuffer = new byte[4096];
-    }
-
     while (bytesSkipped != bytesToSkip) {
-      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
-      int read = responseByteStream.read(skipBuffer, 0, readLength);
+      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, SKIP_BUFFER.length);
+      int read = castNonNull(responseByteStream).read(SKIP_BUFFER, 0, readLength);
       if (Thread.currentThread().isInterrupted()) {
         throw new InterruptedIOException();
       }
@@ -332,13 +331,8 @@ private void skipInternal() throws IOException {
         throw new EOFException();
       }
       bytesSkipped += read;
-      if (listener != null) {
-        listener.onBytesTransferred(this, read);
-      }
+      bytesTransferred(read);
     }
-
-    // Release the shared skip buffer.
-    skipBufferReference.set(skipBuffer);
   }
 
   /**
@@ -367,7 +361,7 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
       readLength = (int) Math.min(readLength, bytesRemaining);
     }
 
-    int read = responseByteStream.read(buffer, offset, readLength);
+    int read = castNonNull(responseByteStream).read(buffer, offset, readLength);
     if (read == -1) {
       if (bytesToRead != C.LENGTH_UNSET) {
         // End of stream reached having not read sufficient data.
@@ -377,9 +371,7 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
     }
 
     bytesRead += read;
-    if (listener != null) {
-      listener.onBytesTransferred(this, read);
-    }
+    bytesTransferred(read);
     return read;
   }
 
@@ -387,8 +379,10 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
    * Closes the current connection quietly, if there is one.
    */
   private void closeConnectionQuietly() {
-    response.body().close();
-    response = null;
+    if (response != null) {
+      Assertions.checkNotNull(response.body()).close();
+      response = null;
+    }
     responseByteStream = null;
   }
 
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 32fc5a58cb..09f4e0b61a 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.okhttp;
 
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
@@ -30,10 +28,30 @@
  */
 public final class OkHttpDataSourceFactory extends BaseFactory {
 
-  @NonNull private final Call.Factory callFactory;
-  @Nullable private final String userAgent;
-  @Nullable private final TransferListener<? super DataSource> listener;
-  @Nullable private final CacheControl cacheControl;
+  private final Call.Factory callFactory;
+  private final @Nullable String userAgent;
+  private final @Nullable TransferListener listener;
+  private final @Nullable CacheControl cacheControl;
+
+  /**
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the sources created by the factory.
+   * @param userAgent An optional User-Agent string.
+   */
+  public OkHttpDataSourceFactory(Call.Factory callFactory, @Nullable String userAgent) {
+    this(callFactory, userAgent, /* listener= */ null, /* cacheControl= */ null);
+  }
+
+  /**
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the sources created by the factory.
+   * @param userAgent An optional User-Agent string.
+   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
+   */
+  public OkHttpDataSourceFactory(
+      Call.Factory callFactory, @Nullable String userAgent, @Nullable CacheControl cacheControl) {
+    this(callFactory, userAgent, /* listener= */ null, cacheControl);
+  }
 
   /**
    * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
@@ -41,9 +59,9 @@
    * @param userAgent An optional User-Agent string.
    * @param listener An optional listener.
    */
-  public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable String userAgent,
-      @Nullable TransferListener<? super DataSource> listener) {
-    this(callFactory, userAgent, listener, null);
+  public OkHttpDataSourceFactory(
+      Call.Factory callFactory, @Nullable String userAgent, @Nullable TransferListener listener) {
+    this(callFactory, userAgent, listener, /* cacheControl= */ null);
   }
 
   /**
@@ -53,8 +71,10 @@ public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable Stri
    * @param listener An optional listener.
    * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
    */
-  public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable String userAgent,
-      @Nullable TransferListener<? super DataSource> listener,
+  public OkHttpDataSourceFactory(
+      Call.Factory callFactory,
+      @Nullable String userAgent,
+      @Nullable TransferListener listener,
       @Nullable CacheControl cacheControl) {
     this.callFactory = callFactory;
     this.userAgent = userAgent;
@@ -65,8 +85,16 @@ public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable Stri
   @Override
   protected OkHttpDataSource createDataSourceInternal(
       HttpDataSource.RequestProperties defaultRequestProperties) {
-    return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl,
-        defaultRequestProperties);
+    OkHttpDataSource dataSource =
+        new OkHttpDataSource(
+            callFactory,
+            userAgent,
+            /* contentTypePredicate= */ null,
+            cacheControl,
+            defaultRequestProperties);
+    if (listener != null) {
+      dataSource.addTransferListener(listener);
+    }
+    return dataSource;
   }
-
 }
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 2d20c65697..cb12442de8 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -18,10 +18,16 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
         consumerProguardFiles 'proguard-rules.txt'
+        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
     }
 
     sourceSets.main {
@@ -32,6 +38,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
+    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
 }
 
 ext {
diff --git a/extensions/opus/src/androidTest/AndroidManifest.xml b/extensions/opus/src/androidTest/AndroidManifest.xml
index 9e7f05051e..5ba0f3c0f4 100644
--- a/extensions/opus/src/androidTest/AndroidManifest.xml
+++ b/extensions/opus/src/androidTest/AndroidManifest.xml
@@ -26,6 +26,6 @@
 
   <instrumentation
       android:targetPackage="com.google.android.exoplayer2.ext.opus.test"
-      android:name="android.test.InstrumentationTestRunner"/>
+    android:name="androidx.test.runner.AndroidJUnitRunner"/>
 
 </manifest>
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index c547cff434..c457514c87 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -15,10 +15,13 @@
  */
 package com.google.android.exoplayer2.ext.opus;
 
+import static androidx.test.InstrumentationRegistry.getContext;
+import static org.junit.Assert.fail;
+
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
-import android.test.InstrumentationTestCase;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
@@ -29,43 +32,40 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Playback tests using {@link LibopusAudioRenderer}.
- */
-public class OpusPlaybackTest extends InstrumentationTestCase {
+/** Playback tests using {@link LibopusAudioRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public class OpusPlaybackTest {
 
   private static final String BEAR_OPUS_URI = "asset:///bear-opus.webm";
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  @Before
+  public void setUp() {
     if (!OpusLibrary.isAvailable()) {
       fail("Opus library not available.");
     }
   }
 
-  public void testBasicPlayback() throws ExoPlaybackException {
+  @Test
+  public void testBasicPlayback() throws Exception {
     playUri(BEAR_OPUS_URI);
   }
 
-  private void playUri(String uri) throws ExoPlaybackException {
-    TestPlaybackRunnable testPlaybackRunnable = new TestPlaybackRunnable(Uri.parse(uri),
-        getInstrumentation().getContext());
+  private void playUri(String uri) throws Exception {
+    TestPlaybackRunnable testPlaybackRunnable =
+        new TestPlaybackRunnable(Uri.parse(uri), getContext());
     Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
-    try {
-      thread.join();
-    } catch (InterruptedException e) {
-      fail(); // Should never happen.
-    }
+    thread.join();
     if (testPlaybackRunnable.playbackException != null) {
       throw testPlaybackRunnable.playbackException;
     }
   }
 
-  private static class TestPlaybackRunnable extends Player.DefaultEventListener
-      implements Runnable {
+  private static class TestPlaybackRunnable implements Player.EventListener, Runnable {
 
     private final Context context;
     private final Uri uri;
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index b94f3e9332..e288339058 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -30,8 +30,10 @@
  */
 public final class LibopusAudioRenderer extends SimpleDecoderAudioRenderer {
 
+  /** The number of input and output buffers. */
   private static final int NUM_BUFFERS = 16;
-  private static final int INITIAL_INPUT_BUFFER_SIZE = 960 * 6;
+  /** The default input buffer size. */
+  private static final int DEFAULT_INPUT_BUFFER_SIZE = 960 * 6;
 
   private OpusDecoder decoder;
 
@@ -76,7 +78,7 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     if (!OpusLibrary.isAvailable()
         || !MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
-    } else if (!supportsOutputEncoding(C.ENCODING_PCM_16BIT)) {
+    } else if (!supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
@@ -88,8 +90,15 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
   @Override
   protected OpusDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
       throws OpusDecoderException {
-    decoder = new OpusDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
-        format.initializationData, mediaCrypto);
+    int initialInputBufferSize =
+        format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
+    decoder =
+        new OpusDecoder(
+            NUM_BUFFERS,
+            NUM_BUFFERS,
+            initialInputBufferSize,
+            format.initializationData,
+            mediaCrypto);
     return decoder;
   }
 
diff --git a/extensions/rtmp/build.gradle b/extensions/rtmp/build.gradle
index c34e0b9999..af02ee2eaa 100644
--- a/extensions/rtmp/build.gradle
+++ b/extensions/rtmp/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion 15
         targetSdkVersion project.ext.targetSdkVersion
@@ -28,6 +33,8 @@ dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'net.butterflytv.utils:rtmp-client:3.0.1'
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    testImplementation 'junit:junit:' + junitVersion
+    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
 }
 
 ext {
diff --git a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java
index 0601af4a2f..08c328ce81 100644
--- a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java
+++ b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java
@@ -19,6 +19,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -26,40 +27,40 @@
 import net.butterflytv.rtmp_client.RtmpClient;
 import net.butterflytv.rtmp_client.RtmpClient.RtmpIOException;
 
-/**
- * A Real-Time Messaging Protocol (RTMP) {@link DataSource}.
- */
-public final class RtmpDataSource implements DataSource {
+/** A Real-Time Messaging Protocol (RTMP) {@link DataSource}. */
+public final class RtmpDataSource extends BaseDataSource {
 
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.rtmp");
   }
 
-  @Nullable private final TransferListener<? super RtmpDataSource> listener;
-
   private RtmpClient rtmpClient;
   private Uri uri;
 
   public RtmpDataSource() {
-    this(null);
+    super(/* isNetwork= */ true);
   }
 
   /**
    * @param listener An optional listener.
+   * @deprecated Use {@link #RtmpDataSource()} and {@link #addTransferListener(TransferListener)}.
    */
-  public RtmpDataSource(@Nullable TransferListener<? super RtmpDataSource> listener) {
-    this.listener = listener;
+  @Deprecated
+  public RtmpDataSource(@Nullable TransferListener listener) {
+    this();
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
   public long open(DataSpec dataSpec) throws RtmpIOException {
+    transferInitializing(dataSpec);
     rtmpClient = new RtmpClient();
     rtmpClient.open(dataSpec.uri.toString(), false);
 
     this.uri = dataSpec.uri;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
     return C.LENGTH_UNSET;
   }
 
@@ -69,9 +70,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
     if (bytesRead == -1) {
       return C.RESULT_END_OF_INPUT;
     }
-    if (listener != null) {
-      listener.onBytesTransferred(this, bytesRead);
-    }
+    bytesTransferred(bytesRead);
     return bytesRead;
   }
 
@@ -79,9 +78,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
   public void close() {
     if (uri != null) {
       uri = null;
-      if (listener != null) {
-        listener.onTransferEnd(this);
-      }
+      transferEnded();
     }
     if (rtmpClient != null) {
       rtmpClient.close();
diff --git a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
index 0510e9c7da..d1350276f2 100644
--- a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
+++ b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
@@ -25,23 +25,24 @@
  */
 public final class RtmpDataSourceFactory implements DataSource.Factory {
 
-  @Nullable
-  private final TransferListener<? super RtmpDataSource> listener;
+  private final @Nullable TransferListener listener;
 
   public RtmpDataSourceFactory() {
     this(null);
   }
 
-  /**
-   * @param listener An optional listener.
-   */
-  public RtmpDataSourceFactory(@Nullable TransferListener<? super RtmpDataSource> listener) {
+  /** @param listener An optional listener. */
+  public RtmpDataSourceFactory(@Nullable TransferListener listener) {
     this.listener = listener;
   }
 
   @Override
   public DataSource createDataSource() {
-    return new RtmpDataSource(listener);
+    RtmpDataSource dataSource = new RtmpDataSource();
+    if (listener != null) {
+      dataSource.addTransferListener(listener);
+    }
+    return dataSource;
   }
 
 }
diff --git a/extensions/rtmp/src/test/AndroidManifest.xml b/extensions/rtmp/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..7eab4e2d59
--- /dev/null
+++ b/extensions/rtmp/src/test/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.rtmp"/>
diff --git a/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java b/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
new file mode 100644
index 0000000000..f4753798b8
--- /dev/null
+++ b/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.rtmp;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link DefaultDataSource} with RTMP URIs. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultDataSourceTest {
+
+  @Test
+  public void openRtmpDataSpec_instantiatesRtmpDataSourceViaReflection() throws IOException {
+    DefaultDataSource dataSource =
+        new DefaultDataSource(
+            RuntimeEnvironment.application, "userAgent", /* allowCrossProtocolRedirects= */ false);
+    DataSpec dataSpec = new DataSpec(Uri.parse("rtmp://test.com/stream"));
+    try {
+      dataSource.open(dataSpec);
+    } catch (UnsatisfiedLinkError e) {
+      // RtmpDataSource was successfully instantiated (test run using Gradle).
+    } catch (UnsupportedOperationException e) {
+      // RtmpDataSource was successfully instantiated (test run using Blaze).
+    }
+  }
+}
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 9601829c91..306f04d0e2 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -49,7 +49,7 @@ git clone https://chromium.googlesource.com/libyuv/libyuv libyuv
 
 ```
 cd "${VP9_EXT_PATH}/jni/libvpx" && \
-git checkout tags/v1.6.1 -b v1.6.1 && \
+git checkout tags/v1.7.0 -b v1.7.0 && \
 cd "${VP9_EXT_PATH}/jni/libyuv" && \
 git checkout 996a2bbd
 ```
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 7dc95b388f..96c58d7a57 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -18,10 +18,16 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
         consumerProguardFiles 'proguard-rules.txt'
+        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
     }
 
     sourceSets.main {
@@ -33,6 +39,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
     androidTestImplementation 'com.google.truth:truth:' + truthVersion
 }
 
diff --git a/extensions/vp9/src/androidTest/AndroidManifest.xml b/extensions/vp9/src/androidTest/AndroidManifest.xml
index c7ed3d7fb2..214427c4f0 100644
--- a/extensions/vp9/src/androidTest/AndroidManifest.xml
+++ b/extensions/vp9/src/androidTest/AndroidManifest.xml
@@ -26,6 +26,6 @@
 
   <instrumentation
       android:targetPackage="com.google.android.exoplayer2.ext.vp9.test"
-      android:name="android.test.InstrumentationTestRunner"/>
+      android:name="androidx.test.runner.AndroidJUnitRunner"/>
 
 </manifest>
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index 09701f9542..2eb5c87e04 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
+import static androidx.test.InstrumentationRegistry.getContext;
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
-import android.test.InstrumentationTestCase;
-import android.util.Log;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
@@ -32,11 +33,14 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.util.Log;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Playback tests using {@link LibvpxVideoRenderer}.
- */
-public class VpxPlaybackTest extends InstrumentationTestCase {
+/** Playback tests using {@link LibvpxVideoRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public class VpxPlaybackTest {
 
   private static final String BEAR_URI = "asset:///bear-vp9.webm";
   private static final String BEAR_ODD_DIMENSIONS_URI = "asset:///bear-vp9-odd-dimensions.webm";
@@ -45,23 +49,25 @@
 
   private static final String TAG = "VpxPlaybackTest";
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  @Before
+  public void setUp() {
     if (!VpxLibrary.isAvailable()) {
       fail("Vpx library not available.");
     }
   }
 
-  public void testBasicPlayback() throws ExoPlaybackException {
+  @Test
+  public void testBasicPlayback() throws Exception {
     playUri(BEAR_URI);
   }
 
-  public void testOddDimensionsPlayback() throws ExoPlaybackException {
+  @Test
+  public void testOddDimensionsPlayback() throws Exception {
     playUri(BEAR_ODD_DIMENSIONS_URI);
   }
 
-  public void test10BitProfile2Playback() throws ExoPlaybackException {
+  @Test
+  public void test10BitProfile2Playback() throws Exception {
     if (VpxLibrary.isHighBitDepthSupported()) {
       Log.d(TAG, "High Bit Depth supported.");
       playUri(ROADTRIP_10BIT_URI);
@@ -70,6 +76,7 @@ public void test10BitProfile2Playback() throws ExoPlaybackException {
     Log.d(TAG, "High Bit Depth not supported.");
   }
 
+  @Test
   public void testInvalidBitstream() {
     try {
       playUri(INVALID_BITSTREAM_URI);
@@ -80,23 +87,18 @@ public void testInvalidBitstream() {
     }
   }
 
-  private void playUri(String uri) throws ExoPlaybackException {
-    TestPlaybackRunnable testPlaybackRunnable = new TestPlaybackRunnable(Uri.parse(uri),
-        getInstrumentation().getContext());
+  private void playUri(String uri) throws Exception {
+    TestPlaybackRunnable testPlaybackRunnable =
+        new TestPlaybackRunnable(Uri.parse(uri), getContext());
     Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
-    try {
-      thread.join();
-    } catch (InterruptedException e) {
-      fail(); // Should never happen.
-    }
+    thread.join();
     if (testPlaybackRunnable.playbackException != null) {
       throw testPlaybackRunnable.playbackException;
     }
   }
 
-  private static class TestPlaybackRunnable extends Player.DefaultEventListener
-      implements Runnable {
+  private static class TestPlaybackRunnable implements Player.EventListener, Runnable {
 
     private final Context context;
     private final Uri uri;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index 7fde7678b8..e3081cd2d2 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -39,10 +39,13 @@
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.TimedValueQueue;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -62,9 +65,13 @@
  */
 public class LibvpxVideoRenderer extends BaseRenderer {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReinitializationState {}
   /**
    * The decoder does not need to be re-initialized.
@@ -99,11 +106,8 @@
    * requiring multiple output buffers to be dequeued at a time for it to make progress.
    */
   private static final int NUM_OUTPUT_BUFFERS = 8;
-  /**
-   * The initial input buffer size. Input buffers are reallocated dynamically if this value is
-   * insufficient.
-   */
-  private static final int INITIAL_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
+  /** The default input buffer size. */
+  private static final int DEFAULT_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
 
   private final boolean scaleToFit;
   private final boolean disableLoopFilter;
@@ -112,10 +116,14 @@
   private final boolean playClearSamplesWithoutKeys;
   private final EventDispatcher eventDispatcher;
   private final FormatHolder formatHolder;
+  private final TimedValueQueue<Format> formatQueue;
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
+  private final boolean useSurfaceYuvOutput;
 
   private Format format;
+  private Format pendingFormat;
+  private Format outputFormat;
   private VpxDecoder decoder;
   private VpxInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
@@ -144,6 +152,8 @@
   private int consecutiveDroppedFrameCount;
   private int buffersInCodecCount;
   private long lastRenderTimeUs;
+  private long outputStreamOffsetUs;
+  private VideoFrameMetadataListener frameMetadataListener;
 
   protected DecoderCounters decoderCounters;
 
@@ -177,7 +187,8 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
         maxDroppedFramesToNotify,
         /* drmSessionManager= */ null,
         /* playClearSamplesWithoutKeys= */ false,
-        /* disableLoopFilter= */ false);
+        /* disableLoopFilter= */ false,
+        /* useSurfaceYuvOutput= */ false);
   }
 
   /**
@@ -197,11 +208,18 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
+   * @param useSurfaceYuvOutput Directly output YUV to the Surface via ANativeWindow.
    */
-  public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
-      Handler eventHandler, VideoRendererEventListener eventListener,
-      int maxDroppedFramesToNotify, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys, boolean disableLoopFilter) {
+  public LibvpxVideoRenderer(
+      boolean scaleToFit,
+      long allowedJoiningTimeMs,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify,
+      DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      boolean disableLoopFilter,
+      boolean useSurfaceYuvOutput) {
     super(C.TRACK_TYPE_VIDEO);
     this.scaleToFit = scaleToFit;
     this.disableLoopFilter = disableLoopFilter;
@@ -209,9 +227,11 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    this.useSurfaceYuvOutput = useSurfaceYuvOutput;
     joiningDeadlineMs = C.TIME_UNSET;
     clearReportedVideoSize();
     formatHolder = new FormatHolder();
+    formatQueue = new TimedValueQueue<>();
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     outputMode = VpxDecoder.OUTPUT_MODE_NONE;
@@ -321,6 +341,7 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
     } else {
       joiningDeadlineMs = C.TIME_UNSET;
     }
+    formatQueue.clear();
   }
 
   @Override
@@ -364,6 +385,12 @@ protected void onDisabled() {
     }
   }
 
+  @Override
+  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
+    outputStreamOffsetUs = offsetUs;
+    super.onStreamChanged(formats, offsetUs);
+  }
+
   /**
    * Called when a decoder has been created and configured.
    *
@@ -430,6 +457,7 @@ protected void releaseDecoder() {
   protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
     Format oldFormat = format;
     format = newFormat;
+    pendingFormat = newFormat;
 
     boolean drmInitDataChanged = !Util.areEqual(format.drmInitData, oldFormat == null ? null
         : oldFormat.drmInitData);
@@ -549,21 +577,25 @@ protected void dropOutputBuffer(VpxOutputBuffer outputBuffer) {
    *
    * @param outputBuffer The buffer to render.
    */
-  protected void renderOutputBuffer(VpxOutputBuffer outputBuffer) {
+  protected void renderOutputBuffer(VpxOutputBuffer outputBuffer) throws VpxDecoderException {
     int bufferMode = outputBuffer.mode;
     boolean renderRgb = bufferMode == VpxDecoder.OUTPUT_MODE_RGB && surface != null;
+    boolean renderSurface = bufferMode == VpxDecoder.OUTPUT_MODE_SURFACE_YUV && surface != null;
     boolean renderYuv = bufferMode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null;
     lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-    if (!renderRgb && !renderYuv) {
+    if (!renderRgb && !renderYuv && !renderSurface) {
       dropOutputBuffer(outputBuffer);
     } else {
       maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
       if (renderRgb) {
         renderRgbFrame(outputBuffer, scaleToFit);
         outputBuffer.release();
-      } else /* renderYuv */ {
+      } else if (renderYuv) {
         outputBufferRenderer.setOutputBuffer(outputBuffer);
         // The renderer will release the buffer.
+      } else { // renderSurface
+        decoder.renderToSurface(outputBuffer, surface);
+        outputBuffer.release();
       }
       consecutiveDroppedFrameCount = 0;
       decoderCounters.renderedOutputBufferCount++;
@@ -605,7 +637,7 @@ protected void updateDroppedBufferCounters(int droppedBufferCount) {
     consecutiveDroppedFrameCount += droppedBufferCount;
     decoderCounters.maxConsecutiveDroppedBufferCount =
         Math.max(consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedBufferCount);
-    if (droppedFrames >= maxDroppedFramesToNotify) {
+    if (maxDroppedFramesToNotify > 0 && droppedFrames >= maxDroppedFramesToNotify) {
       maybeNotifyDroppedFrames();
     }
   }
@@ -613,11 +645,13 @@ protected void updateDroppedBufferCounters(int droppedBufferCount) {
   // PlayerMessage.Target implementation.
 
   @Override
-  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+  public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
       setOutput((Surface) message, null);
     } else if (messageType == MSG_SET_OUTPUT_BUFFER_RENDERER) {
       setOutput(null, (VpxOutputBufferRenderer) message);
+    } else if (messageType == C.MSG_SET_VIDEO_FRAME_METADATA_LISTENER) {
+      frameMetadataListener = (VideoFrameMetadataListener) message;
     } else {
       super.handleMessage(messageType, message);
     }
@@ -633,8 +667,13 @@ private void setOutput(
       // The output has changed.
       this.surface = surface;
       this.outputBufferRenderer = outputBufferRenderer;
-      outputMode = outputBufferRenderer != null ? VpxDecoder.OUTPUT_MODE_YUV
-          : surface != null ? VpxDecoder.OUTPUT_MODE_RGB : VpxDecoder.OUTPUT_MODE_NONE;
+      if (surface != null) {
+        outputMode =
+            useSurfaceYuvOutput ? VpxDecoder.OUTPUT_MODE_SURFACE_YUV : VpxDecoder.OUTPUT_MODE_RGB;
+      } else {
+        outputMode =
+            outputBufferRenderer != null ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_NONE;
+      }
       if (outputMode != VpxDecoder.OUTPUT_MODE_NONE) {
         if (decoder != null) {
           decoder.setOutputMode(outputMode);
@@ -684,13 +723,16 @@ private void maybeInitDecoder() throws ExoPlaybackException {
     try {
       long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
       TraceUtil.beginSection("createVpxDecoder");
+      int initialInputBufferSize =
+          format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
       decoder =
           new VpxDecoder(
               NUM_INPUT_BUFFERS,
               NUM_OUTPUT_BUFFERS,
-              INITIAL_INPUT_BUFFER_SIZE,
+              initialInputBufferSize,
               mediaCrypto,
-              disableLoopFilter);
+              disableLoopFilter,
+              useSurfaceYuvOutput);
       decoder.setOutputMode(outputMode);
       TraceUtil.endSection();
       long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
@@ -753,6 +795,10 @@ private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackExcepti
     if (waitingForKeys) {
       return false;
     }
+    if (pendingFormat != null) {
+      formatQueue.add(inputBuffer.timeUs, pendingFormat);
+      pendingFormat = null;
+    }
     inputBuffer.flip();
     inputBuffer.colorInfo = formatHolder.format.colorInfo;
     onQueueInputBuffer(inputBuffer);
@@ -817,7 +863,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
    * @throws ExoPlaybackException If an error occurs processing the output buffer.
    */
   private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
-      throws ExoPlaybackException {
+      throws ExoPlaybackException, VpxDecoderException {
     if (initialPositionUs == C.TIME_UNSET) {
       initialPositionUs = positionUs;
     }
@@ -832,11 +878,21 @@ private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
       return false;
     }
 
+    long presentationTimeUs = outputBuffer.timeUs - outputStreamOffsetUs;
+    Format format = formatQueue.pollFloor(presentationTimeUs);
+    if (format != null) {
+      outputFormat = format;
+    }
+
     long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
     boolean isStarted = getState() == STATE_STARTED;
     if (!renderedFirstFrame
         || (isStarted
             && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
+      if (frameMetadataListener != null) {
+        frameMetadataListener.onVideoFrameAboutToBeRendered(
+            presentationTimeUs, System.nanoTime(), outputFormat);
+      }
       renderOutputBuffer(outputBuffer);
       return true;
     }
@@ -854,6 +910,10 @@ private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     if (earlyUs < 30000) {
+      if (frameMetadataListener != null) {
+        frameMetadataListener.onVideoFrameAboutToBeRendered(
+            presentationTimeUs, System.nanoTime(), outputFormat);
+      }
       renderOutputBuffer(outputBuffer);
       return true;
     }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 6f8c0a1918..51ef8e9bcf 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
+import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.CryptoInfo;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
@@ -31,6 +32,7 @@
   public static final int OUTPUT_MODE_NONE = -1;
   public static final int OUTPUT_MODE_YUV = 0;
   public static final int OUTPUT_MODE_RGB = 1;
+  public static final int OUTPUT_MODE_SURFACE_YUV = 2;
 
   private static final int NO_ERROR = 0;
   private static final int DECODE_ERROR = 1;
@@ -50,10 +52,17 @@
    * @param exoMediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted
    *     content. Maybe null and can be ignored if decoder does not handle encrypted content.
    * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
+   * @param enableSurfaceYuvOutputMode Whether OUTPUT_MODE_SURFACE_YUV is allowed.
    * @throws VpxDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
-      ExoMediaCrypto exoMediaCrypto, boolean disableLoopFilter) throws VpxDecoderException {
+  public VpxDecoder(
+      int numInputBuffers,
+      int numOutputBuffers,
+      int initialInputBufferSize,
+      ExoMediaCrypto exoMediaCrypto,
+      boolean disableLoopFilter,
+      boolean enableSurfaceYuvOutputMode)
+      throws VpxDecoderException {
     super(new VpxInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
     if (!VpxLibrary.isAvailable()) {
       throw new VpxDecoderException("Failed to load decoder native libraries.");
@@ -62,7 +71,7 @@ public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBuf
     if (exoMediaCrypto != null && !VpxLibrary.vpxIsSecureDecodeSupported()) {
       throw new VpxDecoderException("Vpx decoder does not support secure decode.");
     }
-    vpxDecContext = vpxInit(disableLoopFilter);
+    vpxDecContext = vpxInit(disableLoopFilter, enableSurfaceYuvOutputMode);
     if (vpxDecContext == 0) {
       throw new VpxDecoderException("Failed to initialize decoder");
     }
@@ -96,6 +105,11 @@ protected VpxOutputBuffer createOutputBuffer() {
 
   @Override
   protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
+    // Decode only frames do not acquire a reference on the internal decoder buffer and thus do not
+    // require a call to vpxReleaseFrame.
+    if (outputMode == OUTPUT_MODE_SURFACE_YUV && !buffer.isDecodeOnly()) {
+      vpxReleaseFrame(vpxDecContext, buffer);
+    }
     super.releaseOutputBuffer(buffer);
   }
 
@@ -145,13 +159,36 @@ public void release() {
     vpxClose(vpxDecContext);
   }
 
-  private native long vpxInit(boolean disableLoopFilter);
+  /** Renders the outputBuffer to the surface. Used with OUTPUT_MODE_SURFACE_YUV only. */
+  public void renderToSurface(VpxOutputBuffer outputBuffer, Surface surface)
+      throws VpxDecoderException {
+    int getFrameResult = vpxRenderFrame(vpxDecContext, surface, outputBuffer);
+    if (getFrameResult == -1) {
+      throw new VpxDecoderException("Buffer render failed.");
+    }
+  }
+
+  private native long vpxInit(boolean disableLoopFilter, boolean enableSurfaceYuvOutputMode);
+
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
   private native long vpxSecureDecode(long context, ByteBuffer encoded, int length,
       ExoMediaCrypto mediaCrypto, int inputMode, byte[] key, byte[] iv,
       int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEncryptedData);
   private native int vpxGetFrame(long context, VpxOutputBuffer outputBuffer);
+
+  /**
+   * Renders the frame to the surface. Used with OUTPUT_MODE_SURFACE_YUV only. Must only be called
+   * if {@link #vpxInit} was called with {@code enableBufferManager = true}.
+   */
+  private native int vpxRenderFrame(long context, Surface surface, VpxOutputBuffer outputBuffer);
+
+  /**
+   * Releases the frame. Used with OUTPUT_MODE_SURFACE_YUV only. Must only be called if {@link
+   * #vpxInit} was called with {@code enableBufferManager = true}.
+   */
+  private native int vpxReleaseFrame(long context, VpxOutputBuffer outputBuffer);
+
   private native int vpxGetErrorCode(long context);
   private native String vpxGetErrorMessage(long context);
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index 2618bf7c62..fa0df1cfa9 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -30,6 +30,8 @@
   public static final int COLORSPACE_BT2020 = 3;
 
   private final VpxDecoder owner;
+  /** Decoder private data. */
+  public int decoderPrivate;
 
   public int mode;
   /**
diff --git a/extensions/vp9/src/main/jni/Android.mk b/extensions/vp9/src/main/jni/Android.mk
index 92fed0a064..868b869d56 100644
--- a/extensions/vp9/src/main/jni/Android.mk
+++ b/extensions/vp9/src/main/jni/Android.mk
@@ -35,7 +35,7 @@ LOCAL_MODULE := libvpxJNI
 LOCAL_ARM_MODE := arm
 LOCAL_CPP_EXTENSION := .cc
 LOCAL_SRC_FILES := vpx_jni.cc
-LOCAL_LDLIBS := -llog -lz -lm
+LOCAL_LDLIBS := -llog -lz -lm -landroid
 LOCAL_SHARED_LIBRARIES := libvpx
 LOCAL_STATIC_LIBRARIES := libyuv_static cpufeatures
 include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 12bc30112d..f36c433b22 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -21,7 +21,9 @@
 #include <jni.h>
 
 #include <android/log.h>
-
+#include <android/native_window.h>
+#include <android/native_window_jni.h>
+#include <pthread.h>
 #include <algorithm>
 #include <cstdio>
 #include <cstdlib>
@@ -63,6 +65,11 @@ static jmethodID initForRgbFrame;
 static jmethodID initForYuvFrame;
 static jfieldID dataField;
 static jfieldID outputModeField;
+static jfieldID decoderPrivateField;
+
+// android.graphics.ImageFormat.YV12.
+static const int kHalPixelFormatYV12 = 0x32315659;
+static const int kDecoderPrivateBase = 0x100;
 static int errorCode;
 
 jint JNI_OnLoad(JavaVM* vm, void* reserved) {
@@ -282,13 +289,166 @@ static void convert_16_to_8_standard(const vpx_image_t* const img,
   }
 }
 
-DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter) {
-  vpx_codec_ctx_t* context = new vpx_codec_ctx_t();
+struct JniFrameBuffer {
+  friend class JniBufferManager;
+
+  int stride[4];
+  uint8_t* planes[4];
+  int d_w;
+  int d_h;
+
+ private:
+  int id;
+  int ref_count;
+  vpx_codec_frame_buffer_t vpx_fb;
+};
+
+class JniBufferManager {
+  static const int MAX_FRAMES = 32;
+
+  JniFrameBuffer* all_buffers[MAX_FRAMES];
+  int all_buffer_count = 0;
+
+  JniFrameBuffer* free_buffers[MAX_FRAMES];
+  int free_buffer_count = 0;
+
+  pthread_mutex_t mutex;
+
+ public:
+  JniBufferManager() { pthread_mutex_init(&mutex, NULL); }
+
+  ~JniBufferManager() {
+    while (all_buffer_count--) {
+      free(all_buffers[all_buffer_count]->vpx_fb.data);
+    }
+  }
+
+  int get_buffer(size_t min_size, vpx_codec_frame_buffer_t* fb) {
+    pthread_mutex_lock(&mutex);
+    JniFrameBuffer* out_buffer;
+    if (free_buffer_count) {
+      out_buffer = free_buffers[--free_buffer_count];
+      if (out_buffer->vpx_fb.size < min_size) {
+        free(out_buffer->vpx_fb.data);
+        out_buffer->vpx_fb.data = (uint8_t*)malloc(min_size);
+        out_buffer->vpx_fb.size = min_size;
+      }
+    } else {
+      out_buffer = new JniFrameBuffer();
+      out_buffer->id = all_buffer_count;
+      all_buffers[all_buffer_count++] = out_buffer;
+      out_buffer->vpx_fb.data = (uint8_t*)malloc(min_size);
+      out_buffer->vpx_fb.size = min_size;
+      out_buffer->vpx_fb.priv = &out_buffer->id;
+    }
+    *fb = out_buffer->vpx_fb;
+    int retVal = 0;
+    if (!out_buffer->vpx_fb.data || all_buffer_count >= MAX_FRAMES) {
+      LOGE("ERROR: JniBufferManager get_buffer OOM.");
+      retVal = -1;
+    } else {
+      memset(fb->data, 0, fb->size);
+    }
+    out_buffer->ref_count = 1;
+    pthread_mutex_unlock(&mutex);
+    return retVal;
+  }
+
+  JniFrameBuffer* get_buffer(int id) const {
+    if (id < 0 || id >= all_buffer_count) {
+      LOGE("ERROR: JniBufferManager get_buffer invalid id %d.", id);
+      return NULL;
+    }
+    return all_buffers[id];
+  }
+
+  void add_ref(int id) {
+    if (id < 0 || id >= all_buffer_count) {
+      LOGE("ERROR: JniBufferManager add_ref invalid id %d.", id);
+      return;
+    }
+    pthread_mutex_lock(&mutex);
+    all_buffers[id]->ref_count++;
+    pthread_mutex_unlock(&mutex);
+  }
+
+  int release(int id) {
+    if (id < 0 || id >= all_buffer_count) {
+      LOGE("ERROR: JniBufferManager release invalid id %d.", id);
+      return -1;
+    }
+    pthread_mutex_lock(&mutex);
+    JniFrameBuffer* buffer = all_buffers[id];
+    if (!buffer->ref_count) {
+      LOGE("ERROR: JniBufferManager release, buffer already released.");
+      pthread_mutex_unlock(&mutex);
+      return -1;
+    }
+    if (!--buffer->ref_count) {
+      free_buffers[free_buffer_count++] = buffer;
+    }
+    pthread_mutex_unlock(&mutex);
+    return 0;
+  }
+};
+
+struct JniCtx {
+  JniCtx(bool enableBufferManager) {
+    if (enableBufferManager) {
+      buffer_manager = new JniBufferManager();
+    }
+  }
+
+  ~JniCtx() {
+    if (native_window) {
+      ANativeWindow_release(native_window);
+    }
+    if (buffer_manager) {
+      delete buffer_manager;
+    }
+  }
+
+  void acquire_native_window(JNIEnv* env, jobject new_surface) {
+    if (surface != new_surface) {
+      if (native_window) {
+        ANativeWindow_release(native_window);
+      }
+      native_window = ANativeWindow_fromSurface(env, new_surface);
+      surface = new_surface;
+      width = 0;
+    }
+  }
+
+  JniBufferManager* buffer_manager = NULL;
+  vpx_codec_ctx_t* decoder = NULL;
+  ANativeWindow* native_window = NULL;
+  jobject surface = NULL;
+  int width = 0;
+  int height = 0;
+};
+
+int vpx_get_frame_buffer(void* priv, size_t min_size,
+                         vpx_codec_frame_buffer_t* fb) {
+  JniBufferManager* const buffer_manager =
+      reinterpret_cast<JniBufferManager*>(priv);
+  return buffer_manager->get_buffer(min_size, fb);
+}
+
+int vpx_release_frame_buffer(void* priv, vpx_codec_frame_buffer_t* fb) {
+  JniBufferManager* const buffer_manager =
+      reinterpret_cast<JniBufferManager*>(priv);
+  return buffer_manager->release(*(int*)fb->priv);
+}
+
+DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
+             jboolean enableBufferManager) {
+  JniCtx* context = new JniCtx(enableBufferManager);
+  context->decoder = new vpx_codec_ctx_t();
   vpx_codec_dec_cfg_t cfg = {0, 0, 0};
   cfg.threads = android_getCpuCount();
   errorCode = 0;
-  vpx_codec_err_t err = vpx_codec_dec_init(context, &vpx_codec_vp9_dx_algo,
-                                           &cfg, 0);
+  vpx_codec_err_t err =
+      vpx_codec_dec_init(context->decoder, &vpx_codec_vp9_dx_algo, &cfg, 0);
   if (err) {
     LOGE("ERROR: Failed to initialize libvpx decoder, error = %d.", err);
     errorCode = err;
@@ -296,11 +456,20 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter) {
   }
   if (disableLoopFilter) {
     // TODO(b/71930387): Use vpx_codec_control(), not vpx_codec_control_().
-    err = vpx_codec_control_(context, VP9_SET_SKIP_LOOP_FILTER, true);
+    err = vpx_codec_control_(context->decoder, VP9_SET_SKIP_LOOP_FILTER, true);
     if (err) {
       LOGE("ERROR: Failed to shut off libvpx loop filter, error = %d.", err);
     }
   }
+  if (enableBufferManager) {
+    err = vpx_codec_set_frame_buffer_functions(
+        context->decoder, vpx_get_frame_buffer, vpx_release_frame_buffer,
+        context->buffer_manager);
+    if (err) {
+      LOGE("ERROR: Failed to set libvpx frame buffer functions, error = %d.",
+           err);
+    }
+  }
 
   // Populate JNI References.
   const jclass outputBufferClass = env->FindClass(
@@ -312,16 +481,17 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter) {
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
-
+  decoderPrivateField =
+      env->GetFieldID(outputBufferClass, "decoderPrivate", "I");
   return reinterpret_cast<intptr_t>(context);
 }
 
 DECODER_FUNC(jlong, vpxDecode, jlong jContext, jobject encoded, jint len) {
-  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
+  JniCtx* const context = reinterpret_cast<JniCtx*>(jContext);
   const uint8_t* const buffer =
       reinterpret_cast<const uint8_t*>(env->GetDirectBufferAddress(encoded));
   const vpx_codec_err_t status =
-      vpx_codec_decode(context, buffer, len, NULL, 0);
+      vpx_codec_decode(context->decoder, buffer, len, NULL, 0);
   errorCode = 0;
   if (status != VPX_CODEC_OK) {
     LOGE("ERROR: vpx_codec_decode() failed, status= %d", status);
@@ -343,16 +513,16 @@ DECODER_FUNC(jlong, vpxSecureDecode, jlong jContext, jobject encoded, jint len,
 }
 
 DECODER_FUNC(jlong, vpxClose, jlong jContext) {
-  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
-  vpx_codec_destroy(context);
+  JniCtx* const context = reinterpret_cast<JniCtx*>(jContext);
+  vpx_codec_destroy(context->decoder);
   delete context;
   return 0;
 }
 
 DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
-  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
+  JniCtx* const context = reinterpret_cast<JniCtx*>(jContext);
   vpx_codec_iter_t iter = NULL;
-  const vpx_image_t* const img = vpx_codec_get_frame(context, &iter);
+  const vpx_image_t* const img = vpx_codec_get_frame(context->decoder, &iter);
 
   if (img == NULL) {
     return 1;
@@ -360,6 +530,7 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
 
   const int kOutputModeYuv = 0;
   const int kOutputModeRgb = 1;
+  const int kOutputModeSurfaceYuv = 2;
 
   int outputMode = env->GetIntField(jOutputBuffer, outputModeField);
   if (outputMode == kOutputModeRgb) {
@@ -435,13 +606,93 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
       memcpy(data + yLength, img->planes[VPX_PLANE_U], uvLength);
       memcpy(data + yLength + uvLength, img->planes[VPX_PLANE_V], uvLength);
     }
+  } else if (outputMode == kOutputModeSurfaceYuv &&
+             img->fmt != VPX_IMG_FMT_I42016) {
+    if (!context->buffer_manager) {
+      return -1;  // enableBufferManager was not set in vpxInit.
+    }
+    int id = *(int*)img->fb_priv;
+    context->buffer_manager->add_ref(id);
+    JniFrameBuffer* jfb = context->buffer_manager->get_buffer(id);
+    for (int i = 2; i >= 0; i--) {
+      jfb->stride[i] = img->stride[i];
+      jfb->planes[i] = (uint8_t*)img->planes[i];
+    }
+    jfb->d_w = img->d_w;
+    jfb->d_h = img->d_h;
+    env->SetIntField(jOutputBuffer, decoderPrivateField,
+                     id + kDecoderPrivateBase);
   }
   return 0;
 }
 
+DECODER_FUNC(jint, vpxRenderFrame, jlong jContext, jobject jSurface,
+             jobject jOutputBuffer) {
+  JniCtx* const context = reinterpret_cast<JniCtx*>(jContext);
+  const int id = env->GetIntField(jOutputBuffer, decoderPrivateField) -
+                 kDecoderPrivateBase;
+  JniFrameBuffer* srcBuffer = context->buffer_manager->get_buffer(id);
+  context->acquire_native_window(env, jSurface);
+  if (context->native_window == NULL || !srcBuffer) {
+    return 1;
+  }
+  if (context->width != srcBuffer->d_w || context->height != srcBuffer->d_h) {
+    ANativeWindow_setBuffersGeometry(context->native_window, srcBuffer->d_w,
+                                     srcBuffer->d_h, kHalPixelFormatYV12);
+    context->width = srcBuffer->d_w;
+    context->height = srcBuffer->d_h;
+  }
+  ANativeWindow_Buffer buffer;
+  int result = ANativeWindow_lock(context->native_window, &buffer, NULL);
+  if (buffer.bits == NULL || result) {
+    return -1;
+  }
+  // Y
+  const size_t src_y_stride = srcBuffer->stride[VPX_PLANE_Y];
+  int stride = srcBuffer->d_w;
+  const uint8_t* src_base =
+      reinterpret_cast<uint8_t*>(srcBuffer->planes[VPX_PLANE_Y]);
+  uint8_t* dest_base = (uint8_t*)buffer.bits;
+  for (int y = 0; y < srcBuffer->d_h; y++) {
+    memcpy(dest_base, src_base, stride);
+    src_base += src_y_stride;
+    dest_base += buffer.stride;
+  }
+  // UV
+  const int src_uv_stride = srcBuffer->stride[VPX_PLANE_U];
+  const int dest_uv_stride = (buffer.stride / 2 + 15) & (~15);
+  const int32_t buffer_uv_height = (buffer.height + 1) / 2;
+  const int32_t height =
+      std::min((int32_t)(srcBuffer->d_h + 1) / 2, buffer_uv_height);
+  stride = (srcBuffer->d_w + 1) / 2;
+  src_base = reinterpret_cast<uint8_t*>(srcBuffer->planes[VPX_PLANE_U]);
+  const uint8_t* src_v_base =
+      reinterpret_cast<uint8_t*>(srcBuffer->planes[VPX_PLANE_V]);
+  uint8_t* dest_v_base =
+      ((uint8_t*)buffer.bits) + buffer.stride * buffer.height;
+  dest_base = dest_v_base + buffer_uv_height * dest_uv_stride;
+  for (int y = 0; y < height; y++) {
+    memcpy(dest_base, src_base, stride);
+    memcpy(dest_v_base, src_v_base, stride);
+    src_base += src_uv_stride;
+    src_v_base += src_uv_stride;
+    dest_base += dest_uv_stride;
+    dest_v_base += dest_uv_stride;
+  }
+  return ANativeWindow_unlockAndPost(context->native_window);
+}
+
+DECODER_FUNC(void, vpxReleaseFrame, jlong jContext, jobject jOutputBuffer) {
+  JniCtx* const context = reinterpret_cast<JniCtx*>(jContext);
+  const int id = env->GetIntField(jOutputBuffer, decoderPrivateField) -
+                 kDecoderPrivateBase;
+  env->SetIntField(jOutputBuffer, decoderPrivateField, -1);
+  context->buffer_manager->release(id);
+}
+
 DECODER_FUNC(jstring, vpxGetErrorMessage, jlong jContext) {
-  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
-  return env->NewStringUTF(vpx_codec_error(context));
+  JniCtx* const context = reinterpret_cast<JniCtx*>(jContext);
+  return env->NewStringUTF(vpx_codec_error(context->decoder));
 }
 
 DECODER_FUNC(jint, vpxGetErrorCode, jlong jContext) { return errorCode; }
diff --git a/javadoc_combined.gradle b/javadoc_combined.gradle
index aea65d4d97..209ad3a1a3 100644
--- a/javadoc_combined.gradle
+++ b/javadoc_combined.gradle
@@ -39,7 +39,7 @@ class CombinedJavadocPlugin implements Plugin<Project> {
             libraryModules.each { libraryModule ->
               libraryModule.android.libraryVariants.all { variant ->
                 def name = variant.buildType.name
-                if (name.equals("release")) {
+                if (name == "release") {
                   classpath +=
                       libraryModule.project.files(
                           variant.javaCompile.classpath.files,
@@ -63,7 +63,7 @@ class CombinedJavadocPlugin implements Plugin<Project> {
   }
 
   // Returns Android library modules that declare a generateJavadoc task.
-  private Set<Project> getLibraryModules(Project project) {
+  private static Set<Project> getLibraryModules(Project project) {
     project.subprojects.findAll {
       it.plugins.findPlugin("com.android.library") &&
       it.tasks.findByName("generateJavadoc")
diff --git a/library/core/build.gradle b/library/core/build.gradle
index d684f120f2..1ce729d82c 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -17,12 +17,17 @@ apply from: '../../constants.gradle'
 android {
     compileSdkVersion project.ext.compileSdkVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
         consumerProguardFiles 'proguard-rules.txt'
 
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
 
         // The following argument makes the Android Test Orchestrator run its
         // "pm clear" command after each test invocation. This command ensures
@@ -33,11 +38,11 @@ android {
     // Workaround to prevent circular dependency on project :testutils.
     sourceSets {
         androidTest {
-            java.srcDirs += "../../testutils/src/main/java/"
+            java.srcDirs += '../../testutils/src/main/java/'
         }
         test {
-            java.srcDirs += "../../testutils/src/main/java/"
-            java.srcDirs += "../../testutils_robolectric/src/main/java/"
+            java.srcDirs += '../../testutils/src/main/java/'
+            java.srcDirs += '../../testutils_robolectric/src/main/java/'
         }
     }
 
@@ -54,12 +59,14 @@ android {
 dependencies {
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
+    compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersion
+    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
+    androidTestImplementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
     androidTestImplementation 'com.google.dexmaker:dexmaker:' + dexmakerVersion
     androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
     androidTestImplementation 'com.google.truth:truth:' + truthVersion
     androidTestImplementation 'org.mockito:mockito-core:' + mockitoVersion
-    androidTestImplementation 'com.android.support.test:runner:' + testRunnerVersion
-    androidTestUtil 'com.android.support.test:orchestrator:' + testRunnerVersion
+    androidTestAnnotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
     testImplementation 'com.google.truth:truth:' + truthVersion
     testImplementation 'junit:junit:' + junitVersion
     testImplementation 'org.mockito:mockito-core:' + mockitoVersion
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
index fe204822a8..a5c50a78f5 100644
--- a/library/core/proguard-rules.txt
+++ b/library/core/proguard-rules.txt
@@ -30,5 +30,10 @@
   <init>();
 }
 
+# Constructors accessed via reflection in DownloadAction
+-dontnote com.google.android.exoplayer2.source.dash.offline.DashDownloadAction
+-dontnote com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction
+-dontnote com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction
+
 # Don't warn about checkerframework
 -dontwarn org.checkerframework.**
diff --git a/library/core/src/androidTest/AndroidManifest.xml b/library/core/src/androidTest/AndroidManifest.xml
index 1aa47c10f6..d9104b1077 100644
--- a/library/core/src/androidTest/AndroidManifest.xml
+++ b/library/core/src/androidTest/AndroidManifest.xml
@@ -29,6 +29,6 @@
 
   <instrumentation
       android:targetPackage="com.google.android.exoplayer2.core.test"
-      android:name="android.test.InstrumentationTestRunner"/>
+      android:name="androidx.test.runner.AndroidJUnitRunner"/>
 
 </manifest>
diff --git a/library/core/src/androidTest/assets/bitmap/image_256_256.png b/library/core/src/androidTest/assets/bitmap/image_256_256.png
new file mode 100644
index 0000000000..cf1403eebd
Binary files /dev/null and b/library/core/src/androidTest/assets/bitmap/image_256_256.png differ
diff --git a/library/core/src/androidTest/assets/bitmap/image_80_60.bmp b/library/core/src/androidTest/assets/bitmap/image_80_60.bmp
new file mode 100644
index 0000000000..440c80f1b5
Binary files /dev/null and b/library/core/src/androidTest/assets/bitmap/image_80_60.bmp differ
diff --git a/library/core/src/androidTest/assets/mp4/testvid_1022ms.mp4 b/library/core/src/androidTest/assets/mp4/testvid_1022ms.mp4
new file mode 100644
index 0000000000..bbd2729c4d
Binary files /dev/null and b/library/core/src/androidTest/assets/mp4/testvid_1022ms.mp4 differ
diff --git a/library/core/src/androidTest/assets/mp4/video000.png b/library/core/src/androidTest/assets/mp4/video000.png
new file mode 100644
index 0000000000..5f2758fb29
Binary files /dev/null and b/library/core/src/androidTest/assets/mp4/video000.png differ
diff --git a/library/core/src/androidTest/assets/mp4/video014.png b/library/core/src/androidTest/assets/mp4/video014.png
new file mode 100644
index 0000000000..35bf00dcfa
Binary files /dev/null and b/library/core/src/androidTest/assets/mp4/video014.png differ
diff --git a/library/core/src/androidTest/assets/mp4/video015.png b/library/core/src/androidTest/assets/mp4/video015.png
new file mode 100644
index 0000000000..a6dfa8ce2b
Binary files /dev/null and b/library/core/src/androidTest/assets/mp4/video015.png differ
diff --git a/library/core/src/androidTest/assets/mp4/video016.png b/library/core/src/androidTest/assets/mp4/video016.png
new file mode 100644
index 0000000000..5877573d71
Binary files /dev/null and b/library/core/src/androidTest/assets/mp4/video016.png differ
diff --git a/library/core/src/androidTest/assets/mp4/video029.png b/library/core/src/androidTest/assets/mp4/video029.png
new file mode 100644
index 0000000000..9ab47773d4
Binary files /dev/null and b/library/core/src/androidTest/assets/mp4/video029.png differ
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
index 1133928e91..45b784e30f 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
@@ -28,8 +28,8 @@
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.FileNotFoundException;
@@ -87,7 +87,7 @@ public void testReadInvalidUri() throws Exception {
       fail();
     } catch (ContentDataSource.ContentDataSourceException e) {
       // Expected.
-      assertThat(e.getCause()).isInstanceOf(FileNotFoundException.class);
+      assertThat(e).hasCauseThat().isInstanceOf(FileNotFoundException.class);
     } finally {
       dataSource.close();
     }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
index be4a2a96dc..964f7266b5 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
@@ -19,9 +19,9 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import android.util.SparseArray;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
index afbbf6605f..c422bf33fa 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
@@ -18,8 +18,8 @@
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileOutputStream;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
new file mode 100644
index 0000000000..eb3bd4f91a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
+
+/** Abstract base {@link Player} which implements common implementation independent methods. */
+public abstract class BasePlayer implements Player {
+
+  protected final Timeline.Window window;
+
+  public BasePlayer() {
+    window = new Timeline.Window();
+  }
+
+  @Override
+  public final void seekToDefaultPosition() {
+    seekToDefaultPosition(getCurrentWindowIndex());
+  }
+
+  @Override
+  public final void seekToDefaultPosition(int windowIndex) {
+    seekTo(windowIndex, /* positionMs= */ C.TIME_UNSET);
+  }
+
+  @Override
+  public final void seekTo(long positionMs) {
+    seekTo(getCurrentWindowIndex(), positionMs);
+  }
+
+  @Override
+  public final boolean hasPrevious() {
+    return getPreviousWindowIndex() != C.INDEX_UNSET;
+  }
+
+  @Override
+  public final void previous() {
+    int previousWindowIndex = getPreviousWindowIndex();
+    if (previousWindowIndex != C.INDEX_UNSET) {
+      seekToDefaultPosition(previousWindowIndex);
+    }
+  }
+
+  @Override
+  public final boolean hasNext() {
+    return getNextWindowIndex() != C.INDEX_UNSET;
+  }
+
+  @Override
+  public final void next() {
+    int nextWindowIndex = getNextWindowIndex();
+    if (nextWindowIndex != C.INDEX_UNSET) {
+      seekToDefaultPosition(nextWindowIndex);
+    }
+  }
+
+  @Override
+  public final void stop() {
+    stop(/* reset= */ false);
+  }
+
+  @Override
+  public final int getNextWindowIndex() {
+    Timeline timeline = getCurrentTimeline();
+    return timeline.isEmpty()
+        ? C.INDEX_UNSET
+        : timeline.getNextWindowIndex(
+            getCurrentWindowIndex(), getRepeatModeForNavigation(), getShuffleModeEnabled());
+  }
+
+  @Override
+  public final int getPreviousWindowIndex() {
+    Timeline timeline = getCurrentTimeline();
+    return timeline.isEmpty()
+        ? C.INDEX_UNSET
+        : timeline.getPreviousWindowIndex(
+            getCurrentWindowIndex(), getRepeatModeForNavigation(), getShuffleModeEnabled());
+  }
+
+  @Override
+  @Nullable
+  public final Object getCurrentTag() {
+    int windowIndex = getCurrentWindowIndex();
+    Timeline timeline = getCurrentTimeline();
+    return windowIndex >= timeline.getWindowCount()
+        ? null
+        : timeline.getWindow(windowIndex, window, /* setTag= */ true).tag;
+  }
+
+  @Override
+  public final int getBufferedPercentage() {
+    long position = getBufferedPosition();
+    long duration = getDuration();
+    return position == C.TIME_UNSET || duration == C.TIME_UNSET
+        ? 0
+        : duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100);
+  }
+
+  @Override
+  public final boolean isCurrentWindowDynamic() {
+    Timeline timeline = getCurrentTimeline();
+    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
+  }
+
+  @Override
+  public final boolean isCurrentWindowSeekable() {
+    Timeline timeline = getCurrentTimeline();
+    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  }
+
+  @Override
+  public final long getContentDuration() {
+    Timeline timeline = getCurrentTimeline();
+    return timeline.isEmpty()
+        ? C.TIME_UNSET
+        : timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+  }
+
+  @RepeatMode
+  private int getRepeatModeForNavigation() {
+    @RepeatMode int repeatMode = getRepeatMode();
+    return repeatMode == REPEAT_MODE_ONE ? REPEAT_MODE_OFF : repeatMode;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index cb917b9b79..51e724bee1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -163,7 +163,7 @@ public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
   // PlayerMessage.Target implementation.
 
   @Override
-  public void handleMessage(int what, Object object) throws ExoPlaybackException {
+  public void handleMessage(int what, @Nullable Object object) throws ExoPlaybackException {
     // Do nothing.
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index de210f5eff..fac9818d9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -24,7 +24,11 @@
 import android.support.annotation.IntDef;
 import android.view.Surface;
 import com.google.android.exoplayer2.PlayerMessage.Target;
+import com.google.android.exoplayer2.audio.AuxEffectInfo;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
+import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.UUID;
@@ -77,6 +81,12 @@ private C() {}
    */
   public static final long NANOS_PER_SECOND = 1000000000L;
 
+  /** The number of bits per byte. */
+  public static final int BITS_PER_BYTE = 8;
+
+  /** The number of bytes per float. */
+  public static final int BYTES_PER_FLOAT = 4;
+
   /**
    * The name of the ASCII charset.
    */
@@ -102,8 +112,10 @@ private C() {}
   public static final String SANS_SERIF_NAME = "sans-serif";
 
   /**
-   * Crypto modes for a codec.
+   * Crypto modes for a codec. One of {@link #CRYPTO_MODE_UNENCRYPTED}, {@link #CRYPTO_MODE_AES_CTR}
+   * or {@link #CRYPTO_MODE_AES_CBC}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
   public @interface CryptoMode {}
@@ -126,7 +138,15 @@ private C() {}
    */
   public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
 
-  /** Represents an audio encoding, or an invalid or unset value. */
+  /**
+   * Represents an audio encoding, or an invalid or unset value. One of {@link Format#NO_VALUE},
+   * {@link #ENCODING_INVALID}, {@link #ENCODING_PCM_8BIT}, {@link #ENCODING_PCM_16BIT}, {@link
+   * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
+   * #ENCODING_PCM_MU_LAW}, {@link #ENCODING_PCM_A_LAW}, {@link #ENCODING_AC3}, {@link
+   * #ENCODING_E_AC3}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or {@link
+   * #ENCODING_DOLBY_TRUEHD}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     Format.NO_VALUE,
@@ -136,6 +156,8 @@ private C() {}
     ENCODING_PCM_24BIT,
     ENCODING_PCM_32BIT,
     ENCODING_PCM_FLOAT,
+    ENCODING_PCM_MU_LAW,
+    ENCODING_PCM_A_LAW,
     ENCODING_AC3,
     ENCODING_E_AC3,
     ENCODING_DTS,
@@ -145,11 +167,24 @@ private C() {}
   public @interface Encoding {}
 
   /**
-   * Represents a PCM audio encoding, or an invalid or unset value.
+   * Represents a PCM audio encoding, or an invalid or unset value. One of {@link Format#NO_VALUE},
+   * {@link #ENCODING_INVALID}, {@link #ENCODING_PCM_8BIT}, {@link #ENCODING_PCM_16BIT}, {@link
+   * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
+   * #ENCODING_PCM_MU_LAW} or {@link #ENCODING_PCM_A_LAW}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_PCM_FLOAT})
+  @IntDef({
+    Format.NO_VALUE,
+    ENCODING_INVALID,
+    ENCODING_PCM_8BIT,
+    ENCODING_PCM_16BIT,
+    ENCODING_PCM_24BIT,
+    ENCODING_PCM_32BIT,
+    ENCODING_PCM_FLOAT,
+    ENCODING_PCM_MU_LAW,
+    ENCODING_PCM_A_LAW
+  })
   public @interface PcmEncoding {}
   /** @see AudioFormat#ENCODING_INVALID */
   public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
@@ -163,6 +198,10 @@ private C() {}
   public static final int ENCODING_PCM_32BIT = 0x40000000;
   /** @see AudioFormat#ENCODING_PCM_FLOAT */
   public static final int ENCODING_PCM_FLOAT = AudioFormat.ENCODING_PCM_FLOAT;
+  /** Audio encoding for mu-law. */
+  public static final int ENCODING_PCM_MU_LAW = 0x10000000;
+  /** Audio encoding for A-law. */
+  public static final int ENCODING_PCM_A_LAW = 0x20000000;
   /** @see AudioFormat#ENCODING_AC3 */
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
   /** @see AudioFormat#ENCODING_E_AC3 */
@@ -175,18 +214,23 @@ private C() {}
   public static final int ENCODING_DOLBY_TRUEHD = AudioFormat.ENCODING_DOLBY_TRUEHD;
 
   /**
-   * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
-   */
-  @SuppressWarnings("deprecation")
-  public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
-      ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
-
-  /**
-   * Stream types for an {@link android.media.AudioTrack}.
+   * Stream types for an {@link android.media.AudioTrack}. One of {@link #STREAM_TYPE_ALARM}, {@link
+   * #STREAM_TYPE_DTMF}, {@link #STREAM_TYPE_MUSIC}, {@link #STREAM_TYPE_NOTIFICATION}, {@link
+   * #STREAM_TYPE_RING}, {@link #STREAM_TYPE_SYSTEM}, {@link #STREAM_TYPE_VOICE_CALL} or {@link
+   * #STREAM_TYPE_USE_DEFAULT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_DTMF, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION,
-      STREAM_TYPE_RING, STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL, STREAM_TYPE_USE_DEFAULT})
+  @IntDef({
+    STREAM_TYPE_ALARM,
+    STREAM_TYPE_DTMF,
+    STREAM_TYPE_MUSIC,
+    STREAM_TYPE_NOTIFICATION,
+    STREAM_TYPE_RING,
+    STREAM_TYPE_SYSTEM,
+    STREAM_TYPE_VOICE_CALL,
+    STREAM_TYPE_USE_DEFAULT
+  })
   public @interface StreamType {}
   /**
    * @see AudioManager#STREAM_ALARM
@@ -226,11 +270,19 @@ private C() {}
   public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
 
   /**
-   * Content types for {@link com.google.android.exoplayer2.audio.AudioAttributes}.
+   * Content types for {@link com.google.android.exoplayer2.audio.AudioAttributes}. One of {@link
+   * #CONTENT_TYPE_MOVIE}, {@link #CONTENT_TYPE_MUSIC}, {@link #CONTENT_TYPE_SONIFICATION}, {@link
+   * #CONTENT_TYPE_SPEECH} or {@link #CONTENT_TYPE_UNKNOWN}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({CONTENT_TYPE_MOVIE, CONTENT_TYPE_MUSIC, CONTENT_TYPE_SONIFICATION, CONTENT_TYPE_SPEECH,
-      CONTENT_TYPE_UNKNOWN})
+  @IntDef({
+    CONTENT_TYPE_MOVIE,
+    CONTENT_TYPE_MUSIC,
+    CONTENT_TYPE_SONIFICATION,
+    CONTENT_TYPE_SPEECH,
+    CONTENT_TYPE_UNKNOWN
+  })
   public @interface AudioContentType {}
   /**
    * @see android.media.AudioAttributes#CONTENT_TYPE_MOVIE
@@ -257,13 +309,17 @@ private C() {}
       android.media.AudioAttributes.CONTENT_TYPE_UNKNOWN;
 
   /**
-   * Flags for {@link com.google.android.exoplayer2.audio.AudioAttributes}.
-   * <p>
-   * Note that {@code FLAG_HW_AV_SYNC} is not available because the player takes care of setting the
-   * flag when tunneling is enabled via a track selector.
+   * Flags for {@link com.google.android.exoplayer2.audio.AudioAttributes}. Possible flag value is
+   * {@link #FLAG_AUDIBILITY_ENFORCED}.
+   *
+   * <p>Note that {@code FLAG_HW_AV_SYNC} is not available because the player takes care of setting
+   * the flag when tunneling is enabled via a track selector.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_AUDIBILITY_ENFORCED})
+  @IntDef(
+      flag = true,
+      value = {FLAG_AUDIBILITY_ENFORCED})
   public @interface AudioFlags {}
   /**
    * @see android.media.AudioAttributes#FLAG_AUDIBILITY_ENFORCED
@@ -272,23 +328,42 @@ private C() {}
       android.media.AudioAttributes.FLAG_AUDIBILITY_ENFORCED;
 
   /**
-   * Usage types for {@link com.google.android.exoplayer2.audio.AudioAttributes}.
+   * Usage types for {@link com.google.android.exoplayer2.audio.AudioAttributes}. One of {@link
+   * #USAGE_ALARM}, {@link #USAGE_ASSISTANCE_ACCESSIBILITY}, {@link
+   * #USAGE_ASSISTANCE_NAVIGATION_GUIDANCE}, {@link #USAGE_ASSISTANCE_SONIFICATION}, {@link
+   * #USAGE_ASSISTANT}, {@link #USAGE_GAME}, {@link #USAGE_MEDIA}, {@link #USAGE_NOTIFICATION},
+   * {@link #USAGE_NOTIFICATION_COMMUNICATION_DELAYED}, {@link
+   * #USAGE_NOTIFICATION_COMMUNICATION_INSTANT}, {@link #USAGE_NOTIFICATION_COMMUNICATION_REQUEST},
+   * {@link #USAGE_NOTIFICATION_EVENT}, {@link #USAGE_NOTIFICATION_RINGTONE}, {@link
+   * #USAGE_UNKNOWN}, {@link #USAGE_VOICE_COMMUNICATION} or {@link
+   * #USAGE_VOICE_COMMUNICATION_SIGNALLING}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({USAGE_ALARM, USAGE_ASSISTANCE_ACCESSIBILITY, USAGE_ASSISTANCE_NAVIGATION_GUIDANCE,
-      USAGE_ASSISTANCE_SONIFICATION, USAGE_GAME, USAGE_MEDIA, USAGE_NOTIFICATION,
-      USAGE_NOTIFICATION_COMMUNICATION_DELAYED, USAGE_NOTIFICATION_COMMUNICATION_INSTANT,
-      USAGE_NOTIFICATION_COMMUNICATION_REQUEST, USAGE_NOTIFICATION_EVENT,
-      USAGE_NOTIFICATION_RINGTONE, USAGE_UNKNOWN, USAGE_VOICE_COMMUNICATION,
-      USAGE_VOICE_COMMUNICATION_SIGNALLING})
+  @IntDef({
+    USAGE_ALARM,
+    USAGE_ASSISTANCE_ACCESSIBILITY,
+    USAGE_ASSISTANCE_NAVIGATION_GUIDANCE,
+    USAGE_ASSISTANCE_SONIFICATION,
+    USAGE_ASSISTANT,
+    USAGE_GAME,
+    USAGE_MEDIA,
+    USAGE_NOTIFICATION,
+    USAGE_NOTIFICATION_COMMUNICATION_DELAYED,
+    USAGE_NOTIFICATION_COMMUNICATION_INSTANT,
+    USAGE_NOTIFICATION_COMMUNICATION_REQUEST,
+    USAGE_NOTIFICATION_EVENT,
+    USAGE_NOTIFICATION_RINGTONE,
+    USAGE_UNKNOWN,
+    USAGE_VOICE_COMMUNICATION,
+    USAGE_VOICE_COMMUNICATION_SIGNALLING
+  })
   public @interface AudioUsage {}
   /**
    * @see android.media.AudioAttributes#USAGE_ALARM
    */
   public static final int USAGE_ALARM = android.media.AudioAttributes.USAGE_ALARM;
-  /**
-   * @see android.media.AudioAttributes#USAGE_ASSISTANCE_ACCESSIBILITY
-   */
+  /** @see android.media.AudioAttributes#USAGE_ASSISTANCE_ACCESSIBILITY */
   public static final int USAGE_ASSISTANCE_ACCESSIBILITY =
       android.media.AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY;
   /**
@@ -301,6 +376,8 @@ private C() {}
    */
   public static final int USAGE_ASSISTANCE_SONIFICATION =
       android.media.AudioAttributes.USAGE_ASSISTANCE_SONIFICATION;
+  /** @see android.media.AudioAttributes#USAGE_ASSISTANT */
+  public static final int USAGE_ASSISTANT = android.media.AudioAttributes.USAGE_ASSISTANT;
   /**
    * @see android.media.AudioAttributes#USAGE_GAME
    */
@@ -354,11 +431,48 @@ private C() {}
       android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION_SIGNALLING;
 
   /**
-   * Flags which can apply to a buffer containing a media sample.
+   * Audio focus types. One of {@link #AUDIOFOCUS_NONE}, {@link #AUDIOFOCUS_GAIN}, {@link
+   * #AUDIOFOCUS_GAIN_TRANSIENT}, {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or {@link
+   * #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}.
    */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    AUDIOFOCUS_NONE,
+    AUDIOFOCUS_GAIN,
+    AUDIOFOCUS_GAIN_TRANSIENT,
+    AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK,
+    AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE
+  })
+  public @interface AudioFocusGain {}
+  /** @see AudioManager#AUDIOFOCUS_NONE */
+  public static final int AUDIOFOCUS_NONE = AudioManager.AUDIOFOCUS_NONE;
+  /** @see AudioManager#AUDIOFOCUS_GAIN */
+  public static final int AUDIOFOCUS_GAIN = AudioManager.AUDIOFOCUS_GAIN;
+  /** @see AudioManager#AUDIOFOCUS_GAIN_TRANSIENT */
+  public static final int AUDIOFOCUS_GAIN_TRANSIENT = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
+  /** @see AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK */
+  public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK =
+      AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+  /** @see AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE */
+  public static final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE =
+      AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
+
+  /**
+   * Flags which can apply to a buffer containing a media sample. Possible flag values are {@link
+   * #BUFFER_FLAG_KEY_FRAME}, {@link #BUFFER_FLAG_END_OF_STREAM}, {@link #BUFFER_FLAG_ENCRYPTED} and
+   * {@link #BUFFER_FLAG_DECODE_ONLY}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
-      BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
+  @IntDef(
+      flag = true,
+      value = {
+        BUFFER_FLAG_KEY_FRAME,
+        BUFFER_FLAG_END_OF_STREAM,
+        BUFFER_FLAG_ENCRYPTED,
+        BUFFER_FLAG_DECODE_ONLY
+      })
   public @interface BufferFlags {}
   /**
    * Indicates that a buffer holds a synchronization sample.
@@ -368,18 +482,17 @@ private C() {}
    * Flag for empty buffers that signal that the end of the stream was reached.
    */
   public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
-  /**
-   * Indicates that a buffer is (at least partially) encrypted.
-   */
-  public static final int BUFFER_FLAG_ENCRYPTED = 0x40000000;
-  /**
-   * Indicates that a buffer should be decoded but not rendered.
-   */
-  public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
+  /** Indicates that a buffer is (at least partially) encrypted. */
+  public static final int BUFFER_FLAG_ENCRYPTED = 1 << 30; // 0x40000000
+  /** Indicates that a buffer should be decoded but not rendered. */
+  @SuppressWarnings("NumericOverflow")
+  public static final int BUFFER_FLAG_DECODE_ONLY = 1 << 31; // 0x80000000
 
   /**
-   * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s.
+   * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s. One of {@link
+   * #VIDEO_SCALING_MODE_SCALE_TO_FIT} or {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
   public @interface VideoScalingMode {}
@@ -399,25 +512,26 @@ private C() {}
   public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
 
   /**
-   * Track selection flags.
+   * Track selection flags. Possible flag values are {@link #SELECTION_FLAG_DEFAULT}, {@link
+   * #SELECTION_FLAG_FORCED} and {@link #SELECTION_FLAG_AUTOSELECT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
-      SELECTION_FLAG_AUTOSELECT})
+  @IntDef(
+      flag = true,
+      value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED, SELECTION_FLAG_AUTOSELECT})
   public @interface SelectionFlags {}
   /**
    * Indicates that the track should be selected if user preferences do not state otherwise.
    */
   public static final int SELECTION_FLAG_DEFAULT = 1;
-  /**
-   * Indicates that the track must be displayed. Only applies to text tracks.
-   */
-  public static final int SELECTION_FLAG_FORCED = 2;
+  /** Indicates that the track must be displayed. Only applies to text tracks. */
+  public static final int SELECTION_FLAG_FORCED = 1 << 1; // 2
   /**
    * Indicates that the player may choose to play the track in absence of an explicit user
    * preference.
    */
-  public static final int SELECTION_FLAG_AUTOSELECT = 4;
+  public static final int SELECTION_FLAG_AUTOSELECT = 1 << 2; // 4
 
   /**
    * Represents an undetermined language as an ISO 639 alpha-3 language code.
@@ -425,8 +539,10 @@ private C() {}
   public static final String LANGUAGE_UNDETERMINED = "und";
 
   /**
-   * Represents a streaming or other media type.
+   * Represents a streaming or other media type. One of {@link #TYPE_DASH}, {@link #TYPE_SS}, {@link
+   * #TYPE_HLS} or {@link #TYPE_OTHER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
   public @interface ContentType {}
@@ -469,66 +585,46 @@ private C() {}
    */
   public static final int RESULT_FORMAT_READ = -5;
 
-  /**
-   * A data type constant for data of unknown or unspecified type.
-   */
+  /** A data type constant for data of unknown or unspecified type. */
   public static final int DATA_TYPE_UNKNOWN = 0;
-  /**
-   * A data type constant for media, typically containing media samples.
-   */
+  /** A data type constant for media, typically containing media samples. */
   public static final int DATA_TYPE_MEDIA = 1;
-  /**
-   * A data type constant for media, typically containing only initialization data.
-   */
+  /** A data type constant for media, typically containing only initialization data. */
   public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
-  /**
-   * A data type constant for drm or encryption data.
-   */
+  /** A data type constant for drm or encryption data. */
   public static final int DATA_TYPE_DRM = 3;
-  /**
-   * A data type constant for a manifest file.
-   */
+  /** A data type constant for a manifest file. */
   public static final int DATA_TYPE_MANIFEST = 4;
-  /**
-   * A data type constant for time synchronization data.
-   */
+  /** A data type constant for time synchronization data. */
   public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
   /** A data type constant for ads loader data. */
   public static final int DATA_TYPE_AD = 6;
+  /**
+   * A data type constant for live progressive media streams, typically containing media samples.
+   */
+  public static final int DATA_TYPE_MEDIA_PROGRESSIVE_LIVE = 7;
   /**
    * Applications or extensions may define custom {@code DATA_TYPE_*} constants greater than or
    * equal to this value.
    */
   public static final int DATA_TYPE_CUSTOM_BASE = 10000;
 
-  /**
-   * A type constant for tracks of unknown type.
-   */
+  /** A type constant for tracks of unknown type. */
   public static final int TRACK_TYPE_UNKNOWN = -1;
-  /**
-   * A type constant for tracks of some default type, where the type itself is unknown.
-   */
+  /** A type constant for tracks of some default type, where the type itself is unknown. */
   public static final int TRACK_TYPE_DEFAULT = 0;
-  /**
-   * A type constant for audio tracks.
-   */
+  /** A type constant for audio tracks. */
   public static final int TRACK_TYPE_AUDIO = 1;
-  /**
-   * A type constant for video tracks.
-   */
+  /** A type constant for video tracks. */
   public static final int TRACK_TYPE_VIDEO = 2;
-  /**
-   * A type constant for text tracks.
-   */
+  /** A type constant for text tracks. */
   public static final int TRACK_TYPE_TEXT = 3;
-  /**
-   * A type constant for metadata tracks.
-   */
+  /** A type constant for metadata tracks. */
   public static final int TRACK_TYPE_METADATA = 4;
-  /**
-   * A type constant for a dummy or empty track.
-   */
-  public static final int TRACK_TYPE_NONE = 5;
+  /** A type constant for camera motion tracks. */
+  public static final int TRACK_TYPE_CAMERA_MOTION = 5;
+  /** A type constant for a dummy or empty track. */
+  public static final int TRACK_TYPE_NONE = 6;
   /**
    * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
    * equal to this value.
@@ -561,55 +657,42 @@ private C() {}
    */
   public static final int SELECTION_REASON_CUSTOM_BASE = 10000;
 
-  /**
-   * A default size in bytes for an individual allocation that forms part of a larger buffer.
-   */
+  /** A default size in bytes for an individual allocation that forms part of a larger buffer. */
   public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
 
-  /**
-   * A default size in bytes for a video buffer.
-   */
+  /** A default size in bytes for a video buffer. */
   public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
 
-  /**
-   * A default size in bytes for an audio buffer.
-   */
+  /** A default size in bytes for an audio buffer. */
   public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
 
-  /**
-   * A default size in bytes for a text buffer.
-   */
+  /** A default size in bytes for a text buffer. */
   public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
 
-  /**
-   * A default size in bytes for a metadata buffer.
-   */
+  /** A default size in bytes for a metadata buffer. */
   public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
 
-  /**
-   * A default size in bytes for a muxed buffer (e.g. containing video, audio and text).
-   */
-  public static final int DEFAULT_MUXED_BUFFER_SIZE = DEFAULT_VIDEO_BUFFER_SIZE
-      + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
+  /** A default size in bytes for a camera motion buffer. */
+  public static final int DEFAULT_CAMERA_MOTION_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
 
-  /**
-   * "cenc" scheme type name as defined in ISO/IEC 23001-7:2016.
-   */
+  /** A default size in bytes for a muxed buffer (e.g. containing video, audio and text). */
+  public static final int DEFAULT_MUXED_BUFFER_SIZE =
+      DEFAULT_VIDEO_BUFFER_SIZE + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
+
+  /** "cenc" scheme type name as defined in ISO/IEC 23001-7:2016. */
+  @SuppressWarnings("ConstantField")
   public static final String CENC_TYPE_cenc = "cenc";
 
-  /**
-   * "cbc1" scheme type name as defined in ISO/IEC 23001-7:2016.
-   */
+  /** "cbc1" scheme type name as defined in ISO/IEC 23001-7:2016. */
+  @SuppressWarnings("ConstantField")
   public static final String CENC_TYPE_cbc1 = "cbc1";
 
-  /**
-   * "cens" scheme type name as defined in ISO/IEC 23001-7:2016.
-   */
+  /** "cens" scheme type name as defined in ISO/IEC 23001-7:2016. */
+  @SuppressWarnings("ConstantField")
   public static final String CENC_TYPE_cens = "cens";
 
-  /**
-   * "cbcs" scheme type name as defined in ISO/IEC 23001-7:2016.
-   */
+  /** "cbcs" scheme type name as defined in ISO/IEC 23001-7:2016. */
+  @SuppressWarnings("ConstantField")
   public static final String CENC_TYPE_cbcs = "cbcs";
 
   /**
@@ -694,6 +777,27 @@ private C() {}
    */
   public static final int MSG_SET_SCALING_MODE = 4;
 
+  /**
+   * A type of a message that can be passed to an audio {@link Renderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be an {@link AuxEffectInfo}
+   * instance representing an auxiliary audio effect for the underlying audio track.
+   */
+  public static final int MSG_SET_AUX_EFFECT_INFO = 5;
+
+  /**
+   * The type of a message that can be passed to a video {@link Renderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be a {@link
+   * VideoFrameMetadataListener} instance, or null.
+   */
+  public static final int MSG_SET_VIDEO_FRAME_METADATA_LISTENER = 6;
+
+  /**
+   * The type of a message that can be passed to a camera motion {@link Renderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be a {@link CameraMotionListener}
+   * instance, or null.
+   */
+  public static final int MSG_SET_CAMERA_MOTION_LISTENER = 7;
+
   /**
    * Applications or extensions may define custom {@code MSG_*} constants that can be passed to
    * {@link Renderer}s. These custom constants must be greater than or equal to this value.
@@ -701,15 +805,18 @@ private C() {}
   public static final int MSG_CUSTOM_BASE = 10000;
 
   /**
-   * The stereo mode for 360/3D/VR videos.
+   * The stereo mode for 360/3D/VR videos. One of {@link Format#NO_VALUE}, {@link
+   * #STEREO_MODE_MONO}, {@link #STEREO_MODE_TOP_BOTTOM}, {@link #STEREO_MODE_LEFT_RIGHT} or {@link
+   * #STEREO_MODE_STEREO_MESH}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-      Format.NO_VALUE,
-      STEREO_MODE_MONO,
-      STEREO_MODE_TOP_BOTTOM,
-      STEREO_MODE_LEFT_RIGHT,
-      STEREO_MODE_STEREO_MESH
+    Format.NO_VALUE,
+    STEREO_MODE_MONO,
+    STEREO_MODE_TOP_BOTTOM,
+    STEREO_MODE_LEFT_RIGHT,
+    STEREO_MODE_STEREO_MESH
   })
   public @interface StereoMode {}
   /**
@@ -731,8 +838,10 @@ private C() {}
   public static final int STEREO_MODE_STEREO_MESH = 3;
 
   /**
-   * Video colorspaces.
+   * Video colorspaces. One of {@link Format#NO_VALUE}, {@link #COLOR_SPACE_BT709}, {@link
+   * #COLOR_SPACE_BT601} or {@link #COLOR_SPACE_BT2020}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
   public @interface ColorSpace {}
@@ -750,8 +859,10 @@ private C() {}
   public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
 
   /**
-   * Video color transfer characteristics.
+   * Video color transfer characteristics. One of {@link Format#NO_VALUE}, {@link
+   * #COLOR_TRANSFER_SDR}, {@link #COLOR_TRANSFER_ST2084} or {@link #COLOR_TRANSFER_HLG}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
   public @interface ColorTransfer {}
@@ -769,8 +880,10 @@ private C() {}
   public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
 
   /**
-   * Video color range.
+   * Video color range. One of {@link Format#NO_VALUE}, {@link #COLOR_RANGE_LIMITED} or {@link
+   * #COLOR_RANGE_FULL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
   public @interface ColorRange {}
@@ -797,6 +910,51 @@ private C() {}
    */
   public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
 
+  /**
+   * Network connection type. One of {@link #NETWORK_TYPE_UNKNOWN}, {@link #NETWORK_TYPE_OFFLINE},
+   * {@link #NETWORK_TYPE_WIFI}, {@link #NETWORK_TYPE_2G}, {@link #NETWORK_TYPE_3G}, {@link
+   * #NETWORK_TYPE_4G}, {@link #NETWORK_TYPE_CELLULAR_UNKNOWN}, {@link #NETWORK_TYPE_ETHERNET} or
+   * {@link #NETWORK_TYPE_OTHER}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    NETWORK_TYPE_UNKNOWN,
+    NETWORK_TYPE_OFFLINE,
+    NETWORK_TYPE_WIFI,
+    NETWORK_TYPE_2G,
+    NETWORK_TYPE_3G,
+    NETWORK_TYPE_4G,
+    NETWORK_TYPE_CELLULAR_UNKNOWN,
+    NETWORK_TYPE_ETHERNET,
+    NETWORK_TYPE_OTHER
+  })
+  public @interface NetworkType {}
+  /** Unknown network type. */
+  public static final int NETWORK_TYPE_UNKNOWN = 0;
+  /** No network connection. */
+  public static final int NETWORK_TYPE_OFFLINE = 1;
+  /** Network type for a Wifi connection. */
+  public static final int NETWORK_TYPE_WIFI = 2;
+  /** Network type for a 2G cellular connection. */
+  public static final int NETWORK_TYPE_2G = 3;
+  /** Network type for a 3G cellular connection. */
+  public static final int NETWORK_TYPE_3G = 4;
+  /** Network type for a 4G cellular connection. */
+  public static final int NETWORK_TYPE_4G = 5;
+  /**
+   * Network type for cellular connections which cannot be mapped to one of {@link
+   * #NETWORK_TYPE_2G}, {@link #NETWORK_TYPE_3G}, or {@link #NETWORK_TYPE_4G}.
+   */
+  public static final int NETWORK_TYPE_CELLULAR_UNKNOWN = 6;
+  /** Network type for an Ethernet connection. */
+  public static final int NETWORK_TYPE_ETHERNET = 7;
+  /**
+   * Network type for other connections which are not Wifi or cellular (e.g. Ethernet, VPN,
+   * Bluetooth).
+   */
+  public static final int NETWORK_TYPE_OTHER = 8;
+
   /**
    * Converts a time in microseconds to the corresponding time in milliseconds, preserving
    * {@link #TIME_UNSET} and {@link #TIME_END_OF_SOURCE} values.
@@ -820,7 +978,10 @@ public static long msToUs(long timeMs) {
   }
 
   /**
-   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+   * Returns a newly generated audio session identifier, or {@link AudioManager#ERROR} if an error
+   * occurred in which case audio playback may fail.
+   *
+   * @see AudioManager#generateAudioSessionId()
    */
   @TargetApi(21)
   public static int generateAudioSessionIdV21(Context context) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index f8b7f5f5c2..c109ed81c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -52,14 +52,20 @@
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS = 5000;
 
   /**
-   * The default target buffer size in bytes. When set to {@link C#LENGTH_UNSET}, the load control
-   * automatically determines its target buffer size.
+   * The default target buffer size in bytes. The value ({@link C#LENGTH_UNSET}) means that the load
+   * control will calculate the target buffer size based on the selected tracks.
    */
   public static final int DEFAULT_TARGET_BUFFER_BYTES = C.LENGTH_UNSET;
 
   /** The default prioritization of buffer time constraints over size constraints. */
   public static final boolean DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS = true;
 
+  /** The default back buffer duration in milliseconds. */
+  public static final int DEFAULT_BACK_BUFFER_DURATION_MS = 0;
+
+  /** The default for whether the back buffer is retained from the previous keyframe. */
+  public static final boolean DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME = false;
+
   /** Builder for {@link DefaultLoadControl}. */
   public static final class Builder {
 
@@ -71,6 +77,9 @@
     private int targetBufferBytes;
     private boolean prioritizeTimeOverSizeThresholds;
     private PriorityTaskManager priorityTaskManager;
+    private int backBufferDurationMs;
+    private boolean retainBackBufferFromKeyframe;
+    private boolean createDefaultLoadControlCalled;
 
     /** Constructs a new instance. */
     public Builder() {
@@ -82,6 +91,8 @@ public Builder() {
       targetBufferBytes = DEFAULT_TARGET_BUFFER_BYTES;
       prioritizeTimeOverSizeThresholds = DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS;
       priorityTaskManager = null;
+      backBufferDurationMs = DEFAULT_BACK_BUFFER_DURATION_MS;
+      retainBackBufferFromKeyframe = DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME;
     }
 
     /**
@@ -89,8 +100,10 @@ public Builder() {
      *
      * @param allocator The {@link DefaultAllocator}.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setAllocator(DefaultAllocator allocator) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.allocator = allocator;
       return this;
     }
@@ -108,12 +121,14 @@ public Builder setAllocator(DefaultAllocator allocator) {
      *     for playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be
      *     caused by buffer depletion rather than a user action.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setBufferDurationsMs(
         int minBufferMs,
         int maxBufferMs,
         int bufferForPlaybackMs,
         int bufferForPlaybackAfterRebufferMs) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.minBufferMs = minBufferMs;
       this.maxBufferMs = maxBufferMs;
       this.bufferForPlaybackMs = bufferForPlaybackMs;
@@ -123,13 +138,14 @@ public Builder setBufferDurationsMs(
 
     /**
      * Sets the target buffer size in bytes. If set to {@link C#LENGTH_UNSET}, the target buffer
-     * size will be calculated using {@link #calculateTargetBufferSize(Renderer[],
-     * TrackSelectionArray)}.
+     * size will be calculated based on the selected tracks.
      *
      * @param targetBufferBytes The target buffer size in bytes.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setTargetBufferBytes(int targetBufferBytes) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.targetBufferBytes = targetBufferBytes;
       return this;
     }
@@ -141,20 +157,47 @@ public Builder setTargetBufferBytes(int targetBufferBytes) {
      * @param prioritizeTimeOverSizeThresholds Whether the load control prioritizes buffer time
      *     constraints over buffer size constraints.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setPrioritizeTimeOverSizeThresholds(boolean prioritizeTimeOverSizeThresholds) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.prioritizeTimeOverSizeThresholds = prioritizeTimeOverSizeThresholds;
       return this;
     }
 
-    /** Sets the {@link PriorityTaskManager} to use. */
+    /**
+     * Sets the {@link PriorityTaskManager} to use.
+     *
+     * @param priorityTaskManager The {@link PriorityTaskManager} to use.
+     * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
+     */
     public Builder setPriorityTaskManager(PriorityTaskManager priorityTaskManager) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.priorityTaskManager = priorityTaskManager;
       return this;
     }
 
+    /**
+     * Sets the back buffer duration, and whether the back buffer is retained from the previous
+     * keyframe.
+     *
+     * @param backBufferDurationMs The back buffer duration in milliseconds.
+     * @param retainBackBufferFromKeyframe Whether the back buffer is retained from the previous
+     *     keyframe.
+     * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
+     */
+    public Builder setBackBuffer(int backBufferDurationMs, boolean retainBackBufferFromKeyframe) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
+      this.backBufferDurationMs = backBufferDurationMs;
+      this.retainBackBufferFromKeyframe = retainBackBufferFromKeyframe;
+      return this;
+    }
+
     /** Creates a {@link DefaultLoadControl}. */
     public DefaultLoadControl createDefaultLoadControl() {
+      createDefaultLoadControlCalled = true;
       if (allocator == null) {
         allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
       }
@@ -166,7 +209,9 @@ public DefaultLoadControl createDefaultLoadControl() {
           bufferForPlaybackAfterRebufferMs,
           targetBufferBytes,
           prioritizeTimeOverSizeThresholds,
-          priorityTaskManager);
+          priorityTaskManager,
+          backBufferDurationMs,
+          retainBackBufferFromKeyframe);
     }
   }
 
@@ -179,19 +224,21 @@ public DefaultLoadControl createDefaultLoadControl() {
   private final int targetBufferBytesOverwrite;
   private final boolean prioritizeTimeOverSizeThresholds;
   private final PriorityTaskManager priorityTaskManager;
+  private final long backBufferDurationUs;
+  private final boolean retainBackBufferFromKeyframe;
 
   private int targetBufferSize;
   private boolean isBuffering;
 
-  /**
-   * Constructs a new instance, using the {@code DEFAULT_*} constants defined in this class.
-   */
+  /** Constructs a new instance, using the {@code DEFAULT_*} constants defined in this class. */
+  @SuppressWarnings("deprecation")
   public DefaultLoadControl() {
     this(new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE));
   }
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultLoadControl(DefaultAllocator allocator) {
     this(
         allocator,
@@ -205,6 +252,7 @@ public DefaultLoadControl(DefaultAllocator allocator) {
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultLoadControl(
       DefaultAllocator allocator,
       int minBufferMs,
@@ -221,7 +269,7 @@ public DefaultLoadControl(
         bufferForPlaybackAfterRebufferMs,
         targetBufferBytes,
         prioritizeTimeOverSizeThresholds,
-        null);
+        /* priorityTaskManager= */ null);
   }
 
   /** @deprecated Use {@link Builder} instead. */
@@ -235,6 +283,30 @@ public DefaultLoadControl(
       int targetBufferBytes,
       boolean prioritizeTimeOverSizeThresholds,
       PriorityTaskManager priorityTaskManager) {
+    this(
+        allocator,
+        minBufferMs,
+        maxBufferMs,
+        bufferForPlaybackMs,
+        bufferForPlaybackAfterRebufferMs,
+        targetBufferBytes,
+        prioritizeTimeOverSizeThresholds,
+        priorityTaskManager,
+        DEFAULT_BACK_BUFFER_DURATION_MS,
+        DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME);
+  }
+
+  protected DefaultLoadControl(
+      DefaultAllocator allocator,
+      int minBufferMs,
+      int maxBufferMs,
+      int bufferForPlaybackMs,
+      int bufferForPlaybackAfterRebufferMs,
+      int targetBufferBytes,
+      boolean prioritizeTimeOverSizeThresholds,
+      PriorityTaskManager priorityTaskManager,
+      int backBufferDurationMs,
+      boolean retainBackBufferFromKeyframe) {
     assertGreaterOrEqual(bufferForPlaybackMs, 0, "bufferForPlaybackMs", "0");
     assertGreaterOrEqual(
         bufferForPlaybackAfterRebufferMs, 0, "bufferForPlaybackAfterRebufferMs", "0");
@@ -245,15 +317,18 @@ public DefaultLoadControl(
         "minBufferMs",
         "bufferForPlaybackAfterRebufferMs");
     assertGreaterOrEqual(maxBufferMs, minBufferMs, "maxBufferMs", "minBufferMs");
+    assertGreaterOrEqual(backBufferDurationMs, 0, "backBufferDurationMs", "0");
 
     this.allocator = allocator;
-    minBufferUs = minBufferMs * 1000L;
-    maxBufferUs = maxBufferMs * 1000L;
-    bufferForPlaybackUs = bufferForPlaybackMs * 1000L;
-    bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
-    targetBufferBytesOverwrite = targetBufferBytes;
+    this.minBufferUs = C.msToUs(minBufferMs);
+    this.maxBufferUs = C.msToUs(maxBufferMs);
+    this.bufferForPlaybackUs = C.msToUs(bufferForPlaybackMs);
+    this.bufferForPlaybackAfterRebufferUs = C.msToUs(bufferForPlaybackAfterRebufferMs);
+    this.targetBufferBytesOverwrite = targetBufferBytes;
     this.prioritizeTimeOverSizeThresholds = prioritizeTimeOverSizeThresholds;
     this.priorityTaskManager = priorityTaskManager;
+    this.backBufferDurationUs = C.msToUs(backBufferDurationMs);
+    this.retainBackBufferFromKeyframe = retainBackBufferFromKeyframe;
   }
 
   @Override
@@ -288,12 +363,12 @@ public Allocator getAllocator() {
 
   @Override
   public long getBackBufferDurationUs() {
-    return 0;
+    return backBufferDurationUs;
   }
 
   @Override
   public boolean retainBackBufferFromKeyframe() {
-    return false;
+    return retainBackBufferFromKeyframe;
   }
 
   @Override
@@ -310,7 +385,7 @@ public boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpee
     }
     if (bufferedDurationUs < minBufferUs) {
       isBuffering = prioritizeTimeOverSizeThresholds || !targetBufferSizeReached;
-    } else if (bufferedDurationUs > maxBufferUs || targetBufferSizeReached) {
+    } else if (bufferedDurationUs >= maxBufferUs || targetBufferSizeReached) {
       isBuffering = false;
     } // Else don't change the buffering state
     if (priorityTaskManager != null && isBuffering != wasBuffering) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 6cab53b78a..cc16c43b05 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -20,7 +20,6 @@
 import android.os.Looper;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
@@ -33,8 +32,11 @@
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import com.google.android.exoplayer2.video.spherical.CameraMotionRenderer;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Constructor;
@@ -52,11 +54,12 @@
   public static final long DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS = 5000;
 
   /**
-   * Modes for using extension renderers.
+   * Modes for using extension renderers. One of {@link #EXTENSION_RENDERER_MODE_OFF}, {@link
+   * #EXTENSION_RENDERER_MODE_ON} or {@link #EXTENSION_RENDERER_MODE_PREFER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON,
-      EXTENSION_RENDERER_MODE_PREFER})
+  @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON, EXTENSION_RENDERER_MODE_PREFER})
   public @interface ExtensionRendererMode {}
   /**
    * Do not allow use of extension renderers.
@@ -82,7 +85,7 @@
   protected static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
 
   private final Context context;
-  @Nullable private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
+  private final @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
   private final @ExtensionRendererMode int extensionRendererMode;
   private final long allowedVideoJoiningTimeMs;
 
@@ -98,6 +101,7 @@ public DefaultRenderersFactory(Context context) {
    *     directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultRenderersFactory(
       Context context, @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     this(context, drmSessionManager, EXTENSION_RENDERER_MODE_OFF);
@@ -111,7 +115,7 @@ public DefaultRenderersFactory(
    */
   public DefaultRenderersFactory(
       Context context, @ExtensionRendererMode int extensionRendererMode) {
-    this(context, null, extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
+    this(context, extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
   }
 
   /**
@@ -119,6 +123,7 @@ public DefaultRenderersFactory(
    *     DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultRenderersFactory(
       Context context,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
@@ -138,7 +143,10 @@ public DefaultRenderersFactory(
       Context context,
       @ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
-    this(context, null, extensionRendererMode, allowedVideoJoiningTimeMs);
+    this.context = context;
+    this.extensionRendererMode = extensionRendererMode;
+    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
+    this.drmSessionManager = null;
   }
 
   /**
@@ -177,6 +185,7 @@ public DefaultRenderersFactory(
         extensionRendererMode, renderersList);
     buildMetadataRenderers(context, metadataRendererOutput, eventHandler.getLooper(),
         extensionRendererMode, renderersList);
+    buildCameraMotionRenderers(context, extensionRendererMode, renderersList);
     buildMiscellaneousRenderers(context, eventHandler, extensionRendererMode, renderersList);
     return renderersList.toArray(new Renderer[renderersList.size()]);
   }
@@ -355,12 +364,14 @@ protected void buildAudioRenderers(Context context,
    *
    * @param context The {@link Context} associated with the player.
    * @param output An output for the renderers.
-   * @param outputLooper The looper associated with the thread on which the output should be
-   *     called.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
    * @param extensionRendererMode The extension renderer mode.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildTextRenderers(Context context, TextOutput output, Looper outputLooper,
+  protected void buildTextRenderers(
+      Context context,
+      TextOutput output,
+      Looper outputLooper,
       @ExtensionRendererMode int extensionRendererMode,
       ArrayList<Renderer> out) {
     out.add(new TextRenderer(output, outputLooper));
@@ -371,16 +382,31 @@ protected void buildTextRenderers(Context context, TextOutput output, Looper out
    *
    * @param context The {@link Context} associated with the player.
    * @param output An output for the renderers.
-   * @param outputLooper The looper associated with the thread on which the output should be
-   *     called.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
    * @param extensionRendererMode The extension renderer mode.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildMetadataRenderers(Context context, MetadataOutput output, Looper outputLooper,
-      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
+  protected void buildMetadataRenderers(
+      Context context,
+      MetadataOutput output,
+      Looper outputLooper,
+      @ExtensionRendererMode int extensionRendererMode,
+      ArrayList<Renderer> out) {
     out.add(new MetadataRenderer(output, outputLooper));
   }
 
+  /**
+   * Builds camera motion renderers for use by the player.
+   *
+   * @param context The {@link Context} associated with the player.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param out An array to which the built renderers should be appended.
+   */
+  protected void buildCameraMotionRenderers(
+      Context context, @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
+    out.add(new CameraMotionRenderer());
+  }
+
   /**
    * Builds any miscellaneous renderers used by the player.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
index ca7367f1b0..6b84245141 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -28,8 +29,10 @@
 public final class ExoPlaybackException extends Exception {
 
   /**
-   * The type of source that produced the error.
+   * The type of source that produced the error. One of {@link #TYPE_SOURCE}, {@link #TYPE_RENDERER}
+   * or {@link #TYPE_UNEXPECTED}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_SOURCE, TYPE_RENDERER, TYPE_UNEXPECTED})
   public @interface Type {}
@@ -63,25 +66,27 @@
    */
   public final int rendererIndex;
 
+  private final Throwable cause;
+
   /**
-   * Creates an instance of type {@link #TYPE_RENDERER}.
+   * Creates an instance of type {@link #TYPE_SOURCE}.
    *
    * @param cause The cause of the failure.
-   * @param rendererIndex The index of the renderer in which the failure occurred.
    * @return The created instance.
    */
-  public static ExoPlaybackException createForRenderer(Exception cause, int rendererIndex) {
-    return new ExoPlaybackException(TYPE_RENDERER, null, cause, rendererIndex);
+  public static ExoPlaybackException createForSource(IOException cause) {
+    return new ExoPlaybackException(TYPE_SOURCE, cause, C.INDEX_UNSET);
   }
 
   /**
-   * Creates an instance of type {@link #TYPE_SOURCE}.
+   * Creates an instance of type {@link #TYPE_RENDERER}.
    *
    * @param cause The cause of the failure.
+   * @param rendererIndex The index of the renderer in which the failure occurred.
    * @return The created instance.
    */
-  public static ExoPlaybackException createForSource(IOException cause) {
-    return new ExoPlaybackException(TYPE_SOURCE, null, cause, C.INDEX_UNSET);
+  public static ExoPlaybackException createForRenderer(Exception cause, int rendererIndex) {
+    return new ExoPlaybackException(TYPE_RENDERER, cause, rendererIndex);
   }
 
   /**
@@ -91,13 +96,13 @@ public static ExoPlaybackException createForSource(IOException cause) {
    * @return The created instance.
    */
   /* package */ static ExoPlaybackException createForUnexpected(RuntimeException cause) {
-    return new ExoPlaybackException(TYPE_UNEXPECTED, null, cause, C.INDEX_UNSET);
+    return new ExoPlaybackException(TYPE_UNEXPECTED, cause, C.INDEX_UNSET);
   }
 
-  private ExoPlaybackException(@Type int type, String message, Throwable cause,
-      int rendererIndex) {
-    super(message, cause);
+  private ExoPlaybackException(@Type int type, Throwable cause, int rendererIndex) {
+    super(cause);
     this.type = type;
+    this.cause = cause;
     this.rendererIndex = rendererIndex;
   }
 
@@ -108,7 +113,7 @@ private ExoPlaybackException(@Type int type, String message, Throwable cause,
    */
   public IOException getSourceException() {
     Assertions.checkState(type == TYPE_SOURCE);
-    return (IOException) getCause();
+    return (IOException) cause;
   }
 
   /**
@@ -118,7 +123,7 @@ public IOException getSourceException() {
    */
   public Exception getRendererException() {
     Assertions.checkState(type == TYPE_RENDERER);
-    return (Exception) getCause();
+    return (Exception) cause;
   }
 
   /**
@@ -128,7 +133,7 @@ public Exception getRendererException() {
    */
   public RuntimeException getUnexpectedException() {
     Assertions.checkState(type == TYPE_UNEXPECTED);
-    return (RuntimeException) getCause();
+    return (RuntimeException) cause;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index b97790d5fb..0e8c176486 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -89,12 +89,18 @@
  * model">
  *
  * <ul>
- *   <li>ExoPlayer instances must be accessed from a single application thread. This must be the
- *       thread the player is created on if that thread has a {@link Looper}, or the application's
- *       main thread otherwise.
- *   <li>Registered listeners are called on the thread the player is created on if that thread has a
- *       {@link Looper}, or the application's main thread otherwise. Note that this means registered
- *       listeners are called on the same thread which must be used to access the player.
+ *   <li>ExoPlayer instances must be accessed from a single application thread. For the vast
+ *       majority of cases this should be the application's main thread. Using the application's
+ *       main thread is also a requirement when using ExoPlayer's UI components or the IMA
+ *       extension. The thread on which an ExoPlayer instance must be accessed can be explicitly
+ *       specified by passing a `Looper` when creating the player. If no `Looper` is specified, then
+ *       the `Looper` of the thread that the player is created on is used, or if that thread does
+ *       not have a `Looper`, the `Looper` of the application's main thread is used. In all cases
+ *       the `Looper` of the thread from which the player must be accessed can be queried using
+ *       {@link #getApplicationLooper()}.
+ *   <li>Registered listeners are called on the thread associated with {@link
+ *       #getApplicationLooper()}. Note that this means registered listeners are called on the same
+ *       thread which must be used to access the player.
  *   <li>An internal playback thread is responsible for playback. Injected player components such as
  *       Renderers, MediaSources, TrackSelectors and LoadControls are called by the player on this
  *       thread.
@@ -178,12 +184,14 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
   @Deprecated
   @RepeatMode int REPEAT_MODE_ALL = Player.REPEAT_MODE_ALL;
 
+  /** Returns the {@link Looper} associated with the playback thread. */
+  Looper getPlaybackLooper();
+
   /**
-   * Gets the {@link Looper} associated with the playback thread.
-   *
-   * @return The {@link Looper} associated with the playback thread.
+   * Retries a failed or stopped playback. Does nothing if the player has been reset, or if playback
+   * has not failed or been stopped.
    */
-  Looper getPlaybackLooper();
+  void retry();
 
   /**
    * Prepares the player to play the provided {@link MediaSource}. Equivalent to
@@ -224,6 +232,7 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
 
   /** @deprecated Use {@link #createMessage(PlayerMessage.Target)} instead. */
   @Deprecated
+  @SuppressWarnings("deprecation")
   void sendMessages(ExoPlayerMessage... messages);
 
   /**
@@ -231,6 +240,7 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
    *     PlayerMessage#blockUntilDelivered()}.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   void blockingSendMessages(ExoPlayerMessage... messages);
 
   /**
@@ -239,4 +249,7 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
    * @param seekParameters The seek parameters, or {@code null} to use the defaults.
    */
   void setSeekParameters(@Nullable SeekParameters seekParameters);
+
+  /** Returns the currently active {@link SeekParameters} of the player. */
+  SeekParameters getSeekParameters();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 8095ed9c64..81f4285a08 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -16,18 +16,26 @@
 package com.google.android.exoplayer2;
 
 import android.content.Context;
+import android.os.Looper;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.Util;
 
 /**
  * A factory for {@link ExoPlayer} instances.
  */
 public final class ExoPlayerFactory {
 
+  private static @Nullable BandwidthMeter singletonBandwidthMeter;
+
   private ExoPlayerFactory() {}
 
   /**
@@ -36,13 +44,14 @@ private ExoPlayerFactory() {}
    * @param context A {@link Context}.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @deprecated Use {@link #newSimpleInstance(RenderersFactory, TrackSelector, LoadControl)}.
+   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
+   *     LoadControl)}.
    */
   @Deprecated
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl) {
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context, TrackSelector trackSelector, LoadControl loadControl) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
-    return newSimpleInstance(renderersFactory, trackSelector, loadControl);
+    return newSimpleInstance(context, renderersFactory, trackSelector, loadControl);
   }
 
   /**
@@ -53,14 +62,18 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
-   * @deprecated Use {@link #newSimpleInstance(RenderersFactory, TrackSelector, LoadControl)}.
+   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
+   *     LoadControl)}.
    */
   @Deprecated
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      TrackSelector trackSelector,
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
-    return newSimpleInstance(renderersFactory, trackSelector, loadControl, drmSessionManager);
+    return newSimpleInstance(
+        context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
 
   /**
@@ -74,14 +87,19 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param extensionRendererMode The extension renderer mode, which determines if and how available
    *     extension renderers are used. Note that extensions must be included in the application
    *     build for them to be considered available.
-   * @deprecated Use {@link #newSimpleInstance(RenderersFactory, TrackSelector, LoadControl)}.
+   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
+   *     LoadControl)}.
    */
   @Deprecated
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context, extensionRendererMode);
-    return newSimpleInstance(renderersFactory, trackSelector, loadControl, drmSessionManager);
+    return newSimpleInstance(
+        context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
 
   /**
@@ -97,16 +115,30 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    *     build for them to be considered available.
    * @param allowedVideoJoiningTimeMs The maximum duration for which a video renderer can attempt to
    *     seamlessly join an ongoing playback.
-   * @deprecated Use {@link #newSimpleInstance(RenderersFactory, TrackSelector, LoadControl)}.
+   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
+   *     LoadControl)}.
    */
   @Deprecated
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
     RenderersFactory renderersFactory =
         new DefaultRenderersFactory(context, extensionRendererMode, allowedVideoJoiningTimeMs);
-    return newSimpleInstance(renderersFactory, trackSelector, loadControl, drmSessionManager);
+    return newSimpleInstance(
+        context, renderersFactory, trackSelector, loadControl, drmSessionManager);
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance.
+   *
+   * @param context A {@link Context}.
+   */
+  public static SimpleExoPlayer newSimpleInstance(Context context) {
+    return newSimpleInstance(context, new DefaultTrackSelector());
   }
 
   /**
@@ -116,52 +148,82 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    */
   public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector) {
-    return newSimpleInstance(new DefaultRenderersFactory(context), trackSelector);
+    return newSimpleInstance(context, new DefaultRenderersFactory(context), trackSelector);
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance.
+   *
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector)}. The use
+   *     of {@link SimpleExoPlayer#setAudioAttributes(AudioAttributes, boolean)} to manage audio
+   *     focus will be unavailable for the {@link SimpleExoPlayer} returned by this method.
+   */
+  @Deprecated
+  @SuppressWarnings("nullness:argument.type.incompatible")
+  public static SimpleExoPlayer newSimpleInstance(
+      RenderersFactory renderersFactory, TrackSelector trackSelector) {
+    return newSimpleInstance(
+        /* context= */ null, renderersFactory, trackSelector, new DefaultLoadControl());
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    */
-  public static SimpleExoPlayer newSimpleInstance(RenderersFactory renderersFactory,
-      TrackSelector trackSelector) {
-    return newSimpleInstance(renderersFactory, trackSelector, new DefaultLoadControl());
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context, RenderersFactory renderersFactory, TrackSelector trackSelector) {
+    return newSimpleInstance(context, renderersFactory, trackSelector, new DefaultLoadControl());
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
    */
   public static SimpleExoPlayer newSimpleInstance(
+      Context context,
       RenderersFactory renderersFactory,
       TrackSelector trackSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     return newSimpleInstance(
-        renderersFactory, trackSelector, new DefaultLoadControl(), drmSessionManager);
+        context, renderersFactory, trackSelector, new DefaultLoadControl(), drmSessionManager);
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
-  public static SimpleExoPlayer newSimpleInstance(RenderersFactory renderersFactory,
-      TrackSelector trackSelector, LoadControl loadControl) {
-    return new SimpleExoPlayer(
-        renderersFactory, trackSelector, loadControl, /* drmSessionManager= */ null);
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl) {
+    return newSimpleInstance(
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        /* drmSessionManager= */ null,
+        Util.getLooper());
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
@@ -169,16 +231,48 @@ public static SimpleExoPlayer newSimpleInstance(RenderersFactory renderersFactor
    *     will not be used for DRM protected playbacks.
    */
   public static SimpleExoPlayer newSimpleInstance(
+      Context context,
       RenderersFactory renderersFactory,
       TrackSelector trackSelector,
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-    return new SimpleExoPlayer(renderersFactory, trackSelector, loadControl, drmSessionManager);
+    return newSimpleInstance(
+        context, renderersFactory, trackSelector, loadControl, drmSessionManager, Util.getLooper());
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance.
+   *
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
+   */
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      BandwidthMeter bandwidthMeter) {
+    return newSimpleInstance(
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        drmSessionManager,
+        bandwidthMeter,
+        new AnalyticsCollector.Factory(),
+        Util.getLooper());
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
@@ -188,13 +282,116 @@ public static SimpleExoPlayer newSimpleInstance(
    *     will collect and forward all player events.
    */
   public static SimpleExoPlayer newSimpleInstance(
+      Context context,
       RenderersFactory renderersFactory,
       TrackSelector trackSelector,
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       AnalyticsCollector.Factory analyticsCollectorFactory) {
+    return newSimpleInstance(
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        drmSessionManager,
+        analyticsCollectorFactory,
+        Util.getLooper());
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance.
+   *
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
+   */
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      Looper looper) {
+    return newSimpleInstance(
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        drmSessionManager,
+        new AnalyticsCollector.Factory(),
+        looper);
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance.
+   *
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   * @param analyticsCollectorFactory A factory for creating the {@link AnalyticsCollector} that
+   *     will collect and forward all player events.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
+   */
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      AnalyticsCollector.Factory analyticsCollectorFactory,
+      Looper looper) {
+    return newSimpleInstance(
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        drmSessionManager,
+        getDefaultBandwidthMeter(),
+        analyticsCollectorFactory,
+        looper);
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance.
+   *
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   * @param analyticsCollectorFactory A factory for creating the {@link AnalyticsCollector} that
+   *     will collect and forward all player events.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
+   */
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      BandwidthMeter bandwidthMeter,
+      AnalyticsCollector.Factory analyticsCollectorFactory,
+      Looper looper) {
     return new SimpleExoPlayer(
-        renderersFactory, trackSelector, loadControl, drmSessionManager, analyticsCollectorFactory);
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        drmSessionManager,
+        bandwidthMeter,
+        analyticsCollectorFactory,
+        looper);
   }
 
   /**
@@ -216,7 +413,47 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSel
    */
   public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl) {
-    return new ExoPlayerImpl(renderers, trackSelector, loadControl, Clock.DEFAULT);
+    return newInstance(renderers, trackSelector, loadControl, Util.getLooper());
+  }
+
+  /**
+   * Creates an {@link ExoPlayer} instance.
+   *
+   * @param renderers The {@link Renderer}s that will be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
+   */
+  public static ExoPlayer newInstance(
+      Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl, Looper looper) {
+    return newInstance(renderers, trackSelector, loadControl, getDefaultBandwidthMeter(), looper);
+  }
+
+  /**
+   * Creates an {@link ExoPlayer} instance.
+   *
+   * @param renderers The {@link Renderer}s that will be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
+   */
+  public static ExoPlayer newInstance(
+      Renderer[] renderers,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      BandwidthMeter bandwidthMeter,
+      Looper looper) {
+    return new ExoPlayerImpl(
+        renderers, trackSelector, loadControl, bandwidthMeter, Clock.DEFAULT, looper);
   }
 
+  private static synchronized BandwidthMeter getDefaultBandwidthMeter() {
+    if (singletonBandwidthMeter == null) {
+      singletonBandwidthMeter = new DefaultBandwidthMeter.Builder().build();
+    }
+    return singletonBandwidthMeter;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 9a9577c50a..35fa85e467 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -20,7 +20,6 @@
 import android.os.Looper;
 import android.os.Message;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -30,8 +29,10 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -39,31 +40,38 @@
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-/**
- * An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}.
- */
-/* package */ final class ExoPlayerImpl implements ExoPlayer {
+/** An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}. */
+/* package */ final class ExoPlayerImpl extends BasePlayer implements ExoPlayer {
 
   private static final String TAG = "ExoPlayerImpl";
 
+  /**
+   * This empty track selector result can only be used for {@link PlaybackInfo#trackSelectorResult}
+   * when the player does not have any track selection made (such as when player is reset, or when
+   * player seeks to an unprepared period). It will not be used as result of any {@link
+   * TrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)} operation.
+   */
+  /* package */ final TrackSelectorResult emptyTrackSelectorResult;
+
   private final Renderer[] renderers;
   private final TrackSelector trackSelector;
-  private final TrackSelectorResult emptyTrackSelectorResult;
   private final Handler eventHandler;
   private final ExoPlayerImplInternal internalPlayer;
   private final Handler internalPlayerHandler;
   private final CopyOnWriteArraySet<Player.EventListener> listeners;
-  private final Timeline.Window window;
   private final Timeline.Period period;
   private final ArrayDeque<PlaybackInfoUpdate> pendingPlaybackInfoUpdates;
 
+  private MediaSource mediaSource;
   private boolean playWhenReady;
+  private boolean internalPlayWhenReady;
   private @RepeatMode int repeatMode;
   private boolean shuffleModeEnabled;
   private int pendingOperationAcks;
   private boolean hasPendingPrepare;
   private boolean hasPendingSeek;
   private PlaybackParameters playbackParameters;
+  private SeekParameters seekParameters;
   private @Nullable ExoPlaybackException playbackError;
 
   // Playback information when there is no pending seek/set source operation.
@@ -80,11 +88,19 @@
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
    * @param clock The {@link Clock} that will be used by the instance.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
    */
   @SuppressLint("HandlerLeak")
   public ExoPlayerImpl(
-      Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl, Clock clock) {
+      Renderer[] renderers,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      BandwidthMeter bandwidthMeter,
+      Clock clock,
+      Looper looper) {
     Log.i(TAG, "Init " + Integer.toHexString(System.identityHashCode(this)) + " ["
         + ExoPlayerLibraryInfo.VERSION_SLASHY + "] [" + Util.DEVICE_DEBUG_INFO + "]");
     Assertions.checkState(renderers.length > 0);
@@ -99,22 +115,17 @@ public ExoPlayerImpl(
             new RendererConfiguration[renderers.length],
             new TrackSelection[renderers.length],
             null);
-    window = new Timeline.Window();
     period = new Timeline.Period();
     playbackParameters = PlaybackParameters.DEFAULT;
-    Looper eventLooper = Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper();
-    eventHandler = new Handler(eventLooper) {
-      @Override
-      public void handleMessage(Message msg) {
-        ExoPlayerImpl.this.handleEvent(msg);
-      }
-    };
-    playbackInfo =
-        new PlaybackInfo(
-            Timeline.EMPTY,
-            /* startPositionUs= */ 0,
-            TrackGroupArray.EMPTY,
-            emptyTrackSelectorResult);
+    seekParameters = SeekParameters.DEFAULT;
+    eventHandler =
+        new Handler(looper) {
+          @Override
+          public void handleMessage(Message msg) {
+            ExoPlayerImpl.this.handleEvent(msg);
+          }
+        };
+    playbackInfo = PlaybackInfo.createDummy(/* startPositionUs= */ 0, emptyTrackSelectorResult);
     pendingPlaybackInfoUpdates = new ArrayDeque<>();
     internalPlayer =
         new ExoPlayerImplInternal(
@@ -122,6 +133,7 @@ public void handleMessage(Message msg) {
             trackSelector,
             emptyTrackSelectorResult,
             loadControl,
+            bandwidthMeter,
             playWhenReady,
             repeatMode,
             shuffleModeEnabled,
@@ -132,20 +144,39 @@ public void handleMessage(Message msg) {
   }
 
   @Override
+  @Nullable
+  public AudioComponent getAudioComponent() {
+    return null;
+  }
+
+  @Override
+  @Nullable
   public VideoComponent getVideoComponent() {
     return null;
   }
 
   @Override
+  @Nullable
   public TextComponent getTextComponent() {
     return null;
   }
 
+  @Override
+  @Nullable
+  public MetadataComponent getMetadataComponent() {
+    return null;
+  }
+
   @Override
   public Looper getPlaybackLooper() {
     return internalPlayer.getPlaybackLooper();
   }
 
+  @Override
+  public Looper getApplicationLooper() {
+    return eventHandler.getLooper();
+  }
+
   @Override
   public void addListener(Player.EventListener listener) {
     listeners.add(listener);
@@ -166,14 +197,23 @@ public int getPlaybackState() {
     return playbackError;
   }
 
+  @Override
+  public void retry() {
+    if (mediaSource != null
+        && (playbackError != null || playbackInfo.playbackState == Player.STATE_IDLE)) {
+      prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
+    }
+  }
+
   @Override
   public void prepare(MediaSource mediaSource) {
-    prepare(mediaSource, true, true);
+    prepare(mediaSource, /* resetPosition= */ true, /* resetState= */ true);
   }
 
   @Override
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     playbackError = null;
+    this.mediaSource = mediaSource;
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
             resetPosition, resetState, /* playbackState= */ Player.STATE_BUFFERING);
@@ -195,9 +235,17 @@ public void prepare(MediaSource mediaSource, boolean resetPosition, boolean rese
 
   @Override
   public void setPlayWhenReady(boolean playWhenReady) {
+    setPlayWhenReady(playWhenReady, /* suppressPlayback= */ false);
+  }
+
+  public void setPlayWhenReady(boolean playWhenReady, boolean suppressPlayback) {
+    boolean internalPlayWhenReady = playWhenReady && !suppressPlayback;
+    if (this.internalPlayWhenReady != internalPlayWhenReady) {
+      this.internalPlayWhenReady = internalPlayWhenReady;
+      internalPlayer.setPlayWhenReady(internalPlayWhenReady);
+    }
     if (this.playWhenReady != playWhenReady) {
       this.playWhenReady = playWhenReady;
-      internalPlayer.setPlayWhenReady(playWhenReady);
       updatePlaybackInfo(
           playbackInfo,
           /* positionDiscontinuity= */ false,
@@ -250,21 +298,6 @@ public boolean isLoading() {
     return playbackInfo.isLoading;
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    seekToDefaultPosition(getCurrentWindowIndex());
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    seekTo(windowIndex, C.TIME_UNSET);
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    seekTo(getCurrentWindowIndex(), positionMs);
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     Timeline timeline = playbackInfo.timeline;
@@ -294,10 +327,10 @@ public void seekTo(int windowIndex, long positionMs) {
     } else {
       long windowPositionUs = positionMs == C.TIME_UNSET
           ? timeline.getWindow(windowIndex, window).getDefaultPositionUs() : C.msToUs(positionMs);
-      Pair<Integer, Long> periodIndexAndPositon =
+      Pair<Object, Long> periodUidAndPosition =
           timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs);
       maskingWindowPositionMs = C.usToMs(windowPositionUs);
-      maskingPeriodIndex = periodIndexAndPositon.first;
+      maskingPeriodIndex = timeline.getIndexOfPeriod(periodUidAndPosition.first);
     }
     internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
     for (Player.EventListener listener : listeners) {
@@ -323,26 +356,22 @@ public void setSeekParameters(@Nullable SeekParameters seekParameters) {
     if (seekParameters == null) {
       seekParameters = SeekParameters.DEFAULT;
     }
-    internalPlayer.setSeekParameters(seekParameters);
-  }
-
-  @Override
-  public @Nullable Object getCurrentTag() {
-    int windowIndex = getCurrentWindowIndex();
-    return windowIndex > playbackInfo.timeline.getWindowCount()
-        ? null
-        : playbackInfo.timeline.getWindow(windowIndex, window, /* setTag= */ true).tag;
+    if (!this.seekParameters.equals(seekParameters)) {
+      this.seekParameters = seekParameters;
+      internalPlayer.setSeekParameters(seekParameters);
+    }
   }
 
   @Override
-  public void stop() {
-    stop(/* reset= */ false);
+  public SeekParameters getSeekParameters() {
+    return seekParameters;
   }
 
   @Override
   public void stop(boolean reset) {
     if (reset) {
       playbackError = null;
+      mediaSource = null;
     }
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
@@ -369,11 +398,14 @@ public void release() {
     Log.i(TAG, "Release " + Integer.toHexString(System.identityHashCode(this)) + " ["
         + ExoPlayerLibraryInfo.VERSION_SLASHY + "] [" + Util.DEVICE_DEBUG_INFO + "] ["
         + ExoPlayerLibraryInfo.registeredModules() + "]");
+    mediaSource = null;
     internalPlayer.release();
     eventHandler.removeCallbacksAndMessages(null);
   }
 
   @Override
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public void sendMessages(ExoPlayerMessage... messages) {
     for (ExoPlayerMessage message : messages) {
       createMessage(message.target).setType(message.messageType).setPayload(message.message).send();
@@ -391,6 +423,8 @@ public PlayerMessage createMessage(Target target) {
   }
 
   @Override
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public void blockingSendMessages(ExoPlayerMessage... messages) {
     List<PlayerMessage> playerMessages = new ArrayList<>();
     for (ExoPlayerMessage message : messages) {
@@ -423,7 +457,7 @@ public int getCurrentPeriodIndex() {
     if (shouldMaskPosition()) {
       return maskingPeriodIndex;
     } else {
-      return playbackInfo.periodId.periodIndex;
+      return playbackInfo.timeline.getIndexOfPeriod(playbackInfo.periodId.periodUid);
     }
   }
 
@@ -432,77 +466,46 @@ public int getCurrentWindowIndex() {
     if (shouldMaskPosition()) {
       return maskingWindowIndex;
     } else {
-      return playbackInfo.timeline.getPeriod(playbackInfo.periodId.periodIndex, period).windowIndex;
+      return playbackInfo.timeline.getPeriodByUid(playbackInfo.periodId.periodUid, period)
+          .windowIndex;
     }
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    Timeline timeline = playbackInfo.timeline;
-    return timeline.isEmpty() ? C.INDEX_UNSET
-        : timeline.getNextWindowIndex(getCurrentWindowIndex(), repeatMode, shuffleModeEnabled);
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    Timeline timeline = playbackInfo.timeline;
-    return timeline.isEmpty() ? C.INDEX_UNSET
-        : timeline.getPreviousWindowIndex(getCurrentWindowIndex(), repeatMode, shuffleModeEnabled);
-  }
-
   @Override
   public long getDuration() {
-    Timeline timeline = playbackInfo.timeline;
-    if (timeline.isEmpty()) {
-      return C.TIME_UNSET;
-    }
     if (isPlayingAd()) {
       MediaPeriodId periodId = playbackInfo.periodId;
-      timeline.getPeriod(periodId.periodIndex, period);
+      playbackInfo.timeline.getPeriodByUid(periodId.periodUid, period);
       long adDurationUs = period.getAdDurationUs(periodId.adGroupIndex, periodId.adIndexInAdGroup);
       return C.usToMs(adDurationUs);
-    } else {
-      return timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
     }
+    return getContentDuration();
   }
 
   @Override
   public long getCurrentPosition() {
     if (shouldMaskPosition()) {
       return maskingWindowPositionMs;
+    } else if (playbackInfo.periodId.isAd()) {
+      return C.usToMs(playbackInfo.positionUs);
     } else {
-      return playbackInfoPositionUsToWindowPositionMs(playbackInfo.positionUs);
+      return periodPositionUsToWindowPositionMs(playbackInfo.periodId, playbackInfo.positionUs);
     }
   }
 
   @Override
   public long getBufferedPosition() {
-    // TODO - Implement this properly.
-    if (shouldMaskPosition()) {
-      return maskingWindowPositionMs;
-    } else {
-      return playbackInfoPositionUsToWindowPositionMs(playbackInfo.bufferedPositionUs);
+    if (isPlayingAd()) {
+      return playbackInfo.loadingMediaPeriodId.equals(playbackInfo.periodId)
+          ? C.usToMs(playbackInfo.bufferedPositionUs)
+          : getDuration();
     }
+    return getContentBufferedPosition();
   }
 
   @Override
-  public int getBufferedPercentage() {
-    long position = getBufferedPosition();
-    long duration = getDuration();
-    return position == C.TIME_UNSET || duration == C.TIME_UNSET ? 0
-        : (duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100));
-  }
-
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    Timeline timeline = playbackInfo.timeline;
-    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    Timeline timeline = playbackInfo.timeline;
-    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  public long getTotalBufferedDuration() {
+    return Math.max(0, C.usToMs(playbackInfo.totalBufferedDurationUs));
   }
 
   @Override
@@ -523,13 +526,36 @@ public int getCurrentAdIndexInAdGroup() {
   @Override
   public long getContentPosition() {
     if (isPlayingAd()) {
-      playbackInfo.timeline.getPeriod(playbackInfo.periodId.periodIndex, period);
+      playbackInfo.timeline.getPeriodByUid(playbackInfo.periodId.periodUid, period);
       return period.getPositionInWindowMs() + C.usToMs(playbackInfo.contentPositionUs);
     } else {
       return getCurrentPosition();
     }
   }
 
+  @Override
+  public long getContentBufferedPosition() {
+    if (shouldMaskPosition()) {
+      return maskingWindowPositionMs;
+    }
+    if (playbackInfo.loadingMediaPeriodId.windowSequenceNumber
+        != playbackInfo.periodId.windowSequenceNumber) {
+      return playbackInfo.timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+    }
+    long contentBufferedPositionUs = playbackInfo.bufferedPositionUs;
+    if (playbackInfo.loadingMediaPeriodId.isAd()) {
+      Timeline.Period loadingPeriod =
+          playbackInfo.timeline.getPeriodByUid(playbackInfo.loadingMediaPeriodId.periodUid, period);
+      contentBufferedPositionUs =
+          loadingPeriod.getAdGroupTimeUs(playbackInfo.loadingMediaPeriodId.adGroupIndex);
+      if (contentBufferedPositionUs == C.TIME_END_OF_SOURCE) {
+        contentBufferedPositionUs = loadingPeriod.durationUs;
+      }
+    }
+    return periodPositionUsToWindowPositionMs(
+        playbackInfo.loadingMediaPeriodId, contentBufferedPositionUs);
+  }
+
   @Override
   public int getRendererCount() {
     return renderers.length;
@@ -601,7 +627,7 @@ private void handlePlaybackInfo(
       if (playbackInfo.startPositionUs == C.TIME_UNSET) {
         // Replace internal unset start position with externally visible start position of zero.
         playbackInfo =
-            playbackInfo.fromNewPosition(
+            playbackInfo.resetToNewPosition(
                 playbackInfo.periodId, /* startPositionUs= */ 0, playbackInfo.contentPositionUs);
       }
       if ((!this.playbackInfo.timeline.isEmpty() || hasPendingPrepare)
@@ -640,16 +666,26 @@ private PlaybackInfo getResetPlaybackInfo(
       maskingPeriodIndex = getCurrentPeriodIndex();
       maskingWindowPositionMs = getCurrentPosition();
     }
+    MediaPeriodId mediaPeriodId =
+        resetPosition
+            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
+            : playbackInfo.periodId;
+    long startPositionUs = resetPosition ? 0 : playbackInfo.positionUs;
+    long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     return new PlaybackInfo(
         resetState ? Timeline.EMPTY : playbackInfo.timeline,
         resetState ? null : playbackInfo.manifest,
-        playbackInfo.periodId,
-        playbackInfo.startPositionUs,
-        playbackInfo.contentPositionUs,
+        mediaPeriodId,
+        startPositionUs,
+        contentPositionUs,
         playbackState,
         /* isLoading= */ false,
         resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
-        resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult);
+        resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
+        mediaPeriodId,
+        startPositionUs,
+        /* totalBufferedDurationUs= */ 0,
+        startPositionUs);
   }
 
   private void updatePlaybackInfo(
@@ -683,12 +719,10 @@ private void updatePlaybackInfo(
     }
   }
 
-  private long playbackInfoPositionUsToWindowPositionMs(long positionUs) {
+  private long periodPositionUsToWindowPositionMs(MediaPeriodId periodId, long positionUs) {
     long positionMs = C.usToMs(positionUs);
-    if (!playbackInfo.periodId.isAd()) {
-      playbackInfo.timeline.getPeriod(playbackInfo.periodId.periodIndex, period);
-      positionMs += period.getPositionInWindowMs();
-    }
+    playbackInfo.timeline.getPeriodByUid(periodId.periodUid, period);
+    positionMs += period.getPositionInWindowMs();
     return positionMs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index a7d569081e..7f41719d1d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -23,7 +23,6 @@
 import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
@@ -35,9 +34,11 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.HandlerWrapper;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -77,6 +78,7 @@
   private static final int MSG_SET_SHUFFLE_ENABLED = 13;
   private static final int MSG_SEND_MESSAGE = 14;
   private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 15;
+  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 16;
 
   private static final int PREPARING_SOURCE_INTERVAL_MS = 10;
   private static final int RENDERING_INTERVAL_MS = 10;
@@ -87,6 +89,7 @@
   private final TrackSelector trackSelector;
   private final TrackSelectorResult emptyTrackSelectorResult;
   private final LoadControl loadControl;
+  private final BandwidthMeter bandwidthMeter;
   private final HandlerWrapper handler;
   private final HandlerThread internalPlaybackThread;
   private final Handler eventHandler;
@@ -123,6 +126,7 @@ public ExoPlayerImplInternal(
       TrackSelector trackSelector,
       TrackSelectorResult emptyTrackSelectorResult,
       LoadControl loadControl,
+      BandwidthMeter bandwidthMeter,
       boolean playWhenReady,
       @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled,
@@ -133,6 +137,7 @@ public ExoPlayerImplInternal(
     this.trackSelector = trackSelector;
     this.emptyTrackSelectorResult = emptyTrackSelectorResult;
     this.loadControl = loadControl;
+    this.bandwidthMeter = bandwidthMeter;
     this.playWhenReady = playWhenReady;
     this.repeatMode = repeatMode;
     this.shuffleModeEnabled = shuffleModeEnabled;
@@ -146,11 +151,7 @@ public ExoPlayerImplInternal(
 
     seekParameters = SeekParameters.DEFAULT;
     playbackInfo =
-        new PlaybackInfo(
-            Timeline.EMPTY,
-            /* startPositionUs= */ C.TIME_UNSET,
-            TrackGroupArray.EMPTY,
-            emptyTrackSelectorResult);
+        PlaybackInfo.createDummy(/* startPositionUs= */ C.TIME_UNSET, emptyTrackSelectorResult);
     playbackInfoUpdate = new PlaybackInfoUpdate();
     rendererCapabilities = new RendererCapabilities[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
@@ -162,7 +163,7 @@ public ExoPlayerImplInternal(
     enabledRenderers = new Renderer[0];
     window = new Timeline.Window();
     period = new Timeline.Period();
-    trackSelector.init(this);
+    trackSelector.init(/* listener= */ this, bandwidthMeter);
 
     // Note: The documentation for Process.THREAD_PRIORITY_AUDIO that states "Applications can
     // not normally change to this priority" is incorrect.
@@ -271,8 +272,9 @@ public void onTrackSelectionsInvalidated() {
 
   @Override
   public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-    eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters).sendToTarget();
-    updateTrackSelectionPlaybackSpeed(playbackParameters.speed);
+    handler
+        .obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL, playbackParameters)
+        .sendToTarget();
   }
 
   // Handler.Callback implementation.
@@ -324,6 +326,9 @@ public boolean handleMessage(Message msg) {
         case MSG_TRACK_SELECTION_INVALIDATED:
           reselectTracksInternal();
           break;
+        case MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL:
+          handlePlaybackParameters((PlaybackParameters) msg.obj);
+          break;
         case MSG_SEND_MESSAGE:
           sendMessageInternal((PlayerMessage) msg.obj);
           break;
@@ -393,7 +398,11 @@ private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boo
     loadControl.onPrepared();
     this.mediaSource = mediaSource;
     setState(Player.STATE_BUFFERING);
-    mediaSource.prepareSource(player, /* isTopLevelSource= */ true, /* listener= */ this);
+    mediaSource.prepareSource(
+        player,
+        /* isTopLevelSource= */ true,
+        /* listener= */ this,
+        bandwidthMeter.getTransferListener());
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
@@ -419,6 +428,7 @@ private void setRepeatModeInternal(@Player.RepeatMode int repeatMode)
     if (!queue.updateRepeatMode(repeatMode)) {
       seekToCurrentPosition(/* sendDiscontinuity= */ true);
     }
+    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
   }
 
   private void setShuffleModeEnabledInternal(boolean shuffleModeEnabled)
@@ -427,6 +437,7 @@ private void setShuffleModeEnabledInternal(boolean shuffleModeEnabled)
     if (!queue.updateShuffleModeEnabled(shuffleModeEnabled)) {
       seekToCurrentPosition(/* sendDiscontinuity= */ true);
     }
+    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
   }
 
   private void seekToCurrentPosition(boolean sendDiscontinuity) throws ExoPlaybackException {
@@ -437,7 +448,11 @@ private void seekToCurrentPosition(boolean sendDiscontinuity) throws ExoPlayback
         seekToPeriodPosition(periodId, playbackInfo.positionUs, /* forceDisableRenderers= */ true);
     if (newPositionUs != playbackInfo.positionUs) {
       playbackInfo =
-          playbackInfo.fromNewPosition(periodId, newPositionUs, playbackInfo.contentPositionUs);
+          playbackInfo.copyWithNewPosition(
+              periodId,
+              newPositionUs,
+              playbackInfo.contentPositionUs,
+              getTotalBufferedDurationUs());
       if (sendDiscontinuity) {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
@@ -472,8 +487,12 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
       // A MediaPeriod may report a discontinuity at the current playback position to ensure the
       // renderers are flushed. Only report the discontinuity externally if the position changed.
       if (periodPositionUs != playbackInfo.positionUs) {
-        playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
-            playbackInfo.contentPositionUs);
+        playbackInfo =
+            playbackInfo.copyWithNewPosition(
+                playbackInfo.periodId,
+                periodPositionUs,
+                playbackInfo.contentPositionUs,
+                getTotalBufferedDurationUs());
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
     } else {
@@ -483,11 +502,10 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
       playbackInfo.positionUs = periodPositionUs;
     }
 
-    // Update the buffered position.
-    playbackInfo.bufferedPositionUs =
-        enabledRenderers.length == 0
-            ? playingPeriodHolder.info.durationUs
-            : playingPeriodHolder.getBufferedPositionUs(/* convertEosToDuration= */ true);
+    // Update the buffered position and total buffered duration.
+    MediaPeriodHolder loadingPeriod = queue.getLoadingPeriod();
+    playbackInfo.bufferedPositionUs = loadingPeriod.getBufferedPositionUs();
+    playbackInfo.totalBufferedDurationUs = getTotalBufferedDurationUs();
   }
 
   private void doSomeWork() throws ExoPlaybackException, IOException {
@@ -582,20 +600,20 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     long periodPositionUs;
     long contentPositionUs;
     boolean seekPositionAdjusted;
-    Pair<Integer, Long> resolvedSeekPosition =
+    Pair<Object, Long> resolvedSeekPosition =
         resolveSeekPosition(seekPosition, /* trySubsequentPeriods= */ true);
     if (resolvedSeekPosition == null) {
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed or is not ready and a suitable seek position could not be resolved.
-      periodId = new MediaPeriodId(getFirstPeriodIndex());
+      periodId = playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window);
       periodPositionUs = C.TIME_UNSET;
       contentPositionUs = C.TIME_UNSET;
       seekPositionAdjusted = true;
     } else {
       // Update the resolved seek position to take ads into account.
-      int periodIndex = resolvedSeekPosition.first;
+      Object periodUid = resolvedSeekPosition.first;
       contentPositionUs = resolvedSeekPosition.second;
-      periodId = queue.resolveMediaPeriodIdForAds(periodIndex, contentPositionUs);
+      periodId = queue.resolveMediaPeriodIdForAds(periodUid, contentPositionUs);
       if (periodId.isAd()) {
         periodPositionUs = 0;
         seekPositionAdjusted = true;
@@ -635,7 +653,9 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
         periodPositionUs = newPeriodPositionUs;
       }
     } finally {
-      playbackInfo = playbackInfo.fromNewPosition(periodId, periodPositionUs, contentPositionUs);
+      playbackInfo =
+          playbackInfo.copyWithNewPosition(
+              periodId, periodPositionUs, contentPositionUs, getTotalBufferedDurationUs());
       if (seekPositionAdjusted) {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
       }
@@ -660,7 +680,7 @@ private long seekToPeriodPosition(
     MediaPeriodHolder oldPlayingPeriodHolder = queue.getPlayingPeriod();
     MediaPeriodHolder newPlayingPeriodHolder = oldPlayingPeriodHolder;
     while (newPlayingPeriodHolder != null) {
-      if (shouldKeepPeriodHolder(periodId, periodPositionUs, newPlayingPeriodHolder)) {
+      if (periodId.equals(newPlayingPeriodHolder.info.id) && newPlayingPeriodHolder.prepared) {
         queue.removeAfter(newPlayingPeriodHolder);
         break;
       }
@@ -688,26 +708,17 @@ private long seekToPeriodPosition(
       maybeContinueLoading();
     } else {
       queue.clear(/* keepFrontPeriodUid= */ true);
+      // New period has not been prepared.
+      playbackInfo =
+          playbackInfo.copyWithTrackInfo(TrackGroupArray.EMPTY, emptyTrackSelectorResult);
       resetRendererPosition(periodPositionUs);
     }
 
+    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
     return periodPositionUs;
   }
 
-  private boolean shouldKeepPeriodHolder(
-      MediaPeriodId seekPeriodId, long positionUs, MediaPeriodHolder holder) {
-    if (seekPeriodId.equals(holder.info.id) && holder.prepared) {
-      playbackInfo.timeline.getPeriod(holder.info.id.periodIndex, period);
-      int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(positionUs);
-      if (nextAdGroupIndex == C.INDEX_UNSET
-          || period.getAdGroupTimeUs(nextAdGroupIndex) == holder.info.endPositionUs) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackException {
     rendererPositionUs =
         !queue.hasPlayingPeriod()
@@ -749,14 +760,6 @@ private void releaseInternal() {
     }
   }
 
-  private int getFirstPeriodIndex() {
-    Timeline timeline = playbackInfo.timeline;
-    return timeline.isEmpty()
-        ? 0
-        : timeline.getWindow(timeline.getFirstWindowIndex(shuffleModeEnabled), window)
-            .firstPeriodIndex;
-  }
-
   private void resetInternal(
       boolean releaseMediaSource, boolean resetPosition, boolean resetState) {
     handler.removeMessages(MSG_DO_SOME_WORK);
@@ -785,18 +788,28 @@ private void resetInternal(
       pendingMessages.clear();
       nextPendingMessageIndex = 0;
     }
+    MediaPeriodId mediaPeriodId =
+        resetPosition
+            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
+            : playbackInfo.periodId;
+    // Set the start position to TIME_UNSET so that a subsequent seek to 0 isn't ignored.
+    long startPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.positionUs;
+    long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     playbackInfo =
         new PlaybackInfo(
             resetState ? Timeline.EMPTY : playbackInfo.timeline,
             resetState ? null : playbackInfo.manifest,
-            resetPosition ? new MediaPeriodId(getFirstPeriodIndex()) : playbackInfo.periodId,
-            // Set the start position to TIME_UNSET so that a subsequent seek to 0 isn't ignored.
-            resetPosition ? C.TIME_UNSET : playbackInfo.positionUs,
-            resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs,
+            mediaPeriodId,
+            startPositionUs,
+            contentPositionUs,
             playbackInfo.playbackState,
             /* isLoading= */ false,
             resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
-            resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult);
+            resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
+            mediaPeriodId,
+            startPositionUs,
+            /* totalBufferedDurationUs= */ 0,
+            startPositionUs);
     if (releaseMediaSource) {
       if (mediaSource != null) {
         mediaSource.releaseSource(/* listener= */ this);
@@ -840,15 +853,12 @@ private void sendMessageToTarget(PlayerMessage message) throws ExoPlaybackExcept
   private void sendMessageToTargetThread(final PlayerMessage message) {
     Handler handler = message.getHandler();
     handler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            try {
-              deliverMessage(message);
-            } catch (ExoPlaybackException e) {
-              Log.e(TAG, "Unexpected error delivering message on external thread.", e);
-              throw new RuntimeException(e);
-            }
+        () -> {
+          try {
+            deliverMessage(message);
+          } catch (ExoPlaybackException e) {
+            Log.e(TAG, "Unexpected error delivering message on external thread.", e);
+            throw new RuntimeException(e);
           }
         });
   }
@@ -879,7 +889,7 @@ private void resolvePendingMessagePositions() {
   private boolean resolvePendingMessagePosition(PendingMessageInfo pendingMessageInfo) {
     if (pendingMessageInfo.resolvedPeriodUid == null) {
       // Position is still unresolved. Try to find window in current timeline.
-      Pair<Integer, Long> periodPosition =
+      Pair<Object, Long> periodPosition =
           resolveSeekPosition(
               new SeekPosition(
                   pendingMessageInfo.message.getTimeline(),
@@ -890,9 +900,9 @@ private boolean resolvePendingMessagePosition(PendingMessageInfo pendingMessageI
         return false;
       }
       pendingMessageInfo.setResolvedPosition(
-          periodPosition.first,
+          playbackInfo.timeline.getIndexOfPeriod(periodPosition.first),
           periodPosition.second,
-          playbackInfo.timeline.getPeriod(periodPosition.first, period, true).uid);
+          periodPosition.first);
     } else {
       // Position has been resolved for a previous timeline. Try to find the updated period index.
       int index = playbackInfo.timeline.getIndexOfPeriod(pendingMessageInfo.resolvedPeriodUid);
@@ -915,7 +925,8 @@ private void maybeTriggerPendingMessages(long oldPeriodPositionUs, long newPerio
       oldPeriodPositionUs--;
     }
     // Correct next index if necessary (e.g. after seeking, timeline changes, or new messages)
-    int currentPeriodIndex = playbackInfo.periodId.periodIndex;
+    int currentPeriodIndex =
+        playbackInfo.timeline.getIndexOfPeriod(playbackInfo.periodId.periodUid);
     PendingMessageInfo previousInfo =
         nextPendingMessageIndex > 0 ? pendingMessages.get(nextPendingMessageIndex - 1) : null;
     while (previousInfo != null
@@ -1007,12 +1018,14 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       long periodPositionUs =
           playingPeriodHolder.applyTrackSelection(
               playbackInfo.positionUs, recreateStreams, streamResetFlags);
-      updateLoadControlTrackSelection(
-          playingPeriodHolder.trackGroups, playingPeriodHolder.trackSelectorResult);
       if (playbackInfo.playbackState != Player.STATE_ENDED
           && periodPositionUs != playbackInfo.positionUs) {
-        playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
-            playbackInfo.contentPositionUs);
+        playbackInfo =
+            playbackInfo.copyWithNewPosition(
+                playbackInfo.periodId,
+                periodPositionUs,
+                playbackInfo.contentPositionUs,
+                getTotalBufferedDurationUs());
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
         resetRendererPosition(periodPositionUs);
       }
@@ -1048,9 +1061,9 @@ private void reselectTracksInternal() throws ExoPlaybackException {
             Math.max(
                 periodHolder.info.startPositionUs, periodHolder.toPeriodTime(rendererPositionUs));
         periodHolder.applyTrackSelection(loadingPeriodPositionUs, false);
-        updateLoadControlTrackSelection(periodHolder.trackGroups, periodHolder.trackSelectorResult);
       }
     }
+    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ true);
     if (playbackInfo.playbackState != Player.STATE_ENDED) {
       maybeContinueLoading();
       updatePlaybackPositions();
@@ -1058,11 +1071,6 @@ private void reselectTracksInternal() throws ExoPlaybackException {
     }
   }
 
-  private void updateLoadControlTrackSelection(
-      TrackGroupArray trackGroups, TrackSelectorResult trackSelectorResult) {
-    loadControl.onTracksSelected(renderers, trackGroups, trackSelectorResult.selections);
-  }
-
   private void updateTrackSelectionPlaybackSpeed(float playbackSpeed) {
     MediaPeriodHolder periodHolder = queue.getFrontPeriod();
     while (periodHolder != null) {
@@ -1093,12 +1101,10 @@ private boolean shouldTransitionToReadyState(boolean renderersReadyOrEnded) {
     }
     // Renderers are ready and we're loading. Ask the LoadControl whether to transition.
     MediaPeriodHolder loadingHolder = queue.getLoadingPeriod();
-    long bufferedPositionUs = loadingHolder.getBufferedPositionUs(!loadingHolder.info.isFinal);
-    return bufferedPositionUs == C.TIME_END_OF_SOURCE
+    boolean bufferedToEnd = loadingHolder.isFullyBuffered() && loadingHolder.info.isFinal;
+    return bufferedToEnd
         || loadControl.shouldStartPlayback(
-            bufferedPositionUs - loadingHolder.toPeriodTime(rendererPositionUs),
-            mediaClock.getPlaybackParameters().speed,
-            rebuffering);
+            getTotalBufferedDurationUs(), mediaClock.getPlaybackParameters().speed, rebuffering);
   }
 
   private boolean isTimelineReady() {
@@ -1110,6 +1116,19 @@ private boolean isTimelineReady() {
             && (playingPeriodHolder.next.prepared || playingPeriodHolder.next.info.id.isAd()));
   }
 
+  private void maybeThrowSourceInfoRefreshError() throws IOException {
+    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    if (loadingPeriodHolder != null) {
+      // Defer throwing until we read all available media periods.
+      for (Renderer renderer : enabledRenderers) {
+        if (!renderer.hasReadStreamToEnd()) {
+          return;
+        }
+      }
+    }
+    mediaSource.maybeThrowSourceInfoRefreshError();
+  }
+
   private void maybeThrowPeriodPrepareError() throws IOException {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
@@ -1142,32 +1161,45 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       playbackInfoUpdate.incrementPendingOperationAcks(pendingPrepareCount);
       pendingPrepareCount = 0;
       if (pendingInitialSeekPosition != null) {
-        Pair<Integer, Long> periodPosition =
-            resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
+        Pair<Object, Long> periodPosition;
+        try {
+          periodPosition =
+              resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
+        } catch (IllegalSeekPositionException e) {
+          MediaPeriodId firstMediaPeriodId =
+              playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window);
+          playbackInfo =
+              playbackInfo.resetToNewPosition(
+                  firstMediaPeriodId,
+                  /* startPositionUs= */ C.TIME_UNSET,
+                  /* contentPositionUs= */ C.TIME_UNSET);
+          throw e;
+        }
         pendingInitialSeekPosition = null;
         if (periodPosition == null) {
           // The seek position was valid for the timeline that it was performed into, but the
           // timeline has changed and a suitable seek position could not be resolved in the new one.
           handleSourceInfoRefreshEndedPlayback();
         } else {
-          int periodIndex = periodPosition.first;
+          Object periodUid = periodPosition.first;
           long positionUs = periodPosition.second;
-          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodIndex, positionUs);
+          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, positionUs);
           playbackInfo =
-              playbackInfo.fromNewPosition(
+              playbackInfo.resetToNewPosition(
                   periodId, periodId.isAd() ? 0 : positionUs, /* contentPositionUs= */ positionUs);
         }
       } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {
         if (timeline.isEmpty()) {
           handleSourceInfoRefreshEndedPlayback();
         } else {
-          Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline,
-              timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
-          int periodIndex = defaultPosition.first;
+          Pair<Object, Long> defaultPosition =
+              getPeriodPosition(
+                  timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
+          Object periodUid = defaultPosition.first;
           long startPositionUs = defaultPosition.second;
-          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodIndex, startPositionUs);
+          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, startPositionUs);
           playbackInfo =
-              playbackInfo.fromNewPosition(
+              playbackInfo.resetToNewPosition(
                   periodId,
                   periodId.isAd() ? 0 : startPositionUs,
                   /* contentPositionUs= */ startPositionUs);
@@ -1176,72 +1208,72 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       return;
     }
 
-    int playingPeriodIndex = playbackInfo.periodId.periodIndex;
-    long contentPositionUs = playbackInfo.contentPositionUs;
     if (oldTimeline.isEmpty()) {
       // If the old timeline is empty, the period queue is also empty.
       if (!timeline.isEmpty()) {
-        MediaPeriodId periodId =
-            queue.resolveMediaPeriodIdForAds(playingPeriodIndex, contentPositionUs);
+        Pair<Object, Long> defaultPosition =
+            getPeriodPosition(
+                timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
+        Object periodUid = defaultPosition.first;
+        long startPositionUs = defaultPosition.second;
+        MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, startPositionUs);
         playbackInfo =
-            playbackInfo.fromNewPosition(
-                periodId, periodId.isAd() ? 0 : contentPositionUs, contentPositionUs);
+            playbackInfo.resetToNewPosition(
+                periodId,
+                /* startPositionUs= */ periodId.isAd() ? 0 : startPositionUs,
+                /* contentPositionUs= */ startPositionUs);
       }
       return;
     }
     MediaPeriodHolder periodHolder = queue.getFrontPeriod();
-    Object playingPeriodUid = periodHolder == null
-        ? oldTimeline.getPeriod(playingPeriodIndex, period, true).uid : periodHolder.uid;
+    long contentPositionUs = playbackInfo.contentPositionUs;
+    Object playingPeriodUid =
+        periodHolder == null ? playbackInfo.periodId.periodUid : periodHolder.uid;
     int periodIndex = timeline.getIndexOfPeriod(playingPeriodUid);
     if (periodIndex == C.INDEX_UNSET) {
       // We didn't find the current period in the new timeline. Attempt to resolve a subsequent
       // period whose window we can restart from.
-      int newPeriodIndex = resolveSubsequentPeriod(playingPeriodIndex, oldTimeline, timeline);
-      if (newPeriodIndex == C.INDEX_UNSET) {
+      Object newPeriodUid = resolveSubsequentPeriod(playingPeriodUid, oldTimeline, timeline);
+      if (newPeriodUid == null) {
         // We failed to resolve a suitable restart position.
         handleSourceInfoRefreshEndedPlayback();
         return;
       }
       // We resolved a subsequent period. Seek to the default position in the corresponding window.
-      Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline,
-          timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);
-      newPeriodIndex = defaultPosition.first;
+      Pair<Object, Long> defaultPosition =
+          getPeriodPosition(
+              timeline, timeline.getPeriodByUid(newPeriodUid, period).windowIndex, C.TIME_UNSET);
+      newPeriodUid = defaultPosition.first;
       contentPositionUs = defaultPosition.second;
-      MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(newPeriodIndex, contentPositionUs);
-      timeline.getPeriod(newPeriodIndex, period, true);
+      MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(newPeriodUid, contentPositionUs);
       if (periodHolder != null) {
-        // Clear the index of each holder that doesn't contain the default position. If a holder
-        // contains the default position then update its index so it can be re-used when seeking.
-        Object newPeriodUid = period.uid;
-        periodHolder.info = periodHolder.info.copyWithPeriodIndex(C.INDEX_UNSET);
+        // Update the new playing media period info if it already exists.
         while (periodHolder.next != null) {
           periodHolder = periodHolder.next;
-          if (periodHolder.uid.equals(newPeriodUid)) {
-            periodHolder.info = queue.getUpdatedMediaPeriodInfo(periodHolder.info, newPeriodIndex);
-          } else {
-            periodHolder.info = periodHolder.info.copyWithPeriodIndex(C.INDEX_UNSET);
+          if (periodHolder.info.id.equals(periodId)) {
+            periodHolder.info = queue.getUpdatedMediaPeriodInfo(periodHolder.info);
           }
         }
       }
       // Actually do the seek.
       long seekPositionUs = seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
-      playbackInfo = playbackInfo.fromNewPosition(periodId, seekPositionUs, contentPositionUs);
+      playbackInfo =
+          playbackInfo.copyWithNewPosition(
+              periodId, seekPositionUs, contentPositionUs, getTotalBufferedDurationUs());
       return;
     }
 
-    // The current period is in the new timeline. Update the playback info.
-    if (periodIndex != playingPeriodIndex) {
-      playbackInfo = playbackInfo.copyWithPeriodIndex(periodIndex);
-    }
-
     MediaPeriodId playingPeriodId = playbackInfo.periodId;
     if (playingPeriodId.isAd()) {
-      MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodIndex, contentPositionUs);
+      MediaPeriodId periodId =
+          queue.resolveMediaPeriodIdForAds(playingPeriodUid, contentPositionUs);
       if (!periodId.equals(playingPeriodId)) {
         // The previously playing ad should no longer be played, so skip it.
         long seekPositionUs =
             seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
-        playbackInfo = playbackInfo.fromNewPosition(periodId, seekPositionUs, contentPositionUs);
+        playbackInfo =
+            playbackInfo.copyWithNewPosition(
+                periodId, seekPositionUs, contentPositionUs, getTotalBufferedDurationUs());
         return;
       }
     }
@@ -1249,6 +1281,7 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
     if (!queue.updateQueuedPeriods(playingPeriodId, rendererPositionUs)) {
       seekToCurrentPosition(/* sendDiscontinuity= */ false);
     }
+    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
   }
 
   private void handleSourceInfoRefreshEndedPlayback() {
@@ -1260,16 +1293,17 @@ private void handleSourceInfoRefreshEndedPlayback() {
 
   /**
    * Given a period index into an old timeline, finds the first subsequent period that also exists
-   * in a new timeline. The index of this period in the new timeline is returned.
+   * in a new timeline. The uid of this period in the new timeline is returned.
    *
-   * @param oldPeriodIndex The index of the period in the old timeline.
+   * @param oldPeriodUid The index of the period in the old timeline.
    * @param oldTimeline The old timeline.
    * @param newTimeline The new timeline.
-   * @return The index in the new timeline of the first subsequent period, or {@link C#INDEX_UNSET}
-   *     if no such period was found.
+   * @return The uid in the new timeline of the first subsequent period, or null if no such period
+   *     was found.
    */
-  private int resolveSubsequentPeriod(
-      int oldPeriodIndex, Timeline oldTimeline, Timeline newTimeline) {
+  private @Nullable Object resolveSubsequentPeriod(
+      Object oldPeriodUid, Timeline oldTimeline, Timeline newTimeline) {
+    int oldPeriodIndex = oldTimeline.getIndexOfPeriod(oldPeriodUid);
     int newPeriodIndex = C.INDEX_UNSET;
     int maxIterations = oldTimeline.getPeriodCount();
     for (int i = 0; i < maxIterations && newPeriodIndex == C.INDEX_UNSET; i++) {
@@ -1279,14 +1313,13 @@ private int resolveSubsequentPeriod(
         // We've reached the end of the old timeline.
         break;
       }
-      newPeriodIndex = newTimeline.getIndexOfPeriod(
-          oldTimeline.getPeriod(oldPeriodIndex, period, true).uid);
+      newPeriodIndex = newTimeline.getIndexOfPeriod(oldTimeline.getUidOfPeriod(oldPeriodIndex));
     }
-    return newPeriodIndex;
+    return newPeriodIndex == C.INDEX_UNSET ? null : newTimeline.getUidOfPeriod(newPeriodIndex);
   }
 
   /**
-   * Converts a {@link SeekPosition} into the corresponding (periodIndex, periodPositionUs) for the
+   * Converts a {@link SeekPosition} into the corresponding (periodUid, periodPositionUs) for the
    * internal timeline.
    *
    * @param seekPosition The position to resolve.
@@ -1296,7 +1329,7 @@ private int resolveSubsequentPeriod(
    * @throws IllegalSeekPositionException If the window index of the seek position is outside the
    *     bounds of the timeline.
    */
-  private Pair<Integer, Long> resolveSeekPosition(
+  private Pair<Object, Long> resolveSeekPosition(
       SeekPosition seekPosition, boolean trySubsequentPeriods) {
     Timeline timeline = playbackInfo.timeline;
     Timeline seekTimeline = seekPosition.timeline;
@@ -1310,7 +1343,7 @@ private int resolveSubsequentPeriod(
       seekTimeline = timeline;
     }
     // Map the SeekPosition to a position in the corresponding timeline.
-    Pair<Integer, Long> periodPosition;
+    Pair<Object, Long> periodPosition;
     try {
       periodPosition = seekTimeline.getPeriodPosition(window, period, seekPosition.windowIndex,
           seekPosition.windowPositionUs);
@@ -1324,16 +1357,15 @@ private int resolveSubsequentPeriod(
       return periodPosition;
     }
     // Attempt to find the mapped period in the internal timeline.
-    int periodIndex = timeline.getIndexOfPeriod(
-        seekTimeline.getPeriod(periodPosition.first, period, true).uid);
+    int periodIndex = timeline.getIndexOfPeriod(periodPosition.first);
     if (periodIndex != C.INDEX_UNSET) {
       // We successfully located the period in the internal timeline.
-      return Pair.create(periodIndex, periodPosition.second);
+      return periodPosition;
     }
     if (trySubsequentPeriods) {
       // Try and find a subsequent period from the seek timeline in the internal timeline.
-      periodIndex = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
-      if (periodIndex != C.INDEX_UNSET) {
+      Object periodUid = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
+      if (periodUid != null) {
         // We found one. Map the SeekPosition onto the corresponding default position.
         return getPeriodPosition(
             timeline, timeline.getPeriod(periodIndex, period).windowIndex, C.TIME_UNSET);
@@ -1347,7 +1379,7 @@ private int resolveSubsequentPeriod(
    * Calls {@link Timeline#getPeriodPosition(Timeline.Window, Timeline.Period, int, long)} using the
    * current timeline.
    */
-  private Pair<Integer, Long> getPeriodPosition(
+  private Pair<Object, Long> getPeriodPosition(
       Timeline timeline, int windowIndex, long windowPositionUs) {
     return timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs);
   }
@@ -1381,8 +1413,9 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     boolean advancedPlayingPeriod = false;
-    while (playWhenReady && playingPeriodHolder != readingPeriodHolder
-        && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
+    while (playWhenReady
+        && playingPeriodHolder != readingPeriodHolder
+        && rendererPositionUs >= playingPeriodHolder.next.getStartPositionRendererTime()) {
       // All enabled renderers' streams have been read to the end, and the playback position reached
       // the end of the playing period, so advance playback to the next period.
       if (advancedPlayingPeriod) {
@@ -1396,8 +1429,12 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       MediaPeriodHolder oldPlayingPeriodHolder = playingPeriodHolder;
       playingPeriodHolder = queue.advancePlayingPeriod();
       updatePlayingPeriodRenderers(oldPlayingPeriodHolder);
-      playbackInfo = playbackInfo.fromNewPosition(playingPeriodHolder.info.id,
-          playingPeriodHolder.info.startPositionUs, playingPeriodHolder.info.contentPositionUs);
+      playbackInfo =
+          playbackInfo.copyWithNewPosition(
+              playingPeriodHolder.info.id,
+              playingPeriodHolder.info.startPositionUs,
+              playingPeriodHolder.info.contentPositionUs,
+              getTotalBufferedDurationUs());
       playbackInfoUpdate.setPositionDiscontinuity(discontinuityReason);
       updatePlaybackPositions();
       advancedPlayingPeriod = true;
@@ -1418,7 +1455,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
 
     // Advance the reading period if necessary.
-    if (readingPeriodHolder.next == null || !readingPeriodHolder.next.prepared) {
+    if (readingPeriodHolder.next == null) {
       // We don't have a successor to advance the reading period to.
       return;
     }
@@ -1433,6 +1470,12 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       }
     }
 
+    if (!readingPeriodHolder.next.prepared) {
+      // The successor is not prepared yet.
+      maybeThrowPeriodPrepareError();
+      return;
+    }
+
     TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
     readingPeriodHolder = queue.advanceReadingPeriod();
     TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
@@ -1481,19 +1524,18 @@ private void maybeUpdateLoadingPeriod() throws IOException {
     if (queue.shouldLoadNextMediaPeriod()) {
       MediaPeriodInfo info = queue.getNextMediaPeriodInfo(rendererPositionUs, playbackInfo);
       if (info == null) {
-        mediaSource.maybeThrowSourceInfoRefreshError();
+        maybeThrowSourceInfoRefreshError();
       } else {
-        Object uid = playbackInfo.timeline.getPeriod(info.id.periodIndex, period, true).uid;
         MediaPeriod mediaPeriod =
             queue.enqueueNextMediaPeriod(
                 rendererCapabilities,
                 trackSelector,
                 loadControl.getAllocator(),
                 mediaSource,
-                uid,
                 info);
         mediaPeriod.prepare(this, info.startPositionUs);
         setIsLoading(true);
+        handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
       }
     }
   }
@@ -1525,6 +1567,17 @@ private void handleContinueLoadingRequested(MediaPeriod mediaPeriod) {
     maybeContinueLoading();
   }
 
+  private void handlePlaybackParameters(PlaybackParameters playbackParameters)
+      throws ExoPlaybackException {
+    eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters).sendToTarget();
+    updateTrackSelectionPlaybackSpeed(playbackParameters.speed);
+    for (Renderer renderer : renderers) {
+      if (renderer != null) {
+        renderer.setOperatingRate(playbackParameters.speed);
+      }
+    }
+  }
+
   private void maybeContinueLoading() {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
     long nextLoadPositionUs = loadingPeriodHolder.getNextLoadPositionUs();
@@ -1533,7 +1586,7 @@ private void maybeContinueLoading() {
       return;
     }
     long bufferedDurationUs =
-        nextLoadPositionUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+        getTotalBufferedDurationUs(/* bufferedPositionInLoadingPeriodUs= */ nextLoadPositionUs);
     boolean continueLoading =
         loadControl.shouldContinueLoading(
             bufferedDurationUs, mediaClock.getPlaybackParameters().speed);
@@ -1620,7 +1673,44 @@ private boolean rendererWaitingForNextStream(Renderer renderer) {
         && renderer.hasReadStreamToEnd();
   }
 
-  @NonNull
+  private void handleLoadingMediaPeriodChanged(boolean loadingTrackSelectionChanged) {
+    MediaPeriodHolder loadingMediaPeriodHolder = queue.getLoadingPeriod();
+    MediaPeriodId loadingMediaPeriodId =
+        loadingMediaPeriodHolder == null ? playbackInfo.periodId : loadingMediaPeriodHolder.info.id;
+    boolean loadingMediaPeriodChanged =
+        !playbackInfo.loadingMediaPeriodId.equals(loadingMediaPeriodId);
+    if (loadingMediaPeriodChanged) {
+      playbackInfo = playbackInfo.copyWithLoadingMediaPeriodId(loadingMediaPeriodId);
+    }
+    playbackInfo.bufferedPositionUs =
+        loadingMediaPeriodHolder == null
+            ? playbackInfo.positionUs
+            : loadingMediaPeriodHolder.getBufferedPositionUs();
+    playbackInfo.totalBufferedDurationUs = getTotalBufferedDurationUs();
+    if ((loadingMediaPeriodChanged || loadingTrackSelectionChanged)
+        && loadingMediaPeriodHolder != null
+        && loadingMediaPeriodHolder.prepared) {
+      updateLoadControlTrackSelection(
+          loadingMediaPeriodHolder.trackGroups, loadingMediaPeriodHolder.trackSelectorResult);
+    }
+  }
+
+  private long getTotalBufferedDurationUs() {
+    return getTotalBufferedDurationUs(playbackInfo.bufferedPositionUs);
+  }
+
+  private long getTotalBufferedDurationUs(long bufferedPositionInLoadingPeriodUs) {
+    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    return loadingPeriodHolder == null
+        ? 0
+        : bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+  }
+
+  private void updateLoadControlTrackSelection(
+      TrackGroupArray trackGroups, TrackSelectorResult trackSelectorResult) {
+    loadControl.onTracksSelected(renderers, trackGroups, trackSelectorResult.selections);
+  }
+
   private static Format[] getFormats(TrackSelection newSelection) {
     // Build an array of formats contained by the selection.
     int length = newSelection != null ? newSelection.length() : 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 172eb19da3..792f6cf651 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.8.2";
+  public static final String VERSION = "2.9.3";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.8.2";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.3";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2008002;
+  public static final int VERSION_INT = 2009003;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
@@ -51,6 +51,9 @@
    */
   public static final boolean ASSERTIONS_ENABLED = true;
 
+  /** Whether an exception should be thrown in case of an OpenGl error. */
+  public static final boolean GL_ASSERTIONS_ENABLED = false;
+
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.TraceUtil}
    * trace enabled.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 61d416da09..3456fc39a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -46,6 +46,9 @@
 
   /** An identifier for the format, or null if unknown or not applicable. */
   public final @Nullable String id;
+  /** The human readable label, or null if unknown or not applicable. */
+  public final @Nullable String label;
+
   /**
    * The average bandwidth in bits per second, or {@link #NO_VALUE} if unknown or not applicable.
    */
@@ -80,6 +83,13 @@
   /** DRM initialization data if the stream is protected, or null otherwise. */
   public final @Nullable DrmInitData drmInitData;
 
+  /**
+   * For samples that contain subsamples, this is an offset that should be added to subsample
+   * timestamps. A value of {@link #OFFSET_SAMPLE_RELATIVE} indicates that subsample timestamps are
+   * relative to the timestamps of their parent samples.
+   */
+  public final long subsampleOffsetUs;
+
   // Video specific.
 
   /**
@@ -125,12 +135,12 @@
   public final int sampleRate;
   /**
    * The encoding for PCM audio streams. If {@link #sampleMimeType} is {@link MimeTypes#AUDIO_RAW}
-   * then one of {@link C#ENCODING_PCM_8BIT}, {@link C#ENCODING_PCM_16BIT},
-   * {@link C#ENCODING_PCM_24BIT} and {@link C#ENCODING_PCM_32BIT}. Set to {@link #NO_VALUE} for
-   * other media types.
+   * then one of {@link C#ENCODING_PCM_8BIT}, {@link C#ENCODING_PCM_16BIT}, {@link
+   * C#ENCODING_PCM_24BIT}, {@link C#ENCODING_PCM_32BIT}, {@link C#ENCODING_PCM_FLOAT}, {@link
+   * C#ENCODING_PCM_MU_LAW} or {@link C#ENCODING_PCM_A_LAW}. Set to {@link #NO_VALUE} for other
+   * media types.
    */
-  @C.PcmEncoding
-  public final int pcmEncoding;
+  public final @C.PcmEncoding int pcmEncoding;
   /**
    * The number of frames to trim from the start of the decoded audio stream, or 0 if not
    * applicable.
@@ -141,15 +151,6 @@
    */
   public final int encoderPadding;
 
-  // Text specific.
-
-  /**
-   * For samples that contain subsamples, this is an offset that should be added to subsample
-   * timestamps. A value of {@link #OFFSET_SAMPLE_RELATIVE} indicates that subsample timestamps are
-   * relative to the timestamps of their parent samples.
-   */
-  public final long subsampleOffsetUs;
-
   // Audio and text specific.
 
   /**
@@ -171,6 +172,7 @@
 
   // Video.
 
+  @Deprecated
   public static Format createVideoContainerFormat(
       @Nullable String id,
       @Nullable String containerMimeType,
@@ -180,12 +182,62 @@ public static Format createVideoContainerFormat(
       int width,
       int height,
       float frameRate,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @C.SelectionFlags int selectionFlags) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, width,
-        height, frameRate, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, selectionFlags, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
-        initializationData, null, null);
+    return createVideoContainerFormat(
+        id,
+        /* label= */ null,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        width,
+        height,
+        frameRate,
+        initializationData,
+        selectionFlags);
+  }
+
+  public static Format createVideoContainerFormat(
+      @Nullable String id,
+      @Nullable String label,
+      @Nullable String containerMimeType,
+      String sampleMimeType,
+      String codecs,
+      int bitrate,
+      int width,
+      int height,
+      float frameRate,
+      @Nullable List<byte[]> initializationData,
+      @C.SelectionFlags int selectionFlags) {
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        /* maxInputSize= */ NO_VALUE,
+        width,
+        height,
+        frameRate,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        selectionFlags,
+        /* language= */ null,
+        /* accessibilityChannel= */ NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        initializationData,
+        /* drmInitData= */ null,
+        /* metadata= */ null);
   }
 
   public static Format createVideoSampleFormat(
@@ -197,10 +249,21 @@ public static Format createVideoSampleFormat(
       int width,
       int height,
       float frameRate,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @Nullable DrmInitData drmInitData) {
-    return createVideoSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, initializationData, NO_VALUE, NO_VALUE, drmInitData);
+    return createVideoSampleFormat(
+        id,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        initializationData,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        drmInitData);
   }
 
   public static Format createVideoSampleFormat(
@@ -212,13 +275,26 @@ public static Format createVideoSampleFormat(
       int width,
       int height,
       float frameRate,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       int rotationDegrees,
       float pixelWidthHeightRatio,
       @Nullable DrmInitData drmInitData) {
-    return createVideoSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, initializationData, rotationDegrees, pixelWidthHeightRatio, null,
-        NO_VALUE, null, drmInitData);
+    return createVideoSampleFormat(
+        id,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        initializationData,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        drmInitData);
   }
 
   public static Format createVideoSampleFormat(
@@ -230,36 +306,111 @@ public static Format createVideoSampleFormat(
       int width,
       int height,
       float frameRate,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       int rotationDegrees,
       float pixelWidthHeightRatio,
       byte[] projectionData,
       @C.StereoMode int stereoMode,
       @Nullable ColorInfo colorInfo,
       @Nullable DrmInitData drmInitData) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, width, height,
-        frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, 0, null, NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE, initializationData, drmInitData, null);
+    return new Format(
+        id,
+        /* label= */ null,
+        /* containerMimeType= */ null,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        /* selectionFlags= */ 0,
+        /* language= */ null,
+        /* accessibilityChannel= */ NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        initializationData,
+        drmInitData,
+        /* metadata= */ null);
   }
 
   // Audio.
 
+  @Deprecated
+  public static Format createAudioContainerFormat(
+      @Nullable String id,
+      @Nullable String containerMimeType,
+      @Nullable String sampleMimeType,
+      @Nullable String codecs,
+      int bitrate,
+      int channelCount,
+      int sampleRate,
+      @Nullable List<byte[]> initializationData,
+      @C.SelectionFlags int selectionFlags,
+      @Nullable String language) {
+    return createAudioContainerFormat(
+        id,
+        /* label= */ null,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        channelCount,
+        sampleRate,
+        initializationData,
+        selectionFlags,
+        language);
+  }
+
   public static Format createAudioContainerFormat(
       @Nullable String id,
+      @Nullable String label,
       @Nullable String containerMimeType,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
       int bitrate,
       int channelCount,
       int sampleRate,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, channelCount, sampleRate,
-        NO_VALUE, NO_VALUE, NO_VALUE, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
-        initializationData, null, null);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        channelCount,
+        sampleRate,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        selectionFlags,
+        language,
+        /* accessibilityChannel= */ NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        initializationData,
+        /* drmInitData= */ null,
+        /* metadata= */ null);
   }
 
   public static Format createAudioSampleFormat(
@@ -270,12 +421,23 @@ public static Format createAudioSampleFormat(
       int maxInputSize,
       int channelCount,
       int sampleRate,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @Nullable DrmInitData drmInitData,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
-    return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
-        sampleRate, NO_VALUE, initializationData, drmInitData, selectionFlags, language);
+    return createAudioSampleFormat(
+        id,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        channelCount,
+        sampleRate,
+        /* pcmEncoding= */ NO_VALUE,
+        initializationData,
+        drmInitData,
+        selectionFlags,
+        language);
   }
 
   public static Format createAudioSampleFormat(
@@ -287,13 +449,26 @@ public static Format createAudioSampleFormat(
       int channelCount,
       int sampleRate,
       @C.PcmEncoding int pcmEncoding,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @Nullable DrmInitData drmInitData,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
-    return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
-        sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
-        selectionFlags, language, null);
+    return createAudioSampleFormat(
+        id,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        initializationData,
+        drmInitData,
+        selectionFlags,
+        language,
+        /* metadata= */ null);
   }
 
   public static Format createAudioSampleFormat(
@@ -307,19 +482,44 @@ public static Format createAudioSampleFormat(
       @C.PcmEncoding int pcmEncoding,
       int encoderDelay,
       int encoderPadding,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @Nullable DrmInitData drmInitData,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language,
       @Nullable Metadata metadata) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, channelCount, sampleRate, pcmEncoding,
-        encoderDelay, encoderPadding, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
-        initializationData, drmInitData, metadata);
+    return new Format(
+        id,
+        /* label= */ null,
+        /* containerMimeType= */ null,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        /* accessibilityChannel= */ NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   // Text.
 
+  @Deprecated
   public static Format createTextContainerFormat(
       @Nullable String id,
       @Nullable String containerMimeType,
@@ -328,12 +528,41 @@ public static Format createTextContainerFormat(
       int bitrate,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
-    return createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs, bitrate,
-        selectionFlags, language, NO_VALUE);
+    return createTextContainerFormat(
+        id,
+        /* label= */ null,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        selectionFlags,
+        language);
   }
 
   public static Format createTextContainerFormat(
       @Nullable String id,
+      @Nullable String label,
+      @Nullable String containerMimeType,
+      @Nullable String sampleMimeType,
+      @Nullable String codecs,
+      int bitrate,
+      @C.SelectionFlags int selectionFlags,
+      @Nullable String language) {
+    return createTextContainerFormat(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        selectionFlags,
+        language,
+        /* accessibilityChannel= */ NO_VALUE);
+  }
+
+  public static Format createTextContainerFormat(
+      @Nullable String id,
+      @Nullable String label,
       @Nullable String containerMimeType,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
@@ -341,10 +570,34 @@ public static Format createTextContainerFormat(
       @C.SelectionFlags int selectionFlags,
       @Nullable String language,
       int accessibilityChannel) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, selectionFlags, language, accessibilityChannel,
-        OFFSET_SAMPLE_RELATIVE, null, null, null);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        OFFSET_SAMPLE_RELATIVE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        /* metadata= */ null);
   }
 
   public static Format createTextSampleFormat(
@@ -361,8 +614,17 @@ public static Format createTextSampleFormat(
       @C.SelectionFlags int selectionFlags,
       @Nullable String language,
       @Nullable DrmInitData drmInitData) {
-    return createTextSampleFormat(id, sampleMimeType, null, NO_VALUE, selectionFlags, language,
-        NO_VALUE, drmInitData, OFFSET_SAMPLE_RELATIVE, Collections.<byte[]>emptyList());
+    return createTextSampleFormat(
+        id,
+        sampleMimeType,
+        /* codecs= */ null,
+        /* bitrate= */ NO_VALUE,
+        selectionFlags,
+        language,
+        NO_VALUE,
+        drmInitData,
+        OFFSET_SAMPLE_RELATIVE,
+        Collections.emptyList());
   }
 
   public static Format createTextSampleFormat(
@@ -374,8 +636,17 @@ public static Format createTextSampleFormat(
       @Nullable String language,
       int accessibilityChannel,
       @Nullable DrmInitData drmInitData) {
-    return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
-        accessibilityChannel, drmInitData, OFFSET_SAMPLE_RELATIVE, Collections.<byte[]>emptyList());
+    return createTextSampleFormat(
+        id,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        drmInitData,
+        OFFSET_SAMPLE_RELATIVE,
+        Collections.emptyList());
   }
 
   public static Format createTextSampleFormat(
@@ -387,8 +658,17 @@ public static Format createTextSampleFormat(
       @Nullable String language,
       @Nullable DrmInitData drmInitData,
       long subsampleOffsetUs) {
-    return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
-        NO_VALUE, drmInitData, subsampleOffsetUs, Collections.<byte[]>emptyList());
+    return createTextSampleFormat(
+        id,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        selectionFlags,
+        language,
+        /* accessibilityChannel= */ NO_VALUE,
+        drmInitData,
+        subsampleOffsetUs,
+        Collections.emptyList());
   }
 
   public static Format createTextSampleFormat(
@@ -402,10 +682,34 @@ public static Format createTextSampleFormat(
       @Nullable DrmInitData drmInitData,
       long subsampleOffsetUs,
       List<byte[]> initializationData) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, null);
+    return new Format(
+        id,
+        /* label= */ null,
+        /* containerMimeType= */ null,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        /* metadata= */ null);
   }
 
   // Image.
@@ -416,40 +720,42 @@ public static Format createImageSampleFormat(
       @Nullable String codecs,
       int bitrate,
       @C.SelectionFlags int selectionFlags,
-      List<byte[]> initializationData,
+      @Nullable List<byte[]> initializationData,
       @Nullable String language,
       @Nullable DrmInitData drmInitData) {
     return new Format(
         id,
-        null,
+        /* label= */ null,
+        /* containerMimeType= */ null,
         sampleMimeType,
         codecs,
         bitrate,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
-        null,
-        NO_VALUE,
-        null,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
-        NO_VALUE,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
         selectionFlags,
         language,
-        NO_VALUE,
+        /* accessibilityChannel= */ NO_VALUE,
         OFFSET_SAMPLE_RELATIVE,
         initializationData,
         drmInitData,
-        null);
+        /* metadata=*/ null);
   }
 
   // Generic.
 
+  @Deprecated
   public static Format createContainerFormat(
       @Nullable String id,
       @Nullable String containerMimeType,
@@ -458,17 +764,86 @@ public static Format createContainerFormat(
       int bitrate,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, null,
-        null);
+    return createContainerFormat(
+        id,
+        /* label= */ null,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        selectionFlags,
+        language);
+  }
+
+  public static Format createContainerFormat(
+      @Nullable String id,
+      @Nullable String label,
+      @Nullable String containerMimeType,
+      @Nullable String sampleMimeType,
+      @Nullable String codecs,
+      int bitrate,
+      @C.SelectionFlags int selectionFlags,
+      @Nullable String language) {
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        selectionFlags,
+        language,
+        /* accessibilityChannel= */ NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        /* metadata= */ null);
   }
 
   public static Format createSampleFormat(
       @Nullable String id, @Nullable String sampleMimeType, long subsampleOffsetUs) {
-    return new Format(id, null, sampleMimeType, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
+    return new Format(
+        id,
+        /* label= */ null,
+        /* containerMimeType= */ null,
+        sampleMimeType,
+        /* codecs= */ null,
+        /* bitrate= */ NO_VALUE,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        /* selectionFlags= */ 0,
+        /* language= */ null,
+        /* accessibilityChannel= */ NO_VALUE,
+        subsampleOffsetUs,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        /* metadata= */ null);
   }
 
   public static Format createSampleFormat(
@@ -477,13 +852,39 @@ public static Format createSampleFormat(
       @Nullable String codecs,
       int bitrate,
       @Nullable DrmInitData drmInitData) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, drmInitData, null);
+    return new Format(
+        id,
+        /* label= */ null,
+        /* containerMimeType= */ null,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        /* maxInputSize= */ NO_VALUE,
+        /* width= */ NO_VALUE,
+        /* height= */ NO_VALUE,
+        /* frameRate= */ NO_VALUE,
+        /* rotationDegrees= */ NO_VALUE,
+        /* pixelWidthHeightRatio= */ NO_VALUE,
+        /* projectionData= */ null,
+        /* stereoMode= */ NO_VALUE,
+        /* colorInfo= */ null,
+        /* channelCount= */ NO_VALUE,
+        /* sampleRate= */ NO_VALUE,
+        /* pcmEncoding= */ NO_VALUE,
+        /* encoderDelay= */ NO_VALUE,
+        /* encoderPadding= */ NO_VALUE,
+        /* selectionFlags= */ 0,
+        /* language= */ null,
+        /* accessibilityChannel= */ NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        /* initializationData= */ null,
+        drmInitData,
+        /* metadata= */ null);
   }
 
   /* package */ Format(
       @Nullable String id,
+      @Nullable String label,
       @Nullable String containerMimeType,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
@@ -510,6 +911,7 @@ public static Format createSampleFormat(
       @Nullable DrmInitData drmInitData,
       @Nullable Metadata metadata) {
     this.id = id;
+    this.label = label;
     this.containerMimeType = containerMimeType;
     this.sampleMimeType = sampleMimeType;
     this.codecs = codecs;
@@ -533,8 +935,8 @@ public static Format createSampleFormat(
     this.language = language;
     this.accessibilityChannel = accessibilityChannel;
     this.subsampleOffsetUs = subsampleOffsetUs;
-    this.initializationData = initializationData == null ? Collections.<byte[]>emptyList()
-        : initializationData;
+    this.initializationData =
+        initializationData == null ? Collections.emptyList() : initializationData;
     this.drmInitData = drmInitData;
     this.metadata = metadata;
   }
@@ -542,6 +944,7 @@ public static Format createSampleFormat(
   @SuppressWarnings("ResourceType")
   /* package */ Format(Parcel in) {
     id = in.readString();
+    label = in.readString();
     containerMimeType = in.readString();
     sampleMimeType = in.readString();
     codecs = in.readString();
@@ -575,23 +978,70 @@ public static Format createSampleFormat(
   }
 
   public Format copyWithMaxInputSize(int maxInputSize) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   public Format copyWithContainerInfo(
       @Nullable String id,
+      @Nullable String label,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
       int bitrate,
@@ -599,11 +1049,34 @@ public Format copyWithContainerInfo(
       int height,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   @SuppressWarnings("ReferenceEquality")
@@ -612,51 +1085,193 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
       // No need to copy from ourselves.
       return this;
     }
+
+    int trackType = MimeTypes.getTrackType(sampleMimeType);
+
+    // Use manifest value only.
     String id = manifestFormat.id;
-    String codecs = this.codecs == null ? manifestFormat.codecs : this.codecs;
+
+    // Prefer manifest values, but fill in from sample format if missing.
+    String label = manifestFormat.label != null ? manifestFormat.label : this.label;
+    String language = this.language;
+    if ((trackType == C.TRACK_TYPE_TEXT || trackType == C.TRACK_TYPE_AUDIO)
+        && manifestFormat.language != null) {
+      language = manifestFormat.language;
+    }
+
+    // Prefer sample format values, but fill in from manifest if missing.
     int bitrate = this.bitrate == NO_VALUE ? manifestFormat.bitrate : this.bitrate;
-    float frameRate = this.frameRate == NO_VALUE ? manifestFormat.frameRate : this.frameRate;
-    @C.SelectionFlags int selectionFlags = this.selectionFlags |  manifestFormat.selectionFlags;
-    String language = this.language == null ? manifestFormat.language : this.language;
+    String codecs = this.codecs;
+    if (codecs == null) {
+      // The manifest format may be muxed, so filter only codecs of this format's type. If we still
+      // have more than one codec then we're unable to uniquely identify which codec to fill in.
+      String codecsOfType = Util.getCodecsOfType(manifestFormat.codecs, trackType);
+      if (Util.splitCodecs(codecsOfType).length == 1) {
+        codecs = codecsOfType;
+      }
+    }
+    float frameRate = this.frameRate;
+    if (frameRate == NO_VALUE && trackType == C.TRACK_TYPE_VIDEO) {
+      frameRate = manifestFormat.frameRate;
+    }
+
+    // Merge manifest and sample format values.
+    @C.SelectionFlags int selectionFlags = this.selectionFlags | manifestFormat.selectionFlags;
     DrmInitData drmInitData =
         DrmInitData.createSessionCreationData(manifestFormat.drmInitData, this.drmInitData);
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   public Format copyWithDrmInitData(@Nullable DrmInitData drmInitData) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   public Format copyWithMetadata(@Nullable Metadata metadata) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   public Format copyWithRotationDegrees(int rotationDegrees) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
-        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
-        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
-        drmInitData, metadata);
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
   }
 
   /**
@@ -669,9 +1284,32 @@ public int getPixelCount() {
 
   @Override
   public String toString() {
-    return "Format(" + id + ", " + containerMimeType + ", " + sampleMimeType + ", " + bitrate + ", "
-        + language + ", [" + width + ", " + height + ", " + frameRate + "]"
-        + ", [" + channelCount + ", " + sampleRate + "])";
+    return "Format("
+        + id
+        + ", "
+        + label
+        + ", "
+        + containerMimeType
+        + ", "
+        + sampleMimeType
+        + ", "
+        + codecs
+        + ", "
+        + bitrate
+        + ", "
+        + language
+        + ", ["
+        + width
+        + ", "
+        + height
+        + ", "
+        + frameRate
+        + "]"
+        + ", ["
+        + channelCount
+        + ", "
+        + sampleRate
+        + "])";
   }
 
   @Override
@@ -691,6 +1329,18 @@ public int hashCode() {
       result = 31 * result + accessibilityChannel;
       result = 31 * result + (drmInitData == null ? 0 : drmInitData.hashCode());
       result = 31 * result + (metadata == null ? 0 : metadata.hashCode());
+      result = 31 * result + (label != null ? label.hashCode() : 0);
+      result = 31 * result + maxInputSize;
+      result = 31 * result + (int) subsampleOffsetUs;
+      result = 31 * result + Float.floatToIntBits(frameRate);
+      result = 31 * result + Float.floatToIntBits(pixelWidthHeightRatio);
+      result = 31 * result + rotationDegrees;
+      result = 31 * result + stereoMode;
+      result = 31 * result + pcmEncoding;
+      result = 31 * result + encoderDelay;
+      result = 31 * result + encoderPadding;
+      result = 31 * result + selectionFlags;
+      // Not all of the fields are included to keep the calculation quick enough.
       hashCode = result;
     }
     return hashCode;
@@ -705,13 +1355,16 @@ public boolean equals(@Nullable Object obj) {
       return false;
     }
     Format other = (Format) obj;
+    if (hashCode != 0 && other.hashCode != 0 && hashCode != other.hashCode) {
+      return false;
+    }
     return bitrate == other.bitrate
         && maxInputSize == other.maxInputSize
         && width == other.width
         && height == other.height
-        && frameRate == other.frameRate
+        && Float.compare(frameRate, other.frameRate) == 0
         && rotationDegrees == other.rotationDegrees
-        && pixelWidthHeightRatio == other.pixelWidthHeightRatio
+        && Float.compare(pixelWidthHeightRatio, other.pixelWidthHeightRatio) == 0
         && stereoMode == other.stereoMode
         && channelCount == other.channelCount
         && sampleRate == other.sampleRate
@@ -721,6 +1374,7 @@ public boolean equals(@Nullable Object obj) {
         && subsampleOffsetUs == other.subsampleOffsetUs
         && selectionFlags == other.selectionFlags
         && Util.areEqual(id, other.id)
+        && Util.areEqual(label, other.label)
         && Util.areEqual(language, other.language)
         && accessibilityChannel == other.accessibilityChannel
         && Util.areEqual(containerMimeType, other.containerMimeType)
@@ -755,10 +1409,8 @@ public boolean initializationDataEquals(Format other) {
 
   // Utility methods
 
-  /**
-   * Returns a prettier {@link String} than {@link #toString()}, intended for logging.
-   */
-  public static String toLogString(Format format) {
+  /** Returns a prettier {@link String} than {@link #toString()}, intended for logging. */
+  public static String toLogString(@Nullable Format format) {
     if (format == null) {
       return "null";
     }
@@ -767,6 +1419,9 @@ public static String toLogString(Format format) {
     if (format.bitrate != Format.NO_VALUE) {
       builder.append(", bitrate=").append(format.bitrate);
     }
+    if (format.codecs != null) {
+      builder.append(", codecs=").append(format.codecs);
+    }
     if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
       builder.append(", res=").append(format.width).append("x").append(format.height);
     }
@@ -782,6 +1437,9 @@ public static String toLogString(Format format) {
     if (format.language != null) {
       builder.append(", language=").append(format.language);
     }
+    if (format.label != null) {
+      builder.append(", label=").append(format.label);
+    }
     return builder.toString();
   }
 
@@ -795,6 +1453,7 @@ public int describeContents() {
   @Override
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(id);
+    dest.writeString(label);
     dest.writeString(containerMimeType);
     dest.writeString(sampleMimeType);
     dest.writeString(codecs);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java
index b26787517e..8c7ba1eb91 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java
@@ -15,14 +15,13 @@
  */
 package com.google.android.exoplayer2;
 
+import android.support.annotation.Nullable;
+
 /**
  * Holds a {@link Format}.
  */
 public final class FormatHolder {
 
-  /**
-   * The held {@link Format}.
-   */
-  public Format format;
-
+  /** The held {@link Format}. */
+  public @Nullable Format format;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 2f71d0d547..5925c8f383 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2;
 
-import android.util.Log;
 import com.google.android.exoplayer2.source.ClippingMediaPeriod;
 import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
@@ -28,6 +27,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 
 /** Holds a {@link MediaPeriod} with information required to play it as part of a timeline. */
 /* package */ final class MediaPeriodHolder {
@@ -39,7 +39,6 @@
   public final SampleStream[] sampleStreams;
   public final boolean[] mayRetainStreamFlags;
 
-  public long rendererPositionOffsetUs;
   public boolean prepared;
   public boolean hasEnabledTracks;
   public MediaPeriodInfo info;
@@ -51,6 +50,7 @@
   private final TrackSelector trackSelector;
   private final MediaSource mediaSource;
 
+  private long rendererPositionOffsetUs;
   private TrackSelectorResult periodTrackSelectorResult;
 
   /**
@@ -62,7 +62,6 @@
    * @param trackSelector The track selector.
    * @param allocator The allocator.
    * @param mediaSource The media source that produced the media period.
-   * @param uid The unique identifier for the containing timeline period.
    * @param info Information used to identify this media period in its timeline period.
    */
   public MediaPeriodHolder(
@@ -71,24 +70,23 @@ public MediaPeriodHolder(
       TrackSelector trackSelector,
       Allocator allocator,
       MediaSource mediaSource,
-      Object uid,
       MediaPeriodInfo info) {
     this.rendererCapabilities = rendererCapabilities;
     this.rendererPositionOffsetUs = rendererPositionOffsetUs - info.startPositionUs;
     this.trackSelector = trackSelector;
     this.mediaSource = mediaSource;
-    this.uid = Assertions.checkNotNull(uid);
+    this.uid = Assertions.checkNotNull(info.id.periodUid);
     this.info = info;
     sampleStreams = new SampleStream[rendererCapabilities.length];
     mayRetainStreamFlags = new boolean[rendererCapabilities.length];
     MediaPeriod mediaPeriod = mediaSource.createPeriod(info.id, allocator);
-    if (info.endPositionUs != C.TIME_END_OF_SOURCE) {
+    if (info.id.endPositionUs != C.TIME_END_OF_SOURCE) {
       mediaPeriod =
           new ClippingMediaPeriod(
               mediaPeriod,
               /* enableInitialDiscontinuity= */ true,
               /* startUs= */ 0,
-              info.endPositionUs);
+              info.id.endPositionUs);
     }
     this.mediaPeriod = mediaPeriod;
   }
@@ -105,6 +103,10 @@ public long getRendererOffset() {
     return rendererPositionOffsetUs;
   }
 
+  public long getStartPositionRendererTime() {
+    return info.startPositionUs + rendererPositionOffsetUs;
+  }
+
   public boolean isFullyBuffered() {
     return prepared
         && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
@@ -115,22 +117,18 @@ public long getDurationUs() {
   }
 
   /**
-   * Returns the buffered position in microseconds. If the period is buffered to the end then
-   * {@link C#TIME_END_OF_SOURCE} is returned unless {@code convertEosToDuration} is true, in which
-   * case the period duration is returned.
+   * Returns the buffered position in microseconds. If the period is buffered to the end, then the
+   * period duration is returned.
    *
-   * @param convertEosToDuration Whether to return the period duration rather than
-   *     {@link C#TIME_END_OF_SOURCE} if the period is fully buffered.
    * @return The buffered position in microseconds.
    */
-  public long getBufferedPositionUs(boolean convertEosToDuration) {
+  public long getBufferedPositionUs() {
     if (!prepared) {
       return info.startPositionUs;
     }
-    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
-    return bufferedPositionUs == C.TIME_END_OF_SOURCE && convertEosToDuration
-        ? info.durationUs
-        : bufferedPositionUs;
+    long bufferedPositionUs =
+        hasEnabledTracks ? mediaPeriod.getBufferedPositionUs() : C.TIME_END_OF_SOURCE;
+    return bufferedPositionUs == C.TIME_END_OF_SOURCE ? info.durationUs : bufferedPositionUs;
   }
 
   public long getNextLoadPositionUs() {
@@ -218,7 +216,7 @@ public long applyTrackSelection(
   public void release() {
     updatePeriodTrackSelectorResult(null);
     try {
-      if (info.endPositionUs != C.TIME_END_OF_SOURCE) {
+      if (info.id.endPositionUs != C.TIME_END_OF_SOURCE) {
         mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
       } else {
         mediaSource.releasePeriod(mediaPeriod);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
index fce1780b71..ba19b54c3f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
@@ -25,18 +25,13 @@
   public final MediaPeriodId id;
   /** The start position of the media to play within the media period, in microseconds. */
   public final long startPositionUs;
-  /**
-   * The end position of the media to play within the media period, in microseconds, or {@link
-   * C#TIME_END_OF_SOURCE} if the end position is the end of the media period.
-   */
-  public final long endPositionUs;
   /**
    * If this is an ad, the position to play in the next content media period. {@link C#TIME_UNSET}
    * otherwise.
    */
   public final long contentPositionUs;
   /**
-   * The duration of the media period, like {@link #endPositionUs} but with {@link
+   * The duration of the media period, like {@link MediaPeriodId#endPositionUs} but with {@link
    * C#TIME_END_OF_SOURCE} resolved to the timeline period duration. May be {@link C#TIME_UNSET} if
    * the end position is not known.
    */
@@ -55,41 +50,23 @@
   MediaPeriodInfo(
       MediaPeriodId id,
       long startPositionUs,
-      long endPositionUs,
       long contentPositionUs,
       long durationUs,
       boolean isLastInTimelinePeriod,
       boolean isFinal) {
     this.id = id;
     this.startPositionUs = startPositionUs;
-    this.endPositionUs = endPositionUs;
     this.contentPositionUs = contentPositionUs;
     this.durationUs = durationUs;
     this.isLastInTimelinePeriod = isLastInTimelinePeriod;
     this.isFinal = isFinal;
   }
 
-  /**
-   * Returns a copy of this instance with the period identifier's period index set to the specified
-   * value.
-   */
-  public MediaPeriodInfo copyWithPeriodIndex(int periodIndex) {
-    return new MediaPeriodInfo(
-        id.copyWithPeriodIndex(periodIndex),
-        startPositionUs,
-        endPositionUs,
-        contentPositionUs,
-        durationUs,
-        isLastInTimelinePeriod,
-        isFinal);
-  }
-
   /** Returns a copy of this instance with the start position set to the specified value. */
   public MediaPeriodInfo copyWithStartPositionUs(long startPositionUs) {
     return new MediaPeriodInfo(
         id,
         startPositionUs,
-        endPositionUs,
         contentPositionUs,
         durationUs,
         isLastInTimelinePeriod,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 717f873622..c51c1cc149 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -30,7 +30,6 @@
  * loading media period at the end of the queue, with methods for controlling loading and updating
  * the queue. Also has a reference to the media period currently being read.
  */
-@SuppressWarnings("UngroupedOverloads")
 /* package */ final class MediaPeriodQueue {
 
   /**
@@ -47,17 +46,18 @@
   private Timeline timeline;
   private @RepeatMode int repeatMode;
   private boolean shuffleModeEnabled;
-  private MediaPeriodHolder playing;
-  private MediaPeriodHolder reading;
-  private MediaPeriodHolder loading;
+  private @Nullable MediaPeriodHolder playing;
+  private @Nullable MediaPeriodHolder reading;
+  private @Nullable MediaPeriodHolder loading;
   private int length;
-  private Object oldFrontPeriodUid;
+  private @Nullable Object oldFrontPeriodUid;
   private long oldFrontPeriodWindowSequenceNumber;
 
   /** Creates a new media period queue. */
   public MediaPeriodQueue() {
     period = new Timeline.Period();
     window = new Timeline.Window();
+    timeline = Timeline.EMPTY;
   }
 
   /**
@@ -134,7 +134,6 @@ public boolean shouldLoadNextMediaPeriod() {
    * @param trackSelector The track selector.
    * @param allocator The allocator.
    * @param mediaSource The media source that produced the media period.
-   * @param uid The unique identifier for the containing timeline period.
    * @param info Information used to identify this media period in its timeline period.
    */
   public MediaPeriod enqueueNextMediaPeriod(
@@ -142,7 +141,6 @@ public MediaPeriod enqueueNextMediaPeriod(
       TrackSelector trackSelector,
       Allocator allocator,
       MediaSource mediaSource,
-      Object uid,
       MediaPeriodInfo info) {
     long rendererPositionOffsetUs =
         loading == null
@@ -155,7 +153,6 @@ public MediaPeriod enqueueNextMediaPeriod(
             trackSelector,
             allocator,
             mediaSource,
-            uid,
             info);
     if (loading != null) {
       Assertions.checkState(hasPlayingPeriod());
@@ -228,11 +225,13 @@ public MediaPeriodHolder advancePlayingPeriod() {
         reading = playing.next;
       }
       playing.release();
-      playing = playing.next;
       length--;
       if (length == 0) {
         loading = null;
+        oldFrontPeriodUid = playing.uid;
+        oldFrontPeriodWindowSequenceNumber = playing.info.id.windowSequenceNumber;
       }
+      playing = playing.next;
     } else {
       playing = loading;
       reading = loading;
@@ -301,18 +300,18 @@ public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId, long rendererP
     // TODO: Merge this into setTimeline so that the queue gets updated as soon as the new timeline
     // is set, once all cases handled by ExoPlayerImplInternal.handleSourceInfoRefreshed can be
     // handled here.
-    int periodIndex = playingPeriodId.periodIndex;
+    int periodIndex = timeline.getIndexOfPeriod(playingPeriodId.periodUid);
     // The front period is either playing now, or is being loaded and will become the playing
     // period.
     MediaPeriodHolder previousPeriodHolder = null;
     MediaPeriodHolder periodHolder = getFrontPeriod();
     while (periodHolder != null) {
       if (previousPeriodHolder == null) {
-        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info, periodIndex);
+        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info);
       } else {
         // Check this period holder still follows the previous one, based on the new timeline.
         if (periodIndex == C.INDEX_UNSET
-            || !periodHolder.uid.equals(timeline.getPeriod(periodIndex, period, true).uid)) {
+            || !periodHolder.uid.equals(timeline.getUidOfPeriod(periodIndex))) {
           // The holder uid is inconsistent with the new timeline.
           return !removeAfter(previousPeriodHolder);
         }
@@ -322,8 +321,8 @@ public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId, long rendererP
           // We've loaded a next media period that is not in the new timeline.
           return !removeAfter(previousPeriodHolder);
         }
-        // Update the period index.
-        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info, periodIndex);
+        // Update the period holder.
+        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info);
         // Check the media period information matches the new timeline.
         if (!canKeepMediaPeriodHolder(periodHolder, periodInfo)) {
           return !removeAfter(previousPeriodHolder);
@@ -345,16 +344,29 @@ public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId, long rendererP
 
   /**
    * Returns new media period info based on specified {@code mediaPeriodInfo} but taking into
-   * account the current timeline, and with the period index updated to {@code newPeriodIndex}.
+   * account the current timeline. This method must only be called if the period is still part of
+   * the current timeline.
    *
-   * @param mediaPeriodInfo Media period info for a media period based on an old timeline.
-   * @param newPeriodIndex The new period index in the new timeline for the existing media period.
+   * @param info Media period info for a media period based on an old timeline.
    * @return The updated media period info for the current timeline.
    */
-  public MediaPeriodInfo getUpdatedMediaPeriodInfo(
-      MediaPeriodInfo mediaPeriodInfo, int newPeriodIndex) {
-    return getUpdatedMediaPeriodInfo(
-        mediaPeriodInfo, mediaPeriodInfo.id.copyWithPeriodIndex(newPeriodIndex));
+  public MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo info) {
+    boolean isLastInPeriod = isLastInPeriod(info.id);
+    boolean isLastInTimeline = isLastInTimeline(info.id, isLastInPeriod);
+    timeline.getPeriodByUid(info.id.periodUid, period);
+    long durationUs =
+        info.id.isAd()
+            ? period.getAdDurationUs(info.id.adGroupIndex, info.id.adIndexInAdGroup)
+            : (info.id.endPositionUs == C.TIME_END_OF_SOURCE
+                ? period.getDurationUs()
+                : info.id.endPositionUs);
+    return new MediaPeriodInfo(
+        info.id,
+        info.startPositionUs,
+        info.contentPositionUs,
+        durationUs,
+        isLastInPeriod,
+        isLastInTimeline);
   }
 
   /**
@@ -362,13 +374,13 @@ public MediaPeriodInfo getUpdatedMediaPeriodInfo(
    * played, returning an identifier for an ad group if one needs to be played before the specified
    * position, or an identifier for a content media period if not.
    *
-   * @param periodIndex The index of the timeline period to play.
+   * @param periodUid The uid of the timeline period to play.
    * @param positionUs The next content position in the period to play.
    * @return The identifier for the first media period to play, taking into account unplayed ads.
    */
-  public MediaPeriodId resolveMediaPeriodIdForAds(int periodIndex, long positionUs) {
-    long windowSequenceNumber = resolvePeriodIndexToWindowSequenceNumber(periodIndex);
-    return resolveMediaPeriodIdForAds(periodIndex, positionUs, windowSequenceNumber);
+  public MediaPeriodId resolveMediaPeriodIdForAds(Object periodUid, long positionUs) {
+    long windowSequenceNumber = resolvePeriodIndexToWindowSequenceNumber(periodUid);
+    return resolveMediaPeriodIdForAds(periodUid, positionUs, windowSequenceNumber);
   }
 
   // Internal methods.
@@ -378,35 +390,39 @@ public MediaPeriodId resolveMediaPeriodIdForAds(int periodIndex, long positionUs
    * played, returning an identifier for an ad group if one needs to be played before the specified
    * position, or an identifier for a content media period if not.
    *
-   * @param periodIndex The index of the timeline period to play.
+   * @param periodUid The uid of the timeline period to play.
    * @param positionUs The next content position in the period to play.
    * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
    *     windows this period is part of.
    * @return The identifier for the first media period to play, taking into account unplayed ads.
    */
   private MediaPeriodId resolveMediaPeriodIdForAds(
-      int periodIndex, long positionUs, long windowSequenceNumber) {
-    timeline.getPeriod(periodIndex, period);
+      Object periodUid, long positionUs, long windowSequenceNumber) {
+    timeline.getPeriodByUid(periodUid, period);
     int adGroupIndex = period.getAdGroupIndexForPositionUs(positionUs);
     if (adGroupIndex == C.INDEX_UNSET) {
-      return new MediaPeriodId(periodIndex, windowSequenceNumber);
+      int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(positionUs);
+      long endPositionUs =
+          nextAdGroupIndex == C.INDEX_UNSET
+              ? C.TIME_END_OF_SOURCE
+              : period.getAdGroupTimeUs(nextAdGroupIndex);
+      return new MediaPeriodId(periodUid, windowSequenceNumber, endPositionUs);
     } else {
       int adIndexInAdGroup = period.getFirstAdIndexToPlay(adGroupIndex);
-      return new MediaPeriodId(periodIndex, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
+      return new MediaPeriodId(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
     }
   }
 
   /**
-   * Resolves the specified period index to a corresponding window sequence number. Either by
-   * reusing the window sequence number of an existing matching media period or by creating a new
-   * window sequence number.
+   * Resolves the specified period uid to a corresponding window sequence number. Either by reusing
+   * the window sequence number of an existing matching media period or by creating a new window
+   * sequence number.
    *
-   * @param periodIndex The index of the timeline period.
+   * @param periodUid The uid of the timeline period.
    * @return A window sequence number for a media period created for this timeline period.
    */
-  private long resolvePeriodIndexToWindowSequenceNumber(int periodIndex) {
-    Object periodUid = timeline.getPeriod(periodIndex, period, /* setIds= */ true).uid;
-    int windowIndex = period.windowIndex;
+  private long resolvePeriodIndexToWindowSequenceNumber(Object periodUid) {
+    int windowIndex = timeline.getPeriodByUid(periodUid, period).windowIndex;
     if (oldFrontPeriodUid != null) {
       int oldFrontPeriodIndex = timeline.getIndexOfPeriod(oldFrontPeriodUid);
       if (oldFrontPeriodIndex != C.INDEX_UNSET) {
@@ -448,7 +464,6 @@ private long resolvePeriodIndexToWindowSequenceNumber(int periodIndex) {
   private boolean canKeepMediaPeriodHolder(MediaPeriodHolder periodHolder, MediaPeriodInfo info) {
     MediaPeriodInfo periodHolderInfo = periodHolder.info;
     return periodHolderInfo.startPositionUs == info.startPositionUs
-        && periodHolderInfo.endPositionUs == info.endPositionUs
         && periodHolderInfo.id.equals(info.id);
   }
 
@@ -462,32 +477,32 @@ private boolean updateForPlaybackModeChange() {
     if (lastValidPeriodHolder == null) {
       return true;
     }
+    int currentPeriodIndex = timeline.getIndexOfPeriod(lastValidPeriodHolder.uid);
     while (true) {
       int nextPeriodIndex =
           timeline.getNextPeriodIndex(
-              lastValidPeriodHolder.info.id.periodIndex,
-              period,
-              window,
-              repeatMode,
-              shuffleModeEnabled);
+              currentPeriodIndex, period, window, repeatMode, shuffleModeEnabled);
       while (lastValidPeriodHolder.next != null
           && !lastValidPeriodHolder.info.isLastInTimelinePeriod) {
         lastValidPeriodHolder = lastValidPeriodHolder.next;
       }
-      if (nextPeriodIndex == C.INDEX_UNSET
-          || lastValidPeriodHolder.next == null
-          || lastValidPeriodHolder.next.info.id.periodIndex != nextPeriodIndex) {
+
+      if (nextPeriodIndex == C.INDEX_UNSET || lastValidPeriodHolder.next == null) {
+        break;
+      }
+      int nextPeriodHolderPeriodIndex = timeline.getIndexOfPeriod(lastValidPeriodHolder.next.uid);
+      if (nextPeriodHolderPeriodIndex != nextPeriodIndex) {
         break;
       }
       lastValidPeriodHolder = lastValidPeriodHolder.next;
+      currentPeriodIndex = nextPeriodIndex;
     }
 
     // Release any period holders that don't match the new period order.
     boolean readingPeriodRemoved = removeAfter(lastValidPeriodHolder);
 
     // Update the period info for the last holder, as it may now be the last period in the timeline.
-    lastValidPeriodHolder.info =
-        getUpdatedMediaPeriodInfo(lastValidPeriodHolder.info, lastValidPeriodHolder.info.id);
+    lastValidPeriodHolder.info = getUpdatedMediaPeriodInfo(lastValidPeriodHolder.info);
 
     // If renderers may have read from a period that's been removed, it is necessary to restart.
     return !readingPeriodRemoved || !hasPlayingPeriod();
@@ -517,10 +532,16 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
     // until the timeline is updated. Store whether the next timeline period is ready when the
     // timeline is updated, to avoid repeatedly checking the same timeline.
     MediaPeriodInfo mediaPeriodInfo = mediaPeriodHolder.info;
+    // The expected delay until playback transitions to the new period is equal the duration of
+    // media that's currently buffered (assuming no interruptions). This is used to project forward
+    // the start position for transitions to new windows.
+    long bufferedDurationUs =
+        mediaPeriodHolder.getRendererOffset() + mediaPeriodInfo.durationUs - rendererPositionUs;
     if (mediaPeriodInfo.isLastInTimelinePeriod) {
+      int currentPeriodIndex = timeline.getIndexOfPeriod(mediaPeriodInfo.id.periodUid);
       int nextPeriodIndex =
           timeline.getNextPeriodIndex(
-              mediaPeriodInfo.id.periodIndex, period, window, repeatMode, shuffleModeEnabled);
+              currentPeriodIndex, period, window, repeatMode, shuffleModeEnabled);
       if (nextPeriodIndex == C.INDEX_UNSET) {
         // We can't create a next period yet.
         return null;
@@ -533,23 +554,19 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
       long windowSequenceNumber = mediaPeriodInfo.id.windowSequenceNumber;
       if (timeline.getWindow(nextWindowIndex, window).firstPeriodIndex == nextPeriodIndex) {
         // We're starting to buffer a new window. When playback transitions to this window we'll
-        // want it to be from its default start position. The expected delay until playback
-        // transitions is equal the duration of media that's currently buffered (assuming no
-        // interruptions). Hence we project the default start position forward by the duration of
-        // the buffer, and start buffering from this point.
-        long defaultPositionProjectionUs =
-            mediaPeriodHolder.getRendererOffset() + mediaPeriodInfo.durationUs - rendererPositionUs;
-        Pair<Integer, Long> defaultPosition =
+        // want it to be from its default start position, so project the default start position
+        // forward by the duration of the buffer, and start buffering from this point.
+        Pair<Object, Long> defaultPosition =
             timeline.getPeriodPosition(
                 window,
                 period,
                 nextWindowIndex,
-                C.TIME_UNSET,
-                Math.max(0, defaultPositionProjectionUs));
+                /* windowPositionUs= */ C.TIME_UNSET,
+                /* defaultPositionProjectionUs= */ Math.max(0, bufferedDurationUs));
         if (defaultPosition == null) {
           return null;
         }
-        nextPeriodIndex = defaultPosition.first;
+        nextPeriodUid = defaultPosition.first;
         startPositionUs = defaultPosition.second;
         if (mediaPeriodHolder.next != null && mediaPeriodHolder.next.uid.equals(nextPeriodUid)) {
           windowSequenceNumber = mediaPeriodHolder.next.info.id.windowSequenceNumber;
@@ -560,12 +577,12 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
         startPositionUs = 0;
       }
       MediaPeriodId periodId =
-          resolveMediaPeriodIdForAds(nextPeriodIndex, startPositionUs, windowSequenceNumber);
+          resolveMediaPeriodIdForAds(nextPeriodUid, startPositionUs, windowSequenceNumber);
       return getMediaPeriodInfo(periodId, startPositionUs, startPositionUs);
     }
 
     MediaPeriodId currentPeriodId = mediaPeriodInfo.id;
-    timeline.getPeriod(currentPeriodId.periodIndex, period);
+    timeline.getPeriodByUid(currentPeriodId.periodUid, period);
     if (currentPeriodId.isAd()) {
       int adGroupIndex = currentPeriodId.adGroupIndex;
       int adCountInCurrentAdGroup = period.getAdCountInAdGroup(adGroupIndex);
@@ -579,36 +596,52 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
         return !period.isAdAvailable(adGroupIndex, nextAdIndexInAdGroup)
             ? null
             : getMediaPeriodInfoForAd(
-                currentPeriodId.periodIndex,
+                currentPeriodId.periodUid,
                 adGroupIndex,
                 nextAdIndexInAdGroup,
                 mediaPeriodInfo.contentPositionUs,
                 currentPeriodId.windowSequenceNumber);
       } else {
-        // Play content from the ad group position.
+        // Play content from the ad group position. As a special case, if we're transitioning from a
+        // preroll ad group to content and there are no other ad groups, project the start position
+        // forward as if this were a transition to a new window. No attempt is made to handle
+        // midrolls in live streams, as it's unclear what content position should play after an ad
+        // (server-side dynamic ad insertion is more appropriate for this use case).
+        long startPositionUs = mediaPeriodInfo.contentPositionUs;
+        if (period.getAdGroupCount() == 1 && period.getAdGroupTimeUs(0) == 0) {
+          Pair<Object, Long> defaultPosition =
+              timeline.getPeriodPosition(
+                  window,
+                  period,
+                  period.windowIndex,
+                  /* windowPositionUs= */ C.TIME_UNSET,
+                  /* defaultPositionProjectionUs= */ Math.max(0, bufferedDurationUs));
+          if (defaultPosition == null) {
+            return null;
+          }
+          startPositionUs = defaultPosition.second;
+        }
         return getMediaPeriodInfoForContent(
-            currentPeriodId.periodIndex,
-            mediaPeriodInfo.contentPositionUs,
-            currentPeriodId.windowSequenceNumber);
+            currentPeriodId.periodUid, startPositionUs, currentPeriodId.windowSequenceNumber);
       }
-    } else if (mediaPeriodInfo.endPositionUs != C.TIME_END_OF_SOURCE) {
+    } else if (mediaPeriodInfo.id.endPositionUs != C.TIME_END_OF_SOURCE) {
       // Play the next ad group if it's available.
-      int nextAdGroupIndex = period.getAdGroupIndexForPositionUs(mediaPeriodInfo.endPositionUs);
+      int nextAdGroupIndex = period.getAdGroupIndexForPositionUs(mediaPeriodInfo.id.endPositionUs);
       if (nextAdGroupIndex == C.INDEX_UNSET) {
         // The next ad group can't be played. Play content from the ad group position instead.
         return getMediaPeriodInfoForContent(
-            currentPeriodId.periodIndex,
-            mediaPeriodInfo.endPositionUs,
+            currentPeriodId.periodUid,
+            mediaPeriodInfo.id.endPositionUs,
             currentPeriodId.windowSequenceNumber);
       }
       int adIndexInAdGroup = period.getFirstAdIndexToPlay(nextAdGroupIndex);
       return !period.isAdAvailable(nextAdGroupIndex, adIndexInAdGroup)
           ? null
           : getMediaPeriodInfoForAd(
-              currentPeriodId.periodIndex,
+              currentPeriodId.periodUid,
               nextAdGroupIndex,
               adIndexInAdGroup,
-              mediaPeriodInfo.endPositionUs,
+              mediaPeriodInfo.id.endPositionUs,
               currentPeriodId.windowSequenceNumber);
     } else {
       // Check if the postroll ad should be played.
@@ -627,7 +660,7 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
       }
       long contentDurationUs = period.getDurationUs();
       return getMediaPeriodInfoForAd(
-          currentPeriodId.periodIndex,
+          currentPeriodId.periodUid,
           adGroupIndex,
           adIndexInAdGroup,
           contentDurationUs,
@@ -635,57 +668,37 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
     }
   }
 
-  private MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo info, MediaPeriodId newId) {
-    long startPositionUs = info.startPositionUs;
-    long endPositionUs = info.endPositionUs;
-    boolean isLastInPeriod = isLastInPeriod(newId, endPositionUs);
-    boolean isLastInTimeline = isLastInTimeline(newId, isLastInPeriod);
-    timeline.getPeriod(newId.periodIndex, period);
-    long durationUs =
-        newId.isAd()
-            ? period.getAdDurationUs(newId.adGroupIndex, newId.adIndexInAdGroup)
-            : (endPositionUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endPositionUs);
-    return new MediaPeriodInfo(
-        newId,
-        startPositionUs,
-        endPositionUs,
-        info.contentPositionUs,
-        durationUs,
-        isLastInPeriod,
-        isLastInTimeline);
-  }
-
   private MediaPeriodInfo getMediaPeriodInfo(
       MediaPeriodId id, long contentPositionUs, long startPositionUs) {
-    timeline.getPeriod(id.periodIndex, period);
+    timeline.getPeriodByUid(id.periodUid, period);
     if (id.isAd()) {
       if (!period.isAdAvailable(id.adGroupIndex, id.adIndexInAdGroup)) {
         return null;
       }
       return getMediaPeriodInfoForAd(
-          id.periodIndex,
+          id.periodUid,
           id.adGroupIndex,
           id.adIndexInAdGroup,
           contentPositionUs,
           id.windowSequenceNumber);
     } else {
-      return getMediaPeriodInfoForContent(id.periodIndex, startPositionUs, id.windowSequenceNumber);
+      return getMediaPeriodInfoForContent(id.periodUid, startPositionUs, id.windowSequenceNumber);
     }
   }
 
   private MediaPeriodInfo getMediaPeriodInfoForAd(
-      int periodIndex,
+      Object periodUid,
       int adGroupIndex,
       int adIndexInAdGroup,
       long contentPositionUs,
       long windowSequenceNumber) {
     MediaPeriodId id =
-        new MediaPeriodId(periodIndex, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
-    boolean isLastInPeriod = isLastInPeriod(id, C.TIME_END_OF_SOURCE);
+        new MediaPeriodId(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
+    boolean isLastInPeriod = isLastInPeriod(id);
     boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
     long durationUs =
         timeline
-            .getPeriod(id.periodIndex, period)
+            .getPeriodByUid(id.periodUid, period)
             .getAdDurationUs(id.adGroupIndex, id.adIndexInAdGroup);
     long startPositionUs =
         adIndexInAdGroup == period.getFirstAdIndexToPlay(adGroupIndex)
@@ -694,7 +707,6 @@ private MediaPeriodInfo getMediaPeriodInfoForAd(
     return new MediaPeriodInfo(
         id,
         startPositionUs,
-        C.TIME_END_OF_SOURCE,
         contentPositionUs,
         durationUs,
         isLastInPeriod,
@@ -702,23 +714,24 @@ private MediaPeriodInfo getMediaPeriodInfoForAd(
   }
 
   private MediaPeriodInfo getMediaPeriodInfoForContent(
-      int periodIndex, long startPositionUs, long windowSequenceNumber) {
-    MediaPeriodId id = new MediaPeriodId(periodIndex, windowSequenceNumber);
-    timeline.getPeriod(id.periodIndex, period);
+      Object periodUid, long startPositionUs, long windowSequenceNumber) {
     int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(startPositionUs);
-    long endUs =
+    long endPositionUs =
         nextAdGroupIndex == C.INDEX_UNSET
             ? C.TIME_END_OF_SOURCE
             : period.getAdGroupTimeUs(nextAdGroupIndex);
-    boolean isLastInPeriod = isLastInPeriod(id, endUs);
+    MediaPeriodId id = new MediaPeriodId(periodUid, windowSequenceNumber, endPositionUs);
+    timeline.getPeriodByUid(id.periodUid, period);
+    boolean isLastInPeriod = isLastInPeriod(id);
     boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
-    long durationUs = endUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endUs;
+    long durationUs =
+        endPositionUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endPositionUs;
     return new MediaPeriodInfo(
-        id, startPositionUs, endUs, C.TIME_UNSET, durationUs, isLastInPeriod, isLastInTimeline);
+        id, startPositionUs, C.TIME_UNSET, durationUs, isLastInPeriod, isLastInTimeline);
   }
 
-  private boolean isLastInPeriod(MediaPeriodId id, long endPositionUs) {
-    int adGroupCount = timeline.getPeriod(id.periodIndex, period).getAdGroupCount();
+  private boolean isLastInPeriod(MediaPeriodId id) {
+    int adGroupCount = timeline.getPeriodByUid(id.periodUid, period).getAdGroupCount();
     if (adGroupCount == 0) {
       return true;
     }
@@ -727,7 +740,7 @@ private boolean isLastInPeriod(MediaPeriodId id, long endPositionUs) {
     boolean isAd = id.isAd();
     if (period.getAdGroupTimeUs(lastAdGroupIndex) != C.TIME_END_OF_SOURCE) {
       // There's no postroll ad.
-      return !isAd && endPositionUs == C.TIME_END_OF_SOURCE;
+      return !isAd && id.endPositionUs == C.TIME_END_OF_SOURCE;
     }
 
     int postrollAdCount = period.getAdCountInAdGroup(lastAdGroupIndex);
@@ -742,9 +755,10 @@ private boolean isLastInPeriod(MediaPeriodId id, long endPositionUs) {
   }
 
   private boolean isLastInTimeline(MediaPeriodId id, boolean isLastMediaPeriodInPeriod) {
-    int windowIndex = timeline.getPeriod(id.periodIndex, period).windowIndex;
+    int periodIndex = timeline.getIndexOfPeriod(id.periodUid);
+    int windowIndex = timeline.getPeriod(periodIndex, period).windowIndex;
     return !timeline.getWindow(windowIndex, window).isDynamic
-        && timeline.isLastPeriod(id.periodIndex, period, window, repeatMode, shuffleModeEnabled)
+        && timeline.isLastPeriod(periodIndex, period, window, repeatMode, shuffleModeEnabled)
         && isLastMediaPeriodInPeriod;
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
index 593d3d1fce..45d6537b84 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
@@ -182,7 +183,7 @@ public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
   // PlayerMessage.Target implementation.
 
   @Override
-  public void handleMessage(int what, Object object) throws ExoPlaybackException {
+  public void handleMessage(int what, @Nullable Object object) throws ExoPlaybackException {
     // Do nothing.
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index 80de073e2d..4333f51bf7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
+import android.support.annotation.CheckResult;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -25,36 +26,102 @@
  */
 /* package */ final class PlaybackInfo {
 
+  /**
+   * Dummy media period id used while the timeline is empty and no period id is specified. This id
+   * is used when playback infos are created with {@link #createDummy(long, TrackSelectorResult)}.
+   */
+  private static final MediaPeriodId DUMMY_MEDIA_PERIOD_ID =
+      new MediaPeriodId(/* periodUid= */ new Object());
+
+  /** The current {@link Timeline}. */
   public final Timeline timeline;
+  /** The current manifest. */
   public final @Nullable Object manifest;
+  /** The {@link MediaPeriodId} of the currently playing media period in the {@link #timeline}. */
   public final MediaPeriodId periodId;
+  /**
+   * The start position at which playback started in {@link #periodId} relative to the start of the
+   * associated period in the {@link #timeline}, in microseconds. Note that this value changes for
+   * each position discontinuity.
+   */
   public final long startPositionUs;
+  /**
+   * If {@link #periodId} refers to an ad, the position of the suspended content relative to the
+   * start of the associated period in the {@link #timeline}, in microseconds. {@link C#TIME_UNSET}
+   * if {@link #periodId} does not refer to an ad.
+   */
   public final long contentPositionUs;
+  /** The current playback state. One of the {@link Player}.STATE_ constants. */
   public final int playbackState;
+  /** Whether the player is currently loading. */
   public final boolean isLoading;
+  /** The currently available track groups. */
   public final TrackGroupArray trackGroups;
+  /** The result of the current track selection. */
   public final TrackSelectorResult trackSelectorResult;
+  /** The {@link MediaPeriodId} of the currently loading media period in the {@link #timeline}. */
+  public final MediaPeriodId loadingMediaPeriodId;
 
-  public volatile long positionUs;
+  /**
+   * Position up to which media is buffered in {@link #loadingMediaPeriodId) relative to the start
+   * of the associated period in the {@link #timeline}, in microseconds.
+   */
   public volatile long bufferedPositionUs;
+  /**
+   * Total duration of buffered media from {@link #positionUs} to {@link #bufferedPositionUs}
+   * including all ads.
+   */
+  public volatile long totalBufferedDurationUs;
+  /**
+   * Current playback position in {@link #periodId} relative to the start of the associated period
+   * in the {@link #timeline}, in microseconds.
+   */
+  public volatile long positionUs;
 
-  public PlaybackInfo(
-      Timeline timeline,
-      long startPositionUs,
-      TrackGroupArray trackGroups,
-      TrackSelectorResult trackSelectorResult) {
-    this(
-        timeline,
+  /**
+   * Creates empty dummy playback info which can be used for masking as long as no real playback
+   * info is available.
+   *
+   * @param startPositionUs The start position at which playback should start, in microseconds.
+   * @param emptyTrackSelectorResult An empty track selector result with null entries for each
+   *     renderer.
+   * @return A dummy playback info.
+   */
+  public static PlaybackInfo createDummy(
+      long startPositionUs, TrackSelectorResult emptyTrackSelectorResult) {
+    return new PlaybackInfo(
+        Timeline.EMPTY,
         /* manifest= */ null,
-        new MediaPeriodId(/* periodIndex= */ 0),
+        DUMMY_MEDIA_PERIOD_ID,
         startPositionUs,
-        /* contentPositionUs =*/ C.TIME_UNSET,
+        /* contentPositionUs= */ C.TIME_UNSET,
         Player.STATE_IDLE,
         /* isLoading= */ false,
-        trackGroups,
-        trackSelectorResult);
+        TrackGroupArray.EMPTY,
+        emptyTrackSelectorResult,
+        DUMMY_MEDIA_PERIOD_ID,
+        startPositionUs,
+        /* totalBufferedDurationUs= */ 0,
+        startPositionUs);
   }
 
+  /**
+   * Create playback info.
+   *
+   * @param timeline See {@link #timeline}.
+   * @param manifest See {@link #manifest}.
+   * @param periodId See {@link #periodId}.
+   * @param startPositionUs See {@link #startPositionUs}.
+   * @param contentPositionUs See {@link #contentPositionUs}.
+   * @param playbackState See {@link #playbackState}.
+   * @param isLoading See {@link #isLoading}.
+   * @param trackGroups See {@link #trackGroups}.
+   * @param trackSelectorResult See {@link #trackSelectorResult}.
+   * @param loadingMediaPeriodId See {@link #loadingMediaPeriodId}.
+   * @param bufferedPositionUs See {@link #bufferedPositionUs}.
+   * @param totalBufferedDurationUs See {@link #totalBufferedDurationUs}.
+   * @param positionUs See {@link #positionUs}.
+   */
   public PlaybackInfo(
       Timeline timeline,
       @Nullable Object manifest,
@@ -64,21 +131,55 @@ public PlaybackInfo(
       int playbackState,
       boolean isLoading,
       TrackGroupArray trackGroups,
-      TrackSelectorResult trackSelectorResult) {
+      TrackSelectorResult trackSelectorResult,
+      MediaPeriodId loadingMediaPeriodId,
+      long bufferedPositionUs,
+      long totalBufferedDurationUs,
+      long positionUs) {
     this.timeline = timeline;
     this.manifest = manifest;
     this.periodId = periodId;
     this.startPositionUs = startPositionUs;
     this.contentPositionUs = contentPositionUs;
-    this.positionUs = startPositionUs;
-    this.bufferedPositionUs = startPositionUs;
     this.playbackState = playbackState;
     this.isLoading = isLoading;
     this.trackGroups = trackGroups;
     this.trackSelectorResult = trackSelectorResult;
+    this.loadingMediaPeriodId = loadingMediaPeriodId;
+    this.bufferedPositionUs = bufferedPositionUs;
+    this.totalBufferedDurationUs = totalBufferedDurationUs;
+    this.positionUs = positionUs;
+  }
+
+  /**
+   * Returns dummy media period id for the first-to-be-played period of the current timeline.
+   *
+   * @param shuffleModeEnabled Whether shuffle mode is enabled.
+   * @param window A writable {@link Timeline.Window}.
+   * @return A dummy media period id for the first-to-be-played period of the current timeline.
+   */
+  public MediaPeriodId getDummyFirstMediaPeriodId(
+      boolean shuffleModeEnabled, Timeline.Window window) {
+    if (timeline.isEmpty()) {
+      return DUMMY_MEDIA_PERIOD_ID;
+    }
+    int firstPeriodIndex =
+        timeline.getWindow(timeline.getFirstWindowIndex(shuffleModeEnabled), window)
+            .firstPeriodIndex;
+    return new MediaPeriodId(timeline.getUidOfPeriod(firstPeriodIndex));
   }
 
-  public PlaybackInfo fromNewPosition(
+  /**
+   * Copies playback info and resets playing and loading position.
+   *
+   * @param periodId New playing and loading {@link MediaPeriodId}.
+   * @param startPositionUs New start position. See {@link #startPositionUs}.
+   * @param contentPositionUs New content position. See {@link #contentPositionUs}. Value is ignored
+   *     if {@code periodId.isAd()} is true.
+   * @return Copied playback info with reset position.
+   */
+  @CheckResult
+  public PlaybackInfo resetToNewPosition(
       MediaPeriodId periodId, long startPositionUs, long contentPositionUs) {
     return new PlaybackInfo(
         timeline,
@@ -89,93 +190,165 @@ public PlaybackInfo fromNewPosition(
         playbackState,
         isLoading,
         trackGroups,
-        trackSelectorResult);
+        trackSelectorResult,
+        periodId,
+        startPositionUs,
+        /* totalBufferedDurationUs= */ 0,
+        startPositionUs);
   }
 
-  public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
-    PlaybackInfo playbackInfo =
-        new PlaybackInfo(
-            timeline,
-            manifest,
-            periodId.copyWithPeriodIndex(periodIndex),
-            startPositionUs,
-            contentPositionUs,
-            playbackState,
-            isLoading,
-            trackGroups,
-            trackSelectorResult);
-    copyMutablePositions(this, playbackInfo);
-    return playbackInfo;
+  /**
+   * Copied playback info with new playing position.
+   *
+   * @param periodId New playing media period. See {@link #periodId}.
+   * @param positionUs New position. See {@link #positionUs}.
+   * @param contentPositionUs New content position. See {@link #contentPositionUs}. Value is ignored
+   *     if {@code periodId.isAd()} is true.
+   * @param totalBufferedDurationUs New buffered duration. See {@link #totalBufferedDurationUs}.
+   * @return Copied playback info with new playing position.
+   */
+  @CheckResult
+  public PlaybackInfo copyWithNewPosition(
+      MediaPeriodId periodId,
+      long positionUs,
+      long contentPositionUs,
+      long totalBufferedDurationUs) {
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        positionUs,
+        periodId.isAd() ? contentPositionUs : C.TIME_UNSET,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
   }
 
+  /**
+   * Copies playback info with new timeline and manifest.
+   *
+   * @param timeline New timeline. See {@link #timeline}.
+   * @param manifest New manifest. See {@link #manifest}.
+   * @return Copied playback info with new timeline and manifest.
+   */
+  @CheckResult
   public PlaybackInfo copyWithTimeline(Timeline timeline, Object manifest) {
-    PlaybackInfo playbackInfo =
-        new PlaybackInfo(
-            timeline,
-            manifest,
-            periodId,
-            startPositionUs,
-            contentPositionUs,
-            playbackState,
-            isLoading,
-            trackGroups,
-            trackSelectorResult);
-    copyMutablePositions(this, playbackInfo);
-    return playbackInfo;
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        startPositionUs,
+        contentPositionUs,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
   }
 
+  /**
+   * Copies playback info with new playback state.
+   *
+   * @param playbackState New playback state. See {@link #playbackState}.
+   * @return Copied playback info with new playback state.
+   */
+  @CheckResult
   public PlaybackInfo copyWithPlaybackState(int playbackState) {
-    PlaybackInfo playbackInfo =
-        new PlaybackInfo(
-            timeline,
-            manifest,
-            periodId,
-            startPositionUs,
-            contentPositionUs,
-            playbackState,
-            isLoading,
-            trackGroups,
-            trackSelectorResult);
-    copyMutablePositions(this, playbackInfo);
-    return playbackInfo;
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        startPositionUs,
+        contentPositionUs,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
   }
 
+  /**
+   * Copies playback info with new loading state.
+   *
+   * @param isLoading New loading state. See {@link #isLoading}.
+   * @return Copied playback info with new loading state.
+   */
+  @CheckResult
   public PlaybackInfo copyWithIsLoading(boolean isLoading) {
-    PlaybackInfo playbackInfo =
-        new PlaybackInfo(
-            timeline,
-            manifest,
-            periodId,
-            startPositionUs,
-            contentPositionUs,
-            playbackState,
-            isLoading,
-            trackGroups,
-            trackSelectorResult);
-    copyMutablePositions(this, playbackInfo);
-    return playbackInfo;
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        startPositionUs,
+        contentPositionUs,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
   }
 
+  /**
+   * Copies playback info with new track information.
+   *
+   * @param trackGroups New track groups. See {@link #trackGroups}.
+   * @param trackSelectorResult New track selector result. See {@link #trackSelectorResult}.
+   * @return Copied playback info with new track information.
+   */
+  @CheckResult
   public PlaybackInfo copyWithTrackInfo(
       TrackGroupArray trackGroups, TrackSelectorResult trackSelectorResult) {
-    PlaybackInfo playbackInfo =
-        new PlaybackInfo(
-            timeline,
-            manifest,
-            periodId,
-            startPositionUs,
-            contentPositionUs,
-            playbackState,
-            isLoading,
-            trackGroups,
-            trackSelectorResult);
-    copyMutablePositions(this, playbackInfo);
-    return playbackInfo;
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        startPositionUs,
+        contentPositionUs,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
   }
 
-  private static void copyMutablePositions(PlaybackInfo from, PlaybackInfo to) {
-    to.positionUs = from.positionUs;
-    to.bufferedPositionUs = from.bufferedPositionUs;
+  /**
+   * Copies playback info with new loading media period.
+   *
+   * @param loadingMediaPeriodId New loading media period id. See {@link #loadingMediaPeriodId}.
+   * @return Copied playback info with new loading media period.
+   */
+  @CheckResult
+  public PlaybackInfo copyWithLoadingMediaPeriodId(MediaPeriodId loadingMediaPeriodId) {
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        startPositionUs,
+        contentPositionUs,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index 328816d709..e3441fb2a7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -22,10 +22,19 @@
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 import android.view.TextureView;
+import com.google.android.exoplayer2.C.VideoScalingMode;
+import com.google.android.exoplayer2.audio.AudioAttributes;
+import com.google.android.exoplayer2.audio.AudioListener;
+import com.google.android.exoplayer2.audio.AuxEffectInfo;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoListener;
+import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -50,18 +59,101 @@
  */
 public interface Player {
 
+  /** The audio component of a {@link Player}. */
+  interface AudioComponent {
+
+    /**
+     * Adds a listener to receive audio events.
+     *
+     * @param listener The listener to register.
+     */
+    void addAudioListener(AudioListener listener);
+
+    /**
+     * Removes a listener of audio events.
+     *
+     * @param listener The listener to unregister.
+     */
+    void removeAudioListener(AudioListener listener);
+
+    /**
+     * Sets the attributes for audio playback, used by the underlying audio track. If not set, the
+     * default audio attributes will be used. They are suitable for general media playback.
+     *
+     * <p>Setting the audio attributes during playback may introduce a short gap in audio output as
+     * the audio track is recreated. A new audio session id will also be generated.
+     *
+     * <p>If tunneling is enabled by the track selector, the specified audio attributes will be
+     * ignored, but they will take effect if audio is later played without tunneling.
+     *
+     * <p>If the device is running a build before platform API version 21, audio attributes cannot
+     * be set directly on the underlying audio track. In this case, the usage will be mapped onto an
+     * equivalent stream type using {@link Util#getStreamTypeForAudioUsage(int)}.
+     *
+     * @param audioAttributes The attributes to use for audio playback.
+     * @deprecated Use {@link AudioComponent#setAudioAttributes(AudioAttributes, boolean)}.
+     */
+    @Deprecated
+    void setAudioAttributes(AudioAttributes audioAttributes);
+
+    /**
+     * Sets the attributes for audio playback, used by the underlying audio track. If not set, the
+     * default audio attributes will be used. They are suitable for general media playback.
+     *
+     * <p>Setting the audio attributes during playback may introduce a short gap in audio output as
+     * the audio track is recreated. A new audio session id will also be generated.
+     *
+     * <p>If tunneling is enabled by the track selector, the specified audio attributes will be
+     * ignored, but they will take effect if audio is later played without tunneling.
+     *
+     * <p>If the device is running a build before platform API version 21, audio attributes cannot
+     * be set directly on the underlying audio track. In this case, the usage will be mapped onto an
+     * equivalent stream type using {@link Util#getStreamTypeForAudioUsage(int)}.
+     *
+     * <p>If audio focus should be handled, the {@link AudioAttributes#usage} must be {@link
+     * C#USAGE_MEDIA} or {@link C#USAGE_GAME}. Other usages will throw an {@link
+     * IllegalArgumentException}.
+     *
+     * @param audioAttributes The attributes to use for audio playback.
+     * @param handleAudioFocus True if the player should handle audio focus, false otherwise.
+     */
+    void setAudioAttributes(AudioAttributes audioAttributes, boolean handleAudioFocus);
+
+    /** Returns the attributes for audio playback. */
+    AudioAttributes getAudioAttributes();
+
+    /** Returns the audio session identifier, or {@link C#AUDIO_SESSION_ID_UNSET} if not set. */
+    int getAudioSessionId();
+
+    /** Sets information on an auxiliary audio effect to attach to the underlying audio track. */
+    void setAuxEffectInfo(AuxEffectInfo auxEffectInfo);
+
+    /** Detaches any previously attached auxiliary audio effect from the underlying audio track. */
+    void clearAuxEffectInfo();
+
+    /**
+     * Sets the audio volume, with 0 being silence and 1 being unity gain.
+     *
+     * @param audioVolume The audio volume.
+     */
+    void setVolume(float audioVolume);
+
+    /** Returns the audio volume, with 0 being silence and 1 being unity gain. */
+    float getVolume();
+  }
+
   /** The video component of a {@link Player}. */
   interface VideoComponent {
 
     /**
-     * Sets the video scaling mode.
+     * Sets the {@link VideoScalingMode}.
      *
-     * @param videoScalingMode The video scaling mode.
+     * @param videoScalingMode The {@link VideoScalingMode}.
      */
-    void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode);
+    void setVideoScalingMode(@VideoScalingMode int videoScalingMode);
 
-    /** Returns the video scaling mode. */
-    @C.VideoScalingMode
+    /** Returns the {@link VideoScalingMode}. */
+    @VideoScalingMode
     int getVideoScalingMode();
 
     /**
@@ -78,12 +170,54 @@
      */
     void removeVideoListener(VideoListener listener);
 
+    /**
+     * Sets a listener to receive video frame metadata events.
+     *
+     * <p>This method is intended to be called by the same component that sets the {@link Surface}
+     * onto which video will be rendered. If using ExoPlayer's standard UI components, this method
+     * should not be called directly from application code.
+     *
+     * @param listener The listener.
+     */
+    void setVideoFrameMetadataListener(VideoFrameMetadataListener listener);
+
+    /**
+     * Clears the listener which receives video frame metadata events if it matches the one passed.
+     * Else does nothing.
+     *
+     * @param listener The listener to clear.
+     */
+    void clearVideoFrameMetadataListener(VideoFrameMetadataListener listener);
+
+    /**
+     * Sets a listener of camera motion events.
+     *
+     * @param listener The listener.
+     */
+    void setCameraMotionListener(CameraMotionListener listener);
+
+    /**
+     * Clears the listener which receives camera motion events if it matches the one passed. Else
+     * does nothing.
+     *
+     * @param listener The listener to clear.
+     */
+    void clearCameraMotionListener(CameraMotionListener listener);
+
     /**
      * Clears any {@link Surface}, {@link SurfaceHolder}, {@link SurfaceView} or {@link TextureView}
      * currently set on the player.
      */
     void clearVideoSurface();
 
+    /**
+     * Clears the {@link Surface} onto which video is being rendered if it matches the one passed.
+     * Else does nothing.
+     *
+     * @param surface The surface to clear.
+     */
+    void clearVideoSurface(Surface surface);
+
     /**
      * Sets the {@link Surface} onto which video will be rendered. The caller is responsible for
      * tracking the lifecycle of the surface, and must clear the surface by calling {@code
@@ -97,15 +231,7 @@
      *
      * @param surface The {@link Surface}.
      */
-    void setVideoSurface(Surface surface);
-
-    /**
-     * Clears the {@link Surface} onto which video is being rendered if it matches the one passed.
-     * Else does nothing.
-     *
-     * @param surface The surface to clear.
-     */
-    void clearVideoSurface(Surface surface);
+    void setVideoSurface(@Nullable Surface surface);
 
     /**
      * Sets the {@link SurfaceHolder} that holds the {@link Surface} onto which video will be
@@ -174,24 +300,44 @@
     void removeTextOutput(TextOutput listener);
   }
 
+  /** The metadata component of a {@link Player}. */
+  interface MetadataComponent {
+
+    /**
+     * Adds a {@link MetadataOutput} to receive metadata.
+     *
+     * @param output The output to register.
+     */
+    void addMetadataOutput(MetadataOutput output);
+
+    /**
+     * Removes a {@link MetadataOutput}.
+     *
+     * @param output The output to remove.
+     */
+    void removeMetadataOutput(MetadataOutput output);
+  }
+
   /**
-   * Listener of changes in player state.
+   * Listener of changes in player state. All methods have no-op default implementations to allow
+   * selective overrides.
    */
   interface EventListener {
 
     /**
      * Called when the timeline and/or manifest has been refreshed.
-     * <p>
-     * Note that if the timeline has changed then a position discontinuity may also have occurred.
-     * For example, the current period index may have changed as a result of periods being added or
-     * removed from the timeline. This will <em>not</em> be reported via a separate call to
+     *
+     * <p>Note that if the timeline has changed then a position discontinuity may also have
+     * occurred. For example, the current period index may have changed as a result of periods being
+     * added or removed from the timeline. This will <em>not</em> be reported via a separate call to
      * {@link #onPositionDiscontinuity(int)}.
      *
      * @param timeline The latest timeline. Never null, but may be empty.
      * @param manifest The latest manifest. May be null.
      * @param reason The {@link TimelineChangeReason} responsible for this timeline change.
      */
-    void onTimelineChanged(Timeline timeline, Object manifest, @TimelineChangeReason int reason);
+    default void onTimelineChanged(
+        Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {}
 
     /**
      * Called when the available or selected tracks change.
@@ -200,46 +346,47 @@
      * @param trackSelections The track selections for each renderer. Never null and always of
      *     length {@link #getRendererCount()}, but may contain null elements.
      */
-    void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections);
+    default void onTracksChanged(
+        TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {}
 
     /**
      * Called when the player starts or stops loading the source.
      *
      * @param isLoading Whether the source is currently being loaded.
      */
-    void onLoadingChanged(boolean isLoading);
+    default void onLoadingChanged(boolean isLoading) {}
 
     /**
-     * Called when the value returned from either {@link #getPlayWhenReady()} or
-     * {@link #getPlaybackState()} changes.
+     * Called when the value returned from either {@link #getPlayWhenReady()} or {@link
+     * #getPlaybackState()} changes.
      *
      * @param playWhenReady Whether playback will proceed when ready.
      * @param playbackState One of the {@code STATE} constants.
      */
-    void onPlayerStateChanged(boolean playWhenReady, int playbackState);
+    default void onPlayerStateChanged(boolean playWhenReady, int playbackState) {}
 
     /**
      * Called when the value of {@link #getRepeatMode()} changes.
      *
      * @param repeatMode The {@link RepeatMode} used for playback.
      */
-    void onRepeatModeChanged(@RepeatMode int repeatMode);
+    default void onRepeatModeChanged(@RepeatMode int repeatMode) {}
 
     /**
      * Called when the value of {@link #getShuffleModeEnabled()} changes.
      *
      * @param shuffleModeEnabled Whether shuffling of windows is enabled.
      */
-    void onShuffleModeEnabledChanged(boolean shuffleModeEnabled);
+    default void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {}
 
     /**
      * Called when an error occurs. The playback state will transition to {@link #STATE_IDLE}
-     * immediately after this method is called. The player instance can still be used, and
-     * {@link #release()} must still be called on the player should it no longer be required.
+     * immediately after this method is called. The player instance can still be used, and {@link
+     * #release()} must still be called on the player should it no longer be required.
      *
      * @param error The error.
      */
-    void onPlayerError(ExoPlaybackException error);
+    default void onPlayerError(ExoPlaybackException error) {}
 
     /**
      * Called when a position discontinuity occurs without a change to the timeline. A position
@@ -247,14 +394,14 @@
      * transitioning from one period in the timeline to the next), or when the playback position
      * jumps within the period currently being played (as a result of a seek being performed, or
      * when the source introduces a discontinuity internally).
-     * <p>
-     * When a position discontinuity occurs as a result of a change to the timeline this method is
-     * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object, int)} is called in this
+     *
+     * <p>When a position discontinuity occurs as a result of a change to the timeline this method
+     * is <em>not</em> called. {@link #onTimelineChanged(Timeline, Object, int)} is called in this
      * case.
      *
      * @param reason The {@link DiscontinuityReason} responsible for the discontinuity.
      */
-    void onPositionDiscontinuity(@DiscontinuityReason int reason);
+    default void onPositionDiscontinuity(@DiscontinuityReason int reason) {}
 
     /**
      * Called when the current playback parameters change. The playback parameters may change due to
@@ -264,83 +411,36 @@
      *
      * @param playbackParameters The playback parameters.
      */
-    void onPlaybackParametersChanged(PlaybackParameters playbackParameters);
+    default void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {}
 
     /**
      * Called when all pending seek requests have been processed by the player. This is guaranteed
-     * to happen after any necessary changes to the player state were reported to
-     * {@link #onPlayerStateChanged(boolean, int)}.
+     * to happen after any necessary changes to the player state were reported to {@link
+     * #onPlayerStateChanged(boolean, int)}.
      */
-    void onSeekProcessed();
-
+    default void onSeekProcessed() {}
   }
 
   /**
-   * {@link EventListener} allowing selective overrides. All methods are implemented as no-ops.
+   * @deprecated Use {@link EventListener} interface directly for selective overrides as all methods
+   *     are implemented as no-op default methods.
    */
+  @Deprecated
   abstract class DefaultEventListener implements EventListener {
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest,
-        @TimelineChangeReason int reason) {
+    @SuppressWarnings("deprecation")
+    public void onTimelineChanged(
+        Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
       // Call deprecated version. Otherwise, do nothing.
       onTimelineChanged(timeline, manifest);
     }
 
-    @Override
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onRepeatModeChanged(@RepeatMode int repeatMode) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlayerError(ExoPlaybackException error) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onSeekProcessed() {
-      // Do nothing.
-    }
-
-    /**
-     * @deprecated Use {@link DefaultEventListener#onTimelineChanged(Timeline, Object, int)}
-     *     instead.
-     */
+    /** @deprecated Use {@link EventListener#onTimelineChanged(Timeline, Object, int)} instead. */
     @Deprecated
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
+    public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
       // Do nothing.
     }
-
   }
 
   /**
@@ -363,11 +463,13 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
   int STATE_ENDED = 4;
 
   /**
-   * Repeat modes for playback.
+   * Repeat modes for playback. One of {@link #REPEAT_MODE_OFF}, {@link #REPEAT_MODE_ONE} or {@link
+   * #REPEAT_MODE_ALL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REPEAT_MODE_OFF, REPEAT_MODE_ONE, REPEAT_MODE_ALL})
-  public @interface RepeatMode {}
+  @interface RepeatMode {}
   /**
    * Normal playback without repetition.
    */
@@ -381,7 +483,12 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
    */
   int REPEAT_MODE_ALL = 2;
 
-  /** Reasons for position discontinuities. */
+  /**
+   * Reasons for position discontinuities. One of {@link #DISCONTINUITY_REASON_PERIOD_TRANSITION},
+   * {@link #DISCONTINUITY_REASON_SEEK}, {@link #DISCONTINUITY_REASON_SEEK_ADJUSTMENT}, {@link
+   * #DISCONTINUITY_REASON_AD_INSERTION} or {@link #DISCONTINUITY_REASON_INTERNAL}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     DISCONTINUITY_REASON_PERIOD_TRANSITION,
@@ -390,7 +497,7 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
     DISCONTINUITY_REASON_AD_INSERTION,
     DISCONTINUITY_REASON_INTERNAL
   })
-  public @interface DiscontinuityReason {}
+  @interface DiscontinuityReason {}
   /**
    * Automatic playback transition from one period in the timeline to the next. The period index may
    * be the same as it was before the discontinuity in case the current period is repeated.
@@ -409,12 +516,17 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
   int DISCONTINUITY_REASON_INTERNAL = 4;
 
   /**
-   * Reasons for timeline and/or manifest changes.
+   * Reasons for timeline and/or manifest changes. One of {@link #TIMELINE_CHANGE_REASON_PREPARED},
+   * {@link #TIMELINE_CHANGE_REASON_RESET} or {@link #TIMELINE_CHANGE_REASON_DYNAMIC}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TIMELINE_CHANGE_REASON_PREPARED, TIMELINE_CHANGE_REASON_RESET,
-      TIMELINE_CHANGE_REASON_DYNAMIC})
-  public @interface TimelineChangeReason {}
+  @IntDef({
+    TIMELINE_CHANGE_REASON_PREPARED,
+    TIMELINE_CHANGE_REASON_RESET,
+    TIMELINE_CHANGE_REASON_DYNAMIC
+  })
+  @interface TimelineChangeReason {}
   /**
    * Timeline and manifest changed as a result of a player initialization with new media.
    */
@@ -428,6 +540,10 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
    */
   int TIMELINE_CHANGE_REASON_DYNAMIC = 2;
 
+  /** Returns the component of this player for audio output, or null if audio is not supported. */
+  @Nullable
+  AudioComponent getAudioComponent();
+
   /** Returns the component of this player for video output, or null if video is not supported. */
   @Nullable
   VideoComponent getVideoComponent();
@@ -436,6 +552,18 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
   @Nullable
   TextComponent getTextComponent();
 
+  /**
+   * Returns the component of this player for metadata output, or null if metadata is not supported.
+   */
+  @Nullable
+  MetadataComponent getMetadataComponent();
+
+  /**
+   * Returns the {@link Looper} associated with the application thread that's used to access the
+   * player and on which player events are received.
+   */
+  Looper getApplicationLooper();
+
   /**
    * Register a listener to receive events from the player. The listener's methods will be called on
    * the thread that was used to construct the player. However, if the thread used to construct the
@@ -556,6 +684,32 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
    */
   void seekTo(int windowIndex, long positionMs);
 
+  /**
+   * Returns whether a previous window exists, which may depend on the current repeat mode and
+   * whether shuffle mode is enabled.
+   */
+  boolean hasPrevious();
+
+  /**
+   * Seeks to the default position of the previous window in the timeline, which may depend on the
+   * current repeat mode and whether shuffle mode is enabled. Does nothing if {@link #hasPrevious()}
+   * is {@code false}.
+   */
+  void previous();
+
+  /**
+   * Returns whether a next window exists, which may depend on the current repeat mode and whether
+   * shuffle mode is enabled.
+   */
+  boolean hasNext();
+
+  /**
+   * Seeks to the default position of the next window in the timeline, which may depend on the
+   * current repeat mode and whether shuffle mode is enabled. Does nothing if {@link #hasNext()} is
+   * {@code false}.
+   */
+  void next();
+
   /**
    * Attempts to set the playback parameters. Passing {@code null} sets the parameters to the
    * default, {@link PlaybackParameters#DEFAULT}, which means there is no speed or pitch adjustment.
@@ -673,28 +827,32 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
   @Nullable Object getCurrentTag();
 
   /**
-   * Returns the duration of the current window in milliseconds, or {@link C#TIME_UNSET} if the
-   * duration is not known.
+   * Returns the duration of the current content window or ad in milliseconds, or {@link
+   * C#TIME_UNSET} if the duration is not known.
    */
   long getDuration();
 
-  /**
-   * Returns the playback position in the current window, in milliseconds.
-   */
+  /** Returns the playback position in the current content window or ad, in milliseconds. */
   long getCurrentPosition();
 
   /**
-   * Returns an estimate of the position in the current window up to which data is buffered, in
-   * milliseconds.
+   * Returns an estimate of the position in the current content window or ad up to which data is
+   * buffered, in milliseconds.
    */
   long getBufferedPosition();
 
   /**
-   * Returns an estimate of the percentage in the current window up to which data is buffered, or 0
-   * if no estimate is available.
+   * Returns an estimate of the percentage in the current content window or ad up to which data is
+   * buffered, or 0 if no estimate is available.
    */
   int getBufferedPercentage();
 
+  /**
+   * Returns an estimate of the total buffered duration from the current position, in milliseconds.
+   * This includes pre-buffered data for subsequent ads and windows.
+   */
+  long getTotalBufferedDuration();
+
   /**
    * Returns whether the current window is dynamic, or {@code false} if the {@link Timeline} is
    * empty.
@@ -728,6 +886,13 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
    */
   int getCurrentAdIndexInAdGroup();
 
+  /**
+   * If {@link #isPlayingAd()} returns {@code true}, returns the duration of the current content
+   * window in milliseconds, or {@link C#TIME_UNSET} if the duration is not known. If there is no ad
+   * playing, the returned duration is the same as that returned by {@link #getDuration()}.
+   */
+  long getContentDuration();
+
   /**
    * If {@link #isPlayingAd()} returns {@code true}, returns the content position that will be
    * played once all ads in the ad group have finished playing, in milliseconds. If there is no ad
@@ -735,4 +900,10 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
    */
   long getContentPosition();
 
+  /**
+   * If {@link #isPlayingAd()} returns {@code true}, returns an estimate of the content position in
+   * the current content window up to which data is buffered, in milliseconds. If there is no ad
+   * playing, the returned position is the same as that returned by {@link #getBufferedPosition()}.
+   */
+  long getContentBufferedPosition();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
index 2c7aee834e..d60d428563 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
@@ -36,7 +36,7 @@
      * @throws ExoPlaybackException If an error occurred whilst handling the message. Should only be
      *     thrown by targets that handle messages on the playback thread.
      */
-    void handleMessage(int messageType, Object payload) throws ExoPlaybackException;
+    void handleMessage(int messageType, @Nullable Object payload) throws ExoPlaybackException;
   }
 
   /** A sender for messages. */
@@ -55,7 +55,7 @@
   private final Timeline timeline;
 
   private int type;
-  private Object payload;
+  private @Nullable Object payload;
   private Handler handler;
   private int windowIndex;
   private long positionMs;
@@ -134,7 +134,7 @@ public PlayerMessage setPayload(@Nullable Object payload) {
   }
 
   /** Returns the message payload forwarded to {@link Target#handleMessage(int, Object)}. */
-  public Object getPayload() {
+  public @Nullable Object getPayload() {
     return payload;
   }
 
@@ -156,6 +156,14 @@ public Handler getHandler() {
     return handler;
   }
 
+  /**
+   * Returns position in window at {@link #getWindowIndex()} at which the message will be delivered,
+   * in milliseconds. If {@link C#TIME_UNSET}, the message will be delivered immediately.
+   */
+  public long getPositionMs() {
+    return positionMs;
+  }
+
   /**
    * Sets a position in the current window at which the message will be delivered.
    *
@@ -170,14 +178,6 @@ public PlayerMessage setPosition(long positionMs) {
     return this;
   }
 
-  /**
-   * Returns position in window at {@link #getWindowIndex()} at which the message will be delivered,
-   * in milliseconds. If {@link C#TIME_UNSET}, the message will be delivered immediately.
-   */
-  public long getPositionMs() {
-    return positionMs;
-  }
-
   /**
    * Sets a position in a window at which the message will be delivered.
    *
@@ -231,7 +231,7 @@ public boolean getDeleteAfterDelivery() {
    * Player.EventListener#onPlayerError(ExoPlaybackException)}.
    *
    * @return This message.
-   * @throws IllegalStateException If {@link #send()} has already been called.
+   * @throws IllegalStateException If this message has already been sent.
    */
   public PlayerMessage send() {
     Assertions.checkState(!isSent);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
index e53db4568d..c6456e5f7f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.MediaClock;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -34,7 +35,11 @@
  */
 public interface Renderer extends PlayerMessage.Target {
 
-  /** The renderer states. */
+  /**
+   * The renderer states. One of {@link #STATE_DISABLED}, {@link #STATE_ENABLED} or {@link
+   * #STATE_STARTED}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_DISABLED, STATE_ENABLED, STATE_STARTED})
   @interface State {}
@@ -192,6 +197,18 @@ void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
    */
   void resetPosition(long positionUs) throws ExoPlaybackException;
 
+  /**
+   * Sets the operating rate of this renderer, where 1 is the default rate, 2 is twice the default
+   * rate, 0.5 is half the default rate and so on. The operating rate is a hint to the renderer of
+   * the speed at which playback will proceed, and may be used for resource planning.
+   *
+   * <p>The default implementation is a no-op.
+   *
+   * @param operatingRate The operating rate.
+   * @throws ExoPlaybackException If an error occurs handling the operating rate.
+   */
+  default void setOperatingRate(float operatingRate) throws ExoPlaybackException {}
+
   /**
    * Incrementally renders the {@link SampleStream}.
    * <p>
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 0a0df03053..fe52cc7e8c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -16,13 +16,14 @@
 package com.google.android.exoplayer2;
 
 import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Rect;
 import android.graphics.SurfaceTexture;
 import android.media.MediaCodec;
 import android.media.PlaybackParams;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
@@ -30,7 +31,10 @@
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.audio.AudioAttributes;
+import com.google.android.exoplayer2.audio.AudioFocusManager;
+import com.google.android.exoplayer2.audio.AudioListener;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.audio.AuxEffectInfo;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -43,9 +47,13 @@
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -56,7 +64,12 @@
  * be obtained from {@link ExoPlayerFactory}.
  */
 @TargetApi(16)
-public class SimpleExoPlayer implements ExoPlayer, Player.VideoComponent, Player.TextComponent {
+public class SimpleExoPlayer extends BasePlayer
+    implements ExoPlayer,
+        Player.AudioComponent,
+        Player.VideoComponent,
+        Player.TextComponent,
+        Player.MetadataComponent {
 
   /** @deprecated Use {@link com.google.android.exoplayer2.video.VideoListener}. */
   @Deprecated
@@ -66,26 +79,31 @@
 
   protected final Renderer[] renderers;
 
-  private final ExoPlayer player;
+  private final ExoPlayerImpl player;
   private final Handler eventHandler;
   private final ComponentListener componentListener;
   private final CopyOnWriteArraySet<com.google.android.exoplayer2.video.VideoListener>
       videoListeners;
+  private final CopyOnWriteArraySet<AudioListener> audioListeners;
   private final CopyOnWriteArraySet<TextOutput> textOutputs;
   private final CopyOnWriteArraySet<MetadataOutput> metadataOutputs;
   private final CopyOnWriteArraySet<VideoRendererEventListener> videoDebugListeners;
   private final CopyOnWriteArraySet<AudioRendererEventListener> audioDebugListeners;
+  private final BandwidthMeter bandwidthMeter;
   private final AnalyticsCollector analyticsCollector;
 
+  private final AudioFocusManager audioFocusManager;
+
   private Format videoFormat;
   private Format audioFormat;
 
   private Surface surface;
   private boolean ownsSurface;
-  @C.VideoScalingMode
-  private int videoScalingMode;
+  private @C.VideoScalingMode int videoScalingMode;
   private SurfaceHolder surfaceHolder;
   private TextureView textureView;
+  private int surfaceWidth;
+  private int surfaceHeight;
   private DecoderCounters videoDecoderCounters;
   private DecoderCounters audioDecoderCounters;
   private int audioSessionId;
@@ -93,77 +111,108 @@
   private float audioVolume;
   private MediaSource mediaSource;
   private List<Cue> currentCues;
+  private VideoFrameMetadataListener videoFrameMetadataListener;
+  private CameraMotionListener cameraMotionListener;
+  private boolean hasNotifiedFullWrongThreadWarning;
 
   /**
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
    */
   protected SimpleExoPlayer(
+      Context context,
       RenderersFactory renderersFactory,
       TrackSelector trackSelector,
       LoadControl loadControl,
-      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+      BandwidthMeter bandwidthMeter,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      Looper looper) {
     this(
+        context,
         renderersFactory,
         trackSelector,
         loadControl,
         drmSessionManager,
-        new AnalyticsCollector.Factory());
+        bandwidthMeter,
+        new AnalyticsCollector.Factory(),
+        looper);
   }
 
   /**
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
    * @param analyticsCollectorFactory A factory for creating the {@link AnalyticsCollector} that
    *     will collect and forward all player events.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
    */
   protected SimpleExoPlayer(
+      Context context,
       RenderersFactory renderersFactory,
       TrackSelector trackSelector,
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      AnalyticsCollector.Factory analyticsCollectorFactory) {
+      BandwidthMeter bandwidthMeter,
+      AnalyticsCollector.Factory analyticsCollectorFactory,
+      Looper looper) {
     this(
+        context,
         renderersFactory,
         trackSelector,
         loadControl,
         drmSessionManager,
+        bandwidthMeter,
         analyticsCollectorFactory,
-        Clock.DEFAULT);
+        Clock.DEFAULT,
+        looper);
   }
 
   /**
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
    * @param analyticsCollectorFactory A factory for creating the {@link AnalyticsCollector} that
    *     will collect and forward all player events.
    * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
    *     Clock#DEFAULT}, unless the player is being used from a test.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
    */
   protected SimpleExoPlayer(
+      Context context,
       RenderersFactory renderersFactory,
       TrackSelector trackSelector,
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      BandwidthMeter bandwidthMeter,
       AnalyticsCollector.Factory analyticsCollectorFactory,
-      Clock clock) {
+      Clock clock,
+      Looper looper) {
+    this.bandwidthMeter = bandwidthMeter;
     componentListener = new ComponentListener();
     videoListeners = new CopyOnWriteArraySet<>();
+    audioListeners = new CopyOnWriteArraySet<>();
     textOutputs = new CopyOnWriteArraySet<>();
     metadataOutputs = new CopyOnWriteArraySet<>();
     videoDebugListeners = new CopyOnWriteArraySet<>();
     audioDebugListeners = new CopyOnWriteArraySet<>();
-    Looper eventLooper = Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper();
-    eventHandler = new Handler(eventLooper);
+    eventHandler = new Handler(looper);
     renderers =
         renderersFactory.createRenderers(
             eventHandler,
@@ -181,27 +230,46 @@ protected SimpleExoPlayer(
     currentCues = Collections.emptyList();
 
     // Build the player and associated objects.
-    player = createExoPlayerImpl(renderers, trackSelector, loadControl, clock);
+    player =
+        new ExoPlayerImpl(renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
     analyticsCollector = analyticsCollectorFactory.createAnalyticsCollector(player, clock);
     addListener(analyticsCollector);
     videoDebugListeners.add(analyticsCollector);
+    videoListeners.add(analyticsCollector);
     audioDebugListeners.add(analyticsCollector);
+    audioListeners.add(analyticsCollector);
     addMetadataOutput(analyticsCollector);
+    bandwidthMeter.addEventListener(eventHandler, analyticsCollector);
     if (drmSessionManager instanceof DefaultDrmSessionManager) {
       ((DefaultDrmSessionManager) drmSessionManager).addListener(eventHandler, analyticsCollector);
     }
+    audioFocusManager = new AudioFocusManager(context, componentListener);
+  }
+
+  @Override
+  @Nullable
+  public AudioComponent getAudioComponent() {
+    return this;
   }
 
   @Override
+  @Nullable
   public VideoComponent getVideoComponent() {
     return this;
   }
 
   @Override
+  @Nullable
   public TextComponent getTextComponent() {
     return this;
   }
 
+  @Override
+  @Nullable
+  public MetadataComponent getMetadataComponent() {
+    return this;
+  }
+
   /**
    * Sets the video scaling mode.
    *
@@ -212,6 +280,7 @@ public TextComponent getTextComponent() {
    */
   @Override
   public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
+    verifyApplicationThread();
     this.videoScalingMode = videoScalingMode;
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
@@ -231,37 +300,52 @@ public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
 
   @Override
   public void clearVideoSurface() {
+    verifyApplicationThread();
     setVideoSurface(null);
   }
 
-  @Override
-  public void setVideoSurface(Surface surface) {
-    removeSurfaceCallbacks();
-    setVideoSurfaceInternal(surface, false);
-  }
-
   @Override
   public void clearVideoSurface(Surface surface) {
+    verifyApplicationThread();
     if (surface != null && surface == this.surface) {
       setVideoSurface(null);
     }
   }
 
+  @Override
+  public void setVideoSurface(@Nullable Surface surface) {
+    verifyApplicationThread();
+    removeSurfaceCallbacks();
+    setVideoSurfaceInternal(surface, false);
+    int newSurfaceSize = surface == null ? 0 : C.LENGTH_UNSET;
+    maybeNotifySurfaceSizeChanged(/* width= */ newSurfaceSize, /* height= */ newSurfaceSize);
+  }
+
   @Override
   public void setVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
+    verifyApplicationThread();
     removeSurfaceCallbacks();
     this.surfaceHolder = surfaceHolder;
     if (surfaceHolder == null) {
       setVideoSurfaceInternal(null, false);
+      maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
     } else {
       surfaceHolder.addCallback(componentListener);
       Surface surface = surfaceHolder.getSurface();
-      setVideoSurfaceInternal(surface != null && surface.isValid() ? surface : null, false);
+      if (surface != null && surface.isValid()) {
+        setVideoSurfaceInternal(surface, /* ownsSurface= */ false);
+        Rect surfaceSize = surfaceHolder.getSurfaceFrame();
+        maybeNotifySurfaceSizeChanged(surfaceSize.width(), surfaceSize.height());
+      } else {
+        setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ false);
+        maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
+      }
     }
   }
 
   @Override
   public void clearVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
+    verifyApplicationThread();
     if (surfaceHolder != null && surfaceHolder == this.surfaceHolder) {
       setVideoSurfaceHolder(null);
     }
@@ -279,10 +363,12 @@ public void clearVideoSurfaceView(SurfaceView surfaceView) {
 
   @Override
   public void setVideoTextureView(TextureView textureView) {
+    verifyApplicationThread();
     removeSurfaceCallbacks();
     this.textureView = textureView;
     if (textureView == null) {
       setVideoSurfaceInternal(null, true);
+      maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
     } else {
       if (textureView.getSurfaceTextureListener() != null) {
         Log.w(TAG, "Replacing existing SurfaceTextureListener.");
@@ -290,17 +376,113 @@ public void setVideoTextureView(TextureView textureView) {
       textureView.setSurfaceTextureListener(componentListener);
       SurfaceTexture surfaceTexture = textureView.isAvailable() ? textureView.getSurfaceTexture()
           : null;
-      setVideoSurfaceInternal(surfaceTexture == null ? null : new Surface(surfaceTexture), true);
+      if (surfaceTexture == null) {
+        setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ true);
+        maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
+      } else {
+        setVideoSurfaceInternal(new Surface(surfaceTexture), /* ownsSurface= */ true);
+        maybeNotifySurfaceSizeChanged(textureView.getWidth(), textureView.getHeight());
+      }
     }
   }
 
   @Override
   public void clearVideoTextureView(TextureView textureView) {
+    verifyApplicationThread();
     if (textureView != null && textureView == this.textureView) {
       setVideoTextureView(null);
     }
   }
 
+  @Override
+  public void addAudioListener(AudioListener listener) {
+    audioListeners.add(listener);
+  }
+
+  @Override
+  public void removeAudioListener(AudioListener listener) {
+    audioListeners.remove(listener);
+  }
+
+  @Override
+  public void setAudioAttributes(AudioAttributes audioAttributes) {
+    setAudioAttributes(audioAttributes, /* handleAudioFocus= */ false);
+  }
+
+  @Override
+  public void setAudioAttributes(AudioAttributes audioAttributes, boolean handleAudioFocus) {
+    verifyApplicationThread();
+    if (!Util.areEqual(this.audioAttributes, audioAttributes)) {
+      this.audioAttributes = audioAttributes;
+      for (Renderer renderer : renderers) {
+        if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
+          player
+              .createMessage(renderer)
+              .setType(C.MSG_SET_AUDIO_ATTRIBUTES)
+              .setPayload(audioAttributes)
+              .send();
+        }
+      }
+      for (AudioListener audioListener : audioListeners) {
+        audioListener.onAudioAttributesChanged(audioAttributes);
+      }
+    }
+
+    @AudioFocusManager.PlayerCommand
+    int playerCommand =
+        audioFocusManager.setAudioAttributes(
+            handleAudioFocus ? audioAttributes : null, getPlayWhenReady(), getPlaybackState());
+    updatePlayWhenReady(getPlayWhenReady(), playerCommand);
+  }
+
+  @Override
+  public AudioAttributes getAudioAttributes() {
+    return audioAttributes;
+  }
+
+  @Override
+  public int getAudioSessionId() {
+    return audioSessionId;
+  }
+
+  @Override
+  public void setAuxEffectInfo(AuxEffectInfo auxEffectInfo) {
+    verifyApplicationThread();
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_AUX_EFFECT_INFO)
+            .setPayload(auxEffectInfo)
+            .send();
+      }
+    }
+  }
+
+  @Override
+  public void clearAuxEffectInfo() {
+    setAuxEffectInfo(new AuxEffectInfo(AuxEffectInfo.NO_AUX_EFFECT_ID, /* sendLevel= */ 0f));
+  }
+
+  @Override
+  public void setVolume(float audioVolume) {
+    verifyApplicationThread();
+    audioVolume = Util.constrainValue(audioVolume, /* min= */ 0, /* max= */ 1);
+    if (this.audioVolume == audioVolume) {
+      return;
+    }
+    this.audioVolume = audioVolume;
+    sendVolumeToRenderers();
+    for (AudioListener audioListener : audioListeners) {
+      audioListener.onVolumeChanged(audioVolume);
+    }
+  }
+
+  @Override
+  public float getVolume() {
+    return audioVolume;
+  }
+
   /**
    * Sets the stream type for audio playback, used by the underlying audio track.
    * <p>
@@ -343,6 +525,7 @@ public AnalyticsCollector getAnalyticsCollector() {
    * @param listener The listener to be added.
    */
   public void addAnalyticsListener(AnalyticsListener listener) {
+    verifyApplicationThread();
     analyticsCollector.addListener(listener);
   }
 
@@ -352,66 +535,10 @@ public void addAnalyticsListener(AnalyticsListener listener) {
    * @param listener The listener to be removed.
    */
   public void removeAnalyticsListener(AnalyticsListener listener) {
+    verifyApplicationThread();
     analyticsCollector.removeListener(listener);
   }
 
-  /**
-   * Sets the attributes for audio playback, used by the underlying audio track. If not set, the
-   * default audio attributes will be used. They are suitable for general media playback.
-   * <p>
-   * Setting the audio attributes during playback may introduce a short gap in audio output as the
-   * audio track is recreated. A new audio session id will also be generated.
-   * <p>
-   * If tunneling is enabled by the track selector, the specified audio attributes will be ignored,
-   * but they will take effect if audio is later played without tunneling.
-   * <p>
-   * If the device is running a build before platform API version 21, audio attributes cannot be set
-   * directly on the underlying audio track. In this case, the usage will be mapped onto an
-   * equivalent stream type using {@link Util#getStreamTypeForAudioUsage(int)}.
-   *
-   * @param audioAttributes The attributes to use for audio playback.
-   */
-  public void setAudioAttributes(AudioAttributes audioAttributes) {
-    this.audioAttributes = audioAttributes;
-    for (Renderer renderer : renderers) {
-      if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
-        player
-            .createMessage(renderer)
-            .setType(C.MSG_SET_AUDIO_ATTRIBUTES)
-            .setPayload(audioAttributes)
-            .send();
-      }
-    }
-  }
-
-  /**
-   * Returns the attributes for audio playback.
-   */
-  public AudioAttributes getAudioAttributes() {
-    return audioAttributes;
-  }
-
-  /**
-   * Sets the audio volume, with 0 being silence and 1 being unity gain.
-   *
-   * @param audioVolume The audio volume.
-   */
-  public void setVolume(float audioVolume) {
-    this.audioVolume = audioVolume;
-    for (Renderer renderer : renderers) {
-      if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
-        player.createMessage(renderer).setType(C.MSG_SET_VOLUME).setPayload(audioVolume).send();
-      }
-    }
-  }
-
-  /**
-   * Returns the audio volume, with 0 being silence and 1 being unity gain.
-   */
-  public float getVolume() {
-    return audioVolume;
-  }
-
   /**
    * Sets the {@link PlaybackParams} governing audio playback.
    *
@@ -445,13 +572,6 @@ public Format getAudioFormat() {
     return audioFormat;
   }
 
-  /**
-   * Returns the audio session identifier, or {@link C#AUDIO_SESSION_ID_UNSET} if not set.
-   */
-  public int getAudioSessionId() {
-    return audioSessionId;
-  }
-
   /**
    * Returns {@link DecoderCounters} for video, or null if no video is being played.
    */
@@ -476,6 +596,70 @@ public void removeVideoListener(com.google.android.exoplayer2.video.VideoListene
     videoListeners.remove(listener);
   }
 
+  @Override
+  public void setVideoFrameMetadataListener(VideoFrameMetadataListener listener) {
+    verifyApplicationThread();
+    videoFrameMetadataListener = listener;
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_VIDEO_FRAME_METADATA_LISTENER)
+            .setPayload(listener)
+            .send();
+      }
+    }
+  }
+
+  @Override
+  public void clearVideoFrameMetadataListener(VideoFrameMetadataListener listener) {
+    verifyApplicationThread();
+    if (videoFrameMetadataListener != listener) {
+      return;
+    }
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_VIDEO_FRAME_METADATA_LISTENER)
+            .setPayload(null)
+            .send();
+      }
+    }
+  }
+
+  @Override
+  public void setCameraMotionListener(CameraMotionListener listener) {
+    verifyApplicationThread();
+    cameraMotionListener = listener;
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_CAMERA_MOTION) {
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_CAMERA_MOTION_LISTENER)
+            .setPayload(listener)
+            .send();
+      }
+    }
+  }
+
+  @Override
+  public void clearCameraMotionListener(CameraMotionListener listener) {
+    verifyApplicationThread();
+    if (cameraMotionListener != listener) {
+      return;
+    }
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_CAMERA_MOTION) {
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_CAMERA_MOTION_LISTENER)
+            .setPayload(null)
+            .send();
+      }
+    }
+  }
+
   /**
    * Sets a listener to receive video events, removing all existing listeners.
    *
@@ -483,6 +667,7 @@ public void removeVideoListener(com.google.android.exoplayer2.video.VideoListene
    * @deprecated Use {@link #addVideoListener(com.google.android.exoplayer2.video.VideoListener)}.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public void setVideoListener(VideoListener listener) {
     videoListeners.clear();
     if (listener != null) {
@@ -498,6 +683,7 @@ public void setVideoListener(VideoListener listener) {
    *     #removeVideoListener(com.google.android.exoplayer2.video.VideoListener)}.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public void clearVideoListener(VideoListener listener) {
     removeVideoListener(listener);
   }
@@ -540,20 +726,12 @@ public void clearTextOutput(TextOutput output) {
     removeTextOutput(output);
   }
 
-  /**
-   * Adds a {@link MetadataOutput} to receive metadata.
-   *
-   * @param listener The output to register.
-   */
+  @Override
   public void addMetadataOutput(MetadataOutput listener) {
     metadataOutputs.add(listener);
   }
 
-  /**
-   * Removes a {@link MetadataOutput}.
-   *
-   * @param listener The output to remove.
-   */
+  @Override
   public void removeMetadataOutput(MetadataOutput listener) {
     metadataOutputs.remove(listener);
   }
@@ -588,6 +766,7 @@ public void clearMetadataOutput(MetadataOutput output) {
    *     information.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public void setVideoDebugListener(VideoRendererEventListener listener) {
     videoDebugListeners.retainAll(Collections.singleton(analyticsCollector));
     if (listener != null) {
@@ -618,6 +797,7 @@ public void removeVideoDebugListener(VideoRendererEventListener listener) {
    *     information.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public void setAudioDebugListener(AudioRendererEventListener listener) {
     audioDebugListeners.retainAll(Collections.singleton(analyticsCollector));
     if (listener != null) {
@@ -650,26 +830,44 @@ public Looper getPlaybackLooper() {
     return player.getPlaybackLooper();
   }
 
+  @Override
+  public Looper getApplicationLooper() {
+    return player.getApplicationLooper();
+  }
+
   @Override
   public void addListener(Player.EventListener listener) {
+    verifyApplicationThread();
     player.addListener(listener);
   }
 
   @Override
   public void removeListener(Player.EventListener listener) {
+    verifyApplicationThread();
     player.removeListener(listener);
   }
 
   @Override
   public int getPlaybackState() {
+    verifyApplicationThread();
     return player.getPlaybackState();
   }
 
   @Override
-  public ExoPlaybackException getPlaybackError() {
+  public @Nullable ExoPlaybackException getPlaybackError() {
+    verifyApplicationThread();
     return player.getPlaybackError();
   }
 
+  @Override
+  public void retry() {
+    verifyApplicationThread();
+    if (mediaSource != null
+        && (getPlaybackError() != null || getPlaybackState() == Player.STATE_IDLE)) {
+      prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
+    }
+  }
+
   @Override
   public void prepare(MediaSource mediaSource) {
     prepare(mediaSource, /* resetPosition= */ true, /* resetState= */ true);
@@ -677,114 +875,112 @@ public void prepare(MediaSource mediaSource) {
 
   @Override
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-    if (this.mediaSource != mediaSource) {
-      if (this.mediaSource != null) {
-        this.mediaSource.removeEventListener(analyticsCollector);
-        analyticsCollector.resetForNewMediaSource();
-      }
-      mediaSource.addEventListener(eventHandler, analyticsCollector);
-      this.mediaSource = mediaSource;
+    verifyApplicationThread();
+    if (this.mediaSource != null) {
+      this.mediaSource.removeEventListener(analyticsCollector);
+      analyticsCollector.resetForNewMediaSource();
     }
+    this.mediaSource = mediaSource;
+    mediaSource.addEventListener(eventHandler, analyticsCollector);
+    @AudioFocusManager.PlayerCommand
+    int playerCommand = audioFocusManager.handlePrepare(getPlayWhenReady());
+    updatePlayWhenReady(getPlayWhenReady(), playerCommand);
     player.prepare(mediaSource, resetPosition, resetState);
   }
 
   @Override
   public void setPlayWhenReady(boolean playWhenReady) {
-    player.setPlayWhenReady(playWhenReady);
+    verifyApplicationThread();
+    @AudioFocusManager.PlayerCommand
+    int playerCommand = audioFocusManager.handleSetPlayWhenReady(playWhenReady, getPlaybackState());
+    updatePlayWhenReady(playWhenReady, playerCommand);
   }
 
   @Override
   public boolean getPlayWhenReady() {
+    verifyApplicationThread();
     return player.getPlayWhenReady();
   }
 
   @Override
   public @RepeatMode int getRepeatMode() {
+    verifyApplicationThread();
     return player.getRepeatMode();
   }
 
   @Override
   public void setRepeatMode(@RepeatMode int repeatMode) {
+    verifyApplicationThread();
     player.setRepeatMode(repeatMode);
   }
 
   @Override
   public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    verifyApplicationThread();
     player.setShuffleModeEnabled(shuffleModeEnabled);
   }
 
   @Override
   public boolean getShuffleModeEnabled() {
+    verifyApplicationThread();
     return player.getShuffleModeEnabled();
   }
 
   @Override
   public boolean isLoading() {
+    verifyApplicationThread();
     return player.isLoading();
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    analyticsCollector.notifySeekStarted();
-    player.seekToDefaultPosition();
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    analyticsCollector.notifySeekStarted();
-    player.seekToDefaultPosition(windowIndex);
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    analyticsCollector.notifySeekStarted();
-    player.seekTo(positionMs);
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
+    verifyApplicationThread();
     analyticsCollector.notifySeekStarted();
     player.seekTo(windowIndex, positionMs);
   }
 
   @Override
   public void setPlaybackParameters(@Nullable PlaybackParameters playbackParameters) {
+    verifyApplicationThread();
     player.setPlaybackParameters(playbackParameters);
   }
 
   @Override
   public PlaybackParameters getPlaybackParameters() {
+    verifyApplicationThread();
     return player.getPlaybackParameters();
   }
 
   @Override
   public void setSeekParameters(@Nullable SeekParameters seekParameters) {
+    verifyApplicationThread();
     player.setSeekParameters(seekParameters);
   }
 
   @Override
-  public @Nullable Object getCurrentTag() {
-    return player.getCurrentTag();
-  }
-
-  @Override
-  public void stop() {
-    stop(/* reset= */ false);
+  public SeekParameters getSeekParameters() {
+    verifyApplicationThread();
+    return player.getSeekParameters();
   }
 
   @Override
   public void stop(boolean reset) {
+    verifyApplicationThread();
     player.stop(reset);
     if (mediaSource != null) {
       mediaSource.removeEventListener(analyticsCollector);
-      mediaSource = null;
       analyticsCollector.resetForNewMediaSource();
+      if (reset) {
+        mediaSource = null;
+      }
     }
+    audioFocusManager.handleStop();
     currentCues = Collections.emptyList();
   }
 
   @Override
   public void release() {
+    audioFocusManager.handleStop();
     player.release();
     removeSurfaceCallbacks();
     if (surface != null) {
@@ -795,141 +991,136 @@ public void release() {
     }
     if (mediaSource != null) {
       mediaSource.removeEventListener(analyticsCollector);
+      mediaSource = null;
     }
+    bandwidthMeter.removeEventListener(analyticsCollector);
     currentCues = Collections.emptyList();
   }
 
   @Override
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public void sendMessages(ExoPlayerMessage... messages) {
     player.sendMessages(messages);
   }
 
   @Override
   public PlayerMessage createMessage(PlayerMessage.Target target) {
+    verifyApplicationThread();
     return player.createMessage(target);
   }
 
   @Override
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public void blockingSendMessages(ExoPlayerMessage... messages) {
     player.blockingSendMessages(messages);
   }
 
   @Override
   public int getRendererCount() {
+    verifyApplicationThread();
     return player.getRendererCount();
   }
 
   @Override
   public int getRendererType(int index) {
+    verifyApplicationThread();
     return player.getRendererType(index);
   }
 
   @Override
   public TrackGroupArray getCurrentTrackGroups() {
+    verifyApplicationThread();
     return player.getCurrentTrackGroups();
   }
 
   @Override
   public TrackSelectionArray getCurrentTrackSelections() {
+    verifyApplicationThread();
     return player.getCurrentTrackSelections();
   }
 
   @Override
   public Timeline getCurrentTimeline() {
+    verifyApplicationThread();
     return player.getCurrentTimeline();
   }
 
   @Override
-  public Object getCurrentManifest() {
+  public @Nullable Object getCurrentManifest() {
+    verifyApplicationThread();
     return player.getCurrentManifest();
   }
 
   @Override
   public int getCurrentPeriodIndex() {
+    verifyApplicationThread();
     return player.getCurrentPeriodIndex();
   }
 
   @Override
   public int getCurrentWindowIndex() {
+    verifyApplicationThread();
     return player.getCurrentWindowIndex();
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    return player.getNextWindowIndex();
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    return player.getPreviousWindowIndex();
-  }
-
   @Override
   public long getDuration() {
+    verifyApplicationThread();
     return player.getDuration();
   }
 
   @Override
   public long getCurrentPosition() {
+    verifyApplicationThread();
     return player.getCurrentPosition();
   }
 
   @Override
   public long getBufferedPosition() {
+    verifyApplicationThread();
     return player.getBufferedPosition();
   }
 
   @Override
-  public int getBufferedPercentage() {
-    return player.getBufferedPercentage();
-  }
-
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    return player.isCurrentWindowDynamic();
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    return player.isCurrentWindowSeekable();
+  public long getTotalBufferedDuration() {
+    verifyApplicationThread();
+    return player.getTotalBufferedDuration();
   }
 
   @Override
   public boolean isPlayingAd() {
+    verifyApplicationThread();
     return player.isPlayingAd();
   }
 
   @Override
   public int getCurrentAdGroupIndex() {
+    verifyApplicationThread();
     return player.getCurrentAdGroupIndex();
   }
 
   @Override
   public int getCurrentAdIndexInAdGroup() {
+    verifyApplicationThread();
     return player.getCurrentAdIndexInAdGroup();
   }
 
   @Override
   public long getContentPosition() {
+    verifyApplicationThread();
     return player.getContentPosition();
   }
 
-  // Internal methods.
-
-  /**
-   * Creates the {@link ExoPlayer} implementation used by this instance.
-   *
-   * @param renderers The {@link Renderer}s that will be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param clock The {@link Clock} that will be used by this instance.
-   * @return A new {@link ExoPlayer} instance.
-   */
-  protected ExoPlayer createExoPlayerImpl(
-      Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl, Clock clock) {
-    return new ExoPlayerImpl(renderers, trackSelector, loadControl, clock);
+  @Override
+  public long getContentBufferedPosition() {
+    verifyApplicationThread();
+    return player.getContentBufferedPosition();
   }
 
+  // Internal methods.
+
   private void removeSurfaceCallbacks() {
     if (textureView != null) {
       if (textureView.getSurfaceTextureListener() != componentListener) {
@@ -945,7 +1136,7 @@ private void removeSurfaceCallbacks() {
     }
   }
 
-  private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
+  private void setVideoSurfaceInternal(@Nullable Surface surface, boolean ownsSurface) {
     // Note: We don't turn this method into a no-op if the surface is being replaced with itself
     // so as to ensure onRenderedFirstFrame callbacks are still called in this case.
     List<PlayerMessage> messages = new ArrayList<>();
@@ -973,9 +1164,52 @@ private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
     this.ownsSurface = ownsSurface;
   }
 
-  private final class ComponentListener implements VideoRendererEventListener,
-      AudioRendererEventListener, TextOutput, MetadataOutput, SurfaceHolder.Callback,
-      TextureView.SurfaceTextureListener {
+  private void maybeNotifySurfaceSizeChanged(int width, int height) {
+    if (width != surfaceWidth || height != surfaceHeight) {
+      surfaceWidth = width;
+      surfaceHeight = height;
+      for (com.google.android.exoplayer2.video.VideoListener videoListener : videoListeners) {
+        videoListener.onSurfaceSizeChanged(width, height);
+      }
+    }
+  }
+
+  private void sendVolumeToRenderers() {
+    float scaledVolume = audioVolume * audioFocusManager.getVolumeMultiplier();
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
+        player.createMessage(renderer).setType(C.MSG_SET_VOLUME).setPayload(scaledVolume).send();
+      }
+    }
+  }
+
+  private void updatePlayWhenReady(
+      boolean playWhenReady, @AudioFocusManager.PlayerCommand int playerCommand) {
+    player.setPlayWhenReady(
+        playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY,
+        playerCommand != AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY);
+  }
+
+  private void verifyApplicationThread() {
+    if (Looper.myLooper() != getApplicationLooper()) {
+      Log.w(
+          TAG,
+          "Player is accessed on the wrong thread. See "
+              + "https://google.github.io/ExoPlayer/faqs.html#"
+              + "what-do-player-is-accessed-on-the-wrong-thread-warnings-mean",
+          hasNotifiedFullWrongThreadWarning ? null : new IllegalStateException());
+      hasNotifiedFullWrongThreadWarning = true;
+    }
+  }
+
+  private final class ComponentListener
+      implements VideoRendererEventListener,
+          AudioRendererEventListener,
+          TextOutput,
+          MetadataOutput,
+          SurfaceHolder.Callback,
+          TextureView.SurfaceTextureListener,
+          AudioFocusManager.PlayerControl {
 
     // VideoRendererEventListener implementation
 
@@ -1015,8 +1249,12 @@ public void onDroppedFrames(int count, long elapsed) {
     public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
         float pixelWidthHeightRatio) {
       for (com.google.android.exoplayer2.video.VideoListener videoListener : videoListeners) {
-        videoListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
-            pixelWidthHeightRatio);
+        // Prevent duplicate notification if a listener is both a VideoRendererEventListener and
+        // a VideoListener, as they have the same method signature.
+        if (!videoDebugListeners.contains(videoListener)) {
+          videoListener.onVideoSizeChanged(
+              width, height, unappliedRotationDegrees, pixelWidthHeightRatio);
+        }
       }
       for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
@@ -1057,7 +1295,17 @@ public void onAudioEnabled(DecoderCounters counters) {
 
     @Override
     public void onAudioSessionId(int sessionId) {
+      if (audioSessionId == sessionId) {
+        return;
+      }
       audioSessionId = sessionId;
+      for (AudioListener audioListener : audioListeners) {
+        // Prevent duplicate notification if a listener is both a AudioRendererEventListener and
+        // a AudioListener, as they have the same method signature.
+        if (!audioDebugListeners.contains(audioListener)) {
+          audioListener.onAudioSessionId(sessionId);
+        }
+      }
       for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioSessionId(sessionId);
       }
@@ -1126,12 +1374,13 @@ public void surfaceCreated(SurfaceHolder holder) {
 
     @Override
     public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
-      // Do nothing.
+      maybeNotifySurfaceSizeChanged(width, height);
     }
 
     @Override
     public void surfaceDestroyed(SurfaceHolder holder) {
       setVideoSurfaceInternal(null, false);
+      maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
     }
 
     // TextureView.SurfaceTextureListener implementation
@@ -1139,16 +1388,18 @@ public void surfaceDestroyed(SurfaceHolder holder) {
     @Override
     public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) {
       setVideoSurfaceInternal(new Surface(surfaceTexture), true);
+      maybeNotifySurfaceSizeChanged(width, height);
     }
 
     @Override
     public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture, int width, int height) {
-      // Do nothing.
+      maybeNotifySurfaceSizeChanged(width, height);
     }
 
     @Override
     public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
       setVideoSurfaceInternal(null, true);
+      maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
       return true;
     }
 
@@ -1157,6 +1408,16 @@ public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
       // Do nothing.
     }
 
-  }
+    // AudioFocusManager.PlayerControl implementation
+
+    @Override
+    public void setVolumeMultiplier(float volumeMultiplier) {
+      sendVolumeToRenderers();
+    }
 
+    @Override
+    public void executePlayerCommand(@AudioFocusManager.PlayerCommand int playerCommand) {
+      updatePlayWhenReady(getPlayWhenReady(), playerCommand);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 600fbc3014..bb7f027726 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -139,9 +139,12 @@
      */
     public boolean isSeekable;
 
-    /**
-     * Whether this window may change when the timeline is updated.
-     */
+    // TODO: Split this to better describe which parts of the window might change. For example it
+    // should be possible to individually determine whether the start and end positions of the
+    // window may change relative to the underlying periods. For an example of where it's useful to
+    // know that the end position is fixed whilst the start position may still change, see:
+    // https://github.com/google/ExoPlayer/issues/4780.
+    /** Whether this window may change when the timeline is updated. */
     public boolean isDynamic;
 
     /**
@@ -520,6 +523,11 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
         public int getIndexOfPeriod(Object uid) {
           return C.INDEX_UNSET;
         }
+
+        @Override
+        public Object getUidOfPeriod(int periodIndex) {
+          throw new IndexOutOfBoundsException();
+        }
       };
 
   /**
@@ -697,13 +705,13 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
    * Calls {@link #getPeriodPosition(Window, Period, int, long, long)} with a zero default position
    * projection.
    */
-  public final Pair<Integer, Long> getPeriodPosition(Window window, Period period, int windowIndex,
-      long windowPositionUs) {
+  public final Pair<Object, Long> getPeriodPosition(
+      Window window, Period period, int windowIndex, long windowPositionUs) {
     return getPeriodPosition(window, period, windowIndex, windowPositionUs, 0);
   }
 
   /**
-   * Converts (windowIndex, windowPositionUs) to the corresponding (periodIndex, periodPositionUs).
+   * Converts (windowIndex, windowPositionUs) to the corresponding (periodUid, periodPositionUs).
    *
    * @param window A {@link Window} that may be overwritten.
    * @param period A {@link Period} that may be overwritten.
@@ -712,12 +720,16 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
    *     start position.
    * @param defaultPositionProjectionUs If {@code windowPositionUs} is {@link C#TIME_UNSET}, the
    *     duration into the future by which the window's position should be projected.
-   * @return The corresponding (periodIndex, periodPositionUs), or null if {@code #windowPositionUs}
+   * @return The corresponding (periodUid, periodPositionUs), or null if {@code #windowPositionUs}
    *     is {@link C#TIME_UNSET}, {@code defaultPositionProjectionUs} is non-zero, and the window's
    *     position could not be projected by {@code defaultPositionProjectionUs}.
    */
-  public final Pair<Integer, Long> getPeriodPosition(Window window, Period period, int windowIndex,
-      long windowPositionUs, long defaultPositionProjectionUs) {
+  public final Pair<Object, Long> getPeriodPosition(
+      Window window,
+      Period period,
+      int windowIndex,
+      long windowPositionUs,
+      long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, getWindowCount());
     getWindow(windowIndex, window, false, defaultPositionProjectionUs);
     if (windowPositionUs == C.TIME_UNSET) {
@@ -728,13 +740,24 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
     }
     int periodIndex = window.firstPeriodIndex;
     long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;
-    long periodDurationUs = getPeriod(periodIndex, period).getDurationUs();
+    long periodDurationUs = getPeriod(periodIndex, period, /* setIds= */ true).getDurationUs();
     while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs
         && periodIndex < window.lastPeriodIndex) {
       periodPositionUs -= periodDurationUs;
-      periodDurationUs = getPeriod(++periodIndex, period).getDurationUs();
+      periodDurationUs = getPeriod(++periodIndex, period, /* setIds= */ true).getDurationUs();
     }
-    return Pair.create(periodIndex, periodPositionUs);
+    return Pair.create(period.uid, periodPositionUs);
+  }
+
+  /**
+   * Populates a {@link Period} with data for the period with the specified unique identifier.
+   *
+   * @param periodUid The unique identifier of the period.
+   * @param period The {@link Period} to populate. Must not be null.
+   * @return The populated {@link Period}, for convenience.
+   */
+  public Period getPeriodByUid(Object periodUid, Period period) {
+    return getPeriod(getIndexOfPeriod(periodUid), period, /* setIds= */ true);
   }
 
   /**
@@ -770,4 +793,11 @@ public final Period getPeriod(int periodIndex, Period period) {
    */
   public abstract int getIndexOfPeriod(Object uid);
 
+  /**
+   * Returns the unique id of the period identified by its index in the timeline.
+   *
+   * @param periodIndex The index of the period.
+   * @return The unique id of the period.
+   */
+  public abstract Object getUidOfPeriod(int periodIndex);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
index 8f4267efce..113add612a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.analytics;
 
-import android.net.NetworkInfo;
 import android.support.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
@@ -27,6 +26,8 @@
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.Timeline.Window;
 import com.google.android.exoplayer2.analytics.AnalyticsListener.EventTime;
+import com.google.android.exoplayer2.audio.AudioAttributes;
+import com.google.android.exoplayer2.audio.AudioListener;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionEventListener;
@@ -39,14 +40,17 @@
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.video.VideoListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * Data collector which is able to forward analytics events to {@link AnalyticsListener}s by
@@ -59,7 +63,9 @@
         VideoRendererEventListener,
         MediaSourceEventListener,
         BandwidthMeter.EventListener,
-        DefaultDrmSessionEventListener {
+        DefaultDrmSessionEventListener,
+        VideoListener,
+        AudioListener {
 
   /** Factory for an analytics collector. */
   public static class Factory {
@@ -94,7 +100,9 @@ public AnalyticsCollector createAnalyticsCollector(@Nullable Player player, Cloc
    * @param clock A {@link Clock} used to generate timestamps.
    */
   protected AnalyticsCollector(@Nullable Player player, Clock clock) {
-    this.player = player;
+    if (player != null) {
+      this.player = player;
+    }
     this.clock = Assertions.checkNotNull(clock);
     listeners = new CopyOnWriteArraySet<>();
     mediaPeriodQueueTracker = new MediaPeriodQueueTracker();
@@ -146,41 +154,16 @@ public final void notifySeekStarted() {
     }
   }
 
-  /**
-   * Notify analytics collector that the viewport size changed.
-   *
-   * @param width The new width of the viewport in device-independent pixels (dp).
-   * @param height The new height of the viewport in device-independent pixels (dp).
-   */
-  public final void notifyViewportSizeChanged(int width, int height) {
-    EventTime eventTime = generatePlayingMediaPeriodEventTime();
-    for (AnalyticsListener listener : listeners) {
-      listener.onViewportSizeChange(eventTime, width, height);
-    }
-  }
-
-  /**
-   * Notify analytics collector that the network type or connectivity changed.
-   *
-   * @param networkInfo The new network info, or null if no network connection exists.
-   */
-  public final void notifyNetworkTypeChanged(@Nullable NetworkInfo networkInfo) {
-    EventTime eventTime = generatePlayingMediaPeriodEventTime();
-    for (AnalyticsListener listener : listeners) {
-      listener.onNetworkTypeChanged(eventTime, networkInfo);
-    }
-  }
-
   /**
    * Resets the analytics collector for a new media source. Should be called before the player is
    * prepared with a new media source.
    */
   public final void resetForNewMediaSource() {
     // Copying the list is needed because onMediaPeriodReleased will modify the list.
-    List<WindowAndMediaPeriodId> activeMediaPeriods =
-        new ArrayList<>(mediaPeriodQueueTracker.activeMediaPeriods);
-    for (WindowAndMediaPeriodId mediaPeriod : activeMediaPeriods) {
-      onMediaPeriodReleased(mediaPeriod.windowIndex, mediaPeriod.mediaPeriodId);
+    List<MediaPeriodInfo> mediaPeriodInfos =
+        new ArrayList<>(mediaPeriodQueueTracker.mediaPeriodInfoQueue);
+    for (MediaPeriodInfo mediaPeriodInfo : mediaPeriodInfos) {
+      onMediaPeriodReleased(mediaPeriodInfo.windowIndex, mediaPeriodInfo.mediaPeriodId);
     }
   }
 
@@ -205,14 +188,6 @@ public final void onAudioEnabled(DecoderCounters counters) {
     }
   }
 
-  @Override
-  public final void onAudioSessionId(int audioSessionId) {
-    EventTime eventTime = generateReadingMediaPeriodEventTime();
-    for (AnalyticsListener listener : listeners) {
-      listener.onAudioSessionId(eventTime, audioSessionId);
-    }
-  }
-
   @Override
   public final void onAudioDecoderInitialized(
       String decoderName, long initializedTimestampMs, long initializationDurationMs) {
@@ -250,6 +225,32 @@ public final void onAudioDisabled(DecoderCounters counters) {
     }
   }
 
+  // AudioListener implementation.
+
+  @Override
+  public final void onAudioSessionId(int audioSessionId) {
+    EventTime eventTime = generateReadingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onAudioSessionId(eventTime, audioSessionId);
+    }
+  }
+
+  @Override
+  public void onAudioAttributesChanged(AudioAttributes audioAttributes) {
+    EventTime eventTime = generateReadingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onAudioAttributesChanged(eventTime, audioAttributes);
+    }
+  }
+
+  @Override
+  public void onVolumeChanged(float audioVolume) {
+    EventTime eventTime = generateReadingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onVolumeChanged(eventTime, audioVolume);
+    }
+  }
+
   // VideoRendererEventListener implementation.
 
   @Override
@@ -288,30 +289,45 @@ public final void onDroppedFrames(int count, long elapsedMs) {
   }
 
   @Override
-  public final void onVideoSizeChanged(
-      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
-    EventTime eventTime = generateReadingMediaPeriodEventTime();
+  public final void onVideoDisabled(DecoderCounters counters) {
+    // The renderers are disabled after we changed the playing media period on the playback thread
+    // but before this change is reported to the app thread.
+    EventTime eventTime = generateLastReportedPlayingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
-      listener.onVideoSizeChanged(
-          eventTime, width, height, unappliedRotationDegrees, pixelWidthHeightRatio);
+      listener.onDecoderDisabled(eventTime, C.TRACK_TYPE_VIDEO, counters);
     }
   }
 
   @Override
-  public final void onRenderedFirstFrame(Surface surface) {
+  public final void onRenderedFirstFrame(@Nullable Surface surface) {
     EventTime eventTime = generateReadingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
       listener.onRenderedFirstFrame(eventTime, surface);
     }
   }
 
+  // VideoListener implementation.
+
   @Override
-  public final void onVideoDisabled(DecoderCounters counters) {
-    // The renderers are disabled after we changed the playing media period on the playback thread
-    // but before this change is reported to the app thread.
-    EventTime eventTime = generateLastReportedPlayingMediaPeriodEventTime();
+  public final void onRenderedFirstFrame() {
+    // Do nothing. Already reported in VideoRendererEventListener.onRenderedFirstFrame.
+  }
+
+  @Override
+  public final void onVideoSizeChanged(
+      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
+    EventTime eventTime = generateReadingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
-      listener.onDecoderDisabled(eventTime, C.TRACK_TYPE_VIDEO, counters);
+      listener.onVideoSizeChanged(
+          eventTime, width, height, unappliedRotationDegrees, pixelWidthHeightRatio);
+    }
+  }
+
+  @Override
+  public void onSurfaceSizeChanged(int width, int height) {
+    EventTime eventTime = generateReadingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onSurfaceSizeChanged(eventTime, width, height);
     }
   }
 
@@ -320,7 +336,7 @@ public final void onVideoDisabled(DecoderCounters counters) {
   @Override
   public final void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId) {
     mediaPeriodQueueTracker.onMediaPeriodCreated(windowIndex, mediaPeriodId);
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onMediaPeriodCreated(eventTime);
     }
@@ -328,10 +344,11 @@ public final void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPerio
 
   @Override
   public final void onMediaPeriodReleased(int windowIndex, MediaPeriodId mediaPeriodId) {
-    mediaPeriodQueueTracker.onMediaPeriodReleased(windowIndex, mediaPeriodId);
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
-    for (AnalyticsListener listener : listeners) {
-      listener.onMediaPeriodReleased(eventTime);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
+    if (mediaPeriodQueueTracker.onMediaPeriodReleased(mediaPeriodId)) {
+      for (AnalyticsListener listener : listeners) {
+        listener.onMediaPeriodReleased(eventTime);
+      }
     }
   }
 
@@ -341,7 +358,7 @@ public final void onLoadStarted(
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
       MediaLoadData mediaLoadData) {
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onLoadStarted(eventTime, loadEventInfo, mediaLoadData);
     }
@@ -353,7 +370,7 @@ public final void onLoadCompleted(
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
       MediaLoadData mediaLoadData) {
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onLoadCompleted(eventTime, loadEventInfo, mediaLoadData);
     }
@@ -365,7 +382,7 @@ public final void onLoadCanceled(
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
       MediaLoadData mediaLoadData) {
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onLoadCanceled(eventTime, loadEventInfo, mediaLoadData);
     }
@@ -379,7 +396,7 @@ public final void onLoadError(
       MediaLoadData mediaLoadData,
       IOException error,
       boolean wasCanceled) {
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onLoadError(eventTime, loadEventInfo, mediaLoadData, error, wasCanceled);
     }
@@ -387,8 +404,8 @@ public final void onLoadError(
 
   @Override
   public final void onReadingStarted(int windowIndex, MediaPeriodId mediaPeriodId) {
-    mediaPeriodQueueTracker.onReadingStarted(windowIndex, mediaPeriodId);
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    mediaPeriodQueueTracker.onReadingStarted(mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onReadingStarted(eventTime);
     }
@@ -397,7 +414,7 @@ public final void onReadingStarted(int windowIndex, MediaPeriodId mediaPeriodId)
   @Override
   public final void onUpstreamDiscarded(
       int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onUpstreamDiscarded(eventTime, mediaLoadData);
     }
@@ -406,7 +423,7 @@ public final void onUpstreamDiscarded(
   @Override
   public final void onDownstreamFormatChanged(
       int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {
-    EventTime eventTime = generateEventTime(windowIndex, mediaPeriodId);
+    EventTime eventTime = generateMediaPeriodEventTime(windowIndex, mediaPeriodId);
     for (AnalyticsListener listener : listeners) {
       listener.onDownstreamFormatChanged(eventTime, mediaLoadData);
     }
@@ -420,7 +437,7 @@ public final void onDownstreamFormatChanged(
 
   @Override
   public final void onTimelineChanged(
-      Timeline timeline, Object manifest, @Player.TimelineChangeReason int reason) {
+      Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
     mediaPeriodQueueTracker.onTimelineChanged(timeline);
     EventTime eventTime = generatePlayingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
@@ -517,6 +534,14 @@ public final void onBandwidthSample(int elapsedMs, long bytes, long bitrate) {
 
   // DefaultDrmSessionManager.EventListener implementation.
 
+  @Override
+  public final void onDrmSessionAcquired() {
+    EventTime eventTime = generateReadingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onDrmSessionAcquired(eventTime);
+    }
+  }
+
   @Override
   public final void onDrmKeysLoaded() {
     EventTime eventTime = generateReadingMediaPeriodEventTime();
@@ -549,6 +574,14 @@ public final void onDrmKeysRemoved() {
     }
   }
 
+  @Override
+  public final void onDrmSessionReleased() {
+    EventTime eventTime = generateLastReportedPlayingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onDrmSessionReleased(eventTime);
+    }
+  }
+
   // Internal methods.
 
   /** Returns read-only set of registered listeners. */
@@ -556,35 +589,33 @@ public final void onDrmKeysRemoved() {
     return Collections.unmodifiableSet(listeners);
   }
 
-  /** Returns a new {@link EventTime} for the specified window index and media period id. */
-  protected EventTime generateEventTime(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {
-    Assertions.checkNotNull(player);
+  /** Returns a new {@link EventTime} for the specified timeline, window and media period id. */
+  @RequiresNonNull("player")
+  protected EventTime generateEventTime(
+      Timeline timeline, int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {
+    if (timeline.isEmpty()) {
+      // Ensure media period id is only reported together with a valid timeline.
+      mediaPeriodId = null;
+    }
     long realtimeMs = clock.elapsedRealtime();
-    Timeline timeline = player.getCurrentTimeline();
     long eventPositionMs;
-    if (windowIndex == player.getCurrentWindowIndex()) {
-      if (mediaPeriodId != null && mediaPeriodId.isAd()) {
-        // This event is for an ad in the currently playing window.
-        eventPositionMs =
-            player.getCurrentAdGroupIndex() == mediaPeriodId.adGroupIndex
-                    && player.getCurrentAdIndexInAdGroup() == mediaPeriodId.adIndexInAdGroup
-                ? player.getCurrentPosition()
-                : 0 /* Assume start position of 0 for a future ad. */;
-      } else {
-        // This event is for content in the currently playing window.
-        eventPositionMs = player.getContentPosition();
-      }
-    } else if (windowIndex >= timeline.getWindowCount()
-        || (mediaPeriodId != null && mediaPeriodId.isAd())) {
-      // This event is for an unknown future window or for an ad in a future window.
-      // Assume start position of zero.
-      eventPositionMs = 0;
+    boolean isInCurrentWindow =
+        timeline == player.getCurrentTimeline() && windowIndex == player.getCurrentWindowIndex();
+    if (mediaPeriodId != null && mediaPeriodId.isAd()) {
+      boolean isCurrentAd =
+          isInCurrentWindow
+              && player.getCurrentAdGroupIndex() == mediaPeriodId.adGroupIndex
+              && player.getCurrentAdIndexInAdGroup() == mediaPeriodId.adIndexInAdGroup;
+      // Assume start position of 0 for future ads.
+      eventPositionMs = isCurrentAd ? player.getCurrentPosition() : 0;
+    } else if (isInCurrentWindow) {
+      eventPositionMs = player.getContentPosition();
     } else {
-      // This event is for content in a future window. Assume default start position.
-      eventPositionMs = timeline.getWindow(windowIndex, window).getDefaultPositionMs();
+      // Assume default start position for future content windows. If timeline is not available yet,
+      // assume start position of 0.
+      eventPositionMs =
+          timeline.isEmpty() ? 0 : timeline.getWindow(windowIndex, window).getDefaultPositionMs();
     }
-    // TODO(b/30792113): implement this properly (player.getTotalBufferedDuration()).
-    long bufferedDurationMs = player.getBufferedPosition() - player.getContentPosition();
     return new EventTime(
         realtimeMs,
         timeline,
@@ -592,16 +623,23 @@ protected EventTime generateEventTime(int windowIndex, @Nullable MediaPeriodId m
         mediaPeriodId,
         eventPositionMs,
         player.getCurrentPosition(),
-        bufferedDurationMs);
+        player.getTotalBufferedDuration());
   }
 
-  private EventTime generateEventTime(@Nullable WindowAndMediaPeriodId mediaPeriod) {
-    if (mediaPeriod == null) {
-      int windowIndex = Assertions.checkNotNull(player).getCurrentWindowIndex();
-      MediaPeriodId mediaPeriodId = mediaPeriodQueueTracker.tryResolveWindowIndex(windowIndex);
-      return generateEventTime(windowIndex, mediaPeriodId);
+  private EventTime generateEventTime(@Nullable MediaPeriodInfo mediaPeriodInfo) {
+    Assertions.checkNotNull(player);
+    if (mediaPeriodInfo == null) {
+      int windowIndex = player.getCurrentWindowIndex();
+      mediaPeriodInfo = mediaPeriodQueueTracker.tryResolveWindowIndex(windowIndex);
+      if (mediaPeriodInfo == null) {
+        Timeline timeline = player.getCurrentTimeline();
+        boolean windowIsInTimeline = windowIndex < timeline.getWindowCount();
+        return generateEventTime(
+            windowIsInTimeline ? timeline : Timeline.EMPTY, windowIndex, /* mediaPeriodId= */ null);
+      }
     }
-    return generateEventTime(mediaPeriod.windowIndex, mediaPeriod.mediaPeriodId);
+    return generateEventTime(
+        mediaPeriodInfo.timeline, mediaPeriodInfo.windowIndex, mediaPeriodInfo.mediaPeriodId);
   }
 
   private EventTime generateLastReportedPlayingMediaPeriodEventTime() {
@@ -620,67 +658,89 @@ private EventTime generateLoadingMediaPeriodEventTime() {
     return generateEventTime(mediaPeriodQueueTracker.getLoadingMediaPeriod());
   }
 
+  private EventTime generateMediaPeriodEventTime(
+      int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {
+    Assertions.checkNotNull(player);
+    if (mediaPeriodId != null) {
+      MediaPeriodInfo mediaPeriodInfo = mediaPeriodQueueTracker.getMediaPeriodInfo(mediaPeriodId);
+      return mediaPeriodInfo != null
+          ? generateEventTime(mediaPeriodInfo)
+          : generateEventTime(Timeline.EMPTY, windowIndex, mediaPeriodId);
+    }
+    Timeline timeline = player.getCurrentTimeline();
+    boolean windowIsInTimeline = windowIndex < timeline.getWindowCount();
+    return generateEventTime(
+        windowIsInTimeline ? timeline : Timeline.EMPTY, windowIndex, /* mediaPeriodId= */ null);
+  }
+
   /** Keeps track of the active media periods and currently playing and reading media period. */
   private static final class MediaPeriodQueueTracker {
 
     // TODO: Investigate reporting MediaPeriodId in renderer events and adding a listener of queue
     // changes, which would hopefully remove the need to track the queue here.
 
-    private final ArrayList<WindowAndMediaPeriodId> activeMediaPeriods;
+    private final ArrayList<MediaPeriodInfo> mediaPeriodInfoQueue;
+    private final HashMap<MediaPeriodId, MediaPeriodInfo> mediaPeriodIdToInfo;
     private final Period period;
 
-    private WindowAndMediaPeriodId lastReportedPlayingMediaPeriod;
-    private WindowAndMediaPeriodId readingMediaPeriod;
+    private @Nullable MediaPeriodInfo lastReportedPlayingMediaPeriod;
+    private @Nullable MediaPeriodInfo readingMediaPeriod;
     private Timeline timeline;
     private boolean isSeeking;
 
     public MediaPeriodQueueTracker() {
-      activeMediaPeriods = new ArrayList<>();
+      mediaPeriodInfoQueue = new ArrayList<>();
+      mediaPeriodIdToInfo = new HashMap<>();
       period = new Period();
       timeline = Timeline.EMPTY;
     }
 
     /**
-     * Returns the {@link WindowAndMediaPeriodId} of the media period in the front of the queue.
-     * This is the playing media period unless the player hasn't started playing yet (in which case
-     * it is the loading media period or null). While the player is seeking or preparing, this
-     * method will always return null to reflect the uncertainty about the current playing period.
-     * May also be null, if the timeline is empty or no media period is active yet.
+     * Returns the {@link MediaPeriodInfo} of the media period in the front of the queue. This is
+     * the playing media period unless the player hasn't started playing yet (in which case it is
+     * the loading media period or null). While the player is seeking or preparing, this method will
+     * always return null to reflect the uncertainty about the current playing period. May also be
+     * null, if the timeline is empty or no media period is active yet.
      */
-    public @Nullable WindowAndMediaPeriodId getPlayingMediaPeriod() {
-      return activeMediaPeriods.isEmpty() || timeline.isEmpty() || isSeeking
+    public @Nullable MediaPeriodInfo getPlayingMediaPeriod() {
+      return mediaPeriodInfoQueue.isEmpty() || timeline.isEmpty() || isSeeking
           ? null
-          : activeMediaPeriods.get(0);
+          : mediaPeriodInfoQueue.get(0);
     }
 
     /**
-     * Returns the {@link WindowAndMediaPeriodId} of the currently playing media period. This is the
+     * Returns the {@link MediaPeriodInfo} of the currently playing media period. This is the
      * publicly reported period which should always match {@link Player#getCurrentPeriodIndex()}
      * unless the player is currently seeking or being prepared in which case the previous period is
      * reported until the seek or preparation is processed. May be null, if no media period is
      * active yet.
      */
-    public @Nullable WindowAndMediaPeriodId getLastReportedPlayingMediaPeriod() {
+    public @Nullable MediaPeriodInfo getLastReportedPlayingMediaPeriod() {
       return lastReportedPlayingMediaPeriod;
     }
 
     /**
-     * Returns the {@link WindowAndMediaPeriodId} of the media period currently being read by the
-     * player. May be null, if the player is not reading a media period.
+     * Returns the {@link MediaPeriodInfo} of the media period currently being read by the player.
+     * May be null, if the player is not reading a media period.
      */
-    public @Nullable WindowAndMediaPeriodId getReadingMediaPeriod() {
+    public @Nullable MediaPeriodInfo getReadingMediaPeriod() {
       return readingMediaPeriod;
     }
 
     /**
-     * Returns the {@link MediaPeriodId} of the media period at the end of the queue which is
+     * Returns the {@link MediaPeriodInfo} of the media period at the end of the queue which is
      * currently loading or will be the next one loading. May be null, if no media period is active
      * yet.
      */
-    public @Nullable WindowAndMediaPeriodId getLoadingMediaPeriod() {
-      return activeMediaPeriods.isEmpty()
+    public @Nullable MediaPeriodInfo getLoadingMediaPeriod() {
+      return mediaPeriodInfoQueue.isEmpty()
           ? null
-          : activeMediaPeriods.get(activeMediaPeriods.size() - 1);
+          : mediaPeriodInfoQueue.get(mediaPeriodInfoQueue.size() - 1);
+    }
+
+    /** Returns the {@link MediaPeriodInfo} for the given {@link MediaPeriodId}. */
+    public @Nullable MediaPeriodInfo getMediaPeriodInfo(MediaPeriodId mediaPeriodId) {
+      return mediaPeriodIdToInfo.get(mediaPeriodId);
     }
 
     /** Returns whether the player is currently seeking. */
@@ -689,24 +749,21 @@ public boolean isSeeking() {
     }
 
     /**
-     * Tries to find an existing media period id from the specified window index. Only returns a
-     * non-null media period id if there is a unique, unambiguous match.
+     * Tries to find an existing media period info from the specified window index. Only returns a
+     * non-null media period info if there is a unique, unambiguous match.
      */
-    public @Nullable MediaPeriodId tryResolveWindowIndex(int windowIndex) {
-      MediaPeriodId match = null;
-      if (timeline != null) {
-        int timelinePeriodCount = timeline.getPeriodCount();
-        for (int i = 0; i < activeMediaPeriods.size(); i++) {
-          WindowAndMediaPeriodId mediaPeriod = activeMediaPeriods.get(i);
-          int periodIndex = mediaPeriod.mediaPeriodId.periodIndex;
-          if (periodIndex < timelinePeriodCount
-              && timeline.getPeriod(periodIndex, period).windowIndex == windowIndex) {
-            if (match != null) {
-              // Ambiguous match.
-              return null;
-            }
-            match = mediaPeriod.mediaPeriodId;
+    public @Nullable MediaPeriodInfo tryResolveWindowIndex(int windowIndex) {
+      MediaPeriodInfo match = null;
+      for (int i = 0; i < mediaPeriodInfoQueue.size(); i++) {
+        MediaPeriodInfo info = mediaPeriodInfoQueue.get(i);
+        int periodIndex = timeline.getIndexOfPeriod(info.mediaPeriodId.periodUid);
+        if (periodIndex != C.INDEX_UNSET
+            && timeline.getPeriod(periodIndex, period).windowIndex == windowIndex) {
+          if (match != null) {
+            // Ambiguous match.
+            return null;
           }
+          match = info;
         }
       }
       return match;
@@ -719,12 +776,14 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
 
     /** Updates the queue with a reported timeline change. */
     public void onTimelineChanged(Timeline timeline) {
-      for (int i = 0; i < activeMediaPeriods.size(); i++) {
-        activeMediaPeriods.set(
-            i, updateMediaPeriodToNewTimeline(activeMediaPeriods.get(i), timeline));
+      for (int i = 0; i < mediaPeriodInfoQueue.size(); i++) {
+        MediaPeriodInfo newMediaPeriodInfo =
+            updateMediaPeriodInfoToNewTimeline(mediaPeriodInfoQueue.get(i), timeline);
+        mediaPeriodInfoQueue.set(i, newMediaPeriodInfo);
+        mediaPeriodIdToInfo.put(newMediaPeriodInfo.mediaPeriodId, newMediaPeriodInfo);
       }
       if (readingMediaPeriod != null) {
-        readingMediaPeriod = updateMediaPeriodToNewTimeline(readingMediaPeriod, timeline);
+        readingMediaPeriod = updateMediaPeriodInfoToNewTimeline(readingMediaPeriod, timeline);
       }
       this.timeline = timeline;
       updateLastReportedPlayingMediaPeriod();
@@ -743,74 +802,76 @@ public void onSeekProcessed() {
 
     /** Updates the queue with a newly created media period. */
     public void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId) {
-      activeMediaPeriods.add(new WindowAndMediaPeriodId(windowIndex, mediaPeriodId));
-      if (activeMediaPeriods.size() == 1 && !timeline.isEmpty()) {
+      boolean isInTimeline = timeline.getIndexOfPeriod(mediaPeriodId.periodUid) != C.INDEX_UNSET;
+      MediaPeriodInfo mediaPeriodInfo =
+          new MediaPeriodInfo(mediaPeriodId, isInTimeline ? timeline : Timeline.EMPTY, windowIndex);
+      mediaPeriodInfoQueue.add(mediaPeriodInfo);
+      mediaPeriodIdToInfo.put(mediaPeriodId, mediaPeriodInfo);
+      if (mediaPeriodInfoQueue.size() == 1 && !timeline.isEmpty()) {
         updateLastReportedPlayingMediaPeriod();
       }
     }
 
-    /** Updates the queue with a released media period. */
-    public void onMediaPeriodReleased(int windowIndex, MediaPeriodId mediaPeriodId) {
-      WindowAndMediaPeriodId mediaPeriod = new WindowAndMediaPeriodId(windowIndex, mediaPeriodId);
-      activeMediaPeriods.remove(mediaPeriod);
-      if (mediaPeriod.equals(readingMediaPeriod)) {
-        readingMediaPeriod = activeMediaPeriods.isEmpty() ? null : activeMediaPeriods.get(0);
+    /**
+     * Updates the queue with a released media period. Returns whether the media period was still in
+     * the queue.
+     */
+    public boolean onMediaPeriodReleased(MediaPeriodId mediaPeriodId) {
+      MediaPeriodInfo mediaPeriodInfo = mediaPeriodIdToInfo.remove(mediaPeriodId);
+      if (mediaPeriodInfo == null) {
+        // The media period has already been removed from the queue in resetForNewMediaSource().
+        return false;
+      }
+      mediaPeriodInfoQueue.remove(mediaPeriodInfo);
+      if (readingMediaPeriod != null && mediaPeriodId.equals(readingMediaPeriod.mediaPeriodId)) {
+        readingMediaPeriod = mediaPeriodInfoQueue.isEmpty() ? null : mediaPeriodInfoQueue.get(0);
       }
+      return true;
     }
 
     /** Update the queue with a change in the reading media period. */
-    public void onReadingStarted(int windowIndex, MediaPeriodId mediaPeriodId) {
-      readingMediaPeriod = new WindowAndMediaPeriodId(windowIndex, mediaPeriodId);
+    public void onReadingStarted(MediaPeriodId mediaPeriodId) {
+      readingMediaPeriod = mediaPeriodIdToInfo.get(mediaPeriodId);
     }
 
     private void updateLastReportedPlayingMediaPeriod() {
-      if (!activeMediaPeriods.isEmpty()) {
-        lastReportedPlayingMediaPeriod = activeMediaPeriods.get(0);
+      if (!mediaPeriodInfoQueue.isEmpty()) {
+        lastReportedPlayingMediaPeriod = mediaPeriodInfoQueue.get(0);
       }
     }
 
-    private WindowAndMediaPeriodId updateMediaPeriodToNewTimeline(
-        WindowAndMediaPeriodId mediaPeriod, Timeline newTimeline) {
-      if (newTimeline.isEmpty() || timeline.isEmpty()) {
-        return mediaPeriod;
-      }
-      Object uid =
-          timeline.getPeriod(mediaPeriod.mediaPeriodId.periodIndex, period, /* setIds= */ true).uid;
-      int newPeriodIndex = newTimeline.getIndexOfPeriod(uid);
+    private MediaPeriodInfo updateMediaPeriodInfoToNewTimeline(
+        MediaPeriodInfo info, Timeline newTimeline) {
+      int newPeriodIndex = newTimeline.getIndexOfPeriod(info.mediaPeriodId.periodUid);
       if (newPeriodIndex == C.INDEX_UNSET) {
-        return mediaPeriod;
+        // Media period is not yet or no longer available in the new timeline. Keep it as it is.
+        return info;
       }
       int newWindowIndex = newTimeline.getPeriod(newPeriodIndex, period).windowIndex;
-      return new WindowAndMediaPeriodId(
-          newWindowIndex, mediaPeriod.mediaPeriodId.copyWithPeriodIndex(newPeriodIndex));
+      return new MediaPeriodInfo(info.mediaPeriodId, newTimeline, newWindowIndex);
     }
   }
 
-  private static final class WindowAndMediaPeriodId {
+  /** Information about a media period and its associated timeline. */
+  private static final class MediaPeriodInfo {
 
-    public final int windowIndex;
+    /** The {@link MediaPeriodId} of the media period. */
     public final MediaPeriodId mediaPeriodId;
+    /**
+     * The {@link Timeline} in which the media period can be found. Or {@link Timeline#EMPTY} if the
+     * media period is not part of a known timeline yet.
+     */
+    public final Timeline timeline;
+    /**
+     * The window index of the media period in the timeline. If the timeline is empty, this is the
+     * prospective window index.
+     */
+    public final int windowIndex;
 
-    public WindowAndMediaPeriodId(int windowIndex, MediaPeriodId mediaPeriodId) {
-      this.windowIndex = windowIndex;
+    public MediaPeriodInfo(MediaPeriodId mediaPeriodId, Timeline timeline, int windowIndex) {
       this.mediaPeriodId = mediaPeriodId;
-    }
-
-    @Override
-    public boolean equals(@Nullable Object other) {
-      if (this == other) {
-        return true;
-      }
-      if (other == null || getClass() != other.getClass()) {
-        return false;
-      }
-      WindowAndMediaPeriodId that = (WindowAndMediaPeriodId) other;
-      return windowIndex == that.windowIndex && mediaPeriodId.equals(that.mediaPeriodId);
-    }
-
-    @Override
-    public int hashCode() {
-      return 31 * windowIndex + mediaPeriodId.hashCode();
+      this.timeline = timeline;
+      this.windowIndex = windowIndex;
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
index 48057f2bff..e5ed530268 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.analytics;
 
-import android.net.NetworkInfo;
 import android.support.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
@@ -26,6 +25,7 @@
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.Player.TimelineChangeReason;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.audio.AudioSink;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.metadata.Metadata;
@@ -41,6 +41,8 @@
  *
  * <p>All events are recorded with an {@link EventTime} specifying the elapsed real time and media
  * time at the time of the event.
+ *
+ * <p>All methods have no-op default implementations to allow selective overrides.
  */
 public interface AnalyticsListener {
 
@@ -127,7 +129,8 @@ public EventTime(
    * @param playWhenReady Whether the playback will proceed when ready.
    * @param playbackState One of the {@link Player}.STATE constants.
    */
-  void onPlayerStateChanged(EventTime eventTime, boolean playWhenReady, int playbackState);
+  default void onPlayerStateChanged(
+      EventTime eventTime, boolean playWhenReady, int playbackState) {}
 
   /**
    * Called when the timeline changed.
@@ -135,7 +138,7 @@ public EventTime(
    * @param eventTime The event time.
    * @param reason The reason for the timeline change.
    */
-  void onTimelineChanged(EventTime eventTime, @TimelineChangeReason int reason);
+  default void onTimelineChanged(EventTime eventTime, @TimelineChangeReason int reason) {}
 
   /**
    * Called when a position discontinuity occurred.
@@ -143,21 +146,21 @@ public EventTime(
    * @param eventTime The event time.
    * @param reason The reason for the position discontinuity.
    */
-  void onPositionDiscontinuity(EventTime eventTime, @DiscontinuityReason int reason);
+  default void onPositionDiscontinuity(EventTime eventTime, @DiscontinuityReason int reason) {}
 
   /**
    * Called when a seek operation started.
    *
    * @param eventTime The event time.
    */
-  void onSeekStarted(EventTime eventTime);
+  default void onSeekStarted(EventTime eventTime) {}
 
   /**
    * Called when a seek operation was processed.
    *
    * @param eventTime The event time.
    */
-  void onSeekProcessed(EventTime eventTime);
+  default void onSeekProcessed(EventTime eventTime) {}
 
   /**
    * Called when the playback parameters changed.
@@ -165,7 +168,8 @@ public EventTime(
    * @param eventTime The event time.
    * @param playbackParameters The new playback parameters.
    */
-  void onPlaybackParametersChanged(EventTime eventTime, PlaybackParameters playbackParameters);
+  default void onPlaybackParametersChanged(
+      EventTime eventTime, PlaybackParameters playbackParameters) {}
 
   /**
    * Called when the repeat mode changed.
@@ -173,7 +177,7 @@ public EventTime(
    * @param eventTime The event time.
    * @param repeatMode The new repeat mode.
    */
-  void onRepeatModeChanged(EventTime eventTime, @Player.RepeatMode int repeatMode);
+  default void onRepeatModeChanged(EventTime eventTime, @Player.RepeatMode int repeatMode) {}
 
   /**
    * Called when the shuffle mode changed.
@@ -181,7 +185,7 @@ public EventTime(
    * @param eventTime The event time.
    * @param shuffleModeEnabled Whether the shuffle mode is enabled.
    */
-  void onShuffleModeChanged(EventTime eventTime, boolean shuffleModeEnabled);
+  default void onShuffleModeChanged(EventTime eventTime, boolean shuffleModeEnabled) {}
 
   /**
    * Called when the player starts or stops loading data from a source.
@@ -189,7 +193,7 @@ public EventTime(
    * @param eventTime The event time.
    * @param isLoading Whether the player is loading.
    */
-  void onLoadingChanged(EventTime eventTime, boolean isLoading);
+  default void onLoadingChanged(EventTime eventTime, boolean isLoading) {}
 
   /**
    * Called when a fatal player error occurred.
@@ -197,7 +201,7 @@ public EventTime(
    * @param eventTime The event time.
    * @param error The error.
    */
-  void onPlayerError(EventTime eventTime, ExoPlaybackException error);
+  default void onPlayerError(EventTime eventTime, ExoPlaybackException error) {}
 
   /**
    * Called when the available or selected tracks for the renderers changed.
@@ -206,8 +210,8 @@ public EventTime(
    * @param trackGroups The available tracks. May be empty.
    * @param trackSelections The track selections for each renderer. May contain null elements.
    */
-  void onTracksChanged(
-      EventTime eventTime, TrackGroupArray trackGroups, TrackSelectionArray trackSelections);
+  default void onTracksChanged(
+      EventTime eventTime, TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {}
 
   /**
    * Called when a media source started loading data.
@@ -216,7 +220,8 @@ void onTracksChanged(
    * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
-  void onLoadStarted(EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData);
+  default void onLoadStarted(
+      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a media source completed loading data.
@@ -225,8 +230,8 @@ void onTracksChanged(
    * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
-  void onLoadCompleted(
-      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData);
+  default void onLoadCompleted(
+      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a media source canceled loading data.
@@ -235,8 +240,8 @@ void onLoadCompleted(
    * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
-  void onLoadCanceled(
-      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData);
+  default void onLoadCanceled(
+      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a media source loading error occurred. These errors are just for informational
@@ -248,12 +253,12 @@ void onLoadCanceled(
    * @param error The load error.
    * @param wasCanceled Whether the load was canceled as a result of the error.
    */
-  void onLoadError(
+  default void onLoadError(
       EventTime eventTime,
       LoadEventInfo loadEventInfo,
       MediaLoadData mediaLoadData,
       IOException error,
-      boolean wasCanceled);
+      boolean wasCanceled) {}
 
   /**
    * Called when the downstream format sent to the renderers changed.
@@ -261,7 +266,7 @@ void onLoadError(
    * @param eventTime The event time.
    * @param mediaLoadData The {@link MediaLoadData} defining the newly selected media data.
    */
-  void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLoadData);
+  default void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLoadData) {}
 
   /**
    * Called when data is removed from the back of a media buffer, typically so that it can be
@@ -270,28 +275,28 @@ void onLoadError(
    * @param eventTime The event time.
    * @param mediaLoadData The {@link MediaLoadData} defining the media being discarded.
    */
-  void onUpstreamDiscarded(EventTime eventTime, MediaLoadData mediaLoadData);
+  default void onUpstreamDiscarded(EventTime eventTime, MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a media source created a media period.
    *
    * @param eventTime The event time.
    */
-  void onMediaPeriodCreated(EventTime eventTime);
+  default void onMediaPeriodCreated(EventTime eventTime) {}
 
   /**
    * Called when a media source released a media period.
    *
    * @param eventTime The event time.
    */
-  void onMediaPeriodReleased(EventTime eventTime);
+  default void onMediaPeriodReleased(EventTime eventTime) {}
 
   /**
    * Called when the player started reading a media period.
    *
    * @param eventTime The event time.
    */
-  void onReadingStarted(EventTime eventTime);
+  default void onReadingStarted(EventTime eventTime) {}
 
   /**
    * Called when the bandwidth estimate for the current data source has been updated.
@@ -301,25 +306,19 @@ void onLoadError(
    * @param totalBytesLoaded The total bytes loaded this update is based on.
    * @param bitrateEstimate The bandwidth estimate, in bits per second.
    */
-  void onBandwidthEstimate(
-      EventTime eventTime, int totalLoadTimeMs, long totalBytesLoaded, long bitrateEstimate);
+  default void onBandwidthEstimate(
+      EventTime eventTime, int totalLoadTimeMs, long totalBytesLoaded, long bitrateEstimate) {}
 
   /**
-   * Called when the viewport size of the output surface changed.
+   * Called when the output surface size changed.
    *
    * @param eventTime The event time.
-   * @param width The width of the viewport in device-independent pixels (dp).
-   * @param height The height of the viewport in device-independent pixels (dp).
+   * @param width The surface width in pixels. May be {@link C#LENGTH_UNSET} if unknown, or 0 if the
+   *     video is not rendered onto a surface.
+   * @param height The surface height in pixels. May be {@link C#LENGTH_UNSET} if unknown, or 0 if
+   *     the video is not rendered onto a surface.
    */
-  void onViewportSizeChange(EventTime eventTime, int width, int height);
-
-  /**
-   * Called when the type of the network connection changed.
-   *
-   * @param eventTime The event time.
-   * @param networkInfo The network info for the current connection, or null if disconnected.
-   */
-  void onNetworkTypeChanged(EventTime eventTime, @Nullable NetworkInfo networkInfo);
+  default void onSurfaceSizeChanged(EventTime eventTime, int width, int height) {}
 
   /**
    * Called when there is {@link Metadata} associated with the current playback time.
@@ -327,7 +326,7 @@ void onBandwidthEstimate(
    * @param eventTime The event time.
    * @param metadata The metadata.
    */
-  void onMetadata(EventTime eventTime, Metadata metadata);
+  default void onMetadata(EventTime eventTime, Metadata metadata) {}
 
   /**
    * Called when an audio or video decoder has been enabled.
@@ -337,7 +336,8 @@ void onBandwidthEstimate(
    *     {@link C#TRACK_TYPE_VIDEO}.
    * @param decoderCounters The accumulated event counters associated with this decoder.
    */
-  void onDecoderEnabled(EventTime eventTime, int trackType, DecoderCounters decoderCounters);
+  default void onDecoderEnabled(
+      EventTime eventTime, int trackType, DecoderCounters decoderCounters) {}
 
   /**
    * Called when an audio or video decoder has been initialized.
@@ -348,8 +348,8 @@ void onBandwidthEstimate(
    * @param decoderName The decoder that was created.
    * @param initializationDurationMs Time taken to initialize the decoder, in milliseconds.
    */
-  void onDecoderInitialized(
-      EventTime eventTime, int trackType, String decoderName, long initializationDurationMs);
+  default void onDecoderInitialized(
+      EventTime eventTime, int trackType, String decoderName, long initializationDurationMs) {}
 
   /**
    * Called when an audio or video decoder input format changed.
@@ -359,7 +359,7 @@ void onDecoderInitialized(
    *     C#TRACK_TYPE_AUDIO} or {@link C#TRACK_TYPE_VIDEO}.
    * @param format The new input format for the decoder.
    */
-  void onDecoderInputFormatChanged(EventTime eventTime, int trackType, Format format);
+  default void onDecoderInputFormatChanged(EventTime eventTime, int trackType, Format format) {}
 
   /**
    * Called when an audio or video decoder has been disabled.
@@ -369,7 +369,8 @@ void onDecoderInitialized(
    *     {@link C#TRACK_TYPE_VIDEO}.
    * @param decoderCounters The accumulated event counters associated with this decoder.
    */
-  void onDecoderDisabled(EventTime eventTime, int trackType, DecoderCounters decoderCounters);
+  default void onDecoderDisabled(
+      EventTime eventTime, int trackType, DecoderCounters decoderCounters) {}
 
   /**
    * Called when the audio session id is set.
@@ -377,7 +378,23 @@ void onDecoderInitialized(
    * @param eventTime The event time.
    * @param audioSessionId The audio session id.
    */
-  void onAudioSessionId(EventTime eventTime, int audioSessionId);
+  default void onAudioSessionId(EventTime eventTime, int audioSessionId) {}
+
+  /**
+   * Called when the audio attributes change.
+   *
+   * @param eventTime The event time.
+   * @param audioAttributes The audio attributes.
+   */
+  default void onAudioAttributesChanged(EventTime eventTime, AudioAttributes audioAttributes) {}
+
+  /**
+   * Called when the volume changes.
+   *
+   * @param eventTime The event time.
+   * @param volume The new volume, with 0 being silence and 1 being unity gain.
+   */
+  default void onVolumeChanged(EventTime eventTime, float volume) {}
 
   /**
    * Called when an audio underrun occurred.
@@ -389,8 +406,8 @@ void onDecoderInitialized(
    *     as the buffered media can have a variable bitrate so the duration may be unknown.
    * @param elapsedSinceLastFeedMs The time since the {@link AudioSink} was last fed data.
    */
-  void onAudioUnderrun(
-      EventTime eventTime, int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+  default void onAudioUnderrun(
+      EventTime eventTime, int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {}
 
   /**
    * Called after video frames have been dropped.
@@ -401,7 +418,7 @@ void onAudioUnderrun(
    *     is timed from when the renderer was started or from when dropped frames were last reported
    *     (whichever was more recent), and not from when the first of the reported drops occurred.
    */
-  void onDroppedVideoFrames(EventTime eventTime, int droppedFrames, long elapsedMs);
+  default void onDroppedVideoFrames(EventTime eventTime, int droppedFrames, long elapsedMs) {}
 
   /**
    * Called before a frame is rendered for the first time since setting the surface, and each time
@@ -416,12 +433,12 @@ void onAudioUnderrun(
    *     since the renderer will apply all necessary rotations internally.
    * @param pixelWidthHeightRatio The width to height ratio of each pixel.
    */
-  void onVideoSizeChanged(
+  default void onVideoSizeChanged(
       EventTime eventTime,
       int width,
       int height,
       int unappliedRotationDegrees,
-      float pixelWidthHeightRatio);
+      float pixelWidthHeightRatio) {}
 
   /**
    * Called when a frame is rendered for the first time since setting the surface, and when a frame
@@ -431,14 +448,21 @@ void onVideoSizeChanged(
    * @param surface The {@link Surface} to which a first frame has been rendered, or {@code null} if
    *     the renderer renders to something that isn't a {@link Surface}.
    */
-  void onRenderedFirstFrame(EventTime eventTime, Surface surface);
+  default void onRenderedFirstFrame(EventTime eventTime, @Nullable Surface surface) {}
+
+  /**
+   * Called each time a drm session is acquired.
+   *
+   * @param eventTime The event time.
+   */
+  default void onDrmSessionAcquired(EventTime eventTime) {}
 
   /**
    * Called each time drm keys are loaded.
    *
    * @param eventTime The event time.
    */
-  void onDrmKeysLoaded(EventTime eventTime);
+  default void onDrmKeysLoaded(EventTime eventTime) {}
 
   /**
    * Called when a drm error occurs. These errors are just for informational purposes and the player
@@ -447,19 +471,26 @@ void onVideoSizeChanged(
    * @param eventTime The event time.
    * @param error The error.
    */
-  void onDrmSessionManagerError(EventTime eventTime, Exception error);
+  default void onDrmSessionManagerError(EventTime eventTime, Exception error) {}
 
   /**
    * Called each time offline drm keys are restored.
    *
    * @param eventTime The event time.
    */
-  void onDrmKeysRestored(EventTime eventTime);
+  default void onDrmKeysRestored(EventTime eventTime) {}
 
   /**
    * Called each time offline drm keys are removed.
    *
    * @param eventTime The event time.
    */
-  void onDrmKeysRemoved(EventTime eventTime);
+  default void onDrmKeysRemoved(EventTime eventTime) {}
+
+  /**
+   * Called each time a drm session is released.
+   *
+   * @param eventTime The event time.
+   */
+  default void onDrmSessionReleased(EventTime eventTime) {}
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/DefaultAnalyticsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/DefaultAnalyticsListener.java
index 4a49de56b0..d487a8aa99 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/DefaultAnalyticsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/DefaultAnalyticsListener.java
@@ -15,152 +15,9 @@
  */
 package com.google.android.exoplayer2.analytics;
 
-import android.net.NetworkInfo;
-import android.view.Surface;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.PlaybackParameters;
-import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.source.MediaSourceEventListener.LoadEventInfo;
-import com.google.android.exoplayer2.source.MediaSourceEventListener.MediaLoadData;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import java.io.IOException;
-
 /**
- * {@link AnalyticsListener} allowing selective overrides. All methods are implemented as no-ops.
+ * @deprecated Use {@link AnalyticsListener} directly for selective overrides as all methods are
+ *     implemented as no-op default methods.
  */
-public abstract class DefaultAnalyticsListener implements AnalyticsListener {
-
-  @Override
-  public void onPlayerStateChanged(EventTime eventTime, boolean playWhenReady, int playbackState) {}
-
-  @Override
-  public void onTimelineChanged(EventTime eventTime, int reason) {}
-
-  @Override
-  public void onPositionDiscontinuity(EventTime eventTime, int reason) {}
-
-  @Override
-  public void onSeekStarted(EventTime eventTime) {}
-
-  @Override
-  public void onSeekProcessed(EventTime eventTime) {}
-
-  @Override
-  public void onPlaybackParametersChanged(
-      EventTime eventTime, PlaybackParameters playbackParameters) {}
-
-  @Override
-  public void onRepeatModeChanged(EventTime eventTime, int repeatMode) {}
-
-  @Override
-  public void onShuffleModeChanged(EventTime eventTime, boolean shuffleModeEnabled) {}
-
-  @Override
-  public void onLoadingChanged(EventTime eventTime, boolean isLoading) {}
-
-  @Override
-  public void onPlayerError(EventTime eventTime, ExoPlaybackException error) {}
-
-  @Override
-  public void onTracksChanged(
-      EventTime eventTime, TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {}
-
-  @Override
-  public void onLoadStarted(
-      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}
-
-  @Override
-  public void onLoadCompleted(
-      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}
-
-  @Override
-  public void onLoadCanceled(
-      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}
-
-  @Override
-  public void onLoadError(
-      EventTime eventTime,
-      LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData,
-      IOException error,
-      boolean wasCanceled) {}
-
-  @Override
-  public void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLoadData) {}
-
-  @Override
-  public void onUpstreamDiscarded(EventTime eventTime, MediaLoadData mediaLoadData) {}
-
-  @Override
-  public void onMediaPeriodCreated(EventTime eventTime) {}
-
-  @Override
-  public void onMediaPeriodReleased(EventTime eventTime) {}
-
-  @Override
-  public void onReadingStarted(EventTime eventTime) {}
-
-  @Override
-  public void onBandwidthEstimate(
-      EventTime eventTime, int totalLoadTimeMs, long totalBytesLoaded, long bitrateEstimate) {}
-
-  @Override
-  public void onViewportSizeChange(EventTime eventTime, int width, int height) {}
-
-  @Override
-  public void onNetworkTypeChanged(EventTime eventTime, NetworkInfo networkInfo) {}
-
-  @Override
-  public void onMetadata(EventTime eventTime, Metadata metadata) {}
-
-  @Override
-  public void onDecoderEnabled(
-      EventTime eventTime, int trackType, DecoderCounters decoderCounters) {}
-
-  @Override
-  public void onDecoderInitialized(
-      EventTime eventTime, int trackType, String decoderName, long initializationDurationMs) {}
-
-  @Override
-  public void onDecoderInputFormatChanged(EventTime eventTime, int trackType, Format format) {}
-
-  @Override
-  public void onDecoderDisabled(
-      EventTime eventTime, int trackType, DecoderCounters decoderCounters) {}
-
-  @Override
-  public void onAudioSessionId(EventTime eventTime, int audioSessionId) {}
-
-  @Override
-  public void onAudioUnderrun(
-      EventTime eventTime, int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {}
-
-  @Override
-  public void onDroppedVideoFrames(EventTime eventTime, int droppedFrames, long elapsedMs) {}
-
-  @Override
-  public void onVideoSizeChanged(
-      EventTime eventTime,
-      int width,
-      int height,
-      int unappliedRotationDegrees,
-      float pixelWidthHeightRatio) {}
-
-  @Override
-  public void onRenderedFirstFrame(EventTime eventTime, Surface surface) {}
-
-  @Override
-  public void onDrmKeysLoaded(EventTime eventTime) {}
-
-  @Override
-  public void onDrmSessionManagerError(EventTime eventTime, Exception error) {}
-
-  @Override
-  public void onDrmKeysRestored(EventTime eventTime) {}
-
-  @Override
-  public void onDrmKeysRemoved(EventTime eventTime) {}
-}
+@Deprecated
+public abstract class DefaultAnalyticsListener implements AnalyticsListener {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index c61b8ff24c..230b96d01f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -23,17 +23,25 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
 
-/** Utility methods for parsing Dolby TrueHD and (E-)AC3 syncframes. */
+/**
+ * Utility methods for parsing Dolby TrueHD and (E-)AC-3 syncframes. (E-)AC-3 parsing follows the
+ * definition in ETSI TS 102 366 V1.2.1.
+ */
 public final class Ac3Util {
 
   /** Holds sample format information as presented by a syncframe header. */
   public static final class SyncFrameInfo {
 
-    /** AC3 stream types. See also ETSI TS 102 366 E.1.3.1.1. */
+    /**
+     * AC3 stream types. See also ETSI TS 102 366 E.1.3.1.1. One of {@link #STREAM_TYPE_UNDEFINED},
+     * {@link #STREAM_TYPE_TYPE0}, {@link #STREAM_TYPE_TYPE1} or {@link #STREAM_TYPE_TYPE2}.
+     */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({STREAM_TYPE_UNDEFINED, STREAM_TYPE_TYPE0, STREAM_TYPE_TYPE1, STREAM_TYPE_TYPE2})
     public @interface StreamType {}
@@ -137,17 +145,17 @@ private SyncFrameInfo(
       121, 139, 174, 208, 243, 278, 348, 417, 487, 557, 696, 835, 975, 1114, 1253, 1393};
 
   /**
-   * Returns the AC-3 format given {@code data} containing the AC3SpecificBox according to
-   * ETSI TS 102 366 Annex F. The reading position of {@code data} will be modified.
+   * Returns the AC-3 format given {@code data} containing the AC3SpecificBox according to ETSI TS
+   * 102 366 Annex F. The reading position of {@code data} will be modified.
    *
    * @param data The AC3SpecificBox to parse.
-   * @param trackId The track identifier to set on the format, or null.
+   * @param trackId The track identifier to set on the format.
    * @param language The language to set on the format.
    * @param drmInitData {@link DrmInitData} to be included in the format.
    * @return The AC-3 format parsed from data in the header.
    */
-  public static Format parseAc3AnnexFFormat(ParsableByteArray data, String trackId,
-      String language, DrmInitData drmInitData) {
+  public static Format parseAc3AnnexFFormat(
+      ParsableByteArray data, String trackId, String language, DrmInitData drmInitData) {
     int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
     int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     int nextByte = data.readUnsignedByte();
@@ -155,22 +163,32 @@ public static Format parseAc3AnnexFFormat(ParsableByteArray data, String trackId
     if ((nextByte & 0x04) != 0) { // lfeon
       channelCount++;
     }
-    return Format.createAudioSampleFormat(trackId, MimeTypes.AUDIO_AC3, null, Format.NO_VALUE,
-        Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0, language);
+    return Format.createAudioSampleFormat(
+        trackId,
+        MimeTypes.AUDIO_AC3,
+        /* codecs= */ null,
+        Format.NO_VALUE,
+        Format.NO_VALUE,
+        channelCount,
+        sampleRate,
+        /* initializationData= */ null,
+        drmInitData,
+        /* selectionFlags= */ 0,
+        language);
   }
 
   /**
-   * Returns the E-AC-3 format given {@code data} containing the EC3SpecificBox according to
-   * ETSI TS 102 366 Annex F. The reading position of {@code data} will be modified.
+   * Returns the E-AC-3 format given {@code data} containing the EC3SpecificBox according to ETSI TS
+   * 102 366 Annex F. The reading position of {@code data} will be modified.
    *
    * @param data The EC3SpecificBox to parse.
-   * @param trackId The track identifier to set on the format, or null.
+   * @param trackId The track identifier to set on the format.
    * @param language The language to set on the format.
    * @param drmInitData {@link DrmInitData} to be included in the format.
    * @return The E-AC-3 format parsed from data in the header.
    */
-  public static Format parseEAc3AnnexFFormat(ParsableByteArray data, String trackId,
-      String language, DrmInitData drmInitData) {
+  public static Format parseEAc3AnnexFFormat(
+      ParsableByteArray data, String trackId, String language, DrmInitData drmInitData) {
     data.skipBytes(2); // data_rate, num_ind_sub
 
     // Read the first independent substream.
@@ -200,8 +218,18 @@ public static Format parseEAc3AnnexFFormat(ParsableByteArray data, String trackI
         mimeType = MimeTypes.AUDIO_E_AC3_JOC;
       }
     }
-    return Format.createAudioSampleFormat(trackId, mimeType, null, Format.NO_VALUE,
-        Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0, language);
+    return Format.createAudioSampleFormat(
+        trackId,
+        mimeType,
+        /* codecs= */ null,
+        Format.NO_VALUE,
+        Format.NO_VALUE,
+        channelCount,
+        sampleRate,
+        /* initializationData= */ null,
+        drmInitData,
+        /* selectionFlags= */ 0,
+        language);
   }
 
   /**
@@ -214,7 +242,7 @@ public static Format parseEAc3AnnexFFormat(ParsableByteArray data, String trackI
   public static SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
     int initialPosition = data.getPosition();
     data.skipBits(40);
-    boolean isEac3 = data.readBits(5) == 16;
+    boolean isEac3 = data.readBits(5) == 16; // See bsid in subsection E.1.3.1.6.
     data.setPosition(initialPosition);
     String mimeType;
     @StreamType int streamType = SyncFrameInfo.STREAM_TYPE_UNDEFINED;
@@ -242,7 +270,7 @@ public static SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
           break;
       }
       data.skipBits(3); // substreamid
-      frameSize = (data.readBits(11) + 1) * 2;
+      frameSize = (data.readBits(11) + 1) * 2; // See frmsiz in subsection E.1.3.1.3.
       int fscod = data.readBits(2);
       int audioBlocks;
       int numblkscod;
@@ -428,18 +456,25 @@ public static SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
   }
 
   /**
-   * Returns the size in bytes of the given AC-3 syncframe.
+   * Returns the size in bytes of the given (E-)AC-3 syncframe.
    *
    * @param data The syncframe to parse.
    * @return The syncframe size in bytes. {@link C#LENGTH_UNSET} if the input is invalid.
    */
   public static int parseAc3SyncframeSize(byte[] data) {
-    if (data.length < 5) {
+    if (data.length < 6) {
       return C.LENGTH_UNSET;
     }
-    int fscod = (data[4] & 0xC0) >> 6;
-    int frmsizecod = data[4] & 0x3F;
-    return getAc3SyncframeSize(fscod, frmsizecod);
+    boolean isEac3 = ((data[5] & 0xFF) >> 3) == 16; // See bsid in subsection E.1.3.1.6.
+    if (isEac3) {
+      int frmsiz = (data[2] & 0x07) << 8; // Most significant 3 bits.
+      frmsiz |= data[3] & 0xFF; // Least significant 8 bits.
+      return (frmsiz + 1) * 2; // See frmsiz in subsection E.1.3.1.3.
+    } else {
+      int fscod = (data[4] & 0xC0) >> 6;
+      int frmsizecod = data[4] & 0x3F;
+      return getAc3SyncframeSize(fscod, frmsizecod);
+    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
index 5e963a2540..848b3ee10c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
@@ -39,12 +39,9 @@
    */
   public static final class Builder {
 
-    @C.AudioContentType
-    private int contentType;
-    @C.AudioFlags
-    private int flags;
-    @C.AudioUsage
-    private int usage;
+    private @C.AudioContentType int contentType;
+    private @C.AudioFlags int flags;
+    private @C.AudioUsage int usage;
 
     /**
      * Creates a new builder for {@link AudioAttributes}.
@@ -91,14 +88,11 @@ public AudioAttributes build() {
 
   }
 
-  @C.AudioContentType
-  public final int contentType;
-  @C.AudioFlags
-  public final int flags;
-  @C.AudioUsage
-  public final int usage;
+  public final @C.AudioContentType int contentType;
+  public final @C.AudioFlags int flags;
+  public final @C.AudioUsage int usage;
 
-  private android.media.AudioAttributes audioAttributesV21;
+  private @Nullable android.media.AudioAttributes audioAttributesV21;
 
   private AudioAttributes(@C.AudioContentType int contentType, @C.AudioFlags int flags,
       @C.AudioUsage int usage) {
@@ -108,7 +102,7 @@ private AudioAttributes(@C.AudioContentType int contentType, @C.AudioFlags int f
   }
 
   @TargetApi(21)
-  /* package */ android.media.AudioAttributes getAudioAttributesV21() {
+  public android.media.AudioAttributes getAudioAttributesV21() {
     if (audioAttributesV21 == null) {
       audioAttributesV21 = new android.media.AudioAttributes.Builder()
           .setContentType(contentType)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
index 4b03a5047b..6a5e58ef2a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
@@ -25,17 +25,15 @@
 import android.support.annotation.Nullable;
 import java.util.Arrays;
 
-/**
- * Represents the set of audio formats that a device is capable of playing.
- */
+/** Represents the set of audio formats that a device is capable of playing. */
 @TargetApi(21)
 public final class AudioCapabilities {
 
-  /**
-   * The minimum audio capabilities supported by all devices.
-   */
+  private static final int DEFAULT_MAX_CHANNEL_COUNT = 8;
+
+  /** The minimum audio capabilities supported by all devices. */
   public static final AudioCapabilities DEFAULT_AUDIO_CAPABILITIES =
-      new AudioCapabilities(new int[] {AudioFormat.ENCODING_PCM_16BIT}, 2);
+      new AudioCapabilities(new int[] {AudioFormat.ENCODING_PCM_16BIT}, DEFAULT_MAX_CHANNEL_COUNT);
 
   /**
    * Returns the current audio capabilities for the device.
@@ -50,12 +48,14 @@ public static AudioCapabilities getCapabilities(Context context) {
   }
 
   @SuppressLint("InlinedApi")
-  /* package */ static AudioCapabilities getCapabilities(Intent intent) {
+  /* package */ static AudioCapabilities getCapabilities(@Nullable Intent intent) {
     if (intent == null || intent.getIntExtra(AudioManager.EXTRA_AUDIO_PLUG_STATE, 0) == 0) {
       return DEFAULT_AUDIO_CAPABILITIES;
     }
-    return new AudioCapabilities(intent.getIntArrayExtra(AudioManager.EXTRA_ENCODINGS),
-        intent.getIntExtra(AudioManager.EXTRA_MAX_CHANNEL_COUNT, 0));
+    return new AudioCapabilities(
+        intent.getIntArrayExtra(AudioManager.EXTRA_ENCODINGS),
+        intent.getIntExtra(
+            AudioManager.EXTRA_MAX_CHANNEL_COUNT, /* defaultValue= */ DEFAULT_MAX_CHANNEL_COUNT));
   }
 
   private final int[] supportedEncodings;
@@ -65,11 +65,15 @@ public static AudioCapabilities getCapabilities(Context context) {
    * Constructs new audio capabilities based on a set of supported encodings and a maximum channel
    * count.
    *
+   * <p>Applications should generally call {@link #getCapabilities(Context)} to obtain an instance
+   * based on the capabilities advertised by the platform, rather than calling this constructor.
+   *
    * @param supportedEncodings Supported audio encodings from {@link android.media.AudioFormat}'s
-   *     {@code ENCODING_*} constants.
+   *     {@code ENCODING_*} constants. Passing {@code null} indicates that no encodings are
+   *     supported.
    * @param maxChannelCount The maximum number of audio channels that can be played simultaneously.
    */
-  /* package */ AudioCapabilities(int[] supportedEncodings, int maxChannelCount) {
+  public AudioCapabilities(@Nullable int[] supportedEncodings, int maxChannelCount) {
     if (supportedEncodings != null) {
       this.supportedEncodings = Arrays.copyOf(supportedEncodings, supportedEncodings.length);
       Arrays.sort(this.supportedEncodings);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java
index 49ec96e3d6..aa610db8b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java
@@ -20,6 +20,8 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.media.AudioManager;
+import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
@@ -44,17 +46,29 @@
   }
 
   private final Context context;
+  private final @Nullable Handler handler;
   private final Listener listener;
-  private final BroadcastReceiver receiver;
+  private final @Nullable BroadcastReceiver receiver;
 
-  /* package */ AudioCapabilities audioCapabilities;
+  /* package */ @Nullable AudioCapabilities audioCapabilities;
 
   /**
    * @param context A context for registering the receiver.
    * @param listener The listener to notify when audio capabilities change.
    */
   public AudioCapabilitiesReceiver(Context context, Listener listener) {
+    this(context, /* handler= */ null, listener);
+  }
+
+  /**
+   * @param context A context for registering the receiver.
+   * @param handler The handler to which {@link Listener} events will be posted. If null, listener
+   *     methods are invoked on the main thread.
+   * @param listener The listener to notify when audio capabilities change.
+   */
+  public AudioCapabilitiesReceiver(Context context, @Nullable Handler handler, Listener listener) {
     this.context = Assertions.checkNotNull(context);
+    this.handler = handler;
     this.listener = Assertions.checkNotNull(listener);
     this.receiver = Util.SDK_INT >= 21 ? new HdmiAudioPlugBroadcastReceiver() : null;
   }
@@ -68,8 +82,17 @@ public AudioCapabilitiesReceiver(Context context, Listener listener) {
    */
   @SuppressWarnings("InlinedApi")
   public AudioCapabilities register() {
-    Intent stickyIntent = receiver == null ? null
-        : context.registerReceiver(receiver, new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG));
+    Intent stickyIntent = null;
+    if (receiver != null) {
+      IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG);
+      if (handler != null) {
+        stickyIntent =
+            context.registerReceiver(
+                receiver, intentFilter, /* broadcastPermission= */ null, handler);
+      } else {
+        stickyIntent = context.registerReceiver(receiver, intentFilter);
+      }
+    }
     audioCapabilities = AudioCapabilities.getCapabilities(stickyIntent);
     return audioCapabilities;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
new file mode 100644
index 0000000000..7146426a4a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
@@ -0,0 +1,457 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import android.content.Context;
+import android.media.AudioFocusRequest;
+import android.media.AudioManager;
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+/** Manages requesting and responding to changes in audio focus. */
+public final class AudioFocusManager {
+
+  /** Interface to allow AudioFocusManager to give commands to a player. */
+  public interface PlayerControl {
+    /**
+     * Called when the volume multiplier on the player should be changed.
+     *
+     * @param volumeMultiplier The new volume multiplier.
+     */
+    void setVolumeMultiplier(float volumeMultiplier);
+
+    /**
+     * Called when a command must be executed on the player.
+     *
+     * @param playerCommand The command that must be executed.
+     */
+    void executePlayerCommand(@PlayerCommand int playerCommand);
+  }
+
+  /**
+   * Player commands. One of {@link #PLAYER_COMMAND_DO_NOT_PLAY}, {@link
+   * #PLAYER_COMMAND_WAIT_FOR_CALLBACK} or {@link #PLAYER_COMMAND_PLAY_WHEN_READY}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    PLAYER_COMMAND_DO_NOT_PLAY,
+    PLAYER_COMMAND_WAIT_FOR_CALLBACK,
+    PLAYER_COMMAND_PLAY_WHEN_READY,
+  })
+  public @interface PlayerCommand {}
+  /** Do not play. */
+  public static final int PLAYER_COMMAND_DO_NOT_PLAY = -1;
+  /** Do not play now. Wait for callback to play. */
+  public static final int PLAYER_COMMAND_WAIT_FOR_CALLBACK = 0;
+  /** Play freely. */
+  public static final int PLAYER_COMMAND_PLAY_WHEN_READY = 1;
+
+  /** Audio focus state. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    AUDIO_FOCUS_STATE_LOST_FOCUS,
+    AUDIO_FOCUS_STATE_NO_FOCUS,
+    AUDIO_FOCUS_STATE_HAVE_FOCUS,
+    AUDIO_FOCUS_STATE_LOSS_TRANSIENT,
+    AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
+  })
+  private @interface AudioFocusState {}
+  /** No audio focus was held, but has been lost by another app taking it permanently. */
+  private static final int AUDIO_FOCUS_STATE_LOST_FOCUS = -1;
+  /** No audio focus is currently being held. */
+  private static final int AUDIO_FOCUS_STATE_NO_FOCUS = 0;
+  /** The requested audio focus is currently held. */
+  private static final int AUDIO_FOCUS_STATE_HAVE_FOCUS = 1;
+  /** Audio focus has been temporarily lost. */
+  private static final int AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 2;
+  /** Audio focus has been temporarily lost, but playback may continue with reduced volume. */
+  private static final int AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK = 3;
+
+  private static final String TAG = "AudioFocusManager";
+
+  private static final float VOLUME_MULTIPLIER_DUCK = 0.2f;
+  private static final float VOLUME_MULTIPLIER_DEFAULT = 1.0f;
+
+  private final @Nullable AudioManager audioManager;
+  private final AudioFocusListener focusListener;
+  private final PlayerControl playerControl;
+  private @Nullable AudioAttributes audioAttributes;
+
+  private @AudioFocusState int audioFocusState;
+  private int focusGain;
+  private float volumeMultiplier = 1.0f;
+
+  private @MonotonicNonNull AudioFocusRequest audioFocusRequest;
+  private boolean rebuildAudioFocusRequest;
+
+  /**
+   * Constructs an AudioFocusManager to automatically handle audio focus for a player.
+   *
+   * @param context The current context.
+   * @param playerControl A {@link PlayerControl} to handle commands from this instance.
+   */
+  public AudioFocusManager(@Nullable Context context, PlayerControl playerControl) {
+    this.audioManager =
+        context == null
+            ? null
+            : (AudioManager)
+                context.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+    this.playerControl = playerControl;
+    this.focusListener = new AudioFocusListener();
+    this.audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
+  }
+
+  /** Gets the current player volume multiplier. */
+  public float getVolumeMultiplier() {
+    return volumeMultiplier;
+  }
+
+  /**
+   * Sets audio attributes that should be used to manage audio focus.
+   *
+   * @param audioAttributes The audio attributes or {@code null} if audio focus should not be
+   *     managed automatically.
+   * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
+   * @param playerState The current player state; {@link ExoPlayer#getPlaybackState()}.
+   * @return A {@link PlayerCommand} to execute on the player.
+   */
+  public @PlayerCommand int setAudioAttributes(
+      @Nullable AudioAttributes audioAttributes, boolean playWhenReady, int playerState) {
+    if (this.audioAttributes == null && audioAttributes == null) {
+      return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
+    }
+
+    Assertions.checkNotNull(
+        audioManager, "SimpleExoPlayer must be created with a context to handle audio focus.");
+    if (!Util.areEqual(this.audioAttributes, audioAttributes)) {
+      this.audioAttributes = audioAttributes;
+      focusGain = convertAudioAttributesToFocusGain(audioAttributes);
+
+      Assertions.checkArgument(
+          focusGain == C.AUDIOFOCUS_GAIN || focusGain == C.AUDIOFOCUS_NONE,
+          "Automatic handling of audio focus is only available for USAGE_MEDIA and USAGE_GAME.");
+      if (playWhenReady
+          && (playerState == Player.STATE_BUFFERING || playerState == Player.STATE_READY)) {
+        return requestAudioFocus();
+      }
+    }
+
+    return playerState == Player.STATE_IDLE
+        ? handleIdle(playWhenReady)
+        : handlePrepare(playWhenReady);
+  }
+
+  /**
+   * Called by a player as part of {@link ExoPlayer#prepare(MediaSource, boolean, boolean)}.
+   *
+   * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
+   * @return A {@link PlayerCommand} to execute on the player.
+   */
+  public @PlayerCommand int handlePrepare(boolean playWhenReady) {
+    if (audioManager == null) {
+      return PLAYER_COMMAND_PLAY_WHEN_READY;
+    }
+
+    return playWhenReady ? requestAudioFocus() : PLAYER_COMMAND_DO_NOT_PLAY;
+  }
+
+  /**
+   * Called by the player as part of {@link ExoPlayer#setPlayWhenReady(boolean)}.
+   *
+   * @param playWhenReady The desired value of playWhenReady.
+   * @param playerState The current state of the player.
+   * @return A {@link PlayerCommand} to execute on the player.
+   */
+  public @PlayerCommand int handleSetPlayWhenReady(boolean playWhenReady, int playerState) {
+    if (audioManager == null) {
+      return PLAYER_COMMAND_PLAY_WHEN_READY;
+    }
+
+    if (!playWhenReady) {
+      abandonAudioFocus();
+      return PLAYER_COMMAND_DO_NOT_PLAY;
+    }
+
+    return playerState == Player.STATE_IDLE ? handleIdle(playWhenReady) : requestAudioFocus();
+  }
+
+  /** Called by the player as part of {@link ExoPlayer#stop(boolean)}. */
+  public void handleStop() {
+    if (audioManager == null) {
+      return;
+    }
+
+    abandonAudioFocus(/* forceAbandon= */ true);
+  }
+
+  // Internal methods.
+
+  @PlayerCommand
+  private int handleIdle(boolean playWhenReady) {
+    return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
+  }
+
+  private @PlayerCommand int requestAudioFocus() {
+    int focusRequestResult;
+
+    if (focusGain == C.AUDIOFOCUS_NONE) {
+      if (audioFocusState != AUDIO_FOCUS_STATE_NO_FOCUS) {
+        abandonAudioFocus(/* forceAbandon= */ true);
+      }
+      return PLAYER_COMMAND_PLAY_WHEN_READY;
+    }
+
+    if (audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
+      if (Util.SDK_INT >= 26) {
+        focusRequestResult = requestAudioFocusV26();
+      } else {
+        focusRequestResult = requestAudioFocusDefault();
+      }
+      audioFocusState =
+          focusRequestResult == AudioManager.AUDIOFOCUS_REQUEST_GRANTED
+              ? AUDIO_FOCUS_STATE_HAVE_FOCUS
+              : AUDIO_FOCUS_STATE_NO_FOCUS;
+    }
+
+    if (audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
+      return PLAYER_COMMAND_DO_NOT_PLAY;
+    }
+
+    return audioFocusState == AUDIO_FOCUS_STATE_LOSS_TRANSIENT
+        ? PLAYER_COMMAND_WAIT_FOR_CALLBACK
+        : PLAYER_COMMAND_PLAY_WHEN_READY;
+  }
+
+  private void abandonAudioFocus() {
+    abandonAudioFocus(/* forceAbandon= */ false);
+  }
+
+  private void abandonAudioFocus(boolean forceAbandon) {
+    if (focusGain == C.AUDIOFOCUS_NONE && audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
+      return;
+    }
+
+    if (focusGain != C.AUDIOFOCUS_GAIN
+        || audioFocusState == AUDIO_FOCUS_STATE_LOST_FOCUS
+        || forceAbandon) {
+      if (Util.SDK_INT >= 26) {
+        abandonAudioFocusV26();
+      } else {
+        abandonAudioFocusDefault();
+      }
+      audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
+    }
+  }
+
+  private int requestAudioFocusDefault() {
+    AudioManager audioManager = Assertions.checkNotNull(this.audioManager);
+    return audioManager.requestAudioFocus(
+        focusListener,
+        Util.getStreamTypeForAudioUsage(Assertions.checkNotNull(audioAttributes).usage),
+        focusGain);
+  }
+
+  @RequiresApi(26)
+  private int requestAudioFocusV26() {
+    if (audioFocusRequest == null || rebuildAudioFocusRequest) {
+      AudioFocusRequest.Builder builder =
+          audioFocusRequest == null
+              ? new AudioFocusRequest.Builder(focusGain)
+              : new AudioFocusRequest.Builder(audioFocusRequest);
+
+      boolean willPauseWhenDucked = willPauseWhenDucked();
+      audioFocusRequest =
+          builder
+              .setAudioAttributes(Assertions.checkNotNull(audioAttributes).getAudioAttributesV21())
+              .setWillPauseWhenDucked(willPauseWhenDucked)
+              .setOnAudioFocusChangeListener(focusListener)
+              .build();
+
+      rebuildAudioFocusRequest = false;
+    }
+    return Assertions.checkNotNull(audioManager).requestAudioFocus(audioFocusRequest);
+  }
+
+  private void abandonAudioFocusDefault() {
+    Assertions.checkNotNull(audioManager).abandonAudioFocus(focusListener);
+  }
+
+  @RequiresApi(26)
+  private void abandonAudioFocusV26() {
+    if (audioFocusRequest != null) {
+      Assertions.checkNotNull(audioManager).abandonAudioFocusRequest(audioFocusRequest);
+    }
+  }
+
+  private boolean willPauseWhenDucked() {
+    return audioAttributes != null && audioAttributes.contentType == C.CONTENT_TYPE_SPEECH;
+  }
+
+  /**
+   * Converts {@link AudioAttributes} to one of the audio focus request.
+   *
+   * <p>This follows the class Javadoc of {@link AudioFocusRequest}.
+   *
+   * @param audioAttributes The audio attributes associated with this focus request.
+   * @return The type of audio focus gain that should be requested.
+   */
+  private static int convertAudioAttributesToFocusGain(@Nullable AudioAttributes audioAttributes) {
+
+    if (audioAttributes == null) {
+      // Don't handle audio focus. It may be either video only contents or developers
+      // want to have more finer grained control. (e.g. adding audio focus listener)
+      return C.AUDIOFOCUS_NONE;
+    }
+
+    switch (audioAttributes.usage) {
+        // USAGE_VOICE_COMMUNICATION_SIGNALLING is for DTMF that may happen multiple times
+        // during the phone call when AUDIOFOCUS_GAIN_TRANSIENT is requested for that.
+        // Don't request audio focus here.
+      case C.USAGE_VOICE_COMMUNICATION_SIGNALLING:
+        return C.AUDIOFOCUS_NONE;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN: Examples of uses of this focus gain are for music
+        // playback, for a game or a video player'
+      case C.USAGE_GAME:
+      case C.USAGE_MEDIA:
+        return C.AUDIOFOCUS_GAIN;
+
+        // Special usages: USAGE_UNKNOWN shouldn't be used. Request audio focus to prevent
+        // multiple media playback happen at the same time.
+      case C.USAGE_UNKNOWN:
+        Log.w(
+            TAG,
+            "Specify a proper usage in the audio attributes for audio focus"
+                + " handling. Using AUDIOFOCUS_GAIN by default.");
+        return C.AUDIOFOCUS_GAIN;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN_TRANSIENT: An example is for playing an alarm, or
+        // during a VoIP call'
+      case C.USAGE_ALARM:
+      case C.USAGE_VOICE_COMMUNICATION:
+        return C.AUDIOFOCUS_GAIN_TRANSIENT;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK: Examples are when playing
+        // driving directions or notifications'
+      case C.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
+      case C.USAGE_ASSISTANCE_SONIFICATION:
+      case C.USAGE_NOTIFICATION:
+      case C.USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
+      case C.USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
+      case C.USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
+      case C.USAGE_NOTIFICATION_EVENT:
+      case C.USAGE_NOTIFICATION_RINGTONE:
+        return C.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN_EXCLUSIVE: This is typically used if you are doing
+        // audio recording or speech recognition'.
+        // Assistant is considered as both recording and notifying developer
+      case C.USAGE_ASSISTANT:
+        if (Util.SDK_INT >= 19) {
+          return C.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
+        } else {
+          return C.AUDIOFOCUS_GAIN_TRANSIENT;
+        }
+
+        // Special usages:
+      case C.USAGE_ASSISTANCE_ACCESSIBILITY:
+        if (audioAttributes.contentType == C.CONTENT_TYPE_SPEECH) {
+          // Voice shouldn't be interrupted by other playback.
+          return C.AUDIOFOCUS_GAIN_TRANSIENT;
+        }
+        return C.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+      default:
+        Log.w(TAG, "Unidentified audio usage: " + audioAttributes.usage);
+        return C.AUDIOFOCUS_NONE;
+    }
+  }
+
+  // Internal audio focus listener.
+
+  private class AudioFocusListener implements AudioManager.OnAudioFocusChangeListener {
+    @Override
+    public void onAudioFocusChange(int focusChange) {
+      // Convert the platform focus change to internal state.
+      switch (focusChange) {
+        case AudioManager.AUDIOFOCUS_LOSS:
+          audioFocusState = AUDIO_FOCUS_STATE_LOST_FOCUS;
+          break;
+        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+          audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
+          break;
+        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
+          if (willPauseWhenDucked()) {
+            audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
+          } else {
+            audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK;
+          }
+          break;
+        case AudioManager.AUDIOFOCUS_GAIN:
+          audioFocusState = AUDIO_FOCUS_STATE_HAVE_FOCUS;
+          break;
+        default:
+          Log.w(TAG, "Unknown focus change type: " + focusChange);
+          // Early return.
+          return;
+      }
+
+      // Handle the internal state (change).
+      switch (audioFocusState) {
+        case AUDIO_FOCUS_STATE_NO_FOCUS:
+          // Focus was not requested; nothing to do.
+          break;
+        case AUDIO_FOCUS_STATE_LOST_FOCUS:
+          playerControl.executePlayerCommand(PLAYER_COMMAND_DO_NOT_PLAY);
+          abandonAudioFocus(/* forceAbandon= */ true);
+          break;
+        case AUDIO_FOCUS_STATE_LOSS_TRANSIENT:
+          playerControl.executePlayerCommand(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
+          break;
+        case AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK:
+          // Volume will be adjusted by the code below.
+          break;
+        case AUDIO_FOCUS_STATE_HAVE_FOCUS:
+          playerControl.executePlayerCommand(PLAYER_COMMAND_PLAY_WHEN_READY);
+          break;
+        default:
+          throw new IllegalStateException("Unknown audio focus state: " + audioFocusState);
+      }
+
+      float volumeMultiplier =
+          (audioFocusState == AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK)
+              ? AudioFocusManager.VOLUME_MULTIPLIER_DUCK
+              : AudioFocusManager.VOLUME_MULTIPLIER_DEFAULT;
+      if (AudioFocusManager.this.volumeMultiplier != volumeMultiplier) {
+        AudioFocusManager.this.volumeMultiplier = volumeMultiplier;
+        playerControl.setVolumeMultiplier(volumeMultiplier);
+      }
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioListener.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioListener.java
new file mode 100644
index 0000000000..8ce365b283
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioListener.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+/** A listener for changes in audio configuration. */
+public interface AudioListener {
+
+  /**
+   * Called when the audio session is set.
+   *
+   * @param audioSessionId The audio session id.
+   */
+  default void onAudioSessionId(int audioSessionId) {}
+
+  /**
+   * Called when the audio attributes change.
+   *
+   * @param audioAttributes The audio attributes.
+   */
+  default void onAudioAttributesChanged(AudioAttributes audioAttributes) {}
+
+  /**
+   * Called when the volume changes.
+   *
+   * @param volume The new volume, with 0 being silence and 1 being unity gain.
+   */
+  default void onVolumeChanged(float volume) {}
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
index 7a4958a61a..eff7bc8de2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
@@ -25,7 +25,8 @@
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
- * Listener of audio {@link Renderer} events.
+ * Listener of audio {@link Renderer} events. All methods have no-op default implementations to
+ * allow selective overrides.
  */
 public interface AudioRendererEventListener {
 
@@ -35,14 +36,14 @@
    * @param counters {@link DecoderCounters} that will be updated by the renderer for as long as it
    *     remains enabled.
    */
-  void onAudioEnabled(DecoderCounters counters);
+  default void onAudioEnabled(DecoderCounters counters) {}
 
   /**
    * Called when the audio session is set.
    *
    * @param audioSessionId The audio session id.
    */
-  void onAudioSessionId(int audioSessionId);
+  default void onAudioSessionId(int audioSessionId) {}
 
   /**
    * Called when a decoder is created.
@@ -52,15 +53,15 @@
    *     finished.
    * @param initializationDurationMs The time taken to initialize the decoder in milliseconds.
    */
-  void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
-      long initializationDurationMs);
+  default void onAudioDecoderInitialized(
+      String decoderName, long initializedTimestampMs, long initializationDurationMs) {}
 
   /**
    * Called when the format of the media being consumed by the renderer changes.
    *
    * @param format The new format.
    */
-  void onAudioInputFormatChanged(Format format);
+  default void onAudioInputFormatChanged(Format format) {}
 
   /**
    * Called when an {@link AudioSink} underrun occurs.
@@ -71,14 +72,15 @@ void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
    *     as the buffered media can have a variable bitrate so the duration may be unknown.
    * @param elapsedSinceLastFeedMs The time since the {@link AudioSink} was last fed data.
    */
-  void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+  default void onAudioSinkUnderrun(
+      int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {}
 
   /**
    * Called when the renderer is disabled.
    *
    * @param counters {@link DecoderCounters} that were updated by the renderer.
    */
-  void onAudioDisabled(DecoderCounters counters);
+  default void onAudioDisabled(DecoderCounters counters) {}
 
   /**
    * Dispatches events to a {@link AudioRendererEventListener}.
@@ -104,12 +106,7 @@ public EventDispatcher(@Nullable Handler handler,
      */
     public void enabled(final DecoderCounters decoderCounters) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onAudioEnabled(decoderCounters);
-          }
-        });
+        handler.post(() -> listener.onAudioEnabled(decoderCounters));
       }
     }
 
@@ -119,13 +116,10 @@ public void run() {
     public void decoderInitialized(final String decoderName,
         final long initializedTimestampMs, final long initializationDurationMs) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onAudioDecoderInitialized(decoderName, initializedTimestampMs,
-                initializationDurationMs);
-          }
-        });
+        handler.post(
+            () ->
+                listener.onAudioDecoderInitialized(
+                    decoderName, initializedTimestampMs, initializationDurationMs));
       }
     }
 
@@ -134,12 +128,7 @@ public void run() {
      */
     public void inputFormatChanged(final Format format) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onAudioInputFormatChanged(format);
-          }
-        });
+        handler.post(() -> listener.onAudioInputFormatChanged(format));
       }
     }
 
@@ -149,12 +138,8 @@ public void run() {
     public void audioTrackUnderrun(final int bufferSize, final long bufferSizeMs,
         final long elapsedSinceLastFeedMs) {
       if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
-          }
-        });
+        handler.post(
+            () -> listener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs));
       }
     }
 
@@ -163,13 +148,11 @@ public void run() {
      */
     public void disabled(final DecoderCounters counters) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            counters.ensureUpdated();
-            listener.onAudioDisabled(counters);
-          }
-        });
+        handler.post(
+            () -> {
+              counters.ensureUpdated();
+              listener.onAudioDisabled(counters);
+            });
       }
     }
 
@@ -178,12 +161,7 @@ public void run() {
      */
     public void audioSessionId(final int audioSessionId) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onAudioSessionId(audioSessionId);
-          }
-        });
+        handler.post(() -> listener.onAudioSessionId(audioSessionId));
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
index 07584d575e..24d218bf3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
@@ -18,6 +18,7 @@
 import android.media.AudioTrack;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import java.nio.ByteBuffer;
 
@@ -165,12 +166,13 @@ public WriteException(int errorCode) {
   void setListener(Listener listener);
 
   /**
-   * Returns whether it's possible to play audio in the specified encoding.
+   * Returns whether the sink supports the audio format.
    *
-   * @param encoding The audio encoding.
-   * @return Whether it's possible to play audio in the specified encoding.
+   * @param channelCount The number of channels, or {@link Format#NO_VALUE} if not known.
+   * @param encoding The audio encoding, or {@link Format#NO_VALUE} if not known.
+   * @return Whether the sink supports the audio format.
    */
-  boolean isEncodingSupported(@C.Encoding int encoding);
+  boolean supportsOutput(int channelCount, @C.Encoding int encoding);
 
   /**
    * Returns the playback position in the stream starting at zero, in microseconds, or
@@ -215,9 +217,7 @@ void configure(
    */
   void play();
 
-  /**
-   * Signals to the sink that the next buffer is discontinuous with the previous buffer.
-   */
+  /** Signals to the sink that the next buffer may be discontinuous with the previous buffer. */
   void handleDiscontinuity();
 
   /**
@@ -283,11 +283,12 @@ boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
    */
   void setAudioAttributes(AudioAttributes audioAttributes);
 
-  /**
-   * Sets the audio session id.
-   */
+  /** Sets the audio session id. */
   void setAudioSessionId(int audioSessionId);
 
+  /** Sets the auxiliary effect. */
+  void setAuxEffectInfo(AuxEffectInfo auxEffectInfo);
+
   /**
    * Enables tunneling, if possible. The sink is reset if tunneling was previously disabled or if
    * the audio session id has changed. Enabling tunneling is only possible if the sink is based on a
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
index 47120e7375..569260efeb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
@@ -22,6 +22,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -45,6 +46,7 @@
 /* package */ final class AudioTimestampPoller {
 
   /** Timestamp polling states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     STATE_INITIALIZING,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
index 4714db8902..62b120f00a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
@@ -15,13 +15,17 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.media.AudioTimestamp;
 import android.media.AudioTrack;
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
@@ -94,6 +98,7 @@ void onSystemTimeUsMismatch(
   }
 
   /** {@link AudioTrack} playback states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({PLAYSTATE_STOPPED, PLAYSTATE_PAUSED, PLAYSTATE_PLAYING})
   private @interface PlayState {}
@@ -128,10 +133,10 @@ void onSystemTimeUsMismatch(
   private final Listener listener;
   private final long[] playheadOffsets;
 
-  private AudioTrack audioTrack;
+  private @Nullable AudioTrack audioTrack;
   private int outputPcmFrameSize;
   private int bufferSize;
-  private AudioTimestampPoller audioTimestampPoller;
+  private @Nullable AudioTimestampPoller audioTimestampPoller;
   private int outputSampleRate;
   private boolean needsPassthroughWorkarounds;
   private long bufferSizeUs;
@@ -139,7 +144,7 @@ void onSystemTimeUsMismatch(
   private long smoothedPlayheadOffsetUs;
   private long lastPlayheadSampleTimeUs;
 
-  private Method getLatencyMethod;
+  private @Nullable Method getLatencyMethod;
   private long latencyUs;
   private boolean hasData;
 
@@ -193,7 +198,7 @@ public void setAudioTrack(
     audioTimestampPoller = new AudioTimestampPoller(audioTrack);
     outputSampleRate = audioTrack.getSampleRate();
     needsPassthroughWorkarounds = needsPassthroughWorkarounds(outputEncoding);
-    isOutputPcm = Util.isEncodingPcm(outputEncoding);
+    isOutputPcm = Util.isEncodingLinearPcm(outputEncoding);
     bufferSizeUs = isOutputPcm ? framesToDurationUs(bufferSize / outputPcmFrameSize) : C.TIME_UNSET;
     lastRawPlaybackHeadPosition = 0;
     rawPlaybackHeadWrapCount = 0;
@@ -205,13 +210,14 @@ public void setAudioTrack(
   }
 
   public long getCurrentPositionUs(boolean sourceEnded) {
-    if (audioTrack.getPlayState() == PLAYSTATE_PLAYING) {
+    if (Assertions.checkNotNull(this.audioTrack).getPlayState() == PLAYSTATE_PLAYING) {
       maybeSampleSyncParams();
     }
 
     // If the device supports it, use the playback timestamp from AudioTrack.getTimestamp.
     // Otherwise, derive a smoothed position by sampling the track's frame position.
     long systemTimeUs = System.nanoTime() / 1000;
+    AudioTimestampPoller audioTimestampPoller = Assertions.checkNotNull(this.audioTimestampPoller);
     if (audioTimestampPoller.hasTimestamp()) {
       // Calculate the speed-adjusted position using the timestamp (which may be in the future).
       long timestampPositionFrames = audioTimestampPoller.getTimestampPositionFrames();
@@ -241,12 +247,12 @@ public long getCurrentPositionUs(boolean sourceEnded) {
 
   /** Starts position tracking. Must be called immediately before {@link AudioTrack#play()}. */
   public void start() {
-    audioTimestampPoller.reset();
+    Assertions.checkNotNull(audioTimestampPoller).reset();
   }
 
   /** Returns whether the audio track is in the playing state. */
   public boolean isPlaying() {
-    return audioTrack.getPlayState() == PLAYSTATE_PLAYING;
+    return Assertions.checkNotNull(audioTrack).getPlayState() == PLAYSTATE_PLAYING;
   }
 
   /**
@@ -257,7 +263,7 @@ public boolean isPlaying() {
    * @return Whether the caller can write data to the track.
    */
   public boolean mayHandleBuffer(long writtenFrames) {
-    @PlayState int playState = audioTrack.getPlayState();
+    @PlayState int playState = Assertions.checkNotNull(audioTrack).getPlayState();
     if (needsPassthroughWorkarounds) {
       // An AC-3 audio track continues to play data written while it is paused. Stop writing so its
       // buffer empties. See [Internal: b/18899620].
@@ -339,7 +345,7 @@ public boolean pause() {
     if (stopTimestampUs == C.TIME_UNSET) {
       // The audio track is going to be paused, so reset the timestamp poller to ensure it doesn't
       // supply an advancing position.
-      audioTimestampPoller.reset();
+      Assertions.checkNotNull(audioTimestampPoller).reset();
       return true;
     }
     // We've handled the end of the stream already, so there's no need to pause the track.
@@ -388,6 +394,7 @@ private void maybeSampleSyncParams() {
   }
 
   private void maybePollAndCheckTimestamp(long systemTimeUs, long playbackPositionUs) {
+    AudioTimestampPoller audioTimestampPoller = Assertions.checkNotNull(this.audioTimestampPoller);
     if (!audioTimestampPoller.maybePollTimestamp(systemTimeUs)) {
       return;
     }
@@ -423,7 +430,9 @@ private void maybeUpdateLatency(long systemTimeUs) {
         // Compute the audio track latency, excluding the latency due to the buffer (leaving
         // latency due to the mixer and audio hardware driver).
         latencyUs =
-            (Integer) getLatencyMethod.invoke(audioTrack, (Object[]) null) * 1000L - bufferSizeUs;
+            castNonNull((Integer) getLatencyMethod.invoke(Assertions.checkNotNull(audioTrack)))
+                    * 1000L
+                - bufferSizeUs;
         // Sanity check that the latency is non-negative.
         latencyUs = Math.max(latencyUs, 0);
         // Sanity check that the latency isn't too large.
@@ -457,7 +466,7 @@ private void resetSyncParams() {
    */
   private boolean forceHasPendingData() {
     return needsPassthroughWorkarounds
-        && audioTrack.getPlayState() == AudioTrack.PLAYSTATE_PAUSED
+        && Assertions.checkNotNull(audioTrack).getPlayState() == AudioTrack.PLAYSTATE_PAUSED
         && getPlaybackHeadPosition() == 0;
   }
 
@@ -483,6 +492,7 @@ private long getPlaybackHeadPositionUs() {
    * @return The playback head position, in frames.
    */
   private long getPlaybackHeadPosition() {
+    AudioTrack audioTrack = Assertions.checkNotNull(this.audioTrack);
     if (stopTimestampUs != C.TIME_UNSET) {
       // Simulate the playback head position up to the total number of frames submitted.
       long elapsedTimeSinceStopUs = (SystemClock.elapsedRealtime() * 1000) - stopTimestampUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java
new file mode 100644
index 0000000000..7462a9c4b0
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import android.media.AudioTrack;
+import android.media.audiofx.AudioEffect;
+import android.support.annotation.Nullable;
+
+/**
+ * Represents auxiliary effect information, which can be used to attach an auxiliary effect to an
+ * underlying {@link AudioTrack}.
+ *
+ * <p>Auxiliary effects can only be applied if the application has the {@code
+ * android.permission.MODIFY_AUDIO_SETTINGS} permission. Apps are responsible for retaining the
+ * associated audio effect instance and releasing it when it's no longer needed. See the
+ * documentation of {@link AudioEffect} for more information.
+ */
+public final class AuxEffectInfo {
+
+  /** Value for {@link #effectId} representing no auxiliary effect. */
+  public static final int NO_AUX_EFFECT_ID = 0;
+
+  /**
+   * The identifier of the effect, or {@link #NO_AUX_EFFECT_ID} if there is no effect.
+   *
+   * @see android.media.AudioTrack#attachAuxEffect(int)
+   */
+  public final int effectId;
+  /**
+   * The send level for the effect.
+   *
+   * @see android.media.AudioTrack#setAuxEffectSendLevel(float)
+   */
+  public final float sendLevel;
+
+  /**
+   * Creates an instance with the given effect identifier and send level.
+   *
+   * @param effectId The effect identifier. This is the value returned by {@link
+   *     AudioEffect#getId()} on the effect, or {@value NO_AUX_EFFECT_ID} which represents no
+   *     effect. This value is passed to {@link AudioTrack#attachAuxEffect(int)} on the underlying
+   *     audio track.
+   * @param sendLevel The send level for the effect, where 0 represents no effect and a value of 1
+   *     is full send. If {@code effectId} is not {@value #NO_AUX_EFFECT_ID}, this value is passed
+   *     to {@link AudioTrack#setAuxEffectSendLevel(float)} on the underlying audio track.
+   */
+  public AuxEffectInfo(int effectId, float sendLevel) {
+    this.effectId = effectId;
+    this.sendLevel = sendLevel;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    AuxEffectInfo auxEffectInfo = (AuxEffectInfo) o;
+    return effectId == auxEffectInfo.effectId
+        && Float.compare(auxEffectInfo.sendLevel, sendLevel) == 0;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + effectId;
+    result = 31 * result + Float.floatToIntBits(sendLevel);
+    return result;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 1025cb953b..429510bcaf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -24,11 +24,13 @@
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -170,6 +172,9 @@ public long getSkippedOutputFrameCount() {
    */
   private static final int BUFFER_MULTIPLICATION_FACTOR = 4;
 
+  /** To avoid underruns on some devices (e.g., Broadcom 7271), scale up the AC3 buffer duration. */
+  private static final int AC3_BUFFER_MULTIPLICATION_FACTOR = 2;
+
   /**
    * @see AudioTrack#ERROR_BAD_VALUE
    */
@@ -194,12 +199,12 @@ public long getSkippedOutputFrameCount() {
 
   private static final String TAG = "AudioTrack";
 
-  /**
-   * Represents states of the {@link #startMediaTimeUs} value.
-   */
+  /** Represents states of the {@link #startMediaTimeUs} value. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({START_NOT_SET, START_IN_SYNC, START_NEED_SYNC})
   private @interface StartMediaTimeState {}
+
   private static final int START_NOT_SET = 0;
   private static final int START_IN_SYNC = 1;
   private static final int START_NEED_SYNC = 2;
@@ -279,6 +284,7 @@ public long getSkippedOutputFrameCount() {
 
   private boolean playing;
   private int audioSessionId;
+  private AuxEffectInfo auxEffectInfo;
   private boolean tunneling;
   private long lastFeedElapsedRealtimeMs;
 
@@ -355,6 +361,7 @@ public DefaultAudioSink(
     startMediaTimeState = START_NOT_SET;
     audioAttributes = AudioAttributes.DEFAULT;
     audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+    auxEffectInfo = new AuxEffectInfo(AuxEffectInfo.NO_AUX_EFFECT_ID, 0f);
     playbackParameters = PlaybackParameters.DEFAULT;
     drainingAudioProcessorIndex = C.INDEX_UNSET;
     activeAudioProcessors = new AudioProcessor[0];
@@ -370,14 +377,18 @@ public void setListener(Listener listener) {
   }
 
   @Override
-  public boolean isEncodingSupported(@C.Encoding int encoding) {
-    if (Util.isEncodingPcm(encoding)) {
+  public boolean supportsOutput(int channelCount, @C.Encoding int encoding) {
+    if (Util.isEncodingLinearPcm(encoding)) {
       // AudioTrack supports 16-bit integer PCM output in all platform API versions, and float
       // output from platform API version 21 only. Other integer PCM encodings are resampled by this
-      // sink to 16-bit PCM.
+      // sink to 16-bit PCM. We assume that the audio framework will downsample any number of
+      // channels to the output device's required number of channels.
       return encoding != C.ENCODING_PCM_FLOAT || Util.SDK_INT >= 21;
     } else {
-      return audioCapabilities != null && audioCapabilities.supportsEncoding(encoding);
+      return audioCapabilities != null
+          && audioCapabilities.supportsEncoding(encoding)
+          && (channelCount == Format.NO_VALUE
+              || channelCount <= audioCapabilities.getMaxChannelCount());
     }
   }
 
@@ -405,10 +416,10 @@ public void configure(
     this.inputSampleRate = inputSampleRate;
     int channelCount = inputChannelCount;
     int sampleRate = inputSampleRate;
-    isInputPcm = Util.isEncodingPcm(inputEncoding);
+    isInputPcm = Util.isEncodingLinearPcm(inputEncoding);
     shouldConvertHighResIntPcmToFloat =
         enableConvertHighResIntPcmToFloat
-            && isEncodingSupported(C.ENCODING_PCM_32BIT)
+            && supportsOutput(channelCount, C.ENCODING_PCM_32BIT)
             && Util.isEncodingHighResolutionIntegerPcm(inputEncoding);
     if (isInputPcm) {
       pcmFrameSize = Util.getPcmFrameSize(inputEncoding, channelCount);
@@ -416,6 +427,16 @@ public void configure(
     @C.Encoding int encoding = inputEncoding;
     boolean processingEnabled = isInputPcm && inputEncoding != C.ENCODING_PCM_FLOAT;
     canApplyPlaybackParameters = processingEnabled && !shouldConvertHighResIntPcmToFloat;
+
+    if (Util.SDK_INT < 21 && channelCount == 8 && outputChannels == null) {
+      // AudioTrack doesn't support 8 channel output before Android L. Discard the last two (side)
+      // channels to give a 6 channel stream that is supported.
+      outputChannels = new int[6];
+      for (int i = 0; i < outputChannels.length; i++) {
+        outputChannels[i] = i;
+      }
+    }
+
     if (processingEnabled) {
       trimmingAudioProcessor.setTrimFrameCount(trimStartFrames, trimEndFrames);
       channelMappingAudioProcessor.setChannelMap(outputChannels);
@@ -433,55 +454,9 @@ public void configure(
       }
     }
 
-    int channelConfig;
-    switch (channelCount) {
-      case 1:
-        channelConfig = AudioFormat.CHANNEL_OUT_MONO;
-        break;
-      case 2:
-        channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
-        break;
-      case 3:
-        channelConfig = AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER;
-        break;
-      case 4:
-        channelConfig = AudioFormat.CHANNEL_OUT_QUAD;
-        break;
-      case 5:
-        channelConfig = AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER;
-        break;
-      case 6:
-        channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
-        break;
-      case 7:
-        channelConfig = AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER;
-        break;
-      case 8:
-        channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
-        break;
-      default:
-        throw new ConfigurationException("Unsupported channel count: " + channelCount);
-    }
-
-    // Workaround for overly strict channel configuration checks on nVidia Shield.
-    if (Util.SDK_INT <= 23 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER)) {
-      switch (channelCount) {
-        case 7:
-          channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
-          break;
-        case 3:
-        case 5:
-          channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
-          break;
-        default:
-          break;
-      }
-    }
-
-    // Workaround for Nexus Player not reporting support for mono passthrough.
-    // (See [Internal: b/34268671].)
-    if (Util.SDK_INT <= 25 && "fugu".equals(Util.DEVICE) && !isInputPcm && channelCount == 1) {
-      channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
+    int channelConfig = getChannelConfig(channelCount, isInputPcm);
+    if (channelConfig == AudioFormat.CHANNEL_INVALID) {
+      throw new ConfigurationException("Unsupported channel count: " + channelCount);
     }
 
     if (!flush
@@ -501,29 +476,25 @@ public void configure(
     outputEncoding = encoding;
     outputPcmFrameSize =
         isInputPcm ? Util.getPcmFrameSize(outputEncoding, channelCount) : C.LENGTH_UNSET;
-    if (specifiedBufferSize != 0) {
-      bufferSize = specifiedBufferSize;
-    } else if (isInputPcm) {
-      int minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, outputEncoding);
+    bufferSize = specifiedBufferSize != 0 ? specifiedBufferSize : getDefaultBufferSize();
+  }
+
+  private int getDefaultBufferSize() {
+    if (isInputPcm) {
+      int minBufferSize =
+          AudioTrack.getMinBufferSize(outputSampleRate, outputChannelConfig, outputEncoding);
       Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
       int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
       int maxAppBufferSize = (int) Math.max(minBufferSize,
           durationUsToFrames(MAX_BUFFER_DURATION_US) * outputPcmFrameSize);
-      bufferSize = Util.constrainValue(multipliedBufferSize, minAppBufferSize, maxAppBufferSize);
+      return Util.constrainValue(multipliedBufferSize, minAppBufferSize, maxAppBufferSize);
     } else {
-      // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
-      // account. [Internal: b/25181305]
-      if (outputEncoding == C.ENCODING_AC3 || outputEncoding == C.ENCODING_E_AC3) {
-        // AC-3 allows bitrates up to 640 kbit/s.
-        bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 80 * 1024 / C.MICROS_PER_SECOND);
-      } else if (outputEncoding == C.ENCODING_DTS) {
-        // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
-        bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
-      } else /* outputEncoding == C.ENCODING_DTS_HD || outputEncoding == C.ENCODING_DOLBY_TRUEHD*/ {
-        // HD passthrough requires a larger buffer to avoid underrun.
-        bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 6 * 1024 / C.MICROS_PER_SECOND);
+      int rate = getMaximumEncodedRateBytesPerSecond(outputEncoding);
+      if (outputEncoding == C.ENCODING_AC3) {
+        rate *= AC3_BUFFER_MULTIPLICATION_FACTOR;
       }
+      return (int) (PASSTHROUGH_BUFFER_DURATION_US * rate / C.MICROS_PER_SECOND);
     }
   }
 
@@ -589,6 +560,11 @@ private void initialize() throws InitializationException {
     audioTrackPositionTracker.setAudioTrack(
         audioTrack, outputEncoding, outputPcmFrameSize, bufferSize);
     setVolumeInternal();
+
+    if (auxEffectInfo.effectId != AuxEffectInfo.NO_AUX_EFFECT_ID) {
+      audioTrack.attachAuxEffect(auxEffectInfo.effectId);
+      audioTrack.setAuxEffectSendLevel(auxEffectInfo.sendLevel);
+    }
   }
 
   @Override
@@ -667,7 +643,9 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       } else {
         // Sanity check that presentationTimeUs is consistent with the expected value.
         long expectedPresentationTimeUs =
-            startMediaTimeUs + inputFramesToDurationUs(getSubmittedFrames());
+            startMediaTimeUs
+                + inputFramesToDurationUs(
+                    getSubmittedFrames() - trimmingAudioProcessor.getTrimmedFrameCount());
         if (startMediaTimeState == START_IN_SYNC
             && Math.abs(expectedPresentationTimeUs - presentationTimeUs) > 200000) {
           Log.e(TAG, "Discontinuity detected [expected " + expectedPresentationTimeUs + ", got "
@@ -677,9 +655,10 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         if (startMediaTimeState == START_NEED_SYNC) {
           // Adjust startMediaTimeUs to be consistent with the current buffer's start time and the
           // number of bytes submitted.
-          startMediaTimeUs += (presentationTimeUs - expectedPresentationTimeUs);
+          long adjustmentUs = presentationTimeUs - expectedPresentationTimeUs;
+          startMediaTimeUs += adjustmentUs;
           startMediaTimeState = START_IN_SYNC;
-          if (listener != null) {
+          if (listener != null && adjustmentUs != 0) {
             listener.onPositionDiscontinuity();
           }
         }
@@ -909,6 +888,24 @@ public void setAudioSessionId(int audioSessionId) {
     }
   }
 
+  @Override
+  public void setAuxEffectInfo(AuxEffectInfo auxEffectInfo) {
+    if (this.auxEffectInfo.equals(auxEffectInfo)) {
+      return;
+    }
+    int effectId = auxEffectInfo.effectId;
+    float sendLevel = auxEffectInfo.sendLevel;
+    if (audioTrack != null) {
+      if (this.auxEffectInfo.effectId != effectId) {
+        audioTrack.attachAuxEffect(effectId);
+      }
+      if (effectId != AuxEffectInfo.NO_AUX_EFFECT_ID) {
+        audioTrack.setAuxEffectSendLevel(sendLevel);
+      }
+    }
+    this.auxEffectInfo = auxEffectInfo;
+  }
+
   @Override
   public void enableTunnelingV21(int tunnelingAudioSessionId) {
     Assertions.checkState(Util.SDK_INT >= 21);
@@ -971,6 +968,7 @@ public void reset() {
       playbackParametersCheckpoints.clear();
       playbackParametersOffsetUs = 0;
       playbackParametersPositionUs = 0;
+      trimmingAudioProcessor.resetTrimmedFrameCount();
       inputBuffer = null;
       outputBuffer = null;
       flushAudioProcessors();
@@ -1170,6 +1168,55 @@ private AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
         : toIntPcmAvailableAudioProcessors;
   }
 
+  private static int getChannelConfig(int channelCount, boolean isInputPcm) {
+    if (Util.SDK_INT <= 28 && !isInputPcm) {
+      // In passthrough mode the channel count used to configure the audio track doesn't affect how
+      // the stream is handled, except that some devices do overly-strict channel configuration
+      // checks. Therefore we override the channel count so that a known-working channel
+      // configuration is chosen in all cases. See [Internal: b/29116190].
+      if (channelCount == 7) {
+        channelCount = 8;
+      } else if (channelCount == 3 || channelCount == 4 || channelCount == 5) {
+        channelCount = 6;
+      }
+    }
+
+    // Workaround for Nexus Player not reporting support for mono passthrough.
+    // (See [Internal: b/34268671].)
+    if (Util.SDK_INT <= 26 && "fugu".equals(Util.DEVICE) && !isInputPcm && channelCount == 1) {
+      channelCount = 2;
+    }
+
+    return Util.getAudioTrackChannelConfig(channelCount);
+  }
+
+  private static int getMaximumEncodedRateBytesPerSecond(@C.Encoding int encoding) {
+    switch (encoding) {
+      case C.ENCODING_AC3:
+        return 640 * 1000 / 8;
+      case C.ENCODING_E_AC3:
+        return 6144 * 1000 / 8;
+      case C.ENCODING_DTS:
+        // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
+        return 1536 * 1000 / 8;
+      case C.ENCODING_DTS_HD:
+        return 18000 * 1000 / 8;
+      case C.ENCODING_DOLBY_TRUEHD:
+        return 24500 * 1000 / 8;
+      case C.ENCODING_INVALID:
+      case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_PCM_24BIT:
+      case C.ENCODING_PCM_32BIT:
+      case C.ENCODING_PCM_8BIT:
+      case C.ENCODING_PCM_A_LAW:
+      case C.ENCODING_PCM_FLOAT:
+      case C.ENCODING_PCM_MU_LAW:
+      case Format.NO_VALUE:
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffer buffer) {
     if (encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD) {
       return DtsUtil.parseDtsAudioSampleCount(buffer);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
index dc07b1a646..f65dc3fc4e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
@@ -74,13 +74,13 @@ public static boolean isSyncWord(int word) {
    * subsections 5.3/5.4.
    *
    * @param frame The DTS frame to parse.
-   * @param trackId The track identifier to set on the format, or null.
+   * @param trackId The track identifier to set on the format.
    * @param language The language to set on the format.
    * @param drmInitData {@link DrmInitData} to be included in the format.
    * @return The DTS format parsed from data in the header.
    */
-  public static Format parseDtsFormat(byte[] frame, String trackId, String language,
-      DrmInitData drmInitData) {
+  public static Format parseDtsFormat(
+      byte[] frame, String trackId, String language, DrmInitData drmInitData) {
     ParsableBitArray frameBits = getNormalizedFrameHeader(frame);
     frameBits.skipBits(32 + 1 + 5 + 1 + 7 + 14); // SYNC, FTYPE, SHORT, CPF, NBLKS, FSIZE
     int amode = frameBits.readBits(6);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 9ab066ee7d..daa0447905 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -24,6 +24,7 @@
 import android.media.MediaFormat;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
+import android.support.annotation.CallSuper;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -41,10 +42,13 @@
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.mediacodec.MediaFormatUtil;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Decodes and renders audio using {@link MediaCodec} and an {@link AudioSink}.
@@ -58,27 +62,42 @@
  *   <li>Message with type {@link C#MSG_SET_AUDIO_ATTRIBUTES} to set the audio attributes. The
  *       message payload should be an {@link com.google.android.exoplayer2.audio.AudioAttributes}
  *       instance that will configure the underlying audio track.
+ *   <li>Message with type {@link C#MSG_SET_AUX_EFFECT_INFO} to set the auxiliary effect. The
+ *       message payload should be an {@link AuxEffectInfo} instance that will configure the
+ *       underlying audio track.
  * </ul>
  */
 @TargetApi(16)
 public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock {
 
+  /**
+   * Maximum number of tracked pending stream change times. Generally there is zero or one pending
+   * stream change. We track more to allow for pending changes that have fewer samples than the
+   * codec latency.
+   */
+  private static final int MAX_PENDING_STREAM_CHANGE_COUNT = 10;
+
+  private static final String TAG = "MediaCodecAudioRenderer";
+
   private final Context context;
   private final EventDispatcher eventDispatcher;
   private final AudioSink audioSink;
+  private final long[] pendingStreamChangeTimesUs;
 
   private int codecMaxInputSize;
   private boolean passthroughEnabled;
   private boolean codecNeedsDiscardChannelsWorkaround;
+  private boolean codecNeedsEosBufferTimestampWorkaround;
   private android.media.MediaFormat passthroughMediaFormat;
-  @C.Encoding
-  private int pcmEncoding;
+  private @C.Encoding int pcmEncoding;
   private int channelCount;
   private int encoderDelay;
   private int encoderPadding;
   private long currentPositionUs;
   private boolean allowFirstBufferPositionDiscontinuity;
   private boolean allowPositionDiscontinuity;
+  private long lastInputTimeUs;
+  private int pendingStreamChangeCount;
 
   /**
    * @param context A context.
@@ -229,9 +248,16 @@ public MediaCodecAudioRenderer(
       @Nullable Handler eventHandler,
       @Nullable AudioRendererEventListener eventListener,
       AudioSink audioSink) {
-    super(C.TRACK_TYPE_AUDIO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
+    super(
+        C.TRACK_TYPE_AUDIO,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        /* assumedMinimumCodecOperatingRate= */ 44100);
     this.context = context.getApplicationContext();
     this.audioSink = audioSink;
+    lastInputTimeUs = C.TIME_UNSET;
+    pendingStreamChangeTimesUs = new long[MAX_PENDING_STREAM_CHANGE_COUNT];
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     audioSink.setListener(new AudioSinkListener());
   }
@@ -246,12 +272,14 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
     }
     int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     boolean supportsFormatDrm = supportsFormatDrm(drmSessionManager, format.drmInitData);
-    if (supportsFormatDrm && allowPassthrough(mimeType)
+    if (supportsFormatDrm
+        && allowPassthrough(format.channelCount, mimeType)
         && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
       return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
-    if ((MimeTypes.AUDIO_RAW.equals(mimeType) && !audioSink.isEncodingSupported(format.pcmEncoding))
-        || !audioSink.isEncodingSupported(C.ENCODING_PCM_16BIT)) {
+    if ((MimeTypes.AUDIO_RAW.equals(mimeType)
+            && !audioSink.supportsOutput(format.channelCount, format.pcmEncoding))
+        || !audioSink.supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       // Assume the decoder outputs 16-bit PCM, unless the input is raw.
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
@@ -262,35 +290,41 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         requiresSecureDecryption |= drmInitData.get(i).requiresSecureDecryption;
       }
     }
-    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType,
-        requiresSecureDecryption);
-    if (decoderInfo == null) {
-      return requiresSecureDecryption && mediaCodecSelector.getDecoderInfo(mimeType, false) != null
-          ? FORMAT_UNSUPPORTED_DRM : FORMAT_UNSUPPORTED_SUBTYPE;
+    List<MediaCodecInfo> decoderInfos =
+        mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecryption);
+    if (decoderInfos.isEmpty()) {
+      return requiresSecureDecryption
+              && !mediaCodecSelector
+                  .getDecoderInfos(format.sampleMimeType, /* requiresSecureDecoder= */ false)
+                  .isEmpty()
+          ? FORMAT_UNSUPPORTED_DRM
+          : FORMAT_UNSUPPORTED_SUBTYPE;
     }
     if (!supportsFormatDrm) {
       return FORMAT_UNSUPPORTED_DRM;
     }
-    // Note: We assume support for unknown sampleRate and channelCount.
-    boolean decoderCapable = Util.SDK_INT < 21
-        || ((format.sampleRate == Format.NO_VALUE
-        || decoderInfo.isAudioSampleRateSupportedV21(format.sampleRate))
-        && (format.channelCount == Format.NO_VALUE
-        ||  decoderInfo.isAudioChannelCountSupportedV21(format.channelCount)));
-    int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
+    // Check capabilities for the first decoder in the list, which takes priority.
+    MediaCodecInfo decoderInfo = decoderInfos.get(0);
+    boolean isFormatSupported = decoderInfo.isFormatSupported(format);
+    int adaptiveSupport =
+        isFormatSupported && decoderInfo.isSeamlessAdaptationSupported(format)
+            ? ADAPTIVE_SEAMLESS
+            : ADAPTIVE_NOT_SEAMLESS;
+    int formatSupport = isFormatSupported ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
+    return adaptiveSupport | tunnelingSupport | formatSupport;
   }
 
   @Override
-  protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
-      Format format, boolean requiresSecureDecoder) throws DecoderQueryException {
-    if (allowPassthrough(format.sampleMimeType)) {
+  protected List<MediaCodecInfo> getDecoderInfos(
+      MediaCodecSelector mediaCodecSelector, Format format, boolean requiresSecureDecoder)
+      throws DecoderQueryException {
+    if (allowPassthrough(format.channelCount, format.sampleMimeType)) {
       MediaCodecInfo passthroughDecoderInfo = mediaCodecSelector.getPassthroughDecoderInfo();
       if (passthroughDecoderInfo != null) {
-        return passthroughDecoderInfo;
+        return Collections.singletonList(passthroughDecoderInfo);
       }
     }
-    return super.getDecoderInfo(mediaCodecSelector, format, requiresSecureDecoder);
+    return super.getDecoderInfos(mediaCodecSelector, format, requiresSecureDecoder);
   }
 
   /**
@@ -298,22 +332,29 @@ protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
    * This implementation returns true if the {@link AudioSink} indicates that encoded audio output
    * is supported.
    *
+   * @param channelCount The number of channels in the input media, or {@link Format#NO_VALUE} if
+   *     not known.
    * @param mimeType The type of input media.
    * @return Whether passthrough playback is supported.
    */
-  protected boolean allowPassthrough(String mimeType) {
-    @C.Encoding int encoding = MimeTypes.getEncoding(mimeType);
-    return encoding != C.ENCODING_INVALID && audioSink.isEncodingSupported(encoding);
+  protected boolean allowPassthrough(int channelCount, String mimeType) {
+    return audioSink.supportsOutput(channelCount, MimeTypes.getEncoding(mimeType));
   }
 
   @Override
-  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
-      MediaCrypto crypto) {
+  protected void configureCodec(
+      MediaCodecInfo codecInfo,
+      MediaCodec codec,
+      Format format,
+      MediaCrypto crypto,
+      float codecOperatingRate) {
     codecMaxInputSize = getCodecMaxInputSize(codecInfo, format, getStreamFormats());
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
+    codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);
     passthroughEnabled = codecInfo.passthrough;
     String codecMimeType = codecInfo.mimeType == null ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
-    MediaFormat mediaFormat = getMediaFormat(format, codecMimeType, codecMaxInputSize);
+    MediaFormat mediaFormat =
+        getMediaFormat(format, codecMimeType, codecMaxInputSize, codecOperatingRate);
     codec.configure(mediaFormat, /* surface= */ null, crypto, /* flags= */ 0);
     if (passthroughEnabled) {
       // Store the input MIME type if we're using the passthrough codec.
@@ -327,13 +368,17 @@ protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format
   @Override
   protected @KeepCodecResult int canKeepCodec(
       MediaCodec codec, MediaCodecInfo codecInfo, Format oldFormat, Format newFormat) {
-    return KEEP_CODEC_RESULT_NO;
-    // TODO: Determine when codecs can be safely kept. When doing so, also uncomment the commented
-    // out code in getCodecMaxInputSize.
-    // return getCodecMaxInputSize(codecInfo, newFormat) <= codecMaxInputSize
-    //         && areAdaptationCompatible(oldFormat, newFormat)
-    //     ? KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION
-    //     : KEEP_CODEC_RESULT_NO;
+    if (getCodecMaxInputSize(codecInfo, newFormat) <= codecMaxInputSize
+        && codecInfo.isSeamlessAdaptationSupported(
+            oldFormat, newFormat, /* isNewFormatComplete= */ true)
+        && oldFormat.encoderDelay == 0
+        && oldFormat.encoderPadding == 0
+        && newFormat.encoderDelay == 0
+        && newFormat.encoderPadding == 0) {
+      return KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION;
+    } else {
+      return KEEP_CODEC_RESULT_NO;
+    }
   }
 
   @Override
@@ -341,6 +386,21 @@ public MediaClock getMediaClock() {
     return this;
   }
 
+  @Override
+  protected float getCodecOperatingRate(
+      float operatingRate, Format format, Format[] streamFormats) {
+    // Use the highest known stream sample-rate up front, to avoid having to reconfigure the codec
+    // should an adaptive switch to that stream occur.
+    int maxSampleRate = -1;
+    for (Format streamFormat : streamFormats) {
+      int streamSampleRate = streamFormat.sampleRate;
+      if (streamSampleRate != Format.NO_VALUE) {
+        maxSampleRate = Math.max(maxSampleRate, streamSampleRate);
+      }
+    }
+    return maxSampleRate == -1 ? CODEC_OPERATING_RATE_UNSET : (maxSampleRate * operatingRate);
+  }
+
   @Override
   protected void onCodecInitialized(String name, long initializedTimestampMs,
       long initializationDurationMs) {
@@ -431,6 +491,22 @@ protected void onEnabled(boolean joining) throws ExoPlaybackException {
     }
   }
 
+  @Override
+  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
+    super.onStreamChanged(formats, offsetUs);
+    if (lastInputTimeUs != C.TIME_UNSET) {
+      if (pendingStreamChangeCount == pendingStreamChangeTimesUs.length) {
+        Log.w(
+            TAG,
+            "Too many stream changes, so dropping change at "
+                + pendingStreamChangeTimesUs[pendingStreamChangeCount - 1]);
+      } else {
+        pendingStreamChangeCount++;
+      }
+      pendingStreamChangeTimesUs[pendingStreamChangeCount - 1] = lastInputTimeUs;
+    }
+  }
+
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     super.onPositionReset(positionUs, joining);
@@ -438,6 +514,8 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
     currentPositionUs = positionUs;
     allowFirstBufferPositionDiscontinuity = true;
     allowPositionDiscontinuity = true;
+    lastInputTimeUs = C.TIME_UNSET;
+    pendingStreamChangeCount = 0;
   }
 
   @Override
@@ -456,6 +534,8 @@ protected void onStopped() {
   @Override
   protected void onDisabled() {
     try {
+      lastInputTimeUs = C.TIME_UNSET;
+      pendingStreamChangeCount = 0;
       audioSink.release();
     } finally {
       try {
@@ -506,12 +586,43 @@ protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
       }
       allowFirstBufferPositionDiscontinuity = false;
     }
+    lastInputTimeUs = Math.max(buffer.timeUs, lastInputTimeUs);
+  }
+
+  @CallSuper
+  @Override
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    while (pendingStreamChangeCount != 0 && presentationTimeUs >= pendingStreamChangeTimesUs[0]) {
+      audioSink.handleDiscontinuity();
+      pendingStreamChangeCount--;
+      System.arraycopy(
+          pendingStreamChangeTimesUs,
+          /* srcPos= */ 1,
+          pendingStreamChangeTimesUs,
+          /* destPos= */ 0,
+          pendingStreamChangeCount);
+    }
   }
 
   @Override
-  protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
-      ByteBuffer buffer, int bufferIndex, int bufferFlags, long bufferPresentationTimeUs,
-      boolean shouldSkip) throws ExoPlaybackException {
+  protected boolean processOutputBuffer(
+      long positionUs,
+      long elapsedRealtimeUs,
+      MediaCodec codec,
+      ByteBuffer buffer,
+      int bufferIndex,
+      int bufferFlags,
+      long bufferPresentationTimeUs,
+      boolean shouldSkip,
+      Format format)
+      throws ExoPlaybackException {
+    if (codecNeedsEosBufferTimestampWorkaround
+        && bufferPresentationTimeUs == 0
+        && (bufferFlags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0
+        && lastInputTimeUs != C.TIME_UNSET) {
+      bufferPresentationTimeUs = lastInputTimeUs;
+    }
+
     if (passthroughEnabled && (bufferFlags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
       // Discard output buffers from the passthrough (raw) decoder containing codec specific data.
       codec.releaseOutputBuffer(bufferIndex, false);
@@ -547,7 +658,7 @@ protected void renderToEndOfStream() throws ExoPlaybackException {
   }
 
   @Override
-  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+  public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
     switch (messageType) {
       case C.MSG_SET_VOLUME:
         audioSink.setVolume((Float) message);
@@ -556,6 +667,10 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
         AudioAttributes audioAttributes = (AudioAttributes) message;
         audioSink.setAudioAttributes(audioAttributes);
         break;
+      case C.MSG_SET_AUX_EFFECT_INFO:
+        AuxEffectInfo auxEffectInfo = (AuxEffectInfo) message;
+        audioSink.setAuxEffectInfo(auxEffectInfo);
+        break;
       default:
         super.handleMessage(messageType, message);
         break;
@@ -574,16 +689,17 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
   protected int getCodecMaxInputSize(
       MediaCodecInfo codecInfo, Format format, Format[] streamFormats) {
     int maxInputSize = getCodecMaxInputSize(codecInfo, format);
-    // if (streamFormats.length == 1) {
-    //   // The single entry in streamFormats must correspond to the format for which the codec is
-    //   // being configured.
-    //   return maxInputSize;
-    // }
-    // for (Format streamFormat : streamFormats) {
-    //   if (areAdaptationCompatible(format, streamFormat)) {
-    //     maxInputSize = Math.max(maxInputSize, getCodecMaxInputSize(codecInfo, streamFormat));
-    //   }
-    // }
+    if (streamFormats.length == 1) {
+      // The single entry in streamFormats must correspond to the format for which the codec is
+      // being configured.
+      return maxInputSize;
+    }
+    for (Format streamFormat : streamFormats) {
+      if (codecInfo.isSeamlessAdaptationSupported(
+          format, streamFormat, /* isNewFormatComplete= */ false)) {
+        maxInputSize = Math.max(maxInputSize, getCodecMaxInputSize(codecInfo, streamFormat));
+      }
+    }
     return maxInputSize;
   }
 
@@ -624,10 +740,13 @@ private int getCodecMaxInputSize(MediaCodecInfo codecInfo, Format format) {
    * @param format The format of the media.
    * @param codecMimeType The MIME type handled by the codec.
    * @param codecMaxInputSize The maximum input size supported by the codec.
+   * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
+   *     no codec operating rate should be set.
    * @return The framework media format.
    */
   @SuppressLint("InlinedApi")
-  protected MediaFormat getMediaFormat(Format format, String codecMimeType, int codecMaxInputSize) {
+  protected MediaFormat getMediaFormat(
+      Format format, String codecMimeType, int codecMaxInputSize, float codecOperatingRate) {
     MediaFormat mediaFormat = new MediaFormat();
     // Set format parameters that should always be set.
     mediaFormat.setString(MediaFormat.KEY_MIME, codecMimeType);
@@ -639,6 +758,9 @@ protected MediaFormat getMediaFormat(Format format, String codecMimeType, int co
     // Set codec configuration values.
     if (Util.SDK_INT >= 23) {
       mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 /* realtime priority */);
+      if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET) {
+        mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
+      }
     }
     return mediaFormat;
   }
@@ -654,25 +776,6 @@ private void updateCurrentPosition() {
     }
   }
 
-  /**
-   * Returns whether a codec with suitable maximum input size will support adaptation between two
-   * {@link Format}s.
-   *
-   * @param first The first format.
-   * @param second The second format.
-   * @return Whether the codec will support adaptation between the two {@link Format}s.
-   */
-  private static boolean areAdaptationCompatible(Format first, Format second) {
-    return first.sampleMimeType.equals(second.sampleMimeType)
-        && first.channelCount == second.channelCount
-        && first.sampleRate == second.sampleRate
-        && first.encoderDelay == 0
-        && first.encoderPadding == 0
-        && second.encoderDelay == 0
-        && second.encoderPadding == 0
-        && first.initializationDataEquals(second);
-  }
-
   /**
    * Returns whether the decoder is known to output six audio channels when provided with input with
    * fewer than six channels.
@@ -687,6 +790,24 @@ private static boolean codecNeedsDiscardChannelsWorkaround(String codecName) {
         || Util.DEVICE.startsWith("heroqlte"));
   }
 
+  /**
+   * Returns whether the decoder may output a non-empty buffer with timestamp 0 as the end of stream
+   * buffer.
+   *
+   * <p>See <a href="https://github.com/google/ExoPlayer/issues/5045">GitHub issue #5045</a>.
+   */
+  private static boolean codecNeedsEosBufferTimestampWorkaround(String codecName) {
+    return Util.SDK_INT < 21
+        && "OMX.SEC.mp3.dec".equals(codecName)
+        && "samsung".equals(Util.MANUFACTURER)
+        && (Util.DEVICE.startsWith("baffin")
+            || Util.DEVICE.startsWith("grand")
+            || Util.DEVICE.startsWith("fortuna")
+            || Util.DEVICE.startsWith("gprimelte")
+            || Util.DEVICE.startsWith("j2y18lte")
+            || Util.DEVICE.startsWith("ms01"));
+  }
+
   private final class AudioSinkListener implements AudioSink.Listener {
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
index eac0bffd65..3ae1a393f9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
@@ -98,6 +98,8 @@ public void queueInput(ByteBuffer inputBuffer) {
         break;
       case C.ENCODING_PCM_16BIT:
       case C.ENCODING_PCM_FLOAT:
+      case C.ENCODING_PCM_A_LAW:
+      case C.ENCODING_PCM_MU_LAW:
       case C.ENCODING_INVALID:
       case Format.NO_VALUE:
       default:
@@ -134,6 +136,8 @@ public void queueInput(ByteBuffer inputBuffer) {
         break;
       case C.ENCODING_PCM_16BIT:
       case C.ENCODING_PCM_FLOAT:
+      case C.ENCODING_PCM_A_LAW:
+      case C.ENCODING_PCM_MU_LAW:
       case C.ENCODING_INVALID:
       case Format.NO_VALUE:
       default:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
index a289ced128..a1ff7028c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
@@ -18,6 +18,8 @@
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -33,12 +35,12 @@
    * The minimum duration of audio that must be below {@link #SILENCE_THRESHOLD_LEVEL} to classify
    * that part of audio as silent, in microseconds.
    */
-  private static final long MINIMUM_SILENCE_DURATION_US = 100_000;
+  private static final long MINIMUM_SILENCE_DURATION_US = 150_000;
   /**
    * The duration of silence by which to extend non-silent sections, in microseconds. The value must
    * not exceed {@link #MINIMUM_SILENCE_DURATION_US}.
    */
-  private static final long PADDING_SILENCE_US = 10_000;
+  private static final long PADDING_SILENCE_US = 20_000;
   /**
    * The absolute level below which an individual PCM sample is classified as silent. Note: the
    * specified value will be rounded so that the threshold check only depends on the more
@@ -53,6 +55,7 @@
   private static final byte SILENCE_THRESHOLD_LEVEL_MSB = (SILENCE_THRESHOLD_LEVEL + 128) >> 8;
 
   /** Trimming states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     STATE_NOISY,
@@ -102,8 +105,8 @@ public SilenceSkippingAudioProcessor() {
     outputBuffer = EMPTY_BUFFER;
     channelCount = Format.NO_VALUE;
     sampleRateHz = Format.NO_VALUE;
-    maybeSilenceBuffer = new byte[0];
-    paddingBuffer = new byte[0];
+    maybeSilenceBuffer = Util.EMPTY_BYTE_ARRAY;
+    paddingBuffer = Util.EMPTY_BYTE_ARRAY;
   }
 
   /**
@@ -234,8 +237,8 @@ public void reset() {
     channelCount = Format.NO_VALUE;
     sampleRateHz = Format.NO_VALUE;
     paddingSize = 0;
-    maybeSilenceBuffer = new byte[0];
-    paddingBuffer = new byte[0];
+    maybeSilenceBuffer = Util.EMPTY_BYTE_ARRAY;
+    paddingBuffer = Util.EMPTY_BYTE_ARRAY;
   }
 
   // Internal methods.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index c404912882..9b6be57e4c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -20,6 +20,7 @@
 import android.os.Looper;
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -42,6 +43,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -57,13 +59,20 @@
  *   <li>Message with type {@link C#MSG_SET_AUDIO_ATTRIBUTES} to set the audio attributes. The
  *       message payload should be an {@link com.google.android.exoplayer2.audio.AudioAttributes}
  *       instance that will configure the underlying audio track.
+ *   <li>Message with type {@link C#MSG_SET_AUX_EFFECT_INFO} to set the auxiliary effect. The
+ *       message payload should be an {@link AuxEffectInfo} instance that will configure the
+ *       underlying audio track.
  * </ul>
  */
 public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReinitializationState {}
   /**
    * The decoder does not need to be re-initialized.
@@ -121,7 +130,9 @@ public SimpleDecoderAudioRenderer() {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+  public SimpleDecoderAudioRenderer(
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
       AudioProcessor... audioProcessors) {
     this(
         eventHandler,
@@ -139,8 +150,10 @@ public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListen
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities) {
+  public SimpleDecoderAudioRenderer(
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      @Nullable AudioCapabilities audioCapabilities) {
     this(
         eventHandler,
         eventListener,
@@ -164,9 +177,13 @@ public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListen
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys, AudioProcessor... audioProcessors) {
+  public SimpleDecoderAudioRenderer(
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      @Nullable AudioCapabilities audioCapabilities,
+      @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      AudioProcessor... audioProcessors) {
     this(eventHandler, eventListener, drmSessionManager,
         playClearSamplesWithoutKeys, new DefaultAudioSink(audioCapabilities, audioProcessors));
   }
@@ -184,8 +201,11 @@ public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListen
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    * @param audioSink The sink to which audio will be output.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys,
+  public SimpleDecoderAudioRenderer(
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
       AudioSink audioSink) {
     super(C.TRACK_TYPE_AUDIO);
     this.drmSessionManager = drmSessionManager;
@@ -206,6 +226,9 @@ public MediaClock getMediaClock() {
 
   @Override
   public final int supportsFormat(Format format) {
+    if (!MimeTypes.isAudio(format.sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_TYPE;
+    }
     int formatSupport = supportsFormatInternal(drmSessionManager, format);
     if (formatSupport <= FORMAT_UNSUPPORTED_DRM) {
       return formatSupport;
@@ -215,24 +238,23 @@ public final int supportsFormat(Format format) {
   }
 
   /**
-   * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for
-   * {@link #supportsFormat(Format)}.
+   * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for {@link
+   * #supportsFormat(Format)}.
    *
    * @param drmSessionManager The renderer's {@link DrmSessionManager}.
-   * @param format The format.
+   * @param format The format, which has an audio {@link Format#sampleMimeType}.
    * @return The extent to which the renderer supports the format itself.
    */
-  protected abstract int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
-      Format format);
+  protected abstract int supportsFormatInternal(
+      DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format);
 
   /**
-   * Returns whether the audio sink can accept audio in the specified encoding.
+   * Returns whether the sink supports the audio format.
    *
-   * @param encoding The audio encoding.
-   * @return Whether the audio sink can accept audio in the specified encoding.
+   * @see AudioSink#supportsOutput(int, int)
    */
-  protected final boolean supportsOutputEncoding(@C.Encoding int encoding) {
-    return audioSink.isEncodingSupported(encoding);
+  protected final boolean supportsOutput(int channelCount, @C.Encoding int encoding) {
+    return audioSink.supportsOutput(channelCount, encoding);
   }
 
   @Override
@@ -566,7 +588,7 @@ protected void onDisabled() {
   }
 
   @Override
-  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+  public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
     switch (messageType) {
       case C.MSG_SET_VOLUME:
         audioSink.setVolume((Float) message);
@@ -575,6 +597,10 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
         AudioAttributes audioAttributes = (AudioAttributes) message;
         audioSink.setAudioAttributes(audioAttributes);
         break;
+      case C.MSG_SET_AUX_EFFECT_INFO:
+        AuxEffectInfo auxEffectInfo = (AuxEffectInfo) message;
+        audioSink.setAuxEffectInfo(auxEffectInfo);
+        break;
       default:
         super.handleMessage(messageType, message);
         break;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
new file mode 100644
index 0000000000..0072b7c2a3
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Audio processor that outputs its input unmodified and also outputs its input to a given sink.
+ * This is intended to be used for diagnostics and debugging.
+ *
+ * <p>This audio processor can be inserted into the audio processor chain to access audio data
+ * before/after particular processing steps have been applied. For example, to get audio output
+ * after playback speed adjustment and silence skipping have been applied it is necessary to pass a
+ * custom {@link com.google.android.exoplayer2.audio.DefaultAudioSink.AudioProcessorChain} when
+ * creating the audio sink, and include this audio processor after all other audio processors.
+ */
+public final class TeeAudioProcessor implements AudioProcessor {
+
+  /** A sink for audio buffers handled by the audio processor. */
+  public interface AudioBufferSink {
+
+    /** Called when the audio processor is flushed with a format of subsequent input. */
+    void flush(int sampleRateHz, int channelCount, @C.Encoding int encoding);
+
+    /**
+     * Called when data is written to the audio processor.
+     *
+     * @param buffer A read-only buffer containing input which the audio processor will handle.
+     */
+    void handleBuffer(ByteBuffer buffer);
+  }
+
+  private final AudioBufferSink audioBufferSink;
+
+  private int sampleRateHz;
+  private int channelCount;
+  private @C.Encoding int encoding;
+  private boolean isActive;
+
+  private ByteBuffer buffer;
+  private ByteBuffer outputBuffer;
+  private boolean inputEnded;
+
+  /**
+   * Creates a new tee audio processor, sending incoming data to the given {@link AudioBufferSink}.
+   *
+   * @param audioBufferSink The audio buffer sink that will receive input queued to this audio
+   *     processor.
+   */
+  public TeeAudioProcessor(AudioBufferSink audioBufferSink) {
+    this.audioBufferSink = Assertions.checkNotNull(audioBufferSink);
+
+    buffer = EMPTY_BUFFER;
+    outputBuffer = EMPTY_BUFFER;
+    channelCount = Format.NO_VALUE;
+    sampleRateHz = Format.NO_VALUE;
+  }
+
+  @Override
+  public boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+      throws UnhandledFormatException {
+    this.sampleRateHz = sampleRateHz;
+    this.channelCount = channelCount;
+    this.encoding = encoding;
+    boolean wasActive = isActive;
+    isActive = true;
+    return !wasActive;
+  }
+
+  @Override
+  public boolean isActive() {
+    return isActive;
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return channelCount;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return encoding;
+  }
+
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
+  @Override
+  public void queueInput(ByteBuffer buffer) {
+    int remaining = buffer.remaining();
+    if (remaining == 0) {
+      return;
+    }
+
+    audioBufferSink.handleBuffer(buffer.asReadOnlyBuffer());
+
+    if (this.buffer.capacity() < remaining) {
+      this.buffer = ByteBuffer.allocateDirect(remaining).order(ByteOrder.nativeOrder());
+    } else {
+      this.buffer.clear();
+    }
+
+    this.buffer.put(buffer);
+
+    this.buffer.flip();
+    outputBuffer = this.buffer;
+  }
+
+  @Override
+  public void queueEndOfStream() {
+    inputEnded = true;
+  }
+
+  @Override
+  public ByteBuffer getOutput() {
+    ByteBuffer outputBuffer = this.outputBuffer;
+    this.outputBuffer = EMPTY_BUFFER;
+    return outputBuffer;
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  @Override
+  public boolean isEnded() {
+    return inputEnded && buffer == EMPTY_BUFFER;
+  }
+
+  @Override
+  public void flush() {
+    outputBuffer = EMPTY_BUFFER;
+    inputEnded = false;
+
+    audioBufferSink.flush(sampleRateHz, channelCount, encoding);
+  }
+
+  @Override
+  public void reset() {
+    flush();
+    buffer = EMPTY_BUFFER;
+    sampleRateHz = Format.NO_VALUE;
+    channelCount = Format.NO_VALUE;
+    encoding = Format.NO_VALUE;
+  }
+
+  /**
+   * A sink for audio buffers that writes output audio as .wav files with a given path prefix. When
+   * new audio data is handled after flushing the audio processor, a counter is incremented and its
+   * value is appended to the output file name.
+   *
+   * <p>Note: if writing to external storage it's necessary to grant the {@code
+   * WRITE_EXTERNAL_STORAGE} permission.
+   */
+  public static final class WavFileAudioBufferSink implements AudioBufferSink {
+
+    private static final String TAG = "WaveFileAudioBufferSink";
+
+    private static final int FILE_SIZE_MINUS_8_OFFSET = 4;
+    private static final int FILE_SIZE_MINUS_44_OFFSET = 40;
+    private static final int HEADER_LENGTH = 44;
+
+    private final String outputFileNamePrefix;
+    private final byte[] scratchBuffer;
+    private final ByteBuffer scratchByteBuffer;
+
+    private int sampleRateHz;
+    private int channelCount;
+    private @C.Encoding int encoding;
+    private @Nullable RandomAccessFile randomAccessFile;
+    private int counter;
+    private int bytesWritten;
+
+    /**
+     * Creates a new audio buffer sink that writes to .wav files with the given prefix.
+     *
+     * @param outputFileNamePrefix The prefix for output files.
+     */
+    public WavFileAudioBufferSink(String outputFileNamePrefix) {
+      this.outputFileNamePrefix = outputFileNamePrefix;
+      scratchBuffer = new byte[1024];
+      scratchByteBuffer = ByteBuffer.wrap(scratchBuffer).order(ByteOrder.LITTLE_ENDIAN);
+    }
+
+    @Override
+    public void flush(int sampleRateHz, int channelCount, int encoding) {
+      try {
+        reset();
+      } catch (IOException e) {
+        Log.e(TAG, "Error resetting", e);
+      }
+      this.sampleRateHz = sampleRateHz;
+      this.channelCount = channelCount;
+      this.encoding = encoding;
+    }
+
+    @Override
+    public void handleBuffer(ByteBuffer buffer) {
+      try {
+        maybePrepareFile();
+        writeBuffer(buffer);
+      } catch (IOException e) {
+        Log.e(TAG, "Error writing data", e);
+      }
+    }
+
+    private void maybePrepareFile() throws IOException {
+      if (randomAccessFile != null) {
+        return;
+      }
+      RandomAccessFile randomAccessFile = new RandomAccessFile(getNextOutputFileName(), "rw");
+      writeFileHeader(randomAccessFile);
+      this.randomAccessFile = randomAccessFile;
+      bytesWritten = HEADER_LENGTH;
+    }
+
+    private void writeFileHeader(RandomAccessFile randomAccessFile) throws IOException {
+      // Write the start of the header as big endian data.
+      randomAccessFile.writeInt(WavUtil.RIFF_FOURCC);
+      randomAccessFile.writeInt(-1);
+      randomAccessFile.writeInt(WavUtil.WAVE_FOURCC);
+      randomAccessFile.writeInt(WavUtil.FMT_FOURCC);
+
+      // Write the rest of the header as little endian data.
+      scratchByteBuffer.clear();
+      scratchByteBuffer.putInt(16);
+      scratchByteBuffer.putShort((short) WavUtil.getTypeForEncoding(encoding));
+      scratchByteBuffer.putShort((short) channelCount);
+      scratchByteBuffer.putInt(sampleRateHz);
+      int bytesPerSample = Util.getPcmFrameSize(encoding, channelCount);
+      scratchByteBuffer.putInt(bytesPerSample * sampleRateHz);
+      scratchByteBuffer.putShort((short) bytesPerSample);
+      scratchByteBuffer.putShort((short) (8 * bytesPerSample / channelCount));
+      randomAccessFile.write(scratchBuffer, 0, scratchByteBuffer.position());
+
+      // Write the start of the data chunk as big endian data.
+      randomAccessFile.writeInt(WavUtil.DATA_FOURCC);
+      randomAccessFile.writeInt(-1);
+    }
+
+    private void writeBuffer(ByteBuffer buffer) throws IOException {
+      RandomAccessFile randomAccessFile = Assertions.checkNotNull(this.randomAccessFile);
+      while (buffer.hasRemaining()) {
+        int bytesToWrite = Math.min(buffer.remaining(), scratchBuffer.length);
+        buffer.get(scratchBuffer, 0, bytesToWrite);
+        randomAccessFile.write(scratchBuffer, 0, bytesToWrite);
+        bytesWritten += bytesToWrite;
+      }
+    }
+
+    private void reset() throws IOException {
+      RandomAccessFile randomAccessFile = this.randomAccessFile;
+      if (randomAccessFile == null) {
+        return;
+      }
+
+      try {
+        scratchByteBuffer.clear();
+        scratchByteBuffer.putInt(bytesWritten - 8);
+        randomAccessFile.seek(FILE_SIZE_MINUS_8_OFFSET);
+        randomAccessFile.write(scratchBuffer, 0, 4);
+
+        scratchByteBuffer.clear();
+        scratchByteBuffer.putInt(bytesWritten - 44);
+        randomAccessFile.seek(FILE_SIZE_MINUS_44_OFFSET);
+        randomAccessFile.write(scratchBuffer, 0, 4);
+      } catch (IOException e) {
+        // The file may still be playable, so just log a warning.
+        Log.w(TAG, "Error updating file size", e);
+      }
+
+      try {
+        randomAccessFile.close();
+      } finally {
+        this.randomAccessFile = null;
+      }
+    }
+
+    private String getNextOutputFileName() {
+      return Util.formatInvariant("%s-%04d.wav", outputFileNamePrefix, counter++);
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
index ccaa9c3fed..7b66bd63d2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
@@ -25,11 +25,15 @@
 /** Audio processor for trimming samples from the start/end of data. */
 /* package */ final class TrimmingAudioProcessor implements AudioProcessor {
 
+  private static final int OUTPUT_ENCODING = C.ENCODING_PCM_16BIT;
+
   private boolean isActive;
   private int trimStartFrames;
   private int trimEndFrames;
   private int channelCount;
   private int sampleRateHz;
+  private int bytesPerFrame;
+  private boolean receivedInputSinceConfigure;
 
   private int pendingTrimStartBytes;
   private ByteBuffer buffer;
@@ -37,6 +41,7 @@
   private byte[] endBuffer;
   private int endBufferSize;
   private boolean inputEnded;
+  private long trimmedFrameCount;
 
   /** Creates a new audio processor for trimming samples from the start/end of data. */
   public TrimmingAudioProcessor() {
@@ -44,7 +49,7 @@ public TrimmingAudioProcessor() {
     outputBuffer = EMPTY_BUFFER;
     channelCount = Format.NO_VALUE;
     sampleRateHz = Format.NO_VALUE;
-    endBuffer = new byte[0];
+    endBuffer = Util.EMPTY_BYTE_ARRAY;
   }
 
   /**
@@ -61,19 +66,37 @@ public void setTrimFrameCount(int trimStartFrames, int trimEndFrames) {
     this.trimEndFrames = trimEndFrames;
   }
 
+  /** Sets the trimmed frame count returned by {@link #getTrimmedFrameCount()} to zero. */
+  public void resetTrimmedFrameCount() {
+    trimmedFrameCount = 0;
+  }
+
+  /**
+   * Returns the number of audio frames trimmed since the last call to {@link
+   * #resetTrimmedFrameCount()}.
+   */
+  public long getTrimmedFrameCount() {
+    return trimmedFrameCount;
+  }
+
   @Override
   public boolean configure(int sampleRateHz, int channelCount, @Encoding int encoding)
       throws UnhandledFormatException {
-    if (encoding != C.ENCODING_PCM_16BIT) {
+    if (encoding != OUTPUT_ENCODING) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
+    if (endBufferSize > 0) {
+      trimmedFrameCount += endBufferSize / bytesPerFrame;
+    }
     this.channelCount = channelCount;
     this.sampleRateHz = sampleRateHz;
-    endBuffer = new byte[trimEndFrames * channelCount * 2];
+    bytesPerFrame = Util.getPcmFrameSize(OUTPUT_ENCODING, channelCount);
+    endBuffer = new byte[trimEndFrames * bytesPerFrame];
     endBufferSize = 0;
-    pendingTrimStartBytes = trimStartFrames * channelCount * 2;
+    pendingTrimStartBytes = trimStartFrames * bytesPerFrame;
     boolean wasActive = isActive;
     isActive = trimStartFrames != 0 || trimEndFrames != 0;
+    receivedInputSinceConfigure = false;
     return wasActive != isActive;
   }
 
@@ -89,7 +112,7 @@ public int getOutputChannelCount() {
 
   @Override
   public int getOutputEncoding() {
-    return C.ENCODING_PCM_16BIT;
+    return OUTPUT_ENCODING;
   }
 
   @Override
@@ -103,8 +126,14 @@ public void queueInput(ByteBuffer inputBuffer) {
     int limit = inputBuffer.limit();
     int remaining = limit - position;
 
+    if (remaining == 0) {
+      return;
+    }
+    receivedInputSinceConfigure = true;
+
     // Trim any pending start bytes from the input buffer.
     int trimBytes = Math.min(remaining, pendingTrimStartBytes);
+    trimmedFrameCount += trimBytes / bytesPerFrame;
     pendingTrimStartBytes -= trimBytes;
     inputBuffer.position(position + trimBytes);
     if (pendingTrimStartBytes > 0) {
@@ -151,9 +180,26 @@ public void queueEndOfStream() {
     inputEnded = true;
   }
 
+  @SuppressWarnings("ReferenceEquality")
   @Override
   public ByteBuffer getOutput() {
     ByteBuffer outputBuffer = this.outputBuffer;
+    if (inputEnded && endBufferSize > 0 && outputBuffer == EMPTY_BUFFER) {
+      // Because audio processors may be drained in the middle of the stream we assume that the
+      // contents of the end buffer need to be output. Gapless transitions don't involve a call to
+      // queueEndOfStream so won't be affected. When audio is actually ending we play the padding
+      // data which is incorrect. This behavior can be fixed once we have the timestamps associated
+      // with input buffers.
+      if (buffer.capacity() < endBufferSize) {
+        buffer = ByteBuffer.allocateDirect(endBufferSize).order(ByteOrder.nativeOrder());
+      } else {
+        buffer.clear();
+      }
+      buffer.put(endBuffer, 0, endBufferSize);
+      endBufferSize = 0;
+      buffer.flip();
+      outputBuffer = buffer;
+    }
     this.outputBuffer = EMPTY_BUFFER;
     return outputBuffer;
   }
@@ -161,16 +207,21 @@ public ByteBuffer getOutput() {
   @SuppressWarnings("ReferenceEquality")
   @Override
   public boolean isEnded() {
-    return inputEnded && outputBuffer == EMPTY_BUFFER;
+    return inputEnded && endBufferSize == 0 && outputBuffer == EMPTY_BUFFER;
   }
 
   @Override
   public void flush() {
     outputBuffer = EMPTY_BUFFER;
     inputEnded = false;
-    // It's no longer necessary to trim any media from the start, but it is necessary to clear the
-    // end buffer and refill it.
-    pendingTrimStartBytes = 0;
+    if (receivedInputSinceConfigure) {
+      // Audio processors are flushed after initial configuration, so we leave the pending trim
+      // start byte count unmodified if the processor was just configured. Otherwise we (possibly
+      // incorrectly) assume that this is a seek to a non-zero position. We should instead check the
+      // timestamp of the first input buffer queued after flushing to decide whether to trim (see
+      // also [Internal: b/77292509]).
+      pendingTrimStartBytes = 0;
+    }
     endBufferSize = 0;
   }
 
@@ -180,7 +231,7 @@ public void reset() {
     buffer = EMPTY_BUFFER;
     channelCount = Format.NO_VALUE;
     sampleRateHz = Format.NO_VALUE;
-    endBuffer = new byte[0];
+    endBuffer = Util.EMPTY_BYTE_ARRAY;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/WavUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/WavUtil.java
new file mode 100644
index 0000000000..473a91fedf
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/WavUtil.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.util.Util;
+
+/** Utilities for handling WAVE files. */
+public final class WavUtil {
+
+  /** Four character code for "RIFF". */
+  public static final int RIFF_FOURCC = Util.getIntegerCodeForString("RIFF");
+  /** Four character code for "WAVE". */
+  public static final int WAVE_FOURCC = Util.getIntegerCodeForString("WAVE");
+  /** Four character code for "fmt ". */
+  public static final int FMT_FOURCC = Util.getIntegerCodeForString("fmt ");
+  /** Four character code for "data". */
+  public static final int DATA_FOURCC = Util.getIntegerCodeForString("data");
+
+  /** WAVE type value for integer PCM audio data. */
+  private static final int TYPE_PCM = 0x0001;
+  /** WAVE type value for float PCM audio data. */
+  private static final int TYPE_FLOAT = 0x0003;
+  /** WAVE type value for 8-bit ITU-T G.711 A-law audio data. */
+  private static final int TYPE_A_LAW = 0x0006;
+  /** WAVE type value for 8-bit ITU-T G.711 mu-law audio data. */
+  private static final int TYPE_MU_LAW = 0x0007;
+  /** WAVE type value for extended WAVE format. */
+  private static final int TYPE_WAVE_FORMAT_EXTENSIBLE = 0xFFFE;
+
+  /** Returns the WAVE type value for the given {@code encoding}. */
+  public static int getTypeForEncoding(@C.PcmEncoding int encoding) {
+    switch (encoding) {
+      case C.ENCODING_PCM_8BIT:
+      case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_PCM_24BIT:
+      case C.ENCODING_PCM_32BIT:
+        return TYPE_PCM;
+      case C.ENCODING_PCM_A_LAW:
+        return TYPE_A_LAW;
+      case C.ENCODING_PCM_MU_LAW:
+        return TYPE_MU_LAW;
+      case C.ENCODING_PCM_FLOAT:
+        return TYPE_FLOAT;
+      case C.ENCODING_INVALID:
+      case Format.NO_VALUE:
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  /** Returns the PCM encoding for the given WAVE {@code type} value. */
+  public static @C.PcmEncoding int getEncodingForType(int type, int bitsPerSample) {
+    switch (type) {
+      case TYPE_PCM:
+      case TYPE_WAVE_FORMAT_EXTENSIBLE:
+        return Util.getPcmEncoding(bitsPerSample);
+      case TYPE_FLOAT:
+        return bitsPerSample == 32 ? C.ENCODING_PCM_FLOAT : C.ENCODING_INVALID;
+      case TYPE_A_LAW:
+        return C.ENCODING_PCM_A_LAW;
+      case TYPE_MU_LAW:
+        return C.ENCODING_PCM_MU_LAW;
+      default:
+        return C.ENCODING_INVALID;
+    }
+  }
+
+  private WavUtil() {
+    // Prevent instantiation.
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index d22a45ce88..983c96f89d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -27,11 +28,17 @@
 public class DecoderInputBuffer extends Buffer {
 
   /**
-   * The buffer replacement mode, which may disable replacement.
+   * The buffer replacement mode, which may disable replacement. One of {@link
+   * #BUFFER_REPLACEMENT_MODE_DISABLED}, {@link #BUFFER_REPLACEMENT_MODE_NORMAL} or {@link
+   * #BUFFER_REPLACEMENT_MODE_DIRECT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({BUFFER_REPLACEMENT_MODE_DISABLED, BUFFER_REPLACEMENT_MODE_NORMAL,
-      BUFFER_REPLACEMENT_MODE_DIRECT})
+  @IntDef({
+    BUFFER_REPLACEMENT_MODE_DISABLED,
+    BUFFER_REPLACEMENT_MODE_NORMAL,
+    BUFFER_REPLACEMENT_MODE_DIRECT
+  })
   public @interface BufferReplacementMode {}
   /**
    * Disallows buffer replacement.
@@ -85,8 +92,8 @@ public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode) {
   /**
    * Ensures that {@link #data} is large enough to accommodate a write of a given length at its
    * current position.
-   * <p>
-   * If the capacity of {@link #data} is sufficient this method does nothing. If the capacity is
+   *
+   * <p>If the capacity of {@link #data} is sufficient this method does nothing. If the capacity is
    * insufficient then an attempt is made to replace {@link #data} with a new {@link ByteBuffer}
    * whose capacity is sufficient. Data up to the current position is copied to the new buffer.
    *
@@ -94,7 +101,7 @@ public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode) {
    * @throws IllegalStateException If there is insufficient capacity to accommodate the write and
    *     the buffer replacement mode of the holder is {@link #BUFFER_REPLACEMENT_MODE_DISABLED}.
    */
-  public void ensureSpaceForWrite(int length) throws IllegalStateException {
+  public void ensureSpaceForWrite(int length) {
     if (data == null) {
       data = createReplacementByteBuffer(length);
       return;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
index 441d3899a3..7e5ae694ce 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
@@ -15,15 +15,16 @@
  */
 package com.google.android.exoplayer2.decoder;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.util.ArrayDeque;
 
-/**
- * Base class for {@link Decoder}s that use their own decode thread.
- */
-public abstract class SimpleDecoder<I extends DecoderInputBuffer, O extends OutputBuffer,
-    E extends Exception> implements Decoder<I, O, E> {
+/** Base class for {@link Decoder}s that use their own decode thread. */
+@SuppressWarnings("UngroupedOverloads")
+public abstract class SimpleDecoder<
+        I extends DecoderInputBuffer, O extends OutputBuffer, E extends Exception>
+    implements Decoder<I, O, E> {
 
   private final Thread decodeThread;
 
@@ -142,7 +143,7 @@ public final void flush() {
         releaseInputBufferInternal(queuedInputBuffers.removeFirst());
       }
       while (!queuedOutputBuffers.isEmpty()) {
-        releaseOutputBufferInternal(queuedOutputBuffers.removeFirst());
+        queuedOutputBuffers.removeFirst().release();
       }
     }
   }
@@ -240,10 +241,10 @@ private boolean decode() throws InterruptedException {
 
     synchronized (lock) {
       if (flushed) {
-        releaseOutputBufferInternal(outputBuffer);
+        outputBuffer.release();
       } else if (outputBuffer.isDecodeOnly()) {
         skippedOutputBufferCount++;
-        releaseOutputBufferInternal(outputBuffer);
+        outputBuffer.release();
       } else {
         outputBuffer.skippedOutputBufferCount = skippedOutputBufferCount;
         skippedOutputBufferCount = 0;
@@ -292,14 +293,13 @@ private void releaseOutputBufferInternal(O outputBuffer) {
    * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
    *
    * @param inputBuffer The buffer to decode.
-   * @param outputBuffer The output buffer to store decoded data. The flag
-   *     {@link C#BUFFER_FLAG_DECODE_ONLY} will be set if the same flag is set on
-   *     {@code inputBuffer}, but may be set/unset as required. If the flag is set when the call
-   *     returns then the output buffer will not be made available to dequeue. The output buffer
-   *     may not have been populated in this case.
+   * @param outputBuffer The output buffer to store decoded data. The flag {@link
+   *     C#BUFFER_FLAG_DECODE_ONLY} will be set if the same flag is set on {@code inputBuffer}, but
+   *     may be set/unset as required. If the flag is set when the call returns then the output
+   *     buffer will not be made available to dequeue. The output buffer may not have been populated
+   *     in this case.
    * @param reset Whether the decoder must be reset before decoding.
    * @return A decoder exception if an error occurred, or null if decoding was successful.
    */
-  protected abstract E decode(I inputBuffer, O outputBuffer, boolean reset);
-
+  protected abstract @Nullable E decode(I inputBuffer, O outputBuffer, boolean reset);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java
index 87dbc7a65c..1c64570f9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.drm;
 
-import android.util.Log;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import org.json.JSONArray;
 import org.json.JSONException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
index c57b023139..0b1b4ba380 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
@@ -22,15 +22,18 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
-import android.util.Log;
+import android.support.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.drm.DefaultDrmSessionEventListener.EventDispatcher;
-import com.google.android.exoplayer2.drm.ExoMediaDrm.DefaultKeyRequest;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
+import com.google.android.exoplayer2.util.EventDispatcher;
+import com.google.android.exoplayer2.util.Log;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.UUID;
 
@@ -75,13 +78,14 @@
   private static final int MSG_KEYS = 1;
   private static final int MAX_LICENSE_DURATION_TO_RENEW = 60;
 
+  /** The DRM scheme datas, or null if this session uses offline keys. */
+  public final @Nullable List<SchemeData> schemeDatas;
+
   private final ExoMediaDrm<T> mediaDrm;
   private final ProvisioningManager<T> provisioningManager;
-  private final byte[] initData;
-  private final String mimeType;
   private final @DefaultDrmSessionManager.Mode int mode;
   private final HashMap<String, String> optionalKeyRequestParameters;
-  private final EventDispatcher eventDispatcher;
+  private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final int initialDrmRequestRetryCount;
 
   /* package */ final MediaDrmCallback callback;
@@ -95,7 +99,10 @@
   private T mediaCrypto;
   private DrmSessionException lastException;
   private byte[] sessionId;
-  private byte[] offlineLicenseKeySetId;
+  private @Nullable byte[] offlineLicenseKeySetId;
+
+  private KeyRequest currentKeyRequest;
+  private ProvisionRequest currentProvisionRequest;
 
   /**
    * Instantiates a new DRM session.
@@ -103,9 +110,11 @@
    * @param uuid The UUID of the drm scheme.
    * @param mediaDrm The media DRM.
    * @param provisioningManager The manager for provisioning.
-   * @param initData The DRM init data.
+   * @param schemeDatas DRM scheme datas for this session, or null if an {@code
+   *     offlineLicenseKeySetId} is provided.
    * @param mode The DRM mode.
-   * @param offlineLicenseKeySetId The offlineLicense KeySetId.
+   * @param offlineLicenseKeySetId The offline license key set identifier, or null when not using
+   *     offline keys.
    * @param optionalKeyRequestParameters The optional key request parameters.
    * @param callback The media DRM callback.
    * @param playbackLooper The playback looper.
@@ -117,20 +126,21 @@ public DefaultDrmSession(
       UUID uuid,
       ExoMediaDrm<T> mediaDrm,
       ProvisioningManager<T> provisioningManager,
-      byte[] initData,
-      String mimeType,
+      @Nullable List<SchemeData> schemeDatas,
       @DefaultDrmSessionManager.Mode int mode,
-      byte[] offlineLicenseKeySetId,
+      @Nullable byte[] offlineLicenseKeySetId,
       HashMap<String, String> optionalKeyRequestParameters,
       MediaDrmCallback callback,
       Looper playbackLooper,
-      EventDispatcher eventDispatcher,
+      EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher,
       int initialDrmRequestRetryCount) {
     this.uuid = uuid;
     this.provisioningManager = provisioningManager;
     this.mediaDrm = mediaDrm;
     this.mode = mode;
     this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+    this.schemeDatas =
+        offlineLicenseKeySetId == null ? Collections.unmodifiableList(schemeDatas) : null;
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.callback = callback;
     this.initialDrmRequestRetryCount = initialDrmRequestRetryCount;
@@ -141,14 +151,6 @@ public DefaultDrmSession(
     requestHandlerThread = new HandlerThread("DrmRequestHandler");
     requestHandlerThread.start();
     postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
-
-    if (offlineLicenseKeySetId == null) {
-      this.initData = initData;
-      this.mimeType = mimeType;
-    } else {
-      this.initData = null;
-      this.mimeType = null;
-    }
   }
 
   // Life cycle.
@@ -177,28 +179,51 @@ public boolean release() {
       requestHandlerThread = null;
       mediaCrypto = null;
       lastException = null;
+      currentKeyRequest = null;
+      currentProvisionRequest = null;
       if (sessionId != null) {
         mediaDrm.closeSession(sessionId);
         sessionId = null;
+        eventDispatcher.dispatch(DefaultDrmSessionEventListener::onDrmSessionReleased);
       }
       return true;
     }
     return false;
   }
 
-  public boolean hasInitData(byte[] initData) {
-    return Arrays.equals(this.initData, initData);
-  }
-
   public boolean hasSessionId(byte[] sessionId) {
     return Arrays.equals(this.sessionId, sessionId);
   }
 
+  @SuppressWarnings("deprecation")
+  public void onMediaDrmEvent(int what) {
+    if (!isOpen()) {
+      return;
+    }
+    switch (what) {
+      case ExoMediaDrm.EVENT_KEY_REQUIRED:
+        doLicense(false);
+        break;
+      case ExoMediaDrm.EVENT_KEY_EXPIRED:
+        // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
+        // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
+        // waiting for key response.
+        onKeysExpired();
+        break;
+      case ExoMediaDrm.EVENT_PROVISION_REQUIRED:
+        state = STATE_OPENED;
+        provisioningManager.provisionRequired(this);
+        break;
+      default:
+        break;
+    }
+  }
+
   // Provisioning implementation.
 
   public void provision() {
-    ProvisionRequest request = mediaDrm.getProvisionRequest();
-    postRequestHandler.obtainMessage(MSG_PROVISION, request, true).sendToTarget();
+    currentProvisionRequest = mediaDrm.getProvisionRequest();
+    postRequestHandler.post(MSG_PROVISION, currentProvisionRequest, /* allowRetry= */ true);
   }
 
   public void onProvisionCompleted() {
@@ -255,6 +280,7 @@ private boolean openInternal(boolean allowProvisioning) {
 
     try {
       sessionId = mediaDrm.openSession();
+      eventDispatcher.dispatch(DefaultDrmSessionEventListener::onDrmSessionAcquired);
       mediaCrypto = mediaDrm.createMediaCrypto(sessionId);
       state = STATE_OPENED;
       return true;
@@ -271,11 +297,12 @@ private boolean openInternal(boolean allowProvisioning) {
     return false;
   }
 
-  private void onProvisionResponse(Object response) {
-    if (state != STATE_OPENING && !isOpen()) {
+  private void onProvisionResponse(Object request, Object response) {
+    if (request != currentProvisionRequest || (state != STATE_OPENING && !isOpen())) {
       // This event is stale.
       return;
     }
+    currentProvisionRequest = null;
 
     if (response instanceof Exception) {
       provisioningManager.onProvisionError((Exception) response);
@@ -309,7 +336,7 @@ private void doLicense(boolean allowRetry) {
             onError(new KeysExpiredException());
           } else {
             state = STATE_OPENED_WITH_KEYS;
-            eventDispatcher.drmKeysRestored();
+            eventDispatcher.dispatch(DefaultDrmSessionEventListener::onDrmKeysRestored);
           }
         }
         break;
@@ -357,23 +384,20 @@ private long getLicenseDurationRemainingSec() {
   private void postKeyRequest(int type, boolean allowRetry) {
     byte[] scope = type == ExoMediaDrm.KEY_TYPE_RELEASE ? offlineLicenseKeySetId : sessionId;
     try {
-      KeyRequest request = mediaDrm.getKeyRequest(scope, initData, mimeType, type,
-          optionalKeyRequestParameters);
-      if (C.CLEARKEY_UUID.equals(uuid)) {
-        request = new DefaultKeyRequest(ClearKeyUtil.adjustRequestData(request.getData()),
-            request.getDefaultUrl());
-      }
-      postRequestHandler.obtainMessage(MSG_KEYS, request, allowRetry).sendToTarget();
+      currentKeyRequest =
+          mediaDrm.getKeyRequest(scope, schemeDatas, type, optionalKeyRequestParameters);
+      postRequestHandler.post(MSG_KEYS, currentKeyRequest, allowRetry);
     } catch (Exception e) {
       onKeysError(e);
     }
   }
 
-  private void onKeyResponse(Object response) {
-    if (!isOpen()) {
+  private void onKeyResponse(Object request, Object response) {
+    if (request != currentKeyRequest || !isOpen()) {
       // This event is stale.
       return;
     }
+    currentKeyRequest = null;
 
     if (response instanceof Exception) {
       onKeysError((Exception) response);
@@ -382,12 +406,9 @@ private void onKeyResponse(Object response) {
 
     try {
       byte[] responseData = (byte[]) response;
-      if (C.CLEARKEY_UUID.equals(uuid)) {
-        responseData = ClearKeyUtil.adjustResponseData(responseData);
-      }
       if (mode == DefaultDrmSessionManager.MODE_RELEASE) {
         mediaDrm.provideKeyResponse(offlineLicenseKeySetId, responseData);
-        eventDispatcher.drmKeysRemoved();
+        eventDispatcher.dispatch(DefaultDrmSessionEventListener::onDrmKeysRestored);
       } else {
         byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, responseData);
         if ((mode == DefaultDrmSessionManager.MODE_DOWNLOAD
@@ -396,7 +417,7 @@ private void onKeyResponse(Object response) {
           offlineLicenseKeySetId = keySetId;
         }
         state = STATE_OPENED_WITH_KEYS;
-        eventDispatcher.drmKeysLoaded();
+        eventDispatcher.dispatch(DefaultDrmSessionEventListener::onDrmKeysLoaded);
       }
     } catch (Exception e) {
       onKeysError(e);
@@ -420,7 +441,7 @@ private void onKeysError(Exception e) {
 
   private void onError(final Exception e) {
     lastException = new DrmSessionException(e);
-    eventDispatcher.drmSessionManagerError(e);
+    eventDispatcher.dispatch(listener -> listener.onDrmSessionManagerError(e));
     if (state != STATE_OPENED_WITH_KEYS) {
       state = STATE_ERROR;
     }
@@ -430,30 +451,7 @@ private boolean isOpen() {
     return state == STATE_OPENED || state == STATE_OPENED_WITH_KEYS;
   }
 
-  @SuppressWarnings("deprecation")
-  public void onMediaDrmEvent(int what) {
-    if (!isOpen()) {
-      return;
-    }
-    switch (what) {
-      case ExoMediaDrm.EVENT_KEY_REQUIRED:
-        doLicense(false);
-        break;
-      case ExoMediaDrm.EVENT_KEY_EXPIRED:
-        // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
-        // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
-        // waiting for key response.
-        onKeysExpired();
-        break;
-      case ExoMediaDrm.EVENT_PROVISION_REQUIRED:
-        state = STATE_OPENED;
-        provisioningManager.provisionRequired(this);
-        break;
-      default:
-        break;
-    }
-
-  }
+  // Internal classes.
 
   @SuppressLint("HandlerLeak")
   private class PostResponseHandler extends Handler {
@@ -464,12 +462,15 @@ public PostResponseHandler(Looper looper) {
 
     @Override
     public void handleMessage(Message msg) {
+      Pair<?, ?> requestAndResponse = (Pair<?, ?>) msg.obj;
+      Object request = requestAndResponse.first;
+      Object response = requestAndResponse.second;
       switch (msg.what) {
         case MSG_PROVISION:
-          onProvisionResponse(msg.obj);
+          onProvisionResponse(request, response);
           break;
         case MSG_KEYS:
-          onKeyResponse(msg.obj);
+          onKeyResponse(request, response);
           break;
         default:
           break;
@@ -486,21 +487,24 @@ public PostRequestHandler(Looper backgroundLooper) {
       super(backgroundLooper);
     }
 
-    Message obtainMessage(int what, Object object, boolean allowRetry) {
-      return obtainMessage(what, allowRetry ? 1 : 0 /* allow retry*/, 0 /* error count */,
-          object);
+    void post(int what, Object request, boolean allowRetry) {
+      int allowRetryInt = allowRetry ? 1 : 0;
+      int errorCount = 0;
+      obtainMessage(what, allowRetryInt, errorCount, request).sendToTarget();
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public void handleMessage(Message msg) {
+      Object request = msg.obj;
       Object response;
       try {
         switch (msg.what) {
           case MSG_PROVISION:
-            response = callback.executeProvisionRequest(uuid, (ProvisionRequest) msg.obj);
+            response = callback.executeProvisionRequest(uuid, (ProvisionRequest) request);
             break;
           case MSG_KEYS:
-            response = callback.executeKeyRequest(uuid, (KeyRequest) msg.obj);
+            response = callback.executeKeyRequest(uuid, (KeyRequest) request);
             break;
           default:
             throw new RuntimeException();
@@ -511,7 +515,7 @@ public void handleMessage(Message msg) {
         }
         response = e;
       }
-      postResponseHandler.obtainMessage(msg.what, response).sendToTarget();
+      postResponseHandler.obtainMessage(msg.what, Pair.create(request, response)).sendToTarget();
     }
 
     private boolean maybeRetryRequest(Message originalMsg) {
@@ -534,5 +538,4 @@ private long getRetryDelayMillis(int errorCount) {
     }
 
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java
index 7cdee7c537..fa5b60e66e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java
@@ -15,14 +15,14 @@
  */
 package com.google.android.exoplayer2.drm;
 
-import android.os.Handler;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.util.Assertions;
-import java.util.concurrent.CopyOnWriteArrayList;
 
 /** Listener of {@link DefaultDrmSessionManager} events. */
 public interface DefaultDrmSessionEventListener {
 
+  /** Called each time a drm session is acquired. */
+  default void onDrmSessionAcquired() {}
+
   /** Called each time keys are loaded. */
   void onDrmKeysLoaded();
 
@@ -46,96 +46,6 @@
   /** Called each time offline keys are removed. */
   void onDrmKeysRemoved();
 
-  /** Dispatches drm events to all registered listeners. */
-  final class EventDispatcher {
-
-    private final CopyOnWriteArrayList<HandlerAndListener> listeners;
-
-    /** Creates event dispatcher. */
-    public EventDispatcher() {
-      listeners = new CopyOnWriteArrayList<>();
-    }
-
-    /** Adds listener to event dispatcher. */
-    public void addListener(Handler handler, DefaultDrmSessionEventListener eventListener) {
-      Assertions.checkArgument(handler != null && eventListener != null);
-      listeners.add(new HandlerAndListener(handler, eventListener));
-    }
-
-    /** Removes listener from event dispatcher. */
-    public void removeListener(DefaultDrmSessionEventListener eventListener) {
-      for (HandlerAndListener handlerAndListener : listeners) {
-        if (handlerAndListener.listener == eventListener) {
-          listeners.remove(handlerAndListener);
-        }
-      }
-    }
-
-    /** Dispatches {@link DefaultDrmSessionEventListener#onDrmKeysLoaded()}. */
-    public void drmKeysLoaded() {
-      for (HandlerAndListener handlerAndListener : listeners) {
-        final DefaultDrmSessionEventListener listener = handlerAndListener.listener;
-        handlerAndListener.handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onDrmKeysLoaded();
-              }
-            });
-      }
-    }
-
-    /** Dispatches {@link DefaultDrmSessionEventListener#onDrmSessionManagerError(Exception)}. */
-    public void drmSessionManagerError(final Exception e) {
-      for (HandlerAndListener handlerAndListener : listeners) {
-        final DefaultDrmSessionEventListener listener = handlerAndListener.listener;
-        handlerAndListener.handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onDrmSessionManagerError(e);
-              }
-            });
-      }
-    }
-
-    /** Dispatches {@link DefaultDrmSessionEventListener#onDrmKeysRestored()}. */
-    public void drmKeysRestored() {
-      for (HandlerAndListener handlerAndListener : listeners) {
-        final DefaultDrmSessionEventListener listener = handlerAndListener.listener;
-        handlerAndListener.handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onDrmKeysRestored();
-              }
-            });
-      }
-    }
-
-    /** Dispatches {@link DefaultDrmSessionEventListener#onDrmKeysRemoved()}. */
-    public void drmKeysRemoved() {
-      for (HandlerAndListener handlerAndListener : listeners) {
-        final DefaultDrmSessionEventListener listener = handlerAndListener.listener;
-        handlerAndListener.handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onDrmKeysRemoved();
-              }
-            });
-      }
-    }
-
-    private static final class HandlerAndListener {
-
-      public final Handler handler;
-      public final DefaultDrmSessionEventListener listener;
-
-      public HandlerAndListener(Handler handler, DefaultDrmSessionEventListener eventListener) {
-        this.handler = handler;
-        this.listener = eventListener;
-      }
-    }
-  }
+  /** Called each time a drm session is released. */
+  default void onDrmSessionReleased() {}
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 66c9e5cde7..6062a6652a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -23,17 +23,16 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.text.TextUtils;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DefaultDrmSession.ProvisioningManager;
-import com.google.android.exoplayer2.drm.DefaultDrmSessionEventListener.EventDispatcher;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.OnEventListener;
-import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.EventDispatcher;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -68,7 +67,11 @@ private MissingSchemeDataException(UUID uuid) {
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
 
-  /** Determines the action to be done after a session acquired. */
+  /**
+   * Determines the action to be done after a session acquired. One of {@link #MODE_PLAYBACK},
+   * {@link #MODE_QUERY}, {@link #MODE_DOWNLOAD} or {@link #MODE_RELEASE}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({MODE_PLAYBACK, MODE_QUERY, MODE_DOWNLOAD, MODE_RELEASE})
   public @interface Mode {}
@@ -89,13 +92,12 @@ private MissingSchemeDataException(UUID uuid) {
   public static final int INITIAL_DRM_REQUEST_RETRY_COUNT = 3;
 
   private static final String TAG = "DefaultDrmSessionMgr";
-  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
 
   private final UUID uuid;
   private final ExoMediaDrm<T> mediaDrm;
   private final MediaDrmCallback callback;
   private final HashMap<String, String> optionalKeyRequestParameters;
-  private final EventDispatcher eventDispatcher;
+  private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final boolean multiSession;
   private final int initialDrmRequestRetryCount;
 
@@ -132,7 +134,7 @@ private MissingSchemeDataException(UUID uuid) {
    *
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
@@ -208,7 +210,7 @@ private MissingSchemeDataException(UUID uuid) {
    * @param uuid The UUID of the drm scheme.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
@@ -246,7 +248,7 @@ public DefaultDrmSessionManager(
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    */
   public DefaultDrmSessionManager(
       UUID uuid,
@@ -286,7 +288,7 @@ public DefaultDrmSessionManager(
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @param multiSession A boolean that specify whether multiple key session support is enabled.
    *     Default is false.
    */
@@ -336,7 +338,7 @@ public DefaultDrmSessionManager(
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @param multiSession A boolean that specify whether multiple key session support is enabled.
    *     Default is false.
    * @param initialDrmRequestRetryCount The number of times to retry for initial provisioning and
@@ -356,13 +358,17 @@ public DefaultDrmSessionManager(
     this.mediaDrm = mediaDrm;
     this.callback = callback;
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
-    this.eventDispatcher = new EventDispatcher();
+    this.eventDispatcher = new EventDispatcher<>();
     this.multiSession = multiSession;
     this.initialDrmRequestRetryCount = initialDrmRequestRetryCount;
     mode = MODE_PLAYBACK;
     sessions = new ArrayList<>();
     provisioningSessions = new ArrayList<>();
-    if (multiSession) {
+    if (multiSession && C.WIDEVINE_UUID.equals(uuid) && Util.SDK_INT >= 19) {
+      // TODO: Enabling session sharing probably doesn't do anything useful here. It would only be
+      // useful if DefaultDrmSession instances were aware of one another's state, which is not
+      // implemented. Or if custom renderers are being used that allow playback to proceed before
+      // keys, which seems unlikely to be true in practice.
       mediaDrm.setPropertyString("sessionSharing", "enable");
     }
     mediaDrm.setOnEventListener(new MediaDrmEventListener());
@@ -474,8 +480,8 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
       // An offline license can be restored so a session can always be acquired.
       return true;
     }
-    SchemeData schemeData = getSchemeData(drmInitData, uuid, true);
-    if (schemeData == null) {
+    List<SchemeData> schemeDatas = getSchemeDatas(drmInitData, uuid, true);
+    if (schemeDatas.isEmpty()) {
       if (drmInitData.schemeDataCount == 1 && drmInitData.get(0).matches(C.COMMON_PSSH_UUID)) {
         // Assume scheme specific data will be added before the session is opened.
         Log.w(
@@ -509,17 +515,14 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
       }
     }
 
-    byte[] initData = null;
-    String mimeType = null;
+    List<SchemeData> schemeDatas = null;
     if (offlineLicenseKeySetId == null) {
-      SchemeData data = getSchemeData(drmInitData, uuid, false);
-      if (data == null) {
+      schemeDatas = getSchemeDatas(drmInitData, uuid, false);
+      if (schemeDatas.isEmpty()) {
         final MissingSchemeDataException error = new MissingSchemeDataException(uuid);
-        eventDispatcher.drmSessionManagerError(error);
+        eventDispatcher.dispatch(listener -> listener.onDrmSessionManagerError(error));
         return new ErrorStateDrmSession<>(new DrmSessionException(error));
       }
-      initData = getSchemeInitData(data, uuid);
-      mimeType = getSchemeMimeType(data, uuid);
     }
 
     DefaultDrmSession<T> session;
@@ -529,7 +532,7 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
       // Only use an existing session if it has matching init data.
       session = null;
       for (DefaultDrmSession<T> existingSession : sessions) {
-        if (existingSession.hasInitData(initData)) {
+        if (Util.areEqual(existingSession.schemeDatas, schemeDatas)) {
           session = existingSession;
           break;
         }
@@ -543,8 +546,7 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
               uuid,
               mediaDrm,
               this,
-              initData,
-              mimeType,
+              schemeDatas,
               mode,
               offlineLicenseKeySetId,
               optionalKeyRequestParameters,
@@ -607,16 +609,17 @@ public void onProvisionError(Exception error) {
   // Internal methods.
 
   /**
-   * Extracts {@link SchemeData} suitable for the given DRM scheme {@link UUID}.
+   * Extracts {@link SchemeData} instances suitable for the given DRM scheme {@link UUID}.
    *
    * @param drmInitData The {@link DrmInitData} from which to extract the {@link SchemeData}.
    * @param uuid The UUID.
    * @param allowMissingData Whether a {@link SchemeData} with null {@link SchemeData#data} may be
    *     returned.
-   * @return The extracted {@link SchemeData}, or null if no suitable data is present.
+   * @return The extracted {@link SchemeData} instances, or an empty list if no suitable data is
+   *     present.
    */
-  private static SchemeData getSchemeData(DrmInitData drmInitData, UUID uuid,
-      boolean allowMissingData) {
+  private static List<SchemeData> getSchemeDatas(
+      DrmInitData drmInitData, UUID uuid, boolean allowMissingData) {
     // Look for matching scheme data (matching the Common PSSH box for ClearKey).
     List<SchemeData> matchingSchemeDatas = new ArrayList<>(drmInitData.schemeDataCount);
     for (int i = 0; i < drmInitData.schemeDataCount; i++) {
@@ -627,52 +630,7 @@ private static SchemeData getSchemeData(DrmInitData drmInitData, UUID uuid,
         matchingSchemeDatas.add(schemeData);
       }
     }
-
-    if (matchingSchemeDatas.isEmpty()) {
-      return null;
-    }
-
-    // For Widevine PSSH boxes, prefer V1 boxes from API 23 and V0 before.
-    if (C.WIDEVINE_UUID.equals(uuid)) {
-      for (int i = 0; i < matchingSchemeDatas.size(); i++) {
-        SchemeData matchingSchemeData = matchingSchemeDatas.get(i);
-        int version = matchingSchemeData.hasData()
-            ? PsshAtomUtil.parseVersion(matchingSchemeData.data) : -1;
-        if (Util.SDK_INT < 23 && version == 0) {
-          return matchingSchemeData;
-        } else if (Util.SDK_INT >= 23 && version == 1) {
-          return matchingSchemeData;
-        }
-      }
-    }
-
-    // If we don't have any special handling, prefer the first matching scheme data.
-    return matchingSchemeDatas.get(0);
-  }
-
-  private static byte[] getSchemeInitData(SchemeData data, UUID uuid) {
-    byte[] schemeInitData = data.data;
-    if (Util.SDK_INT < 21) {
-      // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
-      byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData, uuid);
-      if (psshData == null) {
-        // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
-      } else {
-        schemeInitData = psshData;
-      }
-    }
-    return schemeInitData;
-  }
-
-  private static String getSchemeMimeType(SchemeData data, UUID uuid) {
-    String schemeMimeType = data.mimeType;
-    if (Util.SDK_INT < 26 && C.CLEARKEY_UUID.equals(uuid)
-        && (MimeTypes.VIDEO_MP4.equals(schemeMimeType)
-        || MimeTypes.AUDIO_MP4.equals(schemeMimeType))) {
-      // Prior to API level 26 the ClearKey CDM only accepted "cenc" as the scheme for MP4.
-      schemeMimeType = CENC_SCHEME_MIME_TYPE;
-    }
-    return schemeMimeType;
+    return matchingSchemeDatas;
   }
 
   @SuppressLint("HandlerLeak")
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
index c2de662010..b9415c74af 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
@@ -266,9 +266,9 @@ private static boolean containsSchemeDataWithUuid(
      * applies to all schemes).
      */
     private final UUID uuid;
-    /**
-     * The mimeType of {@link #data}.
-     */
+    /** The URL of the server to which license requests should be made. May be null if unknown. */
+    public final @Nullable String licenseServerUrl;
+    /** The mimeType of {@link #data}. */
     public final String mimeType;
     /**
      * The initialization data. May be null for scheme support checks only.
@@ -297,7 +297,25 @@ public SchemeData(UUID uuid, String mimeType, byte[] data) {
      * @param requiresSecureDecryption See {@link #requiresSecureDecryption}.
      */
     public SchemeData(UUID uuid, String mimeType, byte[] data, boolean requiresSecureDecryption) {
+      this(uuid, /* licenseServerUrl= */ null, mimeType, data, requiresSecureDecryption);
+    }
+
+    /**
+     * @param uuid The {@link UUID} of the DRM scheme, or {@link C#UUID_NIL} if the data is
+     *     universal (i.e. applies to all schemes).
+     * @param licenseServerUrl See {@link #licenseServerUrl}.
+     * @param mimeType See {@link #mimeType}.
+     * @param data See {@link #data}.
+     * @param requiresSecureDecryption See {@link #requiresSecureDecryption}.
+     */
+    public SchemeData(
+        UUID uuid,
+        @Nullable String licenseServerUrl,
+        String mimeType,
+        byte[] data,
+        boolean requiresSecureDecryption) {
       this.uuid = Assertions.checkNotNull(uuid);
+      this.licenseServerUrl = licenseServerUrl;
       this.mimeType = Assertions.checkNotNull(mimeType);
       this.data = data;
       this.requiresSecureDecryption = requiresSecureDecryption;
@@ -305,6 +323,7 @@ public SchemeData(UUID uuid, String mimeType, byte[] data, boolean requiresSecur
 
     /* package */ SchemeData(Parcel in) {
       uuid = new UUID(in.readLong(), in.readLong());
+      licenseServerUrl = in.readString();
       mimeType = in.readString();
       data = in.createByteArray();
       requiresSecureDecryption = in.readByte() != 0;
@@ -337,6 +356,16 @@ public boolean hasData() {
       return data != null;
     }
 
+    /**
+     * Returns a copy of this instance with the specified data.
+     *
+     * @param data The data to include in the copy.
+     * @return The new instance.
+     */
+    public SchemeData copyWithData(@Nullable byte[] data) {
+      return new SchemeData(uuid, licenseServerUrl, mimeType, data, requiresSecureDecryption);
+    }
+
     @Override
     public boolean equals(@Nullable Object obj) {
       if (!(obj instanceof SchemeData)) {
@@ -346,7 +375,9 @@ public boolean equals(@Nullable Object obj) {
         return true;
       }
       SchemeData other = (SchemeData) obj;
-      return mimeType.equals(other.mimeType) && Util.areEqual(uuid, other.uuid)
+      return Util.areEqual(licenseServerUrl, other.licenseServerUrl)
+          && Util.areEqual(mimeType, other.mimeType)
+          && Util.areEqual(uuid, other.uuid)
           && Arrays.equals(data, other.data);
     }
 
@@ -354,6 +385,7 @@ public boolean equals(@Nullable Object obj) {
     public int hashCode() {
       if (hashCode == 0) {
         int result = uuid.hashCode();
+        result = 31 * result + (licenseServerUrl == null ? 0 : licenseServerUrl.hashCode());
         result = 31 * result + mimeType.hashCode();
         result = 31 * result + Arrays.hashCode(data);
         hashCode = result;
@@ -372,6 +404,7 @@ public int describeContents() {
     public void writeToParcel(Parcel dest, int flags) {
       dest.writeLong(uuid.getMostSignificantBits());
       dest.writeLong(uuid.getLeastSignificantBits());
+      dest.writeString(licenseServerUrl);
       dest.writeString(mimeType);
       dest.writeByteArray(data);
       dest.writeByte((byte) (requiresSecureDecryption ? 1 : 0));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index a3ae1d8b71..f2fbe94895 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -18,6 +18,7 @@
 import android.annotation.TargetApi;
 import android.media.MediaDrm;
 import android.support.annotation.IntDef;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
@@ -40,11 +41,13 @@ public DrmSessionException(Throwable cause) {
   }
 
   /**
-   * The state of the DRM session.
+   * The state of the DRM session. One of {@link #STATE_RELEASED}, {@link #STATE_ERROR}, {@link
+   * #STATE_OPENING}, {@link #STATE_OPENED} or {@link #STATE_OPENED_WITH_KEYS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_RELEASED, STATE_ERROR, STATE_OPENING, STATE_OPENED, STATE_OPENED_WITH_KEYS})
-  public @interface State {}
+  @interface State {}
   /**
    * The session has been released.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
index 2699559c5f..24c3ddbbd0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
@@ -22,6 +22,7 @@
 import android.media.NotProvisionedException;
 import android.os.Handler;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -105,101 +106,63 @@ void onKeyStatusChange(
         boolean hasNewUsableKey);
   }
 
-  /**
-   * @see android.media.MediaDrm.KeyStatus
-   */
-  interface KeyStatus {
-    /** Returns the status code for the key. */
-    int getStatusCode();
-    /** Returns the id for the key. */
-    byte[] getKeyId();
-  }
-
-  /**
-   * Default implementation of {@link KeyStatus}.
-   */
-  final class DefaultKeyStatus implements KeyStatus {
+  /** @see android.media.MediaDrm.KeyStatus */
+  final class KeyStatus {
 
     private final int statusCode;
     private final byte[] keyId;
 
-    DefaultKeyStatus(int statusCode, byte[] keyId) {
+    public KeyStatus(int statusCode, byte[] keyId) {
       this.statusCode = statusCode;
       this.keyId = keyId;
     }
 
-    @Override
     public int getStatusCode() {
       return statusCode;
     }
 
-    @Override
     public byte[] getKeyId() {
       return keyId;
     }
 
   }
 
-  /**
-   * @see android.media.MediaDrm.KeyRequest
-   */
-  interface KeyRequest {
-    byte[] getData();
-    String getDefaultUrl();
-  }
-
-  /**
-   * Default implementation of {@link KeyRequest}.
-   */
-  final class DefaultKeyRequest implements KeyRequest {
+  /** @see android.media.MediaDrm.KeyRequest */
+  final class KeyRequest {
 
     private final byte[] data;
-    private final String defaultUrl;
+    private final String licenseServerUrl;
 
-    public DefaultKeyRequest(byte[] data, String defaultUrl) {
+    public KeyRequest(byte[] data, String licenseServerUrl) {
       this.data = data;
-      this.defaultUrl = defaultUrl;
+      this.licenseServerUrl = licenseServerUrl;
     }
 
-    @Override
     public byte[] getData() {
       return data;
     }
 
-    @Override
-    public String getDefaultUrl() {
-      return defaultUrl;
+    public String getLicenseServerUrl() {
+      return licenseServerUrl;
     }
 
   }
 
-  /**
-   * @see android.media.MediaDrm.ProvisionRequest
-   */
-  interface ProvisionRequest {
-    byte[] getData();
-    String getDefaultUrl();
-  }
-
-  /**
-   * Default implementation of {@link ProvisionRequest}.
-   */
-  final class DefaultProvisionRequest implements ProvisionRequest {
+  /** @see android.media.MediaDrm.ProvisionRequest */
+  final class ProvisionRequest {
 
     private final byte[] data;
     private final String defaultUrl;
 
-    public DefaultProvisionRequest(byte[] data, String defaultUrl) {
+    public ProvisionRequest(byte[] data, String defaultUrl) {
       this.data = data;
       this.defaultUrl = defaultUrl;
     }
 
-    @Override
     public byte[] getData() {
       return data;
     }
 
-    @Override
     public String getDefaultUrl() {
       return defaultUrl;
     }
@@ -226,13 +189,29 @@ public String getDefaultUrl() {
    */
   void closeSession(byte[] sessionId);
 
-  /** @see MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap) */
+  /**
+   * Generates a key request.
+   *
+   * @param scope If {@code keyType} is {@link #KEY_TYPE_STREAMING} or {@link #KEY_TYPE_OFFLINE},
+   *     the session id that the keys will be provided to. If {@code keyType} is {@link
+   *     #KEY_TYPE_RELEASE}, the keySetId of the keys to release.
+   * @param schemeDatas If key type is {@link #KEY_TYPE_STREAMING} or {@link #KEY_TYPE_OFFLINE}, a
+   *     list of {@link SchemeData} instances extracted from the media. Null otherwise.
+   * @param keyType The type of the request. Either {@link #KEY_TYPE_STREAMING} to acquire keys for
+   *     streaming, {@link #KEY_TYPE_OFFLINE} to acquire keys for offline usage, or {@link
+   *     #KEY_TYPE_RELEASE} to release acquired keys. Releasing keys invalidates them for all
+   *     sessions.
+   * @param optionalParameters Are included in the key request message to allow a client application
+   *     to provide additional message parameters to the server. This may be {@code null} if no
+   *     additional parameters are to be sent.
+   * @return The generated key request.
+   * @see MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)
+   */
   KeyRequest getKeyRequest(
       byte[] scope,
-      byte[] init,
-      String mimeType,
+      @Nullable List<SchemeData> schemeDatas,
       int keyType,
-      HashMap<String, String> optionalParameters)
+      @Nullable HashMap<String, String> optionalParameters)
       throws NotProvisionedException;
 
   /** @see MediaDrm#provideKeyResponse(byte[], byte[]) */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index f960cd637f..d2a5b6a0d6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.media.DeniedByServerException;
 import android.media.MediaCrypto;
@@ -23,10 +24,13 @@
 import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
 import android.media.UnsupportedSchemeException;
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -40,6 +44,8 @@
 @TargetApi(23)
 public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto> {
 
+  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
+
   private final UUID uuid;
   private final MediaDrm mediaDrm;
 
@@ -63,22 +69,21 @@ public static FrameworkMediaDrm newInstance(UUID uuid) throws UnsupportedDrmExce
   private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
     Assertions.checkNotNull(uuid);
     Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid), "Use C.CLEARKEY_UUID instead");
-    // ClearKey had to be accessed using the Common PSSH UUID prior to API level 27.
-    uuid = Util.SDK_INT < 27 && C.CLEARKEY_UUID.equals(uuid) ? C.COMMON_PSSH_UUID : uuid;
     this.uuid = uuid;
-    this.mediaDrm = new MediaDrm(uuid);
+    this.mediaDrm = new MediaDrm(adjustUuid(uuid));
+    if (C.WIDEVINE_UUID.equals(uuid) && needsForceWidevineL3Workaround()) {
+      forceWidevineL3(mediaDrm);
+    }
   }
 
   @Override
   public void setOnEventListener(
       final ExoMediaDrm.OnEventListener<? super FrameworkMediaCrypto> listener) {
-    mediaDrm.setOnEventListener(listener == null ? null : new MediaDrm.OnEventListener() {
-      @Override
-      public void onEvent(@NonNull MediaDrm md, @Nullable byte[] sessionId, int event, int extra,
-          byte[] data) {
-        listener.onEvent(FrameworkMediaDrm.this, sessionId, event, extra, data);
-      }
-    });
+    mediaDrm.setOnEventListener(
+        listener == null
+            ? null
+            : (mediaDrm, sessionId, event, extra, data) ->
+                listener.onEvent(FrameworkMediaDrm.this, sessionId, event, extra, data));
   }
 
   @Override
@@ -87,20 +92,19 @@ public void setOnKeyStatusChangeListener(
     if (Util.SDK_INT < 23) {
       throw new UnsupportedOperationException();
     }
-    
-    mediaDrm.setOnKeyStatusChangeListener(listener == null ? null
-        : new MediaDrm.OnKeyStatusChangeListener() {
-          @Override
-          public void onKeyStatusChange(@NonNull MediaDrm md, @NonNull byte[] sessionId,
-              @NonNull List<MediaDrm.KeyStatus> keyInfo, boolean hasNewUsableKey) {
-            List<KeyStatus> exoKeyInfo = new ArrayList<>();
-            for (MediaDrm.KeyStatus keyStatus : keyInfo) {
-              exoKeyInfo.add(new DefaultKeyStatus(keyStatus.getStatusCode(), keyStatus.getKeyId()));
-            }
-            listener.onKeyStatusChange(FrameworkMediaDrm.this, sessionId, exoKeyInfo,
-                hasNewUsableKey);
-          }
-        }, null);
+
+    mediaDrm.setOnKeyStatusChangeListener(
+        listener == null
+            ? null
+            : (mediaDrm, sessionId, keyInfo, hasNewUsableKey) -> {
+              List<KeyStatus> exoKeyInfo = new ArrayList<>();
+              for (MediaDrm.KeyStatus keyStatus : keyInfo) {
+                exoKeyInfo.add(new KeyStatus(keyStatus.getStatusCode(), keyStatus.getKeyId()));
+              }
+              listener.onKeyStatusChange(
+                  FrameworkMediaDrm.this, sessionId, exoKeyInfo, hasNewUsableKey);
+            },
+        null);
   }
 
   @Override
@@ -114,23 +118,49 @@ public void closeSession(byte[] sessionId) {
   }
 
   @Override
-  public KeyRequest getKeyRequest(byte[] scope, byte[] init, String mimeType, int keyType,
-      HashMap<String, String> optionalParameters) throws NotProvisionedException {
-    final MediaDrm.KeyRequest request = mediaDrm.getKeyRequest(scope, init, mimeType, keyType,
-        optionalParameters);
-    return new DefaultKeyRequest(request.getData(), request.getDefaultUrl());
+  public KeyRequest getKeyRequest(
+      byte[] scope,
+      @Nullable List<DrmInitData.SchemeData> schemeDatas,
+      int keyType,
+      @Nullable HashMap<String, String> optionalParameters)
+      throws NotProvisionedException {
+    SchemeData schemeData = null;
+    byte[] initData = null;
+    String mimeType = null;
+    if (schemeDatas != null) {
+      schemeData = getSchemeData(uuid, schemeDatas);
+      initData = adjustRequestInitData(uuid, schemeData.data);
+      mimeType = adjustRequestMimeType(uuid, schemeData.mimeType);
+    }
+    MediaDrm.KeyRequest request =
+        mediaDrm.getKeyRequest(scope, initData, mimeType, keyType, optionalParameters);
+
+    byte[] requestData = adjustRequestData(uuid, request.getData());
+
+    String licenseServerUrl = request.getDefaultUrl();
+    if (TextUtils.isEmpty(licenseServerUrl)
+        && schemeData != null
+        && !TextUtils.isEmpty(schemeData.licenseServerUrl)) {
+      licenseServerUrl = schemeData.licenseServerUrl;
+    }
+
+    return new KeyRequest(requestData, licenseServerUrl);
   }
 
   @Override
   public byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException {
+    if (C.CLEARKEY_UUID.equals(uuid)) {
+      response = ClearKeyUtil.adjustResponseData(response);
+    }
+
     return mediaDrm.provideKeyResponse(scope, response);
   }
 
   @Override
   public ProvisionRequest getProvisionRequest() {
     final MediaDrm.ProvisionRequest request = mediaDrm.getProvisionRequest();
-    return new DefaultProvisionRequest(request.getData(), request.getDefaultUrl());
+    return new ProvisionRequest(request.getData(), request.getDefaultUrl());
   }
 
   @Override
@@ -179,8 +209,114 @@ public FrameworkMediaCrypto createMediaCrypto(byte[] initData) throws MediaCrypt
     // indicate that it required secure video decoders [Internal ref: b/11428937].
     boolean forceAllowInsecureDecoderComponents = Util.SDK_INT < 21
         && C.WIDEVINE_UUID.equals(uuid) && "L3".equals(getPropertyString("securityLevel"));
-    return new FrameworkMediaCrypto(new MediaCrypto(uuid, initData),
-        forceAllowInsecureDecoderComponents);
+    return new FrameworkMediaCrypto(
+        new MediaCrypto(adjustUuid(uuid), initData), forceAllowInsecureDecoderComponents);
+  }
+
+  private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas) {
+    if (!C.WIDEVINE_UUID.equals(uuid)) {
+      // For non-Widevine CDMs always use the first scheme data.
+      return schemeDatas.get(0);
+    }
+
+    if (Util.SDK_INT >= 28 && schemeDatas.size() > 1) {
+      // For API level 28 and above, concatenate multiple PSSH scheme datas if possible.
+      SchemeData firstSchemeData = schemeDatas.get(0);
+      int concatenatedDataLength = 0;
+      boolean canConcatenateData = true;
+      for (int i = 0; i < schemeDatas.size(); i++) {
+        SchemeData schemeData = schemeDatas.get(i);
+        if (schemeData.requiresSecureDecryption == firstSchemeData.requiresSecureDecryption
+            && Util.areEqual(schemeData.mimeType, firstSchemeData.mimeType)
+            && Util.areEqual(schemeData.licenseServerUrl, firstSchemeData.licenseServerUrl)
+            && PsshAtomUtil.isPsshAtom(schemeData.data)) {
+          concatenatedDataLength += schemeData.data.length;
+        } else {
+          canConcatenateData = false;
+          break;
+        }
+      }
+      if (canConcatenateData) {
+        byte[] concatenatedData = new byte[concatenatedDataLength];
+        int concatenatedDataPosition = 0;
+        for (int i = 0; i < schemeDatas.size(); i++) {
+          SchemeData schemeData = schemeDatas.get(i);
+          int schemeDataLength = schemeData.data.length;
+          System.arraycopy(
+              schemeData.data, 0, concatenatedData, concatenatedDataPosition, schemeDataLength);
+          concatenatedDataPosition += schemeDataLength;
+        }
+        return firstSchemeData.copyWithData(concatenatedData);
+      }
+    }
+
+    // For API levels 23 - 27, prefer the first V1 PSSH box. For API levels 22 and earlier, prefer
+    // the first V0 box.
+    for (int i = 0; i < schemeDatas.size(); i++) {
+      SchemeData schemeData = schemeDatas.get(i);
+      int version = PsshAtomUtil.parseVersion(schemeData.data);
+      if (Util.SDK_INT < 23 && version == 0) {
+        return schemeData;
+      } else if (Util.SDK_INT >= 23 && version == 1) {
+        return schemeData;
+      }
+    }
+
+    // If all else fails, use the first scheme data.
+    return schemeDatas.get(0);
+  }
+
+  private static UUID adjustUuid(UUID uuid) {
+    // ClearKey had to be accessed using the Common PSSH UUID prior to API level 27.
+    return Util.SDK_INT < 27 && C.CLEARKEY_UUID.equals(uuid) ? C.COMMON_PSSH_UUID : uuid;
   }
 
+  private static byte[] adjustRequestInitData(UUID uuid, byte[] initData) {
+    // Prior to L the Widevine CDM required data to be extracted from the PSSH atom. Some Amazon
+    // devices also required data to be extracted from the PSSH atom for PlayReady.
+    if ((Util.SDK_INT < 21 && C.WIDEVINE_UUID.equals(uuid))
+        || (C.PLAYREADY_UUID.equals(uuid)
+            && "Amazon".equals(Util.MANUFACTURER)
+            && ("AFTB".equals(Util.MODEL) // Fire TV Gen 1
+                || "AFTS".equals(Util.MODEL) // Fire TV Gen 2
+                || "AFTM".equals(Util.MODEL)))) { // Fire TV Stick Gen 1
+      byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(initData, uuid);
+      if (psshData != null) {
+        // Extraction succeeded, so return the extracted data.
+        return psshData;
+      }
+    }
+    return initData;
+  }
+
+  private static String adjustRequestMimeType(UUID uuid, String mimeType) {
+    // Prior to API level 26 the ClearKey CDM only accepted "cenc" as the scheme for MP4.
+    if (Util.SDK_INT < 26
+        && C.CLEARKEY_UUID.equals(uuid)
+        && (MimeTypes.VIDEO_MP4.equals(mimeType) || MimeTypes.AUDIO_MP4.equals(mimeType))) {
+      return CENC_SCHEME_MIME_TYPE;
+    }
+    return mimeType;
+  }
+
+  private static byte[] adjustRequestData(UUID uuid, byte[] requestData) {
+    if (C.CLEARKEY_UUID.equals(uuid)) {
+      return ClearKeyUtil.adjustRequestData(requestData);
+    }
+    return requestData;
+  }
+
+  @SuppressLint("WrongConstant") // Suppress spurious lint error [Internal ref: b/32137960]
+  private static void forceWidevineL3(MediaDrm mediaDrm) {
+    mediaDrm.setPropertyString("securityLevel", "L3");
+  }
+
+  /**
+   * Returns whether the device codec is known to fail if security level L1 is used.
+   *
+   * <p>See <a href="https://github.com/google/ExoPlayer/issues/4413">GitHub issue #4413</a>.
+   */
+  private static boolean needsForceWidevineL3Workaround() {
+    return "ASUS_Z00AD".equals(Util.MODEL);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
index 9150a72b53..8b8c3bec99 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
@@ -110,12 +110,12 @@ public void clearAllKeyRequestProperties() {
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url =
         request.getDefaultUrl() + "&signedRequest=" + Util.fromUtf8Bytes(request.getData());
-    return executePost(dataSourceFactory, url, new byte[0], null);
+    return executePost(dataSourceFactory, url, Util.EMPTY_BYTE_ARRAY, null);
   }
 
   @Override
   public byte[] executeKeyRequest(UUID uuid, KeyRequest request) throws Exception {
-    String url = request.getDefaultUrl();
+    String url = request.getLicenseServerUrl();
     if (forceDefaultLicenseUrl || TextUtils.isEmpty(url)) {
       url = defaultLicenseUrl;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/MediaDrmCallback.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/MediaDrmCallback.java
index 617e168f9a..5b0ed04f81 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/MediaDrmCallback.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/MediaDrmCallback.java
@@ -43,5 +43,4 @@
    * @throws Exception If an error occurred executing the request.
    */
   byte[] executeKeyRequest(UUID uuid, KeyRequest request) throws Exception;
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
index f0e748d722..7f4a0f5f03 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.drm;
 
 import android.support.annotation.IntDef;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -25,8 +26,10 @@
 public final class UnsupportedDrmException extends Exception {
 
   /**
-   * The reason for the exception.
+   * The reason for the exception. One of {@link #REASON_UNSUPPORTED_SCHEME} or {@link
+   * #REASON_INSTANTIATION_ERROR}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REASON_UNSUPPORTED_SCHEME, REASON_INSTANTIATION_ERROR})
   public @interface Reason {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
new file mode 100644
index 0000000000..e8b6e736ba
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor;
+
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.nio.ByteBuffer;
+
+/**
+ * A seeker that supports seeking within a stream by searching for the target frame using binary
+ * search.
+ *
+ * <p>This seeker operates on a stream that contains multiple frames (or samples). Each frame is
+ * associated with some kind of timestamps, such as stream time, or frame indices. Given a target
+ * seek time, the seeker will find the corresponding target timestamp, and perform a search
+ * operation within the stream to identify the target frame and return the byte position in the
+ * stream of the target frame.
+ */
+public abstract class BinarySearchSeeker {
+
+  /** A seeker that looks for a given timestamp from an input. */
+  protected interface TimestampSeeker {
+
+    /**
+     * Searches a limited window of the provided input for a target timestamp. The size of the
+     * window is implementation specific, but should be small enough such that it's reasonable for
+     * multiple such reads to occur during a seek operation.
+     *
+     * @param input The {@link ExtractorInput} from which data should be peeked.
+     * @param targetTimestamp The target timestamp.
+     * @param outputFrameHolder If {@link TimestampSearchResult#TYPE_TARGET_TIMESTAMP_FOUND} is
+     *     returned, this holder may be updated to hold the extracted frame that contains the target
+     *     frame/sample associated with the target timestamp.
+     * @return A {@link TimestampSearchResult} that describes the result of the search.
+     * @throws IOException If an error occurred reading from the input.
+     * @throws InterruptedException If the thread was interrupted.
+     */
+    TimestampSearchResult searchForTimestamp(
+        ExtractorInput input, long targetTimestamp, OutputFrameHolder outputFrameHolder)
+        throws IOException, InterruptedException;
+
+    /** Called when a seek operation finishes. */
+    default void onSeekFinished() {}
+  }
+
+  /**
+   * Holds a frame extracted from a stream, together with the time stamp of the frame in
+   * microseconds.
+   */
+  public static final class OutputFrameHolder {
+
+    public long timeUs;
+    public ByteBuffer byteBuffer;
+
+    /** Constructs an instance, wrapping the given byte buffer. */
+    public OutputFrameHolder(ByteBuffer outputByteBuffer) {
+      this.timeUs = 0;
+      this.byteBuffer = outputByteBuffer;
+    }
+  }
+
+  /**
+   * A {@link SeekTimestampConverter} implementation that returns the seek time itself as the
+   * timestamp for a seek time position.
+   */
+  public static final class DefaultSeekTimestampConverter implements SeekTimestampConverter {
+
+    @Override
+    public long timeUsToTargetTime(long timeUs) {
+      return timeUs;
+    }
+  }
+
+  /**
+   * A converter that converts seek time in stream time into target timestamp for the {@link
+   * BinarySearchSeeker}.
+   */
+  protected interface SeekTimestampConverter {
+    /**
+     * Converts a seek time in microseconds into target timestamp for the {@link
+     * BinarySearchSeeker}.
+     */
+    long timeUsToTargetTime(long timeUs);
+  }
+
+  /**
+   * When seeking within the source, if the offset is smaller than or equal to this value, the seek
+   * operation will be performed using a skip operation. Otherwise, the source will be reloaded at
+   * the new seek position.
+   */
+  private static final long MAX_SKIP_BYTES = 256 * 1024;
+
+  protected final BinarySearchSeekMap seekMap;
+  protected final TimestampSeeker timestampSeeker;
+  protected @Nullable SeekOperationParams seekOperationParams;
+
+  private final int minimumSearchRange;
+
+  /**
+   * Constructs an instance.
+   *
+   * @param seekTimestampConverter The {@link SeekTimestampConverter} that converts seek time in
+   *     stream time into target timestamp.
+   * @param timestampSeeker A {@link TimestampSeeker} that will be used to search for timestamps
+   *     within the stream.
+   * @param durationUs The duration of the stream in microseconds.
+   * @param floorTimePosition The minimum timestamp value (inclusive) in the stream.
+   * @param ceilingTimePosition The minimum timestamp value (exclusive) in the stream.
+   * @param floorBytePosition The starting position of the frame with minimum timestamp value
+   *     (inclusive) in the stream.
+   * @param ceilingBytePosition The position after the frame with maximum timestamp value in the
+   *     stream.
+   * @param approxBytesPerFrame Approximated bytes per frame.
+   * @param minimumSearchRange The minimum byte range that this binary seeker will operate on. If
+   *     the remaining search range is smaller than this value, the search will stop, and the seeker
+   *     will return the position at the floor of the range as the result.
+   */
+  @SuppressWarnings("initialization")
+  protected BinarySearchSeeker(
+      SeekTimestampConverter seekTimestampConverter,
+      TimestampSeeker timestampSeeker,
+      long durationUs,
+      long floorTimePosition,
+      long ceilingTimePosition,
+      long floorBytePosition,
+      long ceilingBytePosition,
+      long approxBytesPerFrame,
+      int minimumSearchRange) {
+    this.timestampSeeker = timestampSeeker;
+    this.minimumSearchRange = minimumSearchRange;
+    this.seekMap =
+        new BinarySearchSeekMap(
+            seekTimestampConverter,
+            durationUs,
+            floorTimePosition,
+            ceilingTimePosition,
+            floorBytePosition,
+            ceilingBytePosition,
+            approxBytesPerFrame);
+  }
+
+  /** Returns the seek map for the stream. */
+  public final SeekMap getSeekMap() {
+    return seekMap;
+  }
+
+  /**
+   * Sets the target time in microseconds within the stream to seek to.
+   *
+   * @param timeUs The target time in microseconds within the stream.
+   */
+  public final void setSeekTargetUs(long timeUs) {
+    if (seekOperationParams != null && seekOperationParams.getSeekTimeUs() == timeUs) {
+      return;
+    }
+    seekOperationParams = createSeekParamsForTargetTimeUs(timeUs);
+  }
+
+  /** Returns whether the last operation set by {@link #setSeekTargetUs(long)} is still pending. */
+  public final boolean isSeeking() {
+    return seekOperationParams != null;
+  }
+
+  /**
+   * Continues to handle the pending seek operation. Returns one of the {@code RESULT_} values from
+   * {@link Extractor}.
+   *
+   * @param input The {@link ExtractorInput} from which data should be read.
+   * @param seekPositionHolder If {@link Extractor#RESULT_SEEK} is returned, this holder is updated
+   *     to hold the position of the required seek.
+   * @param outputFrameHolder If {@link Extractor#RESULT_CONTINUE} is returned, this holder may be
+   *     updated to hold the extracted frame that contains the target sample. The caller needs to
+   *     check the byte buffer limit to see if an extracted frame is available.
+   * @return One of the {@code RESULT_} values defined in {@link Extractor}.
+   * @throws IOException If an error occurred reading from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public int handlePendingSeek(
+      ExtractorInput input, PositionHolder seekPositionHolder, OutputFrameHolder outputFrameHolder)
+      throws InterruptedException, IOException {
+    TimestampSeeker timestampSeeker = Assertions.checkNotNull(this.timestampSeeker);
+    while (true) {
+      SeekOperationParams seekOperationParams = Assertions.checkNotNull(this.seekOperationParams);
+      long floorPosition = seekOperationParams.getFloorBytePosition();
+      long ceilingPosition = seekOperationParams.getCeilingBytePosition();
+      long searchPosition = seekOperationParams.getNextSearchBytePosition();
+
+      if (ceilingPosition - floorPosition <= minimumSearchRange) {
+        // The seeking range is too small, so we can just continue from the floor position.
+        markSeekOperationFinished(/* foundTargetFrame= */ false, floorPosition);
+        return seekToPosition(input, floorPosition, seekPositionHolder);
+      }
+      if (!skipInputUntilPosition(input, searchPosition)) {
+        return seekToPosition(input, searchPosition, seekPositionHolder);
+      }
+
+      input.resetPeekPosition();
+      TimestampSearchResult timestampSearchResult =
+          timestampSeeker.searchForTimestamp(
+              input, seekOperationParams.getTargetTimePosition(), outputFrameHolder);
+
+      switch (timestampSearchResult.type) {
+        case TimestampSearchResult.TYPE_POSITION_OVERESTIMATED:
+          seekOperationParams.updateSeekCeiling(
+              timestampSearchResult.timestampToUpdate, timestampSearchResult.bytePositionToUpdate);
+          break;
+        case TimestampSearchResult.TYPE_POSITION_UNDERESTIMATED:
+          seekOperationParams.updateSeekFloor(
+              timestampSearchResult.timestampToUpdate, timestampSearchResult.bytePositionToUpdate);
+          break;
+        case TimestampSearchResult.TYPE_TARGET_TIMESTAMP_FOUND:
+          markSeekOperationFinished(
+              /* foundTargetFrame= */ true, timestampSearchResult.bytePositionToUpdate);
+          skipInputUntilPosition(input, timestampSearchResult.bytePositionToUpdate);
+          return seekToPosition(
+              input, timestampSearchResult.bytePositionToUpdate, seekPositionHolder);
+        case TimestampSearchResult.TYPE_NO_TIMESTAMP:
+          // We can't find any timestamp in the search range from the search position.
+          // Give up, and just continue reading from the last search position in this case.
+          markSeekOperationFinished(/* foundTargetFrame= */ false, searchPosition);
+          return seekToPosition(input, searchPosition, seekPositionHolder);
+        default:
+          throw new IllegalStateException("Invalid case");
+      }
+    }
+  }
+
+  protected SeekOperationParams createSeekParamsForTargetTimeUs(long timeUs) {
+    return new SeekOperationParams(
+        timeUs,
+        seekMap.timeUsToTargetTime(timeUs),
+        seekMap.floorTimePosition,
+        seekMap.ceilingTimePosition,
+        seekMap.floorBytePosition,
+        seekMap.ceilingBytePosition,
+        seekMap.approxBytesPerFrame);
+  }
+
+  protected final void markSeekOperationFinished(boolean foundTargetFrame, long resultPosition) {
+    seekOperationParams = null;
+    timestampSeeker.onSeekFinished();
+    onSeekOperationFinished(foundTargetFrame, resultPosition);
+  }
+
+  protected void onSeekOperationFinished(boolean foundTargetFrame, long resultPosition) {
+    // Do nothing.
+  }
+
+  protected final boolean skipInputUntilPosition(ExtractorInput input, long position)
+      throws IOException, InterruptedException {
+    long bytesToSkip = position - input.getPosition();
+    if (bytesToSkip >= 0 && bytesToSkip <= MAX_SKIP_BYTES) {
+      input.skipFully((int) bytesToSkip);
+      return true;
+    }
+    return false;
+  }
+
+  protected final int seekToPosition(
+      ExtractorInput input, long position, PositionHolder seekPositionHolder) {
+    if (position == input.getPosition()) {
+      return Extractor.RESULT_CONTINUE;
+    } else {
+      seekPositionHolder.position = position;
+      return Extractor.RESULT_SEEK;
+    }
+  }
+
+  /**
+   * Contains parameters for a pending seek operation by {@link BinarySearchSeeker}.
+   *
+   * <p>This class holds parameters for a binary-search for the {@code targetTimePosition} in the
+   * range [floorPosition, ceilingPosition).
+   */
+  protected static class SeekOperationParams {
+    private final long seekTimeUs;
+    private final long targetTimePosition;
+    private final long approxBytesPerFrame;
+
+    private long floorTimePosition;
+    private long ceilingTimePosition;
+    private long floorBytePosition;
+    private long ceilingBytePosition;
+    private long nextSearchBytePosition;
+
+    /**
+     * Returns the next position in the stream to search for target frame, given [floorBytePosition,
+     * ceilingBytePosition), with corresponding [floorTimePosition, ceilingTimePosition).
+     */
+    protected static long calculateNextSearchBytePosition(
+        long targetTimePosition,
+        long floorTimePosition,
+        long ceilingTimePosition,
+        long floorBytePosition,
+        long ceilingBytePosition,
+        long approxBytesPerFrame) {
+      if (floorBytePosition + 1 >= ceilingBytePosition
+          || floorTimePosition + 1 >= ceilingTimePosition) {
+        return floorBytePosition;
+      }
+      long seekTimeDuration = targetTimePosition - floorTimePosition;
+      float estimatedBytesPerTimeUnit =
+          (float) (ceilingBytePosition - floorBytePosition)
+              / (ceilingTimePosition - floorTimePosition);
+      // It's better to under-estimate rather than over-estimate, because the extractor
+      // input can skip forward easily, but cannot rewind easily (it may require a new connection
+      // to be made).
+      // Therefore, we should reduce the estimated position by some amount, so it will converge to
+      // the correct frame earlier.
+      long bytesToSkip = (long) (seekTimeDuration * estimatedBytesPerTimeUnit);
+      long confidenceInterval = bytesToSkip / 20;
+      long estimatedFramePosition = floorBytePosition + bytesToSkip - approxBytesPerFrame;
+      long estimatedPosition = estimatedFramePosition - confidenceInterval;
+      return Util.constrainValue(estimatedPosition, floorBytePosition, ceilingBytePosition - 1);
+    }
+
+    protected SeekOperationParams(
+        long seekTimeUs,
+        long targetTimePosition,
+        long floorTimePosition,
+        long ceilingTimePosition,
+        long floorBytePosition,
+        long ceilingBytePosition,
+        long approxBytesPerFrame) {
+      this.seekTimeUs = seekTimeUs;
+      this.targetTimePosition = targetTimePosition;
+      this.floorTimePosition = floorTimePosition;
+      this.ceilingTimePosition = ceilingTimePosition;
+      this.floorBytePosition = floorBytePosition;
+      this.ceilingBytePosition = ceilingBytePosition;
+      this.approxBytesPerFrame = approxBytesPerFrame;
+      this.nextSearchBytePosition =
+          calculateNextSearchBytePosition(
+              targetTimePosition,
+              floorTimePosition,
+              ceilingTimePosition,
+              floorBytePosition,
+              ceilingBytePosition,
+              approxBytesPerFrame);
+    }
+
+    /**
+     * Returns the floor byte position of the range [floorPosition, ceilingPosition) for this seek
+     * operation.
+     */
+    private long getFloorBytePosition() {
+      return floorBytePosition;
+    }
+
+    /**
+     * Returns the ceiling byte position of the range [floorPosition, ceilingPosition) for this seek
+     * operation.
+     */
+    private long getCeilingBytePosition() {
+      return ceilingBytePosition;
+    }
+
+    /** Returns the target timestamp as translated from the seek time. */
+    private long getTargetTimePosition() {
+      return targetTimePosition;
+    }
+
+    /** Returns the target seek time in microseconds. */
+    private long getSeekTimeUs() {
+      return seekTimeUs;
+    }
+
+    /** Updates the floor constraints (inclusive) of the seek operation. */
+    private void updateSeekFloor(long floorTimePosition, long floorBytePosition) {
+      this.floorTimePosition = floorTimePosition;
+      this.floorBytePosition = floorBytePosition;
+      updateNextSearchBytePosition();
+    }
+
+    /** Updates the ceiling constraints (exclusive) of the seek operation. */
+    private void updateSeekCeiling(long ceilingTimePosition, long ceilingBytePosition) {
+      this.ceilingTimePosition = ceilingTimePosition;
+      this.ceilingBytePosition = ceilingBytePosition;
+      updateNextSearchBytePosition();
+    }
+
+    /** Returns the next position in the stream to search. */
+    private long getNextSearchBytePosition() {
+      return nextSearchBytePosition;
+    }
+
+    private void updateNextSearchBytePosition() {
+      this.nextSearchBytePosition =
+          calculateNextSearchBytePosition(
+              targetTimePosition,
+              floorTimePosition,
+              ceilingTimePosition,
+              floorBytePosition,
+              ceilingBytePosition,
+              approxBytesPerFrame);
+    }
+  }
+
+  /**
+   * Represents possible search results for {@link
+   * TimestampSeeker#searchForTimestamp(ExtractorInput, long, OutputFrameHolder)}.
+   */
+  public static final class TimestampSearchResult {
+
+    /** The search found a timestamp that it deems close enough to the given target. */
+    public static final int TYPE_TARGET_TIMESTAMP_FOUND = 0;
+    /** The search found only timestamps larger than the target timestamp. */
+    public static final int TYPE_POSITION_OVERESTIMATED = -1;
+    /** The search found only timestamps smaller than the target timestamp. */
+    public static final int TYPE_POSITION_UNDERESTIMATED = -2;
+    /** The search didn't find any timestamps. */
+    public static final int TYPE_NO_TIMESTAMP = -3;
+
+    @Documented
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+      TYPE_TARGET_TIMESTAMP_FOUND,
+      TYPE_POSITION_OVERESTIMATED,
+      TYPE_POSITION_UNDERESTIMATED,
+      TYPE_NO_TIMESTAMP
+    })
+    @interface Type {}
+
+    public static final TimestampSearchResult NO_TIMESTAMP_IN_RANGE_RESULT =
+        new TimestampSearchResult(TYPE_NO_TIMESTAMP, C.TIME_UNSET, C.POSITION_UNSET);
+
+    /** The type of the result. */
+    @Type private final int type;
+
+    /**
+     * When {@link #type} is {@link #TYPE_POSITION_OVERESTIMATED}, the {@link
+     * SeekOperationParams#ceilingTimePosition} should be updated with this value. When {@link
+     * #type} is {@link #TYPE_POSITION_UNDERESTIMATED}, the {@link
+     * SeekOperationParams#floorTimePosition} should be updated with this value.
+     */
+    private final long timestampToUpdate;
+    /**
+     * When {@link #type} is {@link #TYPE_POSITION_OVERESTIMATED}, the {@link
+     * SeekOperationParams#ceilingBytePosition} should be updated with this value. When {@link
+     * #type} is {@link #TYPE_POSITION_UNDERESTIMATED}, the {@link
+     * SeekOperationParams#floorBytePosition} should be updated with this value.
+     */
+    private final long bytePositionToUpdate;
+
+    private TimestampSearchResult(
+        @Type int type, long timestampToUpdate, long bytePositionToUpdate) {
+      this.type = type;
+      this.timestampToUpdate = timestampToUpdate;
+      this.bytePositionToUpdate = bytePositionToUpdate;
+    }
+
+    /**
+     * Returns a result to signal that the current position in the input stream overestimates the
+     * true position of the target frame, and the {@link BinarySearchSeeker} should modify its
+     * {@link SeekOperationParams}'s ceiling timestamp and byte position using the given values.
+     */
+    public static TimestampSearchResult overestimatedResult(
+        long newCeilingTimestamp, long newCeilingBytePosition) {
+      return new TimestampSearchResult(
+          TYPE_POSITION_OVERESTIMATED, newCeilingTimestamp, newCeilingBytePosition);
+    }
+
+    /**
+     * Returns a result to signal that the current position in the input stream underestimates the
+     * true position of the target frame, and the {@link BinarySearchSeeker} should modify its
+     * {@link SeekOperationParams}'s floor timestamp and byte position using the given values.
+     */
+    public static TimestampSearchResult underestimatedResult(
+        long newFloorTimestamp, long newCeilingBytePosition) {
+      return new TimestampSearchResult(
+          TYPE_POSITION_UNDERESTIMATED, newFloorTimestamp, newCeilingBytePosition);
+    }
+
+    /**
+     * Returns a result to signal that the target timestamp has been found at {@code
+     * resultBytePosition}, and the seek operation can stop.
+     *
+     * <p>Note that when this value is returned from {@link
+     * TimestampSeeker#searchForTimestamp(ExtractorInput, long, OutputFrameHolder)}, the {@link
+     * OutputFrameHolder} may be updated to hold the target frame as an optimization.
+     */
+    public static TimestampSearchResult targetFoundResult(long resultBytePosition) {
+      return new TimestampSearchResult(
+          TYPE_TARGET_TIMESTAMP_FOUND, C.TIME_UNSET, resultBytePosition);
+    }
+  }
+
+  /**
+   * A {@link SeekMap} implementation that returns the estimated byte location from {@link
+   * SeekOperationParams#calculateNextSearchBytePosition(long, long, long, long, long, long)} for
+   * each {@link #getSeekPoints(long)} query.
+   */
+  public static class BinarySearchSeekMap implements SeekMap {
+    private final SeekTimestampConverter seekTimestampConverter;
+    private final long durationUs;
+    private final long floorTimePosition;
+    private final long ceilingTimePosition;
+    private final long floorBytePosition;
+    private final long ceilingBytePosition;
+    private final long approxBytesPerFrame;
+
+    /** Constructs a new instance of this seek map. */
+    public BinarySearchSeekMap(
+        SeekTimestampConverter seekTimestampConverter,
+        long durationUs,
+        long floorTimePosition,
+        long ceilingTimePosition,
+        long floorBytePosition,
+        long ceilingBytePosition,
+        long approxBytesPerFrame) {
+      this.seekTimestampConverter = seekTimestampConverter;
+      this.durationUs = durationUs;
+      this.floorTimePosition = floorTimePosition;
+      this.ceilingTimePosition = ceilingTimePosition;
+      this.floorBytePosition = floorBytePosition;
+      this.ceilingBytePosition = ceilingBytePosition;
+      this.approxBytesPerFrame = approxBytesPerFrame;
+    }
+
+    @Override
+    public boolean isSeekable() {
+      return true;
+    }
+
+    @Override
+    public SeekPoints getSeekPoints(long timeUs) {
+      long nextSearchPosition =
+          SeekOperationParams.calculateNextSearchBytePosition(
+              /* targetTimePosition= */ seekTimestampConverter.timeUsToTargetTime(timeUs),
+              /* floorTimePosition= */ floorTimePosition,
+              /* ceilingTimePosition= */ ceilingTimePosition,
+              /* floorBytePosition= */ floorBytePosition,
+              /* ceilingBytePosition= */ ceilingBytePosition,
+              /* approxBytesPerFrame= */ approxBytesPerFrame);
+      return new SeekPoints(new SeekPoint(timeUs, nextSearchPosition));
+    }
+
+    @Override
+    public long getDurationUs() {
+      return durationUs;
+    }
+
+    /** @see SeekTimestampConverter#timeUsToTargetTime(long) */
+    public long timeUsToTargetTime(long timeUs) {
+      return seekTimestampConverter.timeUsToTargetTime(timeUs);
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMap.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMap.java
new file mode 100644
index 0000000000..abce01b5ef
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMap.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * A {@link SeekMap} implementation that assumes the stream has a constant bitrate and consists of
+ * multiple independent frames of the same size. Seek points are calculated to be at frame
+ * boundaries.
+ */
+public class ConstantBitrateSeekMap implements SeekMap {
+
+  private final long inputLength;
+  private final long firstFrameBytePosition;
+  private final int frameSize;
+  private final long dataSize;
+  private final int bitrate;
+  private final long durationUs;
+
+  /**
+   * Constructs a new instance from a stream.
+   *
+   * @param inputLength The length of the stream in bytes, or {@link C#LENGTH_UNSET} if unknown.
+   * @param firstFrameBytePosition The byte-position of the first frame in the stream.
+   * @param bitrate The bitrate (which is assumed to be constant in the stream).
+   * @param frameSize The size of each frame in the stream in bytes. May be {@link C#LENGTH_UNSET}
+   *     if unknown.
+   */
+  public ConstantBitrateSeekMap(
+      long inputLength, long firstFrameBytePosition, int bitrate, int frameSize) {
+    this.inputLength = inputLength;
+    this.firstFrameBytePosition = firstFrameBytePosition;
+    this.frameSize = frameSize == C.LENGTH_UNSET ? 1 : frameSize;
+    this.bitrate = bitrate;
+
+    if (inputLength == C.LENGTH_UNSET) {
+      dataSize = C.LENGTH_UNSET;
+      durationUs = C.TIME_UNSET;
+    } else {
+      dataSize = inputLength - firstFrameBytePosition;
+      durationUs = getTimeUsAtPosition(inputLength, firstFrameBytePosition, bitrate);
+    }
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return dataSize != C.LENGTH_UNSET;
+  }
+
+  @Override
+  public SeekPoints getSeekPoints(long timeUs) {
+    if (dataSize == C.LENGTH_UNSET) {
+      return new SeekPoints(new SeekPoint(0, firstFrameBytePosition));
+    }
+    long seekFramePosition = getFramePositionForTimeUs(timeUs);
+    long seekTimeUs = getTimeUsAtPosition(seekFramePosition);
+    SeekPoint seekPoint = new SeekPoint(seekTimeUs, seekFramePosition);
+    if (seekTimeUs >= timeUs || seekFramePosition + frameSize >= inputLength) {
+      return new SeekPoints(seekPoint);
+    } else {
+      long secondSeekPosition = seekFramePosition + frameSize;
+      long secondSeekTimeUs = getTimeUsAtPosition(secondSeekPosition);
+      SeekPoint secondSeekPoint = new SeekPoint(secondSeekTimeUs, secondSeekPosition);
+      return new SeekPoints(seekPoint, secondSeekPoint);
+    }
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Returns the stream time in microseconds for a given position.
+   *
+   * @param position The stream byte-position.
+   * @return The stream time in microseconds for the given position.
+   */
+  public long getTimeUsAtPosition(long position) {
+    return getTimeUsAtPosition(position, firstFrameBytePosition, bitrate);
+  }
+
+  // Internal methods
+
+  /**
+   * Returns the stream time in microseconds for a given stream position.
+   *
+   * @param position The stream byte-position.
+   * @param firstFrameBytePosition The position of the first frame in the stream.
+   * @param bitrate The bitrate (which is assumed to be constant in the stream).
+   * @return The stream time in microseconds for the given stream position.
+   */
+  private static long getTimeUsAtPosition(long position, long firstFrameBytePosition, int bitrate) {
+    return Math.max(0, position - firstFrameBytePosition)
+        * C.BITS_PER_BYTE
+        * C.MICROS_PER_SECOND
+        / bitrate;
+  }
+
+  private long getFramePositionForTimeUs(long timeUs) {
+    long positionOffset = (timeUs * bitrate) / (C.MICROS_PER_SECOND * C.BITS_PER_BYTE);
+    // Constrain to nearest preceding frame offset.
+    positionOffset = (positionOffset / frameSize) * frameSize;
+    positionOffset =
+        Util.constrainValue(positionOffset, /* min= */ 0, /* max= */ dataSize - frameSize);
+    return firstFrameBytePosition + positionOffset;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
index c3f6304091..450cca42b0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
@@ -130,16 +130,16 @@ public void peekFully(byte[] target, int offset, int length)
   public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
     ensureSpaceForPeek(length);
-    int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
+    int bytesPeeked = peekBufferLength - peekBufferPosition;
     while (bytesPeeked < length) {
       bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
           allowEndOfInput);
       if (bytesPeeked == C.RESULT_END_OF_INPUT) {
         return false;
       }
+      peekBufferLength = peekBufferPosition + bytesPeeked;
     }
     peekBufferPosition += length;
-    peekBufferLength = Math.max(peekBufferLength, peekBufferPosition);
     return true;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
index 425f2b77cd..54bb617c58 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
@@ -72,6 +72,9 @@
     FLAC_EXTRACTOR_CONSTRUCTOR = flacExtractorConstructor;
   }
 
+  private boolean constantBitrateSeekingEnabled;
+  private @AdtsExtractor.Flags int adtsFlags;
+  private @AmrExtractor.Flags int amrFlags;
   private @MatroskaExtractor.Flags int matroskaFlags;
   private @Mp4Extractor.Flags int mp4Flags;
   private @FragmentedMp4Extractor.Flags int fragmentedMp4Flags;
@@ -83,6 +86,48 @@ public DefaultExtractorsFactory() {
     tsMode = TsExtractor.MODE_SINGLE_PMT;
   }
 
+  /**
+   * Convenience method to set whether approximate seeking using constant bitrate assumptions should
+   * be enabled for all extractors that support it. If set to true, the flags required to enable
+   * this functionality will be OR'd with those passed to the setters when creating extractor
+   * instances. If set to false then the flags passed to the setters will be used without
+   * modification.
+   *
+   * @param constantBitrateSeekingEnabled Whether approximate seeking using a constant bitrate
+   *     assumption should be enabled for all extractors that support it.
+   * @return The factory, for convenience.
+   */
+  public synchronized DefaultExtractorsFactory setConstantBitrateSeekingEnabled(
+      boolean constantBitrateSeekingEnabled) {
+    this.constantBitrateSeekingEnabled = constantBitrateSeekingEnabled;
+    return this;
+  }
+
+  /**
+   * Sets flags for {@link AdtsExtractor} instances created by the factory.
+   *
+   * @see AdtsExtractor#AdtsExtractor(long, int)
+   * @param flags The flags to use.
+   * @return The factory, for convenience.
+   */
+  public synchronized DefaultExtractorsFactory setAdtsExtractorFlags(
+      @AdtsExtractor.Flags int flags) {
+    this.adtsFlags = flags;
+    return this;
+  }
+
+  /**
+   * Sets flags for {@link AmrExtractor} instances created by the factory.
+   *
+   * @see AmrExtractor#AmrExtractor(int)
+   * @param flags The flags to use.
+   * @return The factory, for convenience.
+   */
+  public synchronized DefaultExtractorsFactory setAmrExtractorFlags(@AmrExtractor.Flags int flags) {
+    this.amrFlags = flags;
+    return this;
+  }
+
   /**
    * Sets flags for {@link MatroskaExtractor} instances created by the factory.
    *
@@ -165,15 +210,31 @@ public synchronized DefaultExtractorsFactory setTsExtractorFlags(
     extractors[0] = new MatroskaExtractor(matroskaFlags);
     extractors[1] = new FragmentedMp4Extractor(fragmentedMp4Flags);
     extractors[2] = new Mp4Extractor(mp4Flags);
-    extractors[3] = new Mp3Extractor(mp3Flags);
-    extractors[4] = new AdtsExtractor();
+    extractors[3] =
+        new Mp3Extractor(
+            mp3Flags
+                | (constantBitrateSeekingEnabled
+                    ? Mp3Extractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
+                    : 0));
+    extractors[4] =
+        new AdtsExtractor(
+            /* firstStreamSampleTimestampUs= */ 0,
+            adtsFlags
+                | (constantBitrateSeekingEnabled
+                    ? AdtsExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
+                    : 0));
     extractors[5] = new Ac3Extractor();
     extractors[6] = new TsExtractor(tsMode, tsFlags);
     extractors[7] = new FlvExtractor();
     extractors[8] = new OggExtractor();
     extractors[9] = new PsExtractor();
     extractors[10] = new WavExtractor();
-    extractors[11] = new AmrExtractor();
+    extractors[11] =
+        new AmrExtractor(
+            amrFlags
+                | (constantBitrateSeekingEnabled
+                    ? AmrExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
+                    : 0));
     if (FLAC_EXTRACTOR_CONSTRUCTOR != null) {
       try {
         extractors[12] = FLAC_EXTRACTOR_CONSTRUCTOR.newInstance();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyExtractorOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyExtractorOutput.java
new file mode 100644
index 0000000000..f199493500
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyExtractorOutput.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor;
+
+/** A dummy {@link ExtractorOutput} implementation. */
+public final class DummyExtractorOutput implements ExtractorOutput {
+
+  @Override
+  public TrackOutput track(int id, int type) {
+    return new DummyTrackOutput();
+  }
+
+  @Override
+  public void endTracks() {
+    // Do nothing.
+  }
+
+  @Override
+  public void seekMap(SeekMap seekMap) {
+    // Do nothing.
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
index c023b0de95..9eaf0f7ef7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -50,9 +51,12 @@ public void sampleData(ParsableByteArray data, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
-      CryptoData cryptoData) {
+  public void sampleMetadata(
+      long timeUs,
+      @C.BufferFlags int flags,
+      int size,
+      int offset,
+      @Nullable CryptoData cryptoData) {
     // Do nothing.
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 7a2bc15da9..05f5d98d3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -15,8 +15,12 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Extracts media data from a container format.
@@ -41,6 +45,15 @@
    */
   int RESULT_END_OF_INPUT = C.RESULT_END_OF_INPUT;
 
+  /**
+   * Result values that can be returned by {@link #read(ExtractorInput, PositionHolder)}. One of
+   * {@link #RESULT_CONTINUE}, {@link #RESULT_SEEK} or {@link #RESULT_END_OF_INPUT}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {RESULT_CONTINUE, RESULT_SEEK, RESULT_END_OF_INPUT})
+  @interface ReadResult {}
+
   /**
    * Returns whether this extractor can extract samples from the {@link ExtractorInput}, which must
    * provide data from the start of the stream.
@@ -63,14 +76,14 @@
   void init(ExtractorOutput output);
 
   /**
-   * Extracts data read from a provided {@link ExtractorInput}. Must not be called before
-   * {@link #init(ExtractorOutput)}.
-   * <p>
-   * A single call to this method will block until some progress has been made, but will not block
-   * for longer than this. Hence each call will consume only a small amount of input data.
-   * <p>
-   * In the common case, {@link #RESULT_CONTINUE} is returned to indicate that the
-   * {@link ExtractorInput} passed to the next read is required to provide data continuing from the
+   * Extracts data read from a provided {@link ExtractorInput}. Must not be called before {@link
+   * #init(ExtractorOutput)}.
+   *
+   * <p>A single call to this method will block until some progress has been made, but will not
+   * block for longer than this. Hence each call will consume only a small amount of input data.
+   *
+   * <p>In the common case, {@link #RESULT_CONTINUE} is returned to indicate that the {@link
+   * ExtractorInput} passed to the next read is required to provide data continuing from the
    * position in the stream reached by the returning call. If the extractor requires data to be
    * provided from a different position, then that position is set in {@code seekPosition} and
    * {@link #RESULT_SEEK} is returned. If the extractor reached the end of the data provided by the
@@ -83,6 +96,7 @@
    * @throws IOException If an error occurred reading from the input.
    * @throws InterruptedException If the thread was interrupted.
    */
+  @ReadResult
   int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ExtractorsFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ExtractorsFactory.java
index b89990ff10..ee29f376a1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ExtractorsFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ExtractorsFactory.java
@@ -15,14 +15,9 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-/**
- * Factory for arrays of {@link Extractor}s.
- */
+/** Factory for arrays of {@link Extractor} instances. */
 public interface ExtractorsFactory {
 
-  /**
-   * Returns an array of new {@link Extractor} instances.
-   */
+  /** Returns an array of new {@link Extractor} instances. */
   Extractor[] createExtractors();
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
index 75d8b4cf2d..a0effc0df8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
@@ -18,7 +18,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
-import com.google.android.exoplayer2.metadata.id3.Id3Decoder.FramePredicate;
+import com.google.android.exoplayer2.metadata.id3.InternalFrame;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -27,19 +27,8 @@
  */
 public final class GaplessInfoHolder {
 
-  /**
-   * A {@link FramePredicate} suitable for use when decoding {@link Metadata} that will be passed
-   * to {@link #setFromMetadata(Metadata)}. Only frames that might contain gapless playback
-   * information are decoded.
-   */
-  public static final FramePredicate GAPLESS_INFO_ID3_FRAME_PREDICATE = new FramePredicate() {
-    @Override
-    public boolean evaluate(int majorVersion, int id0, int id1, int id2, int id3) {
-      return id0 == 'C' && id1 == 'O' && id2 == 'M' && (id3 == 'M' || majorVersion == 2);
-    }
-  };
-
-  private static final String GAPLESS_COMMENT_ID = "iTunSMPB";
+  private static final String GAPLESS_DOMAIN = "com.apple.iTunes";
+  private static final String GAPLESS_DESCRIPTION = "iTunSMPB";
   private static final Pattern GAPLESS_COMMENT_PATTERN =
       Pattern.compile("^ [0-9a-fA-F]{8} ([0-9a-fA-F]{8}) ([0-9a-fA-F]{8})");
 
@@ -91,7 +80,15 @@ public boolean setFromMetadata(Metadata metadata) {
       Metadata.Entry entry = metadata.get(i);
       if (entry instanceof CommentFrame) {
         CommentFrame commentFrame = (CommentFrame) entry;
-        if (setFromComment(commentFrame.description, commentFrame.text)) {
+        if (GAPLESS_DESCRIPTION.equals(commentFrame.description)
+            && setFromComment(commentFrame.text)) {
+          return true;
+        }
+      } else if (entry instanceof InternalFrame) {
+        InternalFrame internalFrame = (InternalFrame) entry;
+        if (GAPLESS_DOMAIN.equals(internalFrame.domain)
+            && GAPLESS_DESCRIPTION.equals(internalFrame.description)
+            && setFromComment(internalFrame.text)) {
           return true;
         }
       }
@@ -103,14 +100,10 @@ public boolean setFromMetadata(Metadata metadata) {
    * Populates the holder with data parsed from a gapless playback comment (stored in an ID3 header
    * or MPEG 4 user data), if valid and non-zero.
    *
-   * @param name The comment's identifier.
    * @param data The comment's payload data.
    * @return Whether the holder was populated.
    */
-  private boolean setFromComment(String name, String data) {
-    if (!GAPLESS_COMMENT_ID.equals(name)) {
-      return false;
-    }
+  private boolean setFromComment(String data) {
     Matcher matcher = GAPLESS_COMMENT_PATTERN.matcher(data);
     if (matcher.find()) {
       try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
index f394a7415c..87bb992082 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
@@ -34,16 +34,26 @@
   private static final String[] MIME_TYPE_BY_LAYER =
       new String[] {MimeTypes.AUDIO_MPEG_L1, MimeTypes.AUDIO_MPEG_L2, MimeTypes.AUDIO_MPEG};
   private static final int[] SAMPLING_RATE_V1 = {44100, 48000, 32000};
-  private static final int[] BITRATE_V1_L1 =
-      {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448};
-  private static final int[] BITRATE_V2_L1 =
-      {32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256};
-  private static final int[] BITRATE_V1_L2 =
-      {32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384};
-  private static final int[] BITRATE_V1_L3 =
-      {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320};
-  private static final int[] BITRATE_V2 =
-      {8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160};
+  private static final int[] BITRATE_V1_L1 = {
+    32000, 64000, 96000, 128000, 160000, 192000, 224000, 256000, 288000, 320000, 352000, 384000,
+    416000, 448000
+  };
+  private static final int[] BITRATE_V2_L1 = {
+    32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 176000, 192000,
+    224000, 256000
+  };
+  private static final int[] BITRATE_V1_L2 = {
+    32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000,
+    320000, 384000
+  };
+  private static final int[] BITRATE_V1_L3 = {
+    32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000,
+    320000
+  };
+  private static final int[] BITRATE_V2 = {
+    8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000,
+    160000
+  };
 
   /**
    * Returns the size of the frame associated with {@code header}, or {@link C#LENGTH_UNSET} if it
@@ -89,7 +99,7 @@ public static int getFrameSize(int header) {
     if (layer == 3) {
       // Layer I (layer == 3)
       bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];
-      return (12000 * bitrate / samplingRate + padding) * 4;
+      return (12 * bitrate / samplingRate + padding) * 4;
     } else {
       // Layer II (layer == 2) or III (layer == 1)
       if (version == 3) {
@@ -102,10 +112,10 @@ public static int getFrameSize(int header) {
 
     if (version == 3) {
       // Version 1
-      return 144000 * bitrate / samplingRate + padding;
+      return 144 * bitrate / samplingRate + padding;
     } else {
       // Version 2 or 2.5
-      return (layer == 1 ? 72000 : 144000) * bitrate / samplingRate + padding;
+      return (layer == 1 ? 72 : 144) * bitrate / samplingRate + padding;
     }
   }
 
@@ -153,11 +163,13 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
     }
 
     int padding = (headerData >>> 9) & 1;
-    int bitrate, frameSize, samplesPerFrame;
+    int bitrate;
+    int frameSize;
+    int samplesPerFrame;
     if (layer == 3) {
       // Layer I (layer == 3)
       bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];
-      frameSize = (12000 * bitrate / sampleRate + padding) * 4;
+      frameSize = (12 * bitrate / sampleRate + padding) * 4;
       samplesPerFrame = 384;
     } else {
       // Layer II (layer == 2) or III (layer == 1)
@@ -165,19 +177,22 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
         // Version 1
         bitrate = layer == 2 ? BITRATE_V1_L2[bitrateIndex - 1] : BITRATE_V1_L3[bitrateIndex - 1];
         samplesPerFrame = 1152;
-        frameSize = 144000 * bitrate / sampleRate + padding;
+        frameSize = 144 * bitrate / sampleRate + padding;
       } else {
         // Version 2 or 2.5.
         bitrate = BITRATE_V2[bitrateIndex - 1];
         samplesPerFrame = layer == 1 ? 576 : 1152;
-        frameSize = (layer == 1 ? 72000 : 144000) * bitrate / sampleRate + padding;
+        frameSize = (layer == 1 ? 72 : 144) * bitrate / sampleRate + padding;
       }
     }
 
+    // Calculate the bitrate in the same way Mp3Extractor calculates sample timestamps so that
+    // seeking to a given timestamp and playing from the start up to that timestamp give the same
+    // results for CBR streams. See also [internal: b/120390268].
+    bitrate = 8 * frameSize * sampleRate / samplesPerFrame;
     String mimeType = MIME_TYPE_BY_LAYER[3 - layer];
     int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
-    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate * 1000,
-        samplesPerFrame);
+    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
     return true;
   }
 
@@ -196,8 +211,14 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
   /** Number of samples stored in the frame. */
   public int samplesPerFrame;
 
-  private void setValues(int version, String mimeType, int frameSize, int sampleRate, int channels,
-      int bitrate, int samplesPerFrame) {
+  private void setValues(
+      int version,
+      String mimeType,
+      int frameSize,
+      int sampleRate,
+      int channels,
+      int bitrate,
+      int samplesPerFrame) {
     this.version = version;
     this.mimeType = mimeType;
     this.frameSize = frameSize;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
index 6a8cef6b64..7b832eb400 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
@@ -125,21 +125,23 @@ int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
 
   /**
    * Called when metadata associated with a sample has been extracted from the stream.
-   * <p>
-   * The corresponding sample data will have already been passed to the output via calls to
-   * {@link #sampleData(ExtractorInput, int, boolean)} or
-   * {@link #sampleData(ParsableByteArray, int)}.
+   *
+   * <p>The corresponding sample data will have already been passed to the output via calls to
+   * {@link #sampleData(ExtractorInput, int, boolean)} or {@link #sampleData(ParsableByteArray,
+   * int)}.
    *
    * @param timeUs The media timestamp associated with the sample, in microseconds.
    * @param flags Flags associated with the sample. See {@code C.BUFFER_FLAG_*}.
    * @param size The size of the sample data, in bytes.
-   * @param offset The number of bytes that have been passed to
-   *     {@link #sampleData(ExtractorInput, int, boolean)} or
-   *     {@link #sampleData(ParsableByteArray, int)} since the last byte belonging to the sample
-   *     whose metadata is being passed.
+   * @param offset The number of bytes that have been passed to {@link #sampleData(ExtractorInput,
+   *     int, boolean)} or {@link #sampleData(ParsableByteArray, int)} since the last byte belonging
+   *     to the sample whose metadata is being passed.
    * @param encryptionData The encryption data required to decrypt the sample. May be null.
    */
-  void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
-      CryptoData encryptionData);
-
+  void sampleMetadata(
+      long timeUs,
+      @C.BufferFlags int flags,
+      int size,
+      int offset,
+      @Nullable CryptoData encryptionData);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
index b58e979c26..b93969acfe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
@@ -15,9 +15,12 @@
  */
 package com.google.android.exoplayer2.extractor.amr;
 
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.extractor.ConstantBitrateSeekMap;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -29,6 +32,9 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 
 /**
@@ -40,14 +46,23 @@
 public final class AmrExtractor implements Extractor {
 
   /** Factory for {@link AmrExtractor} instances. */
-  public static final ExtractorsFactory FACTORY =
-      new ExtractorsFactory() {
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new AmrExtractor()};
 
-        @Override
-        public Extractor[] createExtractors() {
-          return new Extractor[] {new AmrExtractor()};
-        }
-      };
+  /**
+   * Flags controlling the behavior of the extractor. Possible flag value is {@link
+   * #FLAG_ENABLE_CONSTANT_BITRATE_SEEKING}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(
+      flag = true,
+      value = {FLAG_ENABLE_CONSTANT_BITRATE_SEEKING})
+  public @interface Flags {}
+  /**
+   * Flag to force enable seeking using a constant bitrate assumption in cases where seeking would
+   * otherwise not be possible.
+   */
+  public static final int FLAG_ENABLE_CONSTANT_BITRATE_SEEKING = 1;
 
   /**
    * The frame size in bytes, including header (1 byte), for each of the 16 frame types for AMR
@@ -100,23 +115,43 @@
 
   /** Theoretical maximum frame size for a AMR frame. */
   private static final int MAX_FRAME_SIZE_BYTES = frameSizeBytesByTypeWb[8];
+  /**
+   * The required number of samples in the stream with same sample size to classify the stream as a
+   * constant-bitrate-stream.
+   */
+  private static final int NUM_SAME_SIZE_CONSTANT_BIT_RATE_THRESHOLD = 20;
 
   private static final int SAMPLE_RATE_WB = 16_000;
   private static final int SAMPLE_RATE_NB = 8_000;
   private static final int SAMPLE_TIME_PER_FRAME_US = 20_000;
 
   private final byte[] scratch;
+  private final @Flags int flags;
 
   private boolean isWideBand;
   private long currentSampleTimeUs;
-  private int currentSampleTotalBytes;
+  private int currentSampleSize;
   private int currentSampleBytesRemaining;
+  private boolean hasOutputSeekMap;
+  private long firstSamplePosition;
+  private int firstSampleSize;
+  private int numSamplesWithSameSize;
+  private long timeOffsetUs;
 
+  private ExtractorOutput extractorOutput;
   private TrackOutput trackOutput;
+  private @Nullable SeekMap seekMap;
   private boolean hasOutputFormat;
 
   public AmrExtractor() {
+    this(/* flags= */ 0);
+  }
+
+  /** @param flags Flags that control the extractor's behavior. */
+  public AmrExtractor(@Flags int flags) {
+    this.flags = flags;
     scratch = new byte[1];
+    firstSampleSize = C.LENGTH_UNSET;
   }
 
   // Extractor implementation.
@@ -127,10 +162,10 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   }
 
   @Override
-  public void init(ExtractorOutput output) {
-    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
-    trackOutput = output.track(/* id= */ 0, C.TRACK_TYPE_AUDIO);
-    output.endTracks();
+  public void init(ExtractorOutput extractorOutput) {
+    this.extractorOutput = extractorOutput;
+    trackOutput = extractorOutput.track(/* id= */ 0, C.TRACK_TYPE_AUDIO);
+    extractorOutput.endTracks();
   }
 
   @Override
@@ -142,14 +177,21 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       }
     }
     maybeOutputFormat();
-    return readSample(input);
+    int sampleReadResult = readSample(input);
+    maybeOutputSeekMap(input.getLength(), sampleReadResult);
+    return sampleReadResult;
   }
 
   @Override
   public void seek(long position, long timeUs) {
     currentSampleTimeUs = 0;
-    currentSampleTotalBytes = 0;
+    currentSampleSize = 0;
     currentSampleBytesRemaining = 0;
+    if (position != 0 && seekMap instanceof ConstantBitrateSeekMap) {
+      timeOffsetUs = ((ConstantBitrateSeekMap) seekMap).getTimeUsAtPosition(position);
+    } else {
+      timeOffsetUs = 0;
+    }
   }
 
   @Override
@@ -228,11 +270,18 @@ private void maybeOutputFormat() {
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
     if (currentSampleBytesRemaining == 0) {
       try {
-        currentSampleTotalBytes = readNextSampleSize(extractorInput);
+        currentSampleSize = peekNextSampleSize(extractorInput);
       } catch (EOFException e) {
         return RESULT_END_OF_INPUT;
       }
-      currentSampleBytesRemaining = currentSampleTotalBytes;
+      currentSampleBytesRemaining = currentSampleSize;
+      if (firstSampleSize == C.LENGTH_UNSET) {
+        firstSamplePosition = extractorInput.getPosition();
+        firstSampleSize = currentSampleSize;
+      }
+      if (firstSampleSize == currentSampleSize) {
+        numSamplesWithSameSize++;
+      }
     }
 
     int bytesAppended =
@@ -247,16 +296,16 @@ private int readSample(ExtractorInput extractorInput) throws IOException, Interr
     }
 
     trackOutput.sampleMetadata(
-        currentSampleTimeUs,
+        timeOffsetUs + currentSampleTimeUs,
         C.BUFFER_FLAG_KEY_FRAME,
-        currentSampleTotalBytes,
+        currentSampleSize,
         /* offset= */ 0,
         /* encryptionData= */ null);
     currentSampleTimeUs += SAMPLE_TIME_PER_FRAME_US;
     return RESULT_CONTINUE;
   }
 
-  private int readNextSampleSize(ExtractorInput extractorInput)
+  private int peekNextSampleSize(ExtractorInput extractorInput)
       throws IOException, InterruptedException {
     extractorInput.resetPeekPosition();
     extractorInput.peekFully(scratch, /* offset= */ 0, /* length= */ 1);
@@ -296,4 +345,39 @@ private boolean isNarrowBandValidFrameType(int frameType) {
     // For narrow band, type 12-14 are for future use.
     return !isWideBand && (frameType < 12 || frameType > 14);
   }
+
+  private void maybeOutputSeekMap(long inputLength, int sampleReadResult) {
+    if (hasOutputSeekMap) {
+      return;
+    }
+
+    if ((flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) == 0
+        || inputLength == C.LENGTH_UNSET
+        || (firstSampleSize != C.LENGTH_UNSET && firstSampleSize != currentSampleSize)) {
+      seekMap = new SeekMap.Unseekable(C.TIME_UNSET);
+      extractorOutput.seekMap(seekMap);
+      hasOutputSeekMap = true;
+    } else if (numSamplesWithSameSize >= NUM_SAME_SIZE_CONSTANT_BIT_RATE_THRESHOLD
+        || sampleReadResult == RESULT_END_OF_INPUT) {
+      seekMap = getConstantBitrateSeekMap(inputLength);
+      extractorOutput.seekMap(seekMap);
+      hasOutputSeekMap = true;
+    }
+  }
+
+  private SeekMap getConstantBitrateSeekMap(long inputLength) {
+    int bitrate = getBitrateFromFrameSize(firstSampleSize, SAMPLE_TIME_PER_FRAME_US);
+    return new ConstantBitrateSeekMap(inputLength, firstSamplePosition, bitrate, firstSampleSize);
+  }
+
+  /**
+   * Returns the stream bitrate, given a frame size and the duration of that frame in microseconds.
+   *
+   * @param frameSize The size of each frame in the stream.
+   * @param durationUsPerFrame The duration of the given frame in microseconds.
+   * @return The stream bitrate.
+   */
+  private static int getBitrateFromFrameSize(int frameSize, long durationUsPerFrame) {
+    return (int) ((frameSize * C.BITS_PER_BYTE * C.MICROS_PER_SECOND) / durationUsPerFrame);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index d908f28945..4211cab489 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -34,25 +35,20 @@
  */
 public final class FlvExtractor implements Extractor {
 
-  /**
-   * Factory for {@link FlvExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new FlvExtractor()};
-    }
+  /** Factory for {@link FlvExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new FlvExtractor()};
 
-  };
-
-  /**
-   * Extractor states.
-   */
+  /** Extractor states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({STATE_READING_FLV_HEADER, STATE_SKIPPING_TO_TAG_HEADER, STATE_READING_TAG_HEADER,
-      STATE_READING_TAG_DATA})
+  @IntDef({
+    STATE_READING_FLV_HEADER,
+    STATE_SKIPPING_TO_TAG_HEADER,
+    STATE_READING_TAG_HEADER,
+    STATE_READING_TAG_DATA
+  })
   private @interface States {}
+
   private static final int STATE_READING_FLV_HEADER = 1;
   private static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
   private static final int STATE_READING_TAG_HEADER = 3;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
index c0494e1ee0..0987bc473f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayDeque;
@@ -31,6 +32,7 @@
  */
 /* package */ final class DefaultEbmlReader implements EbmlReader {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({ELEMENT_STATE_READ_ID, ELEMENT_STATE_READ_CONTENT_SIZE, ELEMENT_STATE_READ_CONTENT})
   private @interface ElementState {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
index b1cd508c8e..cc17af5632 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -27,7 +28,11 @@
  */
 /* package */ interface EbmlReaderOutput {
 
-  /** EBML element types. */
+  /**
+   * EBML element types. One of {@link #TYPE_UNKNOWN}, {@link #TYPE_MASTER}, {@link
+   * #TYPE_UNSIGNED_INT}, {@link #TYPE_STRING}, {@link #TYPE_BINARY} or {@link #TYPE_FLOAT}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNKNOWN, TYPE_MASTER, TYPE_UNSIGNED_INT, TYPE_STRING, TYPE_BINARY, TYPE_FLOAT})
   @interface ElementType {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 1049554f7a..86b750e821 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -17,7 +17,6 @@
 
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
@@ -36,6 +35,7 @@
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.LongArray;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
@@ -45,6 +45,7 @@
 import com.google.android.exoplayer2.video.ColorInfo;
 import com.google.android.exoplayer2.video.HevcConfig;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -61,23 +62,18 @@
  */
 public final class MatroskaExtractor implements Extractor {
 
-  /**
-   * Factory for {@link MatroskaExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new MatroskaExtractor()};
-    }
-
-  };
+  /** Factory for {@link MatroskaExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new MatroskaExtractor()};
 
   /**
-   * Flags controlling the behavior of the extractor.
+   * Flags controlling the behavior of the extractor. Possible flag value is {@link
+   * #FLAG_DISABLE_SEEK_FOR_CUES}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_DISABLE_SEEK_FOR_CUES})
+  @IntDef(
+      flag = true,
+      value = {FLAG_DISABLE_SEEK_FOR_CUES})
   public @interface Flags {}
   /**
    * Flag to disable seeking for cues.
@@ -161,6 +157,7 @@
   private static final int ID_FLAG_DEFAULT = 0x88;
   private static final int ID_FLAG_FORCED = 0x55AA;
   private static final int ID_DEFAULT_DURATION = 0x23E383;
+  private static final int ID_NAME = 0x536E;
   private static final int ID_CODEC_ID = 0x86;
   private static final int ID_CODEC_PRIVATE = 0x63A2;
   private static final int ID_CODEC_DELAY = 0x56AA;
@@ -616,10 +613,10 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         currentTrack.number = (int) value;
         break;
       case ID_FLAG_DEFAULT:
-        currentTrack.flagForced = value == 1;
+        currentTrack.flagDefault = value == 1;
         break;
       case ID_FLAG_FORCED:
-        currentTrack.flagDefault = value == 1;
+        currentTrack.flagForced = value == 1;
         break;
       case ID_TRACK_TYPE:
         currentTrack.type = (int) value;
@@ -819,6 +816,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           throw new ParserException("DocType " + value + " not supported");
         }
         break;
+      case ID_NAME:
+        currentTrack.name = value;
+        break;
       case ID_CODEC_ID:
         currentTrack.codecId = value;
         break;
@@ -1467,6 +1467,7 @@ public int getElementType(int id) {
         case ID_MAX_FALL:
           return TYPE_UNSIGNED_INT;
         case ID_DOC_TYPE:
+        case ID_NAME:
         case ID_CODEC_ID:
         case ID_LANGUAGE:
           return TYPE_STRING;
@@ -1560,7 +1561,7 @@ public void startSample(ExtractorInput input, @C.BufferFlags int blockFlags, int
       if (!foundSyncframe) {
         input.peekFully(syncframePrefix, 0, Ac3Util.TRUEHD_SYNCFRAME_PREFIX_LENGTH);
         input.resetPeekPosition();
-        if ((Ac3Util.parseTrueHdSyncframeAudioSampleCount(syncframePrefix) == C.INDEX_UNSET)) {
+        if (Ac3Util.parseTrueHdSyncframeAudioSampleCount(syncframePrefix) == 0) {
           return;
         }
         foundSyncframe = true;
@@ -1613,6 +1614,7 @@ public void outputPendingSampleMetadata(Track track) {
     private static final int DEFAULT_MAX_FALL = 200;  // nits.
 
     // Common elements.
+    public String name;
     public String codecId;
     public int number;
     public int type;
@@ -1837,10 +1839,34 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
           byte[] hdrStaticInfo = getHdrStaticInfo();
           colorInfo = new ColorInfo(colorSpace, colorRange, colorTransfer, hdrStaticInfo);
         }
-        format = Format.createVideoSampleFormat(Integer.toString(trackId), mimeType, null,
-            Format.NO_VALUE, maxInputSize, width, height, Format.NO_VALUE, initializationData,
-            Format.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode, colorInfo,
-            drmInitData);
+        int rotationDegrees = Format.NO_VALUE;
+        // Some HTC devices signal rotation in track names.
+        if ("htc_video_rotA-000".equals(name)) {
+          rotationDegrees = 0;
+        } else if ("htc_video_rotA-090".equals(name)) {
+          rotationDegrees = 90;
+        } else if ("htc_video_rotA-180".equals(name)) {
+          rotationDegrees = 180;
+        } else if ("htc_video_rotA-270".equals(name)) {
+          rotationDegrees = 270;
+        }
+        format =
+            Format.createVideoSampleFormat(
+                Integer.toString(trackId),
+                mimeType,
+                /* codecs= */ null,
+                /* bitrate= */ Format.NO_VALUE,
+                maxInputSize,
+                width,
+                height,
+                /* frameRate= */ Format.NO_VALUE,
+                initializationData,
+                rotationDegrees,
+                pixelWidthHeightRatio,
+                projectionData,
+                stereoMode,
+                colorInfo,
+                drmInitData);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
         type = C.TRACK_TYPE_TEXT;
         format = Format.createTextSampleFormat(Integer.toString(trackId), mimeType, selectionFlags,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
index d358c0cae1..f400720772 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
@@ -16,78 +16,32 @@
 package com.google.android.exoplayer2.extractor.mp3;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ConstantBitrateSeekMap;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
-import com.google.android.exoplayer2.extractor.SeekPoint;
-import com.google.android.exoplayer2.util.Util;
 
 /**
  * MP3 seeker that doesn't rely on metadata and seeks assuming the source has a constant bitrate.
  */
-/* package */ final class ConstantBitrateSeeker implements Mp3Extractor.Seeker {
-
-  private static final int BITS_PER_BYTE = 8;
-
-  private final long firstFramePosition;
-  private final int frameSize;
-  private final long dataSize;
-  private final int bitrate;
-  private final long durationUs;
+/* package */ final class ConstantBitrateSeeker extends ConstantBitrateSeekMap
+    implements Mp3Extractor.Seeker {
 
   /**
    * @param inputLength The length of the stream in bytes, or {@link C#LENGTH_UNSET} if unknown.
    * @param firstFramePosition The position of the first frame in the stream.
    * @param mpegAudioHeader The MPEG audio header associated with the first frame.
    */
-  public ConstantBitrateSeeker(long inputLength, long firstFramePosition,
-      MpegAudioHeader mpegAudioHeader) {
-    this.firstFramePosition = firstFramePosition;
-    this.frameSize = mpegAudioHeader.frameSize;
-    this.bitrate = mpegAudioHeader.bitrate;
-    if (inputLength == C.LENGTH_UNSET) {
-      dataSize = C.LENGTH_UNSET;
-      durationUs = C.TIME_UNSET;
-    } else {
-      dataSize = inputLength - firstFramePosition;
-      durationUs = getTimeUs(inputLength);
-    }
-  }
-
-  @Override
-  public boolean isSeekable() {
-    return dataSize != C.LENGTH_UNSET;
-  }
-
-  @Override
-  public SeekPoints getSeekPoints(long timeUs) {
-    if (dataSize == C.LENGTH_UNSET) {
-      return new SeekPoints(new SeekPoint(0, firstFramePosition));
-    }
-    long positionOffset = (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
-    // Constrain to nearest preceding frame offset.
-    positionOffset = (positionOffset / frameSize) * frameSize;
-    positionOffset = Util.constrainValue(positionOffset, 0, dataSize - frameSize);
-    long seekPosition = firstFramePosition + positionOffset;
-    long seekTimeUs = getTimeUs(seekPosition);
-    SeekPoint seekPoint = new SeekPoint(seekTimeUs, seekPosition);
-    if (seekTimeUs >= timeUs || positionOffset == dataSize - frameSize) {
-      return new SeekPoints(seekPoint);
-    } else {
-      long secondSeekPosition = seekPosition + frameSize;
-      long secondSeekTimeUs = getTimeUs(secondSeekPosition);
-      SeekPoint secondSeekPoint = new SeekPoint(secondSeekTimeUs, secondSeekPosition);
-      return new SeekPoints(seekPoint, secondSeekPoint);
-    }
+  public ConstantBitrateSeeker(
+      long inputLength, long firstFramePosition, MpegAudioHeader mpegAudioHeader) {
+    super(inputLength, firstFramePosition, mpegAudioHeader.bitrate, mpegAudioHeader.frameSize);
   }
 
   @Override
   public long getTimeUs(long position) {
-    return (Math.max(0, position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE)
-        / bitrate;
+    return getTimeUsAtPosition(position);
   }
 
   @Override
-  public long getDurationUs() {
-    return durationUs;
+  public long getDataEndPosition() {
+    return C.POSITION_UNSET;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
new file mode 100644
index 0000000000..868c1d9fbf
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp3;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.SeekPoint;
+import com.google.android.exoplayer2.metadata.id3.MlltFrame;
+import com.google.android.exoplayer2.util.Util;
+
+/** MP3 seeker that uses metadata from an {@link MlltFrame}. */
+/* package */ final class MlltSeeker implements Mp3Extractor.Seeker {
+
+  /**
+   * Returns an {@link MlltSeeker} for seeking in the stream.
+   *
+   * @param firstFramePosition The position of the start of the first frame in the stream.
+   * @param mlltFrame The MLLT frame with seeking metadata.
+   * @return An {@link MlltSeeker} for seeking in the stream.
+   */
+  public static MlltSeeker create(long firstFramePosition, MlltFrame mlltFrame) {
+    int referenceCount = mlltFrame.bytesDeviations.length;
+    long[] referencePositions = new long[1 + referenceCount];
+    long[] referenceTimesMs = new long[1 + referenceCount];
+    referencePositions[0] = firstFramePosition;
+    referenceTimesMs[0] = 0;
+    long position = firstFramePosition;
+    long timeMs = 0;
+    for (int i = 1; i <= referenceCount; i++) {
+      position += mlltFrame.bytesBetweenReference + mlltFrame.bytesDeviations[i - 1];
+      timeMs += mlltFrame.millisecondsBetweenReference + mlltFrame.millisecondsDeviations[i - 1];
+      referencePositions[i] = position;
+      referenceTimesMs[i] = timeMs;
+    }
+    return new MlltSeeker(referencePositions, referenceTimesMs);
+  }
+
+  private final long[] referencePositions;
+  private final long[] referenceTimesMs;
+  private final long durationUs;
+
+  private MlltSeeker(long[] referencePositions, long[] referenceTimesMs) {
+    this.referencePositions = referencePositions;
+    this.referenceTimesMs = referenceTimesMs;
+    // Use the last reference point as the duration, as extrapolating variable bitrate at the end of
+    // the stream may give a large error.
+    durationUs = C.msToUs(referenceTimesMs[referenceTimesMs.length - 1]);
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public SeekPoints getSeekPoints(long timeUs) {
+    timeUs = Util.constrainValue(timeUs, 0, durationUs);
+    Pair<Long, Long> timeMsAndPosition =
+        linearlyInterpolate(C.usToMs(timeUs), referenceTimesMs, referencePositions);
+    timeUs = C.msToUs(timeMsAndPosition.first);
+    long position = timeMsAndPosition.second;
+    return new SeekPoints(new SeekPoint(timeUs, position));
+  }
+
+  @Override
+  public long getTimeUs(long position) {
+    Pair<Long, Long> positionAndTimeMs =
+        linearlyInterpolate(position, referencePositions, referenceTimesMs);
+    return C.msToUs(positionAndTimeMs.second);
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Given a set of reference points as coordinates in {@code xReferences} and {@code yReferences}
+   * and an x-axis value, linearly interpolates between corresponding reference points to give a
+   * y-axis value.
+   *
+   * @param x The x-axis value for which a y-axis value is needed.
+   * @param xReferences x coordinates of reference points.
+   * @param yReferences y coordinates of reference points.
+   * @return The linearly interpolated y-axis value.
+   */
+  private static Pair<Long, Long> linearlyInterpolate(
+      long x, long[] xReferences, long[] yReferences) {
+    int previousReferenceIndex =
+        Util.binarySearchFloor(xReferences, x, /* inclusive= */ true, /* stayInBounds= */ true);
+    long xPreviousReference = xReferences[previousReferenceIndex];
+    long yPreviousReference = yReferences[previousReferenceIndex];
+    int nextReferenceIndex = previousReferenceIndex + 1;
+    if (nextReferenceIndex == xReferences.length) {
+      return Pair.create(xPreviousReference, yPreviousReference);
+    } else {
+      long xNextReference = xReferences[nextReferenceIndex];
+      long yNextReference = yReferences[nextReferenceIndex];
+      double proportion =
+          xNextReference == xPreviousReference
+              ? 0.0
+              : ((double) x - xPreviousReference) / (xNextReference - xPreviousReference);
+      long y = (long) (proportion * (yNextReference - yPreviousReference)) + yPreviousReference;
+      return Pair.create(x, y);
+    }
+  }
+
+  @Override
+  public long getDataEndPosition() {
+    return C.POSITION_UNSET;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index bd786191a0..e8848bf983 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp3;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -31,10 +32,13 @@
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder.FramePredicate;
+import com.google.android.exoplayer2.metadata.id3.MlltFrame;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -43,23 +47,18 @@
  */
 public final class Mp3Extractor implements Extractor {
 
-  /**
-   * Factory for {@link Mp3Extractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new Mp3Extractor()};
-    }
-
-  };
+  /** Factory for {@link Mp3Extractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new Mp3Extractor()};
 
   /**
-   * Flags controlling the behavior of the extractor.
+   * Flags controlling the behavior of the extractor. Possible flag values are {@link
+   * #FLAG_ENABLE_CONSTANT_BITRATE_SEEKING} and {@link #FLAG_DISABLE_ID3_METADATA}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_ENABLE_CONSTANT_BITRATE_SEEKING, FLAG_DISABLE_ID3_METADATA})
+  @IntDef(
+      flag = true,
+      value = {FLAG_ENABLE_CONSTANT_BITRATE_SEEKING, FLAG_DISABLE_ID3_METADATA})
   public @interface Flags {}
   /**
    * Flag to force enable seeking using a constant bitrate assumption in cases where seeking would
@@ -72,6 +71,12 @@
    */
   public static final int FLAG_DISABLE_ID3_METADATA = 2;
 
+  /** Predicate that matches ID3 frames containing only required gapless/seeking metadata. */
+  private static final FramePredicate REQUIRED_ID3_FRAME_PREDICATE =
+      (majorVersion, id0, id1, id2, id3) ->
+          ((id0 == 'C' && id1 == 'O' && id2 == 'M' && (id3 == 'M' || majorVersion == 2))
+              || (id0 == 'M' && id1 == 'L' && id2 == 'L' && (id3 == 'T' || majorVersion == 2)));
+
   /**
    * The maximum number of bytes to search when synchronizing, before giving up.
    */
@@ -178,7 +183,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       }
     }
     if (seeker == null) {
-      seeker = maybeReadSeekFrame(input);
+      // Read past any seek frame and set the seeker based on metadata or a seek frame. Metadata
+      // takes priority as it can provide greater precision.
+      Seeker seekFrameSeeker = maybeReadSeekFrame(input);
+      Seeker metadataSeeker = maybeHandleSeekMetadata(metadata, input.getPosition());
+      if (metadataSeeker != null) {
+        seeker = metadataSeeker;
+      } else if (seekFrameSeeker != null) {
+        seeker = seekFrameSeeker;
+      }
       if (seeker == null
           || (!seeker.isSeekable() && (flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) != 0)) {
         seeker = getConstantBitrateSeeker(input);
@@ -210,7 +223,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
     if (sampleBytesRemaining == 0) {
       extractorInput.resetPeekPosition();
-      if (!extractorInput.peekFully(scratch.data, 0, 4, true)) {
+      if (peekEndOfStreamOrHeader(extractorInput)) {
         return RESULT_END_OF_INPUT;
       }
       scratch.setPosition(0);
@@ -257,11 +270,11 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     int searchLimitBytes = sniffing ? MAX_SNIFF_BYTES : MAX_SYNC_BYTES;
     input.resetPeekPosition();
     if (input.getPosition() == 0) {
-      // We need to parse enough ID3 metadata to retrieve any gapless playback information even
-      // if ID3 metadata parsing is disabled.
-      boolean onlyDecodeGaplessInfoFrames = (flags & FLAG_DISABLE_ID3_METADATA) != 0;
+      // We need to parse enough ID3 metadata to retrieve any gapless/seeking playback information
+      // even if ID3 metadata parsing is disabled.
+      boolean parseAllId3Frames = (flags & FLAG_DISABLE_ID3_METADATA) == 0;
       Id3Decoder.FramePredicate id3FramePredicate =
-          onlyDecodeGaplessInfoFrames ? GaplessInfoHolder.GAPLESS_INFO_ID3_FRAME_PREDICATE : null;
+          parseAllId3Frames ? null : REQUIRED_ID3_FRAME_PREDICATE;
       metadata = id3Peeker.peekId3Data(input, id3FramePredicate);
       if (metadata != null) {
         gaplessInfoHolder.setFromMetadata(metadata);
@@ -272,9 +285,12 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
       }
     }
     while (true) {
-      if (!input.peekFully(scratch.data, 0, 4, validFrameCount > 0)) {
-        // We reached the end of the stream but found at least one valid frame.
-        break;
+      if (peekEndOfStreamOrHeader(input)) {
+        if (validFrameCount > 0) {
+          // We reached the end of the stream but found at least one valid frame.
+          break;
+        }
+        throw new EOFException();
       }
       scratch.setPosition(0);
       int headerData = scratch.readInt();
@@ -319,6 +335,17 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     return true;
   }
 
+  /**
+   * Returns whether the extractor input is peeking the end of the stream. If {@code false},
+   * populates the scratch buffer with the next four bytes.
+   */
+  private boolean peekEndOfStreamOrHeader(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    return (seeker != null && extractorInput.getPeekPosition() == seeker.getDataEndPosition())
+        || !extractorInput.peekFully(
+            scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true);
+  }
+
   /**
    * Consumes the next frame from the {@code input} if it contains VBRI or Xing seeking metadata,
    * returning a {@link Seeker} if the metadata was present and valid, or {@code null} otherwise.
@@ -405,9 +432,24 @@ private static int getSeekFrameHeader(ParsableByteArray frame, int xingBase) {
     return SEEK_HEADER_UNSET;
   }
 
+  @Nullable
+  private static MlltSeeker maybeHandleSeekMetadata(Metadata metadata, long firstFramePosition) {
+    if (metadata != null) {
+      int length = metadata.length();
+      for (int i = 0; i < length; i++) {
+        Metadata.Entry entry = metadata.get(i);
+        if (entry instanceof MlltFrame) {
+          return MlltSeeker.create(firstFramePosition, (MlltFrame) entry);
+        }
+      }
+    }
+    return null;
+  }
+
   /**
-   * {@link SeekMap} that also allows mapping from position (byte offset) back to time, which can be
-   * used to work out the new sample basis timestamp after seeking and resynchronization.
+   * {@link SeekMap} that provides the end position of audio data and also allows mapping from
+   * position (byte offset) back to time, which can be used to work out the new sample basis
+   * timestamp after seeking and resynchronization.
    */
   /* package */ interface Seeker extends SeekMap {
 
@@ -419,6 +461,11 @@ private static int getSeekFrameHeader(ParsableByteArray frame, int xingBase) {
      */
     long getTimeUs(long position);
 
+    /**
+     * Returns the position (byte offset) in the stream that is immediately after audio data, or
+     * {@link C#POSITION_UNSET} if not known.
+     */
+    long getDataEndPosition();
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
index f918b5c43d..15e778115d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.SeekPoint;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -42,8 +43,8 @@
    * @return A {@link VbriSeeker} for seeking in the stream, or {@code null} if the required
    *     information is not present.
    */
-  public static VbriSeeker create(long inputLength, long position, MpegAudioHeader mpegAudioHeader,
-      ParsableByteArray frame) {
+  public static @Nullable VbriSeeker create(
+      long inputLength, long position, MpegAudioHeader mpegAudioHeader, ParsableByteArray frame) {
     frame.skipBytes(10);
     int numFrames = frame.readInt();
     if (numFrames <= 0) {
@@ -88,17 +89,19 @@ public static VbriSeeker create(long inputLength, long position, MpegAudioHeader
     if (inputLength != C.LENGTH_UNSET && inputLength != position) {
       Log.w(TAG, "VBRI data size mismatch: " + inputLength + ", " + position);
     }
-    return new VbriSeeker(timesUs, positions, durationUs);
+    return new VbriSeeker(timesUs, positions, durationUs, /* dataEndPosition= */ position);
   }
 
   private final long[] timesUs;
   private final long[] positions;
   private final long durationUs;
+  private final long dataEndPosition;
 
-  private VbriSeeker(long[] timesUs, long[] positions, long durationUs) {
+  private VbriSeeker(long[] timesUs, long[] positions, long durationUs, long dataEndPosition) {
     this.timesUs = timesUs;
     this.positions = positions;
     this.durationUs = durationUs;
+    this.dataEndPosition = dataEndPosition;
   }
 
   @Override
@@ -128,4 +131,8 @@ public long getDurationUs() {
     return durationUs;
   }
 
+  @Override
+  public long getDataEndPosition() {
+    return dataEndPosition;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
index a3bd5a2da2..42752e55fb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
@@ -15,10 +15,12 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.SeekPoint;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -38,12 +40,12 @@
    * @param position The position of the start of this frame in the stream.
    * @param mpegAudioHeader The MPEG audio header associated with the frame.
    * @param frame The data in this audio frame, with its position set to immediately after the
-   *    'Xing' or 'Info' tag.
+   *     'Xing' or 'Info' tag.
    * @return A {@link XingSeeker} for seeking in the stream, or {@code null} if the required
    *     information is not present.
    */
-  public static XingSeeker create(long inputLength, long position, MpegAudioHeader mpegAudioHeader,
-      ParsableByteArray frame) {
+  public static @Nullable XingSeeker create(
+      long inputLength, long position, MpegAudioHeader mpegAudioHeader, ParsableByteArray frame) {
     int samplesPerFrame = mpegAudioHeader.samplesPerFrame;
     int sampleRate = mpegAudioHeader.sampleRate;
 
@@ -73,33 +75,44 @@ public static XingSeeker create(long inputLength, long position, MpegAudioHeader
     if (inputLength != C.LENGTH_UNSET && inputLength != position + dataSize) {
       Log.w(TAG, "XING data size mismatch: " + inputLength + ", " + (position + dataSize));
     }
-    return new XingSeeker(position, mpegAudioHeader.frameSize, durationUs, dataSize,
-        tableOfContents);
+    return new XingSeeker(
+        position, mpegAudioHeader.frameSize, durationUs, dataSize, tableOfContents);
   }
 
   private final long dataStartPosition;
   private final int xingFrameSize;
   private final long durationUs;
-  /**
-   * Data size, including the XING frame.
-   */
+  /** Data size, including the XING frame. */
   private final long dataSize;
+
+  private final long dataEndPosition;
   /**
-   * Entries are in the range [0, 255], but are stored as long integers for convenience.
+   * Entries are in the range [0, 255], but are stored as long integers for convenience. Null if the
+   * table of contents was missing from the header, in which case seeking is not be supported.
    */
-  private final long[] tableOfContents;
+  private final @Nullable long[] tableOfContents;
 
   private XingSeeker(long dataStartPosition, int xingFrameSize, long durationUs) {
-    this(dataStartPosition, xingFrameSize, durationUs, C.LENGTH_UNSET, null);
+    this(
+        dataStartPosition,
+        xingFrameSize,
+        durationUs,
+        /* dataSize= */ C.LENGTH_UNSET,
+        /* tableOfContents= */ null);
   }
 
-  private XingSeeker(long dataStartPosition, int xingFrameSize, long durationUs, long dataSize,
-      long[] tableOfContents) {
+  private XingSeeker(
+      long dataStartPosition,
+      int xingFrameSize,
+      long durationUs,
+      long dataSize,
+      @Nullable long[] tableOfContents) {
     this.dataStartPosition = dataStartPosition;
     this.xingFrameSize = xingFrameSize;
     this.durationUs = durationUs;
-    this.dataSize = dataSize;
     this.tableOfContents = tableOfContents;
+    this.dataSize = dataSize;
+    dataEndPosition = dataSize == C.LENGTH_UNSET ? C.POSITION_UNSET : dataStartPosition + dataSize;
   }
 
   @Override
@@ -121,6 +134,7 @@ public SeekPoints getSeekPoints(long timeUs) {
       scaledPosition = 256;
     } else {
       int prevTableIndex = (int) percent;
+      long[] tableOfContents = Assertions.checkNotNull(this.tableOfContents);
       double prevScaledPosition = tableOfContents[prevTableIndex];
       double nextScaledPosition = prevTableIndex == 99 ? 256 : tableOfContents[prevTableIndex + 1];
       // Linearly interpolate between the two scaled positions.
@@ -140,6 +154,7 @@ public long getTimeUs(long position) {
     if (!isSeekable() || positionOffset <= xingFrameSize) {
       return 0L;
     }
+    long[] tableOfContents = Assertions.checkNotNull(this.tableOfContents);
     double scaledPosition = (positionOffset * 256d) / dataSize;
     int prevTableIndex = Util.binarySearchFloor(tableOfContents, (long) scaledPosition, true, true);
     long prevTimeUs = getTimeUsForTableIndex(prevTableIndex);
@@ -157,6 +172,11 @@ public long getDurationUs() {
     return durationUs;
   }
 
+  @Override
+  public long getDataEndPosition() {
+    return dataEndPosition;
+  }
+
   /**
    * Returns the time in microseconds for a given table index.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index 21d861af30..f51c97389b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+@SuppressWarnings("ConstantField")
 /* package*/ abstract class Atom {
 
   /**
@@ -141,6 +143,12 @@
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
   public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
   public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
+  public static final int TYPE_alaw = Util.getIntegerCodeForString("alaw");
+  public static final int TYPE_ulaw = Util.getIntegerCodeForString("ulaw");
+  public static final int TYPE_Opus = Util.getIntegerCodeForString("Opus");
+  public static final int TYPE_dOps = Util.getIntegerCodeForString("dOps");
+  public static final int TYPE_fLaC = Util.getIntegerCodeForString("fLaC");
+  public static final int TYPE_dfLa = Util.getIntegerCodeForString("dfLa");
 
   public final int type;
 
@@ -214,14 +222,14 @@ public void add(ContainerAtom atom) {
 
     /**
      * Returns the child leaf of the given type.
-     * <p>
-     * If no child exists with the given type then null is returned. If multiple children exist with
-     * the given type then the first one to have been added is returned.
+     *
+     * <p>If no child exists with the given type then null is returned. If multiple children exist
+     * with the given type then the first one to have been added is returned.
      *
      * @param type The leaf type.
      * @return The child leaf of the given type, or null if no such child exists.
      */
-    public LeafAtom getLeafAtomOfType(int type) {
+    public @Nullable LeafAtom getLeafAtomOfType(int type) {
       int childrenSize = leafChildren.size();
       for (int i = 0; i < childrenSize; i++) {
         LeafAtom atom = leafChildren.get(i);
@@ -234,14 +242,14 @@ public LeafAtom getLeafAtomOfType(int type) {
 
     /**
      * Returns the child container of the given type.
-     * <p>
-     * If no child exists with the given type then null is returned. If multiple children exist with
-     * the given type then the first one to have been added is returned.
+     *
+     * <p>If no child exists with the given type then null is returned. If multiple children exist
+     * with the given type then the first one to have been added is returned.
      *
      * @param type The container type.
      * @return The child container of the given type, or null if no such child exists.
      */
-    public ContainerAtom getContainerAtomOfType(int type) {
+    public @Nullable ContainerAtom getContainerAtomOfType(int type) {
       int childrenSize = containerChildren.size();
       for (int i = 0; i < childrenSize; i++) {
         ContainerAtom atom = containerChildren.get(i);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index a2b787d6b0..d085156f2b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -17,7 +17,6 @@
 
 import static com.google.android.exoplayer2.util.MimeTypes.getMimeTypeFromMp4ObjectType;
 
-import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -28,6 +27,7 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -38,9 +38,8 @@
 import java.util.Collections;
 import java.util.List;
 
-/**
- * Utility methods for parsing MP4 format atom payloads according to ISO 14496-12.
- */
+/** Utility methods for parsing MP4 format atom payloads according to ISO 14496-12. */
+@SuppressWarnings("ConstantField")
 /* package */ final class AtomParsers {
 
   private static final String TAG = "AtomParsers";
@@ -59,6 +58,9 @@
    */
   private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 3;
 
+  /** The magic signature for an Opus Identification header, as defined in RFC-7845. */
+  private static final byte[] opusMagic = Util.getUtf8Bytes("OpusHead");
+
   /**
    * Parses a trak atom (defined in 14496-12).
    *
@@ -117,10 +119,11 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long
    * @param stblAtom stbl (sample table) atom to decode.
    * @param gaplessInfoHolder Holder to populate with gapless playback information.
    * @return Sample table described by the stbl atom.
-   * @throws ParserException If the resulting sample sequence does not contain a sync sample.
+   * @throws ParserException Thrown if the stbl atom can't be parsed.
    */
-  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom,
-      GaplessInfoHolder gaplessInfoHolder) throws ParserException {
+  public static TrackSampleTable parseStbl(
+      Track track, Atom.ContainerAtom stblAtom, GaplessInfoHolder gaplessInfoHolder)
+      throws ParserException {
     SampleSizeBox sampleSizeBox;
     Atom.LeafAtom stszAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz);
     if (stszAtom != null) {
@@ -136,7 +139,13 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     int sampleCount = sampleSizeBox.getSampleCount();
     if (sampleCount == 0) {
       return new TrackSampleTable(
-          new long[0], new int[0], 0, new long[0], new int[0], C.TIME_UNSET);
+          track,
+          /* offsets= */ new long[0],
+          /* sizes= */ new int[0],
+          /* maximumSize= */ 0,
+          /* timestampsUs= */ new long[0],
+          /* flags= */ new int[0],
+          /* durationUs= */ C.TIME_UNSET);
     }
 
     // Entries are byte offsets of chunks.
@@ -215,11 +224,20 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
 
       for (int i = 0; i < sampleCount; i++) {
         // Advance to the next chunk if necessary.
-        while (remainingSamplesInChunk == 0) {
-          Assertions.checkState(chunkIterator.moveNext());
+        boolean chunkDataComplete = true;
+        while (remainingSamplesInChunk == 0 && (chunkDataComplete = chunkIterator.moveNext())) {
           offset = chunkIterator.offset;
           remainingSamplesInChunk = chunkIterator.numSamples;
         }
+        if (!chunkDataComplete) {
+          Log.w(TAG, "Unexpected end of chunk data");
+          sampleCount = i;
+          offsets = Arrays.copyOf(offsets, sampleCount);
+          sizes = Arrays.copyOf(sizes, sampleCount);
+          timestamps = Arrays.copyOf(timestamps, sampleCount);
+          flags = Arrays.copyOf(flags, sampleCount);
+          break;
+        }
 
         // Add on the timestamp offset if ctts is present.
         if (ctts != null) {
@@ -273,23 +291,38 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       }
       duration = timestampTimeUnits + timestampOffset;
 
-      Assertions.checkArgument(remainingSamplesAtTimestampOffset == 0);
-      // Remove trailing ctts entries with 0-valued sample counts.
+      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
+      // still be playable.
+      boolean isCttsValid = true;
       while (remainingTimestampOffsetChanges > 0) {
-        Assertions.checkArgument(ctts.readUnsignedIntToInt() == 0);
+        if (ctts.readUnsignedIntToInt() != 0) {
+          isCttsValid = false;
+          break;
+        }
         ctts.readInt(); // Ignore offset.
         remainingTimestampOffsetChanges--;
       }
-
-      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
-      // still be playable.
-      if (remainingSynchronizationSamples != 0 || remainingSamplesAtTimestampDelta != 0
-          || remainingSamplesInChunk != 0 || remainingTimestampDeltaChanges != 0) {
-        Log.w(TAG, "Inconsistent stbl box for track " + track.id
-            + ": remainingSynchronizationSamples " + remainingSynchronizationSamples
-            + ", remainingSamplesAtTimestampDelta " + remainingSamplesAtTimestampDelta
-            + ", remainingSamplesInChunk " + remainingSamplesInChunk
-            + ", remainingTimestampDeltaChanges " + remainingTimestampDeltaChanges);
+      if (remainingSynchronizationSamples != 0
+          || remainingSamplesAtTimestampDelta != 0
+          || remainingSamplesInChunk != 0
+          || remainingTimestampDeltaChanges != 0
+          || remainingSamplesAtTimestampOffset != 0
+          || !isCttsValid) {
+        Log.w(
+            TAG,
+            "Inconsistent stbl box for track "
+                + track.id
+                + ": remainingSynchronizationSamples "
+                + remainingSynchronizationSamples
+                + ", remainingSamplesAtTimestampDelta "
+                + remainingSamplesAtTimestampDelta
+                + ", remainingSamplesInChunk "
+                + remainingSamplesInChunk
+                + ", remainingTimestampDeltaChanges "
+                + remainingTimestampDeltaChanges
+                + ", remainingSamplesAtTimestampOffset "
+                + remainingSamplesAtTimestampOffset
+                + (!isCttsValid ? ", ctts invalid" : ""));
       }
     } else {
       long[] chunkOffsetsBytes = new long[chunkIterator.length];
@@ -315,7 +348,8 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       // There is no edit list, or we are ignoring it as we already have gapless metadata to apply.
       // This implementation does not support applying both gapless metadata and an edit list.
       Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+      return new TrackSampleTable(
+          track, offsets, sizes, maximumSize, timestamps, flags, durationUs);
     }
 
     // See the BMFF spec (ISO 14496-12) subsection 8.6.6. Edit lists that require prerolling from a
@@ -342,7 +376,11 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
           gaplessInfoHolder.encoderDelay = (int) encoderDelay;
           gaplessInfoHolder.encoderPadding = (int) encoderPadding;
           Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
-          return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+          long editedDurationUs =
+              Util.scaleLargeTimestamp(
+                  track.editListDurations[0], C.MICROS_PER_SECOND, track.movieTimescale);
+          return new TrackSampleTable(
+              track, offsets, sizes, maximumSize, timestamps, flags, editedDurationUs);
         }
       }
     }
@@ -359,7 +397,8 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       }
       durationUs =
           Util.scaleLargeTimestamp(duration - editStartTime, C.MICROS_PER_SECOND, track.timescale);
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+      return new TrackSampleTable(
+          track, offsets, sizes, maximumSize, timestamps, flags, durationUs);
     }
 
     // Omit any sample at the end point of an edit for audio tracks.
@@ -369,19 +408,29 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     int editedSampleCount = 0;
     int nextSampleIndex = 0;
     boolean copyMetadata = false;
+    int[] startIndices = new int[track.editListDurations.length];
+    int[] endIndices = new int[track.editListDurations.length];
     for (int i = 0; i < track.editListDurations.length; i++) {
       long editMediaTime = track.editListMediaTimes[i];
       if (editMediaTime != -1) {
         long editDuration =
             Util.scaleLargeTimestamp(
                 track.editListDurations[i], track.timescale, track.movieTimescale);
-        int startIndex = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
-        int endIndex =
+        startIndices[i] = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
+        endIndices[i] =
             Util.binarySearchCeil(
                 timestamps, editMediaTime + editDuration, omitClippedSample, false);
-        editedSampleCount += endIndex - startIndex;
-        copyMetadata |= nextSampleIndex != startIndex;
-        nextSampleIndex = endIndex;
+        while (startIndices[i] < endIndices[i]
+            && (flags[startIndices[i]] & C.BUFFER_FLAG_KEY_FRAME) == 0) {
+          // Applying the edit correctly would require prerolling from the previous sync sample. In
+          // the current implementation we advance to the next sync sample instead. Only other
+          // tracks (i.e. audio) will be rendered until the time of the first sync sample.
+          // See https://github.com/google/ExoPlayer/issues/1659.
+          startIndices[i]++;
+        }
+        editedSampleCount += endIndices[i] - startIndices[i];
+        copyMetadata |= nextSampleIndex != startIndices[i];
+        nextSampleIndex = endIndices[i];
       }
     }
     copyMetadata |= editedSampleCount != sampleCount;
@@ -396,48 +445,31 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     int sampleIndex = 0;
     for (int i = 0; i < track.editListDurations.length; i++) {
       long editMediaTime = track.editListMediaTimes[i];
-      long editDuration = track.editListDurations[i];
-      if (editMediaTime != -1) {
-        long endMediaTime =
-            editMediaTime
-                + Util.scaleLargeTimestamp(editDuration, track.timescale, track.movieTimescale);
-        int startIndex = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
-        int endIndex = Util.binarySearchCeil(timestamps, endMediaTime, omitClippedSample, false);
-        if (copyMetadata) {
-          int count = endIndex - startIndex;
-          System.arraycopy(offsets, startIndex, editedOffsets, sampleIndex, count);
-          System.arraycopy(sizes, startIndex, editedSizes, sampleIndex, count);
-          System.arraycopy(flags, startIndex, editedFlags, sampleIndex, count);
-        }
-        for (int j = startIndex; j < endIndex; j++) {
-          long ptsUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.movieTimescale);
-          long timeInSegmentUs =
-              Util.scaleLargeTimestamp(
-                  timestamps[j] - editMediaTime, C.MICROS_PER_SECOND, track.timescale);
-          editedTimestamps[sampleIndex] = ptsUs + timeInSegmentUs;
-          if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
-            editedMaximumSize = sizes[j];
-          }
-          sampleIndex++;
+      int startIndex = startIndices[i];
+      int endIndex = endIndices[i];
+      if (copyMetadata) {
+        int count = endIndex - startIndex;
+        System.arraycopy(offsets, startIndex, editedOffsets, sampleIndex, count);
+        System.arraycopy(sizes, startIndex, editedSizes, sampleIndex, count);
+        System.arraycopy(flags, startIndex, editedFlags, sampleIndex, count);
+      }
+      for (int j = startIndex; j < endIndex; j++) {
+        long ptsUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.movieTimescale);
+        long timeInSegmentUs =
+            Util.scaleLargeTimestamp(
+                timestamps[j] - editMediaTime, C.MICROS_PER_SECOND, track.timescale);
+        editedTimestamps[sampleIndex] = ptsUs + timeInSegmentUs;
+        if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
+          editedMaximumSize = sizes[j];
         }
+        sampleIndex++;
       }
-      pts += editDuration;
-    }
-    long editedDurationUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.timescale);
-
-    boolean hasSyncSample = false;
-    for (int i = 0; i < editedFlags.length && !hasSyncSample; i++) {
-      hasSyncSample |= (editedFlags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0;
+      pts += track.editListDurations[i];
     }
-    if (!hasSyncSample) {
-      // We don't support edit lists where the edited sample sequence doesn't contain a sync sample.
-      // Such edit lists are often (although not always) broken, so we ignore it and continue.
-      Log.w(TAG, "Ignoring edit list: Edited sample sequence does not contain a sync sample.");
-      Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
-    }
-
+    long editedDurationUs =
+        Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.movieTimescale);
     return new TrackSampleTable(
+        track,
         editedOffsets,
         editedSizes,
         editedMaximumSize,
@@ -612,9 +644,11 @@ private static int parseHdlr(ParsableByteArray hdlr) {
     long timescale = mdhd.readUnsignedInt();
     mdhd.skipBytes(version == 0 ? 4 : 8);
     int languageCode = mdhd.readUnsignedShort();
-    String language = "" + (char) (((languageCode >> 10) & 0x1F) + 0x60)
-        + (char) (((languageCode >> 5) & 0x1F) + 0x60)
-        + (char) (((languageCode) & 0x1F) + 0x60);
+    String language =
+        ""
+            + (char) (((languageCode >> 10) & 0x1F) + 0x60)
+            + (char) (((languageCode >> 5) & 0x1F) + 0x60)
+            + (char) ((languageCode & 0x1F) + 0x60);
     return Pair.create(timescale, language);
   }
 
@@ -646,13 +680,24 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
           || childAtomType == Atom.TYPE_vp09) {
         parseVideoSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             rotationDegrees, drmInitData, out, i);
-      } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
-          || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3
-          || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
-          || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
-          || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
-          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt
-          || childAtomType == Atom.TYPE__mp3 || childAtomType == Atom.TYPE_alac) {
+      } else if (childAtomType == Atom.TYPE_mp4a
+          || childAtomType == Atom.TYPE_enca
+          || childAtomType == Atom.TYPE_ac_3
+          || childAtomType == Atom.TYPE_ec_3
+          || childAtomType == Atom.TYPE_dtsc
+          || childAtomType == Atom.TYPE_dtse
+          || childAtomType == Atom.TYPE_dtsh
+          || childAtomType == Atom.TYPE_dtsl
+          || childAtomType == Atom.TYPE_samr
+          || childAtomType == Atom.TYPE_sawb
+          || childAtomType == Atom.TYPE_lpcm
+          || childAtomType == Atom.TYPE_sowt
+          || childAtomType == Atom.TYPE__mp3
+          || childAtomType == Atom.TYPE_alac
+          || childAtomType == Atom.TYPE_alaw
+          || childAtomType == Atom.TYPE_ulaw
+          || childAtomType == Atom.TYPE_Opus
+          || childAtomType == Atom.TYPE_fLaC) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             language, isQuickTime, drmInitData, out, i);
       } else if (childAtomType == Atom.TYPE_TTML || childAtomType == Atom.TYPE_tx3g
@@ -700,8 +745,18 @@ private static void parseTextSampleEntry(ParsableByteArray parent, int atomType,
       throw new IllegalStateException();
     }
 
-    out.format = Format.createTextSampleFormat(Integer.toString(trackId), mimeType, null,
-        Format.NO_VALUE, 0, language, Format.NO_VALUE, null, subsampleOffsetUs, initializationData);
+    out.format =
+        Format.createTextSampleFormat(
+            Integer.toString(trackId),
+            mimeType,
+            /* codecs= */ null,
+            /* bitrate= */ Format.NO_VALUE,
+            /* selectionFlags= */ 0,
+            language,
+            /* accessibilityChannel= */ Format.NO_VALUE,
+            /* drmInitData= */ null,
+            subsampleOffsetUs,
+            initializationData);
   }
 
   private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType, int position,
@@ -935,6 +990,14 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_MPEG;
     } else if (atomType == Atom.TYPE_alac) {
       mimeType = MimeTypes.AUDIO_ALAC;
+    } else if (atomType == Atom.TYPE_alaw) {
+      mimeType = MimeTypes.AUDIO_ALAW;
+    } else if (atomType == Atom.TYPE_ulaw) {
+      mimeType = MimeTypes.AUDIO_MLAW;
+    } else if (atomType == Atom.TYPE_Opus) {
+      mimeType = MimeTypes.AUDIO_OPUS;
+    } else if (atomType == Atom.TYPE_fLaC) {
+      mimeType = MimeTypes.AUDIO_FLAC;
     }
 
     byte[] initializationData = null;
@@ -975,7 +1038,20 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       } else if (childAtomType == Atom.TYPE_alac) {
         initializationData = new byte[childAtomSize];
         parent.setPosition(childPosition);
-        parent.readBytes(initializationData, 0, childAtomSize);
+        parent.readBytes(initializationData, /* offset= */ 0, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_dOps) {
+        // Build an Opus Identification Header (defined in RFC-7845) by concatenating the Opus Magic
+        // Signature and the body of the dOps atom.
+        int childAtomBodySize = childAtomSize - Atom.HEADER_SIZE;
+        initializationData = new byte[opusMagic.length + childAtomBodySize];
+        System.arraycopy(opusMagic, 0, initializationData, 0, opusMagic.length);
+        parent.setPosition(childPosition + Atom.HEADER_SIZE);
+        parent.readBytes(initializationData, opusMagic.length, childAtomBodySize);
+      } else if (childAtomSize == Atom.TYPE_dfLa) {
+        int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
+        initializationData = new byte[childAtomBodySize];
+        parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
+        parent.readBytes(initializationData, /* offset= */ 0, childAtomBodySize);
       }
       childPosition += childAtomSize;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index 0bf42f1839..0f1fd8f649 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -17,7 +17,6 @@
 
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
@@ -37,12 +36,14 @@
 import com.google.android.exoplayer2.extractor.mp4.Atom.LeafAtom;
 import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayDeque;
@@ -57,25 +58,27 @@
  */
 public final class FragmentedMp4Extractor implements Extractor {
 
-  /**
-   * Factory for {@link FragmentedMp4Extractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new FragmentedMp4Extractor()};
-    }
-
-  };
+  /** Factory for {@link FragmentedMp4Extractor} instances. */
+  public static final ExtractorsFactory FACTORY =
+      () -> new Extractor[] {new FragmentedMp4Extractor()};
 
   /**
-   * Flags controlling the behavior of the extractor.
+   * Flags controlling the behavior of the extractor. Possible flag values are {@link
+   * #FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME}, {@link #FLAG_WORKAROUND_IGNORE_TFDT_BOX},
+   * {@link #FLAG_ENABLE_EMSG_TRACK}, {@link #FLAG_SIDELOADED} and {@link
+   * #FLAG_WORKAROUND_IGNORE_EDIT_LISTS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
-      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_SIDELOADED,
-      FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
+  @IntDef(
+      flag = true,
+      value = {
+        FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
+        FLAG_WORKAROUND_IGNORE_TFDT_BOX,
+        FLAG_ENABLE_EMSG_TRACK,
+        FLAG_SIDELOADED,
+        FLAG_WORKAROUND_IGNORE_EDIT_LISTS
+      })
   public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -85,27 +88,26 @@
    * This flag does nothing if the stream is not a video stream.
    */
   public static final int FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME = 1;
-  /**
-   * Flag to ignore any tfdt boxes in the stream.
-   */
-  public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 2;
+  /** Flag to ignore any tfdt boxes in the stream. */
+  public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 1 << 1; // 2
   /**
    * Flag to indicate that the extractor should output an event message metadata track. Any event
    * messages in the stream will be delivered as samples to this track.
    */
-  public static final int FLAG_ENABLE_EMSG_TRACK = 4;
+  public static final int FLAG_ENABLE_EMSG_TRACK = 1 << 2; // 4
   /**
    * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
    * container.
    */
-  private static final int FLAG_SIDELOADED = 8;
-  /**
-   * Flag to ignore any edit lists in the stream.
-   */
-  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 16;
+  private static final int FLAG_SIDELOADED = 1 << 3; // 8
+  /** Flag to ignore any edit lists in the stream. */
+  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 1 << 4; // 16
 
   private static final String TAG = "FragmentedMp4Extractor";
+
+  @SuppressWarnings("ConstantField")
   private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
+
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
   private static final Format EMSG_FORMAT =
@@ -201,8 +203,7 @@ public FragmentedMp4Extractor(
       @Nullable TimestampAdjuster timestampAdjuster,
       @Nullable Track sideloadedTrack,
       @Nullable DrmInitData sideloadedDrmInitData) {
-    this(flags, timestampAdjuster, sideloadedTrack, sideloadedDrmInitData,
-        Collections.<Format>emptyList());
+    this(flags, timestampAdjuster, sideloadedTrack, sideloadedDrmInitData, Collections.emptyList());
   }
 
   /**
@@ -499,7 +500,7 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       for (int i = 0; i < trackCount; i++) {
         Track track = tracks.valueAt(i);
         TrackBundle trackBundle = new TrackBundle(extractorOutput.track(i, track.type));
-        trackBundle.init(track, defaultSampleValuesArray.get(track.id));
+        trackBundle.init(track, getDefaultSampleValues(defaultSampleValuesArray, track.id));
         trackBundles.put(track.id, trackBundle);
         durationUs = Math.max(durationUs, track.durationUs);
       }
@@ -509,11 +510,23 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       Assertions.checkState(trackBundles.size() == trackCount);
       for (int i = 0; i < trackCount; i++) {
         Track track = tracks.valueAt(i);
-        trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+        trackBundles
+            .get(track.id)
+            .init(track, getDefaultSampleValues(defaultSampleValuesArray, track.id));
       }
     }
   }
 
+  private DefaultSampleValues getDefaultSampleValues(
+      SparseArray<DefaultSampleValues> defaultSampleValuesArray, int trackId) {
+    if (defaultSampleValuesArray.size() == 1) {
+      // Ignore track id if there is only one track to cope with non-matching track indices.
+      // See https://github.com/google/ExoPlayer/issues/4477.
+      return defaultSampleValuesArray.valueAt(/* index= */ 0);
+    }
+    return Assertions.checkNotNull(defaultSampleValuesArray.get(trackId));
+  }
+
   private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException {
     parseMoof(moof, trackBundles, flags, extendedTypeScratch);
     // If drm init data is sideloaded, we ignore pssh boxes.
@@ -586,10 +599,13 @@ private void onEmsgLeafAtomRead(ParsableByteArray atom) {
 
     // Output the sample metadata.
     if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
+      long sampleTimeUs = segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs;
+      if (timestampAdjuster != null) {
+        sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
+      }
       for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
         emsgTrackOutput.sampleMetadata(
-            segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs,
-            C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0 /* offset */, null);
+            sampleTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, /* offset= */ 0, null);
       }
     } else {
       // We need the first sample timestamp in the segment before we can output the metadata.
@@ -642,7 +658,7 @@ private static void parseMoof(ContainerAtom moof, SparseArray<TrackBundle> track
   private static void parseTraf(ContainerAtom traf, SparseArray<TrackBundle> trackBundleArray,
       @Flags int flags, byte[] extendedTypeScratch) throws ParserException {
     LeafAtom tfhd = traf.getLeafAtomOfType(Atom.TYPE_tfhd);
-    TrackBundle trackBundle = parseTfhd(tfhd.data, trackBundleArray, flags);
+    TrackBundle trackBundle = parseTfhd(tfhd.data, trackBundleArray);
     if (trackBundle == null) {
       return;
     }
@@ -728,7 +744,7 @@ private static void parseTruns(ContainerAtom traf, TrackBundle trackBundle, long
 
   private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArray saiz,
       TrackFragment out) throws ParserException {
-    int vectorSize = encryptionBox.initializationVectorSize;
+    int vectorSize = encryptionBox.perSampleIvSize;
     saiz.setPosition(Atom.HEADER_SIZE);
     int fullAtom = saiz.readInt();
     int flags = Atom.parseFullAtomFlags(fullAtom);
@@ -793,13 +809,13 @@ private static void parseSaio(ParsableByteArray saio, TrackFragment out) throws
    * @return The {@link TrackBundle} to which the {@link TrackFragment} belongs, or null if the tfhd
    *     does not refer to any {@link TrackBundle}.
    */
-  private static TrackBundle parseTfhd(ParsableByteArray tfhd,
-      SparseArray<TrackBundle> trackBundles, int flags) {
+  private static TrackBundle parseTfhd(
+      ParsableByteArray tfhd, SparseArray<TrackBundle> trackBundles) {
     tfhd.setPosition(Atom.HEADER_SIZE);
     int fullAtom = tfhd.readInt();
     int atomFlags = Atom.parseFullAtomFlags(fullAtom);
     int trackId = tfhd.readInt();
-    TrackBundle trackBundle = trackBundles.get((flags & FLAG_SIDELOADED) == 0 ? trackId : 0);
+    TrackBundle trackBundle = getTrackBundle(trackBundles, trackId);
     if (trackBundle == null) {
       return null;
     }
@@ -824,6 +840,17 @@ private static TrackBundle parseTfhd(ParsableByteArray tfhd,
     return trackBundle;
   }
 
+  private static @Nullable TrackBundle getTrackBundle(
+      SparseArray<TrackBundle> trackBundles, int trackId) {
+    if (trackBundles.size() == 1) {
+      // Ignore track id if there is only one track. This is either because we have a side-loaded
+      // track (flag FLAG_SIDELOADED) or to cope with non-matching track indices (see
+      // https://github.com/google/ExoPlayer/issues/4083).
+      return trackBundles.valueAt(/* index= */ 0);
+    }
+    return trackBundles.get(trackId);
+  }
+
   /**
    * Parses a tfdt atom (defined in 14496-12).
    *
@@ -1185,6 +1212,10 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     Track track = currentTrackBundle.track;
     TrackOutput output = currentTrackBundle.output;
     int sampleIndex = currentTrackBundle.currentSampleIndex;
+    long sampleTimeUs = fragment.getSamplePresentationTime(sampleIndex) * 1000L;
+    if (timestampAdjuster != null) {
+      sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
+    }
     if (track.nalUnitLengthFieldLength != 0) {
       // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
       // they're only 1 or 2 bytes long.
@@ -1225,8 +1256,7 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
             // If the format is H.265/HEVC the NAL unit header has two bytes so skip one more byte.
             nalBuffer.setPosition(MimeTypes.VIDEO_H265.equals(track.format.sampleMimeType) ? 1 : 0);
             nalBuffer.setLimit(unescapedLength);
-            CeaUtil.consume(fragment.getSamplePresentationTime(sampleIndex) * 1000L, nalBuffer,
-                cea608TrackOutputs);
+            CeaUtil.consume(sampleTimeUs, nalBuffer, cea608TrackOutputs);
           } else {
             // Write the payload of the NAL unit.
             writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);
@@ -1242,21 +1272,14 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
       }
     }
 
-    long sampleTimeUs = fragment.getSamplePresentationTime(sampleIndex) * 1000L;
-    if (timestampAdjuster != null) {
-      sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
-    }
-
     @C.BufferFlags int sampleFlags = fragment.sampleIsSyncFrameTable[sampleIndex]
         ? C.BUFFER_FLAG_KEY_FRAME : 0;
 
     // Encryption data.
     TrackOutput.CryptoData cryptoData = null;
-    if (fragment.definesEncryptionData) {
+    TrackEncryptionBox encryptionBox = currentTrackBundle.getEncryptionBoxIfEncrypted();
+    if (encryptionBox != null) {
       sampleFlags |= C.BUFFER_FLAG_ENCRYPTED;
-      TrackEncryptionBox encryptionBox = fragment.trackEncryptionBox != null
-          ? fragment.trackEncryptionBox
-          : track.getSampleDescriptionEncryptionBox(fragment.header.sampleDescriptionIndex);
       cryptoData = encryptionBox.cryptoData;
     }
 
@@ -1275,10 +1298,17 @@ private void outputPendingMetadataSamples(long sampleTimeUs) {
     while (!pendingMetadataSampleInfos.isEmpty()) {
       MetadataSampleInfo sampleInfo = pendingMetadataSampleInfos.removeFirst();
       pendingMetadataSampleBytes -= sampleInfo.size;
+      long metadataTimeUs = sampleTimeUs + sampleInfo.presentationTimeDeltaUs;
+      if (timestampAdjuster != null) {
+        metadataTimeUs = timestampAdjuster.adjustSampleTimestamp(metadataTimeUs);
+      }
       for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
         emsgTrackOutput.sampleMetadata(
-            sampleTimeUs + sampleInfo.presentationTimeDeltaUs,
-            C.BUFFER_FLAG_KEY_FRAME, sampleInfo.size, pendingMetadataSampleBytes, null);
+            metadataTimeUs,
+            C.BUFFER_FLAG_KEY_FRAME,
+            sampleInfo.size,
+            pendingMetadataSampleBytes,
+            null);
       }
     }
   }
@@ -1453,16 +1483,16 @@ public boolean next() {
      * @return The number of written bytes.
      */
     public int outputSampleEncryptionData() {
-      if (!fragment.definesEncryptionData) {
+      TrackEncryptionBox encryptionBox = getEncryptionBoxIfEncrypted();
+      if (encryptionBox == null) {
         return 0;
       }
 
-      TrackEncryptionBox encryptionBox = getEncryptionBox();
       ParsableByteArray initializationVectorData;
       int vectorSize;
-      if (encryptionBox.initializationVectorSize != 0) {
+      if (encryptionBox.perSampleIvSize != 0) {
         initializationVectorData = fragment.sampleEncryptionData;
-        vectorSize = encryptionBox.initializationVectorSize;
+        vectorSize = encryptionBox.perSampleIvSize;
       } else {
         // The default initialization vector should be used.
         byte[] initVectorData = encryptionBox.defaultInitializationVector;
@@ -1471,7 +1501,7 @@ public int outputSampleEncryptionData() {
         vectorSize = initVectorData.length;
       }
 
-      boolean subsampleEncryption = fragment.sampleHasSubsampleEncryptionTable[currentSampleIndex];
+      boolean subsampleEncryption = fragment.sampleHasSubsampleEncryptionTable(currentSampleIndex);
 
       // Write the signal byte, containing the vector size and the subsample encryption flag.
       encryptionSignalByte.data[0] = (byte) (vectorSize | (subsampleEncryption ? 0x80 : 0));
@@ -1494,25 +1524,27 @@ public int outputSampleEncryptionData() {
 
     /** Skips the encryption data for the current sample. */
     private void skipSampleEncryptionData() {
-      if (!fragment.definesEncryptionData) {
+      TrackEncryptionBox encryptionBox = getEncryptionBoxIfEncrypted();
+      if (encryptionBox == null) {
         return;
       }
 
       ParsableByteArray sampleEncryptionData = fragment.sampleEncryptionData;
-      TrackEncryptionBox encryptionBox = getEncryptionBox();
-      if (encryptionBox.initializationVectorSize != 0) {
-        sampleEncryptionData.skipBytes(encryptionBox.initializationVectorSize);
+      if (encryptionBox.perSampleIvSize != 0) {
+        sampleEncryptionData.skipBytes(encryptionBox.perSampleIvSize);
       }
-      if (fragment.sampleHasSubsampleEncryptionTable[currentSampleIndex]) {
+      if (fragment.sampleHasSubsampleEncryptionTable(currentSampleIndex)) {
         sampleEncryptionData.skipBytes(6 * sampleEncryptionData.readUnsignedShort());
       }
     }
 
-    private TrackEncryptionBox getEncryptionBox() {
+    private TrackEncryptionBox getEncryptionBoxIfEncrypted() {
       int sampleDescriptionIndex = fragment.header.sampleDescriptionIndex;
-      return fragment.trackEncryptionBox != null
-          ? fragment.trackEncryptionBox
-          : track.getSampleDescriptionEncryptionBox(sampleDescriptionIndex);
+      TrackEncryptionBox encryptionBox =
+          fragment.trackEncryptionBox != null
+              ? fragment.trackEncryptionBox
+              : track.getSampleDescriptionEncryptionBox(sampleDescriptionIndex);
+      return encryptionBox != null && encryptionBox.isEncrypted ? encryptionBox : null;
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
index fed1694925..670fe116a6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
 import com.google.android.exoplayer2.metadata.id3.Id3Frame;
+import com.google.android.exoplayer2.metadata.id3.InternalFrame;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -68,6 +70,8 @@
   // Type for items that are intended for internal use by the player.
   private static final int TYPE_INTERNAL = Util.getIntegerCodeForString("----");
 
+  private static final int PICTURE_TYPE_FRONT_COVER = 3;
+
   // Standard genres.
   private static final String[] STANDARD_GENRES = new String[] {
       // These are the official ID3v1 genres.
@@ -103,13 +107,13 @@ private MetadataUtil() {}
 
   /**
    * Parses a single ilst element from a {@link ParsableByteArray}. The element is read starting
-   * from the current position of the {@link ParsableByteArray}, and the position is advanced by
-   * the size of the element. The position is advanced even if the element's type is unrecognized.
+   * from the current position of the {@link ParsableByteArray}, and the position is advanced by the
+   * size of the element. The position is advanced even if the element's type is unrecognized.
    *
    * @param ilst Holds the data to be parsed.
    * @return The parsed element, or null if the element's type was not recognized.
    */
-  public static Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
+  public static @Nullable Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
     int position = ilst.getPosition();
     int endPosition = position + ilst.readInt();
     int type = ilst.readInt();
@@ -181,20 +185,20 @@ private MetadataUtil() {}
     }
   }
 
-  private static TextInformationFrame parseTextAttribute(int type, String id,
-      ParsableByteArray data) {
+  private static @Nullable TextInformationFrame parseTextAttribute(
+      int type, String id, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
       data.skipBytes(8); // version (1), flags (3), empty (4)
       String value = data.readNullTerminatedString(atomSize - 16);
-      return new TextInformationFrame(id, null, value);
+      return new TextInformationFrame(id, /* description= */ null, value);
     }
     Log.w(TAG, "Failed to parse text attribute: " + Atom.getAtomTypeString(type));
     return null;
   }
 
-  private static CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
+  private static @Nullable CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
@@ -206,22 +210,27 @@ private static CommentFrame parseCommentAttribute(int type, ParsableByteArray da
     return null;
   }
 
-  private static Id3Frame parseUint8Attribute(int type, String id, ParsableByteArray data,
-      boolean isTextInformationFrame, boolean isBoolean) {
+  private static @Nullable Id3Frame parseUint8Attribute(
+      int type,
+      String id,
+      ParsableByteArray data,
+      boolean isTextInformationFrame,
+      boolean isBoolean) {
     int value = parseUint8AttributeValue(data);
     if (isBoolean) {
       value = Math.min(1, value);
     }
     if (value >= 0) {
-      return isTextInformationFrame ? new TextInformationFrame(id, null, Integer.toString(value))
+      return isTextInformationFrame
+          ? new TextInformationFrame(id, /* description= */ null, Integer.toString(value))
           : new CommentFrame(LANGUAGE_UNDEFINED, id, Integer.toString(value));
     }
     Log.w(TAG, "Failed to parse uint8 attribute: " + Atom.getAtomTypeString(type));
     return null;
   }
 
-  private static TextInformationFrame parseIndexAndCountAttribute(int type, String attributeName,
-      ParsableByteArray data) {
+  private static @Nullable TextInformationFrame parseIndexAndCountAttribute(
+      int type, String attributeName, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data && atomSize >= 22) {
@@ -233,25 +242,26 @@ private static TextInformationFrame parseIndexAndCountAttribute(int type, String
         if (count > 0) {
           value += "/" + count;
         }
-        return new TextInformationFrame(attributeName, null, value);
+        return new TextInformationFrame(attributeName, /* description= */ null, value);
       }
     }
     Log.w(TAG, "Failed to parse index/count attribute: " + Atom.getAtomTypeString(type));
     return null;
   }
 
-  private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArray data) {
+  private static @Nullable TextInformationFrame parseStandardGenreAttribute(
+      ParsableByteArray data) {
     int genreCode = parseUint8AttributeValue(data);
     String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
         ? STANDARD_GENRES[genreCode - 1] : null;
     if (genreString != null) {
-      return new TextInformationFrame("TCON", null, genreString);
+      return new TextInformationFrame("TCON", /* description= */ null, genreString);
     }
     Log.w(TAG, "Failed to parse standard genre code");
     return null;
   }
 
-  private static ApicFrame parseCoverArt(ParsableByteArray data) {
+  private static @Nullable ApicFrame parseCoverArt(ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
@@ -265,13 +275,18 @@ private static ApicFrame parseCoverArt(ParsableByteArray data) {
       data.skipBytes(4); // empty (4)
       byte[] pictureData = new byte[atomSize - 16];
       data.readBytes(pictureData, 0, pictureData.length);
-      return new ApicFrame(mimeType, null, 3 /* Cover (front) */, pictureData);
+      return new ApicFrame(
+          mimeType,
+          /* description= */ null,
+          /* pictureType= */ PICTURE_TYPE_FRONT_COVER,
+          pictureData);
     }
     Log.w(TAG, "Failed to parse cover art attribute");
     return null;
   }
 
-  private static Id3Frame parseInternalAttribute(ParsableByteArray data, int endPosition) {
+  private static @Nullable Id3Frame parseInternalAttribute(
+      ParsableByteArray data, int endPosition) {
     String domain = null;
     String name = null;
     int dataAtomPosition = -1;
@@ -293,14 +308,13 @@ private static Id3Frame parseInternalAttribute(ParsableByteArray data, int endPo
         data.skipBytes(atomSize - 12);
       }
     }
-    if (!"com.apple.iTunes".equals(domain) || !"iTunSMPB".equals(name) || dataAtomPosition == -1) {
-      // We're only interested in iTunSMPB.
+    if (domain == null || name == null || dataAtomPosition == -1) {
       return null;
     }
     data.setPosition(dataAtomPosition);
     data.skipBytes(16); // size (4), type (4), version (1), flags (3), empty (4)
     String value = data.readNullTerminatedString(dataAtomSize - 16);
-    return new CommentFrame(LANGUAGE_UNDEFINED, name, value);
+    return new InternalFrame(domain, name, value);
   }
 
   private static int parseUint8AttributeValue(ParsableByteArray data) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index e70a49a2d7..17c82c2c5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -35,6 +35,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayDeque;
@@ -46,35 +47,30 @@
  */
 public final class Mp4Extractor implements Extractor, SeekMap {
 
-  /**
-   * Factory for {@link Mp4Extractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new Mp4Extractor()};
-    }
-
-  };
+  /** Factory for {@link Mp4Extractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new Mp4Extractor()};
 
   /**
-   * Flags controlling the behavior of the extractor.
+   * Flags controlling the behavior of the extractor. Possible flag value is {@link
+   * #FLAG_WORKAROUND_IGNORE_EDIT_LISTS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
+  @IntDef(
+      flag = true,
+      value = {FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
   public @interface Flags {}
   /**
    * Flag to ignore any edit lists in the stream.
    */
   public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 1;
 
-  /**
-   * Parser states.
-   */
+  /** Parser states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_READING_ATOM_HEADER, STATE_READING_ATOM_PAYLOAD, STATE_READING_SAMPLE})
   private @interface State {}
+
   private static final int STATE_READING_ATOM_HEADER = 0;
   private static final int STATE_READING_ATOM_PAYLOAD = 1;
   private static final int STATE_READING_SAMPLE = 2;
@@ -391,25 +387,14 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
       }
     }
 
-    for (int i = 0; i < moov.containerChildren.size(); i++) {
-      Atom.ContainerAtom atom = moov.containerChildren.get(i);
-      if (atom.type != Atom.TYPE_trak) {
-        continue;
-      }
-
-      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd),
-          C.TIME_UNSET, null, (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0, isQuickTime);
-      if (track == null) {
-        continue;
-      }
-
-      Atom.ContainerAtom stblAtom = atom.getContainerAtomOfType(Atom.TYPE_mdia)
-          .getContainerAtomOfType(Atom.TYPE_minf).getContainerAtomOfType(Atom.TYPE_stbl);
-      TrackSampleTable trackSampleTable = AtomParsers.parseStbl(track, stblAtom, gaplessInfoHolder);
-      if (trackSampleTable.sampleCount == 0) {
-        continue;
-      }
+    boolean ignoreEditLists = (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0;
+    ArrayList<TrackSampleTable> trackSampleTables =
+        getTrackSampleTables(moov, gaplessInfoHolder, ignoreEditLists);
 
+    int trackCount = trackSampleTables.size();
+    for (int i = 0; i < trackCount; i++) {
+      TrackSampleTable trackSampleTable = trackSampleTables.get(i);
+      Track track = trackSampleTable.track;
       Mp4Track mp4Track = new Mp4Track(track, trackSampleTable,
           extractorOutput.track(i, track.type));
       // Each sample has up to three bytes of overhead for the start code that replaces its length.
@@ -445,6 +430,39 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
     extractorOutput.seekMap(this);
   }
 
+  private ArrayList<TrackSampleTable> getTrackSampleTables(
+      ContainerAtom moov, GaplessInfoHolder gaplessInfoHolder, boolean ignoreEditLists)
+      throws ParserException {
+    ArrayList<TrackSampleTable> trackSampleTables = new ArrayList<>();
+    for (int i = 0; i < moov.containerChildren.size(); i++) {
+      Atom.ContainerAtom atom = moov.containerChildren.get(i);
+      if (atom.type != Atom.TYPE_trak) {
+        continue;
+      }
+      Track track =
+          AtomParsers.parseTrak(
+              atom,
+              moov.getLeafAtomOfType(Atom.TYPE_mvhd),
+              /* duration= */ C.TIME_UNSET,
+              /* drmInitData= */ null,
+              ignoreEditLists,
+              isQuickTime);
+      if (track == null) {
+        continue;
+      }
+      Atom.ContainerAtom stblAtom =
+          atom.getContainerAtomOfType(Atom.TYPE_mdia)
+              .getContainerAtomOfType(Atom.TYPE_minf)
+              .getContainerAtomOfType(Atom.TYPE_stbl);
+      TrackSampleTable trackSampleTable = AtomParsers.parseStbl(track, stblAtom, gaplessInfoHolder);
+      if (trackSampleTable.sampleCount == 0) {
+        continue;
+      }
+      trackSampleTables.add(trackSampleTable);
+    }
+    return trackSampleTables;
+  }
+
   /**
    * Attempts to extract the next sample in the current mdat atom for the specified track.
    * <p>
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
index a033f5c663..40cfa13325 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.support.annotation.Nullable;
-import android.util.Log;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
 import java.util.UUID;
@@ -52,32 +52,41 @@ private PsshAtomUtil() {}
   @SuppressWarnings("ParameterNotNullable")
   public static byte[] buildPsshAtom(
       UUID systemId, @Nullable UUID[] keyIds, @Nullable byte[] data) {
-    boolean buildV1Atom = keyIds != null;
     int dataLength = data != null ? data.length : 0;
     int psshBoxLength = Atom.FULL_HEADER_SIZE + 16 /* SystemId */ + 4 /* DataSize */ + dataLength;
-    if (buildV1Atom) {
+    if (keyIds != null) {
       psshBoxLength += 4 /* KID_count */ + (keyIds.length * 16) /* KIDs */;
     }
     ByteBuffer psshBox = ByteBuffer.allocate(psshBoxLength);
     psshBox.putInt(psshBoxLength);
     psshBox.putInt(Atom.TYPE_pssh);
-    psshBox.putInt(buildV1Atom ? 0x01000000 : 0 /* version=(buildV1Atom ? 1 : 0), flags=0 */);
+    psshBox.putInt(keyIds != null ? 0x01000000 : 0 /* version=(buildV1Atom ? 1 : 0), flags=0 */);
     psshBox.putLong(systemId.getMostSignificantBits());
     psshBox.putLong(systemId.getLeastSignificantBits());
-    if (buildV1Atom) {
+    if (keyIds != null) {
       psshBox.putInt(keyIds.length);
       for (UUID keyId : keyIds) {
         psshBox.putLong(keyId.getMostSignificantBits());
         psshBox.putLong(keyId.getLeastSignificantBits());
       }
     }
-    if (dataLength != 0) {
+    if (data != null && data.length != 0) {
       psshBox.putInt(data.length);
       psshBox.put(data);
     } // Else the last 4 bytes are a 0 DataSize.
     return psshBox.array();
   }
 
+  /**
+   * Returns whether the data is a valid PSSH atom.
+   *
+   * @param data The data to parse.
+   * @return Whether the data is a valid PSSH atom.
+   */
+  public static boolean isPsshAtom(byte[] data) {
+    return parsePsshAtom(data) != null;
+  }
+
   /**
    * Parses the UUID from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 3adc5a8972..59cd602209 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -19,6 +19,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -28,8 +29,10 @@
 public final class Track {
 
   /**
-   * The transformation to apply to samples in the track, if any.
+   * The transformation to apply to samples in the track, if any. One of {@link
+   * #TRANSFORMATION_NONE} or {@link #TRANSFORMATION_CEA608_CDAT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TRANSFORMATION_NONE, TRANSFORMATION_CEA608_CDAT})
   public @interface Transformation {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
index d39aae0c5f..f09e6ae421 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
@@ -16,10 +16,10 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.support.annotation.Nullable;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 
 /**
  * Encapsulates information parsed from a track encryption (tenc) box or sample group description 
@@ -45,33 +45,36 @@
    */
   public final TrackOutput.CryptoData cryptoData;
 
-  /**
-   * The initialization vector size in bytes for the samples in the corresponding sample group.
-   */
-  public final int initializationVectorSize;
+  /** The initialization vector size in bytes for the samples in the corresponding sample group. */
+  public final int perSampleIvSize;
 
   /**
-   * If {@link #initializationVectorSize} is 0, holds the default initialization vector as defined
-   * in the track encryption box or sample group description box. Null otherwise.
+   * If {@link #perSampleIvSize} is 0, holds the default initialization vector as defined in the
+   * track encryption box or sample group description box. Null otherwise.
    */
   public final byte[] defaultInitializationVector;
 
   /**
    * @param isEncrypted See {@link #isEncrypted}.
    * @param schemeType See {@link #schemeType}.
-   * @param initializationVectorSize See {@link #initializationVectorSize}.
+   * @param perSampleIvSize See {@link #perSampleIvSize}.
    * @param keyId See {@link TrackOutput.CryptoData#encryptionKey}.
    * @param defaultEncryptedBlocks See {@link TrackOutput.CryptoData#encryptedBlocks}.
    * @param defaultClearBlocks See {@link TrackOutput.CryptoData#clearBlocks}.
    * @param defaultInitializationVector See {@link #defaultInitializationVector}.
    */
-  public TrackEncryptionBox(boolean isEncrypted, @Nullable String schemeType,
-      int initializationVectorSize, byte[] keyId, int defaultEncryptedBlocks,
-      int defaultClearBlocks, @Nullable byte[] defaultInitializationVector) {
-    Assertions.checkArgument(initializationVectorSize == 0 ^ defaultInitializationVector == null);
+  public TrackEncryptionBox(
+      boolean isEncrypted,
+      @Nullable String schemeType,
+      int perSampleIvSize,
+      byte[] keyId,
+      int defaultEncryptedBlocks,
+      int defaultClearBlocks,
+      @Nullable byte[] defaultInitializationVector) {
+    Assertions.checkArgument(perSampleIvSize == 0 ^ defaultInitializationVector == null);
     this.isEncrypted = isEncrypted;
     this.schemeType = schemeType;
-    this.initializationVectorSize = initializationVectorSize;
+    this.perSampleIvSize = perSampleIvSize;
     this.defaultInitializationVector = defaultInitializationVector;
     cryptoData = new TrackOutput.CryptoData(schemeToCryptoMode(schemeType), keyId,
         defaultEncryptedBlocks, defaultClearBlocks);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackFragment.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackFragment.java
index 5ac673d037..51ec2bf282 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackFragment.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackFragment.java
@@ -190,4 +190,8 @@ public long getSamplePresentationTime(int index) {
     return sampleDecodingTimeTable[index] + sampleCompositionTimeOffsetTable[index];
   }
 
+  /** Returns whether the sample at the given index has a subsample encryption table. */
+  public boolean sampleHasSubsampleEncryptionTable(int index) {
+    return definesEncryptionData && sampleHasSubsampleEncryptionTable[index];
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
index 9f77c49664..56851fc1e0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
@@ -24,29 +24,19 @@
  */
 /* package */ final class TrackSampleTable {
 
-  /**
-   * Number of samples.
-   */
+  /** The track corresponding to this sample table. */
+  public final Track track;
+  /** Number of samples. */
   public final int sampleCount;
-  /**
-   * Sample offsets in bytes.
-   */
+  /** Sample offsets in bytes. */
   public final long[] offsets;
-  /**
-   * Sample sizes in bytes.
-   */
+  /** Sample sizes in bytes. */
   public final int[] sizes;
-  /**
-   * Maximum sample size in {@link #sizes}.
-   */
+  /** Maximum sample size in {@link #sizes}. */
   public final int maximumSize;
-  /**
-   * Sample timestamps in microseconds.
-   */
+  /** Sample timestamps in microseconds. */
   public final long[] timestampsUs;
-  /**
-   * Sample flags.
-   */
+  /** Sample flags. */
   public final int[] flags;
   /**
    * The duration of the track sample table in microseconds, or {@link C#TIME_UNSET} if the sample
@@ -55,6 +45,7 @@
   public final long durationUs;
 
   public TrackSampleTable(
+      Track track,
       long[] offsets,
       int[] sizes,
       int maximumSize,
@@ -65,6 +56,7 @@ public TrackSampleTable(
     Assertions.checkArgument(offsets.length == timestampsUs.length);
     Assertions.checkArgument(flags.length == timestampsUs.length);
 
+    this.track = track;
     this.offsets = offsets;
     this.sizes = sizes;
     this.maximumSize = maximumSize;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
index 042ab681f9..93ed00a05b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
@@ -23,9 +23,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 
-/**
- * Used to seek in an Ogg stream.
- */
+/** Seeks in an Ogg stream. */
 /* package */ final class DefaultOggSeeker implements OggSeeker {
 
   //@VisibleForTesting
@@ -56,19 +54,27 @@
 
   /**
    * Constructs an OggSeeker.
+   *
    * @param startPosition Start position of the payload (inclusive).
    * @param endPosition End position of the payload (exclusive).
-   * @param streamReader StreamReader instance which owns this OggSeeker
+   * @param streamReader The {@link StreamReader} that owns this seeker.
    * @param firstPayloadPageSize The total size of the first payload page, in bytes.
    * @param firstPayloadPageGranulePosition The granule position of the first payload page.
+   * @param firstPayloadPageIsLastPage Whether the first payload page is also the last page in the
+   *     ogg stream.
    */
-  public DefaultOggSeeker(long startPosition, long endPosition, StreamReader streamReader,
-      int firstPayloadPageSize, long firstPayloadPageGranulePosition) {
+  public DefaultOggSeeker(
+      long startPosition,
+      long endPosition,
+      StreamReader streamReader,
+      long firstPayloadPageSize,
+      long firstPayloadPageGranulePosition,
+      boolean firstPayloadPageIsLastPage) {
     Assertions.checkArgument(startPosition >= 0 && endPosition > startPosition);
     this.streamReader = streamReader;
     this.startPosition = startPosition;
     this.endPosition = endPosition;
-    if (firstPayloadPageSize == endPosition - startPosition) {
+    if (firstPayloadPageSize == endPosition - startPosition || firstPayloadPageIsLastPage) {
       totalGranules = firstPayloadPageGranulePosition;
       state = STATE_IDLE;
     } else {
@@ -240,11 +246,11 @@ public long getDurationUs() {
    * Skips to the next page.
    *
    * @param input The {@code ExtractorInput} to skip to the next page.
-   * @throws IOException thrown if peeking/reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while peeking/reading from the input.
-   * @throws EOFException if the next page can't be found before the end of the input.
+   * @throws IOException If peeking/reading from the input fails.
+   * @throws InterruptedException If the thread is interrupted.
+   * @throws EOFException If the next page can't be found before the end of the input.
    */
-  //@VisibleForTesting
+  // @VisibleForTesting
   void skipToNextPage(ExtractorInput input) throws IOException, InterruptedException {
     if (!skipToNextPage(input, endPosition)) {
       // Not found until eof.
@@ -256,21 +262,21 @@ void skipToNextPage(ExtractorInput input) throws IOException, InterruptedExcepti
    * Skips to the next page. Searches for the next page header.
    *
    * @param input The {@code ExtractorInput} to skip to the next page.
-   * @param until Searches until this position.
-   * @return true if the next page is found.
+   * @param limit The limit up to which the search should take place.
+   * @return Whether the next page was found.
    * @throws IOException thrown if peeking/reading from the input fails.
    * @throws InterruptedException thrown if interrupted while peeking/reading from the input.
    */
-  //@VisibleForTesting
-  boolean skipToNextPage(ExtractorInput input, long until)
+  // @VisibleForTesting
+  boolean skipToNextPage(ExtractorInput input, long limit)
       throws IOException, InterruptedException {
-    until = Math.min(until + 3, endPosition);
+    limit = Math.min(limit + 3, endPosition);
     byte[] buffer = new byte[2048];
     int peekLength = buffer.length;
     while (true) {
-      if (input.getPosition() + peekLength > until) {
+      if (input.getPosition() + peekLength > limit) {
         // Make sure to not peek beyond the end of the input.
-        peekLength = (int) (until - input.getPosition());
+        peekLength = (int) (limit - input.getPosition());
         if (peekLength < 4) {
           // Not found until end.
           return false;
@@ -278,7 +284,9 @@ boolean skipToNextPage(ExtractorInput input, long until)
       }
       input.peekFully(buffer, 0, peekLength, false);
       for (int i = 0; i < peekLength - 3; i++) {
-        if (buffer[i] == 'O' && buffer[i + 1] == 'g' && buffer[i + 2] == 'g'
+        if (buffer[i] == 'O'
+            && buffer[i + 1] == 'g'
+            && buffer[i + 2] == 'g'
             && buffer[i + 3] == 'S') {
           // Match! Skip to the start of the pattern.
           input.skipFully(i);
@@ -295,13 +303,12 @@ boolean skipToNextPage(ExtractorInput input, long until)
    * total number of samples per channel.
    *
    * @param input The {@link ExtractorInput} to read from.
-   * @return the total number of samples of this input.
-   * @throws IOException thrown if reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while reading from the input.
+   * @return The total number of samples of this input.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If the thread is interrupted.
    */
-  //@VisibleForTesting
-  long readGranuleOfLastPage(ExtractorInput input)
-      throws IOException, InterruptedException {
+  // @VisibleForTesting
+  long readGranuleOfLastPage(ExtractorInput input) throws IOException, InterruptedException {
     skipToNextPage(input);
     pageHeader.reset();
     while ((pageHeader.type & 0x04) != 0x04 && input.getPosition() < endPosition) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
index a4d8f97d5b..5e74eab8d4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
@@ -31,17 +31,8 @@
  */
 public class OggExtractor implements Extractor {
 
-  /**
-   * Factory for {@link OggExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new OggExtractor()};
-    }
-
-  };
+  /** Factory for {@link OggExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new OggExtractor()};
 
   private static final int MAX_VERIFICATION_BYTES = 8;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java
index c7f4e9489b..482f0c5021 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java
@@ -51,11 +51,11 @@ public void reset() {
    * can resume properly from an error while reading a continued packet spanned across multiple
    * pages.
    *
-   * @param input the {@link ExtractorInput} to read data from.
-   * @return {@code true} if the read was successful. {@code false} if the end of the input was
-   *    encountered having read no data.
-   * @throws IOException thrown if reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while reading from input.
+   * @param input The {@link ExtractorInput} to read data from.
+   * @return {@code true} if the read was successful. The read fails if the end of the input is
+   *     encountered without reading data.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If the thread is interrupted.
    */
   public boolean populate(ExtractorInput input) throws IOException, InterruptedException {
     Assertions.checkState(input != null);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java
index e260a72d44..bbf7e2fc6b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java
@@ -71,13 +71,13 @@ public void reset() {
   /**
    * Peeks an Ogg page header and updates this {@link OggPageHeader}.
    *
-   * @param input the {@link ExtractorInput} to read from.
-   * @param quiet if {@code true} no Exceptions are thrown but {@code false} is return if something
-   *    goes wrong.
-   * @return {@code true} if the read was successful. {@code false} if the end of the input was
-   *    encountered having read no data.
-   * @throws IOException thrown if reading data fails or the stream is invalid.
-   * @throws InterruptedException thrown if thread is interrupted when reading/peeking.
+   * @param input The {@link ExtractorInput} to read from.
+   * @param quiet If {@code true}, no exceptions are thrown but {@code false} is returned if
+   *     something goes wrong.
+   * @return {@code true} if the read was successful. The read fails if the end of the input is
+   *     encountered without reading data.
+   * @throws IOException If reading data fails or the stream is invalid.
+   * @throws InterruptedException If the thread is interrupted.
    */
   public boolean populate(ExtractorInput input, boolean quiet)
       throws IOException, InterruptedException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java
index ce3b9ea6ba..ff5f115573 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
@@ -67,8 +66,7 @@ protected long preparePayload(ParsableByteArray packet) {
   }
 
   @Override
-  protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
-      throws IOException, InterruptedException {
+  protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData) {
     if (!headerRead) {
       byte[] metadata = Arrays.copyOf(packet.data, packet.limit());
       int channelCount = metadata[9] & 0xFF;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
index d136468faa..e459ad1e58 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
@@ -26,9 +26,8 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
 
-/**
- * StreamReader abstract class.
- */
+/** StreamReader abstract class. */
+@SuppressWarnings("UngroupedOverloads")
 /* package */ abstract class StreamReader {
 
   private static final int STATE_READ_HEADERS = 0;
@@ -145,9 +144,15 @@ private int readHeaders(ExtractorInput input) throws IOException, InterruptedExc
       oggSeeker = new UnseekableOggSeeker();
     } else {
       OggPageHeader firstPayloadPageHeader = oggPacket.getPageHeader();
-      oggSeeker = new DefaultOggSeeker(payloadStartPosition, input.getLength(), this,
-          firstPayloadPageHeader.headerSize + firstPayloadPageHeader.bodySize,
-          firstPayloadPageHeader.granulePosition);
+      boolean isLastPage = (firstPayloadPageHeader.type & 0x04) != 0; // Type 4 is end of stream.
+      oggSeeker =
+          new DefaultOggSeeker(
+              payloadStartPosition,
+              input.getLength(),
+              this,
+              firstPayloadPageHeader.headerSize + firstPayloadPageHeader.bodySize,
+              firstPayloadPageHeader.granulePosition,
+              isLastPage);
     }
 
     setupData = null;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java
index 31ac6858be..147ad5a20b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java
@@ -153,7 +153,7 @@ protected boolean readHeaders(ParsableByteArray packet, long position, SetupData
     buffer.setLimit(buffer.limit() + 4);
     // The vorbis decoder expects the number of samples in the packet
     // to be appended to the audio data as an int32
-    buffer.data[buffer.limit() - 4] = (byte) ((packetSampleCount) & 0xFF);
+    buffer.data[buffer.limit() - 4] = (byte) (packetSampleCount & 0xFF);
     buffer.data[buffer.limit() - 3] = (byte) ((packetSampleCount >>> 8) & 0xFF);
     buffer.data[buffer.limit() - 2] = (byte) ((packetSampleCount >>> 16) & 0xFF);
     buffer.data[buffer.limit() - 1] = (byte) ((packetSampleCount >>> 24) & 0xFF);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtil.java
index 0235fba272..1d7b50cd3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtil.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
-import android.util.Log;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.Arrays;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index bc37277c57..3741d52294 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.audio.Ac3Util;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -33,17 +35,8 @@
  */
 public final class Ac3Extractor implements Extractor {
 
-  /**
-   * Factory for {@link Ac3Extractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new Ac3Extractor()};
-    }
-
-  };
+  /** Factory for {@link Ac3Extractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new Ac3Extractor()};
 
   /**
    * The maximum number of bytes to search when sniffing, excluding ID3 information, before giving
@@ -94,7 +87,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
     int headerPosition = startPosition;
     int validFramesCount = 0;
     while (true) {
-      input.peekFully(scratch.data, 0, 5);
+      input.peekFully(scratch.data, 0, 6);
       scratch.setPosition(0);
       int syncBytes = scratch.readUnsignedShort();
       if (syncBytes != AC3_SYNC_WORD) {
@@ -112,7 +105,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
         if (frameSize == C.LENGTH_UNSET) {
           return false;
         }
-        input.advancePeekPosition(frameSize - 5);
+        input.advancePeekPosition(frameSize - 6);
       }
     }
   }
@@ -149,7 +142,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
 
     if (!startedPacket) {
       // Pass data to the reader as though it's contained within a single infinitely long packet.
-      reader.packetStarted(firstSampleTimestampUs, true);
+      reader.packetStarted(firstSampleTimestampUs, FLAG_DATA_ALIGNMENT_INDICATOR);
       startedPacket = true;
     }
     // TODO: Make it possible for the reader to consume the dataSource directly, so that it becomes
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 4141f83370..93724be92d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -33,9 +34,11 @@
  */
 public final class Ac3Reader implements ElementaryStreamReader {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_FINDING_SYNC, STATE_READING_HEADER, STATE_READING_SAMPLE})
   private @interface State {}
+
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
   private static final int STATE_READING_SAMPLE = 2;
@@ -97,7 +100,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator gener
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index a0a748660e..77b79fa19f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -15,7 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.extractor.ConstantBitrateSeekMap;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -23,50 +29,95 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Extracts data from AAC bit streams with ADTS framing.
  */
 public final class AdtsExtractor implements Extractor {
 
+  /** Factory for {@link AdtsExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new AdtsExtractor()};
+
   /**
-   * Factory for {@link AdtsExtractor} instances.
+   * Flags controlling the behavior of the extractor. Possible flag value is {@link
+   * #FLAG_ENABLE_CONSTANT_BITRATE_SEEKING}.
    */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new AdtsExtractor()};
-    }
-
-  };
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(
+      flag = true,
+      value = {FLAG_ENABLE_CONSTANT_BITRATE_SEEKING})
+  public @interface Flags {}
+  /**
+   * Flag to force enable seeking using a constant bitrate assumption in cases where seeking would
+   * otherwise not be possible.
+   *
+   * <p>Note that this approach may result in approximated stream duration and seek position that
+   * are not precise, especially when the stream bitrate varies a lot.
+   */
+  public static final int FLAG_ENABLE_CONSTANT_BITRATE_SEEKING = 1;
 
-  private static final int MAX_PACKET_SIZE = 200;
+  private static final int MAX_PACKET_SIZE = 2 * 1024;
   private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
   /**
    * The maximum number of bytes to search when sniffing, excluding the header, before giving up.
    * Frame sizes are represented by 13-bit fields, so expect a valid frame in the first 8192 bytes.
    */
   private static final int MAX_SNIFF_BYTES = 8 * 1024;
+  /**
+   * The maximum number of frames to use when calculating the average frame size for constant
+   * bitrate seeking.
+   */
+  private static final int NUM_FRAMES_FOR_AVERAGE_FRAME_SIZE = 1000;
+
+  private final @Flags int flags;
 
-  private final long firstSampleTimestampUs;
   private final AdtsReader reader;
   private final ParsableByteArray packetBuffer;
+  private final ParsableByteArray scratch;
+  private final ParsableBitArray scratchBits;
+  private final long firstStreamSampleTimestampUs;
 
+  private @Nullable ExtractorOutput extractorOutput;
+
+  private long firstSampleTimestampUs;
+  private long firstFramePosition;
+  private int averageFrameSize;
+  private boolean hasCalculatedAverageFrameSize;
   private boolean startedPacket;
+  private boolean hasOutputSeekMap;
 
   public AdtsExtractor() {
     this(0);
   }
 
-  public AdtsExtractor(long firstSampleTimestampUs) {
-    this.firstSampleTimestampUs = firstSampleTimestampUs;
+  public AdtsExtractor(long firstStreamSampleTimestampUs) {
+    this(/* firstStreamSampleTimestampUs= */ firstStreamSampleTimestampUs, /* flags= */ 0);
+  }
+
+  /**
+   * @param firstStreamSampleTimestampUs The timestamp to be used for the first sample of the stream
+   *     output from this extractor.
+   * @param flags Flags that control the extractor's behavior.
+   */
+  public AdtsExtractor(long firstStreamSampleTimestampUs, @Flags int flags) {
+    this.firstStreamSampleTimestampUs = firstStreamSampleTimestampUs;
+    this.firstSampleTimestampUs = firstStreamSampleTimestampUs;
+    this.flags = flags;
     reader = new AdtsReader(true);
     packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
+    averageFrameSize = C.LENGTH_UNSET;
+    firstFramePosition = C.POSITION_UNSET;
+    scratch = new ParsableByteArray(10);
+    scratchBits = new ParsableBitArray(scratch.data);
   }
 
   // Extractor implementation.
@@ -74,41 +125,26 @@ public AdtsExtractor(long firstSampleTimestampUs) {
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     // Skip any ID3 headers.
-    ParsableByteArray scratch = new ParsableByteArray(10);
-    ParsableBitArray scratchBits = new ParsableBitArray(scratch.data);
-    int startPosition = 0;
-    while (true) {
-      input.peekFully(scratch.data, 0, 10);
-      scratch.setPosition(0);
-      if (scratch.readUnsignedInt24() != ID3_TAG) {
-        break;
-      }
-      scratch.skipBytes(3);
-      int length = scratch.readSynchSafeInt();
-      startPosition += 10 + length;
-      input.advancePeekPosition(length);
-    }
-    input.resetPeekPosition();
-    input.advancePeekPosition(startPosition);
+    int startPosition = peekId3Header(input);
 
     // Try to find four or more consecutive AAC audio frames, exceeding the MPEG TS packet size.
     int headerPosition = startPosition;
-    int validFramesSize = 0;
+    int totalValidFramesSize = 0;
     int validFramesCount = 0;
     while (true) {
       input.peekFully(scratch.data, 0, 2);
       scratch.setPosition(0);
       int syncBytes = scratch.readUnsignedShort();
-      if ((syncBytes & 0xFFF6) != 0xFFF0) {
+      if (!AdtsReader.isAdtsSyncWord(syncBytes)) {
         validFramesCount = 0;
-        validFramesSize = 0;
+        totalValidFramesSize = 0;
         input.resetPeekPosition();
         if (++headerPosition - startPosition >= MAX_SNIFF_BYTES) {
           return false;
         }
         input.advancePeekPosition(headerPosition);
       } else {
-        if (++validFramesCount >= 4 && validFramesSize > 188) {
+        if (++validFramesCount >= 4 && totalValidFramesSize > TsExtractor.TS_PACKET_SIZE) {
           return true;
         }
 
@@ -121,22 +157,23 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
           return false;
         }
         input.advancePeekPosition(frameSize - 6);
-        validFramesSize += frameSize;
+        totalValidFramesSize += frameSize;
       }
     }
   }
 
   @Override
   public void init(ExtractorOutput output) {
+    this.extractorOutput = output;
     reader.createTracks(output, new TrackIdGenerator(0, 1));
     output.endTracks();
-    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
 
   @Override
   public void seek(long position, long timeUs) {
     startedPacket = false;
     reader.seek();
+    firstSampleTimestampUs = firstStreamSampleTimestampUs + timeUs;
   }
 
   @Override
@@ -147,8 +184,17 @@ public void release() {
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
+    long inputLength = input.getLength();
+    boolean canUseConstantBitrateSeeking =
+        (flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) != 0 && inputLength != C.LENGTH_UNSET;
+    if (canUseConstantBitrateSeeking) {
+      calculateAverageFrameSize(input);
+    }
+
     int bytesRead = input.read(packetBuffer.data, 0, MAX_PACKET_SIZE);
-    if (bytesRead == C.RESULT_END_OF_INPUT) {
+    boolean readEndOfStream = bytesRead == RESULT_END_OF_INPUT;
+    maybeOutputSeekMap(inputLength, canUseConstantBitrateSeeking, readEndOfStream);
+    if (readEndOfStream) {
       return RESULT_END_OF_INPUT;
     }
 
@@ -158,7 +204,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
     if (!startedPacket) {
       // Pass data to the reader as though it's contained within a single infinitely long packet.
-      reader.packetStarted(firstSampleTimestampUs, true);
+      reader.packetStarted(firstSampleTimestampUs, FLAG_DATA_ALIGNMENT_INDICATOR);
       startedPacket = true;
     }
     // TODO: Make it possible for reader to consume the dataSource directly, so that it becomes
@@ -167,4 +213,117 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     return RESULT_CONTINUE;
   }
 
+  private int peekId3Header(ExtractorInput input) throws IOException, InterruptedException {
+    int firstFramePosition = 0;
+    while (true) {
+      input.peekFully(scratch.data, 0, 10);
+      scratch.setPosition(0);
+      if (scratch.readUnsignedInt24() != ID3_TAG) {
+        break;
+      }
+      scratch.skipBytes(3);
+      int length = scratch.readSynchSafeInt();
+      firstFramePosition += 10 + length;
+      input.advancePeekPosition(length);
+    }
+    input.resetPeekPosition();
+    input.advancePeekPosition(firstFramePosition);
+    if (this.firstFramePosition == C.POSITION_UNSET) {
+      this.firstFramePosition = firstFramePosition;
+    }
+    return firstFramePosition;
+  }
+
+  private void maybeOutputSeekMap(
+      long inputLength, boolean canUseConstantBitrateSeeking, boolean readEndOfStream) {
+    if (hasOutputSeekMap) {
+      return;
+    }
+    boolean useConstantBitrateSeeking = canUseConstantBitrateSeeking && averageFrameSize > 0;
+    if (useConstantBitrateSeeking
+        && reader.getSampleDurationUs() == C.TIME_UNSET
+        && !readEndOfStream) {
+      // Wait for the sampleDurationUs to be available, or for the end of the stream to be reached,
+      // before creating seek map.
+      return;
+    }
+
+    ExtractorOutput extractorOutput = Assertions.checkNotNull(this.extractorOutput);
+    if (useConstantBitrateSeeking && reader.getSampleDurationUs() != C.TIME_UNSET) {
+      extractorOutput.seekMap(getConstantBitrateSeekMap(inputLength));
+    } else {
+      extractorOutput.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
+    }
+    hasOutputSeekMap = true;
+  }
+
+  private void calculateAverageFrameSize(ExtractorInput input)
+      throws IOException, InterruptedException {
+    if (hasCalculatedAverageFrameSize) {
+      return;
+    }
+    averageFrameSize = C.LENGTH_UNSET;
+    input.resetPeekPosition();
+    if (input.getPosition() == 0) {
+      // Skip any ID3 headers.
+      peekId3Header(input);
+    }
+
+    int numValidFrames = 0;
+    long totalValidFramesSize = 0;
+    while (input.peekFully(
+        scratch.data, /* offset= */ 0, /* length= */ 2, /* allowEndOfInput= */ true)) {
+      scratch.setPosition(0);
+      int syncBytes = scratch.readUnsignedShort();
+      if (!AdtsReader.isAdtsSyncWord(syncBytes)) {
+        // Invalid sync byte pattern.
+        // Constant bit-rate seeking will probably fail for this stream.
+        numValidFrames = 0;
+        break;
+      } else {
+        // Read the frame size.
+        if (!input.peekFully(
+            scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true)) {
+          break;
+        }
+        scratchBits.setPosition(14);
+        int currentFrameSize = scratchBits.readBits(13);
+        // Either the stream is malformed OR we're not parsing an ADTS stream.
+        if (currentFrameSize <= 6) {
+          hasCalculatedAverageFrameSize = true;
+          throw new ParserException("Malformed ADTS stream");
+        }
+        totalValidFramesSize += currentFrameSize;
+        if (++numValidFrames == NUM_FRAMES_FOR_AVERAGE_FRAME_SIZE) {
+          break;
+        }
+        if (!input.advancePeekPosition(currentFrameSize - 6, /* allowEndOfInput= */ true)) {
+          break;
+        }
+      }
+    }
+    input.resetPeekPosition();
+    if (numValidFrames > 0) {
+      averageFrameSize = (int) (totalValidFramesSize / numValidFrames);
+    } else {
+      averageFrameSize = C.LENGTH_UNSET;
+    }
+    hasCalculatedAverageFrameSize = true;
+  }
+
+  private SeekMap getConstantBitrateSeekMap(long inputLength) {
+    int bitrate = getBitrateFromFrameSize(averageFrameSize, reader.getSampleDurationUs());
+    return new ConstantBitrateSeekMap(inputLength, firstFramePosition, bitrate, averageFrameSize);
+  }
+
+  /**
+   * Returns the stream bitrate, given a frame size and the duration of that frame in microseconds.
+   *
+   * @param frameSize The size of each frame in the stream.
+   * @param durationUsPerFrame The duration of the given frame in microseconds.
+   * @return The stream bitrate.
+   */
+  private static int getBitrateFromFrameSize(int frameSize, long durationUsPerFrame) {
+    return (int) ((frameSize * C.BITS_PER_BYTE * C.MICROS_PER_SECOND) / durationUsPerFrame);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index 96b964a4c4..589b543170 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -25,6 +24,7 @@
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -39,9 +39,10 @@
   private static final String TAG = "AdtsReader";
 
   private static final int STATE_FINDING_SAMPLE = 0;
-  private static final int STATE_READING_ID3_HEADER = 1;
-  private static final int STATE_READING_ADTS_HEADER = 2;
-  private static final int STATE_READING_SAMPLE = 3;
+  private static final int STATE_CHECKING_ADTS_HEADER = 1;
+  private static final int STATE_READING_ID3_HEADER = 2;
+  private static final int STATE_READING_ADTS_HEADER = 3;
+  private static final int STATE_READING_SAMPLE = 4;
 
   private static final int HEADER_SIZE = 5;
   private static final int CRC_SIZE = 2;
@@ -56,6 +57,7 @@
   private static final int ID3_HEADER_SIZE = 10;
   private static final int ID3_SIZE_OFFSET = 6;
   private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
+  private static final int VERSION_UNSET = -1;
 
   private final boolean exposeId3;
   private final ParsableBitArray adtsScratch;
@@ -72,6 +74,13 @@
   private int matchState;
 
   private boolean hasCrc;
+  private boolean foundFirstFrame;
+
+  // Used to verifies sync words
+  private int firstFrameVersion;
+  private int firstFrameSampleRateIndex;
+
+  private int currentFrameVersion;
 
   // Used when parsing the header.
   private boolean hasOutputFormat;
@@ -99,13 +108,21 @@ public AdtsReader(boolean exposeId3, String language) {
     adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
     id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
     setFindingSampleState();
+    firstFrameVersion = VERSION_UNSET;
+    firstFrameSampleRateIndex = C.INDEX_UNSET;
+    sampleDurationUs = C.TIME_UNSET;
     this.exposeId3 = exposeId3;
     this.language = language;
   }
 
+  /** Returns whether an integer matches an ADTS SYNC word. */
+  public static boolean isAdtsSyncWord(int candidateSyncWord) {
+    return (candidateSyncWord & 0xFFF6) == 0xFFF0;
+  }
+
   @Override
   public void seek() {
-    setFindingSampleState();
+    resetSync();
   }
 
   @Override
@@ -124,7 +141,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
@@ -140,6 +157,9 @@ public void consume(ParsableByteArray data) throws ParserException {
             parseId3Header();
           }
           break;
+        case STATE_CHECKING_ADTS_HEADER:
+          checkAdtsHeader(data);
+          break;
         case STATE_READING_ADTS_HEADER:
           int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
           if (continueRead(data, adtsScratch.data, targetLength)) {
@@ -149,6 +169,8 @@ public void consume(ParsableByteArray data) throws ParserException {
         case STATE_READING_SAMPLE:
           readSample(data);
           break;
+        default:
+          throw new IllegalStateException();
       }
     }
   }
@@ -158,6 +180,19 @@ public void packetFinished() {
     // Do nothing.
   }
 
+  /**
+   * Returns the duration in microseconds per sample, or {@link C#TIME_UNSET} if the sample duration
+   * is not available.
+   */
+  public long getSampleDurationUs() {
+    return sampleDurationUs;
+  }
+
+  private void resetSync() {
+    foundFirstFrame = false;
+    setFindingSampleState();
+  }
+
   /**
    * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
    * that the data should be written into {@code target} starting from an offset of zero.
@@ -219,6 +254,12 @@ private void setReadingAdtsHeaderState() {
     bytesRead = 0;
   }
 
+  /** Sets the state to STATE_CHECKING_ADTS_HEADER. */
+  private void setCheckingAdtsHeaderState() {
+    state = STATE_CHECKING_ADTS_HEADER;
+    bytesRead = 0;
+  }
+
   /**
    * Locates the next sample start, advancing the position to the byte that immediately follows
    * identifier. If a sample was not located, the position is advanced to the limit.
@@ -231,12 +272,21 @@ private void findNextSample(ParsableByteArray pesBuffer) {
     int endOffset = pesBuffer.limit();
     while (position < endOffset) {
       int data = adtsData[position++] & 0xFF;
-      if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
-        hasCrc = (data & 0x1) == 0;
-        setReadingAdtsHeaderState();
-        pesBuffer.setPosition(position);
-        return;
+      if (matchState == MATCH_STATE_FF && isAdtsSyncBytes((byte) 0xFF, (byte) data)) {
+        if (foundFirstFrame
+            || checkSyncPositionValid(pesBuffer, /* syncPositionCandidate= */ position - 2)) {
+          currentFrameVersion = (data & 0x8) >> 3;
+          hasCrc = (data & 0x1) == 0;
+          if (!foundFirstFrame) {
+            setCheckingAdtsHeaderState();
+          } else {
+            setReadingAdtsHeaderState();
+          }
+          pesBuffer.setPosition(position);
+          return;
+        }
       }
+
       switch (matchState | data) {
         case MATCH_STATE_START | 0xFF:
           matchState = MATCH_STATE_FF;
@@ -264,6 +314,117 @@ private void findNextSample(ParsableByteArray pesBuffer) {
     pesBuffer.setPosition(position);
   }
 
+  /**
+   * Peeks the Adts header of the current frame and checks if it is valid. If the header is valid,
+   * transition to {@link #STATE_READING_ADTS_HEADER}; else, transition to {@link
+   * #STATE_FINDING_SAMPLE}.
+   */
+  private void checkAdtsHeader(ParsableByteArray buffer) {
+    if (buffer.bytesLeft() == 0) {
+      // Not enough data to check yet, defer this check.
+      return;
+    }
+    // Peek the next byte of buffer into scratch array.
+    adtsScratch.data[0] = buffer.data[buffer.getPosition()];
+
+    adtsScratch.setPosition(2);
+    int currentFrameSampleRateIndex = adtsScratch.readBits(4);
+    if (firstFrameSampleRateIndex != C.INDEX_UNSET
+        && currentFrameSampleRateIndex != firstFrameSampleRateIndex) {
+      // Invalid header.
+      resetSync();
+      return;
+    }
+
+    if (!foundFirstFrame) {
+      foundFirstFrame = true;
+      firstFrameVersion = currentFrameVersion;
+      firstFrameSampleRateIndex = currentFrameSampleRateIndex;
+    }
+    setReadingAdtsHeaderState();
+  }
+
+  /**
+   * Returns whether the given syncPositionCandidate is a real SYNC word.
+   *
+   * <p>SYNC word pattern can occur within AAC data, so we perform a few checks to make sure this is
+   * really a SYNC word. This includes:
+   *
+   * <ul>
+   *   <li>Checking if MPEG version of this frame matches the first detected version.
+   *   <li>Checking if the sample rate index of this frame matches the first detected sample rate
+   *       index.
+   *   <li>Checking if the bytes immediately after the current package also match a SYNC-word.
+   * </ul>
+   *
+   * If the buffer runs out of data for any check, optimistically skip that check, because
+   * AdtsReader consumes each buffer as a whole. We will still run a header validity check later.
+   */
+  private boolean checkSyncPositionValid(ParsableByteArray pesBuffer, int syncPositionCandidate) {
+    // The SYNC word contains 2 bytes, and the first byte may be in the previously consumed buffer.
+    // Hence the second byte of the SYNC word may be byte 0 of this buffer, and
+    // syncPositionCandidate (which indicates position of the first byte of the SYNC word) may be
+    // -1.
+    // Since the first byte of the SYNC word is always FF, which does not contain any informational
+    // bits, we set the byte position to be the second byte in the SYNC word to ensure it's always
+    // within this buffer.
+    pesBuffer.setPosition(syncPositionCandidate + 1);
+    if (!tryRead(pesBuffer, adtsScratch.data, 1)) {
+      return false;
+    }
+
+    adtsScratch.setPosition(4);
+    int currentFrameVersion = adtsScratch.readBits(1);
+    if (firstFrameVersion != VERSION_UNSET && currentFrameVersion != firstFrameVersion) {
+      return false;
+    }
+
+    if (firstFrameSampleRateIndex != C.INDEX_UNSET) {
+      if (!tryRead(pesBuffer, adtsScratch.data, 1)) {
+        return true;
+      }
+      adtsScratch.setPosition(2);
+      int currentFrameSampleRateIndex = adtsScratch.readBits(4);
+      if (currentFrameSampleRateIndex != firstFrameSampleRateIndex) {
+        return false;
+      }
+      pesBuffer.setPosition(syncPositionCandidate + 2);
+    }
+
+    // Optionally check the byte after this frame matches SYNC word.
+
+    if (!tryRead(pesBuffer, adtsScratch.data, 4)) {
+      return true;
+    }
+    adtsScratch.setPosition(14);
+    int frameSize = adtsScratch.readBits(13);
+    if (frameSize <= 6) {
+      // Not a frame.
+      return false;
+    }
+    int nextSyncPosition = syncPositionCandidate + frameSize;
+    if (nextSyncPosition + 1 >= pesBuffer.limit()) {
+      return true;
+    }
+    return (isAdtsSyncBytes(pesBuffer.data[nextSyncPosition], pesBuffer.data[nextSyncPosition + 1])
+        && (firstFrameVersion == VERSION_UNSET
+            || ((pesBuffer.data[nextSyncPosition + 1] & 0x8) >> 3) == currentFrameVersion));
+  }
+
+  private boolean isAdtsSyncBytes(byte firstByte, byte secondByte) {
+    int syncWord = (firstByte & 0xFF) << 8 | (secondByte & 0xFF);
+    return isAdtsSyncWord(syncWord);
+  }
+
+  /** Reads {@code targetLength} bytes into target, and returns whether the read succeeded. */
+  private boolean tryRead(ParsableByteArray source, byte[] target, int targetLength) {
+    if (source.bytesLeft() < targetLength) {
+      return false;
+    }
+    source.readBytes(target, /* offset= */ 0, targetLength);
+    return true;
+  }
+
   /**
    * Parses the Id3 header.
    */
@@ -296,12 +457,12 @@ private void parseAdtsHeader() throws ParserException {
         audioObjectType = 2;
       }
 
-      int sampleRateIndex = adtsScratch.readBits(4);
-      adtsScratch.skipBits(1);
+      adtsScratch.skipBits(5);
       int channelConfig = adtsScratch.readBits(3);
 
-      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
-          audioObjectType, sampleRateIndex, channelConfig);
+      byte[] audioSpecificConfig =
+          CodecSpecificDataUtil.buildAacAudioSpecificConfig(
+              audioObjectType, firstFrameSampleRateIndex, channelConfig);
       Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
           audioSpecificConfig);
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 2d16b46895..a5506e2cfb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -19,8 +19,10 @@
 import android.util.SparseArray;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
+import com.google.android.exoplayer2.text.cea.Cea708InitializationData;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -33,18 +35,56 @@
 public final class DefaultTsPayloadReaderFactory implements TsPayloadReader.Factory {
 
   /**
-   * Flags controlling elementary stream readers' behavior.
+   * Flags controlling elementary stream readers' behavior. Possible flag values are {@link
+   * #FLAG_ALLOW_NON_IDR_KEYFRAMES}, {@link #FLAG_IGNORE_AAC_STREAM}, {@link
+   * #FLAG_IGNORE_H264_STREAM}, {@link #FLAG_DETECT_ACCESS_UNITS}, {@link
+   * #FLAG_IGNORE_SPLICE_INFO_STREAM} and {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_ALLOW_NON_IDR_KEYFRAMES, FLAG_IGNORE_AAC_STREAM,
-      FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS, FLAG_IGNORE_SPLICE_INFO_STREAM,
-      FLAG_OVERRIDE_CAPTION_DESCRIPTORS})
+  @IntDef(
+      flag = true,
+      value = {
+        FLAG_ALLOW_NON_IDR_KEYFRAMES,
+        FLAG_IGNORE_AAC_STREAM,
+        FLAG_IGNORE_H264_STREAM,
+        FLAG_DETECT_ACCESS_UNITS,
+        FLAG_IGNORE_SPLICE_INFO_STREAM,
+        FLAG_OVERRIDE_CAPTION_DESCRIPTORS
+      })
   public @interface Flags {}
+
+  /**
+   * When extracting H.264 samples, whether to treat samples consisting of non-IDR I slices as
+   * synchronization samples (key-frames).
+   */
   public static final int FLAG_ALLOW_NON_IDR_KEYFRAMES = 1;
+  /**
+   * Prevents the creation of {@link AdtsReader} and {@link LatmReader} instances. This flag should
+   * be enabled if the transport stream contains no packets for an AAC elementary stream that is
+   * declared in the PMT.
+   */
   public static final int FLAG_IGNORE_AAC_STREAM = 1 << 1;
+  /**
+   * Prevents the creation of {@link H264Reader} instances. This flag should be enabled if the
+   * transport stream contains no packets for an H.264 elementary stream that is declared in the
+   * PMT.
+   */
   public static final int FLAG_IGNORE_H264_STREAM = 1 << 2;
+  /**
+   * When extracting H.264 samples, whether to split the input stream into access units (samples)
+   * based on slice headers. This flag should be disabled if the stream contains access unit
+   * delimiters (AUDs).
+   */
   public static final int FLAG_DETECT_ACCESS_UNITS = 1 << 3;
+  /** Prevents the creation of {@link SpliceInfoSectionReader} instances. */
   public static final int FLAG_IGNORE_SPLICE_INFO_STREAM = 1 << 4;
+  /**
+   * Whether the list of {@code closedCaptionFormats} passed to {@link
+   * DefaultTsPayloadReaderFactory#DefaultTsPayloadReaderFactory(int, List)} should be used in spite
+   * of any closed captions service descriptors. If this flag is disabled, {@code
+   * closedCaptionFormats} will be ignored if the PMT contains closed captions service descriptors.
+   */
   public static final int FLAG_OVERRIDE_CAPTION_DESCRIPTORS = 1 << 5;
 
   private static final int DESCRIPTOR_TAG_CAPTION_SERVICE = 0x86;
@@ -61,7 +101,10 @@ public DefaultTsPayloadReaderFactory() {
    *     readers.
    */
   public DefaultTsPayloadReaderFactory(@Flags int flags) {
-    this(flags, Collections.<Format>emptyList());
+    this(
+        flags,
+        Collections.singletonList(
+            Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0, null)));
   }
 
   /**
@@ -76,10 +119,6 @@ public DefaultTsPayloadReaderFactory(@Flags int flags) {
    */
   public DefaultTsPayloadReaderFactory(@Flags int flags, List<Format> closedCaptionFormats) {
     this.flags = flags;
-    if (!isSet(FLAG_OVERRIDE_CAPTION_DESCRIPTORS) && closedCaptionFormats.isEmpty()) {
-      closedCaptionFormats = Collections.singletonList(Format.createTextSampleFormat(null,
-          MimeTypes.APPLICATION_CEA608, 0, null));
-    }
     this.closedCaptionFormats = closedCaptionFormats;
   }
 
@@ -107,7 +146,7 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
       case TsExtractor.TS_STREAM_TYPE_HDMV_DTS:
         return new PesReader(new DtsReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_H262:
-        return new PesReader(new H262Reader());
+        return new PesReader(new H262Reader(buildUserDataReader(esInfo)));
       case TsExtractor.TS_STREAM_TYPE_H264:
         return isSet(FLAG_IGNORE_H264_STREAM) ? null
             : new PesReader(new H264Reader(buildSeiReader(esInfo),
@@ -137,8 +176,34 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
    * @return A {@link SeiReader} for closed caption tracks.
    */
   private SeiReader buildSeiReader(EsInfo esInfo) {
+    return new SeiReader(getClosedCaptionFormats(esInfo));
+  }
+
+  /**
+   * If {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} is set, returns a {@link UserDataReader} for
+   * {@link #closedCaptionFormats}. If unset, parses the PMT descriptor information and returns a
+   * {@link UserDataReader} for the declared formats, or {@link #closedCaptionFormats} if the
+   * descriptor is not present.
+   *
+   * @param esInfo The {@link EsInfo} passed to {@link #createPayloadReader(int, EsInfo)}.
+   * @return A {@link UserDataReader} for closed caption tracks.
+   */
+  private UserDataReader buildUserDataReader(EsInfo esInfo) {
+    return new UserDataReader(getClosedCaptionFormats(esInfo));
+  }
+
+  /**
+   * If {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} is set, returns a {@link List<Format>} of {@link
+   * #closedCaptionFormats}. If unset, parses the PMT descriptor information and returns a {@link
+   * List<Format>} for the declared formats, or {@link #closedCaptionFormats} if the descriptor is
+   * not present.
+   *
+   * @param esInfo The {@link EsInfo} passed to {@link #createPayloadReader(int, EsInfo)}.
+   * @return A {@link List<Format>} containing list of closed caption formats.
+   */
+  private List<Format> getClosedCaptionFormats(EsInfo esInfo) {
     if (isSet(FLAG_OVERRIDE_CAPTION_DESCRIPTORS)) {
-      return new SeiReader(closedCaptionFormats);
+      return closedCaptionFormats;
     }
     ParsableByteArray scratchDescriptorData = new ParsableByteArray(esInfo.descriptorBytes);
     List<Format> closedCaptionFormats = this.closedCaptionFormats;
@@ -163,21 +228,42 @@ private SeiReader buildSeiReader(EsInfo esInfo) {
             mimeType = MimeTypes.APPLICATION_CEA608;
             accessibilityChannel = 1;
           }
-          closedCaptionFormats.add(Format.createTextSampleFormat(null, mimeType, null,
-              Format.NO_VALUE, 0, language, accessibilityChannel, null));
-          // Skip easy_reader(1), wide_aspect_ratio(1), reserved(14).
-          scratchDescriptorData.skipBytes(2);
+
+          // easy_reader(1), wide_aspect_ratio(1), reserved(6).
+          byte flags = (byte) scratchDescriptorData.readUnsignedByte();
+          // Skip reserved (8).
+          scratchDescriptorData.skipBytes(1);
+
+          List<byte[]> initializationData = null;
+          // The wide_aspect_ratio flag only has meaning for CEA-708.
+          if (isDigital) {
+            boolean isWideAspectRatio = (flags & 0x40) != 0;
+            initializationData = Cea708InitializationData.buildData(isWideAspectRatio);
+          }
+
+          closedCaptionFormats.add(
+              Format.createTextSampleFormat(
+                  /* id= */ null,
+                  mimeType,
+                  /* codecs= */ null,
+                  /* bitrate= */ Format.NO_VALUE,
+                  /* selectionFlags= */ 0,
+                  language,
+                  accessibilityChannel,
+                  /* drmInitData= */ null,
+                  Format.OFFSET_SAMPLE_RELATIVE,
+                  initializationData));
         }
       } else {
         // Unknown descriptor. Ignore.
       }
       scratchDescriptorData.setPosition(nextDescriptorPosition);
     }
-    return new SeiReader(closedCaptionFormats);
+
+    return closedCaptionFormats;
   }
 
   private boolean isSet(@Flags int flag) {
     return (flags & flag) != 0;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index 0fc3383015..1f9b0e79d4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -80,7 +80,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
@@ -111,6 +111,8 @@ public void consume(ParsableByteArray data) {
             state = STATE_FINDING_SYNC;
           }
           break;
+        default:
+          throw new IllegalStateException();
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
index 0944d1810e..3f0a772b1c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -73,8 +75,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    if (!dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    if ((flags & FLAG_DATA_ALIGNMENT_INDICATOR) == 0) {
       return;
     }
     writingSample = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
index fa7f78c8c0..e022fc237b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
@@ -43,9 +43,9 @@
    * Called when a packet starts.
    *
    * @param pesTimeUs The timestamp associated with the packet.
-   * @param dataAlignmentIndicator The data alignment indicator associated with the packet.
+   * @param flags See {@link TsPayloadReader.Flags}.
    */
-  void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator);
+  void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags);
 
   /**
    * Consumes (possibly partial) data from the current packet.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
index a3502a3242..1564157d44 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
@@ -36,6 +36,7 @@
   private static final int START_SEQUENCE_HEADER = 0xB3;
   private static final int START_EXTENSION = 0xB5;
   private static final int START_GROUP = 0xB8;
+  private static final int START_USER_DATA = 0xB2;
 
   private String formatId;
   private TrackOutput output;
@@ -48,9 +49,13 @@
   private boolean hasOutputFormat;
   private long frameDurationUs;
 
+  private final UserDataReader userDataReader;
+  private final ParsableByteArray userDataParsable;
+
   // State that should be reset on seek.
   private final boolean[] prefixFlags;
   private final CsdBuffer csdBuffer;
+  private final NalUnitTargetBuffer userData;
   private long totalBytesWritten;
   private boolean startedFirstSample;
 
@@ -64,14 +69,29 @@
   private boolean sampleHasPicture;
 
   public H262Reader() {
+    this(null);
+  }
+
+  public H262Reader(UserDataReader userDataReader) {
+    this.userDataReader = userDataReader;
     prefixFlags = new boolean[4];
     csdBuffer = new CsdBuffer(128);
+    if (userDataReader != null) {
+      userData = new NalUnitTargetBuffer(START_USER_DATA, 128);
+      userDataParsable = new ParsableByteArray();
+    } else {
+      userData = null;
+      userDataParsable = null;
+    }
   }
 
   @Override
   public void seek() {
     NalUnitUtil.clearPrefixFlags(prefixFlags);
     csdBuffer.reset();
+    if (userDataReader != null) {
+      userData.reset();
+    }
     totalBytesWritten = 0;
     startedFirstSample = false;
   }
@@ -81,10 +101,14 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
     idGenerator.generateNewId();
     formatId = idGenerator.getFormatId();
     output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
+    if (userDataReader != null) {
+      userDataReader.createTracks(extractorOutput, idGenerator);
+    }
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    // TODO (Internal b/32267012): Consider using random access indicator.
     this.pesTimeUs = pesTimeUs;
   }
 
@@ -106,16 +130,19 @@ public void consume(ParsableByteArray data) {
         if (!hasOutputFormat) {
           csdBuffer.onData(dataArray, offset, limit);
         }
+        if (userDataReader != null) {
+          userData.appendToNalUnit(dataArray, offset, limit);
+        }
         return;
       }
 
       // We've found a start code with the following value.
       int startCodeValue = data.data[startCodeOffset + 3] & 0xFF;
+      // This is the number of bytes from the current offset to the start of the next start
+      // code. It may be negative if the start code started in the previously consumed data.
+      int lengthToStartCode = startCodeOffset - offset;
 
       if (!hasOutputFormat) {
-        // This is the number of bytes from the current offset to the start of the next start
-        // code. It may be negative if the start code started in the previously consumed data.
-        int lengthToStartCode = startCodeOffset - offset;
         if (lengthToStartCode > 0) {
           csdBuffer.onData(dataArray, offset, startCodeOffset);
         }
@@ -130,7 +157,24 @@ public void consume(ParsableByteArray data) {
           hasOutputFormat = true;
         }
       }
+      if (userDataReader != null) {
+        int bytesAlreadyPassed = 0;
+        if (lengthToStartCode > 0) {
+          userData.appendToNalUnit(dataArray, offset, startCodeOffset);
+        } else {
+          bytesAlreadyPassed = -lengthToStartCode;
+        }
 
+        if (userData.endNalUnit(bytesAlreadyPassed)) {
+          int unescapedLength = NalUnitUtil.unescapeStream(userData.nalData, userData.nalLength);
+          userDataParsable.reset(userData.nalData, unescapedLength);
+          userDataReader.consume(sampleTimeUs, userDataParsable);
+        }
+
+        if (startCodeValue == START_USER_DATA && data.data[startCodeOffset + 2] == 0x1) {
+          userData.startNalUnit(startCodeValue);
+        }
+      }
       if (startCodeValue == START_PICTURE || startCodeValue == START_SEQUENCE_HEADER) {
         int bytesWrittenPastStartCode = limit - startCodeOffset;
         if (startedFirstSample && sampleHasPicture && hasOutputFormat) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index 3cde946ce3..d249c1b9da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -15,12 +15,15 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_RANDOM_ACCESS_INDICATOR;
+
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.NalUnitUtil.SpsData;
@@ -55,9 +58,12 @@
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
 
-  // Per packet state that gets reset at the start of each packet.
+  // Per PES packet state that gets reset at the start of each PES packet.
   private long pesTimeUs;
 
+  // State inherited from the TS packet header.
+  private boolean randomAccessIndicator;
+
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
@@ -87,6 +93,7 @@ public void seek() {
     sei.reset();
     sampleReader.reset();
     totalBytesWritten = 0;
+    randomAccessIndicator = false;
   }
 
   @Override
@@ -99,8 +106,9 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     this.pesTimeUs = pesTimeUs;
+    randomAccessIndicator |= (flags & FLAG_RANDOM_ACCESS_INDICATOR) != 0;
   }
 
   @Override
@@ -180,9 +188,23 @@ private void endNalUnit(long position, int offset, int discardPadding, long pesT
           initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
           NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
           NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
-          output.format(Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H264, null,
-              Format.NO_VALUE, Format.NO_VALUE, spsData.width, spsData.height, Format.NO_VALUE,
-              initializationData, Format.NO_VALUE, spsData.pixelWidthAspectRatio, null));
+          output.format(
+              Format.createVideoSampleFormat(
+                  formatId,
+                  MimeTypes.VIDEO_H264,
+                  CodecSpecificDataUtil.buildAvcCodecString(
+                      spsData.profileIdc,
+                      spsData.constraintsFlagsAndReservedZero2Bits,
+                      spsData.levelIdc),
+                  /* bitrate= */ Format.NO_VALUE,
+                  /* maxInputSize= */ Format.NO_VALUE,
+                  spsData.width,
+                  spsData.height,
+                  /* frameRate= */ Format.NO_VALUE,
+                  initializationData,
+                  /* rotationDegrees= */ Format.NO_VALUE,
+                  spsData.pixelWidthAspectRatio,
+                  /* drmInitData= */ null));
           hasOutputFormat = true;
           sampleReader.putSps(spsData);
           sampleReader.putPps(ppsData);
@@ -205,12 +227,17 @@ private void endNalUnit(long position, int offset, int discardPadding, long pesT
       seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
       seiReader.consume(pesTimeUs, seiWrapper);
     }
-    sampleReader.endNalUnit(position, offset);
+    boolean sampleIsKeyFrame =
+        sampleReader.endNalUnit(position, offset, hasOutputFormat, randomAccessIndicator);
+    if (sampleIsKeyFrame) {
+      // This is either an IDR frame or the first I-frame since the random access indicator, so mark
+      // it as a keyframe. Clear the flag so that subsequent non-IDR I-frames are not marked as
+      // keyframes until we see another random access indicator.
+      randomAccessIndicator = false;
+    }
   }
 
-  /**
-   * Consumes a stream of NAL units and outputs samples.
-   */
+  /** Consumes a stream of NAL units and outputs samples. */
   private static final class SampleReader {
 
     private static final int DEFAULT_BUFFER_SIZE = 128;
@@ -415,11 +442,12 @@ public void appendToNalUnit(byte[] data, int offset, int limit) {
       isFilling = false;
     }
 
-    public void endNalUnit(long position, int offset) {
+    public boolean endNalUnit(
+        long position, int offset, boolean hasOutputFormat, boolean randomAccessIndicator) {
       if (nalUnitType == NAL_UNIT_TYPE_AUD
           || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
         // If the NAL unit ending is the start of a new sample, output the previous one.
-        if (readingSample) {
+        if (hasOutputFormat && readingSample) {
           int nalUnitLength = (int) (position - nalUnitStartPosition);
           outputSample(offset + nalUnitLength);
         }
@@ -428,8 +456,12 @@ public void endNalUnit(long position, int offset) {
         sampleIsKeyframe = false;
         readingSample = true;
       }
-      sampleIsKeyframe |= nalUnitType == NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
-          && nalUnitType == NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
+      boolean treatIFrameAsKeyframe =
+          allowNonIdrKeyframes ? sliceHeader.isISlice() : randomAccessIndicator;
+      sampleIsKeyframe |=
+          nalUnitType == NAL_UNIT_TYPE_IDR
+              || (treatIFrameAsKeyframe && nalUnitType == NAL_UNIT_TYPE_NON_IDR);
+      return sampleIsKeyframe;
     }
 
     private void outputSample(int offset) {
@@ -471,10 +503,21 @@ public void setSliceType(int sliceType) {
         hasSliceType = true;
       }
 
-      public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
-          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
-          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
-          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+      public void setAll(
+          SpsData spsData,
+          int nalRefIdc,
+          int sliceType,
+          int frameNum,
+          int picParameterSetId,
+          boolean fieldPicFlag,
+          boolean bottomFieldFlagPresent,
+          boolean bottomFieldFlag,
+          boolean idrPicFlag,
+          int idrPicId,
+          int picOrderCntLsb,
+          int deltaPicOrderCntBottom,
+          int deltaPicOrderCnt0,
+          int deltaPicOrderCnt1) {
         this.spsData = spsData;
         this.nalRefIdc = nalRefIdc;
         this.sliceType = sliceType;
@@ -499,23 +542,26 @@ public boolean isISlice() {
 
       private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
         // See ISO 14496-10 subsection 7.4.1.2.4.
-        return isComplete && (!other.isComplete || frameNum != other.frameNum
-            || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
-            || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
-                && bottomFieldFlag != other.bottomFieldFlag)
-            || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
-            || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
-                && (picOrderCntLsb != other.picOrderCntLsb
-                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
-            || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
-                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
-                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
-            || idrPicFlag != other.idrPicFlag
-            || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
+        return isComplete
+            && (!other.isComplete
+                || frameNum != other.frameNum
+                || picParameterSetId != other.picParameterSetId
+                || fieldPicFlag != other.fieldPicFlag
+                || (bottomFieldFlagPresent
+                    && other.bottomFieldFlagPresent
+                    && bottomFieldFlag != other.bottomFieldFlag)
+                || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
+                || (spsData.picOrderCountType == 0
+                    && other.spsData.picOrderCountType == 0
+                    && (picOrderCntLsb != other.picOrderCntLsb
+                        || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+                || (spsData.picOrderCountType == 1
+                    && other.spsData.picOrderCountType == 1
+                    && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+                        || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+                || idrPicFlag != other.idrPicFlag
+                || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
       }
-
     }
-
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
index f6ae80ba56..88bde53746 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
@@ -15,12 +15,12 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -104,7 +104,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    // TODO (Internal b/32267012): Consider using random access indicator.
     this.pesTimeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
index 98e1309143..f936fb9e43 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.util.Log;
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
@@ -63,8 +65,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    if (!dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    if ((flags & FLAG_DATA_ALIGNMENT_INDICATOR) == 0) {
       return;
     }
     writingSample = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
index 313e556764..2a633c191d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
@@ -93,7 +93,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
@@ -134,6 +134,8 @@ public void consume(ParsableByteArray data) throws ParserException {
             state = STATE_FINDING_SYNC_1;
           }
           break;
+        default:
+          throw new IllegalStateException();
       }
     }
   }
@@ -250,6 +252,8 @@ private void parseFrameLength(ParsableBitArray data) {
       case 7:
         data.skipBits(1); // HVXCframeLengthTableIndex.
         break;
+      default:
+        throw new IllegalStateException();
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
index 82fb84b291..393e297818 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
@@ -83,7 +83,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
@@ -100,6 +100,8 @@ public void consume(ParsableByteArray data) {
         case STATE_READING_FRAME:
           readFrameRemainder(data);
           break;
+        default:
+          throw new IllegalStateException();
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
index 4863df42eb..ff755f4ece 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -15,10 +15,10 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
@@ -78,9 +78,8 @@ public final void seek() {
   }
 
   @Override
-  public final void consume(ParsableByteArray data, boolean payloadUnitStartIndicator)
-      throws ParserException {
-    if (payloadUnitStartIndicator) {
+  public final void consume(ParsableByteArray data, @Flags int flags) throws ParserException {
+    if ((flags & FLAG_PAYLOAD_UNIT_START_INDICATOR) != 0) {
       switch (state) {
         case STATE_FINDING_HEADER:
         case STATE_READING_HEADER:
@@ -100,6 +99,8 @@ public final void consume(ParsableByteArray data, boolean payloadUnitStartIndica
           // Either way, notify the reader that it has now finished.
           reader.packetFinished();
           break;
+        default:
+          throw new IllegalStateException();
       }
       setState(STATE_READING_HEADER);
     }
@@ -120,7 +121,8 @@ public final void consume(ParsableByteArray data, boolean payloadUnitStartIndica
           if (continueRead(data, pesScratch.data, readLength)
               && continueRead(data, null, extendedHeaderLength)) {
             parseHeaderExtension();
-            reader.packetStarted(timeUs, dataAlignmentIndicator);
+            flags |= dataAlignmentIndicator ? FLAG_DATA_ALIGNMENT_INDICATOR : 0;
+            reader.packetStarted(timeUs, flags);
             setState(STATE_READING_BODY);
           }
           break;
@@ -140,6 +142,8 @@ public final void consume(ParsableByteArray data, boolean payloadUnitStartIndica
             }
           }
           break;
+        default:
+          throw new IllegalStateException();
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java
new file mode 100644
index 0000000000..4efd38b7eb
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/**
+ * A seeker that supports seeking within PS stream using binary search.
+ *
+ * <p>This seeker uses the first and last SCR values within the stream, as well as the stream
+ * duration to interpolate the SCR value of the seeking position. Then it performs binary search
+ * within the stream to find a packets whose SCR value is with in {@link #SEEK_TOLERANCE_US} from
+ * the target SCR.
+ */
+/* package */ final class PsBinarySearchSeeker extends BinarySearchSeeker {
+
+  private static final long SEEK_TOLERANCE_US = 100_000;
+  private static final int MINIMUM_SEARCH_RANGE_BYTES = 1000;
+  private static final int TIMESTAMP_SEARCH_BYTES = 20000;
+
+  public PsBinarySearchSeeker(
+      TimestampAdjuster scrTimestampAdjuster, long streamDurationUs, long inputLength) {
+    super(
+        new DefaultSeekTimestampConverter(),
+        new PsScrSeeker(scrTimestampAdjuster),
+        streamDurationUs,
+        /* floorTimePosition= */ 0,
+        /* ceilingTimePosition= */ streamDurationUs + 1,
+        /* floorBytePosition= */ 0,
+        /* ceilingBytePosition= */ inputLength,
+        /* approxBytesPerFrame= */ TsExtractor.TS_PACKET_SIZE,
+        MINIMUM_SEARCH_RANGE_BYTES);
+  }
+
+  /**
+   * A seeker that looks for a given SCR timestamp at a given position in a PS stream.
+   *
+   * <p>Given a SCR timestamp, and a position within a PS stream, this seeker will peek up to {@link
+   * #TIMESTAMP_SEARCH_BYTES} bytes from that stream position, look for all packs in that range, and
+   * then compare the SCR timestamps (if available) of these packets to the target timestamp.
+   */
+  private static final class PsScrSeeker implements TimestampSeeker {
+
+    private final TimestampAdjuster scrTimestampAdjuster;
+    private final ParsableByteArray packetBuffer;
+
+    private PsScrSeeker(TimestampAdjuster scrTimestampAdjuster) {
+      this.scrTimestampAdjuster = scrTimestampAdjuster;
+      packetBuffer = new ParsableByteArray();
+    }
+
+    @Override
+    public TimestampSearchResult searchForTimestamp(
+        ExtractorInput input, long targetTimestamp, OutputFrameHolder outputFrameHolder)
+        throws IOException, InterruptedException {
+      long inputPosition = input.getPosition();
+      int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength() - inputPosition);
+
+      packetBuffer.reset(bytesToSearch);
+      input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
+
+      return searchForScrValueInBuffer(packetBuffer, targetTimestamp, inputPosition);
+    }
+
+    @Override
+    public void onSeekFinished() {
+      packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
+    }
+
+    private TimestampSearchResult searchForScrValueInBuffer(
+        ParsableByteArray packetBuffer, long targetScrTimeUs, long bufferStartOffset) {
+      int startOfLastPacketPosition = C.POSITION_UNSET;
+      int endOfLastPacketPosition = C.POSITION_UNSET;
+      long lastScrTimeUsInRange = C.TIME_UNSET;
+
+      while (packetBuffer.bytesLeft() >= 4) {
+        int nextStartCode = peekIntAtPosition(packetBuffer.data, packetBuffer.getPosition());
+        if (nextStartCode != PsExtractor.PACK_START_CODE) {
+          packetBuffer.skipBytes(1);
+          continue;
+        } else {
+          packetBuffer.skipBytes(4);
+        }
+
+        // We found a pack.
+        long scrValue = PsDurationReader.readScrValueFromPack(packetBuffer);
+        if (scrValue != C.TIME_UNSET) {
+          long scrTimeUs = scrTimestampAdjuster.adjustTsTimestamp(scrValue);
+          if (scrTimeUs > targetScrTimeUs) {
+            if (lastScrTimeUsInRange == C.TIME_UNSET) {
+              // First SCR timestamp is already over target.
+              return TimestampSearchResult.overestimatedResult(scrTimeUs, bufferStartOffset);
+            } else {
+              // Last SCR timestamp < target timestamp < this timestamp.
+              return TimestampSearchResult.targetFoundResult(
+                  bufferStartOffset + startOfLastPacketPosition);
+            }
+          } else if (scrTimeUs + SEEK_TOLERANCE_US > targetScrTimeUs) {
+            long startOfPacketInStream = bufferStartOffset + packetBuffer.getPosition();
+            return TimestampSearchResult.targetFoundResult(startOfPacketInStream);
+          }
+
+          lastScrTimeUsInRange = scrTimeUs;
+          startOfLastPacketPosition = packetBuffer.getPosition();
+        }
+        skipToEndOfCurrentPack(packetBuffer);
+        endOfLastPacketPosition = packetBuffer.getPosition();
+      }
+
+      if (lastScrTimeUsInRange != C.TIME_UNSET) {
+        long endOfLastPacketPositionInStream = bufferStartOffset + endOfLastPacketPosition;
+        return TimestampSearchResult.underestimatedResult(
+            lastScrTimeUsInRange, endOfLastPacketPositionInStream);
+      } else {
+        return TimestampSearchResult.NO_TIMESTAMP_IN_RANGE_RESULT;
+      }
+    }
+
+    /**
+     * Skips the buffer position to the position after the end of the current PS pack in the buffer,
+     * given the byte position right after the {@link PsExtractor#PACK_START_CODE} of the pack in
+     * the buffer. If the pack ends after the end of the buffer, skips to the end of the buffer.
+     */
+    private static void skipToEndOfCurrentPack(ParsableByteArray packetBuffer) {
+      int limit = packetBuffer.limit();
+
+      if (packetBuffer.bytesLeft() < 10) {
+        // We require at least 9 bytes for pack header to read SCR value + 1 byte for pack_stuffing
+        // length.
+        packetBuffer.setPosition(limit);
+        return;
+      }
+      packetBuffer.skipBytes(9);
+
+      int packStuffingLength = packetBuffer.readUnsignedByte() & 0x07;
+      if (packetBuffer.bytesLeft() < packStuffingLength) {
+        packetBuffer.setPosition(limit);
+        return;
+      }
+      packetBuffer.skipBytes(packStuffingLength);
+
+      if (packetBuffer.bytesLeft() < 4) {
+        packetBuffer.setPosition(limit);
+        return;
+      }
+
+      int nextStartCode = peekIntAtPosition(packetBuffer.data, packetBuffer.getPosition());
+      if (nextStartCode == PsExtractor.SYSTEM_HEADER_START_CODE) {
+        packetBuffer.skipBytes(4);
+        int systemHeaderLength = packetBuffer.readUnsignedShort();
+        if (packetBuffer.bytesLeft() < systemHeaderLength) {
+          packetBuffer.setPosition(limit);
+          return;
+        }
+        packetBuffer.skipBytes(systemHeaderLength);
+      }
+
+      // Find the position of the next PACK_START_CODE or MPEG_PROGRAM_END_CODE, which is right
+      // after the end position of this pack.
+      // If we couldn't find these codes within the buffer, return the buffer limit, or return
+      // the first position which PES packets pattern does not match (some malformed packets).
+      while (packetBuffer.bytesLeft() >= 4) {
+        nextStartCode = peekIntAtPosition(packetBuffer.data, packetBuffer.getPosition());
+        if (nextStartCode == PsExtractor.PACK_START_CODE
+            || nextStartCode == PsExtractor.MPEG_PROGRAM_END_CODE) {
+          break;
+        }
+        if (nextStartCode >>> 8 != PsExtractor.PACKET_START_CODE_PREFIX) {
+          break;
+        }
+        packetBuffer.skipBytes(4);
+
+        if (packetBuffer.bytesLeft() < 2) {
+          // 2 bytes for PES_packet length.
+          packetBuffer.setPosition(limit);
+          return;
+        }
+        int pesPacketLength = packetBuffer.readUnsignedShort();
+        packetBuffer.setPosition(
+            Math.min(packetBuffer.limit(), packetBuffer.getPosition() + pesPacketLength));
+      }
+    }
+  }
+
+  private static int peekIntAtPosition(byte[] data, int position) {
+    return (data[position] & 0xFF) << 24
+        | (data[position + 1] & 0xFF) << 16
+        | (data[position + 2] & 0xFF) << 8
+        | (data[position + 3] & 0xFF);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java
new file mode 100644
index 0000000000..b0cdf7eb79
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/**
+ * A reader that can extract the approximate duration from a given MPEG program stream (PS).
+ *
+ * <p>This reader extracts the duration by reading system clock reference (SCR) values from the
+ * header of a pack at the start and at the end of the stream, calculating the difference, and
+ * converting that into stream duration. This reader also handles the case when a single SCR
+ * wraparound takes place within the stream, which can make SCR values at the beginning of the
+ * stream larger than SCR values at the end. This class can only be used once to read duration from
+ * a given stream, and the usage of the class is not thread-safe, so all calls should be made from
+ * the same thread.
+ *
+ * <p>Note: See ISO/IEC 13818-1, Table 2-33 for details of the SCR field in pack_header.
+ */
+/* package */ final class PsDurationReader {
+
+  private static final int TIMESTAMP_SEARCH_BYTES = 20000;
+
+  private final TimestampAdjuster scrTimestampAdjuster;
+  private final ParsableByteArray packetBuffer;
+
+  private boolean isDurationRead;
+  private boolean isFirstScrValueRead;
+  private boolean isLastScrValueRead;
+
+  private long firstScrValue;
+  private long lastScrValue;
+  private long durationUs;
+
+  /* package */ PsDurationReader() {
+    scrTimestampAdjuster = new TimestampAdjuster(/* firstSampleTimestampUs= */ 0);
+    firstScrValue = C.TIME_UNSET;
+    lastScrValue = C.TIME_UNSET;
+    durationUs = C.TIME_UNSET;
+    packetBuffer = new ParsableByteArray();
+  }
+
+  /** Returns true if a PS duration has been read. */
+  public boolean isDurationReadFinished() {
+    return isDurationRead;
+  }
+
+  public TimestampAdjuster getScrTimestampAdjuster() {
+    return scrTimestampAdjuster;
+  }
+
+  /**
+   * Reads a PS duration from the input.
+   *
+   * <p>This reader reads the duration by reading SCR values from the header of a pack at the start
+   * and at the end of the stream, calculating the difference, and converting that into stream
+   * duration.
+   *
+   * @param input The {@link ExtractorInput} from which data should be read.
+   * @param seekPositionHolder If {@link Extractor#RESULT_SEEK} is returned, this holder is updated
+   *     to hold the position of the required seek.
+   * @return One of the {@code RESULT_} values defined in {@link Extractor}.
+   * @throws IOException If an error occurred reading from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public @Extractor.ReadResult int readDuration(
+      ExtractorInput input, PositionHolder seekPositionHolder)
+      throws IOException, InterruptedException {
+    if (!isLastScrValueRead) {
+      return readLastScrValue(input, seekPositionHolder);
+    }
+    if (lastScrValue == C.TIME_UNSET) {
+      return finishReadDuration(input);
+    }
+    if (!isFirstScrValueRead) {
+      return readFirstScrValue(input, seekPositionHolder);
+    }
+    if (firstScrValue == C.TIME_UNSET) {
+      return finishReadDuration(input);
+    }
+
+    long minScrPositionUs = scrTimestampAdjuster.adjustTsTimestamp(firstScrValue);
+    long maxScrPositionUs = scrTimestampAdjuster.adjustTsTimestamp(lastScrValue);
+    durationUs = maxScrPositionUs - minScrPositionUs;
+    return finishReadDuration(input);
+  }
+
+  /** Returns the duration last read from {@link #readDuration(ExtractorInput, PositionHolder)}. */
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Returns the SCR value read from the next pack in the stream, given the buffer at the pack
+   * header start position (just behind the pack start code).
+   */
+  public static long readScrValueFromPack(ParsableByteArray packetBuffer) {
+    int originalPosition = packetBuffer.getPosition();
+    if (packetBuffer.bytesLeft() < 9) {
+      // We require at 9 bytes for pack header to read scr value
+      return C.TIME_UNSET;
+    }
+    byte[] scrBytes = new byte[9];
+    packetBuffer.readBytes(scrBytes, /* offset= */ 0, scrBytes.length);
+    packetBuffer.setPosition(originalPosition);
+    if (!checkMarkerBits(scrBytes)) {
+      return C.TIME_UNSET;
+    }
+    return readScrValueFromPackHeader(scrBytes);
+  }
+
+  private int finishReadDuration(ExtractorInput input) {
+    packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
+    isDurationRead = true;
+    input.resetPeekPosition();
+    return Extractor.RESULT_CONTINUE;
+  }
+
+  private int readFirstScrValue(ExtractorInput input, PositionHolder seekPositionHolder)
+      throws IOException, InterruptedException {
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength());
+    int searchStartPosition = 0;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
+      return Extractor.RESULT_SEEK;
+    }
+
+    packetBuffer.reset(bytesToSearch);
+    input.resetPeekPosition();
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
+
+    firstScrValue = readFirstScrValueFromBuffer(packetBuffer);
+    isFirstScrValueRead = true;
+    return Extractor.RESULT_CONTINUE;
+  }
+
+  private long readFirstScrValueFromBuffer(ParsableByteArray packetBuffer) {
+    int searchStartPosition = packetBuffer.getPosition();
+    int searchEndPosition = packetBuffer.limit();
+    for (int searchPosition = searchStartPosition;
+        searchPosition < searchEndPosition - 3;
+        searchPosition++) {
+      int nextStartCode = peekIntAtPosition(packetBuffer.data, searchPosition);
+      if (nextStartCode == PsExtractor.PACK_START_CODE) {
+        packetBuffer.setPosition(searchPosition + 4);
+        long scrValue = readScrValueFromPack(packetBuffer);
+        if (scrValue != C.TIME_UNSET) {
+          return scrValue;
+        }
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+  private int readLastScrValue(ExtractorInput input, PositionHolder seekPositionHolder)
+      throws IOException, InterruptedException {
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, inputLength);
+    long searchStartPosition = inputLength - bytesToSearch;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
+      return Extractor.RESULT_SEEK;
+    }
+
+    packetBuffer.reset(bytesToSearch);
+    input.resetPeekPosition();
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
+
+    lastScrValue = readLastScrValueFromBuffer(packetBuffer);
+    isLastScrValueRead = true;
+    return Extractor.RESULT_CONTINUE;
+  }
+
+  private long readLastScrValueFromBuffer(ParsableByteArray packetBuffer) {
+    int searchStartPosition = packetBuffer.getPosition();
+    int searchEndPosition = packetBuffer.limit();
+    for (int searchPosition = searchEndPosition - 4;
+        searchPosition >= searchStartPosition;
+        searchPosition--) {
+      int nextStartCode = peekIntAtPosition(packetBuffer.data, searchPosition);
+      if (nextStartCode == PsExtractor.PACK_START_CODE) {
+        packetBuffer.setPosition(searchPosition + 4);
+        long scrValue = readScrValueFromPack(packetBuffer);
+        if (scrValue != C.TIME_UNSET) {
+          return scrValue;
+        }
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+  private int peekIntAtPosition(byte[] data, int position) {
+    return (data[position] & 0xFF) << 24
+        | (data[position + 1] & 0xFF) << 16
+        | (data[position + 2] & 0xFF) << 8
+        | (data[position + 3] & 0xFF);
+  }
+
+  private static boolean checkMarkerBits(byte[] scrBytes) {
+    // Verify the 01xxx1xx marker on the 0th byte
+    if ((scrBytes[0] & 0xC4) != 0x44) {
+      return false;
+    }
+    // 1st byte belongs to scr field.
+    // Verify the xxxxx1xx marker on the 2nd byte
+    if ((scrBytes[2] & 0x04) != 0x04) {
+      return false;
+    }
+    // 3rd byte belongs to scr field.
+    // Verify the xxxxx1xx marker on the 4rd byte
+    if ((scrBytes[4] & 0x04) != 0x04) {
+      return false;
+    }
+    // Verify the xxxxxxx1 marker on the 5th byte
+    if ((scrBytes[5] & 0x01) != 0x01) {
+      return false;
+    }
+    // 6th and 7th bytes belongs to program_max_rate field.
+    // Verify the xxxxxx11 marker on the 8th byte
+    return (scrBytes[8] & 0x03) == 0x03;
+  }
+
+  /**
+   * Returns the value of SCR base - 33 bits in big endian order from the PS pack header, ignoring
+   * the marker bits. Note: See ISO/IEC 13818-1, Table 2-33 for details of the SCR field in
+   * pack_header.
+   *
+   * <p>We ignore SCR Ext, because it's too small to have any significance.
+   */
+  private static long readScrValueFromPackHeader(byte[] scrBytes) {
+    return ((scrBytes[0] & 0b00111000L) >> 3) << 30
+        | (scrBytes[0] & 0b00000011L) << 28
+        | (scrBytes[1] & 0xFFL) << 20
+        | ((scrBytes[2] & 0b11111000L) >> 3) << 15
+        | (scrBytes[2] & 0b00000011L) << 13
+        | (scrBytes[3] & 0xFFL) << 5
+        | (scrBytes[4] & 0b11111000L) >> 3;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index f3aad6ba6b..f453a9cc43 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -35,24 +35,20 @@
  */
 public final class PsExtractor implements Extractor {
 
-  /**
-   * Factory for {@link PsExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new PsExtractor()};
-    }
-
-  };
+  /** Factory for {@link PsExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new PsExtractor()};
 
-  private static final int PACK_START_CODE = 0x000001BA;
-  private static final int SYSTEM_HEADER_START_CODE = 0x000001BB;
-  private static final int PACKET_START_CODE_PREFIX = 0x000001;
-  private static final int MPEG_PROGRAM_END_CODE = 0x000001B9;
+  /* package */ static final int PACK_START_CODE = 0x000001BA;
+  /* package */ static final int SYSTEM_HEADER_START_CODE = 0x000001BB;
+  /* package */ static final int PACKET_START_CODE_PREFIX = 0x000001;
+  /* package */ static final int MPEG_PROGRAM_END_CODE = 0x000001B9;
   private static final int MAX_STREAM_ID_PLUS_ONE = 0x100;
+
+  // Max search length for first audio and video track in input data.
   private static final long MAX_SEARCH_LENGTH = 1024 * 1024;
+  // Max search length for additional audio and video tracks in input data after at least one audio
+  // and video track has been found.
+  private static final long MAX_SEARCH_LENGTH_AFTER_AUDIO_AND_VIDEO_FOUND = 8 * 1024;
 
   public static final int PRIVATE_STREAM_1 = 0xBD;
   public static final int AUDIO_STREAM = 0xC0;
@@ -63,12 +59,17 @@
   private final TimestampAdjuster timestampAdjuster;
   private final SparseArray<PesReader> psPayloadReaders; // Indexed by pid
   private final ParsableByteArray psPacketBuffer;
+  private final PsDurationReader durationReader;
+
   private boolean foundAllTracks;
   private boolean foundAudioTrack;
   private boolean foundVideoTrack;
+  private long lastTrackPosition;
 
   // Accessed only by the loading thread.
+  private PsBinarySearchSeeker psBinarySearchSeeker;
   private ExtractorOutput output;
+  private boolean hasOutputSeekMap;
 
   public PsExtractor() {
     this(new TimestampAdjuster(0));
@@ -78,6 +79,7 @@ public PsExtractor(TimestampAdjuster timestampAdjuster) {
     this.timestampAdjuster = timestampAdjuster;
     psPacketBuffer = new ParsableByteArray(4096);
     psPayloadReaders = new SparseArray<>();
+    durationReader = new PsDurationReader();
   }
 
   // Extractor implementation.
@@ -124,12 +126,27 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public void init(ExtractorOutput output) {
     this.output = output;
-    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
 
   @Override
   public void seek(long position, long timeUs) {
-    timestampAdjuster.reset();
+    boolean hasNotEncounteredFirstTimestamp =
+        timestampAdjuster.getTimestampOffsetUs() == C.TIME_UNSET;
+    if (hasNotEncounteredFirstTimestamp
+        || (timestampAdjuster.getFirstSampleTimestampUs() != 0
+            && timestampAdjuster.getFirstSampleTimestampUs() != timeUs)) {
+      // - If the timestamp adjuster in the PS stream has not encountered any sample, it's going to
+      // treat the first timestamp encountered as sample time 0, which is incorrect. In this case,
+      // we have to set the first sample timestamp manually.
+      // - If the timestamp adjuster has its timestamp set manually before, and now we seek to a
+      // different position, we need to set the first sample timestamp manually again.
+      timestampAdjuster.reset();
+      timestampAdjuster.setFirstSampleTimestampUs(timeUs);
+    }
+
+    if (psBinarySearchSeeker != null) {
+      psBinarySearchSeeker.setSeekTargetUs(timeUs);
+    }
     for (int i = 0; i < psPayloadReaders.size(); i++) {
       psPayloadReaders.valueAt(i).seek();
     }
@@ -143,6 +160,24 @@ public void release() {
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
+
+    long inputLength = input.getLength();
+    boolean canReadDuration = inputLength != C.LENGTH_UNSET;
+    if (canReadDuration && !durationReader.isDurationReadFinished()) {
+      return durationReader.readDuration(input, seekPosition);
+    }
+    maybeOutputSeekMap(inputLength);
+    if (psBinarySearchSeeker != null && psBinarySearchSeeker.isSeeking()) {
+      return psBinarySearchSeeker.handlePendingSeek(
+          input, seekPosition, /* outputFrameHolder= */ null);
+    }
+
+    input.resetPeekPosition();
+    long peekBytesLeft =
+        inputLength != C.LENGTH_UNSET ? inputLength - input.getPeekPosition() : C.LENGTH_UNSET;
+    if (peekBytesLeft != C.LENGTH_UNSET && peekBytesLeft < 4) {
+      return RESULT_END_OF_INPUT;
+    }
     // First peek and check what type of start code is next.
     if (!input.peekFully(psPacketBuffer.data, 0, 4, true)) {
       return RESULT_END_OF_INPUT;
@@ -188,18 +223,21 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     if (!foundAllTracks) {
       if (payloadReader == null) {
         ElementaryStreamReader elementaryStreamReader = null;
-        if (!foundAudioTrack && streamId == PRIVATE_STREAM_1) {
+        if (streamId == PRIVATE_STREAM_1) {
           // Private stream, used for AC3 audio.
           // NOTE: This may need further parsing to determine if its DTS, but that's likely only
           // valid for DVDs.
           elementaryStreamReader = new Ac3Reader();
           foundAudioTrack = true;
-        } else if (!foundAudioTrack && (streamId & AUDIO_STREAM_MASK) == AUDIO_STREAM) {
+          lastTrackPosition = input.getPosition();
+        } else if ((streamId & AUDIO_STREAM_MASK) == AUDIO_STREAM) {
           elementaryStreamReader = new MpegAudioReader();
           foundAudioTrack = true;
-        } else if (!foundVideoTrack && (streamId & VIDEO_STREAM_MASK) == VIDEO_STREAM) {
+          lastTrackPosition = input.getPosition();
+        } else if ((streamId & VIDEO_STREAM_MASK) == VIDEO_STREAM) {
           elementaryStreamReader = new H262Reader();
           foundVideoTrack = true;
+          lastTrackPosition = input.getPosition();
         }
         if (elementaryStreamReader != null) {
           TrackIdGenerator idGenerator = new TrackIdGenerator(streamId, MAX_STREAM_ID_PLUS_ONE);
@@ -208,7 +246,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
           psPayloadReaders.put(streamId, payloadReader);
         }
       }
-      if ((foundAudioTrack && foundVideoTrack) || input.getPosition() > MAX_SEARCH_LENGTH) {
+      long maxSearchPosition =
+          foundAudioTrack && foundVideoTrack
+              ? lastTrackPosition + MAX_SEARCH_LENGTH_AFTER_AUDIO_AND_VIDEO_FOUND
+              : MAX_SEARCH_LENGTH;
+      if (input.getPosition() > maxSearchPosition) {
         foundAllTracks = true;
         output.endTracks();
       }
@@ -237,6 +279,22 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
   // Internals.
 
+  private void maybeOutputSeekMap(long inputLength) {
+    if (!hasOutputSeekMap) {
+      hasOutputSeekMap = true;
+      if (durationReader.getDurationUs() != C.TIME_UNSET) {
+        psBinarySearchSeeker =
+            new PsBinarySearchSeeker(
+                durationReader.getScrTimestampAdjuster(),
+                durationReader.getDurationUs(),
+                inputLength);
+        output.seekMap(psBinarySearchSeeker.getSeekMap());
+      } else {
+        output.seekMap(new SeekMap.Unseekable(durationReader.getDurationUs()));
+      }
+    }
+  }
+
   /**
    * Parses PES packet data and extracts samples.
    */
@@ -285,7 +343,7 @@ public void consume(ParsableByteArray data) throws ParserException {
       data.readBytes(pesScratch.data, 0, extendedHeaderLength);
       pesScratch.setPosition(0);
       parseHeaderExtension();
-      pesPayloadReader.packetStarted(timeUs, true);
+      pesPayloadReader.packetStarted(timeUs, TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR);
       pesPayloadReader.consume(data);
       // We always have complete PES packets with program stream.
       pesPayloadReader.packetFinished();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
index d217cfcb7a..101a1f74d9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
@@ -57,7 +57,8 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+  public void consume(ParsableByteArray data, @Flags int flags) {
+    boolean payloadUnitStartIndicator = (flags & FLAG_PAYLOAD_UNIT_START_INDICATOR) != 0;
     int payloadStartPosition = C.POSITION_UNSET;
     if (payloadUnitStartIndicator) {
       int payloadStartOffset = data.readUnsignedByte();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
index 907419f8fc..895c224697 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
@@ -52,9 +52,18 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
           || MimeTypes.APPLICATION_CEA708.equals(channelMimeType),
           "Invalid closed caption mime type provided: " + channelMimeType);
       String formatId = channelFormat.id != null ? channelFormat.id : idGenerator.getFormatId();
-      output.format(Format.createTextSampleFormat(formatId, channelMimeType, null, Format.NO_VALUE,
-          channelFormat.selectionFlags, channelFormat.language, channelFormat.accessibilityChannel,
-          null));
+      output.format(
+          Format.createTextSampleFormat(
+              formatId,
+              channelMimeType,
+              /* codecs= */ null,
+              /* bitrate= */ Format.NO_VALUE,
+              channelFormat.selectionFlags,
+              channelFormat.language,
+              channelFormat.accessibilityChannel,
+              /* drmInitData= */ null,
+              Format.OFFSET_SAMPLE_RELATIVE,
+              channelFormat.initializationData));
       outputs[i] = output;
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java
new file mode 100644
index 0000000000..ea2519d2e9
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/**
+ * A seeker that supports seeking within TS stream using binary search.
+ *
+ * <p>This seeker uses the first and last PCR values within the stream, as well as the stream
+ * duration to interpolate the PCR value of the seeking position. Then it performs binary search
+ * within the stream to find a packets whose PCR value is within {@link #SEEK_TOLERANCE_US} from the
+ * target PCR.
+ */
+/* package */ final class TsBinarySearchSeeker extends BinarySearchSeeker {
+
+  private static final long SEEK_TOLERANCE_US = 100_000;
+  private static final int MINIMUM_SEARCH_RANGE_BYTES = 5 * TsExtractor.TS_PACKET_SIZE;
+  private static final int TIMESTAMP_SEARCH_BYTES = 600 * TsExtractor.TS_PACKET_SIZE;
+
+  public TsBinarySearchSeeker(
+      TimestampAdjuster pcrTimestampAdjuster, long streamDurationUs, long inputLength, int pcrPid) {
+    super(
+        new DefaultSeekTimestampConverter(),
+        new TsPcrSeeker(pcrPid, pcrTimestampAdjuster),
+        streamDurationUs,
+        /* floorTimePosition= */ 0,
+        /* ceilingTimePosition= */ streamDurationUs + 1,
+        /* floorBytePosition= */ 0,
+        /* ceilingBytePosition= */ inputLength,
+        /* approxBytesPerFrame= */ TsExtractor.TS_PACKET_SIZE,
+        MINIMUM_SEARCH_RANGE_BYTES);
+  }
+
+  /**
+   * A {@link TimestampSeeker} implementation that looks for a given PCR timestamp at a given
+   * position in a TS stream.
+   *
+   * <p>Given a PCR timestamp, and a position within a TS stream, this seeker will peek up to {@link
+   * #TIMESTAMP_SEARCH_BYTES} from that stream position, look for all packets with PID equal to
+   * PCR_PID, and then compare the PCR timestamps (if available) of these packets to the target
+   * timestamp.
+   */
+  private static final class TsPcrSeeker implements TimestampSeeker {
+
+    private final TimestampAdjuster pcrTimestampAdjuster;
+    private final ParsableByteArray packetBuffer;
+    private final int pcrPid;
+
+    public TsPcrSeeker(int pcrPid, TimestampAdjuster pcrTimestampAdjuster) {
+      this.pcrPid = pcrPid;
+      this.pcrTimestampAdjuster = pcrTimestampAdjuster;
+      packetBuffer = new ParsableByteArray();
+    }
+
+    @Override
+    public TimestampSearchResult searchForTimestamp(
+        ExtractorInput input, long targetTimestamp, OutputFrameHolder outputFrameHolder)
+        throws IOException, InterruptedException {
+      long inputPosition = input.getPosition();
+      int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength() - inputPosition);
+
+      packetBuffer.reset(bytesToSearch);
+      input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
+
+      return searchForPcrValueInBuffer(packetBuffer, targetTimestamp, inputPosition);
+    }
+
+    private TimestampSearchResult searchForPcrValueInBuffer(
+        ParsableByteArray packetBuffer, long targetPcrTimeUs, long bufferStartOffset) {
+      int limit = packetBuffer.limit();
+
+      long startOfLastPacketPosition = C.POSITION_UNSET;
+      long endOfLastPacketPosition = C.POSITION_UNSET;
+      long lastPcrTimeUsInRange = C.TIME_UNSET;
+
+      while (packetBuffer.bytesLeft() >= TsExtractor.TS_PACKET_SIZE) {
+        int startOfPacket =
+            TsUtil.findSyncBytePosition(packetBuffer.data, packetBuffer.getPosition(), limit);
+        int endOfPacket = startOfPacket + TsExtractor.TS_PACKET_SIZE;
+        if (endOfPacket > limit) {
+          break;
+        }
+        long pcrValue = TsUtil.readPcrFromPacket(packetBuffer, startOfPacket, pcrPid);
+        if (pcrValue != C.TIME_UNSET) {
+          long pcrTimeUs = pcrTimestampAdjuster.adjustTsTimestamp(pcrValue);
+          if (pcrTimeUs > targetPcrTimeUs) {
+            if (lastPcrTimeUsInRange == C.TIME_UNSET) {
+              // First PCR timestamp is already over target.
+              return TimestampSearchResult.overestimatedResult(pcrTimeUs, bufferStartOffset);
+            } else {
+              // Last PCR timestamp < target timestamp < this timestamp.
+              return TimestampSearchResult.targetFoundResult(
+                  bufferStartOffset + startOfLastPacketPosition);
+            }
+          } else if (pcrTimeUs + SEEK_TOLERANCE_US > targetPcrTimeUs) {
+            long startOfPacketInStream = bufferStartOffset + startOfPacket;
+            return TimestampSearchResult.targetFoundResult(startOfPacketInStream);
+          }
+
+          lastPcrTimeUsInRange = pcrTimeUs;
+          startOfLastPacketPosition = startOfPacket;
+        }
+        packetBuffer.setPosition(endOfPacket);
+        endOfLastPacketPosition = endOfPacket;
+      }
+
+      if (lastPcrTimeUsInRange != C.TIME_UNSET) {
+        long endOfLastPacketPositionInStream = bufferStartOffset + endOfLastPacketPosition;
+        return TimestampSearchResult.underestimatedResult(
+            lastPcrTimeUsInRange, endOfLastPacketPositionInStream);
+      } else {
+        return TimestampSearchResult.NO_TIMESTAMP_IN_RANGE_RESULT;
+      }
+    }
+
+    @Override
+    public void onSeekFinished() {
+      packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java
new file mode 100644
index 0000000000..804a643414
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/**
+ * A reader that can extract the approximate duration from a given MPEG transport stream (TS).
+ *
+ * <p>This reader extracts the duration by reading PCR values of the PCR PID packets at the start
+ * and at the end of the stream, calculating the difference, and converting that into stream
+ * duration. This reader also handles the case when a single PCR wraparound takes place within the
+ * stream, which can make PCR values at the beginning of the stream larger than PCR values at the
+ * end. This class can only be used once to read duration from a given stream, and the usage of the
+ * class is not thread-safe, so all calls should be made from the same thread.
+ */
+/* package */ final class TsDurationReader {
+
+  private static final int TIMESTAMP_SEARCH_BYTES = 600 * TsExtractor.TS_PACKET_SIZE;
+
+  private final TimestampAdjuster pcrTimestampAdjuster;
+  private final ParsableByteArray packetBuffer;
+
+  private boolean isDurationRead;
+  private boolean isFirstPcrValueRead;
+  private boolean isLastPcrValueRead;
+
+  private long firstPcrValue;
+  private long lastPcrValue;
+  private long durationUs;
+
+  /* package */ TsDurationReader() {
+    pcrTimestampAdjuster = new TimestampAdjuster(/* firstSampleTimestampUs= */ 0);
+    firstPcrValue = C.TIME_UNSET;
+    lastPcrValue = C.TIME_UNSET;
+    durationUs = C.TIME_UNSET;
+    packetBuffer = new ParsableByteArray();
+  }
+
+  /** Returns true if a TS duration has been read. */
+  public boolean isDurationReadFinished() {
+    return isDurationRead;
+  }
+
+  /**
+   * Reads a TS duration from the input, using the given PCR PID.
+   *
+   * <p>This reader reads the duration by reading PCR values of the PCR PID packets at the start and
+   * at the end of the stream, calculating the difference, and converting that into stream duration.
+   *
+   * @param input The {@link ExtractorInput} from which data should be read.
+   * @param seekPositionHolder If {@link Extractor#RESULT_SEEK} is returned, this holder is updated
+   *     to hold the position of the required seek.
+   * @param pcrPid The PID of the packet stream within this TS stream that contains PCR values.
+   * @return One of the {@code RESULT_} values defined in {@link Extractor}.
+   * @throws IOException If an error occurred reading from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public @Extractor.ReadResult int readDuration(
+      ExtractorInput input, PositionHolder seekPositionHolder, int pcrPid)
+      throws IOException, InterruptedException {
+    if (pcrPid <= 0) {
+      return finishReadDuration(input);
+    }
+    if (!isLastPcrValueRead) {
+      return readLastPcrValue(input, seekPositionHolder, pcrPid);
+    }
+    if (lastPcrValue == C.TIME_UNSET) {
+      return finishReadDuration(input);
+    }
+    if (!isFirstPcrValueRead) {
+      return readFirstPcrValue(input, seekPositionHolder, pcrPid);
+    }
+    if (firstPcrValue == C.TIME_UNSET) {
+      return finishReadDuration(input);
+    }
+
+    long minPcrPositionUs = pcrTimestampAdjuster.adjustTsTimestamp(firstPcrValue);
+    long maxPcrPositionUs = pcrTimestampAdjuster.adjustTsTimestamp(lastPcrValue);
+    durationUs = maxPcrPositionUs - minPcrPositionUs;
+    return finishReadDuration(input);
+  }
+
+  /**
+   * Returns the duration last read from {@link #readDuration(ExtractorInput, PositionHolder, int)}.
+   */
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Returns the {@link TimestampAdjuster} that this class uses to adjust timestamps read from the
+   * input TS stream.
+   */
+  public TimestampAdjuster getPcrTimestampAdjuster() {
+    return pcrTimestampAdjuster;
+  }
+
+  private int finishReadDuration(ExtractorInput input) {
+    packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
+    isDurationRead = true;
+    input.resetPeekPosition();
+    return Extractor.RESULT_CONTINUE;
+  }
+
+  private int readFirstPcrValue(ExtractorInput input, PositionHolder seekPositionHolder, int pcrPid)
+      throws IOException, InterruptedException {
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength());
+    int searchStartPosition = 0;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
+      return Extractor.RESULT_SEEK;
+    }
+
+    packetBuffer.reset(bytesToSearch);
+    input.resetPeekPosition();
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
+
+    firstPcrValue = readFirstPcrValueFromBuffer(packetBuffer, pcrPid);
+    isFirstPcrValueRead = true;
+    return Extractor.RESULT_CONTINUE;
+  }
+
+  private long readFirstPcrValueFromBuffer(ParsableByteArray packetBuffer, int pcrPid) {
+    int searchStartPosition = packetBuffer.getPosition();
+    int searchEndPosition = packetBuffer.limit();
+    for (int searchPosition = searchStartPosition;
+        searchPosition < searchEndPosition;
+        searchPosition++) {
+      if (packetBuffer.data[searchPosition] != TsExtractor.TS_SYNC_BYTE) {
+        continue;
+      }
+      long pcrValue = TsUtil.readPcrFromPacket(packetBuffer, searchPosition, pcrPid);
+      if (pcrValue != C.TIME_UNSET) {
+        return pcrValue;
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+  private int readLastPcrValue(ExtractorInput input, PositionHolder seekPositionHolder, int pcrPid)
+      throws IOException, InterruptedException {
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, inputLength);
+    long searchStartPosition = inputLength - bytesToSearch;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
+      return Extractor.RESULT_SEEK;
+    }
+
+    packetBuffer.reset(bytesToSearch);
+    input.resetPeekPosition();
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
+
+    lastPcrValue = readLastPcrValueFromBuffer(packetBuffer, pcrPid);
+    isLastPcrValueRead = true;
+    return Extractor.RESULT_CONTINUE;
+  }
+
+  private long readLastPcrValueFromBuffer(ParsableByteArray packetBuffer, int pcrPid) {
+    int searchStartPosition = packetBuffer.getPosition();
+    int searchEndPosition = packetBuffer.limit();
+    for (int searchPosition = searchEndPosition - 1;
+        searchPosition >= searchStartPosition;
+        searchPosition--) {
+      if (packetBuffer.data[searchPosition] != TsExtractor.TS_SYNC_BYTE) {
+        continue;
+      }
+      long pcrValue = TsUtil.readPcrFromPacket(packetBuffer, searchPosition, pcrPid);
+      if (pcrValue != C.TIME_UNSET) {
+        return pcrValue;
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 50931e2d90..d91842423d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_PAYLOAD_UNIT_START_INDICATOR;
+
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
@@ -38,6 +40,7 @@
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -50,21 +53,14 @@
  */
 public final class TsExtractor implements Extractor {
 
-  /**
-   * Factory for {@link TsExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new TsExtractor()};
-    }
-
-  };
+  /** Factory for {@link TsExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new TsExtractor()};
 
   /**
-   * Modes for the extractor.
+   * Modes for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT} or {@link
+   * #MODE_HLS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
   public @interface Mode {}
@@ -98,8 +94,9 @@
   public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
   public static final int TS_STREAM_TYPE_DVBSUBS = 0x59;
 
-  private static final int TS_PACKET_SIZE = 188;
-  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
+  public static final int TS_PACKET_SIZE = 188;
+  public static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
+
   private static final int TS_PAT_PID = 0;
   private static final int MAX_PID_PLUS_ONE = 0x2000;
 
@@ -110,20 +107,26 @@
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * 50;
   private static final int SNIFF_TS_PACKET_COUNT = 5;
 
-  @Mode private final int mode;
+  private final @Mode int mode;
   private final List<TimestampAdjuster> timestampAdjusters;
   private final ParsableByteArray tsPacketBuffer;
   private final SparseIntArray continuityCounters;
   private final TsPayloadReader.Factory payloadReaderFactory;
   private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
   private final SparseBooleanArray trackIds;
+  private final SparseBooleanArray trackPids;
+  private final TsDurationReader durationReader;
 
   // Accessed only by the loading thread.
+  private TsBinarySearchSeeker tsBinarySearchSeeker;
   private ExtractorOutput output;
   private int remainingPmts;
   private boolean tracksEnded;
+  private boolean hasOutputSeekMap;
+  private boolean pendingSeekToStart;
   private TsPayloadReader id3Reader;
   private int bytesSinceLastSync;
+  private int pcrPid;
 
   public TsExtractor() {
     this(0);
@@ -144,18 +147,21 @@ public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
    *     {@code FLAG_*} values that control the behavior of the payload readers.
    */
   public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
-    this(mode, new TimestampAdjuster(0),
+    this(
+        mode,
+        new TimestampAdjuster(0),
         new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
   }
 
-
   /**
    * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
    *     and {@link #MODE_HLS}.
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
    * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
    */
-  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+  public TsExtractor(
+      @Mode int mode,
+      TimestampAdjuster timestampAdjuster,
       TsPayloadReader.Factory payloadReaderFactory) {
     this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
     this.mode = mode;
@@ -167,8 +173,11 @@ public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
     }
     tsPacketBuffer = new ParsableByteArray(new byte[BUFFER_SIZE], 0);
     trackIds = new SparseBooleanArray();
+    trackPids = new SparseBooleanArray();
     tsPayloadReaders = new SparseArray<>();
     continuityCounters = new SparseIntArray();
+    durationReader = new TsDurationReader();
+    pcrPid = -1;
     resetPayloadReaders();
   }
 
@@ -178,16 +187,19 @@ public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     byte[] buffer = tsPacketBuffer.data;
     input.peekFully(buffer, 0, TS_PACKET_SIZE * SNIFF_TS_PACKET_COUNT);
-    for (int j = 0; j < TS_PACKET_SIZE; j++) {
-      for (int i = 0; true; i++) {
-        if (i == SNIFF_TS_PACKET_COUNT) {
-          input.skipFully(j);
-          return true;
-        }
-        if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
+    for (int startPosCandidate = 0; startPosCandidate < TS_PACKET_SIZE; startPosCandidate++) {
+      // Try to identify at least SNIFF_TS_PACKET_COUNT packets starting with TS_SYNC_BYTE.
+      boolean isSyncBytePatternCorrect = true;
+      for (int i = 0; i < SNIFF_TS_PACKET_COUNT; i++) {
+        if (buffer[startPosCandidate + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
+          isSyncBytePatternCorrect = false;
           break;
         }
       }
+      if (isSyncBytePatternCorrect) {
+        input.skipFully(startPosCandidate);
+        return true;
+      }
     }
     return false;
   }
@@ -195,19 +207,36 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public void init(ExtractorOutput output) {
     this.output = output;
-    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
 
   @Override
   public void seek(long position, long timeUs) {
+    Assertions.checkState(mode != MODE_HLS);
     int timestampAdjustersCount = timestampAdjusters.size();
     for (int i = 0; i < timestampAdjustersCount; i++) {
-      timestampAdjusters.get(i).reset();
+      TimestampAdjuster timestampAdjuster = timestampAdjusters.get(i);
+      boolean hasNotEncounteredFirstTimestamp =
+          timestampAdjuster.getTimestampOffsetUs() == C.TIME_UNSET;
+      if (hasNotEncounteredFirstTimestamp
+          || (timestampAdjuster.getTimestampOffsetUs() != 0
+              && timestampAdjuster.getFirstSampleTimestampUs() != timeUs)) {
+        // - If a track in the TS stream has not encountered any sample, it's going to treat the
+        // first sample encountered as timestamp 0, which is incorrect. So we have to set the first
+        // sample timestamp for that track manually.
+        // - If the timestamp adjuster has its timestamp set manually before, and now we seek to a
+        // different position, we need to set the first sample timestamp manually again.
+        timestampAdjuster.reset();
+        timestampAdjuster.setFirstSampleTimestampUs(timeUs);
+      }
+    }
+    if (timeUs != 0 && tsBinarySearchSeeker != null) {
+      tsBinarySearchSeeker.setSeekTargetUs(timeUs);
     }
     tsPacketBuffer.reset();
     continuityCounters.clear();
-    // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
-    resetPayloadReaders();
+    for (int i = 0; i < tsPayloadReaders.size(); i++) {
+      tsPayloadReaders.valueAt(i).seek();
+    }
     bytesSinceLastSync = 0;
   }
 
@@ -217,55 +246,51 @@ public void release() {
   }
 
   @Override
-  public int read(ExtractorInput input, PositionHolder seekPosition)
+  public @ReadResult int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    byte[] data = tsPacketBuffer.data;
-
-    // Shift bytes to the start of the buffer if there isn't enough space left at the end.
-    if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
-      int bytesLeft = tsPacketBuffer.bytesLeft();
-      if (bytesLeft > 0) {
-        System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
+    long inputLength = input.getLength();
+    if (tracksEnded) {
+      boolean canReadDuration = inputLength != C.LENGTH_UNSET && mode != MODE_HLS;
+      if (canReadDuration && !durationReader.isDurationReadFinished()) {
+        return durationReader.readDuration(input, seekPosition, pcrPid);
+      }
+      maybeOutputSeekMap(inputLength);
+
+      if (pendingSeekToStart) {
+        pendingSeekToStart = false;
+        seek(/* position= */ 0, /* timeUs= */ 0);
+        if (input.getPosition() != 0) {
+          seekPosition.position = 0;
+          return RESULT_SEEK;
+        }
       }
-      tsPacketBuffer.reset(data, bytesLeft);
-    }
 
-    // Read more bytes until we have at least one packet.
-    while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
-      int limit = tsPacketBuffer.limit();
-      int read = input.read(data, limit, BUFFER_SIZE - limit);
-      if (read == C.RESULT_END_OF_INPUT) {
-        return RESULT_END_OF_INPUT;
+      if (tsBinarySearchSeeker != null && tsBinarySearchSeeker.isSeeking()) {
+        return tsBinarySearchSeeker.handlePendingSeek(
+            input, seekPosition, /* outputFrameHolder= */ null);
       }
-      tsPacketBuffer.setLimit(limit + read);
     }
 
-    // Note: See ISO/IEC 13818-1, section 2.4.3.2 for details of the header format.
-    int limit = tsPacketBuffer.limit();
-    int position = tsPacketBuffer.getPosition();
-    int searchStart = position;
-    while (position < limit && data[position] != TS_SYNC_BYTE) {
-      position++;
+    if (!fillBufferWithAtLeastOnePacket(input)) {
+      return RESULT_END_OF_INPUT;
     }
-    tsPacketBuffer.setPosition(position);
 
-    int endOfPacket = position + TS_PACKET_SIZE;
+    int endOfPacket = findEndOfFirstTsPacketInBuffer();
+    int limit = tsPacketBuffer.limit();
     if (endOfPacket > limit) {
-      bytesSinceLastSync += position - searchStart;
-      if (mode == MODE_HLS && bytesSinceLastSync > TS_PACKET_SIZE * 2) {
-        throw new ParserException("Cannot find sync byte. Most likely not a Transport Stream.");
-      }
       return RESULT_CONTINUE;
     }
-    bytesSinceLastSync = 0;
 
+    @TsPayloadReader.Flags int packetHeaderFlags = 0;
+
+    // Note: See ISO/IEC 13818-1, section 2.4.3.2 for details of the header format.
     int tsPacketHeader = tsPacketBuffer.readInt();
     if ((tsPacketHeader & 0x800000) != 0) { // transport_error_indicator
       // There are uncorrectable errors in this packet.
       tsPacketBuffer.setPosition(endOfPacket);
       return RESULT_CONTINUE;
     }
-    boolean payloadUnitStartIndicator = (tsPacketHeader & 0x400000) != 0;
+    packetHeaderFlags |= (tsPacketHeader & 0x400000) != 0 ? FLAG_PAYLOAD_UNIT_START_INDICATOR : 0;
     // Ignoring transport_priority (tsPacketHeader & 0x200000)
     int pid = (tsPacketHeader & 0x1FFF00) >> 8;
     // Ignoring transport_scrambling_control (tsPacketHeader & 0xC0)
@@ -296,13 +321,28 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     // Skip the adaptation field.
     if (adaptationFieldExists) {
       int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
-      tsPacketBuffer.skipBytes(adaptationFieldLength);
+      int adaptationFieldFlags = tsPacketBuffer.readUnsignedByte();
+
+      packetHeaderFlags |=
+          (adaptationFieldFlags & 0x40) != 0 // random_access_indicator.
+              ? TsPayloadReader.FLAG_RANDOM_ACCESS_INDICATOR
+              : 0;
+      tsPacketBuffer.skipBytes(adaptationFieldLength - 1 /* flags */);
     }
 
     // Read the payload.
-    tsPacketBuffer.setLimit(endOfPacket);
-    payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
-    tsPacketBuffer.setLimit(limit);
+    boolean wereTracksEnded = tracksEnded;
+    if (shouldConsumePacketPayload(pid)) {
+      tsPacketBuffer.setLimit(endOfPacket);
+      payloadReader.consume(tsPacketBuffer, packetHeaderFlags);
+      tsPacketBuffer.setLimit(limit);
+    }
+    if (mode != MODE_HLS && !wereTracksEnded && tracksEnded && inputLength != C.LENGTH_UNSET) {
+      // We have read all tracks from all PMTs in this non-live stream. Now seek to the beginning
+      // and read again to make sure we output all media, including any contained in packets prior
+      // to those containing the track information.
+      pendingSeekToStart = true;
+    }
 
     tsPacketBuffer.setPosition(endOfPacket);
     return RESULT_CONTINUE;
@@ -310,6 +350,78 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
   // Internals.
 
+  private void maybeOutputSeekMap(long inputLength) {
+    if (!hasOutputSeekMap) {
+      hasOutputSeekMap = true;
+      if (durationReader.getDurationUs() != C.TIME_UNSET) {
+        tsBinarySearchSeeker =
+            new TsBinarySearchSeeker(
+                durationReader.getPcrTimestampAdjuster(),
+                durationReader.getDurationUs(),
+                inputLength,
+                pcrPid);
+        output.seekMap(tsBinarySearchSeeker.getSeekMap());
+      } else {
+        output.seekMap(new SeekMap.Unseekable(durationReader.getDurationUs()));
+      }
+    }
+  }
+
+  private boolean fillBufferWithAtLeastOnePacket(ExtractorInput input)
+      throws IOException, InterruptedException {
+    byte[] data = tsPacketBuffer.data;
+    // Shift bytes to the start of the buffer if there isn't enough space left at the end.
+    if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
+      int bytesLeft = tsPacketBuffer.bytesLeft();
+      if (bytesLeft > 0) {
+        System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
+      }
+      tsPacketBuffer.reset(data, bytesLeft);
+    }
+    // Read more bytes until we have at least one packet.
+    while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
+      int limit = tsPacketBuffer.limit();
+      int read = input.read(data, limit, BUFFER_SIZE - limit);
+      if (read == C.RESULT_END_OF_INPUT) {
+        return false;
+      }
+      tsPacketBuffer.setLimit(limit + read);
+    }
+    return true;
+  }
+
+  /**
+   * Returns the position of the end of the first TS packet (exclusive) in the packet buffer.
+   *
+   * <p>This may be a position beyond the buffer limit if the packet has not been read fully into
+   * the buffer, or if no packet could be found within the buffer.
+   */
+  private int findEndOfFirstTsPacketInBuffer() throws ParserException {
+    int searchStart = tsPacketBuffer.getPosition();
+    int limit = tsPacketBuffer.limit();
+    int syncBytePosition = TsUtil.findSyncBytePosition(tsPacketBuffer.data, searchStart, limit);
+    // Discard all bytes before the sync byte.
+    // If sync byte is not found, this means discard the whole buffer.
+    tsPacketBuffer.setPosition(syncBytePosition);
+    int endOfPacket = syncBytePosition + TS_PACKET_SIZE;
+    if (endOfPacket > limit) {
+      bytesSinceLastSync += syncBytePosition - searchStart;
+      if (mode == MODE_HLS && bytesSinceLastSync > TS_PACKET_SIZE * 2) {
+        throw new ParserException("Cannot find sync byte. Most likely not a Transport Stream.");
+      }
+    } else {
+      // We have found a packet within the buffer.
+      bytesSinceLastSync = 0;
+    }
+    return endOfPacket;
+  }
+
+  private boolean shouldConsumePacketPayload(int packetPid) {
+    return mode == MODE_HLS
+        || tracksEnded
+        || !trackPids.get(packetPid, /* valueIfKeyNotFound= */ false); // It's a PSI packet
+  }
+
   private void resetPayloadReaders() {
     trackIds.clear();
     tsPayloadReaders.clear();
@@ -422,9 +534,16 @@ public void consume(ParsableByteArray sectionData) {
       // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12)
       sectionData.skipBytes(2);
       int programNumber = sectionData.readUnsignedShort();
+
+      // Skip 3 bytes (24 bits), including:
       // reserved (2), version_number (5), current_next_indicator (1), section_number (8),
-      // last_section_number (8), reserved (3), PCR_PID (13)
-      sectionData.skipBytes(5);
+      // last_section_number (8)
+      sectionData.skipBytes(3);
+
+      sectionData.readBytes(pmtScratch, 2);
+      // reserved (3), PCR_PID (13)
+      pmtScratch.skipBits(3);
+      pcrPid = pmtScratch.readBits(13);
 
       // Read program_info_length.
       sectionData.readBytes(pmtScratch, 2);
@@ -437,7 +556,7 @@ public void consume(ParsableByteArray sectionData) {
       if (mode == MODE_HLS && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See [Internal: b/20261500].
-        EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
+        EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, Util.EMPTY_BYTE_ARRAY);
         id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
         id3Reader.init(timestampAdjuster, output,
             new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
@@ -476,14 +595,16 @@ public void consume(ParsableByteArray sectionData) {
       int trackIdCount = trackIdToPidScratch.size();
       for (int i = 0; i < trackIdCount; i++) {
         int trackId = trackIdToPidScratch.keyAt(i);
+        int trackPid = trackIdToPidScratch.valueAt(i);
         trackIds.put(trackId, true);
+        trackPids.put(trackPid, true);
         TsPayloadReader reader = trackIdToReaderScratch.valueAt(i);
         if (reader != null) {
           if (reader != id3Reader) {
             reader.init(timestampAdjuster, output,
                 new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
           }
-          tsPayloadReaders.put(trackIdToPidScratch.valueAt(i), reader);
+          tsPayloadReaders.put(trackPid, reader);
         }
       }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index efa764b572..a034b05696 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -15,12 +15,16 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import android.support.annotation.IntDef;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
 import java.util.List;
 
@@ -77,8 +81,10 @@ public EsInfo(int streamType, String language, List<DvbSubtitleInfo> dvbSubtitle
         byte[] descriptorBytes) {
       this.streamType = streamType;
       this.language = language;
-      this.dvbSubtitleInfos = dvbSubtitleInfos == null ? Collections.<DvbSubtitleInfo>emptyList()
-          : Collections.unmodifiableList(dvbSubtitleInfos);
+      this.dvbSubtitleInfos =
+          dvbSubtitleInfos == null
+              ? Collections.emptyList()
+              : Collections.unmodifiableList(dvbSubtitleInfos);
       this.descriptorBytes = descriptorBytes;
     }
 
@@ -172,6 +178,29 @@ private void maybeThrowUninitializedError() {
 
   }
 
+  /**
+   * Contextual flags indicating the presence of indicators in the TS packet or PES packet headers.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(
+      flag = true,
+      value = {
+        FLAG_PAYLOAD_UNIT_START_INDICATOR,
+        FLAG_RANDOM_ACCESS_INDICATOR,
+        FLAG_DATA_ALIGNMENT_INDICATOR
+      })
+  @interface Flags {}
+
+  /** Indicates the presence of the payload_unit_start_indicator in the TS packet header. */
+  int FLAG_PAYLOAD_UNIT_START_INDICATOR = 1;
+  /**
+   * Indicates the presence of the random_access_indicator in the TS packet header adaptation field.
+   */
+  int FLAG_RANDOM_ACCESS_INDICATOR = 1 << 1;
+  /** Indicates the presence of the data_alignment_indicator in the PES header. */
+  int FLAG_DATA_ALIGNMENT_INDICATOR = 1 << 2;
+
   /**
    * Initializes the payload reader.
    *
@@ -185,10 +214,10 @@ void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
 
   /**
    * Notifies the reader that a seek has occurred.
-   * <p>
-   * Following a call to this method, the data passed to the next invocation of
-   * {@link #consume(ParsableByteArray, boolean)} will not be a continuation of the data that was
-   * previously passed. Hence the reader should reset any internal state.
+   *
+   * <p>Following a call to this method, the data passed to the next invocation of {@link #consume}
+   * will not be a continuation of the data that was previously passed. Hence the reader should
+   * reset any internal state.
    */
   void seek();
 
@@ -196,9 +225,8 @@ void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
    * Consumes the payload of a TS packet.
    *
    * @param data The TS packet. The position will be set to the start of the payload.
-   * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
+   * @param flags See {@link Flags}.
    * @throws ParserException If the payload could not be parsed.
    */
-  void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) throws ParserException;
-
+  void consume(ParsableByteArray data, @Flags int flags) throws ParserException;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsUtil.java
new file mode 100644
index 0000000000..2a7a0d25ab
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsUtil.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+/** Utilities method for extracting MPEG-TS streams. */
+public final class TsUtil {
+  /**
+   * Returns the position of the first TS_SYNC_BYTE within the range [startPosition, limitPosition)
+   * from the provided data array, or returns limitPosition if sync byte could not be found.
+   */
+  public static int findSyncBytePosition(byte[] data, int startPosition, int limitPosition) {
+    int position = startPosition;
+    while (position < limitPosition && data[position] != TsExtractor.TS_SYNC_BYTE) {
+      position++;
+    }
+    return position;
+  }
+
+  /**
+   * Returns the PCR value read from a given TS packet.
+   *
+   * @param packetBuffer The buffer that holds the packet.
+   * @param startOfPacket The starting position of the packet in the buffer.
+   * @param pcrPid The PID for valid packets that contain PCR values.
+   * @return The PCR value read from the packet, if its PID is equal to {@code pcrPid} and it
+   *     contains a valid PCR value. Returns {@link C#TIME_UNSET} otherwise.
+   */
+  public static long readPcrFromPacket(
+      ParsableByteArray packetBuffer, int startOfPacket, int pcrPid) {
+    packetBuffer.setPosition(startOfPacket);
+    if (packetBuffer.bytesLeft() < 5) {
+      // Header = 4 bytes, adaptationFieldLength = 1 byte.
+      return C.TIME_UNSET;
+    }
+    // Note: See ISO/IEC 13818-1, section 2.4.3.2 for details of the header format.
+    int tsPacketHeader = packetBuffer.readInt();
+    if ((tsPacketHeader & 0x800000) != 0) {
+      // transport_error_indicator != 0 means there are uncorrectable errors in this packet.
+      return C.TIME_UNSET;
+    }
+    int pid = (tsPacketHeader & 0x1FFF00) >> 8;
+    if (pid != pcrPid) {
+      return C.TIME_UNSET;
+    }
+    boolean adaptationFieldExists = (tsPacketHeader & 0x20) != 0;
+    if (!adaptationFieldExists) {
+      return C.TIME_UNSET;
+    }
+
+    int adaptationFieldLength = packetBuffer.readUnsignedByte();
+    if (adaptationFieldLength >= 7 && packetBuffer.bytesLeft() >= 7) {
+      int flags = packetBuffer.readUnsignedByte();
+      boolean pcrFlagSet = (flags & 0x10) == 0x10;
+      if (pcrFlagSet) {
+        byte[] pcrBytes = new byte[6];
+        packetBuffer.readBytes(pcrBytes, /* offset= */ 0, pcrBytes.length);
+        return readPcrValueFromPcrBytes(pcrBytes);
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+  /**
+   * Returns the value of PCR base - first 33 bits in big endian order from the PCR bytes.
+   *
+   * <p>We ignore PCR Ext, because it's too small to have any significance.
+   */
+  private static long readPcrValueFromPcrBytes(byte[] pcrBytes) {
+    return (pcrBytes[0] & 0xFFL) << 25
+        | (pcrBytes[1] & 0xFFL) << 17
+        | (pcrBytes[2] & 0xFFL) << 9
+        | (pcrBytes[3] & 0xFFL) << 1
+        | (pcrBytes[4] & 0xFFL) >> 7;
+  }
+
+  private TsUtil() {
+    // Prevent instantiation.
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java
new file mode 100644
index 0000000000..724eba1d9a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.List;
+
+/** Consumes user data, outputting contained CEA-608/708 messages to a {@link TrackOutput}. */
+/* package */ final class UserDataReader {
+
+  private static final int USER_DATA_START_CODE = 0x0001B2;
+
+  private final List<Format> closedCaptionFormats;
+  private final TrackOutput[] outputs;
+
+  public UserDataReader(List<Format> closedCaptionFormats) {
+    this.closedCaptionFormats = closedCaptionFormats;
+    outputs = new TrackOutput[closedCaptionFormats.size()];
+  }
+
+  public void createTracks(
+      ExtractorOutput extractorOutput, TsPayloadReader.TrackIdGenerator idGenerator) {
+    for (int i = 0; i < outputs.length; i++) {
+      idGenerator.generateNewId();
+      TrackOutput output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_TEXT);
+      Format channelFormat = closedCaptionFormats.get(i);
+      String channelMimeType = channelFormat.sampleMimeType;
+      Assertions.checkArgument(
+          MimeTypes.APPLICATION_CEA608.equals(channelMimeType)
+              || MimeTypes.APPLICATION_CEA708.equals(channelMimeType),
+          "Invalid closed caption mime type provided: " + channelMimeType);
+      output.format(
+          Format.createTextSampleFormat(
+              idGenerator.getFormatId(),
+              channelMimeType,
+              /* codecs= */ null,
+              /* bitrate= */ Format.NO_VALUE,
+              channelFormat.selectionFlags,
+              channelFormat.language,
+              channelFormat.accessibilityChannel,
+              /* drmInitData= */ null,
+              Format.OFFSET_SAMPLE_RELATIVE,
+              channelFormat.initializationData));
+      outputs[i] = output;
+    }
+  }
+
+  public void consume(long pesTimeUs, ParsableByteArray userDataPayload) {
+    if (userDataPayload.bytesLeft() < 9) {
+      return;
+    }
+    int userDataStartCode = userDataPayload.readInt();
+    int userDataIdentifier = userDataPayload.readInt();
+    int userDataTypeCode = userDataPayload.readUnsignedByte();
+    if (userDataStartCode == USER_DATA_START_CODE
+        && userDataIdentifier == CeaUtil.USER_DATA_IDENTIFIER_GA94
+        && userDataTypeCode == CeaUtil.USER_DATA_TYPE_CODE_MPEG_CC) {
+      CeaUtil.consumeCcData(pesTimeUs, userDataPayload, outputs);
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
index 4f2be71a69..68d252e318 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
 
@@ -32,17 +33,8 @@
  */
 public final class WavExtractor implements Extractor {
 
-  /**
-   * Factory for {@link WavExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new WavExtractor()};
-    }
-
-  };
+  /** Factory for {@link WavExtractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new WavExtractor()};
 
   /** Arbitrary maximum input size of 32KB, which is ~170ms of 16-bit stereo PCM audio at 48KHz. */
   private static final int MAX_INPUT_SIZE = 32 * 1024;
@@ -97,7 +89,16 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       extractorOutput.seekMap(wavHeader);
     }
 
-    int bytesAppended = trackOutput.sampleData(input, MAX_INPUT_SIZE - pendingBytes, true);
+    long dataLimit = wavHeader.getDataLimit();
+    Assertions.checkState(dataLimit != C.POSITION_UNSET);
+
+    long bytesLeft = dataLimit - input.getPosition();
+    if (bytesLeft <= 0) {
+      return Extractor.RESULT_END_OF_INPUT;
+    }
+
+    int maxBytesToRead = (int) Math.min(MAX_INPUT_SIZE - pendingBytes, bytesLeft);
+    int bytesAppended = trackOutput.sampleData(input, maxBytesToRead, true);
     if (bytesAppended != RESULT_END_OF_INPUT) {
       pendingBytes += bytesAppended;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
index 33db6c1e6c..c60117be60 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
@@ -52,7 +52,7 @@ public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, i
     this.encoding = encoding;
   }
 
-  // Setting bounds.
+  // Data bounds.
 
   /**
    * Sets the data start position and size in bytes of sample data in this WAV.
@@ -65,6 +65,11 @@ public void setDataBounds(long dataStartPosition, long dataSize) {
     this.dataSize = dataSize;
   }
 
+  /** Returns the data limit, or {@link C#POSITION_UNSET} if the data bounds have not been set. */
+  public long getDataLimit() {
+    return hasDataBounds() ? (dataStartPosition + dataSize) : C.POSITION_UNSET;
+  }
+
   /** Returns whether the data start position and size have been set. */
   public boolean hasDataBounds() {
     return dataStartPosition != 0 && dataSize != 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
index ca745591f5..c7b7a40ead 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
@@ -15,11 +15,12 @@
  */
 package com.google.android.exoplayer2.extractor.wav;
 
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.audio.WavUtil;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -29,13 +30,6 @@
 
   private static final String TAG = "WavHeaderReader";
 
-  /** Integer PCM audio data. */
-  private static final int TYPE_PCM = 0x0001;
-  /** Float PCM audio data. */
-  private static final int TYPE_FLOAT = 0x0003;
-  /** Extended WAVE format. */
-  private static final int TYPE_WAVE_FORMAT_EXTENSIBLE = 0xFFFE;
-
   /**
    * Peeks and returns a {@code WavHeader}.
    *
@@ -54,21 +48,21 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
 
     // Attempt to read the RIFF chunk.
     ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
-    if (chunkHeader.id != Util.getIntegerCodeForString("RIFF")) {
+    if (chunkHeader.id != WavUtil.RIFF_FOURCC) {
       return null;
     }
 
     input.peekFully(scratch.data, 0, 4);
     scratch.setPosition(0);
     int riffFormat = scratch.readInt();
-    if (riffFormat != Util.getIntegerCodeForString("WAVE")) {
+    if (riffFormat != WavUtil.WAVE_FOURCC) {
       Log.e(TAG, "Unsupported RIFF format: " + riffFormat);
       return null;
     }
 
     // Skip chunks until we find the format chunk.
     chunkHeader = ChunkHeader.peek(input, scratch);
-    while (chunkHeader.id != Util.getIntegerCodeForString("fmt ")) {
+    while (chunkHeader.id != WavUtil.FMT_FOURCC) {
       input.advancePeekPosition((int) chunkHeader.size);
       chunkHeader = ChunkHeader.peek(input, scratch);
     }
@@ -89,22 +83,9 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
           + blockAlignment);
     }
 
-    @C.PcmEncoding int encoding;
-    switch (type) {
-      case TYPE_PCM:
-      case TYPE_WAVE_FORMAT_EXTENSIBLE:
-        encoding = Util.getPcmEncoding(bitsPerSample);
-        break;
-      case TYPE_FLOAT:
-        encoding = bitsPerSample == 32 ? C.ENCODING_PCM_FLOAT : C.ENCODING_INVALID;
-        break;
-      default:
-        Log.e(TAG, "Unsupported WAV format type: " + type);
-        return null;
-    }
-
+    @C.PcmEncoding int encoding = WavUtil.getEncodingForType(type, bitsPerSample);
     if (encoding == C.ENCODING_INVALID) {
-      Log.e(TAG, "Unsupported WAV bit depth " + bitsPerSample + " for type " + type);
+      Log.e(TAG, "Unsupported WAV format: " + bitsPerSample + " bit/sample, type " + type);
       return null;
     }
 
@@ -116,13 +97,15 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
   }
 
   /**
-   * Skips to the data in the given WAV input stream and returns its data size. After calling, the
-   * input stream's position will point to the start of sample data in the WAV.
-   * <p>
-   * If an exception is thrown, the input position will be left pointing to a chunk header.
+   * Skips to the data in the given WAV input stream. After calling, the input stream's position
+   * will point to the start of sample data in the WAV, and the data bounds of the provided {@link
+   * WavHeader} will have been set.
+   *
+   * <p>If an exception is thrown, the input position will be left pointing to a chunk header and
+   * the bounds of the provided {@link WavHeader} will not have been set.
    *
-   * @param input Input stream to skip to the data chunk in. Its peek position must be pointing to
-   *     a valid chunk header.
+   * @param input Input stream to skip to the data chunk in. Its peek position must be pointing to a
+   *     valid chunk header.
    * @param wavHeader WAV header to populate with data bounds.
    * @throws ParserException If an error occurs parsing chunks.
    * @throws IOException If reading from the input fails.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index d822916bce..8cec75a66d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -23,17 +23,16 @@
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCodecInfo.VideoCapabilities;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 
-/**
- * Information about a {@link MediaCodec} for a given mime type.
- */
+/** Information about a {@link MediaCodec} for a given mime type. */
 @TargetApi(16)
+@SuppressWarnings("InlinedApi")
 public final class MediaCodecInfo {
 
   public static final String TAG = "MediaCodecInfo";
@@ -88,6 +87,8 @@
   /** Whether this instance describes a passthrough codec. */
   public final boolean passthrough;
 
+  private final boolean isVideo;
+
   /**
    * Creates an instance representing an audio passthrough decoder.
    *
@@ -157,6 +158,12 @@ private MediaCodecInfo(
     adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
     tunneling = capabilities != null && isTunneling(capabilities);
     secure = forceSecure || (capabilities != null && isSecure(capabilities));
+    isVideo = MimeTypes.isVideo(mimeType);
+  }
+
+  @Override
+  public String toString() {
+    return name;
   }
 
   /**
@@ -182,6 +189,41 @@ public int getMaxSupportedInstances() {
         : getMaxSupportedInstancesV23(capabilities);
   }
 
+  /**
+   * Returns whether the decoder may support decoding the given {@code format}.
+   *
+   * @param format The input media format.
+   * @return Whether the decoder may support decoding the given {@code format}.
+   * @throws MediaCodecUtil.DecoderQueryException Thrown if an error occurs while querying decoders.
+   */
+  public boolean isFormatSupported(Format format) throws MediaCodecUtil.DecoderQueryException {
+    if (!isCodecSupported(format.codecs)) {
+      return false;
+    }
+
+    if (isVideo) {
+      if (format.width <= 0 || format.height <= 0) {
+        return true;
+      }
+      if (Util.SDK_INT >= 21) {
+        return isVideoSizeAndRateSupportedV21(format.width, format.height, format.frameRate);
+      } else {
+        boolean isFormatSupported =
+            format.width * format.height <= MediaCodecUtil.maxH264DecodableFrameSize();
+        if (!isFormatSupported) {
+          logNoSupport("legacyFrameSize, " + format.width + "x" + format.height);
+        }
+        return isFormatSupported;
+      }
+    } else { // Audio
+      return Util.SDK_INT < 21
+          || ((format.sampleRate == Format.NO_VALUE
+                  || isAudioSampleRateSupportedV21(format.sampleRate))
+              && (format.channelCount == Format.NO_VALUE
+                  || isAudioChannelCountSupportedV21(format.channelCount)));
+    }
+  }
+
   /**
    * Whether the decoder supports the given {@code codec}. If there is insufficient information to
    * decide, returns true.
@@ -206,9 +248,15 @@ public boolean isCodecSupported(String codec) {
       // If we don't know any better, we assume that the profile and level are supported.
       return true;
     }
+    int profile = codecProfileAndLevel.first;
+    int level = codecProfileAndLevel.second;
+    if (!isVideo && profile != CodecProfileLevel.AACObjectXHE) {
+      // Some devices/builds under-report audio capabilities, so assume support except for xHE-AAC
+      // which is not widely supported. See https://github.com/google/ExoPlayer/issues/5145.
+      return true;
+    }
     for (CodecProfileLevel capabilities : getProfileLevels()) {
-      if (capabilities.profile == codecProfileAndLevel.first
-          && capabilities.level >= codecProfileAndLevel.second) {
+      if (capabilities.profile == profile && capabilities.level >= level) {
         return true;
       }
     }
@@ -216,6 +264,68 @@ public boolean isCodecSupported(String codec) {
     return false;
   }
 
+  /**
+   * Returns whether it may be possible to adapt to playing a different format when the codec is
+   * configured to play media in the specified {@code format}. For adaptation to succeed, the codec
+   * must also be configured with appropriate maximum values and {@link
+   * #isSeamlessAdaptationSupported(Format, Format, boolean)} must return {@code true} for the
+   * old/new formats.
+   *
+   * @param format The format of media for which the decoder will be configured.
+   * @return Whether adaptation may be possible
+   */
+  public boolean isSeamlessAdaptationSupported(Format format) {
+    if (isVideo) {
+      return adaptive;
+    } else {
+      Pair<Integer, Integer> codecProfileLevel =
+          MediaCodecUtil.getCodecProfileAndLevel(format.codecs);
+      return codecProfileLevel != null && codecProfileLevel.first == CodecProfileLevel.AACObjectXHE;
+    }
+  }
+
+  /**
+   * Returns whether it is possible to adapt the decoder seamlessly from {@code oldFormat} to {@code
+   * newFormat}. If {@code newFormat} may not be completely populated, pass {@code false} for {@code
+   * isNewFormatComplete}.
+   *
+   * @param oldFormat The format being decoded.
+   * @param newFormat The new format.
+   * @param isNewFormatComplete Whether {@code newFormat} is populated with format-specific
+   *     metadata.
+   * @return Whether it is possible to adapt the decoder seamlessly.
+   */
+  public boolean isSeamlessAdaptationSupported(
+      Format oldFormat, Format newFormat, boolean isNewFormatComplete) {
+    if (isVideo) {
+      return oldFormat.sampleMimeType.equals(newFormat.sampleMimeType)
+          && oldFormat.rotationDegrees == newFormat.rotationDegrees
+          && (adaptive
+              || (oldFormat.width == newFormat.width && oldFormat.height == newFormat.height))
+          && ((!isNewFormatComplete && newFormat.colorInfo == null)
+              || Util.areEqual(oldFormat.colorInfo, newFormat.colorInfo));
+    } else {
+      if (!MimeTypes.AUDIO_AAC.equals(mimeType)
+          || !oldFormat.sampleMimeType.equals(newFormat.sampleMimeType)
+          || oldFormat.channelCount != newFormat.channelCount
+          || oldFormat.sampleRate != newFormat.sampleRate) {
+        return false;
+      }
+      // Check the codec profile levels support adaptation.
+      Pair<Integer, Integer> oldCodecProfileLevel =
+          MediaCodecUtil.getCodecProfileAndLevel(oldFormat.codecs);
+      Pair<Integer, Integer> newCodecProfileLevel =
+          MediaCodecUtil.getCodecProfileAndLevel(newFormat.codecs);
+      if (oldCodecProfileLevel == null || newCodecProfileLevel == null) {
+        return false;
+      }
+      int oldProfile = oldCodecProfileLevel.first;
+      int newProfile = newCodecProfileLevel.first;
+      return oldProfile == CodecProfileLevel.AACObjectXHE
+          && newProfile == CodecProfileLevel.AACObjectXHE;
+    }
+  }
+
   /**
    * Whether the decoder supports video with a given width, height and frame rate.
    * <p>
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 03a0b66661..6a813332e3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -21,11 +21,12 @@
 import android.media.MediaCodec.CryptoException;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
+import android.os.Bundle;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.CheckResult;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -40,12 +41,16 @@
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.NalUnitUtil;
+import com.google.android.exoplayer2.util.TimedValueQueue;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -84,22 +89,64 @@
      */
     public final String diagnosticInfo;
 
+    /**
+     * If the decoder failed to initialize and another decoder being used as a fallback also failed
+     * to initialize, the {@link DecoderInitializationException} for the fallback decoder. Null if
+     * there was no fallback decoder or no suitable decoders were found.
+     */
+    public final @Nullable DecoderInitializationException fallbackDecoderInitializationException;
+
     public DecoderInitializationException(Format format, Throwable cause,
         boolean secureDecoderRequired, int errorCode) {
-      super("Decoder init failed: [" + errorCode + "], " + format, cause);
-      this.mimeType = format.sampleMimeType;
-      this.secureDecoderRequired = secureDecoderRequired;
-      this.decoderName = null;
-      this.diagnosticInfo = buildCustomDiagnosticInfo(errorCode);
+      this(
+          "Decoder init failed: [" + errorCode + "], " + format,
+          cause,
+          format.sampleMimeType,
+          secureDecoderRequired,
+          /* decoderName= */ null,
+          buildCustomDiagnosticInfo(errorCode),
+          /* fallbackDecoderInitializationException= */ null);
     }
 
     public DecoderInitializationException(Format format, Throwable cause,
         boolean secureDecoderRequired, String decoderName) {
-      super("Decoder init failed: " + decoderName + ", " + format, cause);
-      this.mimeType = format.sampleMimeType;
+      this(
+          "Decoder init failed: " + decoderName + ", " + format,
+          cause,
+          format.sampleMimeType,
+          secureDecoderRequired,
+          decoderName,
+          Util.SDK_INT >= 21 ? getDiagnosticInfoV21(cause) : null,
+          /* fallbackDecoderInitializationException= */ null);
+    }
+
+    private DecoderInitializationException(
+        String message,
+        Throwable cause,
+        String mimeType,
+        boolean secureDecoderRequired,
+        @Nullable String decoderName,
+        @Nullable String diagnosticInfo,
+        @Nullable DecoderInitializationException fallbackDecoderInitializationException) {
+      super(message, cause);
+      this.mimeType = mimeType;
       this.secureDecoderRequired = secureDecoderRequired;
       this.decoderName = decoderName;
-      this.diagnosticInfo = Util.SDK_INT >= 21 ? getDiagnosticInfoV21(cause) : null;
+      this.diagnosticInfo = diagnosticInfo;
+      this.fallbackDecoderInitializationException = fallbackDecoderInitializationException;
+    }
+
+    @CheckResult
+    private DecoderInitializationException copyWithFallbackException(
+        DecoderInitializationException fallbackException) {
+      return new DecoderInitializationException(
+          getMessage(),
+          getCause(),
+          mimeType,
+          secureDecoderRequired,
+          decoderName,
+          diagnosticInfo,
+          fallbackException);
     }
 
     @TargetApi(21)
@@ -117,6 +164,9 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
 
   }
 
+  /** Indicates no codec operating rate should be set. */
+  protected static final float CODEC_OPERATING_RATE_UNSET = -1;
+
   private static final String TAG = "MediaCodecRenderer";
 
   /**
@@ -133,6 +183,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    * The possible return values for {@link #canKeepCodec(MediaCodec, MediaCodecInfo, Format,
    * Format)}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     KEEP_CODEC_RESULT_NO,
@@ -150,9 +201,13 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   protected static final int KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION = 3;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({RECONFIGURATION_STATE_NONE, RECONFIGURATION_STATE_WRITE_PENDING,
-      RECONFIGURATION_STATE_QUEUE_PENDING})
+  @IntDef({
+    RECONFIGURATION_STATE_NONE,
+    RECONFIGURATION_STATE_WRITE_PENDING,
+    RECONFIGURATION_STATE_QUEUE_PENDING
+  })
   private @interface ReconfigurationState {}
   /**
    * There is no pending adaptive reconfiguration work.
@@ -168,9 +223,13 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int RECONFIGURATION_STATE_QUEUE_PENDING = 2;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReinitializationState {}
   /**
    * The codec does not need to be re-initialized.
@@ -189,9 +248,13 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({ADAPTATION_WORKAROUND_MODE_NEVER, ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION,
-      ADAPTATION_WORKAROUND_MODE_ALWAYS})
+  @IntDef({
+    ADAPTATION_WORKAROUND_MODE_NEVER,
+    ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION,
+    ADAPTATION_WORKAROUND_MODE_ALWAYS
+  })
   private @interface AdaptationWorkaroundMode {}
   /**
    * The adaptation workaround is never used.
@@ -220,26 +283,36 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   @Nullable
   private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
+  private final float assumedMinimumCodecOperatingRate;
   private final DecoderInputBuffer buffer;
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final FormatHolder formatHolder;
+  private final TimedValueQueue<Format> formatQueue;
   private final List<Long> decodeOnlyPresentationTimestamps;
   private final MediaCodec.BufferInfo outputBufferInfo;
 
   private Format format;
+  private Format pendingFormat;
+  private Format outputFormat;
   private DrmSession<FrameworkMediaCrypto> drmSession;
   private DrmSession<FrameworkMediaCrypto> pendingDrmSession;
   private MediaCodec codec;
-  private MediaCodecInfo codecInfo;
+  private float rendererOperatingRate;
+  private float codecOperatingRate;
+  private boolean codecConfiguredWithOperatingRate;
+  private @Nullable ArrayDeque<MediaCodecInfo> availableCodecInfos;
+  private @Nullable DecoderInitializationException preferredDecoderInitializationException;
+  private @Nullable MediaCodecInfo codecInfo;
   private @AdaptationWorkaroundMode int codecAdaptationWorkaroundMode;
+  private boolean codecNeedsReconfigureWorkaround;
   private boolean codecNeedsDiscardToSpsWorkaround;
   private boolean codecNeedsFlushWorkaround;
-  private boolean codecNeedsEosPropagationWorkaround;
   private boolean codecNeedsEosFlushWorkaround;
   private boolean codecNeedsEosOutputExceptionWorkaround;
   private boolean codecNeedsMonoChannelCountWorkaround;
   private boolean codecNeedsAdaptationWorkaroundBuffer;
   private boolean shouldSkipAdaptationWorkaroundOutputBuffer;
+  private boolean codecNeedsEosPropagation;
   private ByteBuffer[] inputBuffers;
   private ByteBuffer[] outputBuffers;
   private long codecHotswapDeadlineMs;
@@ -271,22 +344,32 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param assumedMinimumCodecOperatingRate A codec operating rate that all codecs instantiated by
+   *     this renderer are assumed to meet implicitly (i.e. without the operating rate being set
+   *     explicitly using {@link MediaFormat#KEY_OPERATING_RATE}).
    */
-  public MediaCodecRenderer(int trackType, MediaCodecSelector mediaCodecSelector,
+  public MediaCodecRenderer(
+      int trackType,
+      MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys) {
+      boolean playClearSamplesWithoutKeys,
+      float assumedMinimumCodecOperatingRate) {
     super(trackType);
     Assertions.checkState(Util.SDK_INT >= 16);
     this.mediaCodecSelector = Assertions.checkNotNull(mediaCodecSelector);
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    this.assumedMinimumCodecOperatingRate = assumedMinimumCodecOperatingRate;
     buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     formatHolder = new FormatHolder();
+    formatQueue = new TimedValueQueue<>();
     decodeOnlyPresentationTimestamps = new ArrayList<>();
     outputBufferInfo = new MediaCodec.BufferInfo();
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     codecReinitializationState = REINITIALIZATION_STATE_NONE;
+    codecOperatingRate = CODEC_OPERATING_RATE_UNSET;
+    rendererOperatingRate = 1f;
   }
 
   @Override
@@ -318,18 +401,18 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
       throws DecoderQueryException;
 
   /**
-   * Returns a {@link MediaCodecInfo} for a given format.
+   * Returns a list of decoders that can decode media in the specified format, in priority order.
    *
    * @param mediaCodecSelector The decoder selector.
    * @param format The format for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
-   * @return A {@link MediaCodecInfo} describing the decoder to instantiate, or null if no
-   *     suitable decoder exists.
+   * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
-      Format format, boolean requiresSecureDecoder) throws DecoderQueryException {
-    return mediaCodecSelector.getDecoderInfo(format.sampleMimeType, requiresSecureDecoder);
+  protected List<MediaCodecInfo> getDecoderInfos(
+      MediaCodecSelector mediaCodecSelector, Format format, boolean requiresSecureDecoder)
+      throws DecoderQueryException {
+    return mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecoder);
   }
 
   /**
@@ -339,10 +422,17 @@ protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
    * @param codec The {@link MediaCodec} to configure.
    * @param format The format for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
+   * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
+   *     no codec operating rate should be set.
    * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  protected abstract void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
-      MediaCrypto crypto) throws DecoderQueryException;
+  protected abstract void configureCodec(
+      MediaCodecInfo codecInfo,
+      MediaCodec codec,
+      Format format,
+      MediaCrypto crypto,
+      float codecOperatingRate)
+      throws DecoderQueryException;
 
   protected final void maybeInitCodec() throws ExoPlaybackException {
     if (codec != null || format == null) {
@@ -369,87 +459,77 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
         wrappedMediaCrypto = mediaCrypto.getWrappedMediaCrypto();
         drmSessionRequiresSecureDecoder = mediaCrypto.requiresSecureDecoderComponent(mimeType);
       }
-    }
-
-    if (codecInfo == null) {
-      try {
-        codecInfo = getDecoderInfo(mediaCodecSelector, format, drmSessionRequiresSecureDecoder);
-        if (codecInfo == null && drmSessionRequiresSecureDecoder) {
-          // The drm session indicates that a secure decoder is required, but the device does not
-          // have one. Assuming that supportsFormat indicated support for the media being played, we
-          // know that it does not require a secure output path. Most CDM implementations allow
-          // playback to proceed with a non-secure decoder in this case, so we try our luck.
-          codecInfo = getDecoderInfo(mediaCodecSelector, format, false);
-          if (codecInfo != null) {
-            Log.w(TAG, "Drm session requires secure decoder for " + mimeType + ", but "
-                + "no secure decoder available. Trying to proceed with " + codecInfo.name + ".");
-          }
+      if (deviceNeedsDrmKeysToConfigureCodecWorkaround()) {
+        @DrmSession.State int drmSessionState = drmSession.getState();
+        if (drmSessionState == DrmSession.STATE_ERROR) {
+          throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+        } else if (drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS) {
+          // Wait for keys.
+          return;
         }
-      } catch (DecoderQueryException e) {
-        throwDecoderInitError(new DecoderInitializationException(format, e,
-            drmSessionRequiresSecureDecoder, DecoderInitializationException.DECODER_QUERY_ERROR));
-      }
-
-      if (codecInfo == null) {
-        throwDecoderInitError(new DecoderInitializationException(format, null,
-            drmSessionRequiresSecureDecoder,
-            DecoderInitializationException.NO_SUITABLE_DECODER_ERROR));
       }
     }
 
-    if (!shouldInitCodec(codecInfo)) {
-      return;
+    try {
+      if (!initCodecWithFallback(wrappedMediaCrypto, drmSessionRequiresSecureDecoder)) {
+        // We can't initialize a codec yet.
+        return;
+      }
+    } catch (DecoderInitializationException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
 
     String codecName = codecInfo.name;
     codecAdaptationWorkaroundMode = codecAdaptationWorkaroundMode(codecName);
+    codecNeedsReconfigureWorkaround = codecNeedsReconfigureWorkaround(codecName);
     codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, format);
     codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
-    codecNeedsEosPropagationWorkaround = codecNeedsEosPropagationWorkaround(codecName);
     codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
     codecNeedsEosOutputExceptionWorkaround = codecNeedsEosOutputExceptionWorkaround(codecName);
     codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
-    try {
-      long codecInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("createCodec:" + codecName);
-      codec = MediaCodec.createByCodecName(codecName);
-      TraceUtil.endSection();
-      TraceUtil.beginSection("configureCodec");
-      configureCodec(codecInfo, codec, format, wrappedMediaCrypto);
-      TraceUtil.endSection();
-      TraceUtil.beginSection("startCodec");
-      codec.start();
-      TraceUtil.endSection();
-      long codecInitializedTimestamp = SystemClock.elapsedRealtime();
-      onCodecInitialized(codecName, codecInitializedTimestamp,
-          codecInitializedTimestamp - codecInitializingTimestamp);
-      getCodecBuffers();
-    } catch (Exception e) {
-      throwDecoderInitError(new DecoderInitializationException(format, e,
-          drmSessionRequiresSecureDecoder, codecName));
-    }
-    codecHotswapDeadlineMs = getState() == STATE_STARTED
-        ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS) : C.TIME_UNSET;
+    codecNeedsEosPropagation =
+        codecNeedsEosPropagationWorkaround(codecInfo) || getCodecNeedsEosPropagation();
+    codecHotswapDeadlineMs =
+        getState() == STATE_STARTED
+            ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS)
+            : C.TIME_UNSET;
     resetInputBuffer();
     resetOutputBuffer();
     waitingForFirstSyncFrame = true;
     decoderCounters.decoderInitCount++;
   }
 
-  private void throwDecoderInitError(DecoderInitializationException e)
-      throws ExoPlaybackException {
-    throw ExoPlaybackException.createForRenderer(e, getIndex());
-  }
-
   protected boolean shouldInitCodec(MediaCodecInfo codecInfo) {
     return true;
   }
 
+  /**
+   * Returns whether the codec needs the renderer to propagate the end-of-stream signal directly,
+   * rather than by using an end-of-stream buffer queued to the codec.
+   */
+  protected boolean getCodecNeedsEosPropagation() {
+    return false;
+  }
+
+  /**
+   * Polls the pending output format queue for a given buffer timestamp. If a format is present, it
+   * is removed and returned. Otherwise returns {@code null}. Subclasses should only call this
+   * method if they are taking over responsibility for output format propagation (e.g., when using
+   * video tunneling).
+   */
+  protected final @Nullable Format updateOutputFormatForTime(long presentationTimeUs) {
+    Format format = formatQueue.pollFloor(presentationTimeUs);
+    if (format != null) {
+      outputFormat = format;
+    }
+    return format;
+  }
+
   protected final MediaCodec getCodec() {
     return codec;
   }
 
-  protected final MediaCodecInfo getCodecInfo() {
+  protected final @Nullable MediaCodecInfo getCodecInfo() {
     return codecInfo;
   }
 
@@ -465,11 +545,19 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
     if (codec != null) {
       flushCodec();
     }
+    formatQueue.clear();
+  }
+
+  @Override
+  public final void setOperatingRate(float operatingRate) throws ExoPlaybackException {
+    rendererOperatingRate = operatingRate;
+    updateCodecOperatingRate();
   }
 
   @Override
   protected void onDisabled() {
     format = null;
+    availableCodecInfos = null;
     try {
       releaseCodec();
     } finally {
@@ -504,14 +592,16 @@ protected void releaseCodec() {
     codecNeedsDiscardToSpsWorkaround = false;
     codecNeedsFlushWorkaround = false;
     codecAdaptationWorkaroundMode = ADAPTATION_WORKAROUND_MODE_NEVER;
-    codecNeedsEosPropagationWorkaround = false;
+    codecNeedsReconfigureWorkaround = false;
     codecNeedsEosFlushWorkaround = false;
     codecNeedsMonoChannelCountWorkaround = false;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
+    codecNeedsEosPropagation = false;
     codecReceivedEos = false;
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     codecReinitializationState = REINITIALIZATION_STATE_NONE;
+    codecConfiguredWithOperatingRate = false;
     if (codec != null) {
       decoderCounters.decoderReleaseCount++;
       try {
@@ -622,6 +712,166 @@ protected void flushCodec() throws ExoPlaybackException {
     }
   }
 
+  private boolean initCodecWithFallback(MediaCrypto crypto, boolean drmSessionRequiresSecureDecoder)
+      throws DecoderInitializationException {
+    if (availableCodecInfos == null) {
+      try {
+        availableCodecInfos =
+            new ArrayDeque<>(getAvailableCodecInfos(drmSessionRequiresSecureDecoder));
+        preferredDecoderInitializationException = null;
+      } catch (DecoderQueryException e) {
+        throw new DecoderInitializationException(
+            format,
+            e,
+            drmSessionRequiresSecureDecoder,
+            DecoderInitializationException.DECODER_QUERY_ERROR);
+      }
+    }
+
+    if (availableCodecInfos.isEmpty()) {
+      throw new DecoderInitializationException(
+          format,
+          /* cause= */ null,
+          drmSessionRequiresSecureDecoder,
+          DecoderInitializationException.NO_SUITABLE_DECODER_ERROR);
+    }
+
+    while (true) {
+      MediaCodecInfo codecInfo = availableCodecInfos.peekFirst();
+      if (!shouldInitCodec(codecInfo)) {
+        return false;
+      }
+      try {
+        initCodec(codecInfo, crypto);
+        return true;
+      } catch (Exception e) {
+        Log.w(TAG, "Failed to initialize decoder: " + codecInfo, e);
+        // This codec failed to initialize, so fall back to the next codec in the list (if any). We
+        // won't try to use this codec again unless there's a format change or the renderer is
+        // disabled and re-enabled.
+        availableCodecInfos.removeFirst();
+        DecoderInitializationException exception =
+            new DecoderInitializationException(
+                format, e, drmSessionRequiresSecureDecoder, codecInfo.name);
+        if (preferredDecoderInitializationException == null) {
+          preferredDecoderInitializationException = exception;
+        } else {
+          preferredDecoderInitializationException =
+              preferredDecoderInitializationException.copyWithFallbackException(exception);
+        }
+        if (availableCodecInfos.isEmpty()) {
+          throw preferredDecoderInitializationException;
+        }
+      }
+    }
+  }
+
+  private List<MediaCodecInfo> getAvailableCodecInfos(boolean drmSessionRequiresSecureDecoder)
+      throws DecoderQueryException {
+    List<MediaCodecInfo> codecInfos =
+        getDecoderInfos(mediaCodecSelector, format, drmSessionRequiresSecureDecoder);
+    if (codecInfos.isEmpty() && drmSessionRequiresSecureDecoder) {
+      // The drm session indicates that a secure decoder is required, but the device does not
+      // have one. Assuming that supportsFormat indicated support for the media being played, we
+      // know that it does not require a secure output path. Most CDM implementations allow
+      // playback to proceed with a non-secure decoder in this case, so we try our luck.
+      codecInfos = getDecoderInfos(mediaCodecSelector, format, /* requiresSecureDecoder= */ false);
+      if (!codecInfos.isEmpty()) {
+        Log.w(
+            TAG,
+            "Drm session requires secure decoder for "
+                + format.sampleMimeType
+                + ", but no secure decoder available. Trying to proceed with "
+                + codecInfos
+                + ".");
+      }
+    }
+    return codecInfos;
+  }
+
+  private void initCodec(MediaCodecInfo codecInfo, MediaCrypto crypto) throws Exception {
+    long codecInitializingTimestamp;
+    long codecInitializedTimestamp;
+    MediaCodec codec = null;
+    String name = codecInfo.name;
+    updateCodecOperatingRate();
+    boolean configureWithOperatingRate = codecOperatingRate > assumedMinimumCodecOperatingRate;
+    try {
+      codecInitializingTimestamp = SystemClock.elapsedRealtime();
+      TraceUtil.beginSection("createCodec:" + name);
+      codec = MediaCodec.createByCodecName(name);
+      TraceUtil.endSection();
+      TraceUtil.beginSection("configureCodec");
+      configureCodec(
+          codecInfo,
+          codec,
+          format,
+          crypto,
+          configureWithOperatingRate ? codecOperatingRate : CODEC_OPERATING_RATE_UNSET);
+      codecConfiguredWithOperatingRate = configureWithOperatingRate;
+      TraceUtil.endSection();
+      TraceUtil.beginSection("startCodec");
+      codec.start();
+      TraceUtil.endSection();
+      codecInitializedTimestamp = SystemClock.elapsedRealtime();
+      getCodecBuffers(codec);
+    } catch (Exception e) {
+      if (codec != null) {
+        resetCodecBuffers();
+        codec.release();
+      }
+      throw e;
+    }
+    this.codec = codec;
+    this.codecInfo = codecInfo;
+    long elapsed = codecInitializedTimestamp - codecInitializingTimestamp;
+    onCodecInitialized(name, codecInitializedTimestamp, elapsed);
+  }
+
+  private void getCodecBuffers(MediaCodec codec) {
+    if (Util.SDK_INT < 21) {
+      inputBuffers = codec.getInputBuffers();
+      outputBuffers = codec.getOutputBuffers();
+    }
+  }
+
+  private void resetCodecBuffers() {
+    if (Util.SDK_INT < 21) {
+      inputBuffers = null;
+      outputBuffers = null;
+    }
+  }
+
+  private ByteBuffer getInputBuffer(int inputIndex) {
+    if (Util.SDK_INT >= 21) {
+      return codec.getInputBuffer(inputIndex);
+    } else {
+      return inputBuffers[inputIndex];
+    }
+  }
+
+  private ByteBuffer getOutputBuffer(int outputIndex) {
+    if (Util.SDK_INT >= 21) {
+      return codec.getOutputBuffer(outputIndex);
+    } else {
+      return outputBuffers[outputIndex];
+    }
+  }
+
+  private boolean hasOutputBuffer() {
+    return outputIndex >= 0;
+  }
+
+  private void resetInputBuffer() {
+    inputIndex = C.INDEX_UNSET;
+    buffer.data = null;
+  }
+
+  private void resetOutputBuffer() {
+    outputIndex = C.INDEX_UNSET;
+    outputBuffer = null;
+  }
+
   /**
    * @return Whether it may be possible to feed more input data.
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
@@ -645,7 +895,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
     if (codecReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
       // We need to re-initialize the codec. Send an end of stream signal to the existing codec so
       // that it outputs any remaining buffers before we release it.
-      if (codecNeedsEosPropagationWorkaround) {
+      if (codecNeedsEosPropagation) {
         // Do nothing.
       } else {
         codecReceivedEos = true;
@@ -713,7 +963,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         return false;
       }
       try {
-        if (codecNeedsEosPropagationWorkaround) {
+        if (codecNeedsEosPropagation) {
           // Do nothing.
         } else {
           codecReceivedEos = true;
@@ -752,6 +1002,10 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       if (buffer.isDecodeOnly()) {
         decodeOnlyPresentationTimestamps.add(presentationTimeUs);
       }
+      if (pendingFormat != null) {
+        formatQueue.add(presentationTimeUs, pendingFormat);
+        pendingFormat = null;
+      }
 
       buffer.flip();
       onQueueInputBuffer(buffer);
@@ -773,66 +1027,6 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
     return true;
   }
 
-  private void getCodecBuffers() {
-    if (Util.SDK_INT < 21) {
-      inputBuffers = codec.getInputBuffers();
-      outputBuffers = codec.getOutputBuffers();
-    }
-  }
-
-  private void resetCodecBuffers() {
-    if (Util.SDK_INT < 21) {
-      inputBuffers = null;
-      outputBuffers = null;
-    }
-  }
-
-  private ByteBuffer getInputBuffer(int inputIndex) {
-    if (Util.SDK_INT >= 21) {
-      return codec.getInputBuffer(inputIndex);
-    } else {
-      return inputBuffers[inputIndex];
-    }
-  }
-
-  private ByteBuffer getOutputBuffer(int outputIndex) {
-    if (Util.SDK_INT >= 21) {
-      return codec.getOutputBuffer(outputIndex);
-    } else {
-      return outputBuffers[outputIndex];
-    }
-  }
-
-  private boolean hasOutputBuffer() {
-    return outputIndex >= 0;
-  }
-
-  private void resetInputBuffer() {
-    inputIndex = C.INDEX_UNSET;
-    buffer.data = null;
-  }
-
-  private void resetOutputBuffer() {
-    outputIndex = C.INDEX_UNSET;
-    outputBuffer = null;
-  }
-
-  private static MediaCodec.CryptoInfo getFrameworkCryptoInfo(DecoderInputBuffer buffer,
-      int adaptiveReconfigurationBytes) {
-    MediaCodec.CryptoInfo cryptoInfo = buffer.cryptoInfo.getFrameworkCryptoInfoV16();
-    if (adaptiveReconfigurationBytes == 0) {
-      return cryptoInfo;
-    }
-    // There must be at least one sub-sample, although numBytesOfClearData is permitted to be
-    // null if it contains no clear data. Instantiate it if needed, and add the reconfiguration
-    // bytes to the clear byte count of the first sub-sample.
-    if (cryptoInfo.numBytesOfClearData == null) {
-      cryptoInfo.numBytesOfClearData = new int[1];
-    }
-    cryptoInfo.numBytesOfClearData[0] += adaptiveReconfigurationBytes;
-    return cryptoInfo;
-  }
-
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
     if (drmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
       return false;
@@ -868,6 +1062,7 @@ protected void onCodecInitialized(String name, long initializedTimestampMs,
   protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
     Format oldFormat = format;
     format = newFormat;
+    pendingFormat = newFormat;
 
     boolean drmInitDataChanged =
         !Util.areEqual(format.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
@@ -896,14 +1091,16 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
           keepingCodec = true;
           break;
         case KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION:
-          keepingCodec = true;
-          codecReconfigured = true;
-          codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
-          codecNeedsAdaptationWorkaroundBuffer =
-              codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_ALWAYS
-                  || (codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
-                      && format.width == oldFormat.width
-                      && format.height == oldFormat.height);
+          if (!codecNeedsReconfigureWorkaround) {
+            keepingCodec = true;
+            codecReconfigured = true;
+            codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+            codecNeedsAdaptationWorkaroundBuffer =
+                codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_ALWAYS
+                    || (codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
+                        && format.width == oldFormat.width
+                        && format.height == oldFormat.height);
+          }
           break;
         default:
           throw new IllegalStateException(); // Never happens.
@@ -911,14 +1108,9 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     }
 
     if (!keepingCodec) {
-      if (codecReceivedBuffers) {
-        // Signal end of stream and wait for any final output buffers before re-initialization.
-        codecReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
-      } else {
-        // There aren't any final output buffers, so perform re-initialization immediately.
-        releaseCodec();
-        maybeInitCodec();
-      }
+      reinitializeCodec();
+    } else {
+      updateCodecOperatingRate();
     }
   }
 
@@ -999,6 +1191,77 @@ protected long getDequeueOutputBufferTimeoutUs() {
     return 0;
   }
 
+  /**
+   * Returns the {@link MediaFormat#KEY_OPERATING_RATE} value for a given renderer operating rate,
+   * current format and set of possible stream formats.
+   *
+   * <p>The default implementation returns {@link #CODEC_OPERATING_RATE_UNSET}.
+   *
+   * @param operatingRate The renderer operating rate.
+   * @param format The format for which the codec is being configured.
+   * @param streamFormats The possible stream formats.
+   * @return The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if no codec operating
+   *     rate should be set.
+   */
+  protected float getCodecOperatingRate(
+      float operatingRate, Format format, Format[] streamFormats) {
+    return CODEC_OPERATING_RATE_UNSET;
+  }
+
+  /**
+   * Updates the codec operating rate, and the codec itself if necessary.
+   *
+   * @throws ExoPlaybackException If an error occurs releasing or initializing a codec.
+   */
+  private void updateCodecOperatingRate() throws ExoPlaybackException {
+    if (format == null || Util.SDK_INT < 23) {
+      return;
+    }
+
+    float codecOperatingRate =
+        getCodecOperatingRate(rendererOperatingRate, format, getStreamFormats());
+    if (this.codecOperatingRate == codecOperatingRate) {
+      return;
+    }
+
+    this.codecOperatingRate = codecOperatingRate;
+    if (codec == null || codecReinitializationState != REINITIALIZATION_STATE_NONE) {
+      // Either no codec, or it's about to be reinitialized anyway.
+    } else if (codecOperatingRate == CODEC_OPERATING_RATE_UNSET
+        && codecConfiguredWithOperatingRate) {
+      // We need to clear the operating rate. The only way to do so is to instantiate a new codec
+      // instance. See [Internal ref: b/71987865].
+      reinitializeCodec();
+    } else if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET
+        && (codecConfiguredWithOperatingRate
+            || codecOperatingRate > assumedMinimumCodecOperatingRate)) {
+      // We need to set the operating rate, either because we've set it previously or because it's
+      // above the assumed minimum rate.
+      Bundle codecParameters = new Bundle();
+      codecParameters.putFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
+      codec.setParameters(codecParameters);
+      codecConfiguredWithOperatingRate = true;
+    }
+  }
+
+  /**
+   * Starts the process of releasing the existing codec and initializing a new one. This may occur
+   * immediately, or be deferred until any final output buffers have been dequeued.
+   *
+   * @throws ExoPlaybackException If an error occurs releasing or initializing a codec.
+   */
+  private void reinitializeCodec() throws ExoPlaybackException {
+    availableCodecInfos = null;
+    if (codecReceivedBuffers) {
+      // Signal end of stream and wait for any final output buffers before re-initialization.
+      codecReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
+    } else {
+      // There aren't any final output buffers, so perform re-initialization immediately.
+      releaseCodec();
+      maybeInitCodec();
+    }
+  }
+
   /**
    * @return Whether it may be possible to drain more output data.
    * @throws ExoPlaybackException If an error occurs draining the output buffer.
@@ -1024,42 +1287,45 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
             codec.dequeueOutputBuffer(outputBufferInfo, getDequeueOutputBufferTimeoutUs());
       }
 
-      if (outputIndex >= 0) {
-        // We've dequeued a buffer.
-        if (shouldSkipAdaptationWorkaroundOutputBuffer) {
-          shouldSkipAdaptationWorkaroundOutputBuffer = false;
-          codec.releaseOutputBuffer(outputIndex, false);
+      if (outputIndex < 0) {
+        if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED /* (-2) */) {
+          processOutputFormat();
+          return true;
+        } else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED /* (-3) */) {
+          processOutputBuffersChanged();
           return true;
-        } else if (outputBufferInfo.size == 0
-            && (outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
-          // The dequeued buffer indicates the end of the stream. Process it immediately.
-          processEndOfStream();
-          return false;
-        } else {
-          this.outputIndex = outputIndex;
-          outputBuffer = getOutputBuffer(outputIndex);
-          // The dequeued buffer is a media buffer. Do some initial setup.
-          // It will be processed by calling processOutputBuffer (possibly multiple times).
-          if (outputBuffer != null) {
-            outputBuffer.position(outputBufferInfo.offset);
-            outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);
-          }
-          shouldSkipOutputBuffer = shouldSkipOutputBuffer(outputBufferInfo.presentationTimeUs);
         }
-      } else if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED /* (-2) */) {
-        processOutputFormat();
-        return true;
-      } else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED /* (-3) */) {
-        processOutputBuffersChanged();
-        return true;
-      } else /* MediaCodec.INFO_TRY_AGAIN_LATER (-1) or unknown negative return value */ {
-        if (codecNeedsEosPropagationWorkaround
+        /* MediaCodec.INFO_TRY_AGAIN_LATER (-1) or unknown negative return value */
+        if (codecNeedsEosPropagation
             && (inputStreamEnded
                 || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM)) {
           processEndOfStream();
         }
         return false;
       }
+
+      // We've dequeued a buffer.
+      if (shouldSkipAdaptationWorkaroundOutputBuffer) {
+        shouldSkipAdaptationWorkaroundOutputBuffer = false;
+        codec.releaseOutputBuffer(outputIndex, false);
+        return true;
+      } else if (outputBufferInfo.size == 0
+          && (outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
+        // The dequeued buffer indicates the end of the stream. Process it immediately.
+        processEndOfStream();
+        return false;
+      }
+
+      this.outputIndex = outputIndex;
+      outputBuffer = getOutputBuffer(outputIndex);
+      // The dequeued buffer is a media buffer. Do some initial setup.
+      // It will be processed by calling processOutputBuffer (possibly multiple times).
+      if (outputBuffer != null) {
+        outputBuffer.position(outputBufferInfo.offset);
+        outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);
+      }
+      shouldSkipOutputBuffer = shouldSkipOutputBuffer(outputBufferInfo.presentationTimeUs);
+      updateOutputFormatForTime(outputBufferInfo.presentationTimeUs);
     }
 
     boolean processedOutputBuffer;
@@ -1074,7 +1340,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
                 outputIndex,
                 outputBufferInfo.flags,
                 outputBufferInfo.presentationTimeUs,
-                shouldSkipOutputBuffer);
+                shouldSkipOutputBuffer,
+                outputFormat);
       } catch (IllegalStateException e) {
         processEndOfStream();
         if (outputStreamEnded) {
@@ -1093,7 +1360,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
               outputIndex,
               outputBufferInfo.flags,
               outputBufferInfo.presentationTimeUs,
-              shouldSkipOutputBuffer);
+              shouldSkipOutputBuffer,
+              outputFormat);
     }
 
     if (processedOutputBuffer) {
@@ -1138,36 +1406,43 @@ private void processOutputBuffersChanged() {
 
   /**
    * Processes an output media buffer.
-   * <p>
-   * When a new {@link ByteBuffer} is passed to this method its position and limit delineate the
+   *
+   * <p>When a new {@link ByteBuffer} is passed to this method its position and limit delineate the
    * data to be processed. The return value indicates whether the buffer was processed in full. If
    * true is returned then the next call to this method will receive a new buffer to be processed.
    * If false is returned then the same buffer will be passed to the next call. An implementation of
    * this method is free to modify the buffer and can assume that the buffer will not be externally
    * modified between successive calls. Hence an implementation can, for example, modify the
    * buffer's position to keep track of how much of the data it has processed.
-   * <p>
-   * Note that the first call to this method following a call to
-   * {@link #onPositionReset(long, boolean)} will always receive a new {@link ByteBuffer} to be
-   * processed.
    *
-   * @param positionUs The current media time in microseconds, measured at the start of the
-   *     current iteration of the rendering loop.
-   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
-   *     measured at the start of the current iteration of the rendering loop.
+   * <p>Note that the first call to this method following a call to {@link #onPositionReset(long,
+   * boolean)} will always receive a new {@link ByteBuffer} to be processed.
+   *
+   * @param positionUs The current media time in microseconds, measured at the start of the current
+   *     iteration of the rendering loop.
+   * @param elapsedRealtimeUs {@link SystemClock#elapsedRealtime()} in microseconds, measured at the
+   *     start of the current iteration of the rendering loop.
    * @param codec The {@link MediaCodec} instance.
    * @param buffer The output buffer to process.
    * @param bufferIndex The index of the output buffer.
    * @param bufferFlags The flags attached to the output buffer.
    * @param bufferPresentationTimeUs The presentation time of the output buffer in microseconds.
    * @param shouldSkip Whether the buffer should be skipped (i.e. not rendered).
-   *
+   * @param format The format associated with the buffer.
    * @return Whether the output buffer was fully processed (e.g. rendered or skipped).
    * @throws ExoPlaybackException If an error occurs processing the output buffer.
    */
-  protected abstract boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs,
-      MediaCodec codec, ByteBuffer buffer, int bufferIndex, int bufferFlags,
-      long bufferPresentationTimeUs, boolean shouldSkip) throws ExoPlaybackException;
+  protected abstract boolean processOutputBuffer(
+      long positionUs,
+      long elapsedRealtimeUs,
+      MediaCodec codec,
+      ByteBuffer buffer,
+      int bufferIndex,
+      int bufferFlags,
+      long bufferPresentationTimeUs,
+      boolean shouldSkip,
+      Format format)
+      throws ExoPlaybackException;
 
   /**
    * Incrementally renders any remaining output.
@@ -1209,6 +1484,32 @@ private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
     return false;
   }
 
+  private static MediaCodec.CryptoInfo getFrameworkCryptoInfo(
+      DecoderInputBuffer buffer, int adaptiveReconfigurationBytes) {
+    MediaCodec.CryptoInfo cryptoInfo = buffer.cryptoInfo.getFrameworkCryptoInfoV16();
+    if (adaptiveReconfigurationBytes == 0) {
+      return cryptoInfo;
+    }
+    // There must be at least one sub-sample, although numBytesOfClearData is permitted to be
+    // null if it contains no clear data. Instantiate it if needed, and add the reconfiguration
+    // bytes to the clear byte count of the first sub-sample.
+    if (cryptoInfo.numBytesOfClearData == null) {
+      cryptoInfo.numBytesOfClearData = new int[1];
+    }
+    cryptoInfo.numBytesOfClearData[0] += adaptiveReconfigurationBytes;
+    return cryptoInfo;
+  }
+
+  /**
+   * Returns whether the device needs keys to have been loaded into the {@link DrmSession} before
+   * codec configuration.
+   */
+  private boolean deviceNeedsDrmKeysToConfigureCodecWorkaround() {
+    return "Amazon".equals(Util.MANUFACTURER)
+        && ("AFTM".equals(Util.MODEL) // Fire TV Stick Gen 1
+            || "AFTB".equals(Util.MODEL)); // Fire TV Gen 1
+  }
+
   /**
    * Returns whether the decoder is known to fail when flushed.
    * <p>
@@ -1230,13 +1531,13 @@ private static boolean codecNeedsFlushWorkaround(String name) {
 
   /**
    * Returns a mode that specifies when the adaptation workaround should be enabled.
-   * <p>
-   * When enabled, the workaround queues and discards a blank frame with a resolution whose width
-   * and height both equal {@link #ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT}, to reset the codec's
+   *
+   * <p>When enabled, the workaround queues and discards a blank frame with a resolution whose width
+   * and height both equal {@link #ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT}, to reset the decoder's
    * internal state when a format change occurs.
-   * <p>
-   * See [Internal: b/27807182].
-   * See <a href="https://github.com/google/ExoPlayer/issues/3257">GitHub issue #3257</a>.
+   *
+   * <p>See [Internal: b/27807182]. See <a
+   * href="https://github.com/google/ExoPlayer/issues/3257">GitHub issue #3257</a>.
    *
    * @param name The name of the decoder.
    * @return The mode specifying when the adaptation workaround should be enabled.
@@ -1256,6 +1557,21 @@ private static boolean codecNeedsFlushWorkaround(String name) {
     }
   }
 
+  /**
+   * Returns whether the decoder is known to fail when an attempt is made to reconfigure it with a
+   * new format's configuration data.
+   *
+   * <p>When enabled, the workaround will always release and recreate the decoder, rather than
+   * attempting to reconfigure the existing instance.
+   *
+   * @param name The name of the decoder.
+   * @return True if the decoder is known to fail when an attempt is made to reconfigure it with a
+   *     new format's configuration data.
+   */
+  private static boolean codecNeedsReconfigureWorkaround(String name) {
+    return Util.MODEL.startsWith("SM-T230") && "OMX.MARVELL.VIDEO.HW.CODA7542DECODER".equals(name);
+  }
+
   /**
    * Returns whether the decoder is an H.264/AVC decoder known to fail if NAL units are queued
    * before the codec specific data.
@@ -1272,20 +1588,23 @@ private static boolean codecNeedsDiscardToSpsWorkaround(String name, Format form
   }
 
   /**
-   * Returns whether the decoder is known to handle the propagation of the
-   * {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} flag incorrectly on the host device.
-   * <p>
-   * If true is returned, the renderer will work around the issue by approximating end of stream
+   * Returns whether the decoder is known to handle the propagation of the {@link
+   * MediaCodec#BUFFER_FLAG_END_OF_STREAM} flag incorrectly on the host device.
+   *
+   * <p>If true is returned, the renderer will work around the issue by approximating end of stream
    * behavior without relying on the flag being propagated through to an output buffer by the
    * underlying decoder.
    *
-   * @param name The name of the decoder.
+   * @param codecInfo Information about the {@link MediaCodec}.
    * @return True if the decoder is known to handle {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM}
    *     propagation incorrectly on the host device. False otherwise.
    */
-  private static boolean codecNeedsEosPropagationWorkaround(String name) {
-    return Util.SDK_INT <= 17 && ("OMX.rk.video_decoder.avc".equals(name)
-        || "OMX.allwinner.video.decoder.avc".equals(name));
+  private static boolean codecNeedsEosPropagationWorkaround(MediaCodecInfo codecInfo) {
+    String name = codecInfo.name;
+    return (Util.SDK_INT <= 17
+            && ("OMX.rk.video_decoder.avc".equals(name)
+                || "OMX.allwinner.video.decoder.avc".equals(name)))
+        || ("Amazon".equals(Util.MANUFACTURER) && "AFTS".equals(Util.MODEL) && codecInfo.secure);
   }
 
   /**
@@ -1303,7 +1622,8 @@ private static boolean codecNeedsEosPropagationWorkaround(String name) {
    */
   private static boolean codecNeedsEosFlushWorkaround(String name) {
     return (Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name))
-        || (Util.SDK_INT <= 19 && "hb2000".equals(Util.DEVICE)
+        || (Util.SDK_INT <= 19
+            && ("hb2000".equals(Util.DEVICE) || "stvm8".equals(Util.DEVICE))
             && ("OMX.amlogic.avc.decoder.awesome".equals(name)
                 || "OMX.amlogic.avc.decoder.awesome.secure".equals(name)));
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
index 1823c3a7ff..d92e93d45b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
@@ -16,7 +16,10 @@
 package com.google.android.exoplayer2.mediacodec;
 
 import android.media.MediaCodec;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Selector of {@link MediaCodec} instances.
@@ -24,32 +27,58 @@
 public interface MediaCodecSelector {
 
   /**
-   * Default implementation of {@link MediaCodecSelector}.
+   * Default implementation of {@link MediaCodecSelector}, which returns the preferred decoder for
+   * the given format.
    */
-  MediaCodecSelector DEFAULT = new MediaCodecSelector() {
+  MediaCodecSelector DEFAULT =
+      new MediaCodecSelector() {
+        @Override
+        public List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean requiresSecureDecoder)
+            throws DecoderQueryException {
+          List<MediaCodecInfo> decoderInfos =
+              MediaCodecUtil.getDecoderInfos(mimeType, requiresSecureDecoder);
+          return decoderInfos.isEmpty()
+              ? Collections.emptyList()
+              : Collections.singletonList(decoderInfos.get(0));
+        }
 
-    @Override
-    public MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
-        throws DecoderQueryException {
-      return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
-    }
+        @Override
+        public @Nullable MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
+          return MediaCodecUtil.getPassthroughDecoderInfo();
+        }
+      };
 
-    @Override
-    public MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
-      return MediaCodecUtil.getPassthroughDecoderInfo();
-    }
+  /**
+   * A {@link MediaCodecSelector} that returns a list of decoders in priority order, allowing
+   * fallback to less preferred decoders if initialization fails.
+   *
+   * <p>Note: if a hardware-accelerated video decoder fails to initialize, this selector may provide
+   * a software video decoder to use as a fallback. Using software decoding can be inefficient, and
+   * the decoder may be too slow to keep up with the playback position.
+   */
+  MediaCodecSelector DEFAULT_WITH_FALLBACK =
+      new MediaCodecSelector() {
+        @Override
+        public List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean requiresSecureDecoder)
+            throws DecoderQueryException {
+          return MediaCodecUtil.getDecoderInfos(mimeType, requiresSecureDecoder);
+        }
 
-  };
+        @Override
+        public @Nullable MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
+          return MediaCodecUtil.getPassthroughDecoderInfo();
+        }
+      };
 
   /**
-   * Selects a decoder to instantiate for a given mime type.
+   * Returns a list of decoders that can decode media in the specified MIME type, in priority order.
    *
-   * @param mimeType The mime type for which a decoder is required.
+   * @param mimeType The MIME type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
-   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
+   * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+  List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean requiresSecureDecoder)
       throws DecoderQueryException;
 
   /**
@@ -58,6 +87,6 @@ MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
    * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
+  @Nullable
   MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException;
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 347afe29fd..4d971d461e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -22,13 +22,14 @@
 import android.media.MediaCodecList;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-import android.util.Log;
 import android.util.Pair;
 import android.util.SparseIntArray;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -57,11 +58,9 @@ private DecoderQueryException(Throwable cause) {
   }
 
   private static final String TAG = "MediaCodecUtil";
-  private static final String GOOGLE_RAW_DECODER_NAME = "OMX.google.raw.decoder";
-  private static final String MTK_RAW_DECODER_NAME = "OMX.MTK.AUDIO.DECODER.RAW";
-  private static final MediaCodecInfo PASSTHROUGH_DECODER_INFO =
-      MediaCodecInfo.newPassthroughInstance(GOOGLE_RAW_DECODER_NAME);
   private static final Pattern PROFILE_PATTERN = Pattern.compile("^\\D?(\\d+)$");
+  private static final RawAudioCodecComparator RAW_AUDIO_CODEC_COMPARATOR =
+      new RawAudioCodecComparator();
 
   private static final HashMap<CodecKey, List<MediaCodecInfo>> decoderInfosCache = new HashMap<>();
 
@@ -75,6 +74,9 @@ private DecoderQueryException(Throwable cause) {
   private static final Map<String, Integer> HEVC_CODEC_STRING_TO_PROFILE_LEVEL;
   private static final String CODEC_ID_HEV1 = "hev1";
   private static final String CODEC_ID_HVC1 = "hvc1";
+  // MP4A AAC.
+  private static final SparseIntArray MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE;
+  private static final String CODEC_ID_MP4A = "mp4a";
 
   // Lazily initialized.
   private static int maxH264DecodableFrameSize = -1;
@@ -103,22 +105,21 @@ public static void warmDecoderInfoCache(String mimeType, boolean secure) {
   /**
    * Returns information about a decoder suitable for audio passthrough.
    *
-   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
-   *     exists.
+   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
+   * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static MediaCodecInfo getPassthroughDecoderInfo() {
-    // TODO: Return null if the raw decoder doesn't exist.
-    return PASSTHROUGH_DECODER_INFO;
+  public static @Nullable MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
+    MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.AUDIO_RAW, /* secure= */ false);
+    return decoderInfo == null ? null : MediaCodecInfo.newPassthroughInstance(decoderInfo.name);
   }
 
   /**
    * Returns information about the preferred decoder for a given mime type.
    *
-   * @param mimeType The mime type.
+   * @param mimeType The MIME type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
-   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
-   *     exists.
+   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
   public static @Nullable MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
@@ -128,18 +129,18 @@ public static MediaCodecInfo getPassthroughDecoderInfo() {
   }
 
   /**
-   * Returns all {@link MediaCodecInfo}s for the given mime type, in the order given by
-   * {@link MediaCodecList}.
+   * Returns all {@link MediaCodecInfo}s for the given mime type, in the order given by {@link
+   * MediaCodecList}.
    *
-   * @param mimeType The mime type.
+   * @param mimeType The MIME type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
-   * @return A list of all @{link MediaCodecInfo}s for the given mime type, in the order
-   *     given by {@link MediaCodecList}.
+   * @return A list of all {@link MediaCodecInfo}s for the given mime type, in the order given by
+   *     {@link MediaCodecList}.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static synchronized List<MediaCodecInfo> getDecoderInfos(String mimeType,
-      boolean secure) throws DecoderQueryException {
+  public static synchronized List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean secure)
+      throws DecoderQueryException {
     CodecKey key = new CodecKey(mimeType, secure);
     List<MediaCodecInfo> cachedDecoderInfos = decoderInfosCache.get(key);
     if (cachedDecoderInfos != null) {
@@ -165,7 +166,7 @@ public static MediaCodecInfo getPassthroughDecoderInfo() {
           getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);
       decoderInfos.addAll(eac3DecoderInfos);
     }
-    applyWorkarounds(decoderInfos);
+    applyWorkarounds(mimeType, decoderInfos);
     List<MediaCodecInfo> unmodifiableDecoderInfos = Collections.unmodifiableList(decoderInfos);
     decoderInfosCache.put(key, unmodifiableDecoderInfos);
     return unmodifiableDecoderInfos;
@@ -201,7 +202,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
    * @return A pair (profile constant, level constant) if {@code codec} is well-formed and
    *     recognized, or null otherwise
    */
-  public static Pair<Integer, Integer> getCodecProfileAndLevel(String codec) {
+  public static @Nullable Pair<Integer, Integer> getCodecProfileAndLevel(String codec) {
     if (codec == null) {
       return null;
     }
@@ -213,6 +214,8 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       case CODEC_ID_AVC1:
       case CODEC_ID_AVC2:
         return getAvcProfileAndLevel(codec, parts);
+      case CODEC_ID_MP4A:
+        return getAacCodecProfileAndLevel(codec, parts);
       default:
         return null;
     }
@@ -314,6 +317,25 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
       return false;
     }
 
+    // Work around https://github.com/google/ExoPlayer/issues/4519.
+    if ("OMX.SEC.mp3.dec".equals(name)
+        && (Util.MODEL.startsWith("GT-I9152")
+            || Util.MODEL.startsWith("GT-I9515")
+            || Util.MODEL.startsWith("GT-P5220")
+            || Util.MODEL.startsWith("GT-S7580")
+            || Util.MODEL.startsWith("SM-G350")
+            || Util.MODEL.startsWith("SM-G386")
+            || Util.MODEL.startsWith("SM-T231")
+            || Util.MODEL.startsWith("SM-T530"))) {
+      return false;
+    }
+    if ("OMX.brcm.audio.mp3.decoder".equals(name)
+        && (Util.MODEL.startsWith("GT-I9152")
+            || Util.MODEL.startsWith("GT-S7580")
+            || Util.MODEL.startsWith("SM-G350"))) {
+      return false;
+    }
+
     // Work around https://github.com/google/ExoPlayer/issues/1528 and
     // https://github.com/google/ExoPlayer/issues/3171.
     if (Util.SDK_INT < 18 && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
@@ -395,20 +417,12 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
    * Modifies a list of {@link MediaCodecInfo}s to apply workarounds where we know better than the
    * platform.
    *
+   * @param mimeType The MIME type of input media.
    * @param decoderInfos The list to modify.
    */
-  private static void applyWorkarounds(List<MediaCodecInfo> decoderInfos) {
-    if (Util.SDK_INT < 26 && decoderInfos.size() > 1
-        && MTK_RAW_DECODER_NAME.equals(decoderInfos.get(0).name)) {
-      // Prefer the Google raw decoder over the MediaTek one [Internal: b/62337687].
-      for (int i = 1; i < decoderInfos.size(); i++) {
-        MediaCodecInfo decoderInfo = decoderInfos.get(i);
-        if (GOOGLE_RAW_DECODER_NAME.equals(decoderInfo.name)) {
-          decoderInfos.remove(i);
-          decoderInfos.add(0, decoderInfo);
-          break;
-        }
-      }
+  private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decoderInfos) {
+    if (MimeTypes.AUDIO_RAW.equals(mimeType)) {
+      Collections.sort(decoderInfos, RAW_AUDIO_CODEC_COMPARATOR);
     }
   }
 
@@ -455,8 +469,8 @@ private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
     return new Pair<>(profile, level);
   }
 
-  private static Pair<Integer, Integer> getAvcProfileAndLevel(String codec, String[] codecsParts) {
-    if (codecsParts.length < 2) {
+  private static Pair<Integer, Integer> getAvcProfileAndLevel(String codec, String[] parts) {
+    if (parts.length < 2) {
       // The codec has fewer parts than required by the AVC codec string format.
       Log.w(TAG, "Ignoring malformed AVC codec string: " + codec);
       return null;
@@ -464,14 +478,14 @@ private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
     Integer profileInteger;
     Integer levelInteger;
     try {
-      if (codecsParts[1].length() == 6) {
+      if (parts[1].length() == 6) {
         // Format: avc1.xxccyy, where xx is profile and yy level, both hexadecimal.
-        profileInteger = Integer.parseInt(codecsParts[1].substring(0, 2), 16);
-        levelInteger = Integer.parseInt(codecsParts[1].substring(4), 16);
-      } else if (codecsParts.length >= 3) {
+        profileInteger = Integer.parseInt(parts[1].substring(0, 2), 16);
+        levelInteger = Integer.parseInt(parts[1].substring(4), 16);
+      } else if (parts.length >= 3) {
         // Format: avc1.xx.[y]yy where xx is profile and [y]yy level, both decimal.
-        profileInteger = Integer.parseInt(codecsParts[1]);
-        levelInteger = Integer.parseInt(codecsParts[2]);
+        profileInteger = Integer.parseInt(parts[1]);
+        levelInteger = Integer.parseInt(parts[2]);
       } else {
         // We don't recognize the format.
         Log.w(TAG, "Ignoring malformed AVC codec string: " + codec);
@@ -504,24 +518,60 @@ private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
    */
   private static int avcLevelToMaxFrameSize(int avcLevel) {
     switch (avcLevel) {
-      case CodecProfileLevel.AVCLevel1: return 99 * 16 * 16;
-      case CodecProfileLevel.AVCLevel1b: return 99 * 16 * 16;
-      case CodecProfileLevel.AVCLevel12: return 396 * 16 * 16;
-      case CodecProfileLevel.AVCLevel13: return 396 * 16 * 16;
-      case CodecProfileLevel.AVCLevel2: return 396 * 16 * 16;
-      case CodecProfileLevel.AVCLevel21: return 792 * 16 * 16;
-      case CodecProfileLevel.AVCLevel22: return 1620 * 16 * 16;
-      case CodecProfileLevel.AVCLevel3: return 1620 * 16 * 16;
-      case CodecProfileLevel.AVCLevel31: return 3600 * 16 * 16;
-      case CodecProfileLevel.AVCLevel32: return 5120 * 16 * 16;
-      case CodecProfileLevel.AVCLevel4: return 8192 * 16 * 16;
-      case CodecProfileLevel.AVCLevel41: return 8192 * 16 * 16;
-      case CodecProfileLevel.AVCLevel42: return 8704 * 16 * 16;
-      case CodecProfileLevel.AVCLevel5: return 22080 * 16 * 16;
-      case CodecProfileLevel.AVCLevel51: return 36864 * 16 * 16;
-      case CodecProfileLevel.AVCLevel52: return 36864 * 16 * 16;
-      default: return -1;
+      case CodecProfileLevel.AVCLevel1:
+      case CodecProfileLevel.AVCLevel1b:
+        return 99 * 16 * 16;
+      case CodecProfileLevel.AVCLevel12:
+      case CodecProfileLevel.AVCLevel13:
+      case CodecProfileLevel.AVCLevel2:
+        return 396 * 16 * 16;
+      case CodecProfileLevel.AVCLevel21:
+        return 792 * 16 * 16;
+      case CodecProfileLevel.AVCLevel22:
+      case CodecProfileLevel.AVCLevel3:
+        return 1620 * 16 * 16;
+      case CodecProfileLevel.AVCLevel31:
+        return 3600 * 16 * 16;
+      case CodecProfileLevel.AVCLevel32:
+        return 5120 * 16 * 16;
+      case CodecProfileLevel.AVCLevel4:
+      case CodecProfileLevel.AVCLevel41:
+        return 8192 * 16 * 16;
+      case CodecProfileLevel.AVCLevel42:
+        return 8704 * 16 * 16;
+      case CodecProfileLevel.AVCLevel5:
+        return 22080 * 16 * 16;
+      case CodecProfileLevel.AVCLevel51:
+      case CodecProfileLevel.AVCLevel52:
+        return 36864 * 16 * 16;
+      default:
+        return -1;
+    }
+  }
+
+  private static @Nullable Pair<Integer, Integer> getAacCodecProfileAndLevel(
+      String codec, String[] parts) {
+    if (parts.length != 3) {
+      Log.w(TAG, "Ignoring malformed MP4A codec string: " + codec);
+      return null;
     }
+    try {
+      // Get the object type indication, which is a hexadecimal value (see RFC 6381/ISO 14496-1).
+      int objectTypeIndication = Integer.parseInt(parts[1], 16);
+      String mimeType = MimeTypes.getMimeTypeFromMp4ObjectType(objectTypeIndication);
+      if (MimeTypes.AUDIO_AAC.equals(mimeType)) {
+        // For MPEG-4 audio this is followed by an audio object type indication as a decimal number.
+        int audioObjectTypeIndication = Integer.parseInt(parts[2]);
+        int profile = MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.get(audioObjectTypeIndication, -1);
+        if (profile != -1) {
+          // Level is set to zero in AAC decoder CodecProfileLevels.
+          return new Pair<>(profile, 0);
+        }
+      }
+    } catch (NumberFormatException e) {
+      Log.w(TAG, "Ignoring malformed MP4A codec string: " + codec);
+    }
+    return null;
   }
 
   private interface MediaCodecListCompat {
@@ -652,12 +702,41 @@ public boolean equals(@Nullable Object obj) {
 
   }
 
+  /**
+   * Comparator for ordering media codecs that handle {@link MimeTypes#AUDIO_RAW} to work around
+   * possible inconsistent behavior across different devices. A list sorted with this comparator has
+   * more preferred codecs first.
+   */
+  private static final class RawAudioCodecComparator implements Comparator<MediaCodecInfo> {
+    @Override
+    public int compare(MediaCodecInfo a, MediaCodecInfo b) {
+      return scoreMediaCodecInfo(a) - scoreMediaCodecInfo(b);
+    }
+
+    private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
+      String name = mediaCodecInfo.name;
+      if (name.startsWith("OMX.google") || name.startsWith("c2.android")) {
+        // Prefer generic decoders over ones provided by the device.
+        return -1;
+      }
+      if (Util.SDK_INT < 26 && name.equals("OMX.MTK.AUDIO.DECODER.RAW")) {
+        // This decoder may modify the audio, so any other compatible decoders take precedence. See
+        // [Internal: b/62337687].
+        return 1;
+      }
+      return 0;
+    }
+  }
+
   static {
     AVC_PROFILE_NUMBER_TO_CONST = new SparseIntArray();
     AVC_PROFILE_NUMBER_TO_CONST.put(66, CodecProfileLevel.AVCProfileBaseline);
     AVC_PROFILE_NUMBER_TO_CONST.put(77, CodecProfileLevel.AVCProfileMain);
     AVC_PROFILE_NUMBER_TO_CONST.put(88, CodecProfileLevel.AVCProfileExtended);
     AVC_PROFILE_NUMBER_TO_CONST.put(100, CodecProfileLevel.AVCProfileHigh);
+    AVC_PROFILE_NUMBER_TO_CONST.put(110, CodecProfileLevel.AVCProfileHigh10);
+    AVC_PROFILE_NUMBER_TO_CONST.put(122, CodecProfileLevel.AVCProfileHigh422);
+    AVC_PROFILE_NUMBER_TO_CONST.put(244, CodecProfileLevel.AVCProfileHigh444);
 
     AVC_LEVEL_NUMBER_TO_CONST = new SparseIntArray();
     AVC_LEVEL_NUMBER_TO_CONST.put(10, CodecProfileLevel.AVCLevel1);
@@ -706,6 +785,20 @@ public boolean equals(@Nullable Object obj) {
     HEVC_CODEC_STRING_TO_PROFILE_LEVEL.put("H180", CodecProfileLevel.HEVCHighTierLevel6);
     HEVC_CODEC_STRING_TO_PROFILE_LEVEL.put("H183", CodecProfileLevel.HEVCHighTierLevel61);
     HEVC_CODEC_STRING_TO_PROFILE_LEVEL.put("H186", CodecProfileLevel.HEVCHighTierLevel62);
+
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE = new SparseIntArray();
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(1, CodecProfileLevel.AACObjectMain);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(2, CodecProfileLevel.AACObjectLC);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(3, CodecProfileLevel.AACObjectSSR);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(4, CodecProfileLevel.AACObjectLTP);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(5, CodecProfileLevel.AACObjectHE);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(6, CodecProfileLevel.AACObjectScalable);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(17, CodecProfileLevel.AACObjectERLC);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(20, CodecProfileLevel.AACObjectERScalable);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(23, CodecProfileLevel.AACObjectLD);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(29, CodecProfileLevel.AACObjectHE_PS);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(39, CodecProfileLevel.AACObjectELD);
+    MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(42, CodecProfileLevel.AACObjectXHE);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
index 9137bad4fd..7e4861a8cb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata;
 
+import android.support.annotation.Nullable;
+
 /**
  * Decodes metadata from binary data.
  */
@@ -24,9 +26,8 @@
    * Decodes a {@link Metadata} element from the provided input buffer.
    *
    * @param inputBuffer The input buffer to decode.
-   * @return The decoded metadata object.
-   * @throws MetadataDecoderException If a problem occurred decoding the data.
+   * @return The decoded metadata object, or null if the metadata could not be decoded.
    */
-  Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException;
-
+  @Nullable
+  Metadata decode(MetadataInputBuffer inputBuffer);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index 7d36d87a9e..864616e810 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -19,12 +19,14 @@
 import android.os.Handler.Callback;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
 /**
@@ -46,7 +48,7 @@
 
   private final MetadataDecoderFactory decoderFactory;
   private final MetadataOutput output;
-  private final Handler outputHandler;
+  private final @Nullable Handler outputHandler;
   private final FormatHolder formatHolder;
   private final MetadataInputBuffer buffer;
   private final Metadata[] pendingMetadata;
@@ -61,11 +63,11 @@
    * @param output The output.
    * @param outputLooper The looper associated with the thread on which the output should be called.
    *     If the output makes use of standard Android UI components, then this should normally be the
-   *     looper associated with the application's main thread, which can be obtained using
-   *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
-   *     called directly on the player's internal rendering thread.
+   *     looper associated with the application's main thread, which can be obtained using {@link
+   *     android.app.Activity#getMainLooper()}. Null may be passed if the output should be called
+   *     directly on the player's internal rendering thread.
    */
-  public MetadataRenderer(MetadataOutput output, Looper outputLooper) {
+  public MetadataRenderer(MetadataOutput output, @Nullable Looper outputLooper) {
     this(output, outputLooper, MetadataDecoderFactory.DEFAULT);
   }
 
@@ -73,16 +75,17 @@ public MetadataRenderer(MetadataOutput output, Looper outputLooper) {
    * @param output The output.
    * @param outputLooper The looper associated with the thread on which the output should be called.
    *     If the output makes use of standard Android UI components, then this should normally be the
-   *     looper associated with the application's main thread, which can be obtained using
-   *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
-   *     called directly on the player's internal rendering thread.
+   *     looper associated with the application's main thread, which can be obtained using {@link
+   *     android.app.Activity#getMainLooper()}. Null may be passed if the output should be called
+   *     directly on the player's internal rendering thread.
    * @param decoderFactory A factory from which to obtain {@link MetadataDecoder} instances.
    */
-  public MetadataRenderer(MetadataOutput output, Looper outputLooper,
-      MetadataDecoderFactory decoderFactory) {
+  public MetadataRenderer(
+      MetadataOutput output, @Nullable Looper outputLooper, MetadataDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_METADATA);
     this.output = Assertions.checkNotNull(output);
-    this.outputHandler = outputLooper == null ? null : new Handler(outputLooper, this);
+    this.outputHandler =
+        outputLooper == null ? null : Util.createHandler(outputLooper, /* callback= */ this);
     this.decoderFactory = Assertions.checkNotNull(decoderFactory);
     formatHolder = new FormatHolder();
     buffer = new MetadataInputBuffer();
@@ -125,13 +128,12 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
         } else {
           buffer.subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
           buffer.flip();
-          try {
-            int index = (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
-            pendingMetadata[index] = decoder.decode(buffer);
+          int index = (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
+          Metadata metadata = decoder.decode(buffer);
+          if (metadata != null) {
+            pendingMetadata[index] = metadata;
             pendingMetadataTimestamps[index] = buffer.timeUs;
             pendingMetadataCount++;
-          } catch (MetadataDecoderException e) {
-            throw ExoPlaybackException.createForRenderer(e, getIndex());
           }
         }
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
index 5f521aada6..7d70d9de1c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -81,12 +83,12 @@ public EventMessage(String schemeIdUri, String value, long durationMs, long id,
   }
 
   /* package */ EventMessage(Parcel in) {
-    schemeIdUri = in.readString();
-    value = in.readString();
+    schemeIdUri = castNonNull(in.readString());
+    value = castNonNull(in.readString());
     presentationTimeUs = in.readLong();
     durationMs = in.readLong();
     id = in.readLong();
-    messageData = in.createByteArray();
+    messageData = castNonNull(in.createByteArray());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index 7e5125e71c..14f678374c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
@@ -32,14 +33,15 @@
  */
 public final class EventMessageDecoder implements MetadataDecoder {
 
+  @SuppressWarnings("ByteBufferBackingArray")
   @Override
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = inputBuffer.data;
     byte[] data = buffer.array();
     int size = buffer.limit();
     ParsableByteArray emsgData = new ParsableByteArray(data, size);
-    String schemeIdUri = emsgData.readNullTerminatedString();
-    String value = emsgData.readNullTerminatedString();
+    String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+    String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
     long timescale = emsgData.readUnsignedInt();
     long presentationTimeUs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(),
         C.MICROS_PER_SECOND, timescale);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
index ae78f712c7..53976da0d1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -29,11 +31,12 @@
   public static final String ID = "APIC";
 
   public final String mimeType;
-  public final String description;
+  public final @Nullable String description;
   public final int pictureType;
   public final byte[] pictureData;
 
-  public ApicFrame(String mimeType, String description, int pictureType, byte[] pictureData) {
+  public ApicFrame(
+      String mimeType, @Nullable String description, int pictureType, byte[] pictureData) {
     super(ID);
     this.mimeType = mimeType;
     this.description = description;
@@ -43,10 +46,10 @@ public ApicFrame(String mimeType, String description, int pictureType, byte[] pi
 
   /* package */ ApicFrame(Parcel in) {
     super(ID);
-    mimeType = in.readString();
-    description = in.readString();
+    mimeType = castNonNull(in.readString());
+    description = castNonNull(in.readString());
     pictureType = in.readInt();
-    pictureData = in.createByteArray();
+    pictureData = castNonNull(in.createByteArray());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
index 129803299c..c48829ae54 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -33,8 +35,8 @@ public BinaryFrame(String id, byte[] data) {
   }
 
   /* package */ BinaryFrame(Parcel in) {
-    super(in.readString());
-    data = in.createByteArray();
+    super(castNonNull(in.readString()));
+    data = castNonNull(in.createByteArray());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
index aca530cdee..7ffb6d028c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
@@ -54,7 +56,7 @@ public ChapterFrame(String chapterId, int startTimeMs, int endTimeMs, long start
 
   /* package */ ChapterFrame(Parcel in) {
     super(ID);
-    this.chapterId = in.readString();
+    this.chapterId = castNonNull(in.readString());
     this.startTimeMs = in.readInt();
     this.endTimeMs = in.readInt();
     this.startOffset = in.readLong();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
index 56b08bbee3..c4a7c06e49 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
@@ -45,7 +47,7 @@ public ChapterTocFrame(String elementId, boolean isRoot, boolean isOrdered, Stri
 
   /* package */ ChapterTocFrame(Parcel in) {
     super(ID);
-    this.elementId = in.readString();
+    this.elementId = castNonNull(in.readString());
     this.isRoot = in.readByte() != 0;
     this.isOrdered = in.readByte() != 0;
     this.children = in.createStringArray();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
index e84b776790..5666e48939 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -40,9 +42,9 @@ public CommentFrame(String language, String description, String text) {
 
   /* package */ CommentFrame(Parcel in) {
     super(ID);
-    language = in.readString();
-    description = in.readString();
-    text = in.readString();
+    language = castNonNull(in.readString());
+    description = castNonNull(in.readString());
+    text = castNonNull(in.readString());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
index 8b665fce00..990d8f2e48 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -43,10 +45,10 @@ public GeobFrame(String mimeType, String filename, String description, byte[] da
 
   /* package */ GeobFrame(Parcel in) {
     super(ID);
-    mimeType = in.readString();
-    filename = in.readString();
-    description = in.readString();
-    data = in.createByteArray();
+    mimeType = castNonNull(in.readString());
+    filename = castNonNull(in.readString());
+    description = castNonNull(in.readString());
+    data = castNonNull(in.createByteArray());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index ad24bac6c4..63bf30dd11 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -15,11 +15,13 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.UnsupportedEncodingException;
@@ -55,13 +57,7 @@
 
   /** A predicate that indicates no frames should be decoded. */
   public static final FramePredicate NO_FRAMES_PREDICATE =
-      new FramePredicate() {
-
-        @Override
-        public boolean evaluate(int majorVersion, int id0, int id1, int id2, int id3) {
-          return false;
-        }
-      };
+      (majorVersion, id0, id1, id2, id3) -> false;
 
   private static final String TAG = "Id3Decoder";
 
@@ -88,7 +84,7 @@ public boolean evaluate(int majorVersion, int id0, int id1, int id2, int id3) {
   private static final int ID3_TEXT_ENCODING_UTF_16BE = 2;
   private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
 
-  private final FramePredicate framePredicate;
+  private final @Nullable FramePredicate framePredicate;
 
   public Id3Decoder() {
     this(null);
@@ -97,12 +93,13 @@ public Id3Decoder() {
   /**
    * @param framePredicate Determines which frames are decoded. May be null to decode all frames.
    */
-  public Id3Decoder(FramePredicate framePredicate) {
+  public Id3Decoder(@Nullable FramePredicate framePredicate) {
     this.framePredicate = framePredicate;
   }
 
+  @SuppressWarnings("ByteBufferBackingArray")
   @Override
-  public Metadata decode(MetadataInputBuffer inputBuffer) {
+  public @Nullable Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = inputBuffer.data;
     return decode(buffer.array(), buffer.limit());
   }
@@ -112,9 +109,10 @@ public Metadata decode(MetadataInputBuffer inputBuffer) {
    *
    * @param data The bytes to decode ID3 tags from.
    * @param size Amount of bytes in {@code data} to read.
-   * @return A {@link Metadata} object containing the decoded ID3 tags.
+   * @return A {@link Metadata} object containing the decoded ID3 tags, or null if the data could
+   *     not be decoded.
    */
-  public Metadata decode(byte[] data, int size) {
+  public @Nullable Metadata decode(byte[] data, int size) {
     List<Id3Frame> id3Frames = new ArrayList<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
 
@@ -156,7 +154,7 @@ public Metadata decode(byte[] data, int size) {
    * @param data A {@link ParsableByteArray} from which the header should be read.
    * @return The parsed header, or null if the ID3 tag is unsupported.
    */
-  private static Id3Header decodeHeader(ParsableByteArray data) {
+  private static @Nullable Id3Header decodeHeader(ParsableByteArray data) {
     if (data.bytesLeft() < ID3_HEADER_LENGTH) {
       Log.w(TAG, "Data too short to be an ID3 tag");
       return null;
@@ -270,8 +268,12 @@ private static boolean validateFrames(ParsableByteArray id3Data, int majorVersio
     }
   }
 
-  private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
-      boolean unsignedIntFrameSizeHack, int frameHeaderSize, FramePredicate framePredicate) {
+  private static @Nullable Id3Frame decodeFrame(
+      int majorVersion,
+      ParsableByteArray id3Data,
+      boolean unsignedIntFrameSizeHack,
+      int frameHeaderSize,
+      @Nullable FramePredicate framePredicate) {
     int frameId0 = id3Data.readUnsignedByte();
     int frameId1 = id3Data.readUnsignedByte();
     int frameId2 = id3Data.readUnsignedByte();
@@ -381,6 +383,8 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
       } else if (frameId0 == 'C' && frameId1 == 'T' && frameId2 == 'O' && frameId3 == 'C') {
         frame = decodeChapterTOCFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
             frameHeaderSize, framePredicate);
+      } else if (frameId0 == 'M' && frameId1 == 'L' && frameId2 == 'L' && frameId3 == 'T') {
+        frame = decodeMlltFrame(id3Data, frameSize);
       } else {
         String id = getFrameId(majorVersion, frameId0, frameId1, frameId2, frameId3);
         frame = decodeBinaryFrame(id3Data, frameSize, id);
@@ -399,8 +403,8 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
     }
   }
 
-  private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
-      throws UnsupportedEncodingException {
+  private static @Nullable TextInformationFrame decodeTxxxFrame(
+      ParsableByteArray id3Data, int frameSize) throws UnsupportedEncodingException {
     if (frameSize < 1) {
       // Frame is malformed.
       return null;
@@ -422,8 +426,8 @@ private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, i
     return new TextInformationFrame("TXXX", description, value);
   }
 
-  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
-      int frameSize, String id) throws UnsupportedEncodingException {
+  private static @Nullable TextInformationFrame decodeTextInformationFrame(
+      ParsableByteArray id3Data, int frameSize, String id) throws UnsupportedEncodingException {
     if (frameSize < 1) {
       // Frame is malformed.
       return null;
@@ -441,7 +445,7 @@ private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray
     return new TextInformationFrame(id, null, value);
   }
 
-  private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
+  private static @Nullable UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     if (frameSize < 1) {
       // Frame is malformed.
@@ -552,7 +556,7 @@ private static ApicFrame decodeApicFrame(ParsableByteArray id3Data, int frameSiz
     return new ApicFrame(mimeType, description, pictureType, pictureData);
   }
 
-  private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int frameSize)
+  private static @Nullable CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     if (frameSize < 4) {
       // Frame is malformed.
@@ -579,9 +583,14 @@ private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int fr
     return new CommentFrame(language, description, text);
   }
 
-  private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data, int frameSize,
-      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize,
-      FramePredicate framePredicate) throws UnsupportedEncodingException {
+  private static ChapterFrame decodeChapterFrame(
+      ParsableByteArray id3Data,
+      int frameSize,
+      int majorVersion,
+      boolean unsignedIntFrameSizeHack,
+      int frameHeaderSize,
+      @Nullable FramePredicate framePredicate)
+      throws UnsupportedEncodingException {
     int framePosition = id3Data.getPosition();
     int chapterIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
     String chapterId = new String(id3Data.data, framePosition, chapterIdEndIndex - framePosition,
@@ -614,9 +623,14 @@ private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data, int fr
     return new ChapterFrame(chapterId, startTime, endTime, startOffset, endOffset, subFrameArray);
   }
 
-  private static ChapterTocFrame decodeChapterTOCFrame(ParsableByteArray id3Data, int frameSize,
-      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize,
-      FramePredicate framePredicate) throws UnsupportedEncodingException {
+  private static ChapterTocFrame decodeChapterTOCFrame(
+      ParsableByteArray id3Data,
+      int frameSize,
+      int majorVersion,
+      boolean unsignedIntFrameSizeHack,
+      int frameHeaderSize,
+      @Nullable FramePredicate framePredicate)
+      throws UnsupportedEncodingException {
     int framePosition = id3Data.getPosition();
     int elementIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
     String elementId = new String(id3Data.data, framePosition, elementIdEndIndex - framePosition,
@@ -651,6 +665,36 @@ private static ChapterTocFrame decodeChapterTOCFrame(ParsableByteArray id3Data,
     return new ChapterTocFrame(elementId, isRoot, isOrdered, children, subFrameArray);
   }
 
+  private static MlltFrame decodeMlltFrame(ParsableByteArray id3Data, int frameSize) {
+    // See ID3v2.4.0 native frames subsection 4.6.
+    int mpegFramesBetweenReference = id3Data.readUnsignedShort();
+    int bytesBetweenReference = id3Data.readUnsignedInt24();
+    int millisecondsBetweenReference = id3Data.readUnsignedInt24();
+    int bitsForBytesDeviation = id3Data.readUnsignedByte();
+    int bitsForMillisecondsDeviation = id3Data.readUnsignedByte();
+
+    ParsableBitArray references = new ParsableBitArray();
+    references.reset(id3Data);
+    int referencesBits = 8 * (frameSize - 10);
+    int bitsPerReference = bitsForBytesDeviation + bitsForMillisecondsDeviation;
+    int referencesCount = referencesBits / bitsPerReference;
+    int[] bytesDeviations = new int[referencesCount];
+    int[] millisecondsDeviations = new int[referencesCount];
+    for (int i = 0; i < referencesCount; i++) {
+      int bytesDeviation = references.readBits(bitsForBytesDeviation);
+      int millisecondsDeviation = references.readBits(bitsForMillisecondsDeviation);
+      bytesDeviations[i] = bytesDeviation;
+      millisecondsDeviations[i] = millisecondsDeviation;
+    }
+
+    return new MlltFrame(
+        mpegFramesBetweenReference,
+        bytesBetweenReference,
+        millisecondsBetweenReference,
+        bytesDeviations,
+        millisecondsDeviations);
+  }
+
   private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int frameSize,
       String id) {
     byte[] frame = new byte[frameSize];
@@ -686,14 +730,13 @@ private static int removeUnsynchronization(ParsableByteArray data, int length) {
    */
   private static String getCharsetName(int encodingByte) {
     switch (encodingByte) {
-      case ID3_TEXT_ENCODING_ISO_8859_1:
-        return "ISO-8859-1";
       case ID3_TEXT_ENCODING_UTF_16:
         return "UTF-16";
       case ID3_TEXT_ENCODING_UTF_16BE:
         return "UTF-16BE";
       case ID3_TEXT_ENCODING_UTF_8:
         return "UTF-8";
+      case ID3_TEXT_ENCODING_ISO_8859_1:
       default:
         return "ISO-8859-1";
     }
@@ -749,7 +792,7 @@ private static int delimiterLength(int encodingByte) {
   private static byte[] copyOfRangeIfValid(byte[] data, int from, int to) {
     if (to <= from) {
       // Invalid or zero length range.
-      return new byte[0];
+      return Util.EMPTY_BYTE_ARRAY;
     }
     return Arrays.copyOfRange(data, from, to);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java
index 433c52bdcc..27ea833deb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.metadata.id3;
 
 import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.util.Assertions;
 
 /**
  * Base class for ID3 frames.
@@ -29,7 +28,7 @@
   public final String id;
 
   public Id3Frame(String id) {
-    this.id = Assertions.checkNotNull(id);
+    this.id = id;
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java
new file mode 100644
index 0000000000..c191676ce2
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
+
+/** Internal ID3 frame that is intended for use by the player. */
+public final class InternalFrame extends Id3Frame {
+
+  public static final String ID = "----";
+
+  public final String domain;
+  public final String description;
+  public final String text;
+
+  public InternalFrame(String domain, String description, String text) {
+    super(ID);
+    this.domain = domain;
+    this.description = description;
+    this.text = text;
+  }
+
+  /* package */ InternalFrame(Parcel in) {
+    super(ID);
+    domain = castNonNull(in.readString());
+    description = castNonNull(in.readString());
+    text = castNonNull(in.readString());
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    InternalFrame other = (InternalFrame) obj;
+    return Util.areEqual(description, other.description)
+        && Util.areEqual(domain, other.domain)
+        && Util.areEqual(text, other.text);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (domain != null ? domain.hashCode() : 0);
+    result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + (text != null ? text.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return id + ": domain=" + domain + ", description=" + description;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeString(domain);
+    dest.writeString(text);
+  }
+
+  public static final Creator<InternalFrame> CREATOR =
+      new Creator<InternalFrame>() {
+
+        @Override
+        public InternalFrame createFromParcel(Parcel in) {
+          return new InternalFrame(in);
+        }
+
+        @Override
+        public InternalFrame[] newArray(int size) {
+          return new InternalFrame[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
new file mode 100644
index 0000000000..06a4dd9d2d
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+import java.util.Arrays;
+
+/** MPEG location lookup table frame. */
+public final class MlltFrame extends Id3Frame {
+
+  public static final String ID = "MLLT";
+
+  public final int mpegFramesBetweenReference;
+  public final int bytesBetweenReference;
+  public final int millisecondsBetweenReference;
+  public final int[] bytesDeviations;
+  public final int[] millisecondsDeviations;
+
+  public MlltFrame(
+      int mpegFramesBetweenReference,
+      int bytesBetweenReference,
+      int millisecondsBetweenReference,
+      int[] bytesDeviations,
+      int[] millisecondsDeviations) {
+    super(ID);
+    this.mpegFramesBetweenReference = mpegFramesBetweenReference;
+    this.bytesBetweenReference = bytesBetweenReference;
+    this.millisecondsBetweenReference = millisecondsBetweenReference;
+    this.bytesDeviations = bytesDeviations;
+    this.millisecondsDeviations = millisecondsDeviations;
+  }
+
+  /* package */ MlltFrame(Parcel in) {
+    super(ID);
+    this.mpegFramesBetweenReference = in.readInt();
+    this.bytesBetweenReference = in.readInt();
+    this.millisecondsBetweenReference = in.readInt();
+    this.bytesDeviations = in.createIntArray();
+    this.millisecondsDeviations = in.createIntArray();
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    MlltFrame other = (MlltFrame) obj;
+    return mpegFramesBetweenReference == other.mpegFramesBetweenReference
+        && bytesBetweenReference == other.bytesBetweenReference
+        && millisecondsBetweenReference == other.millisecondsBetweenReference
+        && Arrays.equals(bytesDeviations, other.bytesDeviations)
+        && Arrays.equals(millisecondsDeviations, other.millisecondsDeviations);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + mpegFramesBetweenReference;
+    result = 31 * result + bytesBetweenReference;
+    result = 31 * result + millisecondsBetweenReference;
+    result = 31 * result + Arrays.hashCode(bytesDeviations);
+    result = 31 * result + Arrays.hashCode(millisecondsDeviations);
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(mpegFramesBetweenReference);
+    dest.writeInt(bytesBetweenReference);
+    dest.writeInt(millisecondsBetweenReference);
+    dest.writeIntArray(bytesDeviations);
+    dest.writeIntArray(millisecondsDeviations);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Creator<MlltFrame> CREATOR =
+      new Creator<MlltFrame>() {
+
+        @Override
+        public MlltFrame createFromParcel(Parcel in) {
+          return new MlltFrame(in);
+        }
+
+        @Override
+        public MlltFrame[] newArray(int size) {
+          return new MlltFrame[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
index 1b5ba67c11..a10ce229d9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -39,8 +41,8 @@ public PrivFrame(String owner, byte[] privateData) {
 
   /* package */ PrivFrame(Parcel in) {
     super(ID);
-    owner = in.readString();
-    privateData = in.createByteArray();
+    owner = castNonNull(in.readString());
+    privateData = castNonNull(in.createByteArray());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
index dbab4ca7a8..62175ee90c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -25,19 +27,19 @@
  */
 public final class TextInformationFrame extends Id3Frame {
 
-  public final String description;
+  public final @Nullable String description;
   public final String value;
 
-  public TextInformationFrame(String id, String description, String value) {
+  public TextInformationFrame(String id, @Nullable String description, String value) {
     super(id);
     this.description = description;
     this.value = value;
   }
 
   /* package */ TextInformationFrame(Parcel in) {
-    super(in.readString());
+    super(castNonNull(in.readString()));
     description = in.readString();
-    value = in.readString();
+    value = castNonNull(in.readString());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
index f657eefc30..4b35131bea 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.annotation.Nullable;
@@ -25,19 +27,19 @@
  */
 public final class UrlLinkFrame extends Id3Frame {
 
-  public final String description;
+  public final @Nullable String description;
   public final String url;
 
-  public UrlLinkFrame(String id, String description, String url) {
+  public UrlLinkFrame(String id, @Nullable String description, String url) {
     super(id);
     this.description = description;
     this.url = url;
   }
 
   /* package */ UrlLinkFrame(Parcel in) {
-    super(in.readString());
+    super(castNonNull(in.readString()));
     description = in.readString();
-    url = in.readString();
+    url = castNonNull(in.readString());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
index 4050daa1cb..1153f918fc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
@@ -17,7 +17,6 @@
 
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
-import com.google.android.exoplayer2.metadata.MetadataDecoderException;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -45,8 +44,9 @@ public SpliceInfoDecoder() {
     sectionHeader = new ParsableBitArray();
   }
 
+  @SuppressWarnings("ByteBufferBackingArray")
   @Override
-  public Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException {
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
     // Internal timestamps adjustment.
     if (timestampAdjuster == null
         || inputBuffer.subsampleOffsetUs != timestampAdjuster.getTimestampOffsetUs()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java
index 98360b909c..e9868ceea0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java
@@ -17,6 +17,8 @@
 
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -24,6 +26,8 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /** Contains the necessary parameters for a download or remove action. */
 public abstract class DownloadAction {
@@ -50,6 +54,48 @@ public abstract DownloadAction readFromStream(int version, DataInputStream input
         throws IOException;
   }
 
+  private static @Nullable Deserializer[] defaultDeserializers;
+
+  /** Returns available default {@link Deserializer}s. */
+  public static synchronized Deserializer[] getDefaultDeserializers() {
+    if (defaultDeserializers != null) {
+      return defaultDeserializers;
+    }
+    Deserializer[] deserializers = new Deserializer[4];
+    int count = 0;
+    deserializers[count++] = ProgressiveDownloadAction.DESERIALIZER;
+    Class<?> clazz;
+    // Full class names used for constructor args so the LINT rule triggers if any of them move.
+    try {
+      // LINT.IfChange
+      clazz = Class.forName("com.google.android.exoplayer2.source.dash.offline.DashDownloadAction");
+      // LINT.ThenChange(../../../../../../../../../dash/proguard-rules.txt)
+      deserializers[count++] = getDeserializer(clazz);
+    } catch (Exception e) {
+      // Do nothing.
+    }
+    try {
+      // LINT.IfChange
+      clazz = Class.forName("com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction");
+      // LINT.ThenChange(../../../../../../../../../hls/proguard-rules.txt)
+      deserializers[count++] = getDeserializer(clazz);
+    } catch (Exception e) {
+      // Do nothing.
+    }
+    try {
+      // LINT.IfChange
+      clazz =
+          Class.forName(
+              "com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction");
+      // LINT.ThenChange(../../../../../../../../../smoothstreaming/proguard-rules.txt)
+      deserializers[count++] = getDeserializer(clazz);
+    } catch (Exception e) {
+      // Do nothing.
+    }
+    defaultDeserializers = Arrays.copyOf(Assertions.checkNotNull(deserializers), count);
+    return defaultDeserializers;
+  }
+
   /**
    * Deserializes one action that was serialized with {@link #serializeToStream(DownloadAction,
    * OutputStream)} from the {@code input}, using the {@link Deserializer}s that supports the
@@ -112,7 +158,7 @@ protected DownloadAction(
     this.version = version;
     this.uri = uri;
     this.isRemoveAction = isRemoveAction;
-    this.data = data != null ? data : new byte[0];
+    this.data = data != null ? data : Util.EMPTY_BYTE_ARRAY;
   }
 
   /** Serializes itself into a byte array. */
@@ -132,13 +178,19 @@ public boolean isSameMedia(DownloadAction other) {
     return uri.equals(other.uri);
   }
 
+  /** Returns keys of tracks to be downloaded. */
+  public List<StreamKey> getKeys() {
+    return Collections.emptyList();
+  }
+
   /** Serializes itself into the {@code output}. */
   protected abstract void writeToStream(DataOutputStream output) throws IOException;
 
   /** Creates a {@link Downloader} with the given parameters. */
-  protected abstract Downloader createDownloader(
+  public abstract Downloader createDownloader(
       DownloaderConstructorHelper downloaderConstructorHelper);
 
+  @SuppressWarnings("EqualsGetClass")
   @Override
   public boolean equals(@Nullable Object o) {
     if (o == null || getClass() != o.getClass()) {
@@ -160,4 +212,9 @@ public int hashCode() {
     return result;
   }
 
+  private static Deserializer getDeserializer(Class<?> clazz)
+      throws NoSuchFieldException, IllegalAccessException {
+    Object value = clazz.getDeclaredField("DESERIALIZER").get(null);
+    return (Deserializer) Assertions.checkNotNull(value);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
index f6157c1dc3..bb82df7a48 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
@@ -59,21 +59,9 @@ public void prepare(final Callback callback) {
       public void run() {
         try {
           prepareInternal();
-          handler.post(
-              new Runnable() {
-                @Override
-                public void run() {
-                  callback.onPrepared(DownloadHelper.this);
-                }
-              });
+          handler.post(() -> callback.onPrepared(DownloadHelper.this));
         } catch (final IOException e) {
-          handler.post(
-              new Runnable() {
-                @Override
-                public void run() {
-                  callback.onPrepareError(DownloadHelper.this, e);
-                }
-              });
+          handler.post(() -> callback.onPrepareError(DownloadHelper.this, e));
         }
       }
     }.start();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
index b3f1d3da6a..409f79f30b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
@@ -27,16 +27,17 @@
 import android.os.Looper;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.DownloadAction.Deserializer;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -108,7 +109,8 @@
    * @param upstreamDataSourceFactory A {@link DataSource.Factory} for creating data sources for
    *     downloading upstream data.
    * @param actionSaveFile File to save active actions.
-   * @param deserializers Used to deserialize {@link DownloadAction}s.
+   * @param deserializers Used to deserialize {@link DownloadAction}s. If empty, {@link
+   *     DownloadAction#getDefaultDeserializers()} is used instead.
    */
   public DownloadManager(
       Cache cache,
@@ -127,7 +129,8 @@ public DownloadManager(
    * @param constructorHelper A {@link DownloaderConstructorHelper} to create {@link Downloader}s
    *     for downloading data.
    * @param actionFile The file in which active actions are saved.
-   * @param deserializers Used to deserialize {@link DownloadAction}s.
+   * @param deserializers Used to deserialize {@link DownloadAction}s. If empty, {@link
+   *     DownloadAction#getDefaultDeserializers()} is used instead.
    */
   public DownloadManager(
       DownloaderConstructorHelper constructorHelper,
@@ -149,7 +152,8 @@ public DownloadManager(
    * @param maxSimultaneousDownloads The maximum number of simultaneous download tasks.
    * @param minRetryCount The minimum number of times a task must be retried before failing.
    * @param actionFile The file in which active actions are saved.
-   * @param deserializers Used to deserialize {@link DownloadAction}s.
+   * @param deserializers Used to deserialize {@link DownloadAction}s. If empty, {@link
+   *     DownloadAction#getDefaultDeserializers()} is used instead.
    */
   public DownloadManager(
       DownloaderConstructorHelper constructorHelper,
@@ -157,13 +161,12 @@ public DownloadManager(
       int minRetryCount,
       File actionFile,
       Deserializer... deserializers) {
-    Assertions.checkArgument(deserializers.length > 0, "At least one Deserializer is required.");
-
     this.downloaderConstructorHelper = constructorHelper;
     this.maxActiveDownloadTasks = maxSimultaneousDownloads;
     this.minRetryCount = minRetryCount;
     this.actionFile = new ActionFile(actionFile);
-    this.deserializers = deserializers;
+    this.deserializers =
+        deserializers.length > 0 ? deserializers : DownloadAction.getDefaultDeserializers();
     this.downloadsStopped = true;
 
     tasks = new ArrayList<>();
@@ -334,12 +337,7 @@ public void release() {
       tasks.get(i).stop();
     }
     final ConditionVariable fileIOFinishedCondition = new ConditionVariable();
-    fileIOHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        fileIOFinishedCondition.open();
-      }
-    });
+    fileIOHandler.post(fileIOFinishedCondition::open);
     fileIOFinishedCondition.block();
     fileIOThread.quit();
     logd("Released");
@@ -449,51 +447,45 @@ private void notifyListenersTaskStateChange(Task task) {
 
   private void loadActions() {
     fileIOHandler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            DownloadAction[] loadedActions;
-            try {
-              loadedActions = actionFile.load(DownloadManager.this.deserializers);
-              logd("Action file is loaded.");
-            } catch (Throwable e) {
-              Log.e(TAG, "Action file loading failed.", e);
-              loadedActions = new DownloadAction[0];
-            }
-            final DownloadAction[] actions = loadedActions;
-            handler.post(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    if (released) {
-                      return;
-                    }
-                    List<Task> pendingTasks = new ArrayList<>(tasks);
-                    tasks.clear();
-                    for (DownloadAction action : actions) {
-                      addTaskForAction(action);
-                    }
-                    logd("Tasks are created.");
-                    initialized = true;
-                    for (Listener listener : listeners) {
-                      listener.onInitialized(DownloadManager.this);
-                    }
-                    if (!pendingTasks.isEmpty()) {
-                      tasks.addAll(pendingTasks);
-                      saveActions();
-                    }
-                    maybeStartTasks();
-                    for (int i = 0; i < tasks.size(); i++) {
-                      Task task = tasks.get(i);
-                      if (task.currentState == STATE_QUEUED) {
-                        // Task did not change out of its initial state, and so its initial state
-                        // won't have been reported to listeners. Do so now.
-                        notifyListenersTaskStateChange(task);
-                      }
-                    }
-                  }
-                });
+        () -> {
+          DownloadAction[] loadedActions;
+          try {
+            loadedActions = actionFile.load(DownloadManager.this.deserializers);
+            logd("Action file is loaded.");
+          } catch (Throwable e) {
+            Log.e(TAG, "Action file loading failed.", e);
+            loadedActions = new DownloadAction[0];
           }
+          final DownloadAction[] actions = loadedActions;
+          handler.post(
+              () -> {
+                if (released) {
+                  return;
+                }
+                List<Task> pendingTasks = new ArrayList<>(tasks);
+                tasks.clear();
+                for (DownloadAction action : actions) {
+                  addTaskForAction(action);
+                }
+                logd("Tasks are created.");
+                initialized = true;
+                for (Listener listener : listeners) {
+                  listener.onInitialized(DownloadManager.this);
+                }
+                if (!pendingTasks.isEmpty()) {
+                  tasks.addAll(pendingTasks);
+                  saveActions();
+                }
+                maybeStartTasks();
+                for (int i = 0; i < tasks.size(); i++) {
+                  Task task = tasks.get(i);
+                  if (task.currentState == STATE_QUEUED) {
+                    // Task did not change out of its initial state, and so its initial state
+                    // won't have been reported to listeners. Do so now.
+                    notifyListenersTaskStateChange(task);
+                  }
+                }
+              });
         });
   }
 
@@ -505,17 +497,15 @@ private void saveActions() {
     for (int i = 0; i < tasks.size(); i++) {
       actions[i] = tasks.get(i).action;
     }
-    fileIOHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          actionFile.store(actions);
-          logd("Actions persisted.");
-        } catch (IOException e) {
-          Log.e(TAG, "Persisting actions failed.", e);
-        }
-      }
-    });
+    fileIOHandler.post(
+        () -> {
+          try {
+            actionFile.store(actions);
+            logd("Actions persisted.");
+          } catch (IOException e) {
+            Log.e(TAG, "Persisting actions failed.", e);
+          }
+        });
   }
 
   private static void logd(String message) {
@@ -532,7 +522,8 @@ private static void logd(String message, Task task) {
   public static final class TaskState {
 
     /**
-     * Task states.
+     * Task states. One of {@link #STATE_QUEUED}, {@link #STATE_STARTED}, {@link #STATE_COMPLETED},
+     * {@link #STATE_CANCELED} or {@link #STATE_FAILED}.
      *
      * <p>Transition diagram:
      *
@@ -542,6 +533,7 @@ private static void logd(String message, Task task) {
      *                    -&gt; failed
      * </pre>
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({STATE_QUEUED, STATE_STARTED, STATE_COMPLETED, STATE_CANCELED, STATE_FAILED})
     public @interface State {}
@@ -612,7 +604,10 @@ private TaskState(
   private static final class Task implements Runnable {
 
     /**
-     * Task states.
+     * Task states. One of {@link TaskState#STATE_QUEUED}, {@link TaskState#STATE_STARTED}, {@link
+     * TaskState#STATE_COMPLETED}, {@link TaskState#STATE_CANCELED}, {@link TaskState#STATE_FAILED},
+     * {@link #STATE_QUEUED_CANCELING}, {@link #STATE_STARTED_CANCELING} or {@link
+     * #STATE_STARTED_STOPPING}.
      *
      * <p>Transition map (vertical states are source states):
      *
@@ -628,6 +623,7 @@ private TaskState(
      * +-----------+------+-------+---------+-----------+-----------+--------+--------+------+
      * </pre>
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
       STATE_QUEUED,
@@ -728,6 +724,11 @@ private String getStateString() {
           return "CANCELING";
         case STATE_STARTED_STOPPING:
           return "STOPPING";
+        case STATE_QUEUED:
+        case STATE_STARTED:
+        case STATE_COMPLETED:
+        case STATE_CANCELED:
+        case STATE_FAILED:
         default:
           return TaskState.getStateString(currentState);
       }
@@ -740,6 +741,11 @@ private int getExternalState() {
         case STATE_STARTED_CANCELING:
         case STATE_STARTED_STOPPING:
           return STATE_STARTED;
+        case STATE_QUEUED:
+        case STATE_STARTED:
+        case STATE_COMPLETED:
+        case STATE_CANCELED:
+        case STATE_FAILED:
         default:
           return currentState;
       }
@@ -759,12 +765,7 @@ private boolean canStart() {
     private void cancel() {
       if (changeStateAndNotify(STATE_QUEUED, STATE_QUEUED_CANCELING)) {
         downloadManager.handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                changeStateAndNotify(STATE_QUEUED_CANCELING, STATE_CANCELED);
-              }
-            });
+            () -> changeStateAndNotify(STATE_QUEUED_CANCELING, STATE_CANCELED));
       } else if (changeStateAndNotify(STATE_STARTED, STATE_STARTED_CANCELING)) {
         cancelDownload();
       }
@@ -773,7 +774,7 @@ public void run() {
     private void stop() {
       if (changeStateAndNotify(STATE_STARTED, STATE_STARTED_STOPPING)) {
         logd("Stopping", this);
-        thread.interrupt();
+        cancelDownload();
       }
     }
 
@@ -839,19 +840,14 @@ public void run() {
       }
       final Throwable finalError = error;
       downloadManager.handler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              if (changeStateAndNotify(
-                      STATE_STARTED,
-                      finalError != null ? STATE_FAILED : STATE_COMPLETED,
-                      finalError)
-                  || changeStateAndNotify(STATE_STARTED_CANCELING, STATE_CANCELED)
-                  || changeStateAndNotify(STATE_STARTED_STOPPING, STATE_QUEUED)) {
-                return;
-              }
-              throw new IllegalStateException();
+          () -> {
+            if (changeStateAndNotify(
+                    STATE_STARTED, finalError != null ? STATE_FAILED : STATE_COMPLETED, finalError)
+                || changeStateAndNotify(STATE_STARTED_CANCELING, STATE_CANCELED)
+                || changeStateAndNotify(STATE_STARTED_STOPPING, STATE_QUEUED)) {
+              return;
             }
+            throw new IllegalStateException();
           });
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
index 6dae3f70b3..5c6cf88b48 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
@@ -24,11 +24,11 @@
 import android.os.Looper;
 import android.support.annotation.Nullable;
 import android.support.annotation.StringRes;
-import android.util.Log;
 import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
 import com.google.android.exoplayer2.scheduler.Requirements;
 import com.google.android.exoplayer2.scheduler.RequirementsWatcher;
 import com.google.android.exoplayer2.scheduler.Scheduler;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.NotificationUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -44,21 +44,20 @@
   /** Starts a download service, adding a new {@link DownloadAction} to be executed. */
   public static final String ACTION_ADD = "com.google.android.exoplayer.downloadService.action.ADD";
 
+  /** Reloads the download requirements. */
+  public static final String ACTION_RELOAD_REQUIREMENTS =
+      "com.google.android.exoplayer.downloadService.action.RELOAD_REQUIREMENTS";
+
   /** Like {@link #ACTION_INIT}, but with {@link #KEY_FOREGROUND} implicitly set to true. */
   private static final String ACTION_RESTART =
       "com.google.android.exoplayer.downloadService.action.RESTART";
 
-  /** Starts download tasks. */
-  private static final String ACTION_START_DOWNLOADS =
-      "com.google.android.exoplayer.downloadService.action.START_DOWNLOADS";
-
-  /** Stops download tasks. */
-  private static final String ACTION_STOP_DOWNLOADS =
-      "com.google.android.exoplayer.downloadService.action.STOP_DOWNLOADS";
-
   /** Key for the {@link DownloadAction} in an {@link #ACTION_ADD} intent. */
   public static final String KEY_DOWNLOAD_ACTION = "download_action";
 
+  /** Invalid foreground notification id which can be used to run the service in the background. */
+  public static final int FOREGROUND_NOTIFICATION_ID_NONE = 0;
+
   /**
    * Key for a boolean flag in any intent to indicate whether the service was started in the
    * foreground. If set, the service is guaranteed to call {@link #startForeground(int,
@@ -77,8 +76,10 @@
   // tasks the resume more quickly than when relying on the scheduler alone.
   private static final HashMap<Class<? extends DownloadService>, RequirementsHelper>
       requirementsHelpers = new HashMap<>();
+  private static final Requirements DEFAULT_REQUIREMENTS =
+      new Requirements(Requirements.NETWORK_TYPE_ANY, false, false);
 
-  private final ForegroundNotificationUpdater foregroundNotificationUpdater;
+  private final @Nullable ForegroundNotificationUpdater foregroundNotificationUpdater;
   private final @Nullable String channelId;
   private final @StringRes int channelName;
 
@@ -86,18 +87,31 @@
   private DownloadManagerListener downloadManagerListener;
   private int lastStartId;
   private boolean startedInForeground;
+  private boolean taskRemoved;
 
   /**
-   * Creates a DownloadService with {@link #DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL}.
+   * Creates a DownloadService.
    *
-   * @param foregroundNotificationId The notification id for the foreground notification, must not
-   *     be 0.
+   * <p>If {@code foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE} (value
+   * {@value #FOREGROUND_NOTIFICATION_ID_NONE}) then the service runs in the background. No
+   * foreground notification is displayed and {@link #getScheduler()} isn't called.
+   *
+   * <p>If {@code foregroundNotificationId} isn't {@link #FOREGROUND_NOTIFICATION_ID_NONE} (value
+   * {@value #FOREGROUND_NOTIFICATION_ID_NONE}) the service runs in the foreground with {@link
+   * #DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL}. In that case {@link
+   * #getForegroundNotification(TaskState[])} should be overridden in the subclass.
+   *
+   * @param foregroundNotificationId The notification id for the foreground notification, or {@link
+   *     #FOREGROUND_NOTIFICATION_ID_NONE} (value {@value #FOREGROUND_NOTIFICATION_ID_NONE})
    */
   protected DownloadService(int foregroundNotificationId) {
     this(foregroundNotificationId, DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL);
   }
 
   /**
+   * Creates a DownloadService which will run in the foreground. {@link
+   * #getForegroundNotification(TaskState[])} should be overridden in the subclass.
+   *
    * @param foregroundNotificationId The notification id for the foreground notification, must not
    *     be 0.
    * @param foregroundNotificationUpdateInterval The maximum interval to update foreground
@@ -113,6 +127,9 @@ protected DownloadService(
   }
 
   /**
+   * Creates a DownloadService which will run in the foreground. {@link
+   * #getForegroundNotification(TaskState[])} should be overridden in the subclass.
+   *
    * @param foregroundNotificationId The notification id for the foreground notification. Must not
    *     be 0.
    * @param foregroundNotificationUpdateInterval The maximum interval between updates to the
@@ -130,8 +147,10 @@ protected DownloadService(
       @Nullable String channelId,
       @StringRes int channelName) {
     foregroundNotificationUpdater =
-        new ForegroundNotificationUpdater(
-            foregroundNotificationId, foregroundNotificationUpdateInterval);
+        foregroundNotificationId == 0
+            ? null
+            : new ForegroundNotificationUpdater(
+                foregroundNotificationId, foregroundNotificationUpdateInterval);
     this.channelId = channelId;
     this.channelName = channelName;
   }
@@ -150,8 +169,7 @@ public static Intent buildAddActionIntent(
       Class<? extends DownloadService> clazz,
       DownloadAction downloadAction,
       boolean foreground) {
-    return new Intent(context, clazz)
-        .setAction(ACTION_ADD)
+    return getIntent(context, clazz, ACTION_ADD)
         .putExtra(KEY_DOWNLOAD_ACTION, downloadAction.toByteArray())
         .putExtra(KEY_FOREGROUND, foreground);
   }
@@ -186,7 +204,7 @@ public static void startWithAction(
    * @see #startForeground(Context, Class)
    */
   public static void start(Context context, Class<? extends DownloadService> clazz) {
-    context.startService(new Intent(context, clazz).setAction(ACTION_INIT));
+    context.startService(getIntent(context, clazz, ACTION_INIT));
   }
 
   /**
@@ -199,8 +217,7 @@ public static void start(Context context, Class<? extends DownloadService> clazz
    * @see #start(Context, Class)
    */
   public static void startForeground(Context context, Class<? extends DownloadService> clazz) {
-    Intent intent =
-        new Intent(context, clazz).setAction(ACTION_INIT).putExtra(KEY_FOREGROUND, true);
+    Intent intent = getIntent(context, clazz, ACTION_INIT).putExtra(KEY_FOREGROUND, true);
     Util.startForegroundService(context, intent);
   }
 
@@ -219,17 +236,22 @@ public void onCreate() {
   @Override
   public int onStartCommand(Intent intent, int flags, int startId) {
     lastStartId = startId;
+    taskRemoved = false;
     String intentAction = null;
     if (intent != null) {
       intentAction = intent.getAction();
       startedInForeground |=
           intent.getBooleanExtra(KEY_FOREGROUND, false) || ACTION_RESTART.equals(intentAction);
     }
+    // intentAction is null if the service is restarted or no action is specified.
+    if (intentAction == null) {
+      intentAction = ACTION_INIT;
+    }
     logd("onStartCommand action: " + intentAction + " startId: " + startId);
     switch (intentAction) {
       case ACTION_INIT:
       case ACTION_RESTART:
-        // Do nothing. The RequirementsWatcher will start downloads when possible.
+        // Do nothing.
         break;
       case ACTION_ADD:
         byte[] actionData = intent.getByteArrayExtra(KEY_DOWNLOAD_ACTION);
@@ -243,27 +265,40 @@ public int onStartCommand(Intent intent, int flags, int startId) {
           }
         }
         break;
-      case ACTION_STOP_DOWNLOADS:
-        downloadManager.stopDownloads();
-        break;
-      case ACTION_START_DOWNLOADS:
-        downloadManager.startDownloads();
+      case ACTION_RELOAD_REQUIREMENTS:
+        stopWatchingRequirements();
         break;
       default:
         Log.e(TAG, "Ignoring unrecognized action: " + intentAction);
         break;
     }
-    maybeStartWatchingRequirements();
+
+    Requirements requirements = getRequirements();
+    if (requirements.checkRequirements(this)) {
+      downloadManager.startDownloads();
+    } else {
+      downloadManager.stopDownloads();
+    }
+    maybeStartWatchingRequirements(requirements);
+
     if (downloadManager.isIdle()) {
       stop();
     }
     return START_STICKY;
   }
 
+  @Override
+  public void onTaskRemoved(Intent rootIntent) {
+    logd("onTaskRemoved rootIntent: " + rootIntent);
+    taskRemoved = true;
+  }
+
   @Override
   public void onDestroy() {
     logd("onDestroy");
-    foregroundNotificationUpdater.stopPeriodicUpdates();
+    if (foregroundNotificationUpdater != null) {
+      foregroundNotificationUpdater.stopPeriodicUpdates();
+    }
     downloadManager.removeListener(downloadManagerListener);
     maybeStopWatchingRequirements();
   }
@@ -294,11 +329,13 @@ public IBinder onBind(Intent intent) {
    * device has network connectivity.
    */
   protected Requirements getRequirements() {
-    return new Requirements(Requirements.NETWORK_TYPE_ANY, false, false);
+    return DEFAULT_REQUIREMENTS;
   }
 
   /**
-   * Returns a notification to be displayed when this service running in the foreground.
+   * Should be overridden in the subclass if the service will be run in the foreground.
+   *
+   * <p>Returns a notification to be displayed when this service running in the foreground.
    *
    * <p>This method is called when there is a task state change and periodically while there are
    * active tasks. The periodic update interval can be set using {@link #DownloadService(int,
@@ -311,7 +348,11 @@ protected Requirements getRequirements() {
    * @param taskStates The states of all current tasks.
    * @return The foreground notification to display.
    */
-  protected abstract Notification getForegroundNotification(TaskState[] taskStates);
+  protected Notification getForegroundNotification(TaskState[] taskStates) {
+    throw new IllegalStateException(
+        getClass().getName()
+            + " is started in the foreground but getForegroundNotification() is not implemented.");
+  }
 
   /**
    * Called when the state of a task changes.
@@ -322,14 +363,14 @@ protected void onTaskStateChanged(TaskState taskState) {
     // Do nothing.
   }
 
-  private void maybeStartWatchingRequirements() {
+  private void maybeStartWatchingRequirements(Requirements requirements) {
     if (downloadManager.getDownloadCount() == 0) {
       return;
     }
     Class<? extends DownloadService> clazz = getClass();
     RequirementsHelper requirementsHelper = requirementsHelpers.get(clazz);
     if (requirementsHelper == null) {
-      requirementsHelper = new RequirementsHelper(this, getRequirements(), getScheduler(), clazz);
+      requirementsHelper = new RequirementsHelper(this, requirements, getScheduler(), clazz);
       requirementsHelpers.put(clazz, requirementsHelper);
       requirementsHelper.start();
       logd("started watching requirements");
@@ -340,6 +381,10 @@ private void maybeStopWatchingRequirements() {
     if (downloadManager.getDownloadCount() > 0) {
       return;
     }
+    stopWatchingRequirements();
+  }
+
+  private void stopWatchingRequirements() {
     RequirementsHelper requirementsHelper = requirementsHelpers.remove(getClass());
     if (requirementsHelper != null) {
       requirementsHelper.stop();
@@ -348,13 +393,20 @@ private void maybeStopWatchingRequirements() {
   }
 
   private void stop() {
-    foregroundNotificationUpdater.stopPeriodicUpdates();
-    // Make sure startForeground is called before stopping. Workaround for [Internal: b/69424260].
-    if (startedInForeground && Util.SDK_INT >= 26) {
-      foregroundNotificationUpdater.showNotificationIfNotAlready();
+    if (foregroundNotificationUpdater != null) {
+      foregroundNotificationUpdater.stopPeriodicUpdates();
+      // Make sure startForeground is called before stopping. Workaround for [Internal: b/69424260].
+      if (startedInForeground && Util.SDK_INT >= 26) {
+        foregroundNotificationUpdater.showNotificationIfNotAlready();
+      }
+    }
+    if (Util.SDK_INT < 28 && taskRemoved) { // See [Internal: b/74248644].
+      stopSelf();
+      logd("stopSelf()");
+    } else {
+      boolean stopSelfResult = stopSelfResult(lastStartId);
+      logd("stopSelf(" + lastStartId + ") result: " + stopSelfResult);
     }
-    boolean stopSelfResult = stopSelfResult(lastStartId);
-    logd("stopSelf(" + lastStartId + ") result: " + stopSelfResult);
   }
 
   private void logd(String message) {
@@ -363,19 +415,26 @@ private void logd(String message) {
     }
   }
 
+  private static Intent getIntent(
+      Context context, Class<? extends DownloadService> clazz, String action) {
+    return new Intent(context, clazz).setAction(action);
+  }
+
   private final class DownloadManagerListener implements DownloadManager.Listener {
     @Override
     public void onInitialized(DownloadManager downloadManager) {
-      maybeStartWatchingRequirements();
+      maybeStartWatchingRequirements(getRequirements());
     }
 
     @Override
     public void onTaskStateChanged(DownloadManager downloadManager, TaskState taskState) {
       DownloadService.this.onTaskStateChanged(taskState);
-      if (taskState.state == TaskState.STATE_STARTED) {
-        foregroundNotificationUpdater.startPeriodicUpdates();
-      } else {
-        foregroundNotificationUpdater.update();
+      if (foregroundNotificationUpdater != null) {
+        if (taskState.state == TaskState.STATE_STARTED) {
+          foregroundNotificationUpdater.startPeriodicUpdates();
+        } else {
+          foregroundNotificationUpdater.update();
+        }
       }
     }
 
@@ -465,7 +524,12 @@ public void stop() {
 
     @Override
     public void requirementsMet(RequirementsWatcher requirementsWatcher) {
-      startServiceWithAction(DownloadService.ACTION_START_DOWNLOADS);
+      try {
+        notifyService();
+      } catch (Exception e) {
+        /* If we can't notify the service, don't stop the scheduler. */
+        return;
+      }
       if (scheduler != null) {
         scheduler.cancel();
       }
@@ -473,7 +537,11 @@ public void requirementsMet(RequirementsWatcher requirementsWatcher) {
 
     @Override
     public void requirementsNotMet(RequirementsWatcher requirementsWatcher) {
-      startServiceWithAction(DownloadService.ACTION_STOP_DOWNLOADS);
+      try {
+        notifyService();
+      } catch (Exception e) {
+        /* Do nothing. The service isn't running anyway. */
+      }
       if (scheduler != null) {
         String servicePackage = context.getPackageName();
         boolean success = scheduler.schedule(requirements, servicePackage, ACTION_RESTART);
@@ -483,10 +551,14 @@ public void requirementsNotMet(RequirementsWatcher requirementsWatcher) {
       }
     }
 
-    private void startServiceWithAction(String action) {
-      Intent intent =
-          new Intent(context, serviceClass).setAction(action).putExtra(KEY_FOREGROUND, true);
-      Util.startForegroundService(context, intent);
+    private void notifyService() throws Exception {
+      Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_INIT);
+      try {
+        context.startService(intent);
+      } catch (IllegalStateException e) {
+        /* startService will fail if the app is in the background and the service isn't running. */
+        throw new Exception(e);
+      }
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/FilterableManifest.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/FilterableManifest.java
index 35d05fd43b..e688b7216f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/FilterableManifest.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/FilterableManifest.java
@@ -22,9 +22,8 @@
  * keys.
  *
  * @param <T> The manifest type.
- * @param <K> The stream key type.
  */
-public interface FilterableManifest<T, K> {
+public interface FilterableManifest<T> {
 
   /**
    * Returns a copy of the manifest including only the streams specified by the given keys. If the
@@ -33,5 +32,5 @@
    * @param streamKeys A non-empty list of stream keys.
    * @return The filtered manifest.
    */
-  T copy(List<K> streamKeys);
+  T copy(List<StreamKey> streamKeys);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java
index 8fec07552b..c32cdf7126 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java
@@ -21,25 +21,24 @@
 import java.io.InputStream;
 import java.util.List;
 
-/** A manifest parser that includes only the tracks identified by the given track keys. */
-public final class FilteringManifestParser<T extends FilterableManifest<T, K>, K>
-    implements Parser<T> {
+/** A manifest parser that includes only the streams identified by the given stream keys. */
+public final class FilteringManifestParser<T extends FilterableManifest<T>> implements Parser<T> {
 
   private final Parser<T> parser;
-  private final List<K> trackKeys;
+  private final List<StreamKey> streamKeys;
 
   /**
    * @param parser A parser for the manifest that will be filtered.
-   * @param trackKeys The track keys. If null or empty then filtering will not occur.
+   * @param streamKeys The stream keys. If null or empty then filtering will not occur.
    */
-  public FilteringManifestParser(Parser<T> parser, List<K> trackKeys) {
+  public FilteringManifestParser(Parser<T> parser, List<StreamKey> streamKeys) {
     this.parser = parser;
-    this.trackKeys = trackKeys;
+    this.streamKeys = streamKeys;
   }
 
   @Override
   public T parse(Uri uri, InputStream inputStream) throws IOException {
     T manifest = parser.parse(uri, inputStream);
-    return trackKeys == null || trackKeys.isEmpty() ? manifest : manifest.copy(trackKeys);
+    return streamKeys == null || streamKeys.isEmpty() ? manifest : manifest.copy(streamKeys);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java
index d8db6f96c2..7ced2fa41b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java
@@ -44,7 +44,33 @@ public ProgressiveDownloadAction readFromStream(int version, DataInputStream inp
         }
       };
 
-  public final @Nullable String customCacheKey;
+  private final @Nullable String customCacheKey;
+
+  /**
+   * Creates a progressive stream download action.
+   *
+   * @param uri Uri of the data to be downloaded.
+   * @param data Optional custom data for this action.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
+   *     is used for cache indexing.
+   */
+  public static ProgressiveDownloadAction createDownloadAction(
+      Uri uri, @Nullable byte[] data, @Nullable String customCacheKey) {
+    return new ProgressiveDownloadAction(uri, /* isRemoveAction= */ false, data, customCacheKey);
+  }
+
+  /**
+   * Creates a progressive stream remove action.
+   *
+   * @param uri Uri of the data to be removed.
+   * @param data Optional custom data for this action.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
+   *     is used for cache indexing.
+   */
+  public static ProgressiveDownloadAction createRemoveAction(
+      Uri uri, @Nullable byte[] data, @Nullable String customCacheKey) {
+    return new ProgressiveDownloadAction(uri, /* isRemoveAction= */ true, data, customCacheKey);
+  }
 
   /**
    * @param uri Uri of the data to be downloaded.
@@ -52,7 +78,10 @@ public ProgressiveDownloadAction readFromStream(int version, DataInputStream inp
    * @param data Optional custom data for this action.
    * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
    *     is used for cache indexing.
+   * @deprecated Use {@link #createDownloadAction(Uri, byte[], String)} or {@link
+   *     #createRemoveAction(Uri, byte[], String)}.
    */
+  @Deprecated
   public ProgressiveDownloadAction(
       Uri uri, boolean isRemoveAction, @Nullable byte[] data, @Nullable String customCacheKey) {
     super(TYPE, VERSION, uri, isRemoveAction, data);
@@ -60,7 +89,7 @@ public ProgressiveDownloadAction(
   }
 
   @Override
-  protected ProgressiveDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
+  public ProgressiveDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
     return new ProgressiveDownloader(uri, customCacheKey, constructorHelper);
   }
 
@@ -105,4 +134,5 @@ public int hashCode() {
   private String getCacheKey() {
     return customCacheKey != null ? customCacheKey : CacheUtil.generateKey(uri);
   }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java
index 49b7e36ea6..473209803a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java
@@ -51,12 +51,13 @@ public TrackGroupArray getTrackGroups(int periodIndex) {
   }
 
   @Override
-  public DownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    return new ProgressiveDownloadAction(uri, false, data, customCacheKey);
+  public ProgressiveDownloadAction getDownloadAction(
+      @Nullable byte[] data, List<TrackKey> trackKeys) {
+    return ProgressiveDownloadAction.createDownloadAction(uri, data, customCacheKey);
   }
 
   @Override
-  public DownloadAction getRemoveAction(@Nullable byte[] data) {
-    return new ProgressiveDownloadAction(uri, true, data, customCacheKey);
+  public ProgressiveDownloadAction getRemoveAction(@Nullable byte[] data) {
+    return ProgressiveDownloadAction.createRemoveAction(uri, data, customCacheKey);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java
index ae57131641..403b4e797b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java
@@ -25,19 +25,11 @@
 import java.util.Collections;
 import java.util.List;
 
-/**
- * {@link DownloadAction} for {@link SegmentDownloader}s.
- *
- * @param <K> The type of the representation key object.
- */
-public abstract class SegmentDownloadAction<K extends Comparable<K>> extends DownloadAction {
+/** {@link DownloadAction} for {@link SegmentDownloader}s. */
+public abstract class SegmentDownloadAction extends DownloadAction {
 
-  /**
-   * Base class for {@link SegmentDownloadAction} {@link Deserializer}s.
-   *
-   * @param <K> The type of the representation key object.
-   */
-  protected abstract static class SegmentDownloadActionDeserializer<K> extends Deserializer {
+  /** Base class for {@link SegmentDownloadAction} {@link Deserializer}s. */
+  protected abstract static class SegmentDownloadActionDeserializer extends Deserializer {
 
     public SegmentDownloadActionDeserializer(String type, int version) {
       super(type, version);
@@ -52,22 +44,27 @@ public final DownloadAction readFromStream(int version, DataInputStream input)
       byte[] data = new byte[dataLength];
       input.readFully(data);
       int keyCount = input.readInt();
-      List<K> keys = new ArrayList<>();
+      List<StreamKey> keys = new ArrayList<>();
       for (int i = 0; i < keyCount; i++) {
-        keys.add(readKey(input));
+        keys.add(readKey(version, input));
       }
       return createDownloadAction(uri, isRemoveAction, data, keys);
     }
 
     /** Deserializes a key from the {@code input}. */
-    protected abstract K readKey(DataInputStream input) throws IOException;
+    protected StreamKey readKey(int version, DataInputStream input) throws IOException {
+      int periodIndex = input.readInt();
+      int groupIndex = input.readInt();
+      int trackIndex = input.readInt();
+      return new StreamKey(periodIndex, groupIndex, trackIndex);
+    }
 
     /** Returns a {@link DownloadAction}. */
     protected abstract DownloadAction createDownloadAction(
-        Uri manifestUri, boolean isRemoveAction, byte[] data, List<K> keys);
+        Uri manifestUri, boolean isRemoveAction, byte[] data, List<StreamKey> keys);
   }
 
-  public final List<K> keys;
+  public final List<StreamKey> keys;
 
   /**
    * @param type The type of the action.
@@ -84,18 +81,23 @@ protected SegmentDownloadAction(
       Uri uri,
       boolean isRemoveAction,
       @Nullable byte[] data,
-      List<K> keys) {
+      List<StreamKey> keys) {
     super(type, version, uri, isRemoveAction, data);
     if (isRemoveAction) {
       Assertions.checkArgument(keys.isEmpty());
       this.keys = Collections.emptyList();
     } else {
-      ArrayList<K> mutableKeys = new ArrayList<>(keys);
+      ArrayList<StreamKey> mutableKeys = new ArrayList<>(keys);
       Collections.sort(mutableKeys);
       this.keys = Collections.unmodifiableList(mutableKeys);
     }
   }
 
+  @Override
+  public List<StreamKey> getKeys() {
+    return keys;
+  }
+
   @Override
   public final void writeToStream(DataOutputStream output) throws IOException {
     output.writeUTF(uri.toString());
@@ -108,9 +110,6 @@ public final void writeToStream(DataOutputStream output) throws IOException {
     }
   }
 
-  /** Serializes the {@code key} into the {@code output}. */
-  protected abstract void writeKey(DataOutputStream output, K key) throws IOException;
-
   @Override
   public boolean equals(@Nullable Object o) {
     if (this == o) {
@@ -119,7 +118,7 @@ public boolean equals(@Nullable Object o) {
     if (!super.equals(o)) {
       return false;
     }
-    SegmentDownloadAction<?> that = (SegmentDownloadAction<?>) o;
+    SegmentDownloadAction that = (SegmentDownloadAction) o;
     return keys.equals(that.keys);
   }
 
@@ -130,4 +129,10 @@ public int hashCode() {
     return result;
   }
 
+  /** Serializes the {@code key} into the {@code output}. */
+  private void writeKey(DataOutputStream output, StreamKey key) throws IOException {
+    output.writeInt(key.periodIndex);
+    output.writeInt(key.groupIndex);
+    output.writeInt(key.trackIndex);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
index 9be694264c..625ec4f5e7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.upstream.cache.CacheUtil;
 import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -35,10 +36,8 @@
  * Base class for multi segment stream downloaders.
  *
  * @param <M> The type of the manifest object.
- * @param <K> The type of the streams key object.
  */
-public abstract class SegmentDownloader<M extends FilterableManifest<M, K>, K>
-    implements Downloader {
+public abstract class SegmentDownloader<M extends FilterableManifest<M>> implements Downloader {
 
   /** Smallest unit of content to be downloaded. */
   protected static class Segment implements Comparable<Segment> {
@@ -56,8 +55,7 @@ public Segment(long startTimeUs, DataSpec dataSpec) {
 
     @Override
     public int compareTo(@NonNull Segment other) {
-      long startOffsetDiff = startTimeUs - other.startTimeUs;
-      return startOffsetDiff == 0 ? 0 : ((startOffsetDiff < 0) ? -1 : 1);
+      return Util.compareLong(startTimeUs, other.startTimeUs);
     }
   }
 
@@ -68,7 +66,7 @@ public int compareTo(@NonNull Segment other) {
   private final Cache cache;
   private final CacheDataSource dataSource;
   private final CacheDataSource offlineDataSource;
-  private final ArrayList<K> streamKeys;
+  private final ArrayList<StreamKey> streamKeys;
   private final AtomicBoolean isCanceled;
 
   private volatile int totalSegments;
@@ -82,7 +80,7 @@ public int compareTo(@NonNull Segment other) {
    * @param constructorHelper A {@link DownloaderConstructorHelper} instance.
    */
   public SegmentDownloader(
-      Uri manifestUri, List<K> streamKeys, DownloaderConstructorHelper constructorHelper) {
+      Uri manifestUri, List<StreamKey> streamKeys, DownloaderConstructorHelper constructorHelper) {
     this.manifestUri = manifestUri;
     this.streamKeys = new ArrayList<>(streamKeys);
     this.cache = constructorHelper.getCache();
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/StreamKey.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
similarity index 50%
rename from library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/StreamKey.java
rename to library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
index 6667a3df27..838073cd99 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/StreamKey.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2018 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,25 +13,46 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.source.smoothstreaming.manifest;
+package com.google.android.exoplayer2.offline;
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
-/** Uniquely identifies a track in a {@link SsManifest}. */
+/**
+ * Identifies a given track by the index of the containing period, the index of the containing group
+ * within the period, and the index of the track within the group.
+ */
 public final class StreamKey implements Comparable<StreamKey> {
 
-  public final int streamElementIndex;
+  /** The period index. */
+  public final int periodIndex;
+  /** The group index. */
+  public final int groupIndex;
+  /** The track index. */
   public final int trackIndex;
 
-  public StreamKey(int streamElementIndex, int trackIndex) {
-    this.streamElementIndex = streamElementIndex;
+  /**
+   * @param groupIndex The group index.
+   * @param trackIndex The track index.
+   */
+  public StreamKey(int groupIndex, int trackIndex) {
+    this(0, groupIndex, trackIndex);
+  }
+
+  /**
+   * @param periodIndex The period index.
+   * @param groupIndex The group index.
+   * @param trackIndex The track index.
+   */
+  public StreamKey(int periodIndex, int groupIndex, int trackIndex) {
+    this.periodIndex = periodIndex;
+    this.groupIndex = groupIndex;
     this.trackIndex = trackIndex;
   }
 
   @Override
   public String toString() {
-    return streamElementIndex + "." + trackIndex;
+    return periodIndex + "." + groupIndex + "." + trackIndex;
   }
 
   @Override
@@ -44,12 +65,15 @@ public boolean equals(@Nullable Object o) {
     }
 
     StreamKey that = (StreamKey) o;
-    return streamElementIndex == that.streamElementIndex && trackIndex == that.trackIndex;
+    return periodIndex == that.periodIndex
+        && groupIndex == that.groupIndex
+        && trackIndex == that.trackIndex;
   }
 
   @Override
   public int hashCode() {
-    int result = streamElementIndex;
+    int result = periodIndex;
+    result = 31 * result + groupIndex;
     result = 31 * result + trackIndex;
     return result;
   }
@@ -58,9 +82,12 @@ public int hashCode() {
 
   @Override
   public int compareTo(@NonNull StreamKey o) {
-    int result = streamElementIndex - o.streamElementIndex;
+    int result = periodIndex - o.periodIndex;
     if (result == 0) {
-      result = trackIndex - o.trackIndex;
+      result = groupIndex - o.groupIndex;
+      if (result == 0) {
+        result = trackIndex - o.trackIndex;
+      }
     }
     return result;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
index b3737eb8bc..ed06d3745a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
@@ -25,7 +25,7 @@
 import android.content.Intent;
 import android.os.PersistableBundle;
 import android.support.annotation.RequiresPermission;
-import android.util.Log;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -34,6 +34,7 @@
  *
  * <pre>{@literal
  * <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+ * <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
  *
  * <service android:name="com.google.android.exoplayer2.util.scheduler.PlatformScheduler$PlatformSchedulerService"
  *     android:permission="android.permission.BIND_JOB_SERVICE"
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
index 30b07da3eb..5acd31ee0d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
@@ -25,8 +25,9 @@
 import android.os.BatteryManager;
 import android.os.PowerManager;
 import android.support.annotation.IntDef;
-import android.util.Log;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -35,7 +36,11 @@
  */
 public final class Requirements {
 
-  /** Network types. */
+  /**
+   * Network types. One of {@link #NETWORK_TYPE_NONE}, {@link #NETWORK_TYPE_ANY}, {@link
+   * #NETWORK_TYPE_UNMETERED}, {@link #NETWORK_TYPE_NOT_ROAMING} or {@link #NETWORK_TYPE_METERED}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NETWORK_TYPE_NONE,
@@ -182,7 +187,7 @@ private boolean checkIdleRequirement(Context context) {
     }
     PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
     return Util.SDK_INT >= 23
-        ? !powerManager.isDeviceIdleMode()
+        ? powerManager.isDeviceIdleMode()
         : Util.SDK_INT >= 20 ? !powerManager.isInteractive() : !powerManager.isScreenOn();
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
index 46aa55f094..d1eb28cc2a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
@@ -28,8 +28,8 @@
 import android.os.Looper;
 import android.os.PowerManager;
 import android.support.annotation.RequiresApi;
-import android.util.Log;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -87,7 +87,7 @@ public RequirementsWatcher(Context context, Listener listener, Requirements requ
   public void start() {
     Assertions.checkNotNull(Looper.myLooper());
 
-    checkRequirements(true);
+    requirementsWereMet = requirements.checkRequirements(context);
 
     IntentFilter filter = new IntentFilter();
     if (requirements.getRequiredNetworkType() != Requirements.NETWORK_TYPE_NONE) {
@@ -158,13 +158,11 @@ private void unregisterNetworkCallback() {
     }
   }
 
-  private void checkRequirements(boolean force) {
+  private void checkRequirements() {
     boolean requirementsAreMet = requirements.checkRequirements(context);
-    if (!force) {
-      if (requirementsAreMet == requirementsWereMet) {
-        logd("requirementsAreMet is still " + requirementsAreMet);
-        return;
-      }
+    if (requirementsAreMet == requirementsWereMet) {
+      logd("requirementsAreMet is still " + requirementsAreMet);
+      return;
     }
     requirementsWereMet = requirementsAreMet;
     if (requirementsAreMet) {
@@ -187,7 +185,7 @@ private static void logd(String message) {
     public void onReceive(Context context, Intent intent) {
       if (!isInitialStickyBroadcast()) {
         logd(RequirementsWatcher.this + " received " + intent.getAction());
-        checkRequirements(false);
+        checkRequirements();
       }
     }
   }
@@ -198,14 +196,14 @@ public void onReceive(Context context, Intent intent) {
     public void onAvailable(Network network) {
       super.onAvailable(network);
       logd(RequirementsWatcher.this + " NetworkCallback.onAvailable");
-      checkRequirements(false);
+      checkRequirements();
     }
 
     @Override
     public void onLost(Network network) {
       super.onLost(network);
       logd(RequirementsWatcher.this + " NetworkCallback.onLost");
-      checkRequirements(false);
+      checkRequirements();
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
index 8663b4c05c..4a3505749a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -29,6 +29,37 @@
   private final ShuffleOrder shuffleOrder;
   private final boolean isAtomic;
 
+  /**
+   * Returns UID of child timeline from a concatenated period UID.
+   *
+   * @param concatenatedUid UID of a period in a concatenated timeline.
+   * @return UID of the child timeline this period belongs to.
+   */
+  public static Object getChildTimelineUidFromConcatenatedUid(Object concatenatedUid) {
+    return ((Pair<?, ?>) concatenatedUid).first;
+  }
+
+  /**
+   * Returns UID of the period in the child timeline from a concatenated period UID.
+   *
+   * @param concatenatedUid UID of a period in a concatenated timeline.
+   * @return UID of the period in the child timeline.
+   */
+  public static Object getChildPeriodUidFromConcatenatedUid(Object concatenatedUid) {
+    return ((Pair<?, ?>) concatenatedUid).second;
+  }
+
+  /**
+   * Returns concatenated UID for a period in a child timeline.
+   *
+   * @param childTimelineUid UID of the child timeline this period belongs to.
+   * @param childPeriodUid UID of the period in the child timeline.
+   * @return UID of the period in the concatenated timeline.
+   */
+  public static Object getConcatenatedUid(Object childTimelineUid, Object childPeriodUid) {
+    return Pair.create(childTimelineUid, childPeriodUid);
+  }
+
   /**
    * Sets up a concatenated timeline with a shuffle order of child timelines.
    *
@@ -168,6 +199,18 @@ public final Window getWindow(
     return window;
   }
 
+  @Override
+  public final Period getPeriodByUid(Object uid, Period period) {
+    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);
+    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);
+    int childIndex = getChildIndexByChildUid(childUid);
+    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
+    getTimelineByChildIndex(childIndex).getPeriodByUid(periodUid, period);
+    period.windowIndex += firstWindowIndexInChild;
+    period.uid = uid;
+    return period;
+  }
+
   @Override
   public final Period getPeriod(int periodIndex, Period period, boolean setIds) {
     int childIndex = getChildIndexByPeriodIndex(periodIndex);
@@ -177,7 +220,7 @@ public final Period getPeriod(int periodIndex, Period period, boolean setIds) {
         setIds);
     period.windowIndex += firstWindowIndexInChild;
     if (setIds) {
-      period.uid = Pair.create(getChildUidByChildIndex(childIndex), period.uid);
+      period.uid = getConcatenatedUid(getChildUidByChildIndex(childIndex), period.uid);
     }
     return period;
   }
@@ -187,9 +230,8 @@ public final int getIndexOfPeriod(Object uid) {
     if (!(uid instanceof Pair)) {
       return C.INDEX_UNSET;
     }
-    Pair<?, ?> childUidAndPeriodUid = (Pair<?, ?>) uid;
-    Object childUid = childUidAndPeriodUid.first;
-    Object periodUid = childUidAndPeriodUid.second;
+    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);
+    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);
     int childIndex = getChildIndexByChildUid(childUid);
     if (childIndex == C.INDEX_UNSET) {
       return C.INDEX_UNSET;
@@ -199,6 +241,15 @@ public final int getIndexOfPeriod(Object uid) {
         : getFirstPeriodIndexByChildIndex(childIndex) + periodIndexInChild;
   }
 
+  @Override
+  public final Object getUidOfPeriod(int periodIndex) {
+    int childIndex = getChildIndexByPeriodIndex(periodIndex);
+    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
+    Object periodUidInChild =
+        getTimelineByChildIndex(childIndex).getUidOfPeriod(periodIndex - firstPeriodIndexInChild);
+    return getConcatenatedUid(getChildUidByChildIndex(childIndex), periodUidInChild);
+  }
+
   /**
    * Returns the index of the child timeline containing the given period index.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
index 32526361f5..2feac2978e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
@@ -19,6 +19,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.util.ArrayList;
 
@@ -34,9 +35,9 @@
   private final ArrayList<SourceInfoRefreshListener> sourceInfoListeners;
   private final MediaSourceEventListener.EventDispatcher eventDispatcher;
 
-  private ExoPlayer player;
-  private Timeline timeline;
-  private Object manifest;
+  private @Nullable ExoPlayer player;
+  private @Nullable Timeline timeline;
+  private @Nullable Object manifest;
 
   public BaseMediaSource() {
     sourceInfoListeners = new ArrayList<>(/* initialCapacity= */ 1);
@@ -51,12 +52,17 @@ public BaseMediaSource() {
    * @param isTopLevelSource Whether this source has been passed directly to {@link
    *     ExoPlayer#prepare(MediaSource)} or {@link ExoPlayer#prepare(MediaSource, boolean,
    *     boolean)}.
+   * @param mediaTransferListener The transfer listener which should be informed of any media data
+   *     transfers. May be null if no listener is available. Note that this listener should usually
+   *     be only informed of transfers related to the media loads and not of auxiliary loads for
+   *     manifests and other data.
    */
-  protected abstract void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource);
+  protected abstract void prepareSourceInternal(
+      ExoPlayer player, boolean isTopLevelSource, @Nullable TransferListener mediaTransferListener);
 
   /**
    * Releases the source. This method is called exactly once after each call to {@link
-   * #prepareSourceInternal(ExoPlayer, boolean)}.
+   * #prepareSourceInternal(ExoPlayer, boolean, TransferListener)}.
    */
   protected abstract void releaseSourceInternal();
 
@@ -130,11 +136,20 @@ public final void removeEventListener(MediaSourceEventListener eventListener) {
   @Override
   public final void prepareSource(
       ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener) {
+    prepareSource(player, isTopLevelSource, listener, /* mediaTransferListener= */ null);
+  }
+
+  @Override
+  public final void prepareSource(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      SourceInfoRefreshListener listener,
+      @Nullable TransferListener mediaTransferListener) {
     Assertions.checkArgument(this.player == null || this.player == player);
     sourceInfoListeners.add(listener);
     if (this.player == null) {
       this.player = player;
-      prepareSourceInternal(player, isTopLevelSource);
+      prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
     } else if (timeline != null) {
       listener.onSourceInfoRefreshed(/* source= */ this, timeline, manifest);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index f633dd8f15..3ed18049bf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -21,8 +21,10 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -36,7 +38,11 @@
   /** Thrown when a {@link ClippingMediaSource} cannot clip its wrapped source. */
   public static final class IllegalClippingException extends IOException {
 
-    /** The reason clipping failed. */
+    /**
+     * The reason clipping failed. One of {@link #REASON_INVALID_PERIOD_COUNT}, {@link
+     * #REASON_NOT_SEEKABLE_TO_START} or {@link #REASON_START_EXCEEDS_END}.
+     */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({REASON_INVALID_PERIOD_COUNT, REASON_NOT_SEEKABLE_TO_START, REASON_START_EXCEEDS_END})
     public @interface Reason {}
@@ -211,8 +217,17 @@ public ClippingMediaSource(
   }
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
-    super.prepareSourceInternal(player, isTopLevelSource);
+  @Nullable
+  public Object getTag() {
+    return mediaSource.getTag();
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
     prepareChildSource(/* id= */ null, mediaSource);
   }
 
@@ -339,7 +354,7 @@ public ClippingTimeline(Timeline timeline, long startUs, long endUs)
       if (timeline.getPeriodCount() != 1) {
         throw new IllegalClippingException(IllegalClippingException.REASON_INVALID_PERIOD_COUNT);
       }
-      Window window = timeline.getWindow(0, new Window(), false);
+      Window window = timeline.getWindow(0, new Window());
       startUs = Math.max(0, startUs);
       long resolvedEndUs = endUs == C.TIME_END_OF_SOURCE ? window.durationUs : Math.max(0, endUs);
       if (window.durationUs != C.TIME_UNSET) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
index f5c4b3a16d..69fa4b094b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
@@ -20,7 +20,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaSourceEventListener.MediaLoadData;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -35,8 +35,9 @@
 
   private final HashMap<T, MediaSourceAndListener> childSources;
 
-  private ExoPlayer player;
-  private Handler eventHandler;
+  private @Nullable ExoPlayer player;
+  private @Nullable Handler eventHandler;
+  private @Nullable TransferListener mediaTransferListener;
 
   /** Create composite media source without child sources. */
   protected CompositeMediaSource() {
@@ -45,8 +46,12 @@ protected CompositeMediaSource() {
 
   @Override
   @CallSuper
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
     this.player = player;
+    this.mediaTransferListener = mediaTransferListener;
     eventHandler = new Handler();
   }
 
@@ -78,7 +83,7 @@ public void releaseSourceInternal() {
    * @param manifest The manifest of the child source.
    */
   protected abstract void onChildSourceInfoRefreshed(
-      @Nullable T id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest);
+      T id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest);
 
   /**
    * Prepares a child source.
@@ -93,20 +98,18 @@ protected abstract void onChildSourceInfoRefreshed(
    * @param id A unique id to identify the child source preparation. Null is allowed as an id.
    * @param mediaSource The child {@link MediaSource}.
    */
-  protected final void prepareChildSource(@Nullable final T id, MediaSource mediaSource) {
+  protected final void prepareChildSource(final T id, MediaSource mediaSource) {
     Assertions.checkArgument(!childSources.containsKey(id));
     SourceInfoRefreshListener sourceListener =
-        new SourceInfoRefreshListener() {
-          @Override
-          public void onSourceInfoRefreshed(
-              MediaSource source, Timeline timeline, @Nullable Object manifest) {
-            onChildSourceInfoRefreshed(id, source, timeline, manifest);
-          }
-        };
+        (source, timeline, manifest) -> onChildSourceInfoRefreshed(id, source, timeline, manifest);
     MediaSourceEventListener eventListener = new ForwardingEventListener(id);
     childSources.put(id, new MediaSourceAndListener(mediaSource, sourceListener, eventListener));
-    mediaSource.addEventListener(eventHandler, eventListener);
-    mediaSource.prepareSource(player, /* isTopLevelSource= */ false, sourceListener);
+    mediaSource.addEventListener(Assertions.checkNotNull(eventHandler), eventListener);
+    mediaSource.prepareSource(
+        Assertions.checkNotNull(player),
+        /* isTopLevelSource= */ false,
+        sourceListener,
+        mediaTransferListener);
   }
 
   /**
@@ -114,8 +117,8 @@ public void onSourceInfoRefreshed(
    *
    * @param id The unique id used to prepare the child source.
    */
-  protected final void releaseChildSource(@Nullable T id) {
-    MediaSourceAndListener removedChild = childSources.remove(id);
+  protected final void releaseChildSource(T id) {
+    MediaSourceAndListener removedChild = Assertions.checkNotNull(childSources.remove(id));
     removedChild.mediaSource.releaseSource(removedChild.listener);
     removedChild.mediaSource.removeEventListener(removedChild.eventListener);
   }
@@ -128,7 +131,7 @@ protected final void releaseChildSource(@Nullable T id) {
    * @param windowIndex A window index of the child source.
    * @return The corresponding window index in the composite source.
    */
-  protected int getWindowIndexForChildWindowIndex(@Nullable T id, int windowIndex) {
+  protected int getWindowIndexForChildWindowIndex(T id, int windowIndex) {
     return windowIndex;
   }
 
@@ -143,7 +146,7 @@ protected int getWindowIndexForChildWindowIndex(@Nullable T id, int windowIndex)
    *     corresponding media period id can be determined.
    */
   protected @Nullable MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(
-      @Nullable T id, MediaPeriodId mediaPeriodId) {
+      T id, MediaPeriodId mediaPeriodId) {
     return mediaPeriodId;
   }
 
@@ -177,10 +180,10 @@ public MediaSourceAndListener(
 
   private final class ForwardingEventListener implements MediaSourceEventListener {
 
-    private final @Nullable T id;
+    private final T id;
     private EventDispatcher eventDispatcher;
 
-    public ForwardingEventListener(@Nullable T id) {
+    public ForwardingEventListener(T id) {
       this.eventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
       this.id = id;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 6f7ffa262d..03ccd56645 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -16,9 +16,9 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
-import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
@@ -27,8 +27,10 @@
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource.MediaSourceHolder;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -47,56 +49,32 @@
     implements PlayerMessage.Target {
 
   private static final int MSG_ADD = 0;
-  private static final int MSG_ADD_MULTIPLE = 1;
-  private static final int MSG_REMOVE = 2;
-  private static final int MSG_MOVE = 3;
-  private static final int MSG_CLEAR = 4;
-  private static final int MSG_NOTIFY_LISTENER = 5;
-  private static final int MSG_ON_COMPLETION = 6;
+  private static final int MSG_REMOVE = 1;
+  private static final int MSG_MOVE = 2;
+  private static final int MSG_SET_SHUFFLE_ORDER = 3;
+  private static final int MSG_NOTIFY_LISTENER = 4;
+  private static final int MSG_ON_COMPLETION = 5;
 
   // Accessed on the app thread.
   private final List<MediaSourceHolder> mediaSourcesPublic;
 
   // Accessed on the playback thread.
   private final List<MediaSourceHolder> mediaSourceHolders;
-  private final MediaSourceHolder query;
   private final Map<MediaPeriod, MediaSourceHolder> mediaSourceByMediaPeriod;
-  private final List<EventDispatcher> pendingOnCompletionActions;
+  private final Map<Object, MediaSourceHolder> mediaSourceByUid;
+  private final List<Runnable> pendingOnCompletionActions;
   private final boolean isAtomic;
+  private final boolean useLazyPreparation;
   private final Timeline.Window window;
+  private final Timeline.Period period;
 
-  private ExoPlayer player;
+  private @Nullable ExoPlayer player;
+  private @Nullable Handler playerApplicationHandler;
   private boolean listenerNotificationScheduled;
   private ShuffleOrder shuffleOrder;
   private int windowCount;
   private int periodCount;
 
-  /** Creates a new concatenating media source. */
-  public ConcatenatingMediaSource() {
-    this(/* isAtomic= */ false, new DefaultShuffleOrder(0));
-  }
-
-  /**
-   * Creates a new concatenating media source.
-   *
-   * @param isAtomic Whether the concatenating media source will be treated as atomic, i.e., treated
-   *     as a single item for repeating and shuffling.
-   */
-  public ConcatenatingMediaSource(boolean isAtomic) {
-    this(isAtomic, new DefaultShuffleOrder(0));
-  }
-
-  /**
-   * Creates a new concatenating media source with a custom shuffle order.
-   *
-   * @param isAtomic Whether the concatenating media source will be treated as atomic, i.e., treated
-   *     as a single item for repeating and shuffling.
-   * @param shuffleOrder The {@link ShuffleOrder} to use when shuffling the child media sources.
-   */
-  public ConcatenatingMediaSource(boolean isAtomic, ShuffleOrder shuffleOrder) {
-    this(isAtomic, shuffleOrder, new MediaSource[0]);
-  }
-
   /**
    * @param mediaSources The {@link MediaSource}s to concatenate. It is valid for the same
    *     {@link MediaSource} instance to be present more than once in the array.
@@ -124,17 +102,38 @@ public ConcatenatingMediaSource(boolean isAtomic, MediaSource... mediaSources) {
    */
   public ConcatenatingMediaSource(
       boolean isAtomic, ShuffleOrder shuffleOrder, MediaSource... mediaSources) {
+    this(isAtomic, /* useLazyPreparation= */ false, shuffleOrder, mediaSources);
+  }
+
+  /**
+   * @param isAtomic Whether the concatenating media source will be treated as atomic, i.e., treated
+   *     as a single item for repeating and shuffling.
+   * @param useLazyPreparation Whether playlist items are prepared lazily. If false, all manifest
+   *     loads and other initial preparation steps happen immediately. If true, these initial
+   *     preparations are triggered only when the player starts buffering the media.
+   * @param shuffleOrder The {@link ShuffleOrder} to use when shuffling the child media sources.
+   * @param mediaSources The {@link MediaSource}s to concatenate. It is valid for the same {@link
+   *     MediaSource} instance to be present more than once in the array.
+   */
+  @SuppressWarnings("initialization")
+  public ConcatenatingMediaSource(
+      boolean isAtomic,
+      boolean useLazyPreparation,
+      ShuffleOrder shuffleOrder,
+      MediaSource... mediaSources) {
     for (MediaSource mediaSource : mediaSources) {
       Assertions.checkNotNull(mediaSource);
     }
     this.shuffleOrder = shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
     this.mediaSourceByMediaPeriod = new IdentityHashMap<>();
+    this.mediaSourceByUid = new HashMap<>();
     this.mediaSourcesPublic = new ArrayList<>();
     this.mediaSourceHolders = new ArrayList<>();
     this.pendingOnCompletionActions = new ArrayList<>();
-    this.query = new MediaSourceHolder(/* mediaSource= */ null);
     this.isAtomic = isAtomic;
+    this.useLazyPreparation = useLazyPreparation;
     window = new Timeline.Window();
+    period = new Timeline.Period();
     addMediaSources(Arrays.asList(mediaSources));
   }
 
@@ -181,18 +180,7 @@ public final synchronized void addMediaSource(int index, MediaSource mediaSource
    */
   public final synchronized void addMediaSource(
       int index, MediaSource mediaSource, @Nullable Runnable actionOnCompletion) {
-    Assertions.checkNotNull(mediaSource);
-    MediaSourceHolder mediaSourceHolder = new MediaSourceHolder(mediaSource);
-    mediaSourcesPublic.add(index, mediaSourceHolder);
-    if (player != null) {
-      player
-          .createMessage(this)
-          .setType(MSG_ADD)
-          .setPayload(new MessageData<>(index, mediaSourceHolder, actionOnCompletion))
-          .send();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+    addMediaSources(index, Collections.singletonList(mediaSource), actionOnCompletion);
   }
 
   /**
@@ -254,7 +242,7 @@ public final synchronized void addMediaSources(
     if (player != null && !mediaSources.isEmpty()) {
       player
           .createMessage(this)
-          .setType(MSG_ADD_MULTIPLE)
+          .setType(MSG_ADD)
           .setPayload(new MessageData<>(index, mediaSourceHolders, actionOnCompletion))
           .send();
     } else if (actionOnCompletion != null) {
@@ -268,6 +256,9 @@ public final synchronized void addMediaSources(
    * <p>Note: If you want to move the instance, it's preferable to use {@link #moveMediaSource(int,
    * int)} instead.
    *
+   * <p>Note: If you want to remove a set of contiguous sources, it's preferable to use {@link
+   * #removeMediaSourceRange(int, int)} instead.
+   *
    * @param index The index at which the media source will be removed. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
@@ -279,7 +270,10 @@ public final synchronized void removeMediaSource(int index) {
    * Removes a {@link MediaSource} from the playlist and executes a custom action on completion.
    *
    * <p>Note: If you want to move the instance, it's preferable to use {@link #moveMediaSource(int,
-   * int)} instead.
+   * int, Runnable)} instead.
+   *
+   * <p>Note: If you want to remove a set of contiguous sources, it's preferable to use {@link
+   * #removeMediaSourceRange(int, int, Runnable)} instead.
    *
    * @param index The index at which the media source will be removed. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
@@ -288,12 +282,57 @@ public final synchronized void removeMediaSource(int index) {
    */
   public final synchronized void removeMediaSource(
       int index, @Nullable Runnable actionOnCompletion) {
-    mediaSourcesPublic.remove(index);
+    removeMediaSourceRange(index, index + 1, actionOnCompletion);
+  }
+
+  /**
+   * Removes a range of {@link MediaSource}s from the playlist, by specifying an initial index
+   * (included) and a final index (excluded).
+   *
+   * <p>Note: when specified range is empty, no actual media source is removed and no exception is
+   * thrown.
+   *
+   * @param fromIndex The initial range index, pointing to the first media source that will be
+   *     removed. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @param toIndex The final range index, pointing to the first media source that will be left
+   *     untouched. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @throws IndexOutOfBoundsException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
+   *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
+   */
+  public final synchronized void removeMediaSourceRange(int fromIndex, int toIndex) {
+    removeMediaSourceRange(fromIndex, toIndex, null);
+  }
+
+  /**
+   * Removes a range of {@link MediaSource}s from the playlist, by specifying an initial index
+   * (included) and a final index (excluded), and executes a custom action on completion.
+   *
+   * <p>Note: when specified range is empty, no actual media source is removed and no exception is
+   * thrown.
+   *
+   * @param fromIndex The initial range index, pointing to the first media source that will be
+   *     removed. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @param toIndex The final range index, pointing to the first media source that will be left
+   *     untouched. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     source range has been removed from the playlist.
+   * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
+   *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
+   */
+  public final synchronized void removeMediaSourceRange(
+      int fromIndex, int toIndex, @Nullable Runnable actionOnCompletion) {
+    Util.removeRange(mediaSourcesPublic, fromIndex, toIndex);
+    if (fromIndex == toIndex) {
+      if (actionOnCompletion != null) {
+        actionOnCompletion.run();
+      }
+      return;
+    }
     if (player != null) {
       player
           .createMessage(this)
           .setType(MSG_REMOVE)
-          .setPayload(new MessageData<>(index, null, actionOnCompletion))
+          .setPayload(new MessageData<>(fromIndex, toIndex, actionOnCompletion))
           .send();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
@@ -326,6 +365,9 @@ public final synchronized void moveMediaSource(int currentIndex, int newIndex) {
   public final synchronized void moveMediaSource(
       int currentIndex, int newIndex, @Nullable Runnable actionOnCompletion) {
     if (currentIndex == newIndex) {
+      if (actionOnCompletion != null) {
+        actionOnCompletion.run();
+      }
       return;
     }
     mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
@@ -352,16 +394,7 @@ public final synchronized void clear() {
    *     has been cleared.
    */
   public final synchronized void clear(@Nullable Runnable actionOnCompletion) {
-    mediaSourcesPublic.clear();
-    if (player != null) {
-      player
-          .createMessage(this)
-          .setType(MSG_CLEAR)
-          .setPayload(actionOnCompletion != null ? new EventDispatcher(actionOnCompletion) : null)
-          .send();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+    removeMediaSourceRange(0, getSize(), actionOnCompletion);
   }
 
   /** Returns the number of media sources in the playlist. */
@@ -379,10 +412,61 @@ public final synchronized MediaSource getMediaSource(int index) {
     return mediaSourcesPublic.get(index).mediaSource;
   }
 
+  /**
+   * Sets a new shuffle order to use when shuffling the child media sources.
+   *
+   * @param shuffleOrder A {@link ShuffleOrder}.
+   */
+  public final synchronized void setShuffleOrder(ShuffleOrder shuffleOrder) {
+    setShuffleOrder(shuffleOrder, /* actionOnCompletion= */ null);
+  }
+
+  /**
+   * Sets a new shuffle order to use when shuffling the child media sources.
+   *
+   * @param shuffleOrder A {@link ShuffleOrder}.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the shuffle
+   *     order has been changed.
+   */
+  public final synchronized void setShuffleOrder(
+      ShuffleOrder shuffleOrder, @Nullable Runnable actionOnCompletion) {
+    ExoPlayer player = this.player;
+    if (player != null) {
+      int size = getSize();
+      if (shuffleOrder.getLength() != size) {
+        shuffleOrder =
+            shuffleOrder
+                .cloneAndClear()
+                .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
+      }
+      player
+          .createMessage(this)
+          .setType(MSG_SET_SHUFFLE_ORDER)
+          .setPayload(new MessageData<>(/* index= */ 0, shuffleOrder, actionOnCompletion))
+          .send();
+    } else {
+      this.shuffleOrder =
+          shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
+      if (actionOnCompletion != null) {
+        actionOnCompletion.run();
+      }
+    }
+  }
+
   @Override
-  public final synchronized void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
-    super.prepareSourceInternal(player, isTopLevelSource);
+  @Nullable
+  public Object getTag() {
+    return null;
+  }
+
+  @Override
+  public final synchronized void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
     this.player = player;
+    playerApplicationHandler = new Handler(player.getApplicationLooper());
     if (mediaSourcesPublic.isEmpty()) {
       notifyListener();
     } else {
@@ -392,37 +476,51 @@ public final synchronized void prepareSourceInternal(ExoPlayer player, boolean i
     }
   }
 
+  @Override
+  @SuppressWarnings("MissingSuperCall")
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    // Do nothing. Source info refresh errors of the individual sources will be thrown when calling
+    // DeferredMediaPeriod.maybeThrowPrepareError.
+  }
+
   @Override
   public final MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    int mediaSourceHolderIndex = findMediaSourceHolderByPeriodIndex(id.periodIndex);
-    MediaSourceHolder holder = mediaSourceHolders.get(mediaSourceHolderIndex);
-    MediaPeriodId idInSource =
-        id.copyWithPeriodIndex(id.periodIndex - holder.firstPeriodIndexInChild);
-    DeferredMediaPeriod mediaPeriod =
-        new DeferredMediaPeriod(holder.mediaSource, idInSource, allocator);
+    Object mediaSourceHolderUid = getMediaSourceHolderUid(id.periodUid);
+    MediaSourceHolder holder = mediaSourceByUid.get(mediaSourceHolderUid);
+    if (holder == null) {
+      // Stale event. The media source has already been removed.
+      holder = new MediaSourceHolder(new DummyMediaSource());
+      holder.hasStartedPreparing = true;
+    }
+    DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(holder.mediaSource, id, allocator);
     mediaSourceByMediaPeriod.put(mediaPeriod, holder);
     holder.activeMediaPeriods.add(mediaPeriod);
-    if (holder.isPrepared) {
-      mediaPeriod.createPeriod();
+    if (!holder.hasStartedPreparing) {
+      holder.hasStartedPreparing = true;
+      prepareChildSource(holder, holder.mediaSource);
+    } else if (holder.isPrepared) {
+      MediaPeriodId idInSource = id.copyWithPeriodUid(getChildPeriodUid(holder, id.periodUid));
+      mediaPeriod.createPeriod(idInSource);
     }
     return mediaPeriod;
   }
 
   @Override
   public final void releasePeriod(MediaPeriod mediaPeriod) {
-    MediaSourceHolder holder = mediaSourceByMediaPeriod.remove(mediaPeriod);
+    MediaSourceHolder holder =
+        Assertions.checkNotNull(mediaSourceByMediaPeriod.remove(mediaPeriod));
     ((DeferredMediaPeriod) mediaPeriod).releasePeriod();
     holder.activeMediaPeriods.remove(mediaPeriod);
-    if (holder.activeMediaPeriods.isEmpty() && holder.isRemoved) {
-      releaseChildSource(holder);
-    }
+    maybeReleaseChildSource(holder);
   }
 
   @Override
   public final void releaseSourceInternal() {
     super.releaseSourceInternal();
     mediaSourceHolders.clear();
+    mediaSourceByUid.clear();
     player = null;
+    playerApplicationHandler = null;
     shuffleOrder = shuffleOrder.cloneAndClear();
     windowCount = 0;
     periodCount = 0;
@@ -445,8 +543,8 @@ protected final void onChildSourceInfoRefreshed(
       // by this media source. Otherwise it does not belong to this child source.
       if (mediaSourceHolder.activeMediaPeriods.get(i).id.windowSequenceNumber
           == mediaPeriodId.windowSequenceNumber) {
-        return mediaPeriodId.copyWithPeriodIndex(
-            mediaPeriodId.periodIndex + mediaSourceHolder.firstPeriodIndexInChild);
+        Object periodUid = getPeriodUid(mediaSourceHolder, mediaPeriodId.periodUid);
+        return mediaPeriodId.copyWithPeriodUid(periodUid);
       }
     }
     return null;
@@ -460,47 +558,55 @@ protected int getWindowIndexForChildWindowIndex(
 
   @Override
   @SuppressWarnings("unchecked")
-  public final void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+  public final void handleMessage(int messageType, @Nullable Object message)
+      throws ExoPlaybackException {
+    if (player == null) {
+      // Stale event.
+      return;
+    }
     switch (messageType) {
       case MSG_ADD:
-        MessageData<MediaSourceHolder> addMessage = (MessageData<MediaSourceHolder>) message;
-        shuffleOrder = shuffleOrder.cloneAndInsert(addMessage.index, 1);
-        addMediaSourceInternal(addMessage.index, addMessage.customData);
+        MessageData<Collection<MediaSourceHolder>> addMessage =
+            (MessageData<Collection<MediaSourceHolder>>) Util.castNonNull(message);
+        shuffleOrder = shuffleOrder.cloneAndInsert(addMessage.index, addMessage.customData.size());
+        addMediaSourcesInternal(addMessage.index, addMessage.customData);
         scheduleListenerNotification(addMessage.actionOnCompletion);
         break;
-      case MSG_ADD_MULTIPLE:
-        MessageData<Collection<MediaSourceHolder>> addMultipleMessage =
-            (MessageData<Collection<MediaSourceHolder>>) message;
-        shuffleOrder =
-            shuffleOrder.cloneAndInsert(
-                addMultipleMessage.index, addMultipleMessage.customData.size());
-        addMediaSourcesInternal(addMultipleMessage.index, addMultipleMessage.customData);
-        scheduleListenerNotification(addMultipleMessage.actionOnCompletion);
-        break;
       case MSG_REMOVE:
-        MessageData<Void> removeMessage = (MessageData<Void>) message;
-        shuffleOrder = shuffleOrder.cloneAndRemove(removeMessage.index);
-        removeMediaSourceInternal(removeMessage.index);
+        MessageData<Integer> removeMessage = (MessageData<Integer>) Util.castNonNull(message);
+        int fromIndex = removeMessage.index;
+        int toIndex = removeMessage.customData;
+        if (fromIndex == 0 && toIndex == shuffleOrder.getLength()) {
+          shuffleOrder = shuffleOrder.cloneAndClear();
+        } else {
+          shuffleOrder = shuffleOrder.cloneAndRemove(fromIndex, toIndex);
+        }
+        for (int index = toIndex - 1; index >= fromIndex; index--) {
+          removeMediaSourceInternal(index);
+        }
         scheduleListenerNotification(removeMessage.actionOnCompletion);
         break;
       case MSG_MOVE:
-        MessageData<Integer> moveMessage = (MessageData<Integer>) message;
-        shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index);
+        MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(message);
+        shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index, moveMessage.index + 1);
         shuffleOrder = shuffleOrder.cloneAndInsert(moveMessage.customData, 1);
         moveMediaSourceInternal(moveMessage.index, moveMessage.customData);
         scheduleListenerNotification(moveMessage.actionOnCompletion);
         break;
-      case MSG_CLEAR:
-        clearInternal();
-        scheduleListenerNotification((EventDispatcher) message);
+      case MSG_SET_SHUFFLE_ORDER:
+        MessageData<ShuffleOrder> shuffleOrderMessage =
+            (MessageData<ShuffleOrder>) Util.castNonNull(message);
+        shuffleOrder = shuffleOrderMessage.customData;
+        scheduleListenerNotification(shuffleOrderMessage.actionOnCompletion);
         break;
       case MSG_NOTIFY_LISTENER:
         notifyListener();
         break;
       case MSG_ON_COMPLETION:
-        List<EventDispatcher> actionsOnCompletion = ((List<EventDispatcher>) message);
+        List<Runnable> actionsOnCompletion = (List<Runnable>) Util.castNonNull(message);
+        Handler handler = Assertions.checkNotNull(playerApplicationHandler);
         for (int i = 0; i < actionsOnCompletion.size(); i++) {
-          actionsOnCompletion.get(i).dispatchEvent();
+          handler.post(actionsOnCompletion.get(i));
         }
         break;
       default:
@@ -508,9 +614,9 @@ public final void handleMessage(int messageType, Object message) throws ExoPlayb
     }
   }
 
-  private void scheduleListenerNotification(@Nullable EventDispatcher actionOnCompletion) {
+  private void scheduleListenerNotification(@Nullable Runnable actionOnCompletion) {
     if (!listenerNotificationScheduled) {
-      player.createMessage(this).setType(MSG_NOTIFY_LISTENER).send();
+      Assertions.checkNotNull(player).createMessage(this).setType(MSG_NOTIFY_LISTENER).send();
       listenerNotificationScheduled = true;
     }
     if (actionOnCompletion != null) {
@@ -520,9 +626,9 @@ private void scheduleListenerNotification(@Nullable EventDispatcher actionOnComp
 
   private void notifyListener() {
     listenerNotificationScheduled = false;
-    List<EventDispatcher> actionsOnCompletion =
+    List<Runnable> actionsOnCompletion =
         pendingOnCompletionActions.isEmpty()
-            ? Collections.<EventDispatcher>emptyList()
+            ? Collections.emptyList()
             : new ArrayList<>(pendingOnCompletionActions);
     pendingOnCompletionActions.clear();
     refreshSourceInfo(
@@ -530,7 +636,18 @@ private void notifyListener() {
             mediaSourceHolders, windowCount, periodCount, shuffleOrder, isAtomic),
         /* manifest= */ null);
     if (!actionsOnCompletion.isEmpty()) {
-      player.createMessage(this).setType(MSG_ON_COMPLETION).setPayload(actionsOnCompletion).send();
+      Assertions.checkNotNull(player)
+          .createMessage(this)
+          .setType(MSG_ON_COMPLETION)
+          .setPayload(actionsOnCompletion)
+          .send();
+    }
+  }
+
+  private void addMediaSourcesInternal(
+      int index, Collection<MediaSourceHolder> mediaSourceHolders) {
+    for (MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
+      addMediaSourceInternal(index++, mediaSourceHolder);
     }
   }
 
@@ -551,13 +668,10 @@ private void addMediaSourceInternal(int newIndex, MediaSourceHolder newMediaSour
         newMediaSourceHolder.timeline.getWindowCount(),
         newMediaSourceHolder.timeline.getPeriodCount());
     mediaSourceHolders.add(newIndex, newMediaSourceHolder);
-    prepareChildSource(newMediaSourceHolder, newMediaSourceHolder.mediaSource);
-  }
-
-  private void addMediaSourcesInternal(
-      int index, Collection<MediaSourceHolder> mediaSourceHolders) {
-    for (MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
-      addMediaSourceInternal(index++, mediaSourceHolder);
+    mediaSourceByUid.put(newMediaSourceHolder.uid, newMediaSourceHolder);
+    if (!useLazyPreparation) {
+      newMediaSourceHolder.hasStartedPreparing = true;
+      prepareChildSource(newMediaSourceHolder, newMediaSourceHolder.mediaSource);
     }
   }
 
@@ -578,29 +692,59 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
           windowOffsetUpdate,
           periodOffsetUpdate);
     }
-    mediaSourceHolder.timeline = deferredTimeline.cloneWithNewTimeline(timeline);
-    if (!mediaSourceHolder.isPrepared && !timeline.isEmpty()) {
-      timeline.getWindow(/* windowIndex= */ 0, window);
-      long defaultPeriodPositionUs =
-          window.getPositionInFirstPeriodUs() + window.getDefaultPositionUs();
-      for (int i = 0; i < mediaSourceHolder.activeMediaPeriods.size(); i++) {
-        DeferredMediaPeriod deferredMediaPeriod = mediaSourceHolder.activeMediaPeriods.get(i);
-        deferredMediaPeriod.setDefaultPreparePositionUs(defaultPeriodPositionUs);
-        deferredMediaPeriod.createPeriod();
+    if (mediaSourceHolder.isPrepared) {
+      mediaSourceHolder.timeline = deferredTimeline.cloneWithUpdatedTimeline(timeline);
+    } else if (timeline.isEmpty()) {
+      mediaSourceHolder.timeline =
+          DeferredTimeline.createWithRealTimeline(timeline, DeferredTimeline.DUMMY_ID);
+    } else {
+      // We should have at most one deferred media period for the DummyTimeline because the duration
+      // is unset and we don't load beyond periods with unset duration. We need to figure out how to
+      // handle the prepare positions of multiple deferred media periods, should that ever change.
+      Assertions.checkState(mediaSourceHolder.activeMediaPeriods.size() <= 1);
+      DeferredMediaPeriod deferredMediaPeriod =
+          mediaSourceHolder.activeMediaPeriods.isEmpty()
+              ? null
+              : mediaSourceHolder.activeMediaPeriods.get(0);
+      // Determine first period and the start position.
+      // This will be:
+      //  1. The default window start position if no deferred period has been created yet.
+      //  2. The non-zero prepare position of the deferred period under the assumption that this is
+      //     a non-zero initial seek position in the window.
+      //  3. The default window start position if the deferred period has a prepare position of zero
+      //     under the assumption that the prepare position of zero was used because it's the
+      //     default position of the DummyTimeline window. Note that this will override an
+      //     intentional seek to zero for a window with a non-zero default position. This is
+      //     unlikely to be a problem as a non-zero default position usually only occurs for live
+      //     playbacks and seeking to zero in a live window would cause BehindLiveWindowExceptions
+      //     anyway.
+      long windowStartPositionUs = window.getDefaultPositionUs();
+      if (deferredMediaPeriod != null) {
+        long periodPreparePositionUs = deferredMediaPeriod.getPreparePositionUs();
+        if (periodPreparePositionUs != 0) {
+          windowStartPositionUs = periodPreparePositionUs;
+        }
+      }
+      Pair<Object, Long> periodPosition =
+          timeline.getPeriodPosition(window, period, /* windowIndex= */ 0, windowStartPositionUs);
+      Object periodUid = periodPosition.first;
+      long periodPositionUs = periodPosition.second;
+      mediaSourceHolder.timeline = DeferredTimeline.createWithRealTimeline(timeline, periodUid);
+      if (deferredMediaPeriod != null) {
+        deferredMediaPeriod.overridePreparePositionUs(periodPositionUs);
+        MediaPeriodId idInSource =
+            deferredMediaPeriod.id.copyWithPeriodUid(
+                getChildPeriodUid(mediaSourceHolder, deferredMediaPeriod.id.periodUid));
+        deferredMediaPeriod.createPeriod(idInSource);
       }
-      mediaSourceHolder.isPrepared = true;
     }
+    mediaSourceHolder.isPrepared = true;
     scheduleListenerNotification(/* actionOnCompletion= */ null);
   }
 
-  private void clearInternal() {
-    for (int index = mediaSourceHolders.size() - 1; index >= 0; index--) {
-      removeMediaSourceInternal(index);
-    }
-  }
-
   private void removeMediaSourceInternal(int index) {
     MediaSourceHolder holder = mediaSourceHolders.remove(index);
+    mediaSourceByUid.remove(holder.uid);
     Timeline oldTimeline = holder.timeline;
     correctOffsets(
         index,
@@ -608,9 +752,7 @@ private void removeMediaSourceInternal(int index) {
         -oldTimeline.getWindowCount(),
         -oldTimeline.getPeriodCount());
     holder.isRemoved = true;
-    if (holder.activeMediaPeriods.isEmpty()) {
-      releaseChildSource(holder);
-    }
+    maybeReleaseChildSource(holder);
   }
 
   private void moveMediaSourceInternal(int currentIndex, int newIndex) {
@@ -639,17 +781,32 @@ private void correctOffsets(
     }
   }
 
-  private int findMediaSourceHolderByPeriodIndex(int periodIndex) {
-    query.firstPeriodIndexInChild = periodIndex;
-    int index = Collections.binarySearch(mediaSourceHolders, query);
-    if (index < 0) {
-      return -index - 2;
+  private void maybeReleaseChildSource(MediaSourceHolder mediaSourceHolder) {
+    // Release if the source has been removed from the playlist, but only if it has been previously
+    // prepared and only if we are not waiting for an existing media period to be released.
+    if (mediaSourceHolder.isRemoved
+        && mediaSourceHolder.hasStartedPreparing
+        && mediaSourceHolder.activeMediaPeriods.isEmpty()) {
+      releaseChildSource(mediaSourceHolder);
     }
-    while (index < mediaSourceHolders.size() - 1
-        && mediaSourceHolders.get(index + 1).firstPeriodIndexInChild == periodIndex) {
-      index++;
+  }
+
+  /** Return uid of media source holder from period uid of concatenated source. */
+  private static Object getMediaSourceHolderUid(Object periodUid) {
+    return ConcatenatedTimeline.getChildTimelineUidFromConcatenatedUid(periodUid);
+  }
+
+  /** Return uid of child period from period uid of concatenated source. */
+  private static Object getChildPeriodUid(MediaSourceHolder holder, Object periodUid) {
+    Object childUid = ConcatenatedTimeline.getChildPeriodUidFromConcatenatedUid(periodUid);
+    return childUid.equals(DeferredTimeline.DUMMY_ID) ? holder.timeline.replacedId : childUid;
+  }
+
+  private static Object getPeriodUid(MediaSourceHolder holder, Object childPeriodUid) {
+    if (holder.timeline.replacedId.equals(childPeriodUid)) {
+      childPeriodUid = DeferredTimeline.DUMMY_ID;
     }
-    return index;
+    return ConcatenatedTimeline.getConcatenatedUid(holder.uid, childPeriodUid);
   }
 
   /** Data class to hold playlist media sources together with meta data needed to process them. */
@@ -662,13 +819,14 @@ private int findMediaSourceHolderByPeriodIndex(int periodIndex) {
     public int childIndex;
     public int firstWindowIndexInChild;
     public int firstPeriodIndexInChild;
+    public boolean hasStartedPreparing;
     public boolean isPrepared;
     public boolean isRemoved;
     public List<DeferredMediaPeriod> activeMediaPeriods;
 
     public MediaSourceHolder(MediaSource mediaSource) {
       this.mediaSource = mediaSource;
-      this.timeline = new DeferredTimeline();
+      this.timeline = DeferredTimeline.createWithDummyTimeline(mediaSource.getTag());
       this.activeMediaPeriods = new ArrayList<>();
       this.uid = new Object();
     }
@@ -677,6 +835,7 @@ public void reset(int childIndex, int firstWindowIndexInChild, int firstPeriodIn
       this.childIndex = childIndex;
       this.firstWindowIndexInChild = firstWindowIndexInChild;
       this.firstPeriodIndexInChild = firstPeriodIndexInChild;
+      this.hasStartedPreparing = false;
       this.isPrepared = false;
       this.isRemoved = false;
       this.activeMediaPeriods.clear();
@@ -688,34 +847,16 @@ public int compareTo(@NonNull MediaSourceHolder other) {
     }
   }
 
-  /** Can be used to dispatch a runnable on the thread the object was created on. */
-  private static final class EventDispatcher {
-
-    public final Handler eventHandler;
-    public final Runnable runnable;
-
-    public EventDispatcher(Runnable runnable) {
-      this.runnable = runnable;
-      this.eventHandler =
-          new Handler(Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper());
-    }
-
-    public void dispatchEvent() {
-      eventHandler.post(runnable);
-    }
-  }
-
   /** Message used to post actions from app thread to playback thread. */
   private static final class MessageData<T> {
 
     public final int index;
     public final T customData;
-    public final @Nullable EventDispatcher actionOnCompletion;
+    public final @Nullable Runnable actionOnCompletion;
 
     public MessageData(int index, T customData, @Nullable Runnable actionOnCompletion) {
       this.index = index;
-      this.actionOnCompletion =
-          actionOnCompletion != null ? new EventDispatcher(actionOnCompletion) : null;
+      this.actionOnCompletion = actionOnCompletion;
       this.customData = customData;
     }
   }
@@ -804,19 +945,35 @@ public int getPeriodCount() {
   }
 
   /**
-   * Timeline used as placeholder for an unprepared media source. After preparation, a copy of the
-   * DeferredTimeline is used to keep the originally assigned first period ID.
+   * Timeline used as placeholder for an unprepared media source. After preparation, a
+   * DeferredTimeline is used to keep the originally assigned dummy period ID.
    */
   private static final class DeferredTimeline extends ForwardingTimeline {
 
     private static final Object DUMMY_ID = new Object();
-    private static final Period period = new Period();
-    private static final DummyTimeline dummyTimeline = new DummyTimeline();
 
     private final Object replacedId;
 
-    public DeferredTimeline() {
-      this(dummyTimeline, /* replacedId= */ null);
+    /**
+     * Returns an instance with a dummy timeline using the provided window tag.
+     *
+     * @param windowTag A window tag.
+     */
+    public static DeferredTimeline createWithDummyTimeline(@Nullable Object windowTag) {
+      return new DeferredTimeline(new DummyTimeline(windowTag), DUMMY_ID);
+    }
+
+    /**
+     * Returns an instance with a real timeline, replacing the provided period ID with the already
+     * assigned dummy period ID.
+     *
+     * @param timeline The real timeline.
+     * @param firstPeriodUid The period UID in the timeline which will be replaced by the already
+     *     assigned dummy period UID.
+     */
+    public static DeferredTimeline createWithRealTimeline(
+        Timeline timeline, Object firstPeriodUid) {
+      return new DeferredTimeline(timeline, firstPeriodUid);
     }
 
     private DeferredTimeline(Timeline timeline, Object replacedId) {
@@ -824,14 +981,16 @@ private DeferredTimeline(Timeline timeline, Object replacedId) {
       this.replacedId = replacedId;
     }
 
-    public DeferredTimeline cloneWithNewTimeline(Timeline timeline) {
-      return new DeferredTimeline(
-          timeline,
-          replacedId == null && timeline.getPeriodCount() > 0
-              ? timeline.getPeriod(0, period, true).uid
-              : replacedId);
+    /**
+     * Returns a copy with an updated timeline. This keeps the existing period replacement.
+     *
+     * @param timeline The new timeline.
+     */
+    public DeferredTimeline cloneWithUpdatedTimeline(Timeline timeline) {
+      return new DeferredTimeline(timeline, replacedId);
     }
 
+    /** Returns wrapped timeline. */
     public Timeline getTimeline() {
       return timeline;
     }
@@ -849,11 +1008,23 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
     public int getIndexOfPeriod(Object uid) {
       return timeline.getIndexOfPeriod(DUMMY_ID.equals(uid) ? replacedId : uid);
     }
+
+    @Override
+    public Object getUidOfPeriod(int periodIndex) {
+      Object uid = timeline.getUidOfPeriod(periodIndex);
+      return Util.areEqual(uid, replacedId) ? DUMMY_ID : uid;
+    }
   }
 
   /** Dummy placeholder timeline with one dynamic window with a period of indeterminate duration. */
   private static final class DummyTimeline extends Timeline {
 
+    @Nullable private final Object tag;
+
+    public DummyTimeline(@Nullable Object tag) {
+      this.tag = tag;
+    }
+
     @Override
     public int getWindowCount() {
       return 1;
@@ -863,14 +1034,13 @@ public int getWindowCount() {
     public Window getWindow(
         int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
       return window.set(
-          /* tag= */ null,
+          tag,
           /* presentationStartTimeMs= */ C.TIME_UNSET,
           /* windowStartTimeMs= */ C.TIME_UNSET,
           /* isSeekable= */ false,
           // Dynamic window to indicate pending timeline updates.
           /* isDynamic= */ true,
-          // Position can't be projected yet as the default position is still unknown.
-          /* defaultPositionUs= */ defaultPositionProjectionUs > 0 ? C.TIME_UNSET : 0,
+          /* defaultPositionUs= */ 0,
           /* durationUs= */ C.TIME_UNSET,
           /* firstPeriodIndex= */ 0,
           /* lastPeriodIndex= */ 0,
@@ -885,8 +1055,8 @@ public int getPeriodCount() {
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       return period.set(
-          /* id= */ null,
-          /* uid= */ null,
+          /* id= */ 0,
+          /* uid= */ DeferredTimeline.DUMMY_ID,
           /* windowIndex= */ 0,
           /* durationUs = */ C.TIME_UNSET,
           /* positionInWindowUs= */ 0);
@@ -894,7 +1064,50 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
 
     @Override
     public int getIndexOfPeriod(Object uid) {
-      return uid == null ? 0 : C.INDEX_UNSET;
+      return uid == DeferredTimeline.DUMMY_ID ? 0 : C.INDEX_UNSET;
+    }
+
+    @Override
+    public Object getUidOfPeriod(int periodIndex) {
+      return DeferredTimeline.DUMMY_ID;
+    }
+  }
+
+  /** Dummy media source which does nothing and does not support creating periods. */
+  private static final class DummyMediaSource extends BaseMediaSource {
+
+    @Override
+    protected void prepareSourceInternal(
+        ExoPlayer player,
+        boolean isTopLevelSource,
+        @Nullable TransferListener mediaTransferListener) {
+      // Do nothing.
+    }
+
+    @Override
+    @Nullable
+    public Object getTag() {
+      return null;
+    }
+
+    @Override
+    protected void releaseSourceInternal() {
+      // Do nothing.
+    }
+
+    @Override
+    public void maybeThrowSourceInfoRefreshError() throws IOException {
+      // Do nothing.
+    }
+
+    @Override
+    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void releasePeriod(MediaPeriod mediaPeriod) {
+      // Do nothing.
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
index 229043b127..26c25a749e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
@@ -24,10 +24,10 @@
 import java.io.IOException;
 
 /**
- * Media period that wraps a media source and defers calling its
- * {@link MediaSource#createPeriod(MediaPeriodId, Allocator)} method until {@link #createPeriod()}
- * has been called. This is useful if you need to return a media period immediately but the media
- * source that should create it is not yet prepared.
+ * Media period that wraps a media source and defers calling its {@link
+ * MediaSource#createPeriod(MediaPeriodId, Allocator)} method until {@link
+ * #createPeriod(MediaPeriodId)} has been called. This is useful if you need to return a media
+ * period immediately but the media source that should create it is not yet prepared.
  */
 public final class DeferredMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
 
@@ -40,7 +40,9 @@
     void onPrepareError(MediaPeriodId mediaPeriodId, IOException exception);
   }
 
+  /** The {@link MediaSource} which will create the actual media period. */
   public final MediaSource mediaSource;
+  /** The {@link MediaPeriodId} used to create the deferred media period. */
   public final MediaPeriodId id;
 
   private final Allocator allocator;
@@ -56,7 +58,7 @@
    * Creates a new deferred media period.
    *
    * @param mediaSource The media source to wrap.
-   * @param id The identifier for the media period to create when {@link #createPeriod()} is called.
+   * @param id The identifier used to create the deferred media period.
    * @param allocator The allocator used to create the media period.
    */
   public DeferredMediaPeriod(MediaSource mediaSource, MediaPeriodId id, Allocator allocator) {
@@ -77,33 +79,35 @@ public void setPrepareErrorListener(PrepareErrorListener listener) {
     this.listener = listener;
   }
 
+  /** Returns the position at which the deferred media period was prepared, in microseconds. */
+  public long getPreparePositionUs() {
+    return preparePositionUs;
+  }
+
   /**
-   * Sets the default prepare position at which to prepare the media period. This value is only used
-   * if the call to {@link MediaPeriod#prepare(Callback, long)} is being deferred and the call was
-   * made with a (presumably default) prepare position of 0.
-   *
-   * <p>Note that this will override an intentional seek to zero in the corresponding non-seekable
-   * timeline window. This is unlikely to be a problem as a non-zero default position usually only
-   * occurs for live playbacks and seeking to zero in a live window would cause
-   * BehindLiveWindowExceptions anyway.
+   * Overrides the default prepare position at which to prepare the media period. This value is only
+   * used if the call to {@link MediaPeriod#prepare(Callback, long)} is being deferred.
    *
-   * @param defaultPreparePositionUs The actual default prepare position, in microseconds.
+   * @param defaultPreparePositionUs The default prepare position to use, in microseconds.
    */
-  public void setDefaultPreparePositionUs(long defaultPreparePositionUs) {
-    if (preparePositionUs == 0 && defaultPreparePositionUs != 0) {
-      preparePositionOverrideUs = defaultPreparePositionUs;
-      preparePositionUs = defaultPreparePositionUs;
-    }
+  public void overridePreparePositionUs(long defaultPreparePositionUs) {
+    preparePositionOverrideUs = defaultPreparePositionUs;
   }
 
   /**
    * Calls {@link MediaSource#createPeriod(MediaPeriodId, Allocator)} on the wrapped source then
    * prepares it if {@link #prepare(Callback, long)} has been called. Call {@link #releasePeriod()}
    * to release the period.
+   *
+   * @param id The identifier that should be used to create the media period from the media source.
    */
-  public void createPeriod() {
+  public void createPeriod(MediaPeriodId id) {
     mediaPeriod = mediaSource.createPeriod(id, allocator);
     if (callback != null) {
+      long preparePositionUs =
+          preparePositionOverrideUs != C.TIME_UNSET
+              ? preparePositionOverrideUs
+              : this.preparePositionUs;
       mediaPeriod.prepare(this, preparePositionUs);
     }
   }
@@ -153,7 +157,7 @@ public TrackGroupArray getTrackGroups() {
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    if (preparePositionOverrideUs != C.TIME_UNSET && positionUs == 0) {
+    if (preparePositionOverrideUs != C.TIME_UNSET && positionUs == preparePositionUs) {
       positionUs = preparePositionOverrideUs;
       preparePositionOverrideUs = C.TIME_UNSET;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 63c86c2c96..31daf65d38 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -37,8 +37,11 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.upstream.StatsDataSource;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -46,6 +49,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Arrays;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A {@link MediaPeriod} that extracts data using an {@link Extractor}.
@@ -77,11 +81,11 @@
 
   private final Uri uri;
   private final DataSource dataSource;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final EventDispatcher eventDispatcher;
   private final Listener listener;
   private final Allocator allocator;
-  @Nullable private final String customCacheKey;
+  private final @Nullable String customCacheKey;
   private final long continueLoadingCheckIntervalBytes;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
@@ -91,23 +95,21 @@
   private final Handler handler;
 
   private @Nullable Callback callback;
-  private SeekMap seekMap;
+  private @Nullable SeekMap seekMap;
   private SampleQueue[] sampleQueues;
   private int[] sampleQueueTrackIds;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
-  private int actualMinLoadableRetryCount;
+
+  private @Nullable PreparedState preparedState;
+  private boolean haveAudioVideoTracks;
+  private int dataType;
 
   private boolean seenFirstTrackSelection;
   private boolean notifyDiscontinuity;
   private boolean notifiedReadingStarted;
   private int enabledTrackCount;
-  private TrackGroupArray tracks;
   private long durationUs;
-  private boolean[] trackEnabledStates;
-  private boolean[] trackIsAudioVideoFlags;
-  private boolean[] trackFormatNotificationSent;
-  private boolean haveAudioVideoTracks;
   private long length;
 
   private long lastSeekPositionUs;
@@ -122,7 +124,7 @@
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource The data source to read the media.
    * @param extractors The extractors to use to read the data source.
-   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
    * @param eventDispatcher A dispatcher to notify of events.
    * @param listener A listener to notify when information about the period changes.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
@@ -131,11 +133,13 @@
    * @param continueLoadingCheckIntervalBytes The number of bytes that should be loaded between each
    *     invocation of {@link Callback#onContinueLoadingRequested(SequenceableLoader)}.
    */
+  // maybeFinishPrepare is not posted to the handler until initialization completes.
+  @SuppressWarnings("nullness:methodref.receiver.bound.invalid")
   public ExtractorMediaPeriod(
       Uri uri,
       DataSource dataSource,
       Extractor[] extractors,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       EventDispatcher eventDispatcher,
       Listener listener,
       Allocator allocator,
@@ -143,40 +147,29 @@ public ExtractorMediaPeriod(
       int continueLoadingCheckIntervalBytes) {
     this.uri = uri;
     this.dataSource = dataSource;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
     this.listener = listener;
     this.allocator = allocator;
     this.customCacheKey = customCacheKey;
     this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
     loader = new Loader("Loader:ExtractorMediaPeriod");
-    extractorHolder = new ExtractorHolder(extractors, this);
+    extractorHolder = new ExtractorHolder(extractors);
     loadCondition = new ConditionVariable();
-    maybeFinishPrepareRunnable = new Runnable() {
-      @Override
-      public void run() {
-        maybeFinishPrepare();
-      }
-    };
-    onContinueLoadingRequestedRunnable = new Runnable() {
-      @Override
-      public void run() {
-        if (!released) {
-          callback.onContinueLoadingRequested(ExtractorMediaPeriod.this);
-        }
-      }
-    };
+    maybeFinishPrepareRunnable = this::maybeFinishPrepare;
+    onContinueLoadingRequestedRunnable =
+        () -> {
+          if (!released) {
+            Assertions.checkNotNull(callback).onContinueLoadingRequested(ExtractorMediaPeriod.this);
+          }
+        };
     handler = new Handler();
     sampleQueueTrackIds = new int[0];
     sampleQueues = new SampleQueue[0];
     pendingResetPositionUs = C.TIME_UNSET;
     length = C.LENGTH_UNSET;
     durationUs = C.TIME_UNSET;
-    // Assume on-demand for MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, until prepared.
-    actualMinLoadableRetryCount =
-        minLoadableRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA
-        ? ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND
-        : minLoadableRetryCount;
+    dataType = C.DATA_TYPE_MEDIA;
     eventDispatcher.mediaPeriodCreated();
   }
 
@@ -188,7 +181,7 @@ public void release() {
         sampleQueue.discardToEnd();
       }
     }
-    loader.release(this);
+    loader.release(/* callback= */ this);
     handler.removeCallbacksAndMessages(null);
     callback = null;
     released = true;
@@ -217,13 +210,19 @@ public void maybeThrowPrepareError() throws IOException {
 
   @Override
   public TrackGroupArray getTrackGroups() {
-    return tracks;
+    return getPreparedState().tracks;
   }
 
   @Override
-  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    Assertions.checkState(prepared);
+  public long selectTracks(
+      TrackSelection[] selections,
+      boolean[] mayRetainStreamFlags,
+      @NullableType SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs) {
+    PreparedState preparedState = getPreparedState();
+    TrackGroupArray tracks = preparedState.tracks;
+    boolean[] trackEnabledStates = preparedState.trackEnabledStates;
     int oldEnabledTrackCount = enabledTrackCount;
     // Deselect old tracks.
     for (int i = 0; i < selections.length; i++) {
@@ -292,6 +291,10 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
 
   @Override
   public void discardBuffer(long positionUs, boolean toKeyframe) {
+    if (isPendingReset()) {
+      return;
+    }
+    boolean[] trackEnabledStates = getPreparedState().trackEnabledStates;
     int trackCount = sampleQueues.length;
     for (int i = 0; i < trackCount; i++) {
       sampleQueues[i].discardTo(positionUs, toKeyframe, trackEnabledStates[i]);
@@ -337,6 +340,7 @@ public long readDiscontinuity() {
 
   @Override
   public long getBufferedPositionUs() {
+    boolean[] trackIsAudioVideoFlags = getPreparedState().trackIsAudioVideoFlags;
     if (loadingFinished) {
       return C.TIME_END_OF_SOURCE;
     } else if (isPendingReset()) {
@@ -362,15 +366,27 @@ public long getBufferedPositionUs() {
 
   @Override
   public long seekToUs(long positionUs) {
+    PreparedState preparedState = getPreparedState();
+    SeekMap seekMap = preparedState.seekMap;
+    boolean[] trackIsAudioVideoFlags = preparedState.trackIsAudioVideoFlags;
     // Treat all seeks into non-seekable media as being to t=0.
     positionUs = seekMap.isSeekable() ? positionUs : 0;
-    lastSeekPositionUs = positionUs;
+
     notifyDiscontinuity = false;
-    // If we're not pending a reset, see if we can seek within the buffer.
-    if (!isPendingReset() && seekInsideBufferUs(positionUs)) {
+    lastSeekPositionUs = positionUs;
+    if (isPendingReset()) {
+      // A reset is already pending. We only need to update its position.
+      pendingResetPositionUs = positionUs;
       return positionUs;
     }
-    // We were unable to seek within the buffer, so need to reset.
+
+    // If we're not playing a live stream, try and seek within the buffer.
+    if (dataType != C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE
+        && seekInsideBufferUs(trackIsAudioVideoFlags, positionUs)) {
+      return positionUs;
+    }
+
+    // We can't seek inside the buffer, and so need to reset.
     pendingDeferredRetry = false;
     pendingResetPositionUs = positionUs;
     loadingFinished = false;
@@ -386,6 +402,7 @@ public long seekToUs(long positionUs) {
 
   @Override
   public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    SeekMap seekMap = getPreparedState().seekMap;
     if (!seekMap.isSeekable()) {
       // Treat all seeks into non-seekable media as being to t=0.
       return 0;
@@ -402,7 +419,7 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
   }
 
   /* package */ void maybeThrowError() throws IOException {
-    loader.maybeThrowError(actualMinLoadableRetryCount);
+    loader.maybeThrowError(loadErrorHandlingPolicy.getMinimumLoadableRetryCount(dataType));
   }
 
   /* package */ int readData(int track, FormatHolder formatHolder, DecoderInputBuffer buffer,
@@ -410,12 +427,11 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
     if (suppressRead()) {
       return C.RESULT_NOTHING_READ;
     }
+    maybeNotifyDownstreamFormat(track);
     int result =
         sampleQueues[track].read(
             formatHolder, buffer, formatRequired, loadingFinished, lastSeekPositionUs);
-    if (result == C.RESULT_BUFFER_READ) {
-      maybeNotifyTrackFormat(track);
-    } else if (result == C.RESULT_NOTHING_READ) {
+    if (result == C.RESULT_NOTHING_READ) {
       maybeStartDeferredRetry(track);
     }
     return result;
@@ -425,6 +441,7 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
     if (suppressRead()) {
       return 0;
     }
+    maybeNotifyDownstreamFormat(track);
     SampleQueue sampleQueue = sampleQueues[track];
     int skipCount;
     if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
@@ -435,28 +452,29 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
         skipCount = 0;
       }
     }
-    if (skipCount > 0) {
-      maybeNotifyTrackFormat(track);
-    } else {
+    if (skipCount == 0) {
       maybeStartDeferredRetry(track);
     }
     return skipCount;
   }
 
-  private void maybeNotifyTrackFormat(int track) {
-    if (!trackFormatNotificationSent[track]) {
-      Format trackFormat = tracks.get(track).getFormat(0);
+  private void maybeNotifyDownstreamFormat(int track) {
+    PreparedState preparedState = getPreparedState();
+    boolean[] trackNotifiedDownstreamFormats = preparedState.trackNotifiedDownstreamFormats;
+    if (!trackNotifiedDownstreamFormats[track]) {
+      Format trackFormat = preparedState.tracks.get(track).getFormat(/* index= */ 0);
       eventDispatcher.downstreamFormatChanged(
           MimeTypes.getTrackType(trackFormat.sampleMimeType),
           trackFormat,
           C.SELECTION_REASON_UNKNOWN,
           /* trackSelectionData= */ null,
           lastSeekPositionUs);
-      trackFormatNotificationSent[track] = true;
+      trackNotifiedDownstreamFormats[track] = true;
     }
   }
 
   private void maybeStartDeferredRetry(int track) {
+    boolean[] trackIsAudioVideoFlags = getPreparedState().trackIsAudioVideoFlags;
     if (!pendingDeferredRetry
         || !trackIsAudioVideoFlags[track]
         || sampleQueues[track].hasNextSample()) {
@@ -470,7 +488,7 @@ private void maybeStartDeferredRetry(int track) {
     for (SampleQueue sampleQueue : sampleQueues) {
       sampleQueue.reset();
     }
-    callback.onContinueLoadingRequested(this);
+    Assertions.checkNotNull(callback).onContinueLoadingRequested(this);
   }
 
   private boolean suppressRead() {
@@ -483,6 +501,7 @@ private boolean suppressRead() {
   public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs) {
     if (durationUs == C.TIME_UNSET) {
+      SeekMap seekMap = Assertions.checkNotNull(this.seekMap);
       long largestQueuedTimestampUs = getLargestQueuedTimestampUs();
       durationUs = largestQueuedTimestampUs == Long.MIN_VALUE ? 0
           : largestQueuedTimestampUs + DEFAULT_LAST_SAMPLE_DURATION_US;
@@ -490,6 +509,8 @@ public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
     }
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
+        loadable.dataSource.getLastOpenedUri(),
+        loadable.dataSource.getLastResponseHeaders(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         /* trackFormat= */ null,
@@ -499,10 +520,10 @@ public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
         durationUs,
         elapsedRealtimeMs,
         loadDurationMs,
-        loadable.bytesLoaded);
+        loadable.dataSource.getBytesRead());
     copyLengthFromLoader(loadable);
     loadingFinished = true;
-    callback.onContinueLoadingRequested(this);
+    Assertions.checkNotNull(callback).onContinueLoadingRequested(this);
   }
 
   @Override
@@ -510,6 +531,8 @@ public void onLoadCanceled(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs, boolean released) {
     eventDispatcher.loadCanceled(
         loadable.dataSpec,
+        loadable.dataSource.getLastOpenedUri(),
+        loadable.dataSource.getLastResponseHeaders(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         /* trackFormat= */ null,
@@ -519,24 +542,44 @@ public void onLoadCanceled(ExtractingLoadable loadable, long elapsedRealtimeMs,
         durationUs,
         elapsedRealtimeMs,
         loadDurationMs,
-        loadable.bytesLoaded);
+        loadable.dataSource.getBytesRead());
     if (!released) {
       copyLengthFromLoader(loadable);
       for (SampleQueue sampleQueue : sampleQueues) {
         sampleQueue.reset();
       }
       if (enabledTrackCount > 0) {
-        callback.onContinueLoadingRequested(this);
+        Assertions.checkNotNull(callback).onContinueLoadingRequested(this);
       }
     }
   }
 
   @Override
-  public @Loader.RetryAction int onLoadError(
-      ExtractingLoadable loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error) {
-    boolean isErrorFatal = isLoadableExceptionFatal(error);
+  public LoadErrorAction onLoadError(
+      ExtractingLoadable loadable,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      IOException error,
+      int errorCount) {
+    copyLengthFromLoader(loadable);
+    LoadErrorAction loadErrorAction;
+    long retryDelayMs =
+        loadErrorHandlingPolicy.getRetryDelayMsFor(dataType, durationUs, error, errorCount);
+    if (retryDelayMs == C.TIME_UNSET) {
+      loadErrorAction = Loader.DONT_RETRY_FATAL;
+    } else /* the load should be retried */ {
+      int extractedSamplesCount = getExtractedSamplesCount();
+      boolean madeProgress = extractedSamplesCount > extractedSamplesCountAtStartOfLoad;
+      loadErrorAction =
+          configureRetry(loadable, extractedSamplesCount)
+              ? Loader.createRetryAction(/* resetErrorCount= */ madeProgress, retryDelayMs)
+              : Loader.DONT_RETRY;
+    }
+
     eventDispatcher.loadError(
         loadable.dataSpec,
+        loadable.dataSource.getLastOpenedUri(),
+        loadable.dataSource.getLastResponseHeaders(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         /* trackFormat= */ null,
@@ -546,18 +589,10 @@ public void onLoadCanceled(ExtractingLoadable loadable, long elapsedRealtimeMs,
         durationUs,
         elapsedRealtimeMs,
         loadDurationMs,
-        loadable.bytesLoaded,
+        loadable.dataSource.getBytesRead(),
         error,
-        /* wasCanceled= */ isErrorFatal);
-    copyLengthFromLoader(loadable);
-    if (isErrorFatal) {
-      return Loader.DONT_RETRY_FATAL;
-    }
-    int extractedSamplesCount = getExtractedSamplesCount();
-    boolean madeProgress = extractedSamplesCount > extractedSamplesCountAtStartOfLoad;
-    return configureRetry(loadable, extractedSamplesCount)
-        ? (madeProgress ? Loader.RETRY_RESET_ERROR_COUNT : Loader.RETRY)
-        : Loader.DONT_RETRY;
+        !loadErrorAction.isRetry());
+    return loadErrorAction;
   }
 
   // ExtractorOutput implementation. Called by the loading thread.
@@ -574,8 +609,9 @@ public TrackOutput track(int id, int type) {
     trackOutput.setUpstreamFormatChangeListener(this);
     sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
     sampleQueueTrackIds[trackCount] = id;
-    sampleQueues = Arrays.copyOf(sampleQueues, trackCount + 1);
+    @NullableType SampleQueue[] sampleQueues = Arrays.copyOf(this.sampleQueues, trackCount + 1);
     sampleQueues[trackCount] = trackOutput;
+    this.sampleQueues = Util.castNonNullTypeArray(sampleQueues);
     return trackOutput;
   }
 
@@ -601,7 +637,8 @@ public void onUpstreamFormatChanged(Format format) {
   // Internal methods.
 
   private void maybeFinishPrepare() {
-    if (released || prepared || seekMap == null || !sampleQueuesBuilt) {
+    SeekMap seekMap = this.seekMap;
+    if (released || prepared || !sampleQueuesBuilt || seekMap == null) {
       return;
     }
     for (SampleQueue sampleQueue : sampleQueues) {
@@ -612,9 +649,7 @@ private void maybeFinishPrepare() {
     loadCondition.close();
     int trackCount = sampleQueues.length;
     TrackGroup[] trackArray = new TrackGroup[trackCount];
-    trackIsAudioVideoFlags = new boolean[trackCount];
-    trackEnabledStates = new boolean[trackCount];
-    trackFormatNotificationSent = new boolean[trackCount];
+    boolean[] trackIsAudioVideoFlags = new boolean[trackCount];
     durationUs = seekMap.getDurationUs();
     for (int i = 0; i < trackCount; i++) {
       Format trackFormat = sampleQueues[i].getUpstreamFormat();
@@ -624,14 +659,19 @@ private void maybeFinishPrepare() {
       trackIsAudioVideoFlags[i] = isAudioVideo;
       haveAudioVideoTracks |= isAudioVideo;
     }
-    tracks = new TrackGroupArray(trackArray);
-    if (minLoadableRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA
-        && length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET) {
-      actualMinLoadableRetryCount = ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE;
-    }
+    dataType =
+        length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET
+            ? C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE
+            : C.DATA_TYPE_MEDIA;
+    preparedState =
+        new PreparedState(seekMap, new TrackGroupArray(trackArray), trackIsAudioVideoFlags);
     prepared = true;
     listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
-    callback.onPrepared(this);
+    Assertions.checkNotNull(callback).onPrepared(this);
+  }
+
+  private PreparedState getPreparedState() {
+    return Assertions.checkNotNull(preparedState);
   }
 
   private void copyLengthFromLoader(ExtractingLoadable loadable) {
@@ -641,9 +681,11 @@ private void copyLengthFromLoader(ExtractingLoadable loadable) {
   }
 
   private void startLoading() {
-    ExtractingLoadable loadable = new ExtractingLoadable(uri, dataSource, extractorHolder,
-        loadCondition);
+    ExtractingLoadable loadable =
+        new ExtractingLoadable(
+            uri, dataSource, extractorHolder, /* extractorOutput= */ this, loadCondition);
     if (prepared) {
+      SeekMap seekMap = getPreparedState().seekMap;
       Assertions.checkState(isPendingReset());
       if (durationUs != C.TIME_UNSET && pendingResetPositionUs >= durationUs) {
         loadingFinished = true;
@@ -655,7 +697,9 @@ private void startLoading() {
       pendingResetPositionUs = C.TIME_UNSET;
     }
     extractedSamplesCountAtStartOfLoad = getExtractedSamplesCount();
-    long elapsedRealtimeMs = loader.startLoading(loadable, this, actualMinLoadableRetryCount);
+    long elapsedRealtimeMs =
+        loader.startLoading(
+            loadable, this, loadErrorHandlingPolicy.getMinimumLoadableRetryCount(dataType));
     eventDispatcher.loadStarted(
         loadable.dataSpec,
         C.DATA_TYPE_MEDIA,
@@ -715,10 +759,11 @@ private boolean configureRetry(ExtractingLoadable loadable, int currentExtracted
   /**
    * Attempts to seek to the specified position within the sample queues.
    *
+   * @param trackIsAudioVideoFlags Whether each track is audio/video.
    * @param positionUs The seek position in microseconds.
    * @return Whether the in-buffer seek was successful.
    */
-  private boolean seekInsideBufferUs(long positionUs) {
+  private boolean seekInsideBufferUs(boolean[] trackIsAudioVideoFlags, long positionUs) {
     int trackCount = sampleQueues.length;
     for (int i = 0; i < trackCount; i++) {
       SampleQueue sampleQueue = sampleQueues[i];
@@ -757,10 +802,6 @@ private boolean isPendingReset() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
-  private static boolean isLoadableExceptionFatal(IOException e) {
-    return e instanceof UnrecognizedInputFormatException;
-  }
-
   private final class SampleStreamImpl implements SampleStream {
 
     private final int track;
@@ -792,14 +833,13 @@ public int skipData(long positionUs) {
 
   }
 
-  /**
-   * Loads the media stream and extracts sample data from it.
-   */
+  /** Loads the media stream and extracts sample data from it. */
   /* package */ final class ExtractingLoadable implements Loadable {
 
     private final Uri uri;
-    private final DataSource dataSource;
+    private final StatsDataSource dataSource;
     private final ExtractorHolder extractorHolder;
+    private final ExtractorOutput extractorOutput;
     private final ConditionVariable loadCondition;
     private final PositionHolder positionHolder;
 
@@ -809,24 +849,25 @@ public int skipData(long positionUs) {
     private long seekTimeUs;
     private DataSpec dataSpec;
     private long length;
-    private long bytesLoaded;
 
-    public ExtractingLoadable(Uri uri, DataSource dataSource, ExtractorHolder extractorHolder,
+    public ExtractingLoadable(
+        Uri uri,
+        DataSource dataSource,
+        ExtractorHolder extractorHolder,
+        ExtractorOutput extractorOutput,
         ConditionVariable loadCondition) {
-      this.uri = Assertions.checkNotNull(uri);
-      this.dataSource = Assertions.checkNotNull(dataSource);
-      this.extractorHolder = Assertions.checkNotNull(extractorHolder);
+      this.uri = uri;
+      this.dataSource = new StatsDataSource(dataSource);
+      this.extractorHolder = extractorHolder;
+      this.extractorOutput = extractorOutput;
       this.loadCondition = loadCondition;
       this.positionHolder = new PositionHolder();
       this.pendingExtractorSeek = true;
       this.length = C.LENGTH_UNSET;
+      dataSpec = new DataSpec(uri, positionHolder.position, C.LENGTH_UNSET, customCacheKey);
     }
 
-    public void setLoadPosition(long position, long timeUs) {
-      positionHolder.position = position;
-      seekTimeUs = timeUs;
-      pendingExtractorSeek = true;
-    }
+    // Loadable implementation.
 
     @Override
     public void cancelLoad() {
@@ -845,8 +886,9 @@ public void load() throws IOException, InterruptedException {
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
+          Uri uri = Assertions.checkNotNull(dataSource.getUri());
           input = new DefaultExtractorInput(dataSource, position, length);
-          Extractor extractor = extractorHolder.selectExtractor(input, dataSource.getUri());
+          Extractor extractor = extractorHolder.selectExtractor(input, extractorOutput, uri);
           if (pendingExtractorSeek) {
             extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
@@ -865,33 +907,35 @@ public void load() throws IOException, InterruptedException {
             result = Extractor.RESULT_CONTINUE;
           } else if (input != null) {
             positionHolder.position = input.getPosition();
-            bytesLoaded = positionHolder.position - dataSpec.absoluteStreamPosition;
           }
           Util.closeQuietly(dataSource);
         }
       }
     }
 
+    // Internal methods.
+
+    private void setLoadPosition(long position, long timeUs) {
+      positionHolder.position = position;
+      seekTimeUs = timeUs;
+      pendingExtractorSeek = true;
+    }
   }
 
-  /**
-   * Stores a list of extractors and a selected extractor when the format has been detected.
-   */
+  /** Stores a list of extractors and a selected extractor when the format has been detected. */
   private static final class ExtractorHolder {
 
     private final Extractor[] extractors;
-    private final ExtractorOutput extractorOutput;
-    private Extractor extractor;
+
+    private @Nullable Extractor extractor;
 
     /**
      * Creates a holder that will select an extractor and initialize it using the specified output.
      *
      * @param extractors One or more extractors to choose from.
-     * @param extractorOutput The output that will be used to initialize the selected extractor.
      */
-    public ExtractorHolder(Extractor[] extractors, ExtractorOutput extractorOutput) {
+    public ExtractorHolder(Extractor[] extractors) {
       this.extractors = extractors;
-      this.extractorOutput = extractorOutput;
     }
 
     /**
@@ -899,13 +943,15 @@ public ExtractorHolder(Extractor[] extractors, ExtractorOutput extractorOutput)
      * later calls.
      *
      * @param input The {@link ExtractorInput} from which data should be read.
+     * @param output The {@link ExtractorOutput} that will be used to initialize the selected
+     *     extractor.
      * @param uri The {@link Uri} of the data.
      * @return An initialized extractor for reading {@code input}.
      * @throws UnrecognizedInputFormatException Thrown if the input format could not be detected.
      * @throws IOException Thrown if the input could not be read.
      * @throws InterruptedException Thrown if the thread was interrupted.
      */
-    public Extractor selectExtractor(ExtractorInput input, Uri uri)
+    public Extractor selectExtractor(ExtractorInput input, ExtractorOutput output, Uri uri)
         throws IOException, InterruptedException {
       if (extractor != null) {
         return extractor;
@@ -926,7 +972,7 @@ public Extractor selectExtractor(ExtractorInput input, Uri uri)
         throw new UnrecognizedInputFormatException("None of the available extractors ("
             + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.", uri);
       }
-      extractor.init(extractorOutput);
+      extractor.init(output);
       return extractor;
     }
 
@@ -936,7 +982,24 @@ public void release() {
         extractor = null;
       }
     }
-
   }
 
+  /** Stores state that is initialized when preparation completes. */
+  private static final class PreparedState {
+
+    public final SeekMap seekMap;
+    public final TrackGroupArray tracks;
+    public final boolean[] trackIsAudioVideoFlags;
+    public final boolean[] trackEnabledStates;
+    public final boolean[] trackNotifiedDownstreamFormats;
+
+    public PreparedState(
+        SeekMap seekMap, TrackGroupArray tracks, boolean[] trackIsAudioVideoFlags) {
+      this.seekMap = seekMap;
+      this.tracks = tracks;
+      this.trackIsAudioVideoFlags = trackIsAudioVideoFlags;
+      this.trackEnabledStates = new boolean[tracks.length];
+      this.trackNotifiedDownstreamFormats = new boolean[tracks.length];
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index c4a0487bd9..085b5dba71 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -27,6 +27,9 @@
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 
@@ -43,6 +46,7 @@
  */
 public final class ExtractorMediaSource extends BaseMediaSource
     implements ExtractorMediaPeriod.Listener {
+
   /**
    * Listener of {@link ExtractorMediaSource} events.
    *
@@ -67,40 +71,6 @@
 
   }
 
-  /**
-   * The default minimum number of times to retry loading prior to failing for on-demand streams.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND = 3;
-
-  /**
-   * The default minimum number of times to retry loading prior to failing for live streams.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE = 6;
-
-  /**
-   * Value for {@code minLoadableRetryCount} that causes the loader to retry
-   * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE} times for live streams and
-   * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND} for on-demand streams.
-   */
-  public static final int MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA = -1;
-
-  /**
-   * The default number of bytes that should be loaded between each each invocation of
-   * {@link MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
-   */
-  public static final int DEFAULT_LOADING_CHECK_INTERVAL_BYTES = 1024 * 1024;
-
-  private final Uri uri;
-  private final DataSource.Factory dataSourceFactory;
-  private final ExtractorsFactory extractorsFactory;
-  private final int minLoadableRetryCount;
-  private final String customCacheKey;
-  private final int continueLoadingCheckIntervalBytes;
-  private final @Nullable Object tag;
-
-  private long timelineDurationUs;
-  private boolean timelineIsSeekable;
-
   /** Factory for {@link ExtractorMediaSource}s. */
   public static final class Factory implements AdsMediaSource.MediaSourceFactory {
 
@@ -109,7 +79,7 @@
     private @Nullable ExtractorsFactory extractorsFactory;
     private @Nullable String customCacheKey;
     private @Nullable Object tag;
-    private int minLoadableRetryCount;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private int continueLoadingCheckIntervalBytes;
     private boolean isCreateCalled;
 
@@ -120,7 +90,7 @@
      */
     public Factory(DataSource.Factory dataSourceFactory) {
       this.dataSourceFactory = dataSourceFactory;
-      minLoadableRetryCount = MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
       continueLoadingCheckIntervalBytes = DEFAULT_LOADING_CHECK_INTERVAL_BYTES;
     }
 
@@ -171,16 +141,36 @@ public Factory setTag(Object tag) {
     }
 
     /**
-     * Sets the minimum number of times to retry if a loading error occurs. The default value is
-     * {@link #MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA}.
+     * Sets the minimum number of times to retry if a loading error occurs. See {@link
+     * #setLoadErrorHandlingPolicy} for the default value.
+     *
+     * <p>Calling this method is equivalent to calling {@link #setLoadErrorHandlingPolicy} with
+     * {@link DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy(int)
+     * DefaultLoadErrorHandlingPolicy(minLoadableRetryCount)}
      *
      * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     * @deprecated Use {@link #setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy)} instead.
      */
+    @Deprecated
     public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      return setLoadErrorHandlingPolicy(new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount));
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy}. The default value is created by calling {@link
+     * DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy()}.
+     *
+     * <p>Calling this method overrides any calls to {@link #setMinLoadableRetryCount(int)}.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
       Assertions.checkState(!isCreateCalled);
-      this.minLoadableRetryCount = minLoadableRetryCount;
+      this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
       return this;
     }
 
@@ -217,7 +207,7 @@ public ExtractorMediaSource createMediaSource(Uri uri) {
           uri,
           dataSourceFactory,
           extractorsFactory,
-          minLoadableRetryCount,
+          loadErrorHandlingPolicy,
           customCacheKey,
           continueLoadingCheckIntervalBytes,
           tag);
@@ -243,6 +233,24 @@ public ExtractorMediaSource createMediaSource(
     }
   }
 
+  /**
+   * The default number of bytes that should be loaded between each each invocation of {@link
+   * MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
+   */
+  public static final int DEFAULT_LOADING_CHECK_INTERVAL_BYTES = 1024 * 1024;
+
+  private final Uri uri;
+  private final DataSource.Factory dataSourceFactory;
+  private final ExtractorsFactory extractorsFactory;
+  private final LoadErrorHandlingPolicy loadableLoadErrorHandlingPolicy;
+  private final String customCacheKey;
+  private final int continueLoadingCheckIntervalBytes;
+  private final @Nullable Object tag;
+
+  private long timelineDurationUs;
+  private boolean timelineIsSeekable;
+  private @Nullable TransferListener transferListener;
+
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
@@ -254,6 +262,7 @@ public ExtractorMediaSource createMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
@@ -276,6 +285,7 @@ public ExtractorMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
@@ -283,8 +293,14 @@ public ExtractorMediaSource(
       Handler eventHandler,
       EventListener eventListener,
       String customCacheKey) {
-    this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
-        eventListener, customCacheKey, DEFAULT_LOADING_CHECK_INTERVAL_BYTES);
+    this(
+        uri,
+        dataSourceFactory,
+        extractorsFactory,
+        eventHandler,
+        eventListener,
+        customCacheKey,
+        DEFAULT_LOADING_CHECK_INTERVAL_BYTES);
   }
 
   /**
@@ -293,7 +309,6 @@ public ExtractorMediaSource(
    * @param extractorsFactory A factory for {@link Extractor}s to process the media stream. If the
    *     possible formats are known, pass a factory that instantiates extractors for those formats.
    *     Otherwise, pass a {@link DefaultExtractorsFactory} to use default extractors.
-   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
@@ -303,11 +318,11 @@ public ExtractorMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory,
-      int minLoadableRetryCount,
       Handler eventHandler,
       EventListener eventListener,
       String customCacheKey,
@@ -316,7 +331,7 @@ public ExtractorMediaSource(
         uri,
         dataSourceFactory,
         extractorsFactory,
-        minLoadableRetryCount,
+        new DefaultLoadErrorHandlingPolicy(),
         customCacheKey,
         continueLoadingCheckIntervalBytes,
         /* tag= */ null);
@@ -329,14 +344,14 @@ private ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadableLoadErrorHandlingPolicy,
       @Nullable String customCacheKey,
       int continueLoadingCheckIntervalBytes,
       @Nullable Object tag) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.extractorsFactory = extractorsFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadableLoadErrorHandlingPolicy = loadableLoadErrorHandlingPolicy;
     this.customCacheKey = customCacheKey;
     this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
     this.timelineDurationUs = C.TIME_UNSET;
@@ -344,7 +359,17 @@ private ExtractorMediaSource(
   }
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    transferListener = mediaTransferListener;
     notifySourceInfoRefreshed(timelineDurationUs, /* isSeekable= */ false);
   }
 
@@ -355,12 +380,15 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    Assertions.checkArgument(id.periodIndex == 0);
+    DataSource dataSource = dataSourceFactory.createDataSource();
+    if (transferListener != null) {
+      dataSource.addTransferListener(transferListener);
+    }
     return new ExtractorMediaPeriod(
         uri,
-        dataSourceFactory.createDataSource(),
+        dataSource,
         extractorsFactory.createExtractors(),
-        minLoadableRetryCount,
+        loadableLoadErrorHandlingPolicy,
         createEventDispatcher(id),
         this,
         allocator,
@@ -407,6 +435,8 @@ private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
    * Wraps a deprecated {@link EventListener}, invoking its callback from the equivalent callback in
    * {@link MediaSourceEventListener}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   private static final class EventListenerWrapper extends DefaultMediaSourceEventListener {
     private final EventListener eventListener;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
index c7ab7615d8..45997aced4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
@@ -77,4 +77,8 @@ public int getIndexOfPeriod(Object uid) {
     return timeline.getIndexOfPeriod(uid);
   }
 
+  @Override
+  public Object getUidOfPeriod(int periodIndex) {
+    return timeline.getUidOfPeriod(periodIndex);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 774074b016..cac15d5ed9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -22,7 +22,10 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ShuffleOrder.UnshuffledShuffleOrder;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Loops a {@link MediaSource} a specified number of times.
@@ -34,8 +37,8 @@
 
   private final MediaSource childSource;
   private final int loopCount;
-
-  private int childPeriodCount;
+  private final Map<MediaPeriodId, MediaPeriodId> childMediaPeriodIdToMediaPeriodId;
+  private final Map<MediaPeriod, MediaPeriodId> mediaPeriodToChildMediaPeriodId;
 
   /**
    * Loops the provided source indefinitely. Note that it is usually better to use
@@ -57,37 +60,50 @@ public LoopingMediaSource(MediaSource childSource, int loopCount) {
     Assertions.checkArgument(loopCount > 0);
     this.childSource = childSource;
     this.loopCount = loopCount;
+    childMediaPeriodIdToMediaPeriodId = new HashMap<>();
+    mediaPeriodToChildMediaPeriodId = new HashMap<>();
+  }
+
+  @Override
+  @Nullable
+  public Object getTag() {
+    return childSource.getTag();
   }
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
-    super.prepareSourceInternal(player, isTopLevelSource);
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
     prepareChildSource(/* id= */ null, childSource);
   }
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    return loopCount != Integer.MAX_VALUE
-        ? childSource.createPeriod(id.copyWithPeriodIndex(id.periodIndex % childPeriodCount),
-            allocator)
-        : childSource.createPeriod(id, allocator);
+    if (loopCount == Integer.MAX_VALUE) {
+      return childSource.createPeriod(id, allocator);
+    }
+    Object childPeriodUid = LoopingTimeline.getChildPeriodUidFromConcatenatedUid(id.periodUid);
+    MediaPeriodId childMediaPeriodId = id.copyWithPeriodUid(childPeriodUid);
+    childMediaPeriodIdToMediaPeriodId.put(childMediaPeriodId, id);
+    MediaPeriod mediaPeriod = childSource.createPeriod(childMediaPeriodId, allocator);
+    mediaPeriodToChildMediaPeriodId.put(mediaPeriod, childMediaPeriodId);
+    return mediaPeriod;
   }
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
     childSource.releasePeriod(mediaPeriod);
-  }
-
-  @Override
-  public void releaseSourceInternal() {
-    super.releaseSourceInternal();
-    childPeriodCount = 0;
+    MediaPeriodId childMediaPeriodId = mediaPeriodToChildMediaPeriodId.remove(mediaPeriod);
+    if (childMediaPeriodId != null) {
+      childMediaPeriodIdToMediaPeriodId.remove(childMediaPeriodId);
+    }
   }
 
   @Override
   protected void onChildSourceInfoRefreshed(
       Void id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest) {
-    childPeriodCount = timeline.getPeriodCount();
     Timeline loopingTimeline =
         loopCount != Integer.MAX_VALUE
             ? new LoopingTimeline(timeline, loopCount)
@@ -95,6 +111,14 @@ protected void onChildSourceInfoRefreshed(
     refreshSourceInfo(loopingTimeline, manifest);
   }
 
+  @Override
+  protected @Nullable MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(
+      Void id, MediaPeriodId mediaPeriodId) {
+    return loopCount != Integer.MAX_VALUE
+        ? childMediaPeriodIdToMediaPeriodId.get(mediaPeriodId)
+        : mediaPeriodId;
+  }
+
   private static final class LoopingTimeline extends AbstractConcatenatedTimeline {
 
     private final Timeline childTimeline;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 1a243a8bf0..74449ba16b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
 
 /**
@@ -32,7 +33,7 @@
  *       provide a new timeline whenever the structure of the media changes. The MediaSource
  *       provides these timelines by calling {@link SourceInfoRefreshListener#onSourceInfoRefreshed}
  *       on the {@link SourceInfoRefreshListener}s passed to {@link #prepareSource(ExoPlayer,
- *       boolean, SourceInfoRefreshListener)}.
+ *       boolean, SourceInfoRefreshListener, TransferListener)}.
  *   <li>To provide {@link MediaPeriod} instances for the periods in its timeline. MediaPeriods are
  *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator)}, and provide a way for
  *       the player to load and read the media.
@@ -65,10 +66,8 @@
    */
   final class MediaPeriodId {
 
-    /**
-     * The timeline period index.
-     */
-    public final int periodIndex;
+    /** The unique id of the timeline period. */
+    public final Object periodUid;
 
     /**
      * If the media period is in an ad group, the index of the ad group in the period.
@@ -89,52 +88,83 @@
      */
     public final long windowSequenceNumber;
 
+    /**
+     * The end position of the media to play within the media period, in microseconds, or {@link
+     * C#TIME_END_OF_SOURCE} if the end position is the end of the media period.
+     *
+     * <p>Note that this only applies if the media period is for content (i.e., not for an ad) and
+     * is clipped to the position of the next ad group.
+     */
+    public final long endPositionUs;
+
     /**
      * Creates a media period identifier for a dummy period which is not part of a buffered sequence
      * of windows.
      *
-     * @param periodIndex The period index.
+     * @param periodUid The unique id of the timeline period.
      */
-    public MediaPeriodId(int periodIndex) {
-      this(periodIndex, C.INDEX_UNSET);
+    public MediaPeriodId(Object periodUid) {
+      this(periodUid, C.INDEX_UNSET);
     }
 
     /**
      * Creates a media period identifier for the specified period in the timeline.
      *
-     * @param periodIndex The timeline period index.
+     * @param periodUid The unique id of the timeline period.
+     * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
+     *     windows this media period is part of.
+     */
+    public MediaPeriodId(Object periodUid, long windowSequenceNumber) {
+      this(periodUid, C.INDEX_UNSET, C.INDEX_UNSET, windowSequenceNumber, C.TIME_END_OF_SOURCE);
+    }
+
+    /**
+     * Creates a media period identifier for the specified clipped period in the timeline.
+     *
+     * @param periodUid The unique id of the timeline period.
      * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
      *     windows this media period is part of.
+     * @param endPositionUs The end position of the media period within the timeline period, in
+     *     microseconds.
      */
-    public MediaPeriodId(int periodIndex, long windowSequenceNumber) {
-      this(periodIndex, C.INDEX_UNSET, C.INDEX_UNSET, windowSequenceNumber);
+    public MediaPeriodId(Object periodUid, long windowSequenceNumber, long endPositionUs) {
+      this(periodUid, C.INDEX_UNSET, C.INDEX_UNSET, windowSequenceNumber, endPositionUs);
     }
 
     /**
      * Creates a media period identifier that identifies an ad within an ad group at the specified
      * timeline period.
      *
-     * @param periodIndex The index of the timeline period that contains the ad group.
+     * @param periodUid The unique id of the timeline period that contains the ad group.
      * @param adGroupIndex The index of the ad group.
      * @param adIndexInAdGroup The index of the ad in the ad group.
      * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
      *     windows this media period is part of.
      */
     public MediaPeriodId(
-        int periodIndex, int adGroupIndex, int adIndexInAdGroup, long windowSequenceNumber) {
-      this.periodIndex = periodIndex;
+        Object periodUid, int adGroupIndex, int adIndexInAdGroup, long windowSequenceNumber) {
+      this(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, C.TIME_END_OF_SOURCE);
+    }
+
+    private MediaPeriodId(
+        Object periodUid,
+        int adGroupIndex,
+        int adIndexInAdGroup,
+        long windowSequenceNumber,
+        long endPositionUs) {
+      this.periodUid = periodUid;
       this.adGroupIndex = adGroupIndex;
       this.adIndexInAdGroup = adIndexInAdGroup;
       this.windowSequenceNumber = windowSequenceNumber;
+      this.endPositionUs = endPositionUs;
     }
 
-    /**
-     * Returns a copy of this period identifier but with {@code newPeriodIndex} as its period index.
-     */
-    public MediaPeriodId copyWithPeriodIndex(int newPeriodIndex) {
-      return periodIndex == newPeriodIndex
+    /** Returns a copy of this period identifier but with {@code newPeriodUid} as its period uid. */
+    public MediaPeriodId copyWithPeriodUid(Object newPeriodUid) {
+      return periodUid.equals(newPeriodUid)
           ? this
-          : new MediaPeriodId(newPeriodIndex, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
+          : new MediaPeriodId(
+              newPeriodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, endPositionUs);
     }
 
     /**
@@ -154,22 +184,23 @@ public boolean equals(@Nullable Object obj) {
       }
 
       MediaPeriodId periodId = (MediaPeriodId) obj;
-      return periodIndex == periodId.periodIndex
+      return periodUid.equals(periodId.periodUid)
           && adGroupIndex == periodId.adGroupIndex
           && adIndexInAdGroup == periodId.adIndexInAdGroup
-          && windowSequenceNumber == periodId.windowSequenceNumber;
+          && windowSequenceNumber == periodId.windowSequenceNumber
+          && endPositionUs == periodId.endPositionUs;
     }
 
     @Override
     public int hashCode() {
       int result = 17;
-      result = 31 * result + periodIndex;
+      result = 31 * result + periodUid.hashCode();
       result = 31 * result + adGroupIndex;
       result = 31 * result + adIndexInAdGroup;
       result = 31 * result + (int) windowSequenceNumber;
+      result = 31 * result + (int) endPositionUs;
       return result;
     }
-
   }
 
   /**
@@ -189,6 +220,17 @@ public int hashCode() {
    */
   void removeEventListener(MediaSourceEventListener eventListener);
 
+  /** Returns the tag set on the media source, or null if none was set. */
+  @Nullable
+  default Object getTag() {
+    return null;
+  }
+
+  /** @deprecated Will be removed in the next release. */
+  @Deprecated
+  void prepareSource(
+      ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener);
+
   /**
    * Starts source preparation if not yet started, and adds a listener for timeline and/or manifest
    * updates.
@@ -206,9 +248,16 @@ public int hashCode() {
    *     boolean)}. If {@code false}, this source is being prepared by another source (e.g. {@link
    *     ConcatenatingMediaSource}) for composition.
    * @param listener The listener to be added.
+   * @param mediaTransferListener The transfer listener which should be informed of any media data
+   *     transfers. May be null if no listener is available. Note that this listener should be only
+   *     informed of transfers related to the media loads and not of auxiliary loads for manifests
+   *     and other data.
    */
   void prepareSource(
-      ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener);
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      SourceInfoRefreshListener listener,
+      @Nullable TransferListener mediaTransferListener);
 
   /**
    * Throws any pending error encountered while loading or refreshing source information.
@@ -219,10 +268,9 @@ void prepareSource(
 
   /**
    * Returns a new {@link MediaPeriod} identified by {@code periodId}. This method may be called
-   * multiple times with the same period identifier without an intervening call to
-   * {@link #releasePeriod(MediaPeriod)}.
-   * <p>
-   * Should not be called directly from application code.
+   * multiple times without an intervening call to {@link #releasePeriod(MediaPeriod)}.
+   *
+   * <p>Should not be called directly from application code.
    *
    * @param id The identifier of the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
index 9d1ba10866..98d1d0a2ab 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -27,6 +28,9 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
 
 /** Interface for callbacks to be notified of {@link MediaSource} events. */
@@ -35,8 +39,16 @@
   /** Media source load event information. */
   final class LoadEventInfo {
 
-    /** Defines the data being loaded. */
+    /** Defines the requested data. */
     public final DataSpec dataSpec;
+    /**
+     * The {@link Uri} from which data is being read. The uri will be identical to the one in {@link
+     * #dataSpec}.uri unless redirection has occurred. If redirection has occurred, this is the uri
+     * after redirection.
+     */
+    public final Uri uri;
+    /** The response headers associated with the load, or an empty map if unavailable. */
+    public final Map<String, List<String>> responseHeaders;
     /** The value of {@link SystemClock#elapsedRealtime} at the time of the load event. */
     public final long elapsedRealtimeMs;
     /** The duration of the load up to the event time. */
@@ -47,15 +59,28 @@
     /**
      * Creates load event info.
      *
-     * @param dataSpec Defines the data being loaded.
+     * @param dataSpec Defines the requested data.
+     * @param uri The {@link Uri} from which data is being read. The uri must be identical to the
+     *     one in {@code dataSpec.uri} unless redirection has occurred. If redirection has occurred,
+     *     this is the uri after redirection.
+     * @param responseHeaders The response headers associated with the load, or an empty map if
+     *     unavailable.
      * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} at the time of the
      *     load event.
      * @param loadDurationMs The duration of the load up to the event time.
-     * @param bytesLoaded The number of bytes that were loaded up to the event time.
+     * @param bytesLoaded The number of bytes that were loaded up to the event time. For compressed
+     *     network responses, this is the decompressed size.
      */
     public LoadEventInfo(
-        DataSpec dataSpec, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
+        DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
       this.dataSpec = dataSpec;
+      this.uri = uri;
+      this.responseHeaders = responseHeaders;
       this.elapsedRealtimeMs = elapsedRealtimeMs;
       this.loadDurationMs = loadDurationMs;
       this.bytesLoaded = bytesLoaded;
@@ -155,7 +180,9 @@ public MediaLoadData(
    * @param windowIndex The window index in the timeline of the media source this load belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} this load belongs to. Null if the load does not
    *     belong to a specific media period.
-   * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
+   * @param loadEventInfo The {@link LoadEventInfo} corresponding to the event. The value of {@link
+   *     LoadEventInfo#uri} won't reflect potential redirection yet and {@link
+   *     LoadEventInfo#responseHeaders} will be empty.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
   void onLoadStarted(
@@ -170,7 +197,10 @@ void onLoadStarted(
    * @param windowIndex The window index in the timeline of the media source this load belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} this load belongs to. Null if the load does not
    *     belong to a specific media period.
-   * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
+   * @param loadEventInfo The {@link LoadEventInfo} corresponding to the event. The values of {@link
+   *     LoadEventInfo#elapsedRealtimeMs} and {@link LoadEventInfo#bytesLoaded} are relative to the
+   *     corresponding {@link #onLoadStarted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}
+   *     event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
   void onLoadCompleted(
@@ -185,7 +215,10 @@ void onLoadCompleted(
    * @param windowIndex The window index in the timeline of the media source this load belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} this load belongs to. Null if the load does not
    *     belong to a specific media period.
-   * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
+   * @param loadEventInfo The {@link LoadEventInfo} corresponding to the event. The values of {@link
+   *     LoadEventInfo#elapsedRealtimeMs} and {@link LoadEventInfo#bytesLoaded} are relative to the
+   *     corresponding {@link #onLoadStarted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}
+   *     event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
   void onLoadCanceled(
@@ -211,7 +244,10 @@ void onLoadCanceled(
    * @param windowIndex The window index in the timeline of the media source this load belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} this load belongs to. Null if the load does not
    *     belong to a specific media period.
-   * @param loadEventInfo The {@link LoadEventInfo} defining the load event.
+   * @param loadEventInfo The {@link LoadEventInfo} corresponding to the event. The values of {@link
+   *     LoadEventInfo#elapsedRealtimeMs} and {@link LoadEventInfo#bytesLoaded} are relative to the
+   *     corresponding {@link #onLoadStarted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}
+   *     event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    * @param error The load error.
    * @param wasCanceled Whether the load was canceled as a result of the error.
@@ -268,7 +304,7 @@ void onDownstreamFormatChanged(
     /** Creates an event dispatcher. */
     public EventDispatcher() {
       this(
-          /* listenerAndHandlers= */ new CopyOnWriteArrayList<ListenerAndHandler>(),
+          /* listenerAndHandlers= */ new CopyOnWriteArrayList<>(),
           /* windowIndex= */ 0,
           /* mediaPeriodId= */ null,
           /* mediaTimeOffsetMs= */ 0);
@@ -327,33 +363,23 @@ public void removeEventListener(MediaSourceEventListener eventListener) {
 
     /** Dispatches {@link #onMediaPeriodCreated(int, MediaPeriodId)}. */
     public void mediaPeriodCreated() {
-      Assertions.checkState(mediaPeriodId != null);
+      MediaPeriodId mediaPeriodId = Assertions.checkNotNull(this.mediaPeriodId);
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onMediaPeriodCreated(windowIndex, mediaPeriodId);
-              }
-            });
+            () -> listener.onMediaPeriodCreated(windowIndex, mediaPeriodId));
       }
     }
 
     /** Dispatches {@link #onMediaPeriodReleased(int, MediaPeriodId)}. */
     public void mediaPeriodReleased() {
-      Assertions.checkState(mediaPeriodId != null);
+      MediaPeriodId mediaPeriodId = Assertions.checkNotNull(this.mediaPeriodId);
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onMediaPeriodReleased(windowIndex, mediaPeriodId);
-              }
-            });
+            () -> listener.onMediaPeriodReleased(windowIndex, mediaPeriodId));
       }
     }
 
@@ -384,7 +410,12 @@ public void loadStarted(
         long elapsedRealtimeMs) {
       loadStarted(
           new LoadEventInfo(
-              dataSpec, elapsedRealtimeMs, /* loadDurationMs= */ 0, /* bytesLoaded= */ 0),
+              dataSpec,
+              dataSpec.uri,
+              /* responseHeaders= */ Collections.emptyMap(),
+              elapsedRealtimeMs,
+              /* loadDurationMs= */ 0,
+              /* bytesLoaded= */ 0),
           new MediaLoadData(
               dataType,
               trackType,
@@ -396,29 +427,28 @@ public void loadStarted(
     }
 
     /** Dispatches {@link #onLoadStarted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
-    public void loadStarted(final LoadEventInfo loadEventInfo, final MediaLoadData mediaLoadData) {
+    public void loadStarted(LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onLoadStarted(windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData);
-              }
-            });
+            () -> listener.onLoadStarted(windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData));
       }
     }
 
     /** Dispatches {@link #onLoadCompleted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
     public void loadCompleted(
         DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
         int dataType,
         long elapsedRealtimeMs,
         long loadDurationMs,
         long bytesLoaded) {
       loadCompleted(
           dataSpec,
+          uri,
+          responseHeaders,
           dataType,
           C.TRACK_TYPE_UNKNOWN,
           null,
@@ -434,6 +464,8 @@ public void loadCompleted(
     /** Dispatches {@link #onLoadCompleted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
     public void loadCompleted(
         DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
         int dataType,
         int trackType,
         @Nullable Format trackFormat,
@@ -445,7 +477,8 @@ public void loadCompleted(
         long loadDurationMs,
         long bytesLoaded) {
       loadCompleted(
-          new LoadEventInfo(dataSpec, elapsedRealtimeMs, loadDurationMs, bytesLoaded),
+          new LoadEventInfo(
+              dataSpec, uri, responseHeaders, elapsedRealtimeMs, loadDurationMs, bytesLoaded),
           new MediaLoadData(
               dataType,
               trackType,
@@ -457,30 +490,29 @@ public void loadCompleted(
     }
 
     /** Dispatches {@link #onLoadCompleted(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
-    public void loadCompleted(
-        final LoadEventInfo loadEventInfo, final MediaLoadData mediaLoadData) {
+    public void loadCompleted(LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onLoadCompleted(windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData);
-              }
-            });
+            () ->
+                listener.onLoadCompleted(windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData));
       }
     }
 
     /** Dispatches {@link #onLoadCanceled(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
     public void loadCanceled(
         DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
         int dataType,
         long elapsedRealtimeMs,
         long loadDurationMs,
         long bytesLoaded) {
       loadCanceled(
           dataSpec,
+          uri,
+          responseHeaders,
           dataType,
           C.TRACK_TYPE_UNKNOWN,
           null,
@@ -496,6 +528,8 @@ public void loadCanceled(
     /** Dispatches {@link #onLoadCanceled(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
     public void loadCanceled(
         DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
         int dataType,
         int trackType,
         @Nullable Format trackFormat,
@@ -507,7 +541,8 @@ public void loadCanceled(
         long loadDurationMs,
         long bytesLoaded) {
       loadCanceled(
-          new LoadEventInfo(dataSpec, elapsedRealtimeMs, loadDurationMs, bytesLoaded),
+          new LoadEventInfo(
+              dataSpec, uri, responseHeaders, elapsedRealtimeMs, loadDurationMs, bytesLoaded),
           new MediaLoadData(
               dataType,
               trackType,
@@ -519,17 +554,13 @@ public void loadCanceled(
     }
 
     /** Dispatches {@link #onLoadCanceled(int, MediaPeriodId, LoadEventInfo, MediaLoadData)}. */
-    public void loadCanceled(final LoadEventInfo loadEventInfo, final MediaLoadData mediaLoadData) {
+    public void loadCanceled(LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
-        final MediaSourceEventListener listener = listenerAndHandler.listener;
+        MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onLoadCanceled(windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData);
-              }
-            });
+            () ->
+                listener.onLoadCanceled(windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData));
       }
     }
 
@@ -539,6 +570,8 @@ public void run() {
      */
     public void loadError(
         DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
         int dataType,
         long elapsedRealtimeMs,
         long loadDurationMs,
@@ -547,6 +580,8 @@ public void loadError(
         boolean wasCanceled) {
       loadError(
           dataSpec,
+          uri,
+          responseHeaders,
           dataType,
           C.TRACK_TYPE_UNKNOWN,
           null,
@@ -567,6 +602,8 @@ public void loadError(
      */
     public void loadError(
         DataSpec dataSpec,
+        Uri uri,
+        Map<String, List<String>> responseHeaders,
         int dataType,
         int trackType,
         @Nullable Format trackFormat,
@@ -580,7 +617,8 @@ public void loadError(
         IOException error,
         boolean wasCanceled) {
       loadError(
-          new LoadEventInfo(dataSpec, elapsedRealtimeMs, loadDurationMs, bytesLoaded),
+          new LoadEventInfo(
+              dataSpec, uri, responseHeaders, elapsedRealtimeMs, loadDurationMs, bytesLoaded),
           new MediaLoadData(
               dataType,
               trackType,
@@ -598,37 +636,28 @@ public void loadError(
      * boolean)}.
      */
     public void loadError(
-        final LoadEventInfo loadEventInfo,
-        final MediaLoadData mediaLoadData,
-        final IOException error,
-        final boolean wasCanceled) {
+        LoadEventInfo loadEventInfo,
+        MediaLoadData mediaLoadData,
+        IOException error,
+        boolean wasCanceled) {
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
+            () ->
                 listener.onLoadError(
-                    windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData, error, wasCanceled);
-              }
-            });
+                    windowIndex, mediaPeriodId, loadEventInfo, mediaLoadData, error, wasCanceled));
       }
     }
 
     /** Dispatches {@link #onReadingStarted(int, MediaPeriodId)}. */
     public void readingStarted() {
-      Assertions.checkState(mediaPeriodId != null);
+      MediaPeriodId mediaPeriodId = Assertions.checkNotNull(this.mediaPeriodId);
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onReadingStarted(windowIndex, mediaPeriodId);
-              }
-            });
+            () -> listener.onReadingStarted(windowIndex, mediaPeriodId));
       }
     }
 
@@ -646,17 +675,13 @@ public void upstreamDiscarded(int trackType, long mediaStartTimeUs, long mediaEn
     }
 
     /** Dispatches {@link #onUpstreamDiscarded(int, MediaPeriodId, MediaLoadData)}. */
-    public void upstreamDiscarded(final MediaLoadData mediaLoadData) {
+    public void upstreamDiscarded(MediaLoadData mediaLoadData) {
+      MediaPeriodId mediaPeriodId = Assertions.checkNotNull(this.mediaPeriodId);
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onUpstreamDiscarded(windowIndex, mediaPeriodId, mediaLoadData);
-              }
-            });
+            () -> listener.onUpstreamDiscarded(windowIndex, mediaPeriodId, mediaLoadData));
       }
     }
 
@@ -679,17 +704,12 @@ public void downstreamFormatChanged(
     }
 
     /** Dispatches {@link #onDownstreamFormatChanged(int, MediaPeriodId, MediaLoadData)}. */
-    public void downstreamFormatChanged(final MediaLoadData mediaLoadData) {
+    public void downstreamFormatChanged(MediaLoadData mediaLoadData) {
       for (ListenerAndHandler listenerAndHandler : listenerAndHandlers) {
         final MediaSourceEventListener listener = listenerAndHandler.listener;
         postOrRun(
             listenerAndHandler.handler,
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onDownstreamFormatChanged(windowIndex, mediaPeriodId, mediaLoadData);
-              }
-            });
+            () -> listener.onDownstreamFormatChanged(windowIndex, mediaPeriodId, mediaLoadData));
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index f9bf86081f..573e97cb13 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -20,7 +20,9 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -39,9 +41,8 @@
    */
   public static final class IllegalMergeException extends IOException {
 
-    /**
-     * The reason the merge failed.
-     */
+    /** The reason the merge failed. One of {@link #REASON_PERIOD_COUNT_MISMATCH}. */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({REASON_PERIOD_COUNT_MISMATCH})
     public @interface Reason {}
@@ -67,10 +68,10 @@ public IllegalMergeException(@Reason int reason) {
   private static final int PERIOD_COUNT_UNSET = -1;
 
   private final MediaSource[] mediaSources;
+  private final Timeline[] timelines;
   private final ArrayList<MediaSource> pendingTimelineSources;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
 
-  private Timeline primaryTimeline;
   private Object primaryManifest;
   private int periodCount;
   private IllegalMergeException mergeError;
@@ -94,11 +95,21 @@ public MergingMediaSource(CompositeSequenceableLoaderFactory compositeSequenceab
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     pendingTimelineSources = new ArrayList<>(Arrays.asList(mediaSources));
     periodCount = PERIOD_COUNT_UNSET;
+    timelines = new Timeline[mediaSources.length];
   }
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
-    super.prepareSourceInternal(player, isTopLevelSource);
+  @Nullable
+  public Object getTag() {
+    return mediaSources.length > 0 ? mediaSources[0].getTag() : null;
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
     for (int i = 0; i < mediaSources.length; i++) {
       prepareChildSource(i, mediaSources[i]);
     }
@@ -115,8 +126,11 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     MediaPeriod[] periods = new MediaPeriod[mediaSources.length];
+    int periodIndex = timelines[0].getIndexOfPeriod(id.periodUid);
     for (int i = 0; i < periods.length; i++) {
-      periods[i] = mediaSources[i].createPeriod(id, allocator);
+      MediaPeriodId childMediaPeriodId =
+          id.copyWithPeriodUid(timelines[i].getUidOfPeriod(periodIndex));
+      periods[i] = mediaSources[i].createPeriod(childMediaPeriodId, allocator);
     }
     return new MergingMediaPeriod(compositeSequenceableLoaderFactory, periods);
   }
@@ -132,7 +146,7 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
   @Override
   public void releaseSourceInternal() {
     super.releaseSourceInternal();
-    primaryTimeline = null;
+    Arrays.fill(timelines, null);
     primaryManifest = null;
     periodCount = PERIOD_COUNT_UNSET;
     mergeError = null;
@@ -150,15 +164,21 @@ protected void onChildSourceInfoRefreshed(
       return;
     }
     pendingTimelineSources.remove(mediaSource);
+    timelines[id] = timeline;
     if (mediaSource == mediaSources[0]) {
-      primaryTimeline = timeline;
       primaryManifest = manifest;
     }
     if (pendingTimelineSources.isEmpty()) {
-      refreshSourceInfo(primaryTimeline, primaryManifest);
+      refreshSourceInfo(timelines[0], primaryManifest);
     }
   }
 
+  @Override
+  protected @Nullable MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(
+      Integer id, MediaPeriodId mediaPeriodId) {
+    return id == 0 ? mediaPeriodId : null;
+  }
+
   private IllegalMergeException checkTimelineMerges(Timeline timeline) {
     if (periodCount == PERIOD_COUNT_UNSET) {
       periodCount = timeline.getPeriodCount();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index d9090baf3b..ecc720c656 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -30,10 +30,8 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * A queue of media samples.
- */
-public final class SampleQueue implements TrackOutput {
+/** A queue of media samples. */
+public class SampleQueue implements TrackOutput {
 
   /**
    * A listener for changes to the upstream format.
@@ -568,18 +566,22 @@ public void sampleData(ParsableByteArray buffer, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
-      CryptoData cryptoData) {
+  public void sampleMetadata(
+      long timeUs,
+      @C.BufferFlags int flags,
+      int size,
+      int offset,
+      @Nullable CryptoData cryptoData) {
     if (pendingFormatAdjustment) {
       format(lastUnadjustedFormat);
     }
+    timeUs += sampleOffsetUs;
     if (pendingSplice) {
       if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0 || !metadataQueue.attemptSplice(timeUs)) {
         return;
       }
       pendingSplice = false;
     }
-    timeUs += sampleOffsetUs;
     long absoluteOffset = totalBytesWritten - size - offset;
     metadataQueue.commitSample(timeUs, flags, absoluteOffset, size, cryptoData);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
index f5f98e4d8a..5af9dbd20a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
@@ -21,6 +21,8 @@
 
 /**
  * Shuffled order of indices.
+ *
+ * <p>The shuffle order must be immutable to ensure thread safety.
  */
 public interface ShuffleOrder {
 
@@ -53,6 +55,17 @@ public DefaultShuffleOrder(int length, long randomSeed) {
       this(length, new Random(randomSeed));
     }
 
+    /**
+     * Creates an instance with a specified shuffle order and the specified random seed. The random
+     * seed is used for {@link #cloneAndInsert(int, int)} invocations.
+     *
+     * @param shuffledIndices The shuffled indices to use as order.
+     * @param randomSeed A random seed.
+     */
+    public DefaultShuffleOrder(int[] shuffledIndices, long randomSeed) {
+      this(Arrays.copyOf(shuffledIndices, shuffledIndices.length), new Random(randomSeed));
+    }
+
     private DefaultShuffleOrder(int length, Random random) {
       this(createShuffledList(length, random), random);
     }
@@ -122,15 +135,16 @@ public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
     }
 
     @Override
-    public ShuffleOrder cloneAndRemove(int removalIndex) {
-      int[] newShuffled = new int[shuffled.length - 1];
-      boolean foundRemovedElement = false;
+    public ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive) {
+      int numberOfElementsToRemove = indexToExclusive - indexFrom;
+      int[] newShuffled = new int[shuffled.length - numberOfElementsToRemove];
+      int foundElementsCount = 0;
       for (int i = 0; i < shuffled.length; i++) {
-        if (shuffled[i] == removalIndex) {
-          foundRemovedElement = true;
+        if (shuffled[i] >= indexFrom && shuffled[i] < indexToExclusive) {
+          foundElementsCount++;
         } else {
-          newShuffled[foundRemovedElement ? i - 1 : i] = shuffled[i] > removalIndex
-              ? shuffled[i] - 1 : shuffled[i];
+          newShuffled[i - foundElementsCount] =
+              shuffled[i] >= indexFrom ? shuffled[i] - numberOfElementsToRemove : shuffled[i];
         }
       }
       return new DefaultShuffleOrder(newShuffled, new Random(random.nextLong()));
@@ -200,8 +214,8 @@ public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
     }
 
     @Override
-    public ShuffleOrder cloneAndRemove(int removalIndex) {
-      return new UnshuffledShuffleOrder(length - 1);
+    public ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive) {
+      return new UnshuffledShuffleOrder(length - indexToExclusive + indexFrom);
     }
 
     @Override
@@ -255,12 +269,14 @@ public ShuffleOrder cloneAndClear() {
   ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount);
 
   /**
-   * Returns a copy of the shuffle order with one element removed.
+   * Returns a copy of the shuffle order with a range of elements removed.
    *
-   * @param removalIndex The index of the element in the unshuffled order which is to be removed.
-   * @return A copy of this {@link ShuffleOrder} without the removed element.
+   * @param indexFrom The starting index in the unshuffled order of the range to remove.
+   * @param indexToExclusive The smallest index (must be greater or equal to {@code indexFrom}) that
+   *     will not be removed.
+   * @return A copy of this {@link ShuffleOrder} without the elements in the removed range.
    */
-  ShuffleOrder cloneAndRemove(int removalIndex);
+  ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive);
 
   /** Returns a copy of the shuffle order with all elements removed. */
   ShuffleOrder cloneAndClear();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 0bddd482ac..9e33a2d898 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -193,4 +193,9 @@ public int getIndexOfPeriod(Object uid) {
     return UID.equals(uid) ? 0 : C.INDEX_UNSET;
   }
 
+  @Override
+  public Object getUidOfPeriod(int periodIndex) {
+    Assertions.checkIndex(periodIndex, 0, 1);
+    return UID;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 41814c4b40..73d590951d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -24,8 +25,12 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.upstream.StatsDataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -45,7 +50,8 @@
 
   private final DataSpec dataSpec;
   private final DataSource.Factory dataSourceFactory;
-  private final int minLoadableRetryCount;
+  private final @Nullable TransferListener transferListener;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final EventDispatcher eventDispatcher;
   private final TrackGroupArray tracks;
   private final ArrayList<SampleStreamImpl> sampleStreams;
@@ -61,21 +67,22 @@
   /* package */ boolean loadingSucceeded;
   /* package */ byte[] sampleData;
   /* package */ int sampleSize;
-  private int errorCount;
 
   public SingleSampleMediaPeriod(
       DataSpec dataSpec,
       DataSource.Factory dataSourceFactory,
+      @Nullable TransferListener transferListener,
       Format format,
       long durationUs,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       EventDispatcher eventDispatcher,
       boolean treatLoadErrorsAsEndOfStream) {
     this.dataSpec = dataSpec;
     this.dataSourceFactory = dataSourceFactory;
+    this.transferListener = transferListener;
     this.format = format;
     this.durationUs = durationUs;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
     this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
     tracks = new TrackGroupArray(new TrackGroup(format));
@@ -137,11 +144,15 @@ public boolean continueLoading(long positionUs) {
     if (loadingFinished || loader.isLoading()) {
       return false;
     }
+    DataSource dataSource = dataSourceFactory.createDataSource();
+    if (transferListener != null) {
+      dataSource.addTransferListener(transferListener);
+    }
     long elapsedRealtimeMs =
         loader.startLoading(
-            new SourceLoadable(dataSpec, dataSourceFactory.createDataSource()),
-            this,
-            minLoadableRetryCount);
+            new SourceLoadable(dataSpec, dataSource),
+            /* callback= */ this,
+            loadErrorHandlingPolicy.getMinimumLoadableRetryCount(C.DATA_TYPE_MEDIA));
     eventDispatcher.loadStarted(
         dataSpec,
         C.DATA_TYPE_MEDIA,
@@ -192,8 +203,14 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
   @Override
   public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs) {
+    sampleSize = (int) loadable.dataSource.getBytesRead();
+    sampleData = loadable.sampleData;
+    loadingFinished = true;
+    loadingSucceeded = true;
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
+        loadable.dataSource.getLastOpenedUri(),
+        loadable.dataSource.getLastResponseHeaders(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         format,
@@ -203,11 +220,7 @@ public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
         durationUs,
         elapsedRealtimeMs,
         loadDurationMs,
-        loadable.sampleSize);
-    sampleSize = loadable.sampleSize;
-    sampleData = loadable.sampleData;
-    loadingFinished = true;
-    loadingSucceeded = true;
+        sampleSize);
   }
 
   @Override
@@ -215,6 +228,8 @@ public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long
       boolean released) {
     eventDispatcher.loadCanceled(
         loadable.dataSpec,
+        loadable.dataSource.getLastOpenedUri(),
+        loadable.dataSource.getLastResponseHeaders(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         /* trackFormat= */ null,
@@ -224,16 +239,38 @@ public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long
         durationUs,
         elapsedRealtimeMs,
         loadDurationMs,
-        loadable.sampleSize);
+        loadable.dataSource.getBytesRead());
   }
 
   @Override
-  public @Loader.RetryAction int onLoadError(
-      SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error) {
-    errorCount++;
-    boolean cancel = treatLoadErrorsAsEndOfStream && errorCount >= minLoadableRetryCount;
+  public LoadErrorAction onLoadError(
+      SourceLoadable loadable,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      IOException error,
+      int errorCount) {
+    long retryDelay =
+        loadErrorHandlingPolicy.getRetryDelayMsFor(
+            C.DATA_TYPE_MEDIA, durationUs, error, errorCount);
+    boolean errorCanBePropagated =
+        retryDelay == C.TIME_UNSET
+            || errorCount
+                >= loadErrorHandlingPolicy.getMinimumLoadableRetryCount(C.DATA_TYPE_MEDIA);
+
+    LoadErrorAction action;
+    if (treatLoadErrorsAsEndOfStream && errorCanBePropagated) {
+      loadingFinished = true;
+      action = Loader.DONT_RETRY;
+    } else {
+      action =
+          retryDelay != C.TIME_UNSET
+              ? Loader.createRetryAction(/* resetErrorCount= */ false, retryDelay)
+              : Loader.DONT_RETRY_FATAL;
+    }
     eventDispatcher.loadError(
         loadable.dataSpec,
+        loadable.dataSource.getLastOpenedUri(),
+        loadable.dataSource.getLastResponseHeaders(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         format,
@@ -243,14 +280,10 @@ public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long
         durationUs,
         elapsedRealtimeMs,
         loadDurationMs,
-        loadable.sampleSize,
+        loadable.dataSource.getBytesRead(),
         error,
-        /* wasCanceled= */ cancel);
-    if (cancel) {
-      loadingFinished = true;
-      return Loader.DONT_RETRY;
-    }
-    return Loader.RETRY;
+        /* wasCanceled= */ !action.isRetry());
+    return action;
   }
 
   private final class SampleStreamImpl implements SampleStream {
@@ -260,7 +293,7 @@ public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long
     private static final int STREAM_STATE_END_OF_STREAM = 2;
 
     private int streamState;
-    private boolean formatSent;
+    private boolean notifiedDownstreamFormat;
 
     public void reset() {
       if (streamState == STREAM_STATE_END_OF_STREAM) {
@@ -283,6 +316,7 @@ public void maybeThrowError() throws IOException {
     @Override
     public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         boolean requireFormat) {
+      maybeNotifyDownstreamFormat();
       if (streamState == STREAM_STATE_END_OF_STREAM) {
         buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
@@ -296,7 +330,6 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
           buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
           buffer.ensureSpaceForWrite(sampleSize);
           buffer.data.put(sampleData, 0, sampleSize);
-          sendFormat();
         } else {
           buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
         }
@@ -308,23 +341,23 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
 
     @Override
     public int skipData(long positionUs) {
+      maybeNotifyDownstreamFormat();
       if (positionUs > 0 && streamState != STREAM_STATE_END_OF_STREAM) {
         streamState = STREAM_STATE_END_OF_STREAM;
-        sendFormat();
         return 1;
       }
       return 0;
     }
 
-    private void sendFormat() {
-      if (!formatSent) {
+    private void maybeNotifyDownstreamFormat() {
+      if (!notifiedDownstreamFormat) {
         eventDispatcher.downstreamFormatChanged(
             MimeTypes.getTrackType(format.sampleMimeType),
             format,
             C.SELECTION_REASON_UNKNOWN,
             /* trackSelectionData= */ null,
             /* mediaTimeUs= */ 0);
-        formatSent = true;
+        notifiedDownstreamFormat = true;
       }
     }
   }
@@ -333,14 +366,13 @@ private void sendFormat() {
 
     public final DataSpec dataSpec;
 
-    private final DataSource dataSource;
+    private final StatsDataSource dataSource;
 
-    private int sampleSize;
     private byte[] sampleData;
 
     public SourceLoadable(DataSpec dataSpec, DataSource dataSource) {
       this.dataSpec = dataSpec;
-      this.dataSource = dataSource;
+      this.dataSource = new StatsDataSource(dataSource);
     }
 
     @Override
@@ -350,15 +382,15 @@ public void cancelLoad() {
 
     @Override
     public void load() throws IOException, InterruptedException {
-      // We always load from the beginning, so reset the sampleSize to 0.
-      sampleSize = 0;
+      // We always load from the beginning, so reset bytesRead to 0.
+      dataSource.resetBytesRead();
       try {
         // Create and open the input.
         dataSource.open(dataSpec);
         // Load the sample data.
         int result = 0;
         while (result != C.RESULT_END_OF_INPUT) {
-          sampleSize += result;
+          int sampleSize = (int) dataSource.getBytesRead();
           if (sampleData == null) {
             sampleData = new byte[INITIAL_SAMPLE_SIZE];
           } else if (sampleSize == sampleData.length) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 2c651bef59..66097970c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -24,6 +24,9 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 
@@ -55,7 +58,7 @@
 
     private final DataSource.Factory dataSourceFactory;
 
-    private int minLoadableRetryCount;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private boolean treatLoadErrorsAsEndOfStream;
     private boolean isCreateCalled;
     private @Nullable Object tag;
@@ -68,7 +71,7 @@
      */
     public Factory(DataSource.Factory dataSourceFactory) {
       this.dataSourceFactory = Assertions.checkNotNull(dataSourceFactory);
-      this.minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
     }
 
     /**
@@ -86,16 +89,36 @@ public Factory setTag(Object tag) {
     }
 
     /**
-     * Sets the minimum number of times to retry if a loading error occurs. The default value is
-     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     * Sets the minimum number of times to retry if a loading error occurs. See {@link
+     * #setLoadErrorHandlingPolicy} for the default value.
+     *
+     * <p>Calling this method is equivalent to calling {@link #setLoadErrorHandlingPolicy} with
+     * {@link DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy(int)
+     * DefaultLoadErrorHandlingPolicy(minLoadableRetryCount)}
      *
      * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     * @deprecated Use {@link #setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy)} instead.
      */
+    @Deprecated
     public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      return setLoadErrorHandlingPolicy(new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount));
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy}. The default value is created by calling {@link
+     * DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy()}.
+     *
+     * <p>Calling this method overrides any calls to {@link #setMinLoadableRetryCount(int)}.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
       Assertions.checkState(!isCreateCalled);
-      this.minLoadableRetryCount = minLoadableRetryCount;
+      this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
       return this;
     }
 
@@ -130,7 +153,7 @@ public SingleSampleMediaSource createMediaSource(Uri uri, Format format, long du
           dataSourceFactory,
           format,
           durationUs,
-          minLoadableRetryCount,
+          loadErrorHandlingPolicy,
           treatLoadErrorsAsEndOfStream,
           tag);
     }
@@ -155,18 +178,16 @@ public SingleSampleMediaSource createMediaSource(
 
   }
 
-  /**
-   * The default minimum number of times to retry loading data prior to failing.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
-
   private final DataSpec dataSpec;
   private final DataSource.Factory dataSourceFactory;
   private final Format format;
   private final long durationUs;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final boolean treatLoadErrorsAsEndOfStream;
   private final Timeline timeline;
+  @Nullable private final Object tag;
+
+  private @Nullable TransferListener transferListener;
 
   /**
    * @param uri The {@link Uri} of the media stream.
@@ -177,9 +198,15 @@ public SingleSampleMediaSource createMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public SingleSampleMediaSource(
       Uri uri, DataSource.Factory dataSourceFactory, Format format, long durationUs) {
-    this(uri, dataSourceFactory, format, durationUs, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+    this(
+        uri,
+        dataSourceFactory,
+        format,
+        durationUs,
+        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
   /**
@@ -203,7 +230,7 @@ public SingleSampleMediaSource(
         dataSourceFactory,
         format,
         durationUs,
-        minLoadableRetryCount,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
         /* treatLoadErrorsAsEndOfStream= */ false,
         /* tag= */ null);
   }
@@ -224,6 +251,7 @@ public SingleSampleMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public SingleSampleMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
@@ -239,7 +267,7 @@ public SingleSampleMediaSource(
         dataSourceFactory,
         format,
         durationUs,
-        minLoadableRetryCount,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
         treatLoadErrorsAsEndOfStream,
         /* tag= */ null);
     if (eventHandler != null && eventListener != null) {
@@ -252,15 +280,17 @@ private SingleSampleMediaSource(
       DataSource.Factory dataSourceFactory,
       Format format,
       long durationUs,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       boolean treatLoadErrorsAsEndOfStream,
       @Nullable Object tag) {
     this.dataSourceFactory = dataSourceFactory;
     this.format = format;
     this.durationUs = durationUs;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
-    dataSpec = new DataSpec(uri);
+    this.tag = tag;
+    dataSpec =
+        new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
     timeline =
         new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false, tag);
   }
@@ -268,7 +298,17 @@ private SingleSampleMediaSource(
   // MediaSource implementation.
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    transferListener = mediaTransferListener;
     refreshSourceInfo(timeline, /* manifest= */ null);
   }
 
@@ -279,13 +319,13 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    Assertions.checkArgument(id.periodIndex == 0);
     return new SingleSampleMediaPeriod(
         dataSpec,
         dataSourceFactory,
+        transferListener,
         format,
         durationUs,
-        minLoadableRetryCount,
+        loadErrorHandlingPolicy,
         createEventDispatcher(id),
         treatLoadErrorsAsEndOfStream);
   }
@@ -304,6 +344,8 @@ public void releaseSourceInternal() {
    * Wraps a deprecated {@link EventListener}, invoking its callback from the equivalent callback in
    * {@link MediaSourceEventListener}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   private static final class EventListenerWrapper extends DefaultMediaSourceEventListener {
 
     private final EventListener eventListener;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
index 8654e94bdb..41adb78906 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
@@ -20,6 +20,7 @@
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -96,6 +97,30 @@ public boolean hasUnplayedAds() {
       return count == C.LENGTH_UNSET || getFirstAdIndexToPlay() < count;
     }
 
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+      AdGroup adGroup = (AdGroup) o;
+      return count == adGroup.count
+          && Arrays.equals(uris, adGroup.uris)
+          && Arrays.equals(states, adGroup.states)
+          && Arrays.equals(durationsUs, adGroup.durationsUs);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = count;
+      result = 31 * result + Arrays.hashCode(uris);
+      result = 31 * result + Arrays.hashCode(states);
+      result = 31 * result + Arrays.hashCode(durationsUs);
+      return result;
+    }
+
     /**
      * Returns a new instance with the ad count set to {@code count}. This method may only be called
      * if this instance's ad count has not yet been specified.
@@ -210,7 +235,12 @@ public AdGroup withAllAdsSkipped() {
     }
   }
 
-  /** Represents the state of an ad in an ad group. */
+  /**
+   * Represents the state of an ad in an ad group. One of {@link #AD_STATE_UNAVAILABLE}, {@link
+   * #AD_STATE_AVAILABLE}, {@link #AD_STATE_SKIPPED}, {@link #AD_STATE_PLAYED} or {@link
+   * #AD_STATE_ERROR}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     AD_STATE_UNAVAILABLE,
@@ -287,8 +317,7 @@ public int getAdGroupIndexForPositionUs(long positionUs) {
     // Use a linear search as the array elements may not be increasing due to TIME_END_OF_SOURCE.
     // In practice we expect there to be few ad groups so the search shouldn't be expensive.
     int index = adGroupTimesUs.length - 1;
-    while (index >= 0
-        && (adGroupTimesUs[index] == C.TIME_END_OF_SOURCE || adGroupTimesUs[index] > positionUs)) {
+    while (index >= 0 && isPositionBeforeAdGroup(positionUs, index)) {
       index--;
     }
     return index >= 0 && adGroups[index].hasUnplayedAds() ? index : C.INDEX_UNSET;
@@ -344,6 +373,14 @@ public AdPlaybackState withPlayedAd(int adGroupIndex, int adIndexInAdGroup) {
     return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
   }
 
+  /** Returns an instance with the specified ad marked as skipped. */
+  @CheckResult
+  public AdPlaybackState withSkippedAd(int adGroupIndex, int adIndexInAdGroup) {
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    adGroups[adGroupIndex] = adGroups[adGroupIndex].withAdState(AD_STATE_SKIPPED, adIndexInAdGroup);
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
+  }
+
   /** Returns an instance with the specified ad marked as having a load error. */
   @CheckResult
   public AdPlaybackState withAdLoadError(int adGroupIndex, int adIndexInAdGroup) {
@@ -393,4 +430,38 @@ public AdPlaybackState withContentDurationUs(long contentDurationUs) {
     }
   }
 
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    AdPlaybackState that = (AdPlaybackState) o;
+    return adGroupCount == that.adGroupCount
+        && adResumePositionUs == that.adResumePositionUs
+        && contentDurationUs == that.contentDurationUs
+        && Arrays.equals(adGroupTimesUs, that.adGroupTimesUs)
+        && Arrays.equals(adGroups, that.adGroups);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = adGroupCount;
+    result = 31 * result + (int) adResumePositionUs;
+    result = 31 * result + (int) contentDurationUs;
+    result = 31 * result + Arrays.hashCode(adGroupTimesUs);
+    result = 31 * result + Arrays.hashCode(adGroups);
+    return result;
+  }
+
+  private boolean isPositionBeforeAdGroup(long positionUs, int adGroupIndex) {
+    long adGroupPositionUs = adGroupTimesUs[adGroupIndex];
+    if (adGroupPositionUs == C.TIME_END_OF_SOURCE) {
+      return contentDurationUs == C.TIME_UNSET || positionUs < contentDurationUs;
+    } else {
+      return positionUs < adGroupPositionUs;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
index d05c51a793..f041542356 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
@@ -88,7 +88,9 @@
    * Attaches a player that will play ads loaded using this instance. Called on the main thread by
    * {@link AdsMediaSource}.
    *
-   * @param player The player instance that will play the loaded ads.
+   * @param player The player instance that will play the loaded ads. Only players which are
+   *     accessed on the main thread are supported ({@code player.getApplicationLooper() ==
+   *     Looper.getMainLooper()}).
    * @param eventListener Listener for ads loader events.
    * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
index 7f9dc18eaf..19ddbd2c54 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -36,17 +36,24 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-/** A {@link MediaSource} that inserts ads linearly with a provided content media source. */
+/**
+ * A {@link MediaSource} that inserts ads linearly with a provided content media source. This source
+ * cannot be used as a child source in a composition. It must be the top-level source used to
+ * prepare the player.
+ */
 public final class AdsMediaSource extends CompositeMediaSource<MediaPeriodId> {
 
   /** Factory for creating {@link MediaSource}s to play ad media. */
@@ -77,7 +84,11 @@
    */
   public static final class AdLoadException extends IOException {
 
-    /** Types of ad load exceptions. */
+    /**
+     * Types of ad load exceptions. One of {@link #TYPE_AD}, {@link #TYPE_AD_GROUP}, {@link
+     * #TYPE_ALL_ADS} or {@link #TYPE_UNEXPECTED}.
+     */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({TYPE_AD, TYPE_AD_GROUP, TYPE_ALL_ADS, TYPE_UNEXPECTED})
     public @interface Type {}
@@ -169,7 +180,9 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
 
   }
 
-  private static final String TAG = "AdsMediaSource";
+  // Used to identify the content "child" source for CompositeMediaSource.
+  private static final MediaPeriodId DUMMY_CONTENT_MEDIA_PERIOD_ID =
+      new MediaPeriodId(/* periodUid= */ new Object());
 
   private final MediaSource contentMediaSource;
   private final MediaSourceFactory adMediaSourceFactory;
@@ -187,7 +200,7 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
   private Object contentManifest;
   private AdPlaybackState adPlaybackState;
   private MediaSource[][] adGroupMediaSources;
-  private long[][] adDurationsUs;
+  private Timeline[][] adGroupTimelines;
 
   /**
    * Constructs a new source that inserts ads linearly with the content specified by {@code
@@ -302,23 +315,29 @@ public AdsMediaSource(
     deferredMediaPeriodByAdMediaSource = new HashMap<>();
     period = new Timeline.Period();
     adGroupMediaSources = new MediaSource[0][];
-    adDurationsUs = new long[0][];
+    adGroupTimelines = new Timeline[0][];
     adsLoader.setSupportedContentTypes(adMediaSourceFactory.getSupportedTypes());
   }
 
   @Override
-  public void prepareSourceInternal(final ExoPlayer player, boolean isTopLevelSource) {
-    super.prepareSourceInternal(player, isTopLevelSource);
-    Assertions.checkArgument(isTopLevelSource);
+  @Nullable
+  public Object getTag() {
+    return contentMediaSource.getTag();
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      final ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+    Assertions.checkArgument(
+        isTopLevelSource,
+        "AdsMediaSource must be the top-level source used to prepare the player.");
     final ComponentListener componentListener = new ComponentListener();
     this.componentListener = componentListener;
-    prepareChildSource(new MediaPeriodId(/* periodIndex= */ 0), contentMediaSource);
-    mainHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        adsLoader.attachPlayer(player, componentListener, adUiViewGroup);
-      }
-    });
+    prepareChildSource(DUMMY_CONTENT_MEDIA_PERIOD_ID, contentMediaSource);
+    mainHandler.post(() -> adsLoader.attachPlayer(player, componentListener, adUiViewGroup));
   }
 
   @Override
@@ -334,24 +353,22 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
           int adCount = adIndexInAdGroup + 1;
           adGroupMediaSources[adGroupIndex] =
               Arrays.copyOf(adGroupMediaSources[adGroupIndex], adCount);
-          adDurationsUs[adGroupIndex] = Arrays.copyOf(adDurationsUs[adGroupIndex], adCount);
-          Arrays.fill(adDurationsUs[adGroupIndex], oldAdCount, adCount, C.TIME_UNSET);
+          adGroupTimelines[adGroupIndex] = Arrays.copyOf(adGroupTimelines[adGroupIndex], adCount);
         }
         adGroupMediaSources[adGroupIndex][adIndexInAdGroup] = adMediaSource;
-        deferredMediaPeriodByAdMediaSource.put(adMediaSource, new ArrayList<DeferredMediaPeriod>());
+        deferredMediaPeriodByAdMediaSource.put(adMediaSource, new ArrayList<>());
         prepareChildSource(id, adMediaSource);
       }
       MediaSource mediaSource = adGroupMediaSources[adGroupIndex][adIndexInAdGroup];
-      DeferredMediaPeriod deferredMediaPeriod =
-          new DeferredMediaPeriod(
-              mediaSource,
-              new MediaPeriodId(/* periodIndex= */ 0, id.windowSequenceNumber),
-              allocator);
+      DeferredMediaPeriod deferredMediaPeriod = new DeferredMediaPeriod(mediaSource, id, allocator);
       deferredMediaPeriod.setPrepareErrorListener(
           new AdPrepareErrorListener(adUri, adGroupIndex, adIndexInAdGroup));
       List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.get(mediaSource);
       if (mediaPeriods == null) {
-        deferredMediaPeriod.createPeriod();
+        Object periodUid =
+            adGroupTimelines[adGroupIndex][adIndexInAdGroup].getUidOfPeriod(/* periodIndex= */ 0);
+        MediaPeriodId adSourceMediaPeriodId = new MediaPeriodId(periodUid, id.windowSequenceNumber);
+        deferredMediaPeriod.createPeriod(adSourceMediaPeriodId);
       } else {
         // Keep track of the deferred media period so it can be populated with the real media period
         // when the source's info becomes available.
@@ -360,7 +377,7 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
       return deferredMediaPeriod;
     } else {
       DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(contentMediaSource, id, allocator);
-      mediaPeriod.createPeriod();
+      mediaPeriod.createPeriod(id);
       return mediaPeriod;
     }
   }
@@ -386,13 +403,8 @@ public void releaseSourceInternal() {
     contentManifest = null;
     adPlaybackState = null;
     adGroupMediaSources = new MediaSource[0][];
-    adDurationsUs = new long[0][];
-    mainHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        adsLoader.detachPlayer();
-      }
-    });
+    adGroupTimelines = new Timeline[0][];
+    mainHandler.post(adsLoader::detachPlayer);
   }
 
   @Override
@@ -413,8 +425,8 @@ protected void onChildSourceInfoRefreshed(
   @Override
   protected @Nullable MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(
       MediaPeriodId childId, MediaPeriodId mediaPeriodId) {
-    // The child id for the content period is just a dummy without window sequence number. That's
-    // why we need to forward the reported mediaPeriodId in this case.
+    // The child id for the content period is just DUMMY_CONTENT_MEDIA_PERIOD_ID. That's why we need
+    // to forward the reported mediaPeriodId in this case.
     return childId.isAd() ? childId : mediaPeriodId;
   }
 
@@ -424,8 +436,8 @@ private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
     if (this.adPlaybackState == null) {
       adGroupMediaSources = new MediaSource[adPlaybackState.adGroupCount][];
       Arrays.fill(adGroupMediaSources, new MediaSource[0]);
-      adDurationsUs = new long[adPlaybackState.adGroupCount][];
-      Arrays.fill(adDurationsUs, new long[0]);
+      adGroupTimelines = new Timeline[adPlaybackState.adGroupCount][];
+      Arrays.fill(adGroupTimelines, new Timeline[0]);
     }
     this.adPlaybackState = adPlaybackState;
     maybeUpdateSourceInfo();
@@ -440,20 +452,23 @@ private void onContentSourceInfoRefreshed(Timeline timeline, Object manifest) {
   private void onAdSourceInfoRefreshed(MediaSource mediaSource, int adGroupIndex,
       int adIndexInAdGroup, Timeline timeline) {
     Assertions.checkArgument(timeline.getPeriodCount() == 1);
-    adDurationsUs[adGroupIndex][adIndexInAdGroup] = timeline.getPeriod(0, period).getDurationUs();
-    if (deferredMediaPeriodByAdMediaSource.containsKey(mediaSource)) {
-      List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.get(mediaSource);
+    adGroupTimelines[adGroupIndex][adIndexInAdGroup] = timeline;
+    List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.remove(mediaSource);
+    if (mediaPeriods != null) {
+      Object periodUid = timeline.getUidOfPeriod(/* periodIndex= */ 0);
       for (int i = 0; i < mediaPeriods.size(); i++) {
-        mediaPeriods.get(i).createPeriod();
+        DeferredMediaPeriod mediaPeriod = mediaPeriods.get(i);
+        MediaPeriodId adSourceMediaPeriodId =
+            new MediaPeriodId(periodUid, mediaPeriod.id.windowSequenceNumber);
+        mediaPeriod.createPeriod(adSourceMediaPeriodId);
       }
-      deferredMediaPeriodByAdMediaSource.remove(mediaSource);
     }
     maybeUpdateSourceInfo();
   }
 
   private void maybeUpdateSourceInfo() {
     if (adPlaybackState != null && contentTimeline != null) {
-      adPlaybackState = adPlaybackState.withAdDurationsUs(adDurationsUs);
+      adPlaybackState = adPlaybackState.withAdDurationsUs(getAdDurations(adGroupTimelines, period));
       Timeline timeline =
           adPlaybackState.adGroupCount == 0
               ? contentTimeline
@@ -462,6 +477,20 @@ private void maybeUpdateSourceInfo() {
     }
   }
 
+  private static long[][] getAdDurations(Timeline[][] adTimelines, Timeline.Period period) {
+    long[][] adDurations = new long[adTimelines.length][];
+    for (int i = 0; i < adTimelines.length; i++) {
+      adDurations[i] = new long[adTimelines[i].length];
+      for (int j = 0; j < adTimelines[i].length; j++) {
+        adDurations[i][j] =
+            adTimelines[i][j] == null
+                ? C.TIME_UNSET
+                : adTimelines[i][j].getPeriod(/* periodIndex= */ 0, period).getDurationUs();
+      }
+    }
+    return adDurations;
+  }
+
   /** Listener for component events. All methods are called on the main thread. */
   private final class ComponentListener implements AdsLoader.EventListener {
 
@@ -488,15 +517,13 @@ public void onAdPlaybackState(final AdPlaybackState adPlaybackState) {
       if (released) {
         return;
       }
-      playerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if (released) {
-            return;
-          }
-          AdsMediaSource.this.onAdPlaybackState(adPlaybackState);
-        }
-      });
+      playerHandler.post(
+          () -> {
+            if (released) {
+              return;
+            }
+            AdsMediaSource.this.onAdPlaybackState(adPlaybackState);
+          });
     }
 
     @Override
@@ -505,14 +532,12 @@ public void onAdClicked() {
         return;
       }
       if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            if (!released) {
-              eventListener.onAdClicked();
-            }
-          }
-        });
+        eventHandler.post(
+            () -> {
+              if (!released) {
+                eventListener.onAdClicked();
+              }
+            });
       }
     }
 
@@ -522,14 +547,12 @@ public void onAdTapped() {
         return;
       }
       if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            if (!released) {
-              eventListener.onAdTapped();
-            }
-          }
-        });
+        eventHandler.post(
+            () -> {
+              if (!released) {
+                eventListener.onAdTapped();
+              }
+            });
       }
     }
 
@@ -541,6 +564,8 @@ public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
       createEventDispatcher(/* mediaPeriodId= */ null)
           .loadError(
               dataSpec,
+              dataSpec.uri,
+              /* responseHeaders= */ Collections.emptyMap(),
               C.DATA_TYPE_AD,
               C.TRACK_TYPE_UNKNOWN,
               /* loadDurationMs= */ 0,
@@ -549,15 +574,12 @@ public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
               /* wasCanceled= */ true);
       if (eventHandler != null && eventListener != null) {
         eventHandler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                if (!released) {
-                  if (error.type == AdLoadException.TYPE_UNEXPECTED) {
-                    eventListener.onInternalAdLoadError(error.getRuntimeExceptionForUnexpected());
-                  } else {
-                    eventListener.onAdLoadError(error);
-                  }
+            () -> {
+              if (!released) {
+                if (error.type == AdLoadException.TYPE_UNEXPECTED) {
+                  eventListener.onInternalAdLoadError(error.getRuntimeExceptionForUnexpected());
+                } else {
+                  eventListener.onAdLoadError(error);
                 }
               }
             });
@@ -582,6 +604,8 @@ public void onPrepareError(MediaPeriodId mediaPeriodId, final IOException except
       createEventDispatcher(mediaPeriodId)
           .loadError(
               new DataSpec(adUri),
+              adUri,
+              /* responseHeaders= */ Collections.emptyMap(),
               C.DATA_TYPE_AD,
               C.TRACK_TYPE_UNKNOWN,
               /* loadDurationMs= */ 0,
@@ -589,12 +613,7 @@ public void onPrepareError(MediaPeriodId mediaPeriodId, final IOException except
               AdLoadException.createForAd(exception),
               /* wasCanceled= */ true);
       mainHandler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              adsLoader.handlePrepareError(adGroupIndex, adIndexInAdGroup, exception);
-            }
-          });
+          () -> adsLoader.handlePrepareError(adGroupIndex, adIndexInAdGroup, exception));
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
index b0c245b706..0594a635a5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
@@ -15,15 +15,15 @@
  */
 package com.google.android.exoplayer2.source.ads;
 
+import android.support.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ForwardingTimeline;
 import com.google.android.exoplayer2.util.Assertions;
 
-/**
- * A {@link Timeline} for sources that have ads.
- */
-/* package */ final class SinglePeriodAdTimeline extends ForwardingTimeline {
+/** A {@link Timeline} for sources that have ads. */
+@VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+public final class SinglePeriodAdTimeline extends ForwardingTimeline {
 
   private final AdPlaybackState adPlaybackState;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
index e872f730de..68322c60a1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
@@ -26,10 +26,15 @@
 public abstract class BaseMediaChunk extends MediaChunk {
 
   /**
-   * The media time from which output will begin, or {@link C#TIME_UNSET} if the whole chunk should
-   * be output.
+   * The time from which output will begin, or {@link C#TIME_UNSET} if output will begin from the
+   * start of the chunk.
    */
-  public final long seekTimeUs;
+  public final long clippedStartTimeUs;
+  /**
+   * The time from which output will end, or {@link C#TIME_UNSET} if output will end at the end of
+   * the chunk.
+   */
+  public final long clippedEndTimeUs;
 
   private BaseMediaChunkOutput output;
   private int[] firstSampleIndices;
@@ -42,8 +47,10 @@
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
-   * @param seekTimeUs The media time from which output will begin, or {@link C#TIME_UNSET} if the
-   *     whole chunk should be output.
+   * @param clippedStartTimeUs The time in the chunk from which output will begin, or {@link
+   *     C#TIME_UNSET} to output from the start of the chunk.
+   * @param clippedEndTimeUs The time in the chunk from which output will end, or {@link
+   *     C#TIME_UNSET} to output to the end of the chunk.
    * @param chunkIndex The index of the chunk, or {@link C#INDEX_UNSET} if it is not known.
    */
   public BaseMediaChunk(
@@ -54,11 +61,13 @@ public BaseMediaChunk(
       Object trackSelectionData,
       long startTimeUs,
       long endTimeUs,
-      long seekTimeUs,
+      long clippedStartTimeUs,
+      long clippedEndTimeUs,
       long chunkIndex) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
-    this.seekTimeUs = seekTimeUs;
+    this.clippedStartTimeUs = clippedStartTimeUs;
+    this.clippedEndTimeUs = clippedEndTimeUs;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java
new file mode 100644
index 0000000000..68dd322449
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.chunk;
+
+import java.util.NoSuchElementException;
+
+/**
+ * Base class for {@link MediaChunkIterator}s. Handles {@link #next()} and {@link #isEnded()}, and
+ * provides a bounds check for child classes.
+ */
+public abstract class BaseMediaChunkIterator implements MediaChunkIterator {
+
+  private final long fromIndex;
+  private final long toIndex;
+
+  private long currentIndex;
+
+  /**
+   * Creates base iterator.
+   *
+   * @param fromIndex The index at which the iterator will start.
+   * @param toIndex The last available index.
+   */
+  public BaseMediaChunkIterator(long fromIndex, long toIndex) {
+    this.fromIndex = fromIndex;
+    this.toIndex = toIndex;
+    currentIndex = fromIndex - 1;
+  }
+
+  @Override
+  public boolean isEnded() {
+    return currentIndex > toIndex;
+  }
+
+  @Override
+  public boolean next() {
+    currentIndex++;
+    return !isEnded();
+  }
+
+  /**
+   * Verifies that the iterator points to a valid element.
+   *
+   * @throws NoSuchElementException If the iterator does not point to a valid element.
+   */
+  protected void checkInBounds() {
+    if (currentIndex < fromIndex || currentIndex > toIndex) {
+      throw new NoSuchElementException();
+    }
+  }
+
+  /** Returns the current index this iterator is pointing to. */
+  protected long getCurrentIndex() {
+    return currentIndex;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java
index e0129e5c64..0bcc46fcbf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java
@@ -15,11 +15,11 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
-import android.util.Log;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.TrackOutputProvider;
+import com.google.android.exoplayer2.util.Log;
 
 /** An output for {@link BaseMediaChunk}s. */
 public final class BaseMediaChunkOutput implements TrackOutputProvider {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java
index 0453a8fa12..91c3afec80 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java
@@ -15,13 +15,17 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import android.net.Uri;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.upstream.StatsDataSource;
 import com.google.android.exoplayer2.util.Assertions;
+import java.util.List;
+import java.util.Map;
 
 /**
  * An abstract base class for {@link Loadable} implementations that load chunks of data required
@@ -64,7 +68,7 @@
    */
   public final long endTimeUs;
 
-  protected final DataSource dataSource;
+  protected final StatsDataSource dataSource;
 
   /**
    * @param dataSource The source from which the data should be loaded.
@@ -85,7 +89,7 @@ public Chunk(
       @Nullable Object trackSelectionData,
       long startTimeUs,
       long endTimeUs) {
-    this.dataSource = Assertions.checkNotNull(dataSource);
+    this.dataSource = new StatsDataSource(dataSource);
     this.dataSpec = Assertions.checkNotNull(dataSpec);
     this.type = type;
     this.trackFormat = trackFormat;
@@ -103,8 +107,31 @@ public final long getDurationUs() {
   }
 
   /**
-   * Returns the number of bytes that have been loaded.
+   * Returns the number of bytes that have been loaded. Must only be called after the load
+   * completed, failed, or was canceled.
    */
-  public abstract long bytesLoaded();
+  public final long bytesLoaded() {
+    return dataSource.getBytesRead();
+  }
+
+  /**
+   * Returns the {@link Uri} associated with the last {@link DataSource#open} call. If redirection
+   * occurred, this is the redirected uri. Must only be called after the load completed, failed, or
+   * was canceled.
+   *
+   * @see DataSource#getUri()
+   */
+  public final Uri getUri() {
+    return dataSource.getLastOpenedUri();
+  }
 
+  /**
+   * Returns the response headers associated with the last {@link DataSource#open} call. Must only
+   * be called after the load completed, failed, or was canceled.
+   *
+   * @see DataSource#getResponseHeaders()
+   */
+  public final Map<String, List<String>> getResponseHeaders() {
+    return dataSource.getLastResponseHeaders();
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index f043571b69..a8676b5a05 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import android.support.annotation.Nullable;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -63,6 +64,7 @@
 
   private boolean extractorInitialized;
   private TrackOutputProvider trackOutputProvider;
+  private long endTimeUs;
   private SeekMap seekMap;
   private Format[] sampleFormats;
 
@@ -100,21 +102,25 @@ public SeekMap getSeekMap() {
    * TrackOutputProvider}, and configures the extractor to receive data from a new chunk.
    *
    * @param trackOutputProvider The provider of {@link TrackOutput}s that will receive sample data.
-   * @param seekTimeUs The seek position within the new chunk, or {@link C#TIME_UNSET} to output the
-   *     whole chunk.
+   * @param startTimeUs The start position in the new chunk, or {@link C#TIME_UNSET} to output
+   *     samples from the start of the chunk.
+   * @param endTimeUs The end position in the new chunk, or {@link C#TIME_UNSET} to output samples
+   *     to the end of the chunk.
    */
-  public void init(TrackOutputProvider trackOutputProvider, long seekTimeUs) {
+  public void init(
+      @Nullable TrackOutputProvider trackOutputProvider, long startTimeUs, long endTimeUs) {
     this.trackOutputProvider = trackOutputProvider;
+    this.endTimeUs = endTimeUs;
     if (!extractorInitialized) {
       extractor.init(this);
-      if (seekTimeUs != C.TIME_UNSET) {
-        extractor.seek(/* position= */ 0, seekTimeUs);
+      if (startTimeUs != C.TIME_UNSET) {
+        extractor.seek(/* position= */ 0, startTimeUs);
       }
       extractorInitialized = true;
     } else {
-      extractor.seek(/* position= */ 0, seekTimeUs == C.TIME_UNSET ? 0 : seekTimeUs);
+      extractor.seek(/* position= */ 0, startTimeUs == C.TIME_UNSET ? 0 : startTimeUs);
       for (int i = 0; i < bindingTrackOutputs.size(); i++) {
-        bindingTrackOutputs.valueAt(i).bind(trackOutputProvider);
+        bindingTrackOutputs.valueAt(i).bind(trackOutputProvider, endTimeUs);
       }
     }
   }
@@ -130,7 +136,7 @@ public TrackOutput track(int id, int type) {
       // TODO: Manifest formats for embedded tracks should also be passed here.
       bindingTrackOutput = new BindingTrackOutput(id, type,
           type == primaryTrackType ? primaryTrackManifestFormat : null);
-      bindingTrackOutput.bind(trackOutputProvider);
+      bindingTrackOutput.bind(trackOutputProvider, endTimeUs);
       bindingTrackOutputs.put(id, bindingTrackOutput);
     }
     return bindingTrackOutput;
@@ -157,21 +163,25 @@ public void seekMap(SeekMap seekMap) {
     private final int id;
     private final int type;
     private final Format manifestFormat;
+    private final DummyTrackOutput dummyTrackOutput;
 
     public Format sampleFormat;
     private TrackOutput trackOutput;
+    private long endTimeUs;
 
     public BindingTrackOutput(int id, int type, Format manifestFormat) {
       this.id = id;
       this.type = type;
       this.manifestFormat = manifestFormat;
+      dummyTrackOutput = new DummyTrackOutput();
     }
 
-    public void bind(TrackOutputProvider trackOutputProvider) {
+    public void bind(TrackOutputProvider trackOutputProvider, long endTimeUs) {
       if (trackOutputProvider == null) {
-        trackOutput = new DummyTrackOutput();
+        trackOutput = dummyTrackOutput;
         return;
       }
+      this.endTimeUs = endTimeUs;
       trackOutput = trackOutputProvider.track(id, type);
       if (sampleFormat != null) {
         trackOutput.format(sampleFormat);
@@ -199,6 +209,9 @@ public void sampleData(ParsableByteArray data, int length) {
     @Override
     public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
         CryptoData cryptoData) {
+      if (endTimeUs != C.TIME_UNSET && timeUs >= endTimeUs) {
+        trackOutput = dummyTrackOutput;
+      }
       trackOutput.sampleMetadata(timeUs, flags, size, offset, cryptoData);
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 6cda68bac9..9fac69b281 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.source.chunk;
 
 import android.support.annotation.Nullable;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -27,8 +26,12 @@
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -63,7 +66,7 @@
   private final T chunkSource;
   private final SequenceableLoader.Callback<ChunkSampleStream<T>> callback;
   private final EventDispatcher eventDispatcher;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final Loader loader;
   private final ChunkHolder nextChunkHolder;
   private final ArrayList<BaseMediaChunk> mediaChunks;
@@ -76,10 +79,14 @@
   private @Nullable ReleaseCallback<T> releaseCallback;
   private long pendingResetPositionUs;
   private long lastSeekPositionUs;
+  private int nextNotifyPrimaryFormatMediaChunkIndex;
+
   /* package */ long decodeOnlyUntilPositionUs;
   /* package */ boolean loadingFinished;
 
   /**
+   * Constructs an instance.
+   *
    * @param primaryTrackType The type of the primary track. One of the {@link C} {@code
    *     TRACK_TYPE_*} constants.
    * @param embeddedTrackTypes The types of any embedded tracks, or null.
@@ -91,7 +98,10 @@
    * @param minLoadableRetryCount The minimum number of times that the source should retry a load
    *     before propagating an error.
    * @param eventDispatcher A dispatcher to notify of events.
+   * @deprecated Use {@link #ChunkSampleStream(int, int[], Format[], ChunkSource, Callback,
+   *     Allocator, long, LoadErrorHandlingPolicy, EventDispatcher)} instead.
    */
+  @Deprecated
   public ChunkSampleStream(
       int primaryTrackType,
       int[] embeddedTrackTypes,
@@ -102,13 +112,49 @@ public ChunkSampleStream(
       long positionUs,
       int minLoadableRetryCount,
       EventDispatcher eventDispatcher) {
+    this(
+        primaryTrackType,
+        embeddedTrackTypes,
+        embeddedTrackFormats,
+        chunkSource,
+        callback,
+        allocator,
+        positionUs,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
+        eventDispatcher);
+  }
+
+  /**
+   * Constructs an instance.
+   *
+   * @param primaryTrackType The type of the primary track. One of the {@link C} {@code
+   *     TRACK_TYPE_*} constants.
+   * @param embeddedTrackTypes The types of any embedded tracks, or null.
+   * @param embeddedTrackFormats The formats of the embedded tracks, or null.
+   * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
+   * @param callback An {@link Callback} for the stream.
+   * @param allocator An {@link Allocator} from which allocations can be obtained.
+   * @param positionUs The position from which to start loading media.
+   * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
+   * @param eventDispatcher A dispatcher to notify of events.
+   */
+  public ChunkSampleStream(
+      int primaryTrackType,
+      int[] embeddedTrackTypes,
+      Format[] embeddedTrackFormats,
+      T chunkSource,
+      Callback<ChunkSampleStream<T>> callback,
+      Allocator allocator,
+      long positionUs,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
+      EventDispatcher eventDispatcher) {
     this.primaryTrackType = primaryTrackType;
     this.embeddedTrackTypes = embeddedTrackTypes;
     this.embeddedTrackFormats = embeddedTrackFormats;
     this.chunkSource = chunkSource;
     this.callback = callback;
     this.eventDispatcher = eventDispatcher;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     loader = new Loader("Loader:ChunkSampleStream");
     nextChunkHolder = new ChunkHolder();
     mediaChunks = new ArrayList<>();
@@ -144,16 +190,19 @@ public ChunkSampleStream(
    *     the specified position, rather than any sample before or at that position.
    */
   public void discardBuffer(long positionUs, boolean toKeyframe) {
-    int oldFirstIndex = primarySampleQueue.getFirstIndex();
+    if (isPendingReset()) {
+      return;
+    }
+    int oldFirstSampleIndex = primarySampleQueue.getFirstIndex();
     primarySampleQueue.discardTo(positionUs, toKeyframe, true);
-    int newFirstIndex = primarySampleQueue.getFirstIndex();
-    if (newFirstIndex > oldFirstIndex) {
+    int newFirstSampleIndex = primarySampleQueue.getFirstIndex();
+    if (newFirstSampleIndex > oldFirstSampleIndex) {
       long discardToUs = primarySampleQueue.getFirstTimestampUs();
       for (int i = 0; i < embeddedSampleQueues.length; i++) {
         embeddedSampleQueues[i].discardTo(discardToUs, toKeyframe, embeddedTracksSelected[i]);
       }
-      discardDownstreamMediaChunks(newFirstIndex);
     }
+    discardDownstreamMediaChunks(newFirstSampleIndex);
   }
 
   /**
@@ -230,55 +279,62 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
    */
   public void seekToUs(long positionUs) {
     lastSeekPositionUs = positionUs;
-    primarySampleQueue.rewind();
+    if (isPendingReset()) {
+      // A reset is already pending. We only need to update its position.
+      pendingResetPositionUs = positionUs;
+      return;
+    }
+
+    // Detect whether the seek is to the start of a chunk that's at least partially buffered.
+    BaseMediaChunk seekToMediaChunk = null;
+    for (int i = 0; i < mediaChunks.size(); i++) {
+      BaseMediaChunk mediaChunk = mediaChunks.get(i);
+      long mediaChunkStartTimeUs = mediaChunk.startTimeUs;
+      if (mediaChunkStartTimeUs == positionUs && mediaChunk.clippedStartTimeUs == C.TIME_UNSET) {
+        seekToMediaChunk = mediaChunk;
+        break;
+      } else if (mediaChunkStartTimeUs > positionUs) {
+        // We're not going to find a chunk with a matching start time.
+        break;
+      }
+    }
 
-    // See if we can seek within the primary sample queue.
+    // See if we can seek inside the primary sample queue.
     boolean seekInsideBuffer;
-    if (isPendingReset()) {
-      seekInsideBuffer = false;
+    primarySampleQueue.rewind();
+    if (seekToMediaChunk != null) {
+      // When seeking to the start of a chunk we use the index of the first sample in the chunk
+      // rather than the seek position. This ensures we seek to the keyframe at the start of the
+      // chunk even if the sample timestamps are slightly offset from the chunk start times.
+      seekInsideBuffer =
+          primarySampleQueue.setReadPosition(seekToMediaChunk.getFirstSampleIndex(0));
+      decodeOnlyUntilPositionUs = 0;
     } else {
-      // Detect whether the seek is to the start of a chunk that's at least partially buffered.
-      BaseMediaChunk seekToMediaChunk = null;
-      for (int i = 0; i < mediaChunks.size(); i++) {
-        BaseMediaChunk mediaChunk = mediaChunks.get(i);
-        long mediaChunkStartTimeUs = mediaChunk.startTimeUs;
-        if (mediaChunkStartTimeUs == positionUs && mediaChunk.seekTimeUs == C.TIME_UNSET) {
-          seekToMediaChunk = mediaChunk;
-          break;
-        } else if (mediaChunkStartTimeUs > positionUs) {
-          // We're not going to find a chunk with a matching start time.
-          break;
-        }
-      }
-      if (seekToMediaChunk != null) {
-        // When seeking to the start of a chunk we use the index of the first sample in the chunk
-        // rather than the seek position. This ensures we seek to the keyframe at the start of the
-        // chunk even if the sample timestamps are slightly offset from the chunk start times.
-        seekInsideBuffer =
-            primarySampleQueue.setReadPosition(seekToMediaChunk.getFirstSampleIndex(0));
-        decodeOnlyUntilPositionUs = Long.MIN_VALUE;
-      } else {
-        seekInsideBuffer =
-            primarySampleQueue.advanceTo(
-                    positionUs,
-                    /* toKeyframe= */ true,
-                    /* allowTimeBeyondBuffer= */ positionUs < getNextLoadPositionUs())
-                != SampleQueue.ADVANCE_FAILED;
-        decodeOnlyUntilPositionUs = lastSeekPositionUs;
-      }
+      seekInsideBuffer =
+          primarySampleQueue.advanceTo(
+                  positionUs,
+                  /* toKeyframe= */ true,
+                  /* allowTimeBeyondBuffer= */ positionUs < getNextLoadPositionUs())
+              != SampleQueue.ADVANCE_FAILED;
+      decodeOnlyUntilPositionUs = lastSeekPositionUs;
     }
 
     if (seekInsideBuffer) {
-      // We succeeded. Advance the embedded sample queues to the seek position.
+      // We can seek inside the buffer.
+      nextNotifyPrimaryFormatMediaChunkIndex =
+          primarySampleIndexToMediaChunkIndex(
+              primarySampleQueue.getReadIndex(), /* minChunkIndex= */ 0);
+      // Advance the embedded sample queues to the seek position.
       for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
         embeddedSampleQueue.rewind();
         embeddedSampleQueue.advanceTo(positionUs, true, false);
       }
     } else {
-      // We failed, and need to restart.
+      // We can't seek inside the buffer, and so need to reset.
       pendingResetPositionUs = positionUs;
       loadingFinished = false;
       mediaChunks.clear();
+      nextNotifyPrimaryFormatMediaChunkIndex = 0;
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
@@ -351,13 +407,9 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
     if (isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
-    int result =
-        primarySampleQueue.read(
-            formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
-    if (result == C.RESULT_BUFFER_READ) {
-      maybeNotifyPrimaryTrackFormatChanged(primarySampleQueue.getReadIndex(), 1);
-    }
-    return result;
+    maybeNotifyPrimaryTrackFormatChanged();
+    return primarySampleQueue.read(
+        formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
   }
 
   @Override
@@ -374,9 +426,7 @@ public int skipData(long positionUs) {
         skipCount = 0;
       }
     }
-    if (skipCount > 0) {
-      maybeNotifyPrimaryTrackFormatChanged(primarySampleQueue.getReadIndex(), skipCount);
-    }
+    maybeNotifyPrimaryTrackFormatChanged();
     return skipCount;
   }
 
@@ -385,9 +435,19 @@ public int skipData(long positionUs) {
   @Override
   public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
     chunkSource.onChunkLoadCompleted(loadable);
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, primaryTrackType,
-        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
-        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs,
+    eventDispatcher.loadCompleted(
+        loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
+        loadable.type,
+        primaryTrackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
         loadable.bytesLoaded());
     callback.onContinueLoadingRequested(this);
   }
@@ -395,9 +455,19 @@ public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDur
   @Override
   public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
       boolean released) {
-    eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, primaryTrackType,
-        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
-        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs,
+    eventDispatcher.loadCanceled(
+        loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
+        loadable.type,
+        primaryTrackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
         loadable.bytesLoaded());
     if (!released) {
       primarySampleQueue.reset();
@@ -409,19 +479,26 @@ public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDura
   }
 
   @Override
-  public @Loader.RetryAction int onLoadError(
-      Chunk loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error) {
+  public LoadErrorAction onLoadError(
+      Chunk loadable,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      IOException error,
+      int errorCount) {
     long bytesLoaded = loadable.bytesLoaded();
     boolean isMediaChunk = isMediaChunk(loadable);
     int lastChunkIndex = mediaChunks.size() - 1;
     boolean cancelable =
         bytesLoaded == 0 || !isMediaChunk || !haveReadFromMediaChunk(lastChunkIndex);
-    boolean canceled = false;
-    if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
-      if (!cancelable) {
-        Log.w(TAG, "Ignoring attempt to cancel non-cancelable load.");
-      } else {
-        canceled = true;
+    long blacklistDurationMs =
+        cancelable
+            ? loadErrorHandlingPolicy.getBlacklistDurationMsFor(
+                loadable.type, loadDurationMs, error, errorCount)
+            : C.TIME_UNSET;
+    LoadErrorAction loadErrorAction = null;
+    if (chunkSource.onChunkLoadError(loadable, cancelable, error, blacklistDurationMs)) {
+      if (cancelable) {
+        loadErrorAction = Loader.DONT_RETRY;
         if (isMediaChunk) {
           BaseMediaChunk removed = discardUpstreamMediaChunksFromIndex(lastChunkIndex);
           Assertions.checkState(removed == loadable);
@@ -429,18 +506,43 @@ public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDura
             pendingResetPositionUs = lastSeekPositionUs;
           }
         }
+      } else {
+        Log.w(TAG, "Ignoring attempt to cancel non-cancelable load.");
       }
     }
-    eventDispatcher.loadError(loadable.dataSpec, loadable.type, primaryTrackType,
-        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
-        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, bytesLoaded,
-        error, canceled);
+
+    if (loadErrorAction == null) {
+      // The load was not cancelled. Either the load must be retried or the error propagated.
+      long retryDelayMs =
+          loadErrorHandlingPolicy.getRetryDelayMsFor(
+              loadable.type, loadDurationMs, error, errorCount);
+      loadErrorAction =
+          retryDelayMs != C.TIME_UNSET
+              ? Loader.createRetryAction(/* resetErrorCount= */ false, retryDelayMs)
+              : Loader.DONT_RETRY_FATAL;
+    }
+
+    boolean canceled = !loadErrorAction.isRetry();
+    eventDispatcher.loadError(
+        loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
+        loadable.type,
+        primaryTrackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        bytesLoaded,
+        error,
+        canceled);
     if (canceled) {
       callback.onContinueLoadingRequested(this);
-      return Loader.DONT_RETRY;
-    } else {
-      return Loader.RETRY;
     }
+    return loadErrorAction;
   }
 
   // SequenceableLoader implementation
@@ -452,16 +554,16 @@ public boolean continueLoading(long positionUs) {
     }
 
     boolean pendingReset = isPendingReset();
-    MediaChunk previousChunk;
+    List<BaseMediaChunk> chunkQueue;
     long loadPositionUs;
     if (pendingReset) {
-      previousChunk = null;
+      chunkQueue = Collections.emptyList();
       loadPositionUs = pendingResetPositionUs;
     } else {
-      previousChunk = getLastMediaChunk();
-      loadPositionUs = previousChunk.endTimeUs;
+      chunkQueue = readOnlyMediaChunks;
+      loadPositionUs = getLastMediaChunk().endTimeUs;
     }
-    chunkSource.getNextChunk(previousChunk, positionUs, loadPositionUs, nextChunkHolder);
+    chunkSource.getNextChunk(positionUs, loadPositionUs, chunkQueue, nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     nextChunkHolder.clear();
@@ -481,16 +583,25 @@ public boolean continueLoading(long positionUs) {
       if (pendingReset) {
         boolean resetToMediaChunk = mediaChunk.startTimeUs == pendingResetPositionUs;
         // Only enable setting of the decode only flag if we're not resetting to a chunk boundary.
-        decodeOnlyUntilPositionUs = resetToMediaChunk ? Long.MIN_VALUE : pendingResetPositionUs;
+        decodeOnlyUntilPositionUs = resetToMediaChunk ? 0 : pendingResetPositionUs;
         pendingResetPositionUs = C.TIME_UNSET;
       }
       mediaChunk.init(mediaChunkOutput);
       mediaChunks.add(mediaChunk);
     }
-    long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
-    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, primaryTrackType,
-        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
-        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs);
+    long elapsedRealtimeMs =
+        loader.startLoading(
+            loadable, this, loadErrorHandlingPolicy.getMinimumLoadableRetryCount(loadable.type));
+    eventDispatcher.loadStarted(
+        loadable.dataSpec,
+        loadable.type,
+        primaryTrackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs);
     return true;
   }
 
@@ -559,22 +670,25 @@ private boolean haveReadFromMediaChunk(int mediaChunkIndex) {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
-  private void discardDownstreamMediaChunks(int discardToPrimaryStreamIndex) {
+  private void discardDownstreamMediaChunks(int discardToSampleIndex) {
     int discardToMediaChunkIndex =
-        primaryStreamIndexToMediaChunkIndex(discardToPrimaryStreamIndex, /* minChunkIndex= */ 0);
+        primarySampleIndexToMediaChunkIndex(discardToSampleIndex, /* minChunkIndex= */ 0);
+    // Don't discard any chunks that we haven't reported the primary format change for yet.
+    discardToMediaChunkIndex =
+        Math.min(discardToMediaChunkIndex, nextNotifyPrimaryFormatMediaChunkIndex);
     if (discardToMediaChunkIndex > 0) {
       Util.removeRange(mediaChunks, /* fromIndex= */ 0, /* toIndex= */ discardToMediaChunkIndex);
+      nextNotifyPrimaryFormatMediaChunkIndex -= discardToMediaChunkIndex;
     }
   }
 
-  private void maybeNotifyPrimaryTrackFormatChanged(int toPrimaryStreamReadIndex, int readCount) {
-    int fromMediaChunkIndex = primaryStreamIndexToMediaChunkIndex(
-        toPrimaryStreamReadIndex - readCount, /* minChunkIndex= */ 0);
-    int toMediaChunkIndexInclusive = readCount == 1 ? fromMediaChunkIndex
-        : primaryStreamIndexToMediaChunkIndex(toPrimaryStreamReadIndex - 1,
-            /* minChunkIndex= */ fromMediaChunkIndex);
-    for (int i = fromMediaChunkIndex; i <= toMediaChunkIndexInclusive; i++) {
-      maybeNotifyPrimaryTrackFormatChanged(i);
+  private void maybeNotifyPrimaryTrackFormatChanged() {
+    int readSampleIndex = primarySampleQueue.getReadIndex();
+    int notifyToMediaChunkIndex =
+        primarySampleIndexToMediaChunkIndex(
+            readSampleIndex, /* minChunkIndex= */ nextNotifyPrimaryFormatMediaChunkIndex - 1);
+    while (nextNotifyPrimaryFormatMediaChunkIndex <= notifyToMediaChunkIndex) {
+      maybeNotifyPrimaryTrackFormatChanged(nextNotifyPrimaryFormatMediaChunkIndex++);
     }
   }
 
@@ -590,12 +704,20 @@ private void maybeNotifyPrimaryTrackFormatChanged(int mediaChunkReadIndex) {
   }
 
   /**
-   * Returns media chunk index for primary stream sample index. May be -1 if the list of media
-   * chunks is empty or the requested index is less than the first index in the first media chunk.
+   * Returns the media chunk index corresponding to a given primary sample index.
+   *
+   * @param primarySampleIndex The primary sample index for which the corresponding media chunk
+   *     index is required.
+   * @param minChunkIndex A minimum chunk index from which to start searching, or -1 if no hint can
+   *     be provided.
+   * @return The index of the media chunk corresponding to the sample index, or -1 if the list of
+   *     media chunks is empty, or {@code minChunkIndex} if the sample precedes the first chunk in
+   *     the search (i.e. the chunk at {@code minChunkIndex}, or at index 0 if {@code minChunkIndex}
+   *     is -1.
    */
-  private int primaryStreamIndexToMediaChunkIndex(int primaryStreamIndex, int minChunkIndex) {
+  private int primarySampleIndexToMediaChunkIndex(int primarySampleIndex, int minChunkIndex) {
     for (int i = minChunkIndex + 1; i < mediaChunks.size(); i++) {
-      if (mediaChunks.get(i).getFirstSampleIndex(0) > primaryStreamIndex) {
+      if (mediaChunks.get(i).getFirstSampleIndex(0) > primarySampleIndex) {
         return i - 1;
       }
     }
@@ -616,6 +738,8 @@ private BaseMediaChunk getLastMediaChunk() {
   private BaseMediaChunk discardUpstreamMediaChunksFromIndex(int chunkIndex) {
     BaseMediaChunk firstRemovedChunk = mediaChunks.get(chunkIndex);
     Util.removeRange(mediaChunks, /* fromIndex= */ chunkIndex, /* toIndex= */ mediaChunks.size());
+    nextNotifyPrimaryFormatMediaChunkIndex =
+        Math.max(nextNotifyPrimaryFormatMediaChunkIndex, mediaChunks.size());
     primarySampleQueue.discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(0));
     for (int i = 0; i < embeddedSampleQueues.length; i++) {
       embeddedSampleQueues[i].discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(i + 1));
@@ -633,7 +757,7 @@ private BaseMediaChunk discardUpstreamMediaChunksFromIndex(int chunkIndex) {
     private final SampleQueue sampleQueue;
     private final int index;
 
-    private boolean formatNotificationSent;
+    private boolean notifiedDownstreamFormat;
 
     public EmbeddedSampleStream(ChunkSampleStream<T> parent, SampleQueue sampleQueue, int index) {
       this.parent = parent;
@@ -648,6 +772,10 @@ public boolean isReady() {
 
     @Override
     public int skipData(long positionUs) {
+      if (isPendingReset()) {
+        return 0;
+      }
+      maybeNotifyDownstreamFormat();
       int skipCount;
       if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
         skipCount = sampleQueue.advanceToEnd();
@@ -657,9 +785,6 @@ public int skipData(long positionUs) {
           skipCount = 0;
         }
       }
-      if (skipCount > 0) {
-        maybeNotifyTrackFormatChanged();
-      }
       return skipCount;
     }
 
@@ -674,13 +799,9 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       if (isPendingReset()) {
         return C.RESULT_NOTHING_READ;
       }
-      int result =
-          sampleQueue.read(
-              formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
-      if (result == C.RESULT_BUFFER_READ) {
-        maybeNotifyTrackFormatChanged();
-      }
-      return result;
+      maybeNotifyDownstreamFormat();
+      return sampleQueue.read(
+          formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
     }
 
     public void release() {
@@ -688,15 +809,15 @@ public void release() {
       embeddedTracksSelected[index] = false;
     }
 
-    private void maybeNotifyTrackFormatChanged() {
-      if (!formatNotificationSent) {
+    private void maybeNotifyDownstreamFormat() {
+      if (!notifiedDownstreamFormat) {
         eventDispatcher.downstreamFormatChanged(
             embeddedTrackTypes[index],
             embeddedTrackFormats[index],
             C.SELECTION_REASON_UNKNOWN,
             /* trackSelectionData= */ null,
             lastSeekPositionUs);
-        formatNotificationSent = true;
+        notifiedDownstreamFormat = true;
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
index 568461c206..ee940954bd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.SeekParameters;
 import java.io.IOException;
 import java.util.List;
@@ -59,29 +60,32 @@
 
   /**
    * Returns the next chunk to load.
-   * <p>
-   * If a chunk is available then {@link ChunkHolder#chunk} is set. If the end of the stream has
+   *
+   * <p>If a chunk is available then {@link ChunkHolder#chunk} is set. If the end of the stream has
    * been reached then {@link ChunkHolder#endOfStream} is set. If a chunk is not available but the
    * end of the stream has not been reached, the {@link ChunkHolder} is not modified.
    *
-   * @param previous The most recently loaded media chunk.
    * @param playbackPositionUs The current playback position in microseconds. If playback of the
    *     period to which this chunk source belongs has not yet started, the value will be the
    *     starting position in the period minus the duration of any media in previous periods still
    *     to be played.
-   * @param loadPositionUs The current load position in microseconds. If {@code previous} is null,
+   * @param loadPositionUs The current load position in microseconds. If {@code queue} is empty,
    *     this is the starting position from which chunks should be provided. Else it's equal to
-   *     {@code previous.endTimeUs}.
+   *     {@link MediaChunk#endTimeUs} of the last chunk in the {@code queue}.
+   * @param queue The queue of buffered {@link MediaChunk}s.
    * @param out A holder to populate.
    */
-  void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+  void getNextChunk(
+      long playbackPositionUs,
+      long loadPositionUs,
+      List<? extends MediaChunk> queue,
       ChunkHolder out);
 
   /**
    * Called when the {@link ChunkSampleStream} has finished loading a chunk obtained from this
    * source.
-   * <p>
-   * This method should only be called when the source is enabled.
+   *
+   * <p>This method should only be called when the source is enabled.
    *
    * @param chunk The chunk whose load has been completed.
    */
@@ -90,15 +94,15 @@ void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositio
   /**
    * Called when the {@link ChunkSampleStream} encounters an error loading a chunk obtained from
    * this source.
-   * <p>
-   * This method should only be called when the source is enabled.
+   *
+   * <p>This method should only be called when the source is enabled.
    *
    * @param chunk The chunk whose load encountered the error.
    * @param cancelable Whether the load can be canceled.
    * @param e The error.
-   * @return Whether the load should be canceled. Should always be false if {@code cancelable} is
-   *     false.
+   * @param blacklistDurationMs The duration for which the associated track may be blacklisted, or
+   *     {@link C#TIME_UNSET} if the track may not be blacklisted.
+   * @return Whether the load should be canceled. Must be false if {@code cancelable} is false.
    */
-  boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e);
-
+  boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e, long blacklistDurationMs);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java
deleted file mode 100644
index 38e0c0d51f..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.chunk;
-
-import android.util.Log;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
-
-/**
- * Helper class for blacklisting tracks in a {@link TrackSelection} when 404 (Not Found) and 410
- * (Gone) HTTP response codes are encountered.
- */
-public final class ChunkedTrackBlacklistUtil {
-
-  /**
-   * The default duration for which a track is blacklisted in milliseconds.
-   */
-  public static final long DEFAULT_TRACK_BLACKLIST_MS = 60000;
-
-  private static final String TAG = "ChunkedTrackBlacklist";
-
-  /**
-   * Blacklists {@code trackSelectionIndex} in {@code trackSelection} for
-   * {@link #DEFAULT_TRACK_BLACKLIST_MS} if {@code e} is an {@link InvalidResponseCodeException}
-   * with {@link InvalidResponseCodeException#responseCode} equal to 404 or 410. Else does nothing.
-   * Note that blacklisting will fail if the track is the only non-blacklisted track in the
-   * selection.
-   *
-   * @param trackSelection The track selection.
-   * @param trackSelectionIndex The index in the selection to consider blacklisting.
-   * @param e The error to inspect.
-   * @return Whether the track was blacklisted in the selection.
-   */
-  public static boolean maybeBlacklistTrack(TrackSelection trackSelection, int trackSelectionIndex,
-      Exception e) {
-    return maybeBlacklistTrack(trackSelection, trackSelectionIndex, e, DEFAULT_TRACK_BLACKLIST_MS);
-  }
-
-  /**
-   * Blacklists {@code trackSelectionIndex} in {@code trackSelection} for
-   * {@code blacklistDurationMs} if calling {@link #shouldBlacklist(Exception)} for {@code e}
-   * returns true. Else does nothing. Note that blacklisting will fail if the track is the only
-   * non-blacklisted track in the selection.
-   *
-   * @param trackSelection The track selection.
-   * @param trackSelectionIndex The index in the selection to consider blacklisting.
-   * @param e The error to inspect.
-   * @param blacklistDurationMs The duration to blacklist the track for, if it is blacklisted.
-   * @return Whether the track was blacklisted.
-   */
-  public static boolean maybeBlacklistTrack(TrackSelection trackSelection, int trackSelectionIndex,
-      Exception e, long blacklistDurationMs) {
-    if (shouldBlacklist(e)) {
-      boolean blacklisted = trackSelection.blacklist(trackSelectionIndex, blacklistDurationMs);
-      int responseCode = ((InvalidResponseCodeException) e).responseCode;
-      if (blacklisted) {
-        Log.w(TAG, "Blacklisted: duration=" + blacklistDurationMs + ", responseCode="
-            + responseCode + ", format=" + trackSelection.getFormat(trackSelectionIndex));
-      } else {
-        Log.w(TAG, "Blacklisting failed (cannot blacklist last enabled track): responseCode="
-            + responseCode + ", format=" + trackSelection.getFormat(trackSelectionIndex));
-      }
-      return blacklisted;
-    }
-    return false;
-  }
-
-  /**
-   * Returns whether a loading error is an {@link InvalidResponseCodeException} with
-   * {@link InvalidResponseCodeException#responseCode} equal to 404 or 410.
-   *
-   * @param e The loading error.
-   * @return Wheter the loading error is an {@link InvalidResponseCodeException} with
-   *     {@link InvalidResponseCodeException#responseCode} equal to 404 or 410.
-   */
-  public static boolean shouldBlacklist(Exception e) {
-    if (e instanceof InvalidResponseCodeException) {
-      int responseCode = ((InvalidResponseCodeException) e).responseCode;
-      return responseCode == 404 || responseCode == 410;
-    }
-    return false;
-  }
-
-  private ChunkedTrackBlacklistUtil() {}
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
index 1159f336a7..10b823d444 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
@@ -31,13 +32,15 @@
  */
 public class ContainerMediaChunk extends BaseMediaChunk {
 
+  private static final PositionHolder DUMMY_POSITION_HOLDER = new PositionHolder();
+
   private final int chunkCount;
   private final long sampleOffsetUs;
   private final ChunkExtractorWrapper extractorWrapper;
 
-  private volatile int bytesLoaded;
+  private long nextLoadPosition;
   private volatile boolean loadCanceled;
-  private volatile boolean loadCompleted;
+  private boolean loadCompleted;
 
   /**
    * @param dataSource The source from which the data should be loaded.
@@ -47,8 +50,10 @@
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
-   * @param seekTimeUs The media time from which output will begin, or {@link C#TIME_UNSET} if the
-   *     whole chunk should be output.
+   * @param clippedStartTimeUs The time in the chunk from which output will begin, or {@link
+   *     C#TIME_UNSET} to output from the start of the chunk.
+   * @param clippedEndTimeUs The time in the chunk from which output will end, or {@link
+   *     C#TIME_UNSET} to output to the end of the chunk.
    * @param chunkIndex The index of the chunk, or {@link C#INDEX_UNSET} if it is not known.
    * @param chunkCount The number of chunks in the underlying media that are spanned by this
    *     instance. Normally equal to one, but may be larger if multiple chunks as defined by the
@@ -64,7 +69,8 @@ public ContainerMediaChunk(
       Object trackSelectionData,
       long startTimeUs,
       long endTimeUs,
-      long seekTimeUs,
+      long clippedStartTimeUs,
+      long clippedEndTimeUs,
       long chunkIndex,
       int chunkCount,
       long sampleOffsetUs,
@@ -77,7 +83,8 @@ public ContainerMediaChunk(
         trackSelectionData,
         startTimeUs,
         endTimeUs,
-        seekTimeUs,
+        clippedStartTimeUs,
+        clippedEndTimeUs,
         chunkIndex);
     this.chunkCount = chunkCount;
     this.sampleOffsetUs = sampleOffsetUs;
@@ -94,11 +101,6 @@ public boolean isLoadCompleted() {
     return loadCompleted;
   }
 
-  @Override
-  public final long bytesLoaded() {
-    return bytesLoaded;
-  }
-
   // Loadable implementation.
 
   @Override
@@ -109,28 +111,32 @@ public final void cancelLoad() {
   @SuppressWarnings("NonAtomicVolatileUpdate")
   @Override
   public final void load() throws IOException, InterruptedException {
-    DataSpec loadDataSpec = dataSpec.subrange(bytesLoaded);
+    DataSpec loadDataSpec = dataSpec.subrange(nextLoadPosition);
     try {
       // Create and open the input.
       ExtractorInput input = new DefaultExtractorInput(dataSource,
           loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
-      if (bytesLoaded == 0) {
+      if (nextLoadPosition == 0) {
         // Configure the output and set it as the target for the extractor wrapper.
         BaseMediaChunkOutput output = getOutput();
         output.setSampleOffsetUs(sampleOffsetUs);
         extractorWrapper.init(
-            output, seekTimeUs == C.TIME_UNSET ? 0 : (seekTimeUs - sampleOffsetUs));
+            output,
+            clippedStartTimeUs == C.TIME_UNSET
+                ? C.TIME_UNSET
+                : (clippedStartTimeUs - sampleOffsetUs),
+            clippedEndTimeUs == C.TIME_UNSET ? C.TIME_UNSET : (clippedEndTimeUs - sampleOffsetUs));
       }
       // Load and decode the sample data.
       try {
         Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
+          result = extractor.read(input, DUMMY_POSITION_HOLDER);
         }
         Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
-        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+        nextLoadPosition = input.getPosition() - dataSpec.absoluteStreamPosition;
       }
     } finally {
       Util.closeQuietly(dataSource);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
index 1d3bdb57da..7ea2521eb2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
@@ -32,7 +32,6 @@
   private static final int READ_GRANULARITY = 16 * 1024;
 
   private byte[] data;
-  private int limit;
 
   private volatile boolean loadCanceled;
 
@@ -63,11 +62,6 @@ public DataChunk(DataSource dataSource, DataSpec dataSpec, int type, Format trac
     return data;
   }
 
-  @Override
-  public long bytesLoaded() {
-    return limit;
-  }
-
   // Loadable implementation
 
   @Override
@@ -79,10 +73,10 @@ public final void cancelLoad() {
   public final void load() throws IOException, InterruptedException {
     try {
       dataSource.open(dataSpec);
-      limit = 0;
+      int limit = 0;
       int bytesRead = 0;
       while (bytesRead != C.RESULT_END_OF_INPUT && !loadCanceled) {
-        maybeExpandData();
+        maybeExpandData(limit);
         bytesRead = dataSource.read(data, limit, READ_GRANULARITY);
         if (bytesRead != -1) {
           limit += bytesRead;
@@ -106,7 +100,7 @@ public final void load() throws IOException, InterruptedException {
    */
   protected abstract void consume(byte[] data, int limit) throws IOException;
 
-  private void maybeExpandData() {
+  private void maybeExpandData(int limit) {
     if (data == null) {
       data = new byte[READ_GRANULARITY];
     } else if (data.length < limit + READ_GRANULARITY) {
@@ -115,5 +109,4 @@ private void maybeExpandData() {
       data = Arrays.copyOf(data, data.length + READ_GRANULARITY);
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
index 387a90297a..eecf471b24 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
@@ -32,9 +33,11 @@
  */
 public final class InitializationChunk extends Chunk {
 
+  private static final PositionHolder DUMMY_POSITION_HOLDER = new PositionHolder();
+
   private final ChunkExtractorWrapper extractorWrapper;
 
-  private volatile int bytesLoaded;
+  private long nextLoadPosition;
   private volatile boolean loadCanceled;
 
   /**
@@ -57,11 +60,6 @@ public InitializationChunk(
     this.extractorWrapper = extractorWrapper;
   }
 
-  @Override
-  public long bytesLoaded() {
-    return bytesLoaded;
-  }
-
   // Loadable implementation.
 
   @Override
@@ -72,24 +70,27 @@ public void cancelLoad() {
   @SuppressWarnings("NonAtomicVolatileUpdate")
   @Override
   public void load() throws IOException, InterruptedException {
-    DataSpec loadDataSpec = dataSpec.subrange(bytesLoaded);
+    DataSpec loadDataSpec = dataSpec.subrange(nextLoadPosition);
     try {
       // Create and open the input.
       ExtractorInput input = new DefaultExtractorInput(dataSource,
           loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
-      if (bytesLoaded == 0) {
-        extractorWrapper.init(/* trackOutputProvider= */ null, C.TIME_UNSET);
+      if (nextLoadPosition == 0) {
+        extractorWrapper.init(
+            /* trackOutputProvider= */ null,
+            /* startTimeUs= */ C.TIME_UNSET,
+            /* endTimeUs= */ C.TIME_UNSET);
       }
       // Load and decode the initialization data.
       try {
         Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
+          result = extractor.read(input, DUMMY_POSITION_HOLDER);
         }
         Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
-        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+        nextLoadPosition = input.getPosition() - dataSpec.absoluteStreamPosition;
       }
     } finally {
       Util.closeQuietly(dataSource);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java
new file mode 100644
index 0000000000..71d8940e26
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.chunk;
+
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.util.NoSuchElementException;
+
+/**
+ * Iterator for media chunk sequences.
+ *
+ * <p>The iterator initially points in front of the first available element. The first call to
+ * {@link #next()} moves the iterator to the first element. Check the return value of {@link
+ * #next()} or {@link #isEnded()} to determine whether the iterator reached the end of the available
+ * data.
+ */
+public interface MediaChunkIterator {
+
+  /** An empty media chunk iterator without available data. */
+  MediaChunkIterator EMPTY =
+      new MediaChunkIterator() {
+        @Override
+        public boolean isEnded() {
+          return true;
+        }
+
+        @Override
+        public boolean next() {
+          return false;
+        }
+
+        @Override
+        public DataSpec getDataSpec() {
+          throw new NoSuchElementException();
+        }
+
+        @Override
+        public long getChunkStartTimeUs() {
+          throw new NoSuchElementException();
+        }
+
+        @Override
+        public long getChunkEndTimeUs() {
+          throw new NoSuchElementException();
+        }
+      };
+
+  /** Returns whether the iteration has reached the end of the available data. */
+  boolean isEnded();
+
+  /**
+   * Moves the iterator to the next media chunk.
+   *
+   * <p>Check the return value or {@link #isEnded()} to determine whether the iterator reached the
+   * end of the available data.
+   *
+   * @return Whether the iterator points to a media chunk with available data.
+   */
+  boolean next();
+
+  /**
+   * Returns the {@link DataSpec} used to load the media chunk.
+   *
+   * @throws java.util.NoSuchElementException If the method is called before the first call to
+   *     {@link #next()} or when {@link #isEnded()} is true.
+   */
+  DataSpec getDataSpec();
+
+  /**
+   * Returns the media start time of the chunk, in microseconds.
+   *
+   * @throws java.util.NoSuchElementException If the method is called before the first call to
+   *     {@link #next()} or when {@link #isEnded()} is true.
+   */
+  long getChunkStartTimeUs();
+
+  /**
+   * Returns the media end time of the chunk, in microseconds.
+   *
+   * @throws java.util.NoSuchElementException If the method is called before the first call to
+   *     {@link #next()} or when {@link #isEnded()} is true.
+   */
+  long getChunkEndTimeUs();
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
index 17154ebc62..d53caf8e10 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
@@ -33,8 +33,8 @@
   private final int trackType;
   private final Format sampleFormat;
 
-  private volatile int bytesLoaded;
-  private volatile boolean loadCompleted;
+  private long nextLoadPosition;
+  private boolean loadCompleted;
 
   /**
    * @param dataSource The source from which the data should be loaded.
@@ -68,7 +68,8 @@ public SingleSampleMediaChunk(
         trackSelectionData,
         startTimeUs,
         endTimeUs,
-        C.TIME_UNSET,
+        /* clippedStartTimeUs= */ C.TIME_UNSET,
+        /* clippedEndTimeUs= */ C.TIME_UNSET,
         chunkIndex);
     this.trackType = trackType;
     this.sampleFormat = sampleFormat;
@@ -80,11 +81,6 @@ public boolean isLoadCompleted() {
     return loadCompleted;
   }
 
-  @Override
-  public long bytesLoaded() {
-    return bytesLoaded;
-  }
-
   // Loadable implementation.
 
   @Override
@@ -95,14 +91,15 @@ public void cancelLoad() {
   @SuppressWarnings("NonAtomicVolatileUpdate")
   @Override
   public void load() throws IOException, InterruptedException {
-    DataSpec loadDataSpec = dataSpec.subrange(bytesLoaded);
+    DataSpec loadDataSpec = dataSpec.subrange(nextLoadPosition);
     try {
       // Create and open the input.
       long length = dataSource.open(loadDataSpec);
       if (length != C.LENGTH_UNSET) {
-        length += bytesLoaded;
+        length += nextLoadPosition;
       }
-      ExtractorInput extractorInput = new DefaultExtractorInput(dataSource, bytesLoaded, length);
+      ExtractorInput extractorInput =
+          new DefaultExtractorInput(dataSource, nextLoadPosition, length);
       BaseMediaChunkOutput output = getOutput();
       output.setSampleOffsetUs(0);
       TrackOutput trackOutput = output.track(0, trackType);
@@ -110,10 +107,10 @@ public void load() throws IOException, InterruptedException {
       // Load the sample data.
       int result = 0;
       while (result != C.RESULT_END_OF_INPUT) {
-        bytesLoaded += result;
+        nextLoadPosition += result;
         result = trackOutput.sampleData(extractorInput, Integer.MAX_VALUE, true);
       }
-      int sampleSize = bytesLoaded;
+      int sampleSize = (int) nextLoadPosition;
       trackOutput.sampleMetadata(startTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
     } finally {
       Util.closeQuietly(dataSource);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java b/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
index 51f5ad0a64..e7bb0e16bf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
@@ -22,6 +22,7 @@
 import android.view.accessibility.CaptioningManager;
 import android.view.accessibility.CaptioningManager.CaptionStyle;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -31,11 +32,19 @@
 public final class CaptionStyleCompat {
 
   /**
-   * The type of edge, which may be none.
+   * The type of edge, which may be none. One of {@link #EDGE_TYPE_NONE}, {@link
+   * #EDGE_TYPE_OUTLINE}, {@link #EDGE_TYPE_DROP_SHADOW}, {@link #EDGE_TYPE_RAISED} or {@link
+   * #EDGE_TYPE_DEPRESSED}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({EDGE_TYPE_NONE, EDGE_TYPE_OUTLINE, EDGE_TYPE_DROP_SHADOW, EDGE_TYPE_RAISED,
-      EDGE_TYPE_DEPRESSED})
+  @IntDef({
+    EDGE_TYPE_NONE,
+    EDGE_TYPE_OUTLINE,
+    EDGE_TYPE_DROP_SHADOW,
+    EDGE_TYPE_RAISED,
+    EDGE_TYPE_DEPRESSED
+  })
   public @interface EdgeType {}
   /**
    * Edge type value specifying no character edges.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 8bc0b8e136..a5c666c44a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -19,6 +19,7 @@
 import android.graphics.Color;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -33,8 +34,10 @@
   public static final float DIMEN_UNSET = Float.MIN_VALUE;
 
   /**
-   * The type of anchor, which may be unset.
+   * The type of anchor, which may be unset. One of {@link #TYPE_UNSET}, {@link #ANCHOR_TYPE_START},
+   * {@link #ANCHOR_TYPE_MIDDLE} or {@link #ANCHOR_TYPE_END}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, ANCHOR_TYPE_START, ANCHOR_TYPE_MIDDLE, ANCHOR_TYPE_END})
   public @interface AnchorType {}
@@ -62,8 +65,10 @@
   public static final int ANCHOR_TYPE_END = 2;
 
   /**
-   * The type of line, which may be unset.
+   * The type of line, which may be unset. One of {@link #TYPE_UNSET}, {@link #LINE_TYPE_FRACTION}
+   * or {@link #LINE_TYPE_NUMBER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, LINE_TYPE_FRACTION, LINE_TYPE_NUMBER})
   public @interface LineType {}
@@ -78,7 +83,12 @@
    */
   public static final int LINE_TYPE_NUMBER = 1;
 
-  /** The type of default text size for this cue, which may be unset. */
+  /**
+   * The type of default text size for this cue, which may be unset. One of {@link #TYPE_UNSET},
+   * {@link #TEXT_SIZE_TYPE_FRACTIONAL}, {@link #TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING} or {@link
+   * #TEXT_SIZE_TYPE_ABSOLUTE}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     TYPE_UNSET,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
index 997f750b61..38d6ff25cb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
@@ -67,9 +67,10 @@ protected final void releaseOutputBuffer(SubtitleOutputBuffer buffer) {
     super.releaseOutputBuffer(buffer);
   }
 
+  @SuppressWarnings("ByteBufferBackingArray")
   @Override
-  protected final SubtitleDecoderException decode(SubtitleInputBuffer inputBuffer,
-      SubtitleOutputBuffer outputBuffer, boolean reset) {
+  protected final SubtitleDecoderException decode(
+      SubtitleInputBuffer inputBuffer, SubtitleOutputBuffer outputBuffer, boolean reset) {
     try {
       ByteBuffer inputData = inputBuffer.data;
       Subtitle subtitle = decode(inputData.array(), inputData.limit(), reset);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderException.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderException.java
index b0e9c2d3ce..b235706370 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderException.java
@@ -27,6 +27,11 @@ public SubtitleDecoderException(String message) {
     super(message);
   }
 
+  /** @param cause The cause of this exception. */
+  public SubtitleDecoderException(Exception cause) {
+    super(cause);
+  }
+
   /**
    * @param message The detail message for this exception.
    * @param cause The cause of this exception.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index 139e403844..a64a1835d8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -107,7 +107,7 @@ public SubtitleDecoder createDecoder(Format format) {
             case MimeTypes.APPLICATION_MP4CEA608:
               return new Cea608Decoder(format.sampleMimeType, format.accessibilityChannel);
             case MimeTypes.APPLICATION_CEA708:
-              return new Cea708Decoder(format.accessibilityChannel);
+              return new Cea708Decoder(format.accessibilityChannel, format.initializationData);
             case MimeTypes.APPLICATION_DVBSUBS:
               return new DvbDecoder(format.initializationData);
             case MimeTypes.APPLICATION_PGS:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index c6d7f6f163..16f82a7293 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -20,6 +20,7 @@
 import android.os.Looper;
 import android.os.Message;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -27,6 +28,8 @@
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -47,9 +50,13 @@
   @Deprecated
   public interface Output extends TextOutput {}
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REPLACEMENT_STATE_NONE, REPLACEMENT_STATE_SIGNAL_END_OF_STREAM,
-      REPLACEMENT_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REPLACEMENT_STATE_NONE,
+    REPLACEMENT_STATE_SIGNAL_END_OF_STREAM,
+    REPLACEMENT_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReplacementState {}
   /**
    * The decoder does not need to be replaced.
@@ -70,7 +77,7 @@
 
   private static final int MSG_UPDATE_OUTPUT = 0;
 
-  private final Handler outputHandler;
+  private final @Nullable Handler outputHandler;
   private final TextOutput output;
   private final SubtitleDecoderFactory decoderFactory;
   private final FormatHolder formatHolder;
@@ -87,30 +94,31 @@
 
   /**
    * @param output The output.
-   * @param outputLooper The looper associated with the thread on which the output should be
-   *     called. If the output makes use of standard Android UI components, then this should
-   *     normally be the looper associated with the application's main thread, which can be obtained
-   *     using {@link android.app.Activity#getMainLooper()}. Null may be passed if the output
-   *     should be called directly on the player's internal rendering thread.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
+   *     If the output makes use of standard Android UI components, then this should normally be the
+   *     looper associated with the application's main thread, which can be obtained using {@link
+   *     android.app.Activity#getMainLooper()}. Null may be passed if the output should be called
+   *     directly on the player's internal rendering thread.
    */
-  public TextRenderer(TextOutput output, Looper outputLooper) {
+  public TextRenderer(TextOutput output, @Nullable Looper outputLooper) {
     this(output, outputLooper, SubtitleDecoderFactory.DEFAULT);
   }
 
   /**
    * @param output The output.
-   * @param outputLooper The looper associated with the thread on which the output should be
-   *     called. If the output makes use of standard Android UI components, then this should
-   *     normally be the looper associated with the application's main thread, which can be obtained
-   *     using {@link android.app.Activity#getMainLooper()}. Null may be passed if the output
-   *     should be called directly on the player's internal rendering thread.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
+   *     If the output makes use of standard Android UI components, then this should normally be the
+   *     looper associated with the application's main thread, which can be obtained using {@link
+   *     android.app.Activity#getMainLooper()}. Null may be passed if the output should be called
+   *     directly on the player's internal rendering thread.
    * @param decoderFactory A factory from which to obtain {@link SubtitleDecoder} instances.
    */
-  public TextRenderer(TextOutput output, Looper outputLooper,
-      SubtitleDecoderFactory decoderFactory) {
+  public TextRenderer(
+      TextOutput output, @Nullable Looper outputLooper, SubtitleDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_TEXT);
     this.output = Assertions.checkNotNull(output);
-    this.outputHandler = outputLooper == null ? null : new Handler(outputLooper, this);
+    this.outputHandler =
+        outputLooper == null ? null : Util.createHandler(outputLooper, /* callback= */ this);
     this.decoderFactory = decoderFactory;
     formatHolder = new FormatHolder();
   }
@@ -305,7 +313,7 @@ private void updateOutput(List<Cue> cues) {
   }
 
   private void clearOutput() {
-    updateOutput(Collections.<Cue>emptyList());
+    updateOutput(Collections.emptyList());
   }
 
   @SuppressWarnings("unchecked")
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 57614ae880..3c39fdc6c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -21,10 +21,10 @@
 import android.text.SpannableString;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
-import android.text.style.CharacterStyle;
 import android.text.style.ForegroundColorSpan;
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -55,15 +56,13 @@
 
   private static final int[] ROW_INDICES = new int[] {11, 1, 3, 12, 14, 5, 7, 9};
   private static final int[] COLUMN_INDICES = new int[] {0, 4, 8, 12, 16, 20, 24, 28};
-  private static final int[] COLORS = new int[] {
-      Color.WHITE,
-      Color.GREEN,
-      Color.BLUE,
-      Color.CYAN,
-      Color.RED,
-      Color.YELLOW,
-      Color.MAGENTA,
-  };
+
+  private static final int[] STYLE_COLORS =
+      new int[] {
+        Color.WHITE, Color.GREEN, Color.BLUE, Color.CYAN, Color.RED, Color.YELLOW, Color.MAGENTA
+      };
+  private static final int STYLE_ITALICS = 0x07;
+  private static final int STYLE_UNCHANGED = 0x08;
 
   // The default number of rows to display in roll-up captions mode.
   private static final int DEFAULT_CAPTIONS_ROW_COUNT = 4;
@@ -252,6 +251,7 @@ protected Subtitle createSubtitle() {
     return new CeaSubtitle(cues);
   }
 
+  @SuppressWarnings("ByteBufferBackingArray")
   @Override
   protected void decode(SubtitleInputBuffer inputBuffer) {
     ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
@@ -377,18 +377,10 @@ private void handleMidrowCtrl(byte cc2) {
     // A midrow control code advances the cursor.
     currentCueBuilder.append(' ');
 
-    // cc2 - 0|0|1|0|ATRBT|U
-    // ATRBT is the 3-byte encoded attribute, and U is the underline toggle
-    boolean isUnderlined = (cc2 & 0x01) == 0x01;
-    currentCueBuilder.setUnderline(isUnderlined);
-
-    int attribute = (cc2 >> 1) & 0x0F;
-    if (attribute == 0x07) {
-      currentCueBuilder.setMidrowStyle(new StyleSpan(Typeface.ITALIC), 2);
-      currentCueBuilder.setMidrowStyle(new ForegroundColorSpan(Color.WHITE), 1);
-    } else {
-      currentCueBuilder.setMidrowStyle(new ForegroundColorSpan(COLORS[attribute]), 1);
-    }
+    // cc2 - 0|0|1|0|STYLE|U
+    boolean underline = (cc2 & 0x01) == 0x01;
+    int style = (cc2 >> 1) & 0x07;
+    currentCueBuilder.setStyle(style, underline);
   }
 
   private void handlePreambleAddressCode(byte cc1, byte cc2) {
@@ -414,22 +406,18 @@ private void handlePreambleAddressCode(byte cc1, byte cc2) {
       currentCueBuilder.setRow(row);
     }
 
-    if ((cc2 & 0x01) == 0x01) {
-      currentCueBuilder.setPreambleStyle(new UnderlineSpan());
-    }
-
     // cc2 - 0|1|N|0|STYLE|U
     // cc2 - 0|1|N|1|CURSR|U
-    int attribute = cc2 >> 1 & 0x0F;
-    if (attribute <= 0x07) {
-      if (attribute == 0x07) {
-        currentCueBuilder.setPreambleStyle(new StyleSpan(Typeface.ITALIC));
-        currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(Color.WHITE));
-      } else {
-        currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(COLORS[attribute]));
-      }
-    } else {
-      currentCueBuilder.setIndent(COLUMN_INDICES[attribute & 0x07]);
+    boolean isCursor = (cc2 & 0x10) == 0x10;
+    boolean underline = (cc2 & 0x01) == 0x01;
+    int cursorOrStyle = (cc2 >> 1) & 0x07;
+
+    // We need to call setStyle even for the isCursor case, to update the underline bit.
+    // STYLE_UNCHANGED is used for this case.
+    currentCueBuilder.setStyle(isCursor ? STYLE_UNCHANGED : cursorOrStyle, underline);
+
+    if (isCursor) {
+      currentCueBuilder.setIndent(COLUMN_INDICES[cursorOrStyle]);
     }
   }
 
@@ -464,7 +452,7 @@ private void handleMiscCode(byte cc2) {
 
     switch (cc2) {
       case CTRL_ERASE_DISPLAYED_MEMORY:
-        cues = null;
+        cues = Collections.emptyList();
         if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
           resetCueBuilders();
         }
@@ -519,7 +507,7 @@ private void setCaptionMode(int captionMode) {
     if (oldCaptionMode == CC_MODE_PAINT_ON || captionMode == CC_MODE_ROLL_UP
         || captionMode == CC_MODE_UNKNOWN) {
       // When switching from paint-on or to roll-up or unknown, we also need to clear the caption.
-      cues = null;
+      cues = Collections.emptyList();
     }
   }
 
@@ -585,44 +573,37 @@ private static boolean isRepeatable(byte cc1) {
 
   private static class CueBuilder {
 
-    private static final int POSITION_UNSET = -1;
-
     // 608 captions define a 15 row by 32 column screen grid. These constants convert from 608
     // positions to normalized screen position.
     private static final int SCREEN_CHARWIDTH = 32;
     private static final int BASE_ROW = 15;
 
-    private final List<CharacterStyle> preambleStyles;
-    private final List<CueStyle> midrowStyles;
+    private final List<CueStyle> cueStyles;
     private final List<SpannableString> rolledUpCaptions;
-    private final SpannableStringBuilder captionStringBuilder;
+    private final StringBuilder captionStringBuilder;
 
     private int row;
     private int indent;
     private int tabOffset;
     private int captionMode;
     private int captionRowCount;
-    private int underlineStartPosition;
 
     public CueBuilder(int captionMode, int captionRowCount) {
-      preambleStyles = new ArrayList<>();
-      midrowStyles = new ArrayList<>();
+      cueStyles = new ArrayList<>();
       rolledUpCaptions = new ArrayList<>();
-      captionStringBuilder = new SpannableStringBuilder();
+      captionStringBuilder = new StringBuilder();
       reset(captionMode);
       setCaptionRowCount(captionRowCount);
     }
 
     public void reset(int captionMode) {
       this.captionMode = captionMode;
-      preambleStyles.clear();
-      midrowStyles.clear();
+      cueStyles.clear();
       rolledUpCaptions.clear();
-      captionStringBuilder.clear();
+      captionStringBuilder.setLength(0);
       row = BASE_ROW;
       indent = 0;
       tabOffset = 0;
-      underlineStartPosition = POSITION_UNSET;
     }
 
     public void setCaptionRowCount(int captionRowCount) {
@@ -630,7 +611,8 @@ public void setCaptionRowCount(int captionRowCount) {
     }
 
     public boolean isEmpty() {
-      return preambleStyles.isEmpty() && midrowStyles.isEmpty() && rolledUpCaptions.isEmpty()
+      return cueStyles.isEmpty()
+          && rolledUpCaptions.isEmpty()
           && captionStringBuilder.length() == 0;
     }
 
@@ -638,6 +620,16 @@ public void backspace() {
       int length = captionStringBuilder.length();
       if (length > 0) {
         captionStringBuilder.delete(length - 1, length);
+        // Decrement style start positions if necessary.
+        for (int i = cueStyles.size() - 1; i >= 0; i--) {
+          CueStyle style = cueStyles.get(i);
+          if (style.start == length) {
+            style.start--;
+          } else {
+            // All earlier cues must have style.start < length.
+            break;
+          }
+        }
       }
     }
 
@@ -651,11 +643,8 @@ public void setRow(int row) {
 
     public void rollUp() {
       rolledUpCaptions.add(buildSpannableString());
-      captionStringBuilder.clear();
-      preambleStyles.clear();
-      midrowStyles.clear();
-      underlineStartPosition = POSITION_UNSET;
-
+      captionStringBuilder.setLength(0);
+      cueStyles.clear();
       int numRows = Math.min(captionRowCount, row);
       while (rolledUpCaptions.size() >= numRows) {
         rolledUpCaptions.remove(0);
@@ -670,23 +659,8 @@ public void setTab(int tabs) {
       tabOffset = tabs;
     }
 
-    public void setPreambleStyle(CharacterStyle style) {
-      preambleStyles.add(style);
-    }
-
-    public void setMidrowStyle(CharacterStyle style, int nextStyleIncrement) {
-      midrowStyles.add(new CueStyle(style, captionStringBuilder.length(), nextStyleIncrement));
-    }
-
-    public void setUnderline(boolean enabled) {
-      if (enabled) {
-        underlineStartPosition = captionStringBuilder.length();
-      } else if (underlineStartPosition != POSITION_UNSET) {
-        // underline spans won't overlap, so it's safe to modify the builder directly with them
-        captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
-            captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-        underlineStartPosition = POSITION_UNSET;
-      }
+    public void setStyle(int style, boolean underline) {
+      cueStyles.add(new CueStyle(style, underline, captionStringBuilder.length()));
     }
 
     public void append(char text) {
@@ -694,31 +668,69 @@ public void append(char text) {
     }
 
     public SpannableString buildSpannableString() {
-      int length = captionStringBuilder.length();
+      SpannableStringBuilder builder = new SpannableStringBuilder(captionStringBuilder);
+      int length = builder.length();
+
+      int underlineStartPosition = C.INDEX_UNSET;
+      int italicStartPosition = C.INDEX_UNSET;
+      int colorStartPosition = 0;
+      int color = Color.WHITE;
+
+      boolean nextItalic = false;
+      int nextColor = Color.WHITE;
+
+      for (int i = 0; i < cueStyles.size(); i++) {
+        CueStyle cueStyle = cueStyles.get(i);
+        boolean underline = cueStyle.underline;
+        int style = cueStyle.style;
+        if (style != STYLE_UNCHANGED) {
+          // If the style is a color then italic is cleared.
+          nextItalic = style == STYLE_ITALICS;
+          // If the style is italic then the color is left unchanged.
+          nextColor = style == STYLE_ITALICS ? nextColor : STYLE_COLORS[style];
+        }
 
-      // preamble styles apply to the entire cue
-      for (int i = 0; i < preambleStyles.size(); i++) {
-        captionStringBuilder.setSpan(preambleStyles.get(i), 0, length,
-            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-      }
+        int position = cueStyle.start;
+        int nextPosition = (i + 1) < cueStyles.size() ? cueStyles.get(i + 1).start : length;
+        if (position == nextPosition) {
+          // There are more cueStyles to process at the current position.
+          continue;
+        }
 
-      // midrow styles only apply to part of the cue, and after preamble styles
-      for (int i = 0; i < midrowStyles.size(); i++) {
-        CueStyle cueStyle = midrowStyles.get(i);
-        int end = (i < midrowStyles.size() - cueStyle.nextStyleIncrement)
-            ? midrowStyles.get(i + cueStyle.nextStyleIncrement).start
-            : length;
-        captionStringBuilder.setSpan(cueStyle.style, cueStyle.start, end,
-            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        // Process changes to underline up to the current position.
+        if (underlineStartPosition != C.INDEX_UNSET && !underline) {
+          setUnderlineSpan(builder, underlineStartPosition, position);
+          underlineStartPosition = C.INDEX_UNSET;
+        } else if (underlineStartPosition == C.INDEX_UNSET && underline) {
+          underlineStartPosition = position;
+        }
+        // Process changes to italic up to the current position.
+        if (italicStartPosition != C.INDEX_UNSET && !nextItalic) {
+          setItalicSpan(builder, italicStartPosition, position);
+          italicStartPosition = C.INDEX_UNSET;
+        } else if (italicStartPosition == C.INDEX_UNSET && nextItalic) {
+          italicStartPosition = position;
+        }
+        // Process changes to color up to the current position.
+        if (nextColor != color) {
+          setColorSpan(builder, colorStartPosition, position, color);
+          color = nextColor;
+          colorStartPosition = position;
+        }
       }
 
-      // special case for midrow underlines that went to the end of the cue
-      if (underlineStartPosition != POSITION_UNSET) {
-        captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition, length,
-            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+      // Add any final spans.
+      if (underlineStartPosition != C.INDEX_UNSET && underlineStartPosition != length) {
+        setUnderlineSpan(builder, underlineStartPosition, length);
+      }
+      if (italicStartPosition != C.INDEX_UNSET && italicStartPosition != length) {
+        setItalicSpan(builder, italicStartPosition, length);
+      }
+      if (colorStartPosition != length) {
+        setColorSpan(builder, colorStartPosition, length, color);
       }
 
-      return new SpannableString(captionStringBuilder);
+      return new SpannableString(builder);
     }
 
     public Cue build() {
@@ -788,16 +800,34 @@ public String toString() {
       return captionStringBuilder.toString();
     }
 
+    private static void setUnderlineSpan(SpannableStringBuilder builder, int start, int end) {
+      builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+    }
+
+    private static void setItalicSpan(SpannableStringBuilder builder, int start, int end) {
+      builder.setSpan(new StyleSpan(Typeface.ITALIC), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+    }
+
+    private static void setColorSpan(
+        SpannableStringBuilder builder, int start, int end, int color) {
+      if (color == Color.WHITE) {
+        // White is treated as the default color (i.e. no span is attached).
+        return;
+      }
+      builder.setSpan(new ForegroundColorSpan(color), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+    }
+
     private static class CueStyle {
 
-      public final CharacterStyle style;
-      public final int start;
-      public final int nextStyleIncrement;
+      public final int style;
+      public final boolean underline;
+
+      public int start;
 
-      public CueStyle(CharacterStyle style, int start, int nextStyleIncrement) {
+      public CueStyle(int style, boolean underline, int start) {
         this.style = style;
+        this.underline = underline;
         this.start = start;
-        this.nextStyleIncrement = nextStyleIncrement;
       }
 
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
index 731c9032d6..b3be88b851 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -25,7 +25,6 @@
 import android.text.style.ForegroundColorSpan;
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Cue;
@@ -34,6 +33,7 @@
 import com.google.android.exoplayer2.text.SubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
@@ -152,10 +152,10 @@
   private DtvCcPacket currentDtvCcPacket;
   private int currentWindow;
 
-  public Cea708Decoder(int accessibilityChannel) {
+  public Cea708Decoder(int accessibilityChannel, List<byte[]> initializationData) {
     ccData = new ParsableByteArray();
     serviceBlockPacket = new ParsableBitArray();
-    selectedServiceNumber = (accessibilityChannel == Format.NO_VALUE) ? 1 : accessibilityChannel;
+    selectedServiceNumber = accessibilityChannel == Format.NO_VALUE ? 1 : accessibilityChannel;
 
     cueBuilders = new CueBuilder[NUM_WINDOWS];
     for (int i = 0; i < NUM_WINDOWS; i++) {
@@ -272,7 +272,10 @@ private void processCurrentPacket() {
     if (serviceNumber == 7) {
       // extended service numbers
       serviceBlockPacket.skipBits(2);
-      serviceNumber += serviceBlockPacket.readBits(6);
+      serviceNumber = serviceBlockPacket.readBits(6);
+      if (serviceNumber < 7) {
+        Log.w(TAG, "Invalid extended service number: " + serviceNumber);
+      }
     }
 
     // Ignore packets in which blockSize is 0
@@ -743,7 +746,7 @@ private void handleDefineWindow(int window) {
       }
     }
     Collections.sort(displayCues);
-    return Collections.<Cue>unmodifiableList(displayCues);
+    return Collections.unmodifiableList(displayCues);
   }
 
   private void resetCueBuilders() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708InitializationData.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708InitializationData.java
new file mode 100644
index 0000000000..10bed14adc
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708InitializationData.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import java.util.Collections;
+import java.util.List;
+
+/** Initialization data for CEA-708 decoders. */
+public final class Cea708InitializationData {
+
+  /**
+   * Whether the closed caption service is formatted for displays with 16:9 aspect ratio. If false,
+   * the closed caption service is formatted for 4:3 displays.
+   */
+  public final boolean isWideAspectRatio;
+
+  private Cea708InitializationData(List<byte[]> initializationData) {
+    isWideAspectRatio = initializationData.get(0)[0] != 0;
+  }
+
+  /**
+   * Returns an object representation of CEA-708 initialization data
+   *
+   * @param initializationData Binary CEA-708 initialization data.
+   * @return The object representation.
+   */
+  public static Cea708InitializationData fromData(List<byte[]> initializationData) {
+    return new Cea708InitializationData(initializationData);
+  }
+
+  /**
+   * Builds binary CEA-708 initialization data.
+   *
+   * @param isWideAspectRatio Whether the closed caption service is formatted for displays with 16:9
+   *     aspect ratio.
+   * @return Binary CEA-708 initializaton data.
+   */
+  public static List<byte[]> buildData(boolean isWideAspectRatio) {
+    return Collections.singletonList(new byte[] {(byte) (isWideAspectRatio ? 1 : 0)});
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
index 7da2054a08..738f251e27 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
@@ -54,7 +54,7 @@ public long getEventTime(int index) {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
+    return timeUs >= 0 ? cues : Collections.emptyList();
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
index 67271ee218..75fe8fed25 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
@@ -15,9 +15,9 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -26,13 +26,13 @@
 
   private static final String TAG = "CeaUtil";
 
+  public static final int USER_DATA_IDENTIFIER_GA94 = Util.getIntegerCodeForString("GA94");
+  public static final int USER_DATA_TYPE_CODE_MPEG_CC = 0x3;
+
   private static final int PAYLOAD_TYPE_CC = 4;
   private static final int COUNTRY_CODE = 0xB5;
   private static final int PROVIDER_CODE_ATSC = 0x31;
   private static final int PROVIDER_CODE_DIRECTV = 0x2F;
-  private static final int USER_ID_GA94 = Util.getIntegerCodeForString("GA94");
-  private static final int USER_ID_DTG1 = Util.getIntegerCodeForString("DTG1");
-  private static final int USER_DATA_TYPE_CODE = 0x3;
 
   /**
    * Consumes the unescaped content of an SEI NAL unit, writing the content of any CEA-608 messages
@@ -67,32 +67,52 @@ public static void consume(long presentationTimeUs, ParsableByteArray seiBuffer,
         boolean messageIsSupportedCeaCaption =
             countryCode == COUNTRY_CODE
                 && (providerCode == PROVIDER_CODE_ATSC || providerCode == PROVIDER_CODE_DIRECTV)
-                && userDataTypeCode == USER_DATA_TYPE_CODE;
+                && userDataTypeCode == USER_DATA_TYPE_CODE_MPEG_CC;
         if (providerCode == PROVIDER_CODE_ATSC) {
-          messageIsSupportedCeaCaption &=
-              userIdentifier == USER_ID_GA94 || userIdentifier == USER_ID_DTG1;
+          messageIsSupportedCeaCaption &= userIdentifier == USER_DATA_IDENTIFIER_GA94;
         }
         if (messageIsSupportedCeaCaption) {
-          // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
-          int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
-          // Ignore em_data (1)
-          seiBuffer.skipBytes(1);
-          // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
-          // + cc_data_1 (8) + cc_data_2 (8).
-          int sampleLength = ccCount * 3;
-          int sampleStartPosition = seiBuffer.getPosition();
-          for (TrackOutput output : outputs) {
-            seiBuffer.setPosition(sampleStartPosition);
-            output.sampleData(seiBuffer, sampleLength);
-            output.sampleMetadata(
-                presentationTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
-          }
+          consumeCcData(presentationTimeUs, seiBuffer, outputs);
         }
       }
       seiBuffer.setPosition(nextPayloadPosition);
     }
   }
 
+  /**
+   * Consumes caption data (cc_data), writing the content as samples to all of the provided outputs.
+   *
+   * @param presentationTimeUs The presentation time in microseconds for any samples.
+   * @param ccDataBuffer The buffer containing the caption data.
+   * @param outputs The outputs to which any samples should be written.
+   */
+  public static void consumeCcData(
+      long presentationTimeUs, ParsableByteArray ccDataBuffer, TrackOutput[] outputs) {
+    // First byte contains: reserved (1), process_cc_data_flag (1), zero_bit (1), cc_count (5).
+    int firstByte = ccDataBuffer.readUnsignedByte();
+    boolean processCcDataFlag = (firstByte & 0x40) != 0;
+    if (!processCcDataFlag) {
+      // No need to process.
+      return;
+    }
+    int ccCount = firstByte & 0x1F;
+    ccDataBuffer.skipBytes(1); // Ignore em_data
+    // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
+    // + cc_data_1 (8) + cc_data_2 (8).
+    int sampleLength = ccCount * 3;
+    int sampleStartPosition = ccDataBuffer.getPosition();
+    for (TrackOutput output : outputs) {
+      ccDataBuffer.setPosition(sampleStartPosition);
+      output.sampleData(ccDataBuffer, sampleLength);
+      output.sampleMetadata(
+          presentationTimeUs,
+          C.BUFFER_FLAG_KEY_FRAME,
+          sampleLength,
+          /* offset= */ 0,
+          /* encryptionData= */ null);
+    }
+  }
+
   /**
    * Reads a value from the provided buffer consisting of zero or more 0xFF bytes followed by a
    * terminating byte not equal to 0xFF. The returned value is ((0xFF * N) + T), where N is the
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
index c0caf1e57a..eb956f06db 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
@@ -22,9 +22,9 @@
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
 import android.graphics.Region;
-import android.util.Log;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
index 1e45595144..091bda49f3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
@@ -25,7 +25,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
 
 /** A {@link SimpleSubtitleDecoder} for PGS subtitles. */
@@ -39,25 +38,22 @@
   private static final byte INFLATE_HEADER = 0x78;
 
   private final ParsableByteArray buffer;
+  private final ParsableByteArray inflatedBuffer;
   private final CueBuilder cueBuilder;
 
   private Inflater inflater;
-  private byte[] inflatedData;
-  private int inflatedDataSize;
 
   public PgsDecoder() {
     super("PgsDecoder");
     buffer = new ParsableByteArray();
+    inflatedBuffer = new ParsableByteArray();
     cueBuilder = new CueBuilder();
   }
 
   @Override
   protected Subtitle decode(byte[] data, int size, boolean reset) throws SubtitleDecoderException {
-    if (maybeInflateData(data, size)) {
-      buffer.reset(inflatedData, inflatedDataSize);
-    } else {
-      buffer.reset(data, size);
-    }
+    buffer.reset(data, size);
+    maybeInflateData(buffer);
     cueBuilder.reset();
     ArrayList<Cue> cues = new ArrayList<>();
     while (buffer.bytesLeft() >= 3) {
@@ -69,31 +65,14 @@ protected Subtitle decode(byte[] data, int size, boolean reset) throws SubtitleD
     return new PgsSubtitle(Collections.unmodifiableList(cues));
   }
 
-  private boolean maybeInflateData(byte[] data, int size) {
-    if (size == 0 || data[0] != INFLATE_HEADER) {
-      return false;
-    }
-    if (inflater == null) {
-      inflater = new Inflater();
-      inflatedData = new byte[size];
-    }
-    inflatedDataSize = 0;
-    inflater.setInput(data, 0, size);
-    try {
-      while (!inflater.finished() && !inflater.needsDictionary() && !inflater.needsInput()) {
-        if (inflatedDataSize == inflatedData.length) {
-          inflatedData = Arrays.copyOf(inflatedData, inflatedData.length * 2);
-        }
-        inflatedDataSize +=
-            inflater.inflate(
-                inflatedData, inflatedDataSize, inflatedData.length - inflatedDataSize);
+  private void maybeInflateData(ParsableByteArray buffer) {
+    if (buffer.bytesLeft() > 0 && buffer.peekUnsignedByte() == INFLATE_HEADER) {
+      if (inflater == null) {
+        inflater = new Inflater();
       }
-      return inflater.finished();
-    } catch (DataFormatException e) {
-      // Assume data is not compressed.
-      return false;
-    } finally {
-      inflater.reset();
+      if (Util.inflate(buffer, inflatedBuffer, inflater)) {
+        buffer.reset(inflatedBuffer.data, inflatedBuffer.limit());
+      } // else assume data is not compressed.
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
index e528a57762..c25b26128c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
@@ -16,11 +16,11 @@
 package com.google.android.exoplayer2.text.ssa;
 
 import android.text.TextUtils;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.LongArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
index 6cce902e87..3b039061b0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.text.subrip;
 
+import android.support.annotation.Nullable;
 import android.text.Html;
 import android.text.Spanned;
 import android.text.TextUtils;
-import android.util.Log;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.LongArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
@@ -32,17 +33,38 @@
  */
 public final class SubripDecoder extends SimpleSubtitleDecoder {
 
+  // Fractional positions for use when alignment tags are present.
+  /* package */ static final float START_FRACTION = 0.08f;
+  /* package */ static final float END_FRACTION = 1 - START_FRACTION;
+  /* package */ static final float MID_FRACTION = 0.5f;
+
   private static final String TAG = "SubripDecoder";
 
   private static final String SUBRIP_TIMECODE = "(?:(\\d+):)?(\\d+):(\\d+),(\\d+)";
   private static final Pattern SUBRIP_TIMING_LINE =
       Pattern.compile("\\s*(" + SUBRIP_TIMECODE + ")\\s*-->\\s*(" + SUBRIP_TIMECODE + ")?\\s*");
 
+  private static final Pattern SUBRIP_TAG_PATTERN = Pattern.compile("\\{\\\\.*?\\}");
+  private static final String SUBRIP_ALIGNMENT_TAG = "\\{\\\\an[1-9]\\}";
+
+  // Alignment tags for SSA V4+.
+  private static final String ALIGN_BOTTOM_LEFT = "{\\an1}";
+  private static final String ALIGN_BOTTOM_MID = "{\\an2}";
+  private static final String ALIGN_BOTTOM_RIGHT = "{\\an3}";
+  private static final String ALIGN_MID_LEFT = "{\\an4}";
+  private static final String ALIGN_MID_MID = "{\\an5}";
+  private static final String ALIGN_MID_RIGHT = "{\\an6}";
+  private static final String ALIGN_TOP_LEFT = "{\\an7}";
+  private static final String ALIGN_TOP_MID = "{\\an8}";
+  private static final String ALIGN_TOP_RIGHT = "{\\an9}";
+
   private final StringBuilder textBuilder;
+  private final ArrayList<String> tags;
 
   public SubripDecoder() {
     super("SubripDecoder");
     textBuilder = new StringBuilder();
+    tags = new ArrayList<>();
   }
 
   @Override
@@ -86,17 +108,29 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
         continue;
       }
 
-      // Read and parse the text.
+      // Read and parse the text and tags.
       textBuilder.setLength(0);
+      tags.clear();
       while (!TextUtils.isEmpty(currentLine = subripData.readLine())) {
         if (textBuilder.length() > 0) {
           textBuilder.append("<br>");
         }
-        textBuilder.append(currentLine.trim());
+        textBuilder.append(processLine(currentLine, tags));
       }
 
       Spanned text = Html.fromHtml(textBuilder.toString());
-      cues.add(new Cue(text));
+
+      String alignmentTag = null;
+      for (int i = 0; i < tags.size(); i++) {
+        String tag = tags.get(i);
+        if (tag.matches(SUBRIP_ALIGNMENT_TAG)) {
+          alignmentTag = tag;
+          // Subsequent alignment tags should be ignored.
+          break;
+        }
+      }
+      cues.add(buildCue(text, alignmentTag));
+
       if (haveEndTimecode) {
         cues.add(null);
       }
@@ -108,6 +142,96 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
     return new SubripSubtitle(cuesArray, cueTimesUsArray);
   }
 
+  /**
+   * Trims and removes tags from the given line. The removed tags are added to {@code tags}.
+   *
+   * @param line The line to process.
+   * @param tags A list to which removed tags will be added.
+   * @return The processed line.
+   */
+  private String processLine(String line, ArrayList<String> tags) {
+    line = line.trim();
+
+    int removedCharacterCount = 0;
+    StringBuilder processedLine = new StringBuilder(line);
+    Matcher matcher = SUBRIP_TAG_PATTERN.matcher(line);
+    while (matcher.find()) {
+      String tag = matcher.group();
+      tags.add(tag);
+      int start = matcher.start() - removedCharacterCount;
+      int tagLength = tag.length();
+      processedLine.replace(start, /* end= */ start + tagLength, /* str= */ "");
+      removedCharacterCount += tagLength;
+    }
+
+    return processedLine.toString();
+  }
+
+  /**
+   * Build a {@link Cue} based on the given text and alignment tag.
+   *
+   * @param text The text.
+   * @param alignmentTag The alignment tag, or {@code null} if no alignment tag is available.
+   * @return Built cue
+   */
+  private Cue buildCue(Spanned text, @Nullable String alignmentTag) {
+    if (alignmentTag == null) {
+      return new Cue(text);
+    }
+
+    // Horizontal alignment.
+    @Cue.AnchorType int positionAnchor;
+    switch (alignmentTag) {
+      case ALIGN_BOTTOM_LEFT:
+      case ALIGN_MID_LEFT:
+      case ALIGN_TOP_LEFT:
+        positionAnchor = Cue.ANCHOR_TYPE_START;
+        break;
+      case ALIGN_BOTTOM_RIGHT:
+      case ALIGN_MID_RIGHT:
+      case ALIGN_TOP_RIGHT:
+        positionAnchor = Cue.ANCHOR_TYPE_END;
+        break;
+      case ALIGN_BOTTOM_MID:
+      case ALIGN_MID_MID:
+      case ALIGN_TOP_MID:
+      default:
+        positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+        break;
+    }
+
+    // Vertical alignment.
+    @Cue.AnchorType int lineAnchor;
+    switch (alignmentTag) {
+      case ALIGN_BOTTOM_LEFT:
+      case ALIGN_BOTTOM_MID:
+      case ALIGN_BOTTOM_RIGHT:
+        lineAnchor = Cue.ANCHOR_TYPE_END;
+        break;
+      case ALIGN_TOP_LEFT:
+      case ALIGN_TOP_MID:
+      case ALIGN_TOP_RIGHT:
+        lineAnchor = Cue.ANCHOR_TYPE_START;
+        break;
+      case ALIGN_MID_LEFT:
+      case ALIGN_MID_MID:
+      case ALIGN_MID_RIGHT:
+      default:
+        lineAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+        break;
+    }
+
+    return new Cue(
+        text,
+        /* textAlignment= */ null,
+        getFractionalPositionForAnchorType(lineAnchor),
+        Cue.LINE_TYPE_FRACTION,
+        lineAnchor,
+        getFractionalPositionForAnchorType(positionAnchor),
+        positionAnchor,
+        Cue.DIMEN_UNSET);
+  }
+
   private static long parseTimecode(Matcher matcher, int groupOffset) {
     long timestampMs = Long.parseLong(matcher.group(groupOffset + 1)) * 60 * 60 * 1000;
     timestampMs += Long.parseLong(matcher.group(groupOffset + 2)) * 60 * 1000;
@@ -116,4 +240,15 @@ private static long parseTimecode(Matcher matcher, int groupOffset) {
     return timestampMs * 1000;
   }
 
+  /* package */ static float getFractionalPositionForAnchorType(@Cue.AnchorType int anchorType) {
+    switch (anchorType) {
+      case Cue.ANCHOR_TYPE_START:
+        return SubripDecoder.START_FRACTION;
+      case Cue.ANCHOR_TYPE_MIDDLE:
+        return SubripDecoder.MID_FRACTION;
+      case Cue.ANCHOR_TYPE_END:
+      default:
+        return SubripDecoder.END_FRACTION;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
index 61e0085065..b39f467968 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
@@ -16,12 +16,12 @@
 package com.google.android.exoplayer2.text.ttml;
 
 import android.text.Layout;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.util.ColorParser;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.util.XmlPullParserUtil;
 import java.io.ByteArrayInputStream;
@@ -68,6 +68,7 @@
   private static final String ATTR_END = "end";
   private static final String ATTR_STYLE = "style";
   private static final String ATTR_REGION = "region";
+  private static final String ATTR_IMAGE = "backgroundImage";
 
   private static final Pattern CLOCK_TIME =
       Pattern.compile("^([0-9][0-9]+):([0-9][0-9]):([0-9][0-9])"
@@ -77,6 +78,8 @@
   private static final Pattern FONT_SIZE = Pattern.compile("^(([0-9]*.)?[0-9]+)(px|em|%)$");
   private static final Pattern PERCENTAGE_COORDINATES =
       Pattern.compile("^(\\d+\\.?\\d*?)% (\\d+\\.?\\d*?)%$");
+  private static final Pattern PIXEL_COORDINATES =
+      Pattern.compile("^(\\d+\\.?\\d*?)px (\\d+\\.?\\d*?)px$");
   private static final Pattern CELL_RESOLUTION = Pattern.compile("^(\\d+) (\\d+)$");
 
   private static final int DEFAULT_FRAME_RATE = 30;
@@ -105,6 +108,7 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
       Map<String, TtmlStyle> globalStyles = new HashMap<>();
       Map<String, TtmlRegion> regionMap = new HashMap<>();
+      Map<String, String> imageMap = new HashMap<>();
       regionMap.put(TtmlNode.ANONYMOUS_REGION_ID, new TtmlRegion(null));
       ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes, 0, length);
       xmlParser.setInput(inputStream, null);
@@ -114,6 +118,7 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
       int eventType = xmlParser.getEventType();
       FrameAndTickRate frameAndTickRate = DEFAULT_FRAME_AND_TICK_RATE;
       CellResolution cellResolution = DEFAULT_CELL_RESOLUTION;
+      TtsExtent ttsExtent = null;
       while (eventType != XmlPullParser.END_DOCUMENT) {
         TtmlNode parent = nodeStack.peek();
         if (unsupportedNodeDepth == 0) {
@@ -122,12 +127,13 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
             if (TtmlNode.TAG_TT.equals(name)) {
               frameAndTickRate = parseFrameAndTickRates(xmlParser);
               cellResolution = parseCellResolution(xmlParser, DEFAULT_CELL_RESOLUTION);
+              ttsExtent = parseTtsExtent(xmlParser);
             }
             if (!isSupportedTag(name)) {
               Log.i(TAG, "Ignoring unsupported tag: " + xmlParser.getName());
               unsupportedNodeDepth++;
             } else if (TtmlNode.TAG_HEAD.equals(name)) {
-              parseHeader(xmlParser, globalStyles, regionMap, cellResolution);
+              parseHeader(xmlParser, globalStyles, cellResolution, ttsExtent, regionMap, imageMap);
             } else {
               try {
                 TtmlNode node = parseNode(xmlParser, parent, regionMap, frameAndTickRate);
@@ -145,7 +151,7 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
             parent.addChild(TtmlNode.buildTextNode(xmlParser.getText()));
           } else if (eventType == XmlPullParser.END_TAG) {
             if (xmlParser.getName().equals(TtmlNode.TAG_TT)) {
-              ttmlSubtitle = new TtmlSubtitle(nodeStack.peek(), globalStyles, regionMap);
+              ttmlSubtitle = new TtmlSubtitle(nodeStack.peek(), globalStyles, regionMap, imageMap);
             }
             nodeStack.pop();
           }
@@ -226,11 +232,34 @@ private CellResolution parseCellResolution(XmlPullParser xmlParser, CellResoluti
     }
   }
 
+  private TtsExtent parseTtsExtent(XmlPullParser xmlParser) {
+    String ttsExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);
+    if (ttsExtent == null) {
+      return null;
+    }
+
+    Matcher extentMatcher = PIXEL_COORDINATES.matcher(ttsExtent);
+    if (!extentMatcher.matches()) {
+      Log.w(TAG, "Ignoring non-pixel tts extent: " + ttsExtent);
+      return null;
+    }
+    try {
+      int width = Integer.parseInt(extentMatcher.group(1));
+      int height = Integer.parseInt(extentMatcher.group(2));
+      return new TtsExtent(width, height);
+    } catch (NumberFormatException e) {
+      Log.w(TAG, "Ignoring malformed tts extent: " + ttsExtent);
+      return null;
+    }
+  }
+
   private Map<String, TtmlStyle> parseHeader(
       XmlPullParser xmlParser,
       Map<String, TtmlStyle> globalStyles,
+      CellResolution cellResolution,
+      TtsExtent ttsExtent,
       Map<String, TtmlRegion> globalRegions,
-      CellResolution cellResolution)
+      Map<String, String> imageMap)
       throws IOException, XmlPullParserException {
     do {
       xmlParser.next();
@@ -246,23 +275,41 @@ private CellResolution parseCellResolution(XmlPullParser xmlParser, CellResoluti
           globalStyles.put(style.getId(), style);
         }
       } else if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_REGION)) {
-        TtmlRegion ttmlRegion = parseRegionAttributes(xmlParser, cellResolution);
+        TtmlRegion ttmlRegion = parseRegionAttributes(xmlParser, cellResolution, ttsExtent);
         if (ttmlRegion != null) {
           globalRegions.put(ttmlRegion.id, ttmlRegion);
         }
+      } else if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_METADATA)) {
+        parseMetadata(xmlParser, imageMap);
       }
     } while (!XmlPullParserUtil.isEndTag(xmlParser, TtmlNode.TAG_HEAD));
     return globalStyles;
   }
 
+  private void parseMetadata(XmlPullParser xmlParser, Map<String, String> imageMap)
+      throws IOException, XmlPullParserException {
+    do {
+      xmlParser.next();
+      if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_IMAGE)) {
+        String id = XmlPullParserUtil.getAttributeValue(xmlParser, "id");
+        if (id != null) {
+          String encodedBitmapData = xmlParser.nextText();
+          imageMap.put(id, encodedBitmapData);
+        }
+      }
+    } while (!XmlPullParserUtil.isEndTag(xmlParser, TtmlNode.TAG_METADATA));
+  }
+
   /**
    * Parses a region declaration.
    *
-   * <p>If the region defines an origin and extent, it is required that they're defined as
-   * percentages of the viewport. Region declarations that define origin and extent in other formats
-   * are unsupported, and null is returned.
+   * <p>Supports both percentage and pixel defined regions. In case of pixel defined regions the
+   * passed {@code ttsExtent} is used as a reference window to convert the pixel values to
+   * fractions. In case of missing tts:extent the pixel defined regions can't be parsed, and null is
+   * returned.
    */
-  private TtmlRegion parseRegionAttributes(XmlPullParser xmlParser, CellResolution cellResolution) {
+  private TtmlRegion parseRegionAttributes(
+      XmlPullParser xmlParser, CellResolution cellResolution, TtsExtent ttsExtent) {
     String regionId = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_ID);
     if (regionId == null) {
       return null;
@@ -270,13 +317,30 @@ private TtmlRegion parseRegionAttributes(XmlPullParser xmlParser, CellResolution
 
     float position;
     float line;
+
     String regionOrigin = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_ORIGIN);
     if (regionOrigin != null) {
-      Matcher originMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);
-      if (originMatcher.matches()) {
+      Matcher originPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);
+      Matcher originPixelMatcher = PIXEL_COORDINATES.matcher(regionOrigin);
+      if (originPercentageMatcher.matches()) {
         try {
-          position = Float.parseFloat(originMatcher.group(1)) / 100f;
-          line = Float.parseFloat(originMatcher.group(2)) / 100f;
+          position = Float.parseFloat(originPercentageMatcher.group(1)) / 100f;
+          line = Float.parseFloat(originPercentageMatcher.group(2)) / 100f;
+        } catch (NumberFormatException e) {
+          Log.w(TAG, "Ignoring region with malformed origin: " + regionOrigin);
+          return null;
+        }
+      } else if (originPixelMatcher.matches()) {
+        if (ttsExtent == null) {
+          Log.w(TAG, "Ignoring region with missing tts:extent: " + regionOrigin);
+          return null;
+        }
+        try {
+          int width = Integer.parseInt(originPixelMatcher.group(1));
+          int height = Integer.parseInt(originPixelMatcher.group(2));
+          // Convert pixel values to fractions.
+          position = width / (float) ttsExtent.width;
+          line = height / (float) ttsExtent.height;
         } catch (NumberFormatException e) {
           Log.w(TAG, "Ignoring region with malformed origin: " + regionOrigin);
           return null;
@@ -299,11 +363,27 @@ private TtmlRegion parseRegionAttributes(XmlPullParser xmlParser, CellResolution
     float height;
     String regionExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);
     if (regionExtent != null) {
-      Matcher extentMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);
-      if (extentMatcher.matches()) {
+      Matcher extentPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);
+      Matcher extentPixelMatcher = PIXEL_COORDINATES.matcher(regionExtent);
+      if (extentPercentageMatcher.matches()) {
         try {
-          width = Float.parseFloat(extentMatcher.group(1)) / 100f;
-          height = Float.parseFloat(extentMatcher.group(2)) / 100f;
+          width = Float.parseFloat(extentPercentageMatcher.group(1)) / 100f;
+          height = Float.parseFloat(extentPercentageMatcher.group(2)) / 100f;
+        } catch (NumberFormatException e) {
+          Log.w(TAG, "Ignoring region with malformed extent: " + regionOrigin);
+          return null;
+        }
+      } else if (extentPixelMatcher.matches()) {
+        if (ttsExtent == null) {
+          Log.w(TAG, "Ignoring region with missing tts:extent: " + regionOrigin);
+          return null;
+        }
+        try {
+          int extentWidth = Integer.parseInt(extentPixelMatcher.group(1));
+          int extentHeight = Integer.parseInt(extentPixelMatcher.group(2));
+          // Convert pixel values to fractions.
+          width = extentWidth / (float) ttsExtent.width;
+          height = extentHeight / (float) ttsExtent.height;
         } catch (NumberFormatException e) {
           Log.w(TAG, "Ignoring region with malformed extent: " + regionOrigin);
           return null;
@@ -457,6 +537,7 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
     long startTime = C.TIME_UNSET;
     long endTime = C.TIME_UNSET;
     String regionId = TtmlNode.ANONYMOUS_REGION_ID;
+    String imageId = null;
     String[] styleIds = null;
     int attributeCount = parser.getAttributeCount();
     TtmlStyle style = parseStyleAttributes(parser, null);
@@ -487,6 +568,13 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
             regionId = value;
           }
           break;
+        case ATTR_IMAGE:
+          // Parse URI reference only if refers to an element in the same document (it must start
+          // with '#'). Resolving URIs from external sources is not supported.
+          if (value.startsWith("#")) {
+            imageId = value.substring(1);
+          }
+          break;
         default:
           // Do nothing.
           break;
@@ -509,7 +597,8 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
         endTime = parent.endTimeUs;
       }
     }
-    return TtmlNode.buildNode(parser.getName(), startTime, endTime, style, styleIds, regionId);
+    return TtmlNode.buildNode(
+        parser.getName(), startTime, endTime, style, styleIds, regionId, imageId);
   }
 
   private static boolean isSupportedTag(String tag) {
@@ -525,9 +614,9 @@ private static boolean isSupportedTag(String tag) {
         || tag.equals(TtmlNode.TAG_LAYOUT)
         || tag.equals(TtmlNode.TAG_REGION)
         || tag.equals(TtmlNode.TAG_METADATA)
-        || tag.equals(TtmlNode.TAG_SMPTE_IMAGE)
-        || tag.equals(TtmlNode.TAG_SMPTE_DATA)
-        || tag.equals(TtmlNode.TAG_SMPTE_INFORMATION);
+        || tag.equals(TtmlNode.TAG_IMAGE)
+        || tag.equals(TtmlNode.TAG_DATA)
+        || tag.equals(TtmlNode.TAG_INFORMATION);
   }
 
   private static void parseFontSize(String expression, TtmlStyle out) throws
@@ -651,4 +740,15 @@ private static long parseTimeExpression(String time, FrameAndTickRate frameAndTi
       this.rows = rows;
     }
   }
+
+  /** Represents the tts:extent for a TTML file. */
+  private static final class TtsExtent {
+    final int width;
+    final int height;
+
+    TtsExtent(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
index c8b9a59de4..020bbe201b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
@@ -15,7 +15,12 @@
  */
 package com.google.android.exoplayer2.text.ttml;
 
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.support.annotation.Nullable;
 import android.text.SpannableStringBuilder;
+import android.util.Base64;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.util.Assertions;
@@ -44,9 +49,9 @@
   public static final String TAG_LAYOUT = "layout";
   public static final String TAG_REGION = "region";
   public static final String TAG_METADATA = "metadata";
-  public static final String TAG_SMPTE_IMAGE = "smpte:image";
-  public static final String TAG_SMPTE_DATA = "smpte:data";
-  public static final String TAG_SMPTE_INFORMATION = "smpte:information";
+  public static final String TAG_IMAGE = "image";
+  public static final String TAG_DATA = "data";
+  public static final String TAG_INFORMATION = "information";
 
   public static final String ANONYMOUS_REGION_ID = "";
   public static final String ATTR_ID = "id";
@@ -75,34 +80,57 @@
   public static final String START = "start";
   public static final String END = "end";
 
-  public final String tag;
-  public final String text;
+  @Nullable public final String tag;
+  @Nullable public final String text;
   public final boolean isTextNode;
   public final long startTimeUs;
   public final long endTimeUs;
-  public final TtmlStyle style;
+  @Nullable public final TtmlStyle style;
+  @Nullable private final String[] styleIds;
   public final String regionId;
+  @Nullable public final String imageId;
 
-  private final String[] styleIds;
   private final HashMap<String, Integer> nodeStartsByRegion;
   private final HashMap<String, Integer> nodeEndsByRegion;
 
   private List<TtmlNode> children;
 
   public static TtmlNode buildTextNode(String text) {
-    return new TtmlNode(null, TtmlRenderUtil.applyTextElementSpacePolicy(text), C.TIME_UNSET,
-        C.TIME_UNSET, null, null, ANONYMOUS_REGION_ID);
+    return new TtmlNode(
+        /* tag= */ null,
+        TtmlRenderUtil.applyTextElementSpacePolicy(text),
+        /* startTimeUs= */ C.TIME_UNSET,
+        /* endTimeUs= */ C.TIME_UNSET,
+        /* style= */ null,
+        /* styleIds= */ null,
+        ANONYMOUS_REGION_ID,
+        /* imageId= */ null);
   }
 
-  public static TtmlNode buildNode(String tag, long startTimeUs, long endTimeUs,
-      TtmlStyle style, String[] styleIds, String regionId) {
-    return new TtmlNode(tag, null, startTimeUs, endTimeUs, style, styleIds, regionId);
+  public static TtmlNode buildNode(
+      @Nullable String tag,
+      long startTimeUs,
+      long endTimeUs,
+      @Nullable TtmlStyle style,
+      @Nullable String[] styleIds,
+      String regionId,
+      @Nullable String imageId) {
+    return new TtmlNode(
+        tag, /* text= */ null, startTimeUs, endTimeUs, style, styleIds, regionId, imageId);
   }
 
-  private TtmlNode(String tag, String text, long startTimeUs, long endTimeUs,
-      TtmlStyle style, String[] styleIds, String regionId) {
+  private TtmlNode(
+      @Nullable String tag,
+      @Nullable String text,
+      long startTimeUs,
+      long endTimeUs,
+      @Nullable TtmlStyle style,
+      @Nullable String[] styleIds,
+      String regionId,
+      @Nullable String imageId) {
     this.tag = tag;
     this.text = text;
+    this.imageId = imageId;
     this.style = style;
     this.styleIds = styleIds;
     this.isTextNode = text != null;
@@ -151,7 +179,8 @@ public int getChildCount() {
 
   private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
     boolean isPNode = TAG_P.equals(tag);
-    if (descendsPNode || isPNode) {
+    boolean isDivNode = TAG_DIV.equals(tag);
+    if (descendsPNode || isPNode || (isDivNode && imageId != null)) {
       if (startTimeUs != C.TIME_UNSET) {
         out.add(startTimeUs);
       }
@@ -171,13 +200,46 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
     return styleIds;
   }
 
-  public List<Cue> getCues(long timeUs, Map<String, TtmlStyle> globalStyles,
-      Map<String, TtmlRegion> regionMap) {
-    TreeMap<String, SpannableStringBuilder> regionOutputs = new TreeMap<>();
-    traverseForText(timeUs, false, regionId, regionOutputs);
-    traverseForStyle(timeUs, globalStyles, regionOutputs);
+  public List<Cue> getCues(
+      long timeUs,
+      Map<String, TtmlStyle> globalStyles,
+      Map<String, TtmlRegion> regionMap,
+      Map<String, String> imageMap) {
+
+    List<Pair<String, String>> regionImageOutputs = new ArrayList<>();
+    traverseForImage(timeUs, regionId, regionImageOutputs);
+
+    TreeMap<String, SpannableStringBuilder> regionTextOutputs = new TreeMap<>();
+    traverseForText(timeUs, false, regionId, regionTextOutputs);
+    traverseForStyle(timeUs, globalStyles, regionTextOutputs);
+
     List<Cue> cues = new ArrayList<>();
-    for (Entry<String, SpannableStringBuilder> entry : regionOutputs.entrySet()) {
+
+    // Create image based cues.
+    for (Pair<String, String> regionImagePair : regionImageOutputs) {
+      String encodedBitmapData = imageMap.get(regionImagePair.second);
+      if (encodedBitmapData == null) {
+        // Image reference points to an invalid image. Do nothing.
+        continue;
+      }
+
+      byte[] bitmapData = Base64.decode(encodedBitmapData, Base64.DEFAULT);
+      Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, /* offset= */ 0, bitmapData.length);
+      TtmlRegion region = regionMap.get(regionImagePair.first);
+
+      cues.add(
+          new Cue(
+              bitmap,
+              region.position,
+              Cue.ANCHOR_TYPE_MIDDLE,
+              region.line,
+              region.lineAnchor,
+              region.width,
+              /* height= */ Cue.DIMEN_UNSET));
+    }
+
+    // Create text based cues.
+    for (Entry<String, SpannableStringBuilder> entry : regionTextOutputs.entrySet()) {
       TtmlRegion region = regionMap.get(entry.getKey());
       cues.add(
           new Cue(
@@ -192,9 +254,22 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
               region.textSizeType,
               region.textSize));
     }
+
     return cues;
   }
 
+  private void traverseForImage(
+      long timeUs, String inheritedRegion, List<Pair<String, String>> regionImageList) {
+    String resolvedRegionId = ANONYMOUS_REGION_ID.equals(regionId) ? inheritedRegion : regionId;
+    if (isActive(timeUs) && TAG_DIV.equals(tag) && imageId != null) {
+      regionImageList.add(new Pair<>(resolvedRegionId, imageId));
+      return;
+    }
+    for (int i = 0; i < getChildCount(); ++i) {
+      getChild(i).traverseForImage(timeUs, resolvedRegionId, regionImageList);
+    }
+  }
+
   private void traverseForText(
       long timeUs,
       boolean descendsPNode,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
index 90f93d5b21..a4f0cca955 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
@@ -19,6 +19,7 @@
 import android.support.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -29,25 +30,32 @@
 
   public static final int UNSPECIFIED = -1;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC,
-      STYLE_BOLD_ITALIC})
+  @IntDef(
+      flag = true,
+      value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC, STYLE_BOLD_ITALIC})
   public @interface StyleFlags {}
+
   public static final int STYLE_NORMAL = Typeface.NORMAL;
   public static final int STYLE_BOLD = Typeface.BOLD;
   public static final int STYLE_ITALIC = Typeface.ITALIC;
   public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
   public @interface FontSizeUnit {}
+
   public static final int FONT_SIZE_UNIT_PIXEL = 1;
   public static final int FONT_SIZE_UNIT_EM = 2;
   public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, OFF, ON})
   private @interface OptionalBoolean {}
+
   private static final int OFF = 0;
   private static final int ON = 1;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
index 433436f771..7b30461750 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
@@ -32,13 +32,18 @@
   private final long[] eventTimesUs;
   private final Map<String, TtmlStyle> globalStyles;
   private final Map<String, TtmlRegion> regionMap;
+  private final Map<String, String> imageMap;
 
-  public TtmlSubtitle(TtmlNode root, Map<String, TtmlStyle> globalStyles,
-      Map<String, TtmlRegion> regionMap) {
+  public TtmlSubtitle(
+      TtmlNode root,
+      Map<String, TtmlStyle> globalStyles,
+      Map<String, TtmlRegion> regionMap,
+      Map<String, String> imageMap) {
     this.root = root;
     this.regionMap = regionMap;
-    this.globalStyles = globalStyles != null
-        ? Collections.unmodifiableMap(globalStyles) : Collections.<String, TtmlStyle>emptyMap();
+    this.imageMap = imageMap;
+    this.globalStyles =
+        globalStyles != null ? Collections.unmodifiableMap(globalStyles) : Collections.emptyMap();
     this.eventTimesUs = root.getEventTimesUs();
   }
 
@@ -65,7 +70,7 @@ public long getEventTime(int index) {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return root.getCues(timeUs, globalStyles, regionMap);
+    return root.getCues(timeUs, globalStyles, regionMap, imageMap);
   }
 
   /* @VisibleForTesting */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java
index ebc38bcd70..9211dc51ce 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java
@@ -56,8 +56,8 @@
   private static final int FONT_FACE_ITALIC = 0x0002;
   private static final int FONT_FACE_UNDERLINE = 0x0004;
 
-  private static final int SPAN_PRIORITY_LOW = (0xFF << Spanned.SPAN_PRIORITY_SHIFT);
-  private static final int SPAN_PRIORITY_HIGH = (0x00 << Spanned.SPAN_PRIORITY_SHIFT);
+  private static final int SPAN_PRIORITY_LOW = 0xFF << Spanned.SPAN_PRIORITY_SHIFT;
+  private static final int SPAN_PRIORITY_HIGH = 0;
 
   private static final int DEFAULT_FONT_FACE = 0;
   private static final int DEFAULT_COLOR = Color.WHITE;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gSubtitle.java
index 4f2fc8373e..adb1190ce4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gSubtitle.java
@@ -57,7 +57,7 @@ public long getEventTime(int index) {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
+    return timeUs >= 0 ? cues : Collections.emptyList();
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoder.java
index 17c2366f07..8cb0ac58c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoder.java
@@ -85,8 +85,7 @@ private static Cue parseVttCueBox(ParsableByteArray sampleData, WebvttCue.Builde
       if (boxType == TYPE_sttg) {
         WebvttCueParser.parseCueSettingsList(boxPayload, builder);
       } else if (boxType == TYPE_payl) {
-        WebvttCueParser.parseCueText(null, boxPayload.trim(), builder,
-            Collections.<WebvttCssStyle>emptyList());
+        WebvttCueParser.parseCueText(null, boxPayload.trim(), builder, Collections.emptyList());
       } else {
         // Other VTTCueBox children are still not supported and are ignored.
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttSubtitle.java
index 881300807e..c87c88133c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttSubtitle.java
@@ -51,6 +51,6 @@ public long getEventTime(int index) {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
+    return timeUs >= 0 ? cues : Collections.emptyList();
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index a78c5afa78..fe274a6241 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -19,6 +19,7 @@
 import android.support.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -35,27 +36,40 @@
 
   public static final int UNSPECIFIED = -1;
 
-  /** Style flag enum */
+  /**
+   * Style flag enum. Possible flag values are {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link
+   * #STYLE_BOLD}, {@link #STYLE_ITALIC} and {@link #STYLE_BOLD_ITALIC}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC,
-      STYLE_BOLD_ITALIC})
+  @IntDef(
+      flag = true,
+      value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC, STYLE_BOLD_ITALIC})
   public @interface StyleFlags {}
+
   public static final int STYLE_NORMAL = Typeface.NORMAL;
   public static final int STYLE_BOLD = Typeface.BOLD;
   public static final int STYLE_ITALIC = Typeface.ITALIC;
   public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
-  /** Font size unit enum */
+  /**
+   * Font size unit enum. One of {@link #UNSPECIFIED}, {@link #FONT_SIZE_UNIT_PIXEL}, {@link
+   * #FONT_SIZE_UNIT_EM} or {@link #FONT_SIZE_UNIT_PERCENT}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
   public @interface FontSizeUnit {}
+
   public static final int FONT_SIZE_UNIT_PIXEL = 1;
   public static final int FONT_SIZE_UNIT_EM = 2;
   public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, OFF, ON})
   private @interface OptionalBoolean {}
+
   private static final int OFF = 0;
   private static final int ON = 1;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
index e16b231f7e..857b1562ee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
@@ -17,8 +17,8 @@
 
 import android.text.Layout.Alignment;
 import android.text.SpannableStringBuilder;
-import android.util.Log;
 import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.util.Log;
 
 /**
  * A representation of a WebVTT cue.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
index 6f2a1328c6..9900ca0e72 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
@@ -31,8 +31,8 @@
 import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
 import android.text.style.UnderlineSpan;
-import android.util.Log;
 import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayDeque;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
index 7c3262fbba..06d3c14970 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.text.webvtt;
 
 import android.text.TextUtils;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -62,7 +63,11 @@ protected WebvttSubtitle decode(byte[] bytes, int length, boolean reset)
     definedStyles.clear();
 
     // Validate the first line of the header, and skip the remainder.
-    WebvttParserUtil.validateWebvttHeaderLine(parsableWebvttData);
+    try {
+      WebvttParserUtil.validateWebvttHeaderLine(parsableWebvttData);
+    } catch (ParserException e) {
+      throw new SubtitleDecoderException(e);
+    }
     while (!TextUtils.isEmpty(parsableWebvttData.readLine())) {}
 
     int event;
@@ -105,7 +110,7 @@ private static int getNextEvent(ParsableByteArray parsableWebvttData) {
         foundEvent = EVENT_END_OF_FILE;
       } else if (STYLE_START.equals(line)) {
         foundEvent = EVENT_STYLE_BLOCK;
-      } else if (COMMENT_START.startsWith(line)) {
+      } else if (line.startsWith(COMMENT_START)) {
         foundEvent = EVENT_COMMENT;
       } else {
         foundEvent = EVENT_CUE;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
index b94be19d8f..22aee60a9c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
-import com.google.android.exoplayer2.text.SubtitleDecoderException;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.regex.Matcher;
@@ -27,7 +27,7 @@
 public final class WebvttParserUtil {
 
   private static final Pattern COMMENT = Pattern.compile("^NOTE((\u0020|\u0009).*)?$");
-  private static final Pattern HEADER = Pattern.compile("^\uFEFF?WEBVTT((\u0020|\u0009).*)?$");
+  private static final String WEBVTT_HEADER = "WEBVTT";
 
   private WebvttParserUtil() {}
 
@@ -35,16 +35,26 @@ private WebvttParserUtil() {}
    * Reads and validates the first line of a WebVTT file.
    *
    * @param input The input from which the line should be read.
-   * @throws SubtitleDecoderException If the line isn't the start of a valid WebVTT file.
+   * @throws ParserException If the line isn't the start of a valid WebVTT file.
    */
-  public static void validateWebvttHeaderLine(ParsableByteArray input)
-      throws SubtitleDecoderException {
-    String line = input.readLine();
-    if (line == null || !HEADER.matcher(line).matches()) {
-      throw new SubtitleDecoderException("Expected WEBVTT. Got " + line);
+  public static void validateWebvttHeaderLine(ParsableByteArray input) throws ParserException {
+    int startPosition = input.getPosition();
+    if (!isWebvttHeaderLine(input)) {
+      input.setPosition(startPosition);
+      throw new ParserException("Expected WEBVTT. Got " + input.readLine());
     }
   }
 
+  /**
+   * Returns whether the given input is the first line of a WebVTT file.
+   *
+   * @param input The input from which the line should be read.
+   */
+  public static boolean isWebvttHeaderLine(ParsableByteArray input) {
+    String line = input.readLine();
+    return line != null && line.startsWith(WEBVTT_HEADER);
+  }
+
   /**
    * Parses a WebVTT timestamp.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index 0aa6dcffaa..696f2bdefe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -17,9 +17,11 @@
 
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
@@ -36,7 +38,7 @@
    */
   public static final class Factory implements TrackSelection.Factory {
 
-    private final BandwidthMeter bandwidthMeter;
+    private final @Nullable BandwidthMeter bandwidthMeter;
     private final int minDurationForQualityIncreaseMs;
     private final int maxDurationForQualityDecreaseMs;
     private final int minDurationToRetainAfterDiscardMs;
@@ -45,9 +47,24 @@
     private final long minTimeBetweenBufferReevaluationMs;
     private final Clock clock;
 
+    /** Creates an adaptive track selection factory with default parameters. */
+    public Factory() {
+      this(
+          DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+          DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+          DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+          DEFAULT_BANDWIDTH_FRACTION,
+          DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+          DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+          Clock.DEFAULT);
+    }
+
     /**
-     * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+     * @deprecated Use {@link #Factory()} instead. Custom bandwidth meter should be directly passed
+     *     to the player in {@link ExoPlayerFactory}.
      */
+    @Deprecated
+    @SuppressWarnings("deprecation")
     public Factory(BandwidthMeter bandwidthMeter) {
       this(
           bandwidthMeter,
@@ -61,7 +78,8 @@ public Factory(BandwidthMeter bandwidthMeter) {
     }
 
     /**
-     * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+     * Creates an adaptive track selection factory.
+     *
      * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for the
      *     selected track to switch to one of higher quality.
      * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the
@@ -74,6 +92,27 @@ public Factory(BandwidthMeter bandwidthMeter) {
      *     consider available for use. Setting to a value less than 1 is recommended to account for
      *     inaccuracies in the bandwidth estimator.
      */
+    public Factory(
+        int minDurationForQualityIncreaseMs,
+        int maxDurationForQualityDecreaseMs,
+        int minDurationToRetainAfterDiscardMs,
+        float bandwidthFraction) {
+      this(
+          minDurationForQualityIncreaseMs,
+          maxDurationForQualityDecreaseMs,
+          minDurationToRetainAfterDiscardMs,
+          bandwidthFraction,
+          DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+          DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+          Clock.DEFAULT);
+    }
+
+    /**
+     * @deprecated Use {@link #Factory(int, int, int, float)} instead. Custom bandwidth meter should
+     *     be directly passed to the player in {@link ExoPlayerFactory}.
+     */
+    @Deprecated
+    @SuppressWarnings("deprecation")
     public Factory(
         BandwidthMeter bandwidthMeter,
         int minDurationForQualityIncreaseMs,
@@ -92,7 +131,8 @@ public Factory(
     }
 
     /**
-     * @param bandwidthMeter Provides an estimate of the currently available bandwidth..
+     * Creates an adaptive track selection factory.
+     *
      * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for the
      *     selected track to switch to one of higher quality.
      * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the
@@ -116,8 +156,33 @@ public Factory(
      *     buffer reevaluation calls.
      * @param clock A {@link Clock}.
      */
+    @SuppressWarnings("deprecation")
     public Factory(
-        BandwidthMeter bandwidthMeter,
+        int minDurationForQualityIncreaseMs,
+        int maxDurationForQualityDecreaseMs,
+        int minDurationToRetainAfterDiscardMs,
+        float bandwidthFraction,
+        float bufferedFractionToLiveEdgeForQualityIncrease,
+        long minTimeBetweenBufferReevaluationMs,
+        Clock clock) {
+      this(
+          /* bandwidthMeter= */ null,
+          minDurationForQualityIncreaseMs,
+          maxDurationForQualityDecreaseMs,
+          minDurationToRetainAfterDiscardMs,
+          bandwidthFraction,
+          bufferedFractionToLiveEdgeForQualityIncrease,
+          minTimeBetweenBufferReevaluationMs,
+          clock);
+    }
+
+    /**
+     * @deprecated Use {@link #Factory(int, int, int, float, float, long, Clock)} instead. Custom
+     *     bandwidth meter should be directly passed to the player in {@link ExoPlayerFactory}.
+     */
+    @Deprecated
+    public Factory(
+        @Nullable BandwidthMeter bandwidthMeter,
         int minDurationForQualityIncreaseMs,
         int maxDurationForQualityDecreaseMs,
         int minDurationToRetainAfterDiscardMs,
@@ -137,7 +202,11 @@ public Factory(
     }
 
     @Override
-    public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+    public AdaptiveTrackSelection createTrackSelection(
+        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
+      if (this.bandwidthMeter != null) {
+        bandwidthMeter = this.bandwidthMeter;
+      }
       return new AdaptiveTrackSelection(
           group,
           tracks,
@@ -261,9 +330,14 @@ public void onPlaybackSpeed(float playbackSpeed) {
   }
 
   @Override
-  public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
-      long availableDurationUs) {
+  public void updateSelectedTrack(
+      long playbackPositionUs,
+      long bufferedDurationUs,
+      long availableDurationUs,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] mediaChunkIterators) {
     long nowMs = clock.elapsedRealtime();
+
     // Stash the current selection, then make a new one.
     int currentSelectedIndex = selectedIndex;
     selectedIndex = determineIdealSelectedIndex(nowMs);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index 3f201bccea..798b6ce810 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
@@ -160,7 +161,10 @@ public final boolean blacklist(int index, long blacklistDurationMs) {
     if (!canBlacklist) {
       return false;
     }
-    blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);
+    blacklistUntilTimes[index] =
+        Math.max(
+            blacklistUntilTimes[index],
+            Util.addWithOverflowDefault(nowMs, blacklistDurationMs, Long.MAX_VALUE));
     return true;
   }
 
@@ -186,7 +190,7 @@ public int hashCode() {
 
   // Track groups are compared by identity not value, as distinct groups may have the same value.
   @Override
-  @SuppressWarnings("ReferenceEquality")
+  @SuppressWarnings({"ReferenceEquality", "EqualsGetClass"})
   public boolean equals(@Nullable Object obj) {
     if (this == obj) {
       return true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 3bbb2a7941..4a75b6f722 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -19,6 +19,7 @@
 import android.graphics.Point;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Pair;
@@ -26,6 +27,7 @@
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
@@ -43,6 +45,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A default {@link TrackSelector} suitable for most use cases. Track selections are made according
@@ -55,7 +58,7 @@
  * obtain a {@link ParametersBuilder} initialized with the current {@link Parameters}. The desired
  * modifications can be made on the builder, and the resulting {@link Parameters} can then be built
  * and set on the selector. For example the following code modifies the parameters to restrict video
- * track selections to SD, and to prefer German audio tracks:
+ * track selections to SD, and to select a German audio track if there is one:
  *
  * <pre>{@code
  * // Build on the current parameters.
@@ -82,7 +85,7 @@
  *
  * Selection {@link Parameters} support many different options, some of which are described below.
  *
- * <h3>Track selection overrides</h3>
+ * <h3>Selecting specific tracks</h3>
  *
  * Track selection overrides can be used to select specific tracks. To specify an override for a
  * renderer, it's first necessary to obtain the tracks that have been mapped to it:
@@ -109,13 +112,6 @@
  *         .setSelectionOverride(rendererIndex, rendererTrackGroups, selectionOverride));
  * }</pre>
  *
- * <h3>Disabling renderers</h3>
- *
- * Renderers can be disabled using {@link ParametersBuilder#setRendererDisabled}. Disabling a
- * renderer differs from setting a {@code null} override because the renderer is disabled
- * unconditionally, whereas a {@code null} override is applied only when the track groups available
- * to the renderer match the {@link TrackGroupArray} for which it was specified.
- *
  * <h3>Constraint based track selection</h3>
  *
  * Whilst track selection overrides make it possible to select specific tracks, the recommended way
@@ -144,6 +140,13 @@
  *       only applied to periods whose tracks match those for which the override was set.
  * </ul>
  *
+ * <h3>Disabling renderers</h3>
+ *
+ * Renderers can be disabled using {@link ParametersBuilder#setRendererDisabled}. Disabling a
+ * renderer differs from setting a {@code null} override because the renderer is disabled
+ * unconditionally, whereas a {@code null} override is applied only when the track groups available
+ * to the renderer match the {@link TrackGroupArray} for which it was specified.
+ *
  * <h3>Tunneling</h3>
  *
  * Tunneled playback can be enabled in cases where the combination of renderers and selected tracks
@@ -153,7 +156,8 @@
 public class DefaultTrackSelector extends MappingTrackSelector {
 
   /**
-   * A builder for {@link Parameters}.
+   * A builder for {@link Parameters}. See the {@link Parameters} documentation for explanations of
+   * the parameters that can be configured using this builder.
    */
   public static final class ParametersBuilder {
 
@@ -165,10 +169,12 @@
     private boolean selectUndeterminedTextLanguage;
     private int disabledTextTrackSelectionFlags;
     private boolean forceLowestBitrate;
+    private boolean forceHighestSupportedBitrate;
     private boolean allowMixedMimeAdaptiveness;
     private boolean allowNonSeamlessAdaptiveness;
     private int maxVideoWidth;
     private int maxVideoHeight;
+    private int maxVideoFrameRate;
     private int maxVideoBitrate;
     private boolean exceedVideoConstraintsIfNecessary;
     private boolean exceedRendererCapabilitiesIfNecessary;
@@ -177,9 +183,7 @@
     private boolean viewportOrientationMayChange;
     private int tunnelingAudioSessionId;
 
-    /**
-     * Creates a builder obtaining the initial values from {@link Parameters#DEFAULT}.
-     */
+    /** Creates a builder with default initial values. */
     public ParametersBuilder() {
       this(Parameters.DEFAULT);
     }
@@ -196,10 +200,12 @@ private ParametersBuilder(Parameters initialValues) {
       selectUndeterminedTextLanguage = initialValues.selectUndeterminedTextLanguage;
       disabledTextTrackSelectionFlags = initialValues.disabledTextTrackSelectionFlags;
       forceLowestBitrate = initialValues.forceLowestBitrate;
+      forceHighestSupportedBitrate = initialValues.forceHighestSupportedBitrate;
       allowMixedMimeAdaptiveness = initialValues.allowMixedMimeAdaptiveness;
       allowNonSeamlessAdaptiveness = initialValues.allowNonSeamlessAdaptiveness;
       maxVideoWidth = initialValues.maxVideoWidth;
       maxVideoHeight = initialValues.maxVideoHeight;
+      maxVideoFrameRate = initialValues.maxVideoFrameRate;
       maxVideoBitrate = initialValues.maxVideoBitrate;
       exceedVideoConstraintsIfNecessary = initialValues.exceedVideoConstraintsIfNecessary;
       exceedRendererCapabilitiesIfNecessary = initialValues.exceedRendererCapabilitiesIfNecessary;
@@ -261,6 +267,16 @@ public ParametersBuilder setForceLowestBitrate(boolean forceLowestBitrate) {
       return this;
     }
 
+    /**
+     * See {@link Parameters#forceHighestSupportedBitrate}.
+     *
+     * @return This builder.
+     */
+    public ParametersBuilder setForceHighestSupportedBitrate(boolean forceHighestSupportedBitrate) {
+      this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
+      return this;
+    }
+
     /**
      * See {@link Parameters#allowMixedMimeAdaptiveness}.
      *
@@ -310,6 +326,16 @@ public ParametersBuilder setMaxVideoSize(int maxVideoWidth, int maxVideoHeight)
       return this;
     }
 
+    /**
+     * See {@link Parameters#maxVideoFrameRate}.
+     *
+     * @return This builder.
+     */
+    public ParametersBuilder setMaxVideoFrameRate(int maxVideoFrameRate) {
+      this.maxVideoFrameRate = maxVideoFrameRate;
+      return this;
+    }
+
     /**
      * See {@link Parameters#maxVideoBitrate}.
      *
@@ -343,15 +369,15 @@ public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
     }
 
     /**
-     * Equivalent to invoking {@link #setViewportSize} with the viewport size obtained from
-     * {@link Util#getPhysicalDisplaySize(Context)}.
+     * Equivalent to calling {@link #setViewportSize(int, int, boolean)} with the viewport size
+     * obtained from {@link Util#getPhysicalDisplaySize(Context)}.
      *
-     * @param context The context to obtain the viewport size from.
-     * @param viewportOrientationMayChange See {@link #viewportOrientationMayChange}.
+     * @param context Any context.
+     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
      * @return This builder.
      */
-    public ParametersBuilder setViewportSizeToPhysicalDisplaySize(Context context,
-        boolean viewportOrientationMayChange) {
+    public ParametersBuilder setViewportSizeToPhysicalDisplaySize(
+        Context context, boolean viewportOrientationMayChange) {
       // Assume the viewport is fullscreen.
       Point viewportSize = Util.getPhysicalDisplaySize(context);
       return setViewportSize(viewportSize.x, viewportSize.y, viewportOrientationMayChange);
@@ -368,13 +394,16 @@ public ParametersBuilder clearViewportSizeConstraints() {
     }
 
     /**
-     * See {@link Parameters#viewportWidth}, {@link Parameters#maxVideoHeight} and
-     * {@link Parameters#viewportOrientationMayChange}.
+     * See {@link Parameters#viewportWidth}, {@link Parameters#maxVideoHeight} and {@link
+     * Parameters#viewportOrientationMayChange}.
      *
+     * @param viewportWidth See {@link Parameters#viewportWidth}.
+     * @param viewportHeight See {@link Parameters#viewportHeight}.
+     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
      * @return This builder.
      */
-    public ParametersBuilder setViewportSize(int viewportWidth, int viewportHeight,
-        boolean viewportOrientationMayChange) {
+    public ParametersBuilder setViewportSize(
+        int viewportWidth, int viewportHeight, boolean viewportOrientationMayChange) {
       this.viewportWidth = viewportWidth;
       this.viewportHeight = viewportHeight;
       this.viewportOrientationMayChange = viewportOrientationMayChange;
@@ -485,8 +514,10 @@ public final ParametersBuilder clearSelectionOverrides() {
     }
 
     /**
-     * Enables or disables tunneling. To enable tunneling, pass an audio session id to use when in
-     * tunneling mode. Session ids can be generated using {@link
+     * See {@link Parameters#tunnelingAudioSessionId}.
+     *
+     * <p>Enables or disables tunneling. To enable tunneling, pass an audio session id to use when
+     * in tunneling mode. Session ids can be generated using {@link
      * C#generateAudioSessionIdV21(Context)}. To disable tunneling pass {@link
      * C#AUDIO_SESSION_ID_UNSET}. Tunneling will only be activated if it's both enabled and
      * supported by the audio and video renderers for the selected tracks.
@@ -514,10 +545,12 @@ public Parameters build() {
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags,
           forceLowestBitrate,
+          forceHighestSupportedBitrate,
           allowMixedMimeAdaptiveness,
           allowNonSeamlessAdaptiveness,
           maxVideoWidth,
           maxVideoHeight,
+          maxVideoFrameRate,
           maxVideoBitrate,
           exceedVideoConstraintsIfNecessary,
           exceedRendererCapabilitiesIfNecessary,
@@ -540,25 +573,7 @@ public Parameters build() {
   /** Constraint parameters for {@link DefaultTrackSelector}. */
   public static final class Parameters implements Parcelable {
 
-    /**
-     * An instance with default values:
-     *
-     * <ul>
-     *   <li>No preferred audio language.
-     *   <li>No preferred text language.
-     *   <li>Text tracks with undetermined language are not selected if no track with {@link
-     *       #preferredTextLanguage} is available.
-     *   <li>All selection flags are considered for text track selections.
-     *   <li>Lowest bitrate track selections are not forced.
-     *   <li>Adaptation between different mime types is not allowed.
-     *   <li>Non seamless adaptation is allowed.
-     *   <li>No max limit for video width/height.
-     *   <li>No max video bitrate.
-     *   <li>Video constraints are exceeded if no supported selection can be made otherwise.
-     *   <li>Renderer capabilities are exceeded if no supported selection can be made.
-     *   <li>No viewport constraints.
-     * </ul>
-     */
+    /** An instance with default values. */
     public static final Parameters DEFAULT = new Parameters();
 
     // Per renderer overrides.
@@ -568,105 +583,143 @@ public Parameters build() {
 
     // Audio
     /**
-     * The preferred language for audio, as well as for forced text tracks, as an ISO 639-2/T tag.
-     * {@code null} selects the default track, or the first track if there's no default.
+     * The preferred language for audio and forced text tracks, as an ISO 639-2/T tag. {@code null}
+     * selects the default track, or the first track if there's no default. The default value is
+     * {@code null}.
      */
     public final @Nullable String preferredAudioLanguage;
 
     // Text
     /**
      * The preferred language for text tracks as an ISO 639-2/T tag. {@code null} selects the
-     * default track if there is one, or no track otherwise.
+     * default track if there is one, or no track otherwise. The default value is {@code null}.
      */
     public final @Nullable String preferredTextLanguage;
     /**
-     * Whether a text track with undetermined language should be selected if no track with
-     * {@link #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset.
+     * Whether a text track with undetermined language should be selected if no track with {@link
+     * #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset. The
+     * default value is {@code false}.
      */
     public final boolean selectUndeterminedTextLanguage;
     /**
      * Bitmask of selection flags that are disabled for text track selections. See {@link
-     * C.SelectionFlags}.
+     * C.SelectionFlags}. The default value is {@code 0} (i.e. no flags).
      */
     public final int disabledTextTrackSelectionFlags;
 
     // Video
     /**
-     * Maximum allowed video width.
+     * Maximum allowed video width. The default value is {@link Integer#MAX_VALUE} (i.e. no
+     * constraint).
+     *
+     * <p>To constrain adaptive video track selections to be suitable for a given viewport (the
+     * region of the display within which video will be played), use ({@link #viewportWidth}, {@link
+     * #viewportHeight} and {@link #viewportOrientationMayChange}) instead.
      */
     public final int maxVideoWidth;
     /**
-     * Maximum allowed video height.
+     * Maximum allowed video height. The default value is {@link Integer#MAX_VALUE} (i.e. no
+     * constraint).
+     *
+     * <p>To constrain adaptive video track selections to be suitable for a given viewport (the
+     * region of the display within which video will be played), use ({@link #viewportWidth}, {@link
+     * #viewportHeight} and {@link #viewportOrientationMayChange}) instead.
      */
     public final int maxVideoHeight;
     /**
-     * Maximum video bitrate.
+     * Maximum allowed video frame rate. The default value is {@link Integer#MAX_VALUE} (i.e. no
+     * constraint).
+     */
+    public final int maxVideoFrameRate;
+    /**
+     * Maximum video bitrate. The default value is {@link Integer#MAX_VALUE} (i.e. no constraint).
      */
     public final int maxVideoBitrate;
     /**
-     * Whether to exceed video constraints when no selection can be made otherwise.
+     * Whether to exceed the {@link #maxVideoWidth}, {@link #maxVideoHeight} and {@link
+     * #maxVideoBitrate} constraints when no selection can be made otherwise. The default value is
+     * {@code true}.
      */
     public final boolean exceedVideoConstraintsIfNecessary;
     /**
-     * Viewport width in pixels. Constrains video tracks selections for adaptive playbacks so that
-     * only tracks suitable for the viewport are selected.
+     * Viewport width in pixels. Constrains video track selections for adaptive content so that only
+     * tracks suitable for the viewport are selected. The default value is {@link Integer#MAX_VALUE}
+     * (i.e. no constraint).
      */
     public final int viewportWidth;
     /**
-     * Viewport height in pixels. Constrains video tracks selections for adaptive playbacks so that
-     * only tracks suitable for the viewport are selected.
+     * Viewport height in pixels. Constrains video track selections for adaptive content so that
+     * only tracks suitable for the viewport are selected. The default value is {@link
+     * Integer#MAX_VALUE} (i.e. no constraint).
      */
     public final int viewportHeight;
     /**
-     * Whether the viewport orientation may change during playback. Constrains video tracks
-     * selections for adaptive playbacks so that only tracks suitable for the viewport are selected.
+     * Whether the viewport orientation may change during playback. Constrains video track
+     * selections for adaptive content so that only tracks suitable for the viewport are selected.
+     * The default value is {@code true}.
      */
     public final boolean viewportOrientationMayChange;
 
     // General
     /**
      * Whether to force selection of the single lowest bitrate audio and video tracks that comply
-     * with all other constraints.
+     * with all other constraints. The default value is {@code false}.
      */
     public final boolean forceLowestBitrate;
     /**
-     * Whether to allow adaptive selections containing mixed mime types.
+     * Whether to force selection of the highest bitrate audio and video tracks that comply with all
+     * other constraints. The default value is {@code false}.
+     */
+    public final boolean forceHighestSupportedBitrate;
+    /**
+     * Whether to allow adaptive selections containing mixed mime types. The default value is {@code
+     * false}.
      */
     public final boolean allowMixedMimeAdaptiveness;
     /**
-     * Whether to allow adaptive selections where adaptation may not be completely seamless.
+     * Whether to allow adaptive selections where adaptation may not be completely seamless. The
+     * default value is {@code true}.
      */
     public final boolean allowNonSeamlessAdaptiveness;
     /**
      * Whether to exceed renderer capabilities when no selection can be made otherwise.
+     *
+     * <p>This parameter applies when all of the tracks available for a renderer exceed the
+     * renderer's reported capabilities. If the parameter is {@code true} then the lowest quality
+     * track will still be selected. Playback may succeed if the renderer has under-reported its
+     * true capabilities. If {@code false} then no track will be selected. The default value is
+     * {@code true}.
      */
     public final boolean exceedRendererCapabilitiesIfNecessary;
     /**
      * The audio session id to use when tunneling, or {@link C#AUDIO_SESSION_ID_UNSET} if tunneling
-     * is not to be enabled.
+     * is disabled. The default value is {@link C#AUDIO_SESSION_ID_UNSET} (i.e. tunneling is
+     * disabled).
      */
     public final int tunnelingAudioSessionId;
 
     private Parameters() {
       this(
-          new SparseArray<Map<TrackGroupArray, SelectionOverride>>(),
-          new SparseBooleanArray(),
-          null,
-          null,
-          false,
-          0,
-          false,
-          false,
-          true,
-          Integer.MAX_VALUE,
-          Integer.MAX_VALUE,
-          Integer.MAX_VALUE,
-          true,
-          true,
-          Integer.MAX_VALUE,
-          Integer.MAX_VALUE,
-          true,
-          C.AUDIO_SESSION_ID_UNSET);
+          /* selectionOverrides= */ new SparseArray<>(),
+          /* rendererDisabledFlags= */ new SparseBooleanArray(),
+          /* preferredAudioLanguage= */ null,
+          /* preferredTextLanguage= */ null,
+          /* selectUndeterminedTextLanguage= */ false,
+          /* disabledTextTrackSelectionFlags= */ 0,
+          /* forceLowestBitrate= */ false,
+          /* forceHighestSupportedBitrate= */ false,
+          /* allowMixedMimeAdaptiveness= */ false,
+          /* allowNonSeamlessAdaptiveness= */ true,
+          /* maxVideoWidth= */ Integer.MAX_VALUE,
+          /* maxVideoHeight= */ Integer.MAX_VALUE,
+          /* maxVideoFrameRate= */ Integer.MAX_VALUE,
+          /* maxVideoBitrate= */ Integer.MAX_VALUE,
+          /* exceedVideoConstraintsIfNecessary= */ true,
+          /* exceedRendererCapabilitiesIfNecessary= */ true,
+          /* viewportWidth= */ Integer.MAX_VALUE,
+          /* viewportHeight= */ Integer.MAX_VALUE,
+          /* viewportOrientationMayChange= */ true,
+          /* tunnelingAudioSessionId= */ C.AUDIO_SESSION_ID_UNSET);
     }
 
     /* package */ Parameters(
@@ -677,10 +730,12 @@ private Parameters() {
         boolean selectUndeterminedTextLanguage,
         int disabledTextTrackSelectionFlags,
         boolean forceLowestBitrate,
+        boolean forceHighestSupportedBitrate,
         boolean allowMixedMimeAdaptiveness,
         boolean allowNonSeamlessAdaptiveness,
         int maxVideoWidth,
         int maxVideoHeight,
+        int maxVideoFrameRate,
         int maxVideoBitrate,
         boolean exceedVideoConstraintsIfNecessary,
         boolean exceedRendererCapabilitiesIfNecessary,
@@ -695,10 +750,12 @@ private Parameters() {
       this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
       this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
       this.forceLowestBitrate = forceLowestBitrate;
+      this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
       this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
       this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
       this.maxVideoWidth = maxVideoWidth;
       this.maxVideoHeight = maxVideoHeight;
+      this.maxVideoFrameRate = maxVideoFrameRate;
       this.maxVideoBitrate = maxVideoBitrate;
       this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
       this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
@@ -716,10 +773,12 @@ private Parameters() {
       this.selectUndeterminedTextLanguage = Util.readBoolean(in);
       this.disabledTextTrackSelectionFlags = in.readInt();
       this.forceLowestBitrate = Util.readBoolean(in);
+      this.forceHighestSupportedBitrate = Util.readBoolean(in);
       this.allowMixedMimeAdaptiveness = Util.readBoolean(in);
       this.allowNonSeamlessAdaptiveness = Util.readBoolean(in);
       this.maxVideoWidth = in.readInt();
       this.maxVideoHeight = in.readInt();
+      this.maxVideoFrameRate = in.readInt();
       this.maxVideoBitrate = in.readInt();
       this.exceedVideoConstraintsIfNecessary = Util.readBoolean(in);
       this.exceedRendererCapabilitiesIfNecessary = Util.readBoolean(in);
@@ -783,10 +842,12 @@ public boolean equals(@Nullable Object obj) {
       return selectUndeterminedTextLanguage == other.selectUndeterminedTextLanguage
           && disabledTextTrackSelectionFlags == other.disabledTextTrackSelectionFlags
           && forceLowestBitrate == other.forceLowestBitrate
+          && forceHighestSupportedBitrate == other.forceHighestSupportedBitrate
           && allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
           && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
           && maxVideoWidth == other.maxVideoWidth
           && maxVideoHeight == other.maxVideoHeight
+          && maxVideoFrameRate == other.maxVideoFrameRate
           && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
           && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
           && viewportOrientationMayChange == other.viewportOrientationMayChange
@@ -805,10 +866,12 @@ public int hashCode() {
       int result = selectUndeterminedTextLanguage ? 1 : 0;
       result = 31 * result + disabledTextTrackSelectionFlags;
       result = 31 * result + (forceLowestBitrate ? 1 : 0);
+      result = 31 * result + (forceHighestSupportedBitrate ? 1 : 0);
       result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
       result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
       result = 31 * result + maxVideoWidth;
       result = 31 * result + maxVideoHeight;
+      result = 31 * result + maxVideoFrameRate;
       result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
       result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
       result = 31 * result + (viewportOrientationMayChange ? 1 : 0);
@@ -838,10 +901,12 @@ public void writeToParcel(Parcel dest, int flags) {
       Util.writeBoolean(dest, selectUndeterminedTextLanguage);
       dest.writeInt(disabledTextTrackSelectionFlags);
       Util.writeBoolean(dest, forceLowestBitrate);
+      Util.writeBoolean(dest, forceHighestSupportedBitrate);
       Util.writeBoolean(dest, allowMixedMimeAdaptiveness);
       Util.writeBoolean(dest, allowNonSeamlessAdaptiveness);
       dest.writeInt(maxVideoWidth);
       dest.writeInt(maxVideoHeight);
+      dest.writeInt(maxVideoFrameRate);
       dest.writeInt(maxVideoBitrate);
       Util.writeBoolean(dest, exceedVideoConstraintsIfNecessary);
       Util.writeBoolean(dest, exceedRendererCapabilitiesIfNecessary);
@@ -1043,23 +1108,20 @@ public SelectionOverride createFromParcel(Parcel in) {
   private static final int[] NO_TRACKS = new int[0];
   private static final int WITHIN_RENDERER_CAPABILITIES_BONUS = 1000;
 
-  private final @Nullable TrackSelection.Factory adaptiveTrackSelectionFactory;
+  private final TrackSelection.Factory adaptiveTrackSelectionFactory;
   private final AtomicReference<Parameters> parametersReference;
 
-  /**
-   * Constructs an instance that does not support adaptive track selection.
-   */
+  /** Constructs an instance that uses a default factory to create adaptive track selections. */
   public DefaultTrackSelector() {
-    this((TrackSelection.Factory) null);
+    this(new AdaptiveTrackSelection.Factory());
   }
 
   /**
-   * Constructs an instance that supports adaptive track selection. Adaptive track selections use
-   * the provided {@link BandwidthMeter} to determine which individual track should be used during
-   * playback.
-   *
-   * @param bandwidthMeter The {@link BandwidthMeter}.
+   * @deprecated Use {@link #DefaultTrackSelector()} instead. Custom bandwidth meter should be
+   *     directly passed to the player in {@link ExoPlayerFactory}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultTrackSelector(BandwidthMeter bandwidthMeter) {
     this(new AdaptiveTrackSelection.Factory(bandwidthMeter));
   }
@@ -1067,10 +1129,9 @@ public DefaultTrackSelector(BandwidthMeter bandwidthMeter) {
   /**
    * Constructs an instance that uses a factory to create adaptive track selections.
    *
-   * @param adaptiveTrackSelectionFactory A factory for adaptive {@link TrackSelection}s, or null if
-   *     the selector should not support adaptive tracks.
+   * @param adaptiveTrackSelectionFactory A factory for adaptive {@link TrackSelection}s.
    */
-  public DefaultTrackSelector(@Nullable TrackSelection.Factory adaptiveTrackSelectionFactory) {
+  public DefaultTrackSelector(TrackSelection.Factory adaptiveTrackSelectionFactory) {
     this.adaptiveTrackSelectionFactory = adaptiveTrackSelectionFactory;
     parametersReference = new AtomicReference<>(Parameters.DEFAULT);
   }
@@ -1172,7 +1233,7 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
   // MappingTrackSelector implementation.
 
   @Override
-  protected final Pair<RendererConfiguration[], TrackSelection[]>
+  protected final Pair<@NullableType RendererConfiguration[], @NullableType TrackSelection[]>
       selectTracks(
           MappedTrackInfo mappedTrackInfo,
           int[][][] rendererFormatSupports,
@@ -1180,7 +1241,7 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
           throws ExoPlaybackException {
     Parameters params = parametersReference.get();
     int rendererCount = mappedTrackInfo.getRendererCount();
-    TrackSelection[] rendererTrackSelections =
+    @NullableType TrackSelection[] rendererTrackSelections =
         selectAllTracks(
             mappedTrackInfo,
             rendererFormatSupports,
@@ -1205,7 +1266,9 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
             rendererTrackSelections[i] =
                 Assertions.checkNotNull(adaptiveTrackSelectionFactory)
                     .createTrackSelection(
-                        rendererTrackGroups.get(override.groupIndex), override.tracks);
+                        rendererTrackGroups.get(override.groupIndex),
+                        getBandwidthMeter(),
+                        override.tracks);
           }
         }
       }
@@ -1213,7 +1276,7 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
 
     // Initialize the renderer configurations to the default configuration for all renderers with
     // selections, and null otherwise.
-    RendererConfiguration[] rendererConfigurations =
+    @NullableType RendererConfiguration[] rendererConfigurations =
         new RendererConfiguration[rendererCount];
     for (int i = 0; i < rendererCount; i++) {
       boolean forceRendererDisabled = params.getRendererDisabled(i);
@@ -1253,14 +1316,14 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
    *     disabled, unless RendererCapabilities#getTrackType()} is {@link C#TRACK_TYPE_NONE}.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected TrackSelection[] selectAllTracks(
+  protected @NullableType TrackSelection[] selectAllTracks(
       MappedTrackInfo mappedTrackInfo,
       int[][][] rendererFormatSupports,
       int[] rendererMixedMimeTypeAdaptationSupports,
       Parameters params)
       throws ExoPlaybackException {
     int rendererCount = mappedTrackInfo.getRendererCount();
-    TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCount];
+    @NullableType TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCount];
 
     boolean seenVideoRendererWithMappedTracks = false;
     boolean selectedVideoTracks = false;
@@ -1280,8 +1343,10 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
       }
     }
 
-    boolean selectedAudioTracks = false;
-    boolean selectedTextTracks = false;
+    AudioTrackScore selectedAudioTrackScore = null;
+    int selectedAudioRendererIndex = C.INDEX_UNSET;
+    int selectedTextTrackScore = Integer.MIN_VALUE;
+    int selectedTextRendererIndex = C.INDEX_UNSET;
     for (int i = 0; i < rendererCount; i++) {
       int trackType = mappedTrackInfo.getRendererType(i);
       switch (trackType) {
@@ -1289,23 +1354,38 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
           // Already done. Do nothing.
           break;
         case C.TRACK_TYPE_AUDIO:
-          if (!selectedAudioTracks) {
-            rendererTrackSelections[i] =
-                selectAudioTrack(
-                    mappedTrackInfo.getTrackGroups(i),
-                    rendererFormatSupports[i],
-                    rendererMixedMimeTypeAdaptationSupports[i],
-                    params,
-                    seenVideoRendererWithMappedTracks ? null : adaptiveTrackSelectionFactory);
-            selectedAudioTracks = rendererTrackSelections[i] != null;
+          Pair<TrackSelection, AudioTrackScore> audioSelection =
+              selectAudioTrack(
+                  mappedTrackInfo.getTrackGroups(i),
+                  rendererFormatSupports[i],
+                  rendererMixedMimeTypeAdaptationSupports[i],
+                  params,
+                  seenVideoRendererWithMappedTracks ? null : adaptiveTrackSelectionFactory);
+          if (audioSelection != null
+              && (selectedAudioTrackScore == null
+                  || audioSelection.second.compareTo(selectedAudioTrackScore) > 0)) {
+            if (selectedAudioRendererIndex != C.INDEX_UNSET) {
+              // We've already made a selection for another audio renderer, but it had a lower
+              // score. Clear the selection for that renderer.
+              rendererTrackSelections[selectedAudioRendererIndex] = null;
+            }
+            rendererTrackSelections[i] = audioSelection.first;
+            selectedAudioTrackScore = audioSelection.second;
+            selectedAudioRendererIndex = i;
           }
           break;
         case C.TRACK_TYPE_TEXT:
-          if (!selectedTextTracks) {
-            rendererTrackSelections[i] =
-                selectTextTrack(
-                    mappedTrackInfo.getTrackGroups(i), rendererFormatSupports[i], params);
-            selectedTextTracks = rendererTrackSelections[i] != null;
+          Pair<TrackSelection, Integer> textSelection =
+              selectTextTrack(mappedTrackInfo.getTrackGroups(i), rendererFormatSupports[i], params);
+          if (textSelection != null && textSelection.second > selectedTextTrackScore) {
+            if (selectedTextRendererIndex != C.INDEX_UNSET) {
+              // We've already made a selection for another text renderer, but it had a lower score.
+              // Clear the selection for that renderer.
+              rendererTrackSelections[selectedTextRendererIndex] = null;
+            }
+            rendererTrackSelections[i] = textSelection.first;
+            selectedTextTrackScore = textSelection.second;
+            selectedTextRendererIndex = i;
           }
           break;
         default:
@@ -1344,14 +1424,17 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
       @Nullable TrackSelection.Factory adaptiveTrackSelectionFactory)
       throws ExoPlaybackException {
     TrackSelection selection = null;
-    if (!params.forceLowestBitrate && adaptiveTrackSelectionFactory != null) {
+    if (!params.forceHighestSupportedBitrate
+        && !params.forceLowestBitrate
+        && adaptiveTrackSelectionFactory != null) {
       selection =
           selectAdaptiveVideoTrack(
               groups,
               formatSupports,
               mixedMimeTypeAdaptationSupports,
               params,
-              adaptiveTrackSelectionFactory);
+              adaptiveTrackSelectionFactory,
+              getBandwidthMeter());
     }
     if (selection == null) {
       selection = selectFixedVideoTrack(groups, formatSupports, params);
@@ -1364,7 +1447,8 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
       int[][] formatSupport,
       int mixedMimeTypeAdaptationSupports,
       Parameters params,
-      TrackSelection.Factory adaptiveTrackSelectionFactory)
+      TrackSelection.Factory adaptiveTrackSelectionFactory,
+      BandwidthMeter bandwidthMeter)
       throws ExoPlaybackException {
     int requiredAdaptiveSupport = params.allowNonSeamlessAdaptiveness
         ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
@@ -1374,21 +1458,38 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
             && (mixedMimeTypeAdaptationSupports & requiredAdaptiveSupport) != 0;
     for (int i = 0; i < groups.length; i++) {
       TrackGroup group = groups.get(i);
-      int[] adaptiveTracks = getAdaptiveVideoTracksForGroup(group, formatSupport[i],
-          allowMixedMimeTypes, requiredAdaptiveSupport, params.maxVideoWidth, params.maxVideoHeight,
-          params.maxVideoBitrate, params.viewportWidth, params.viewportHeight,
-          params.viewportOrientationMayChange);
+      int[] adaptiveTracks =
+          getAdaptiveVideoTracksForGroup(
+              group,
+              formatSupport[i],
+              allowMixedMimeTypes,
+              requiredAdaptiveSupport,
+              params.maxVideoWidth,
+              params.maxVideoHeight,
+              params.maxVideoFrameRate,
+              params.maxVideoBitrate,
+              params.viewportWidth,
+              params.viewportHeight,
+              params.viewportOrientationMayChange);
       if (adaptiveTracks.length > 0) {
         return Assertions.checkNotNull(adaptiveTrackSelectionFactory)
-            .createTrackSelection(group, adaptiveTracks);
+            .createTrackSelection(group, bandwidthMeter, adaptiveTracks);
       }
     }
     return null;
   }
 
-  private static int[] getAdaptiveVideoTracksForGroup(TrackGroup group, int[] formatSupport,
-      boolean allowMixedMimeTypes, int requiredAdaptiveSupport, int maxVideoWidth,
-      int maxVideoHeight, int maxVideoBitrate, int viewportWidth, int viewportHeight,
+  private static int[] getAdaptiveVideoTracksForGroup(
+      TrackGroup group,
+      int[] formatSupport,
+      boolean allowMixedMimeTypes,
+      int requiredAdaptiveSupport,
+      int maxVideoWidth,
+      int maxVideoHeight,
+      int maxVideoFrameRate,
+      int maxVideoBitrate,
+      int viewportWidth,
+      int viewportHeight,
       boolean viewportOrientationMayChange) {
     if (group.length < 2) {
       return NO_TRACKS;
@@ -1403,15 +1504,23 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
     String selectedMimeType = null;
     if (!allowMixedMimeTypes) {
       // Select the mime type for which we have the most adaptive tracks.
-      HashSet<String> seenMimeTypes = new HashSet<>();
+      HashSet<@NullableType String> seenMimeTypes = new HashSet<>();
       int selectedMimeTypeTrackCount = 0;
       for (int i = 0; i < selectedTrackIndices.size(); i++) {
         int trackIndex = selectedTrackIndices.get(i);
         String sampleMimeType = group.getFormat(trackIndex).sampleMimeType;
         if (seenMimeTypes.add(sampleMimeType)) {
-          int countForMimeType = getAdaptiveVideoTrackCountForMimeType(group, formatSupport,
-              requiredAdaptiveSupport, sampleMimeType, maxVideoWidth, maxVideoHeight,
-              maxVideoBitrate, selectedTrackIndices);
+          int countForMimeType =
+              getAdaptiveVideoTrackCountForMimeType(
+                  group,
+                  formatSupport,
+                  requiredAdaptiveSupport,
+                  sampleMimeType,
+                  maxVideoWidth,
+                  maxVideoHeight,
+                  maxVideoFrameRate,
+                  maxVideoBitrate,
+                  selectedTrackIndices);
           if (countForMimeType > selectedMimeTypeTrackCount) {
             selectedMimeType = sampleMimeType;
             selectedMimeTypeTrackCount = countForMimeType;
@@ -1421,8 +1530,16 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
     }
 
     // Filter by the selected mime type.
-    filterAdaptiveVideoTrackCountForMimeType(group, formatSupport, requiredAdaptiveSupport,
-        selectedMimeType, maxVideoWidth, maxVideoHeight, maxVideoBitrate, selectedTrackIndices);
+    filterAdaptiveVideoTrackCountForMimeType(
+        group,
+        formatSupport,
+        requiredAdaptiveSupport,
+        selectedMimeType,
+        maxVideoWidth,
+        maxVideoHeight,
+        maxVideoFrameRate,
+        maxVideoBitrate,
+        selectedTrackIndices);
 
     return selectedTrackIndices.size() < 2 ? NO_TRACKS : Util.toArray(selectedTrackIndices);
   }
@@ -1434,13 +1551,20 @@ private static int getAdaptiveVideoTrackCountForMimeType(
       @Nullable String mimeType,
       int maxVideoWidth,
       int maxVideoHeight,
+      int maxVideoFrameRate,
       int maxVideoBitrate,
       List<Integer> selectedTrackIndices) {
     int adaptiveTrackCount = 0;
     for (int i = 0; i < selectedTrackIndices.size(); i++) {
       int trackIndex = selectedTrackIndices.get(i);
-      if (isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
-          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
+      if (isSupportedAdaptiveVideoTrack(
+          group.getFormat(trackIndex),
+          mimeType,
+          formatSupport[trackIndex],
+          requiredAdaptiveSupport,
+          maxVideoWidth,
+          maxVideoHeight,
+          maxVideoFrameRate,
           maxVideoBitrate)) {
         adaptiveTrackCount++;
       }
@@ -1455,12 +1579,19 @@ private static void filterAdaptiveVideoTrackCountForMimeType(
       @Nullable String mimeType,
       int maxVideoWidth,
       int maxVideoHeight,
+      int maxVideoFrameRate,
       int maxVideoBitrate,
       List<Integer> selectedTrackIndices) {
     for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
       int trackIndex = selectedTrackIndices.get(i);
-      if (!isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
-          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
+      if (!isSupportedAdaptiveVideoTrack(
+          group.getFormat(trackIndex),
+          mimeType,
+          formatSupport[trackIndex],
+          requiredAdaptiveSupport,
+          maxVideoWidth,
+          maxVideoHeight,
+          maxVideoFrameRate,
           maxVideoBitrate)) {
         selectedTrackIndices.remove(i);
       }
@@ -1474,11 +1605,14 @@ private static boolean isSupportedAdaptiveVideoTrack(
       int requiredAdaptiveSupport,
       int maxVideoWidth,
       int maxVideoHeight,
+      int maxVideoFrameRate,
       int maxVideoBitrate) {
-    return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)
+    return isSupported(formatSupport, false)
+        && ((formatSupport & requiredAdaptiveSupport) != 0)
         && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
         && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
         && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight)
+        && (format.frameRate == Format.NO_VALUE || format.frameRate <= maxVideoFrameRate)
         && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxVideoBitrate);
   }
 
@@ -1498,10 +1632,14 @@ private static boolean isSupportedAdaptiveVideoTrack(
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
-          boolean isWithinConstraints = selectedTrackIndices.contains(trackIndex)
-              && (format.width == Format.NO_VALUE || format.width <= params.maxVideoWidth)
-              && (format.height == Format.NO_VALUE || format.height <= params.maxVideoHeight)
-              && (format.bitrate == Format.NO_VALUE || format.bitrate <= params.maxVideoBitrate);
+          boolean isWithinConstraints =
+              selectedTrackIndices.contains(trackIndex)
+                  && (format.width == Format.NO_VALUE || format.width <= params.maxVideoWidth)
+                  && (format.height == Format.NO_VALUE || format.height <= params.maxVideoHeight)
+                  && (format.frameRate == Format.NO_VALUE
+                      || format.frameRate <= params.maxVideoFrameRate)
+                  && (format.bitrate == Format.NO_VALUE
+                      || format.bitrate <= params.maxVideoBitrate);
           if (!isWithinConstraints && !params.exceedVideoConstraintsIfNecessary) {
             // Track should not be selected.
             continue;
@@ -1557,10 +1695,11 @@ private static boolean isSupportedAdaptiveVideoTrack(
    * @param params The selector's current constraint parameters.
    * @param adaptiveTrackSelectionFactory A factory for generating adaptive track selections, or
    *     null if a fixed track selection is required.
-   * @return The {@link TrackSelection} for the renderer, or null if no selection was made.
+   * @return The {@link TrackSelection} and corresponding {@link AudioTrackScore}, or null if no
+   *     selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @Nullable TrackSelection selectAudioTrack(
+  protected @Nullable Pair<TrackSelection, AudioTrackScore> selectAudioTrack(
       TrackGroupArray groups,
       int[][] formatSupports,
       int mixedMimeTypeAdaptationSupports,
@@ -1593,17 +1732,27 @@ private static boolean isSupportedAdaptiveVideoTrack(
     }
 
     TrackGroup selectedGroup = groups.get(selectedGroupIndex);
-    if (!params.forceLowestBitrate && adaptiveTrackSelectionFactory != null) {
+
+    TrackSelection selection = null;
+    if (!params.forceHighestSupportedBitrate
+        && !params.forceLowestBitrate
+        && adaptiveTrackSelectionFactory != null) {
       // If the group of the track with the highest score allows it, try to enable adaptation.
       int[] adaptiveTracks =
           getAdaptiveAudioTracks(
               selectedGroup, formatSupports[selectedGroupIndex], params.allowMixedMimeAdaptiveness);
       if (adaptiveTracks.length > 0) {
-        return adaptiveTrackSelectionFactory.createTrackSelection(selectedGroup,
-            adaptiveTracks);
+        selection =
+            adaptiveTrackSelectionFactory.createTrackSelection(
+                selectedGroup, getBandwidthMeter(), adaptiveTracks);
       }
     }
-    return new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    if (selection == null) {
+      // We didn't make an adaptive selection, so make a fixed one instead.
+      selection = new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    }
+
+    return Pair.create(selection, Assertions.checkNotNull(selectedTrackScore));
   }
 
   private static int[] getAdaptiveAudioTracks(TrackGroup group, int[] formatSupport,
@@ -1668,10 +1817,11 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
    * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each mapped
    *     track, indexed by track group index and track index (in that order).
    * @param params The selector's current constraint parameters.
-   * @return The {@link TrackSelection} for the renderer, or null if no selection was made.
+   * @return The {@link TrackSelection} and corresponding track score, or null if no selection was
+   *     made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @Nullable TrackSelection selectTextTrack(
+  protected @Nullable Pair<TrackSelection, Integer> selectTextTrack(
       TrackGroupArray groups, int[][] formatSupport, Parameters params)
       throws ExoPlaybackException {
     TrackGroup selectedGroup = null;
@@ -1726,8 +1876,10 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
         }
       }
     }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    return selectedGroup == null
+        ? null
+        : Pair.create(
+            new FixedTrackSelection(selectedGroup, selectedTrackIndex), selectedTrackScore);
   }
 
   // General track selection methods.
@@ -1791,8 +1943,8 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
   private static void maybeConfigureRenderersForTunneling(
       MappedTrackInfo mappedTrackInfo,
       int[][][] renderererFormatSupports,
-      RendererConfiguration[] rendererConfigurations,
-      TrackSelection[] trackSelections,
+      @NullableType RendererConfiguration[] rendererConfigurations,
+      @NullableType TrackSelection[] trackSelections,
       int tunnelingAudioSessionId) {
     if (tunnelingAudioSessionId == C.AUDIO_SESSION_ID_UNSET) {
       return;
@@ -1988,12 +2140,9 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
     }
   }
 
-  /**
-   * A representation of how well a track fits with our track selection {@link Parameters}.
-   *
-   * <p>This is used to rank different audio tracks relatively with each other.
-   */
-  private static final class AudioTrackScore implements Comparable<AudioTrackScore> {
+  /** Represents how well an audio track matches the selection {@link Parameters}. */
+  protected static final class AudioTrackScore implements Comparable<AudioTrackScore> {
+
     private final Parameters parameters;
     private final int withinRendererCapabilitiesScore;
     private final int matchLanguageScore;
@@ -2013,14 +2162,14 @@ public AudioTrackScore(Format format, Parameters parameters, int formatSupport)
     }
 
     /**
-     * Compares the score of the current track format with another {@link AudioTrackScore}.
+     * Compares this score with another.
      *
      * @param other The other score to compare to.
      * @return A positive integer if this score is better than the other. Zero if they are equal. A
      *     negative integer if this score is worse than the other.
      */
     @Override
-    public int compareTo(AudioTrackScore other) {
+    public int compareTo(@NonNull AudioTrackScore other) {
       if (this.withinRendererCapabilitiesScore != other.withinRendererCapabilitiesScore) {
         return compareInts(this.withinRendererCapabilitiesScore,
             other.withinRendererCapabilitiesScore);
@@ -2042,35 +2191,6 @@ public int compareTo(AudioTrackScore other) {
         return resultSign * compareInts(this.bitrate, other.bitrate);
       }
     }
-
-    @Override
-    public boolean equals(@Nullable Object o) {
-      if (this == o) {
-        return true;
-      }
-      if (o == null || getClass() != o.getClass()) {
-        return false;
-      }
-
-      AudioTrackScore that = (AudioTrackScore) o;
-
-      return withinRendererCapabilitiesScore == that.withinRendererCapabilitiesScore
-          && matchLanguageScore == that.matchLanguageScore
-          && defaultSelectionFlagScore == that.defaultSelectionFlagScore
-          && channelCount == that.channelCount && sampleRate == that.sampleRate
-          && bitrate == that.bitrate;
-    }
-
-    @Override
-    public int hashCode() {
-      int result = withinRendererCapabilitiesScore;
-      result = 31 * result + matchLanguageScore;
-      result = 31 * result + defaultSelectionFlagScore;
-      result = 31 * result + channelCount;
-      result = 31 * result + sampleRate;
-      result = 31 * result + bitrate;
-      return result;
-    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
index 2aecf624da..7755e437ce 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
@@ -18,7 +18,11 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Assertions;
+import java.util.List;
 
 /**
  * A {@link TrackSelection} consisting of a single track.
@@ -26,8 +30,12 @@
 public final class FixedTrackSelection extends BaseTrackSelection {
 
   /**
-   * Factory for {@link FixedTrackSelection} instances.
+   * @deprecated Don't use as adaptive track selection factory as it will throw when multiple tracks
+   *     are selected. If you would like to disable adaptive selection in {@link
+   *     DefaultTrackSelector}, enable the {@link
+   *     DefaultTrackSelector.Parameters#forceHighestSupportedBitrate} flag instead.
    */
+  @Deprecated
   public static final class Factory implements TrackSelection.Factory {
 
     private final int reason;
@@ -48,7 +56,8 @@ public Factory(int reason, @Nullable Object data) {
     }
 
     @Override
-    public FixedTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+    public FixedTrackSelection createTrackSelection(
+        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
       Assertions.checkArgument(tracks.length == 1);
       return new FixedTrackSelection(group, tracks[0], reason, data);
     }
@@ -78,8 +87,12 @@ public FixedTrackSelection(TrackGroup group, int track, int reason, @Nullable Ob
   }
 
   @Override
-  public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
-      long availableDurationUs) {
+  public void updateSelectedTrack(
+      long playbackPositionUs,
+      long bufferedDurationUs,
+      long availableDurationUs,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] mediaChunkIterators) {
     // Do nothing.
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index eb855ea0c4..59a4f96fb0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -26,9 +26,11 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * Base class for {@link TrackSelector}s that first establish a mapping between {@link TrackGroup}s
@@ -42,7 +44,12 @@
    */
   public static final class MappedTrackInfo {
 
-    /** Levels of renderer support. Higher numerical values indicate higher levels of support. */
+    /**
+     * Levels of renderer support. Higher numerical values indicate higher levels of support. One of
+     * {@link #RENDERER_SUPPORT_NO_TRACKS}, {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS}, {@link
+     * #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS} or {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS}.
+     */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
       RENDERER_SUPPORT_NO_TRACKS,
@@ -94,6 +101,7 @@
      *     each mapped track, indexed by renderer, track group and track (in that order).
      * @param unmappedTrackGroups {@link TrackGroup}s not mapped to any renderer.
      */
+    @SuppressWarnings("deprecation")
     /* package */ MappedTrackInfo(
         int[] rendererTrackTypes,
         TrackGroupArray[] rendererTrackGroups,
@@ -382,7 +390,7 @@ public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCap
             rendererFormatSupports,
             unmappedTrackGroupArray);
 
-    Pair<RendererConfiguration[], TrackSelection[]> result =
+    Pair<@NullableType RendererConfiguration[], @NullableType TrackSelection[]> result =
         selectTracks(
             mappedTrackInfo, rendererFormatSupports, rendererMixedMimeTypeAdaptationSupports);
     return new TrackSelectorResult(result.first, result.second, mappedTrackInfo);
@@ -402,7 +410,7 @@ public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCap
    *     RendererCapabilities#getTrackType()} is {@link C#TRACK_TYPE_NONE}.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected abstract Pair<RendererConfiguration[], TrackSelection[]>
+  protected abstract Pair<@NullableType RendererConfiguration[], @NullableType TrackSelection[]>
       selectTracks(
           MappedTrackInfo mappedTrackInfo,
           int[][][] rendererFormatSupports,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
index e1bdc73986..e3c643670b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
@@ -19,6 +19,10 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import java.util.List;
 import java.util.Random;
 
 /**
@@ -45,7 +49,8 @@ public Factory(int seed) {
     }
 
     @Override
-    public RandomTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+    public RandomTrackSelection createTrackSelection(
+        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
       return new RandomTrackSelection(group, tracks, random);
     }
   }
@@ -88,8 +93,12 @@ public RandomTrackSelection(TrackGroup group, int[] tracks, Random random) {
   }
 
   @Override
-  public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
-      long availableDurationUs) {
+  public void updateSelectedTrack(
+      long playbackPositionUs,
+      long bufferedDurationUs,
+      long availableDurationUs,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] mediaChunkIterators) {
     // Count the number of non-blacklisted formats.
     long nowMs = SystemClock.elapsedRealtime();
     int nonBlacklistedFormatCount = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
index ee0a397a8d..78d052ac3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
@@ -20,14 +20,17 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import java.util.List;
 
 /**
- * A track selection consisting of a static subset of selected tracks belonging to a
- * {@link TrackGroup}, and a possibly varying individual selected track from the subset.
- * <p>
- * Tracks belonging to the subset are exposed in decreasing bandwidth order. The individual selected
- * track may change as a result of calling {@link #updateSelectedTrack(long, long, long)}.
+ * A track selection consisting of a static subset of selected tracks belonging to a {@link
+ * TrackGroup}, and a possibly varying individual selected track from the subset.
+ *
+ * <p>Tracks belonging to the subset are exposed in decreasing bandwidth order. The individual
+ * selected track may change as a result of calling {@link #updateSelectedTrack(long, long, long,
+ * List, MediaChunkIterator[])}.
  */
 public interface TrackSelection {
 
@@ -40,12 +43,13 @@
      * Creates a new selection.
      *
      * @param group The {@link TrackGroup}. Must not be null.
+     * @param bandwidthMeter A {@link BandwidthMeter} which can be used to select tracks.
      * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
      *     null or empty. May be in any order.
      * @return The created selection.
      */
-    TrackSelection createTrackSelection(TrackGroup group, int... tracks);
-
+    TrackSelection createTrackSelection(
+        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks);
   }
 
   /**
@@ -146,25 +150,47 @@
   void onPlaybackSpeed(float speed);
 
   /**
-   * Updates the selected track.
-   * <p>
-   * This method may only be called when the selection is enabled.
+   * @deprecated Use and implement {@link #updateSelectedTrack(long, long, long, List,
+   *     MediaChunkIterator[])} instead.
+   */
+  @Deprecated
+  default void updateSelectedTrack(
+      long playbackPositionUs, long bufferedDurationUs, long availableDurationUs) {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * Updates the selected track for sources that load media in discrete {@link MediaChunk}s.
+   *
+   * <p>This method may only be called when the selection is enabled.
    *
    * @param playbackPositionUs The current playback position in microseconds. If playback of the
    *     period to which this track selection belongs has not yet started, the value will be the
    *     starting position in the period minus the duration of any media in previous periods still
    *     to be played.
    * @param bufferedDurationUs The duration of media currently buffered from the current playback
-   *     position, in microseconds. Note that the next load position can be calculated as
-   *     {@code (playbackPositionUs + bufferedDurationUs)}.
+   *     position, in microseconds. Note that the next load position can be calculated as {@code
+   *     (playbackPositionUs + bufferedDurationUs)}.
    * @param availableDurationUs The duration of media available for buffering from the current
-   *     playback position, in microseconds, or {@link C#TIME_UNSET} if media can be buffered
-   *     to the end of the current period. Note that if not set to {@link C#TIME_UNSET}, the
-   *     position up to which media is available for buffering can be calculated as
-   *     {@code (playbackPositionUs + availableDurationUs)}.
-   */
-  void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
-      long availableDurationUs);
+   *     playback position, in microseconds, or {@link C#TIME_UNSET} if media can be buffered to the
+   *     end of the current period. Note that if not set to {@link C#TIME_UNSET}, the position up to
+   *     which media is available for buffering can be calculated as {@code (playbackPositionUs +
+   *     availableDurationUs)}.
+   * @param queue The queue of already buffered {@link MediaChunk}s. Must not be modified.
+   * @param mediaChunkIterators An array of {@link MediaChunkIterator}s providing information about
+   *     the sequence of upcoming media chunks for each track in the selection. All iterators start
+   *     from the media chunk which will be loaded next if the respective track is selected. Note
+   *     that this information may not be available for all tracks, and so some iterators may be
+   *     empty.
+   */
+  default void updateSelectedTrack(
+      long playbackPositionUs,
+      long bufferedDurationUs,
+      long availableDurationUs,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] mediaChunkIterators) {
+    updateSelectedTrack(playbackPositionUs, bufferedDurationUs, availableDurationUs);
+  }
 
   /**
    * May be called periodically by sources that load media in discrete {@link MediaChunk}s and
@@ -188,12 +214,13 @@ void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
 
   /**
    * Attempts to blacklist the track at the specified index in the selection, making it ineligible
-   * for selection by calls to {@link #updateSelectedTrack(long, long, long)} for the specified
-   * period of time. Blacklisting will fail if all other tracks are currently blacklisted. If
-   * blacklisting the currently selected track, note that it will remain selected until the next
-   * call to {@link #updateSelectedTrack(long, long, long)}.
-   * <p>
-   * This method may only be called when the selection is enabled.
+   * for selection by calls to {@link #updateSelectedTrack(long, long, long, List,
+   * MediaChunkIterator[])} for the specified period of time. Blacklisting will fail if all other
+   * tracks are currently blacklisted. If blacklisting the currently selected track, note that it
+   * will remain selected until the next call to {@link #updateSelectedTrack(long, long, long, List,
+   * MediaChunkIterator[])}.
+   *
+   * <p>This method may only be called when the selection is enabled.
    *
    * @param index The index of the track in the selection.
    * @param blacklistDurationMs The duration of time for which the track should be blacklisted, in
@@ -201,5 +228,4 @@ void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
    * @return Whether blacklisting was successful.
    */
   boolean blacklist(int index, long blacklistDurationMs);
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
index 071293566d..48151002be 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.Nullable;
 import java.util.Arrays;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** An array of {@link TrackSelection}s. */
 public final class TrackSelectionArray {
@@ -24,13 +25,13 @@
   /** The length of this array. */
   public final int length;
 
-  private final TrackSelection[] trackSelections;
+  private final @NullableType TrackSelection[] trackSelections;
 
   // Lazily initialized hashcode.
   private int hashCode;
 
   /** @param trackSelections The selections. Must not be null, but may contain null elements. */
-  public TrackSelectionArray(TrackSelection... trackSelections) {
+  public TrackSelectionArray(@NullableType TrackSelection... trackSelections) {
     this.trackSelections = trackSelections;
     this.length = trackSelections.length;
   }
@@ -46,7 +47,7 @@ public TrackSelectionArray(TrackSelection... trackSelections) {
   }
 
   /** Returns the selections in a newly allocated array. */
-  public TrackSelection[] getAll() {
+  public @NullableType TrackSelection[] getAll() {
     return trackSelections.clone();
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index 0c229527a0..3bb603318f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -22,6 +22,8 @@
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.util.Assertions;
 
 /**
  * The component of an {@link ExoPlayer} responsible for selecting tracks to be consumed by each of
@@ -29,48 +31,52 @@
  * suitable for most use cases.
  *
  * <h3>Interactions with the player</h3>
+ *
  * The following interactions occur between the player and its track selector during playback.
+ *
  * <p>
+ *
  * <ul>
- *     <li>When the player is created it will initialize the track selector by calling
- *     {@link #init(InvalidationListener)}.</li>
- *     <li>When the player needs to make a track selection it will call
- *     {@link #selectTracks(RendererCapabilities[], TrackGroupArray)}. This typically occurs at the
- *     start of playback, when the player starts to buffer a new period of the media being played,
- *     and when the track selector invalidates its previous selections.</li>
- *     <li>The player may perform a track selection well in advance of the selected tracks becoming
- *     active, where active is defined to mean that the renderers are actually consuming media
- *     corresponding to the selection that was made. For example when playing media containing
- *     multiple periods, the track selection for a period is made when the player starts to buffer
- *     that period. Hence if the player's buffering policy is to maintain a 30 second buffer, the
- *     selection will occur approximately 30 seconds in advance of it becoming active. In fact the
- *     selection may never become active, for example if the user seeks to some other period of the
- *     media during the 30 second gap. The player indicates to the track selector when a selection
- *     it has previously made becomes active by calling {@link #onSelectionActivated(Object)}.</li>
- *     <li>If the track selector wishes to indicate to the player that selections it has previously
- *     made are invalid, it can do so by calling
- *     {@link InvalidationListener#onTrackSelectionsInvalidated()} on the
- *     {@link InvalidationListener} that was passed to {@link #init(InvalidationListener)}. A
- *     track selector may wish to do this if its configuration has changed, for example if it now
- *     wishes to prefer audio tracks in a particular language. This will trigger the player to make
- *     new track selections. Note that the player will have to re-buffer in the case that the new
- *     track selection for the currently playing period differs from the one that was invalidated.
- *     </li>
+ *   <li>When the player is created it will initialize the track selector by calling {@link
+ *       #init(InvalidationListener, BandwidthMeter)}.
+ *   <li>When the player needs to make a track selection it will call {@link
+ *       #selectTracks(RendererCapabilities[], TrackGroupArray)}. This typically occurs at the start
+ *       of playback, when the player starts to buffer a new period of the media being played, and
+ *       when the track selector invalidates its previous selections.
+ *   <li>The player may perform a track selection well in advance of the selected tracks becoming
+ *       active, where active is defined to mean that the renderers are actually consuming media
+ *       corresponding to the selection that was made. For example when playing media containing
+ *       multiple periods, the track selection for a period is made when the player starts to buffer
+ *       that period. Hence if the player's buffering policy is to maintain a 30 second buffer, the
+ *       selection will occur approximately 30 seconds in advance of it becoming active. In fact the
+ *       selection may never become active, for example if the user seeks to some other period of
+ *       the media during the 30 second gap. The player indicates to the track selector when a
+ *       selection it has previously made becomes active by calling {@link
+ *       #onSelectionActivated(Object)}.
+ *   <li>If the track selector wishes to indicate to the player that selections it has previously
+ *       made are invalid, it can do so by calling {@link
+ *       InvalidationListener#onTrackSelectionsInvalidated()} on the {@link InvalidationListener}
+ *       that was passed to {@link #init(InvalidationListener, BandwidthMeter)}. A track selector
+ *       may wish to do this if its configuration has changed, for example if it now wishes to
+ *       prefer audio tracks in a particular language. This will trigger the player to make new
+ *       track selections. Note that the player will have to re-buffer in the case that the new
+ *       track selection for the currently playing period differs from the one that was invalidated.
  * </ul>
  *
  * <h3>Renderer configuration</h3>
- * The {@link TrackSelectorResult} returned by
- * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} contains not only
- * {@link TrackSelection}s for each renderer, but also {@link RendererConfiguration}s defining
- * configuration parameters that the renderers should apply when consuming the corresponding media.
- * Whilst it may seem counter-intuitive for a track selector to also specify renderer configuration
- * information, in practice the two are tightly bound together. It may only be possible to play a
- * certain combination tracks if the renderers are configured in a particular way. Equally, it may
- * only be possible to configure renderers in a particular way if certain tracks are selected. Hence
- * it makes sense to determined the track selection and corresponding renderer configurations in a
- * single step.
+ *
+ * The {@link TrackSelectorResult} returned by {@link #selectTracks(RendererCapabilities[],
+ * TrackGroupArray)} contains not only {@link TrackSelection}s for each renderer, but also {@link
+ * RendererConfiguration}s defining configuration parameters that the renderers should apply when
+ * consuming the corresponding media. Whilst it may seem counter-intuitive for a track selector to
+ * also specify renderer configuration information, in practice the two are tightly bound together.
+ * It may only be possible to play a certain combination tracks if the renderers are configured in a
+ * particular way. Equally, it may only be possible to configure renderers in a particular way if
+ * certain tracks are selected. Hence it makes sense to determined the track selection and
+ * corresponding renderer configurations in a single step.
  *
  * <h3>Threading model</h3>
+ *
  * All calls made by the player into the track selector are on the player's internal playback
  * thread. The track selector may call {@link InvalidationListener#onTrackSelectionsInvalidated()}
  * from any thread.
@@ -91,15 +97,18 @@
   }
 
   private @Nullable InvalidationListener listener;
+  private @Nullable BandwidthMeter bandwidthMeter;
 
   /**
    * Called by the player to initialize the selector.
    *
    * @param listener An invalidation listener that the selector can call to indicate that selections
    *     it has previously made are no longer valid.
+   * @param bandwidthMeter A bandwidth meter which can be used by track selections to select tracks.
    */
-  public final void init(InvalidationListener listener) {
+  public final void init(InvalidationListener listener, BandwidthMeter bandwidthMeter) {
     this.listener = listener;
+    this.bandwidthMeter = bandwidthMeter;
   }
 
   /**
@@ -132,4 +141,11 @@ protected final void invalidate() {
     }
   }
 
+  /**
+   * Returns a bandwidth meter which can be used by track selections to select tracks. Must only be
+   * called after {@link #init(InvalidationListener, BandwidthMeter)} has been called.
+   */
+  protected final BandwidthMeter getBandwidthMeter() {
+    return Assertions.checkNotNull(bandwidthMeter);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
index 941b90f8a9..f1136f0be5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.util.Util;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * The result of a {@link TrackSelector} operation.
@@ -29,7 +30,7 @@
    * A {@link RendererConfiguration} for each renderer. A null entry indicates the corresponding
    * renderer should be disabled.
    */
-  public final RendererConfiguration[] rendererConfigurations;
+  public final @NullableType RendererConfiguration[] rendererConfigurations;
   /**
    * A {@link TrackSelectionArray} containing the track selection for each renderer.
    */
@@ -48,8 +49,8 @@
    *     TrackSelector#onSelectionActivated(Object)} should the selection be activated.
    */
   public TrackSelectorResult(
-      RendererConfiguration[] rendererConfigurations,
-      TrackSelection[] selections,
+      @NullableType RendererConfiguration[] rendererConfigurations,
+      @NullableType TrackSelection[] selections,
       Object info) {
     this.rendererConfigurations = rendererConfigurations;
     this.selections = new TrackSelectionArray(selections);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
index d0b18bb765..16c27ccde8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
@@ -18,15 +18,14 @@
 import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * A {@link DataSource} for reading from a local asset.
- */
-public final class AssetDataSource implements DataSource {
+/** A {@link DataSource} for reading from a local asset. */
+public final class AssetDataSource extends BaseDataSource {
 
   /**
    * Thrown when an {@link IOException} is encountered reading a local asset.
@@ -40,27 +39,30 @@ public AssetDataSourceException(IOException cause) {
   }
 
   private final AssetManager assetManager;
-  private final TransferListener<? super AssetDataSource> listener;
 
-  private Uri uri;
-  private InputStream inputStream;
+  private @Nullable Uri uri;
+  private @Nullable InputStream inputStream;
   private long bytesRemaining;
   private boolean opened;
 
-  /**
-   * @param context A context.
-   */
+  /** @param context A context. */
   public AssetDataSource(Context context) {
-    this(context, null);
+    super(/* isNetwork= */ false);
+    this.assetManager = context.getAssets();
   }
 
   /**
    * @param context A context.
    * @param listener An optional listener.
+   * @deprecated Use {@link #AssetDataSource(Context)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public AssetDataSource(Context context, TransferListener<? super AssetDataSource> listener) {
-    this.assetManager = context.getAssets();
-    this.listener = listener;
+  @Deprecated
+  public AssetDataSource(Context context, @Nullable TransferListener listener) {
+    this(context);
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
@@ -73,6 +75,7 @@ public long open(DataSpec dataSpec) throws AssetDataSourceException {
       } else if (path.startsWith("/")) {
         path = path.substring(1);
       }
+      transferInitializing(dataSpec);
       inputStream = assetManager.open(path, AssetManager.ACCESS_RANDOM);
       long skipped = inputStream.skip(dataSpec.position);
       if (skipped < dataSpec.position) {
@@ -96,9 +99,7 @@ public long open(DataSpec dataSpec) throws AssetDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
     return bytesRemaining;
   }
 
@@ -129,14 +130,12 @@ public int read(byte[] buffer, int offset, int readLength) throws AssetDataSourc
     if (bytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining -= bytesRead;
     }
-    if (listener != null) {
-      listener.onBytesTransferred(this, bytesRead);
-    }
+    bytesTransferred(bytesRead);
     return bytesRead;
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return uri;
   }
 
@@ -153,9 +152,7 @@ public void close() throws AssetDataSourceException {
       inputStream = null;
       if (opened) {
         opened = false;
-        if (listener != null) {
-          listener.onTransferEnd(this);
-        }
+        transferEnded();
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
index 0a3fb967a8..470937f02f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.os.Handler;
+import android.support.annotation.Nullable;
+
 /**
  * Provides estimates of the currently available bandwidth.
  */
@@ -40,4 +43,26 @@
 
   /** Returns the estimated bandwidth in bits/sec. */
   long getBitrateEstimate();
+
+  /**
+   * Returns the {@link TransferListener} that this instance uses to gather bandwidth information
+   * from data transfers. May be null, if no transfer listener is used.
+   */
+  @Nullable
+  TransferListener getTransferListener();
+
+  /**
+   * Adds an {@link EventListener} to be informed of bandwidth samples.
+   *
+   * @param eventHandler A handler for events.
+   * @param eventListener A listener of events.
+   */
+  void addEventListener(Handler eventHandler, EventListener eventListener);
+
+  /**
+   * Removes an {@link EventListener}.
+   *
+   * @param eventListener The listener to be removed.
+   */
+  void removeEventListener(EventListener eventListener);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java
new file mode 100644
index 0000000000..5ed2e33d2b
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
+import android.support.annotation.Nullable;
+import java.util.ArrayList;
+
+/**
+ * Base {@link DataSource} implementation to keep a list of {@link TransferListener}s.
+ *
+ * <p>Subclasses must call {@link #transferInitializing(DataSpec)}, {@link
+ * #transferStarted(DataSpec)}, {@link #bytesTransferred(int)}, and {@link #transferEnded()} to
+ * inform listeners of data transfers.
+ */
+public abstract class BaseDataSource implements DataSource {
+
+  private final boolean isNetwork;
+  private final ArrayList<TransferListener> listeners;
+
+  private int listenerCount;
+  private @Nullable DataSpec dataSpec;
+
+  /**
+   * Creates base data source.
+   *
+   * @param isNetwork Whether the data source loads data through a network.
+   */
+  protected BaseDataSource(boolean isNetwork) {
+    this.isNetwork = isNetwork;
+    this.listeners = new ArrayList<>(/* initialCapacity= */ 1);
+  }
+
+  @Override
+  public final void addTransferListener(TransferListener transferListener) {
+    if (!listeners.contains(transferListener)) {
+      listeners.add(transferListener);
+      listenerCount++;
+    }
+  }
+
+  /**
+   * Notifies listeners that data transfer for the specified {@link DataSpec} is being initialized.
+   *
+   * @param dataSpec {@link DataSpec} describing the data for initializing transfer.
+   */
+  protected final void transferInitializing(DataSpec dataSpec) {
+    for (int i = 0; i < listenerCount; i++) {
+      listeners.get(i).onTransferInitializing(/* source= */ this, dataSpec, isNetwork);
+    }
+  }
+
+  /**
+   * Notifies listeners that data transfer for the specified {@link DataSpec} started.
+   *
+   * @param dataSpec {@link DataSpec} describing the data being transferred.
+   */
+  protected final void transferStarted(DataSpec dataSpec) {
+    this.dataSpec = dataSpec;
+    for (int i = 0; i < listenerCount; i++) {
+      listeners.get(i).onTransferStart(/* source= */ this, dataSpec, isNetwork);
+    }
+  }
+
+  /**
+   * Notifies listeners that bytes were transferred.
+   *
+   * @param bytesTransferred The number of bytes transferred since the previous call to this method
+   *     (or if the first call, since the transfer was started).
+   */
+  protected final void bytesTransferred(int bytesTransferred) {
+    DataSpec dataSpec = castNonNull(this.dataSpec);
+    for (int i = 0; i < listenerCount; i++) {
+      listeners
+          .get(i)
+          .onBytesTransferred(/* source= */ this, dataSpec, isNetwork, bytesTransferred);
+    }
+  }
+
+  /** Notifies listeners that a transfer ended. */
+  protected final void transferEnded() {
+    DataSpec dataSpec = castNonNull(this.dataSpec);
+    for (int i = 0; i < listenerCount; i++) {
+      listeners.get(i).onTransferEnd(/* source= */ this, dataSpec, isNetwork);
+    }
+    this.dataSpec = null;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
index e5311e783b..16637b4052 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
@@ -16,25 +16,26 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 
-/**
- * A {@link DataSource} for reading from a byte array.
- */
-public final class ByteArrayDataSource implements DataSource {
+/** A {@link DataSource} for reading from a byte array. */
+public final class ByteArrayDataSource extends BaseDataSource {
 
   private final byte[] data;
 
-  private Uri uri;
+  private @Nullable Uri uri;
   private int readPosition;
   private int bytesRemaining;
+  private boolean opened;
 
   /**
    * @param data The data to be read.
    */
   public ByteArrayDataSource(byte[] data) {
+    super(/* isNetwork= */ false);
     Assertions.checkNotNull(data);
     Assertions.checkArgument(data.length > 0);
     this.data = data;
@@ -43,6 +44,7 @@ public ByteArrayDataSource(byte[] data) {
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     uri = dataSpec.uri;
+    transferInitializing(dataSpec);
     readPosition = (int) dataSpec.position;
     bytesRemaining = (int) ((dataSpec.length == C.LENGTH_UNSET)
         ? (data.length - dataSpec.position) : dataSpec.length);
@@ -50,6 +52,8 @@ public long open(DataSpec dataSpec) throws IOException {
       throw new IOException("Unsatisfiable range: [" + readPosition + ", " + dataSpec.length
           + "], length: " + data.length);
     }
+    opened = true;
+    transferStarted(dataSpec);
     return bytesRemaining;
   }
 
@@ -65,16 +69,21 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
     System.arraycopy(data, readPosition, buffer, offset, readLength);
     readPosition += readLength;
     bytesRemaining -= readLength;
+    bytesTransferred(readLength);
     return readLength;
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return uri;
   }
 
   @Override
   public void close() throws IOException {
+    if (opened) {
+      opened = false;
+      transferEnded();
+    }
     uri = null;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
index 87642e0eba..30051a53e6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
 import java.io.FileInputStream;
@@ -26,10 +27,8 @@
 import java.io.IOException;
 import java.nio.channels.FileChannel;
 
-/**
- * A {@link DataSource} for reading from a content URI.
- */
-public final class ContentDataSource implements DataSource {
+/** A {@link DataSource} for reading from a content URI. */
+public final class ContentDataSource extends BaseDataSource {
 
   /**
    * Thrown when an {@link IOException} is encountered reading from a content URI.
@@ -43,11 +42,10 @@ public ContentDataSourceException(IOException cause) {
   }
 
   private final ContentResolver resolver;
-  private final TransferListener<? super ContentDataSource> listener;
 
-  private Uri uri;
-  private AssetFileDescriptor assetFileDescriptor;
-  private FileInputStream inputStream;
+  private @Nullable Uri uri;
+  private @Nullable AssetFileDescriptor assetFileDescriptor;
+  private @Nullable FileInputStream inputStream;
   private long bytesRemaining;
   private boolean opened;
 
@@ -55,22 +53,29 @@ public ContentDataSourceException(IOException cause) {
    * @param context A context.
    */
   public ContentDataSource(Context context) {
-    this(context, null);
+    super(/* isNetwork= */ false);
+    this.resolver = context.getContentResolver();
   }
 
   /**
    * @param context A context.
    * @param listener An optional listener.
+   * @deprecated Use {@link #ContentDataSource(Context)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public ContentDataSource(Context context, TransferListener<? super ContentDataSource> listener) {
-    this.resolver = context.getContentResolver();
-    this.listener = listener;
+  @Deprecated
+  public ContentDataSource(Context context, @Nullable TransferListener listener) {
+    this(context);
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
   public long open(DataSpec dataSpec) throws ContentDataSourceException {
     try {
       uri = dataSpec.uri;
+      transferInitializing(dataSpec);
       assetFileDescriptor = resolver.openAssetFileDescriptor(uri, "r");
       if (assetFileDescriptor == null) {
         throw new FileNotFoundException("Could not open file descriptor for: " + uri);
@@ -102,9 +107,7 @@ public long open(DataSpec dataSpec) throws ContentDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
 
     return bytesRemaining;
   }
@@ -136,17 +139,16 @@ public int read(byte[] buffer, int offset, int readLength) throws ContentDataSou
     if (bytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining -= bytesRead;
     }
-    if (listener != null) {
-      listener.onBytesTransferred(this, bytesRead);
-    }
+    bytesTransferred(bytesRead);
     return bytesRead;
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return uri;
   }
 
+  @SuppressWarnings("Finally")
   @Override
   public void close() throws ContentDataSourceException {
     uri = null;
@@ -168,9 +170,7 @@ public void close() throws ContentDataSourceException {
         assetFileDescriptor = null;
         if (opened) {
           opened = false;
-          if (listener != null) {
-            listener.onTransferEnd(this);
-          }
+          transferEnded();
         }
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
index 33d67f3f46..2d2a7587f7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.util.Base64;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
@@ -23,19 +24,22 @@
 import java.io.IOException;
 import java.net.URLDecoder;
 
-/**
- * A {@link DataSource} for reading data URLs, as defined by RFC 2397.
- */
-public final class DataSchemeDataSource implements DataSource {
+/** A {@link DataSource} for reading data URLs, as defined by RFC 2397. */
+public final class DataSchemeDataSource extends BaseDataSource {
 
   public static final String SCHEME_DATA = "data";
 
-  private DataSpec dataSpec;
+  private @Nullable DataSpec dataSpec;
   private int bytesRead;
-  private byte[] data;
+  private @Nullable byte[] data;
+
+  public DataSchemeDataSource() {
+    super(/* isNetwork= */ false);
+  }
 
   @Override
   public long open(DataSpec dataSpec) throws IOException {
+    transferInitializing(dataSpec);
     this.dataSpec = dataSpec;
     Uri uri = dataSpec.uri;
     String scheme = uri.getScheme();
@@ -55,8 +59,9 @@ public long open(DataSpec dataSpec) throws IOException {
       }
     } else {
       // TODO: Add support for other charsets.
-      data = URLDecoder.decode(dataString, C.ASCII_NAME).getBytes();
+      data = Util.getUtf8Bytes(URLDecoder.decode(dataString, C.ASCII_NAME));
     }
+    transferStarted(dataSpec);
     return data.length;
   }
 
@@ -72,18 +77,22 @@ public int read(byte[] buffer, int offset, int readLength) {
     readLength = Math.min(readLength, remainingBytes);
     System.arraycopy(data, bytesRead, buffer, offset, readLength);
     bytesRead += readLength;
+    bytesTransferred(readLength);
     return readLength;
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return dataSpec != null ? dataSpec.uri : null;
   }
 
   @Override
   public void close() throws IOException {
+    if (data != null) {
+      data = null;
+      transferEnded();
+    }
     dataSpec = null;
-    data = null;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index ce3230fa43..c759499577 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -19,6 +19,9 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A component from which streams of data can be read.
@@ -34,9 +37,15 @@
      * Creates a {@link DataSource} instance.
      */
     DataSource createDataSource();
-
   }
 
+  /**
+   * Adds a {@link TransferListener} to listen to data transfers. This method is not thread-safe.
+   *
+   * @param transferListener A {@link TransferListener}.
+   */
+  void addTransferListener(TransferListener transferListener);
+
   /**
    * Opens the source to read the specified data.
    * <p>
@@ -82,6 +91,14 @@
    */
   @Nullable Uri getUri();
 
+  /**
+   * When the source is open, returns the response headers associated with the last {@link #open}
+   * call. Otherwise, returns an empty map.
+   */
+  default Map<String, List<String>> getResponseHeaders() {
+    return Collections.emptyMap();
+  }
+
   /**
    * Closes the source.
    * <p>
@@ -91,5 +108,4 @@
    * @throws IOException If an error occurs closing the source.
    */
   void close() throws IOException;
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index ad7a9d0147..4a4cc021f4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -20,6 +20,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -30,10 +31,14 @@
 public final class DataSpec {
 
   /**
-   * The flags that apply to any request for data.
+   * The flags that apply to any request for data. Possible flag values are {@link #FLAG_ALLOW_GZIP}
+   * and {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP, FLAG_ALLOW_CACHING_UNKNOWN_LENGTH})
+  @IntDef(
+      flag = true,
+      value = {FLAG_ALLOW_GZIP, FLAG_ALLOW_CACHING_UNKNOWN_LENGTH})
   public @interface Flags {}
   /**
    * Permits an underlying network stack to request that the server use gzip compression.
@@ -46,22 +51,46 @@
    * {@link DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNSET}. The data read from
    * {@link DataSource#read(byte[], int, int)} will be the decompressed data.
    */
-  public static final int FLAG_ALLOW_GZIP = 1 << 0;
+  public static final int FLAG_ALLOW_GZIP = 1;
 
   /**
    * Permits content to be cached even if its length can not be resolved. Typically this's the case
    * for progressive live streams and when {@link #FLAG_ALLOW_GZIP} is used.
    */
-  public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1;
+  public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1; // 2
+
+  /**
+   * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
+   * #HTTP_METHOD_GET}, {@link #HTTP_METHOD_POST} or {@link #HTTP_METHOD_HEAD}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({HTTP_METHOD_GET, HTTP_METHOD_POST, HTTP_METHOD_HEAD})
+  public @interface HttpMethod {}
+
+  public static final int HTTP_METHOD_GET = 1;
+  public static final int HTTP_METHOD_POST = 2;
+  public static final int HTTP_METHOD_HEAD = 3;
 
   /**
    * The source from which data should be read.
    */
   public final Uri uri;
+
   /**
-   * Body for a POST request, null otherwise.
+   * The HTTP method, which will be used by {@link HttpDataSource} when requesting this DataSpec.
+   * This value will be ignored by non-http {@link DataSource}s.
    */
-  public final @Nullable byte[] postBody;
+  public final @HttpMethod int httpMethod;
+
+  /**
+   * The HTTP body, null otherwise. If the body is non-null, then httpBody.length will be non-zero.
+   */
+  public final @Nullable byte[] httpBody;
+
+  /** @deprecated Use {@link #httpBody} instead. */
+  @Deprecated public final @Nullable byte[] postBody;
+
   /**
    * The absolute position of the data in the full stream.
    */
@@ -154,21 +183,57 @@ public DataSpec(
     this(uri, null, absoluteStreamPosition, position, length, key, flags);
   }
 
+  /**
+   * Construct a {@link DataSpec} by inferring the {@link #httpMethod} based on the {@code postBody}
+   * parameter. If postBody is non-null, then httpMethod is set to {@link #HTTP_METHOD_POST}. If
+   * postBody is null, then httpMethod is set to {@link #HTTP_METHOD_GET}.
+   *
+   * @param uri {@link #uri}.
+   * @param postBody {@link #httpBody} The body of the HTTP request, which is also used to infer the
+   *     {@link #httpMethod}.
+   * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
+   * @param position {@link #position}.
+   * @param length {@link #length}.
+   * @param key {@link #key}.
+   * @param flags {@link #flags}.
+   */
+  public DataSpec(
+      Uri uri,
+      @Nullable byte[] postBody,
+      long absoluteStreamPosition,
+      long position,
+      long length,
+      @Nullable String key,
+      @Flags int flags) {
+    this(
+        uri,
+        /* httpMethod= */ postBody != null ? HTTP_METHOD_POST : HTTP_METHOD_GET,
+        /* httpBody= */ postBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags);
+  }
+
   /**
    * Construct a {@link DataSpec} where {@link #position} may differ from {@link
    * #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
-   * @param postBody {@link #postBody}.
+   * @param httpMethod {@link #httpMethod}.
+   * @param httpBody {@link #httpBody}.
    * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
    * @param position {@link #position}.
    * @param length {@link #length}.
    * @param key {@link #key}.
    * @param flags {@link #flags}.
    */
+  @SuppressWarnings("deprecation")
   public DataSpec(
       Uri uri,
-      @Nullable byte[] postBody,
+      @HttpMethod int httpMethod,
+      @Nullable byte[] httpBody,
       long absoluteStreamPosition,
       long position,
       long length,
@@ -178,7 +243,9 @@ public DataSpec(
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNSET);
     this.uri = uri;
-    this.postBody = postBody;
+    this.httpMethod = httpMethod;
+    this.httpBody = (httpBody != null && httpBody.length != 0) ? httpBody : null;
+    this.postBody = this.httpBody;
     this.absoluteStreamPosition = absoluteStreamPosition;
     this.position = position;
     this.length = length;
@@ -197,8 +264,48 @@ public boolean isFlagSet(@Flags int flag) {
 
   @Override
   public String toString() {
-    return "DataSpec[" + uri + ", " + Arrays.toString(postBody) + ", " + absoluteStreamPosition
-        + ", "  + position + ", " + length + ", " + key + ", " + flags + "]";
+    return "DataSpec["
+        + getHttpMethodString()
+        + " "
+        + uri
+        + ", "
+        + Arrays.toString(httpBody)
+        + ", "
+        + absoluteStreamPosition
+        + ", "
+        + position
+        + ", "
+        + length
+        + ", "
+        + key
+        + ", "
+        + flags
+        + "]";
+  }
+
+  /**
+   * Returns an uppercase HTTP method name (e.g., "GET", "POST", "HEAD") corresponding to the {@link
+   * #httpMethod}.
+   */
+  public final String getHttpMethodString() {
+    return getStringForHttpMethod(httpMethod);
+  }
+
+  /**
+   * Returns an uppercase HTTP method name (e.g., "GET", "POST", "HEAD") corresponding to the {@code
+   * httpMethod}.
+   */
+  public static String getStringForHttpMethod(@HttpMethod int httpMethod) {
+    switch (httpMethod) {
+      case HTTP_METHOD_GET:
+        return "GET";
+      case HTTP_METHOD_POST:
+        return "POST";
+      case HTTP_METHOD_HEAD:
+        return "HEAD";
+      default:
+        throw new AssertionError(httpMethod);
+    }
   }
 
   /**
@@ -223,8 +330,15 @@ public DataSpec subrange(long offset, long length) {
     if (offset == 0 && this.length == length) {
       return this;
     } else {
-      return new DataSpec(uri, postBody, absoluteStreamPosition + offset, position + offset, length,
-          key, flags);
+      return new DataSpec(
+          uri,
+          httpMethod,
+          httpBody,
+          absoluteStreamPosition + offset,
+          position + offset,
+          length,
+          key,
+          flags);
     }
   }
 
@@ -235,6 +349,7 @@ public DataSpec subrange(long offset, long length) {
    * @return The copied {@link DataSpec} with the specified Uri.
    */
   public DataSpec withUri(Uri uri) {
-    return new DataSpec(uri, postBody, absoluteStreamPosition, position, length, key, flags);
+    return new DataSpec(
+        uri, httpMethod, httpBody, absoluteStreamPosition, position, length, key, flags);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
index d9bd5873f0..71e2d8d19f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
@@ -117,9 +117,6 @@ public synchronized void release(Allocation[] allocations) {
           Math.max(availableAllocations.length * 2, availableCount + allocations.length));
     }
     for (Allocation allocation : allocations) {
-      // Weak sanity check that the allocation probably originated from this pool.
-      Assertions.checkArgument(allocation.data == initialAllocationBlock
-          || allocation.data.length == individualAllocationSize);
       availableAllocations[availableCount++] = allocation;
     }
     allocatedCount -= allocations.length;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index f32965619a..e9f70ec92a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -15,19 +15,57 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.content.Context;
 import android.os.Handler;
 import android.support.annotation.Nullable;
+import android.util.SparseArray;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.EventDispatcher;
 import com.google.android.exoplayer2.util.SlidingPercentile;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * Estimates bandwidth by listening to data transfers. The bandwidth estimate is calculated using
- * a {@link SlidingPercentile} and is updated each time a transfer ends.
+ * Estimates bandwidth by listening to data transfers.
+ *
+ * <p>The bandwidth estimate is calculated using a {@link SlidingPercentile} and is updated each
+ * time a transfer ends. The initial estimate is based on the current operator's network country
+ * code or the locale of the user, as well as the network connection type. This can be configured in
+ * the {@link Builder}.
  */
-public final class DefaultBandwidthMeter implements BandwidthMeter, TransferListener<Object> {
+public final class DefaultBandwidthMeter implements BandwidthMeter, TransferListener {
+
+  /**
+   * Country groups used to determine the default initial bitrate estimate. The group assignment for
+   * each country is an array of group indices for [Wifi, 2G, 3G, 4G].
+   */
+  public static final Map<String, int[]> DEFAULT_INITIAL_BITRATE_COUNTRY_GROUPS =
+      createInitialBitrateCountryGroupAssignment();
+
+  /** Default initial Wifi bitrate estimate in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI =
+      new long[] {5_700_000, 3_400_000, 1_900_000, 1_000_000, 400_000};
+
+  /** Default initial 2G bitrate estimates in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_2G =
+      new long[] {169_000, 129_000, 114_000, 102_000, 87_000};
 
-  /** Default initial bitrate estimate in bits per second. */
+  /** Default initial 3G bitrate estimates in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_3G =
+      new long[] {2_100_000, 1_300_000, 950_000, 700_000, 400_000};
+
+  /** Default initial 4G bitrate estimates in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_4G =
+      new long[] {6_900_000, 4_300_000, 2_700_000, 1_600_000, 450_000};
+
+  /**
+   * Default initial bitrate estimate used when the device is offline or the network type cannot be
+   * determined, in bits per second.
+   */
   public static final long DEFAULT_INITIAL_BITRATE_ESTIMATE = 1_000_000;
 
   /** Default maximum weight for the sliding window. */
@@ -36,15 +74,28 @@
   /** Builder for a bandwidth meter. */
   public static final class Builder {
 
-    private @Nullable Handler eventHandler;
-    private @Nullable EventListener eventListener;
-    private long initialBitrateEstimate;
+    @Nullable private final Context context;
+
+    @Nullable private Handler eventHandler;
+    @Nullable private EventListener eventListener;
+    private SparseArray<Long> initialBitrateEstimates;
     private int slidingWindowMaxWeight;
     private Clock clock;
 
-    /** Creates a builder with default parameters and without listener. */
+    /** @deprecated Use {@link #Builder(Context)} instead. */
+    @Deprecated
     public Builder() {
-      initialBitrateEstimate = DEFAULT_INITIAL_BITRATE_ESTIMATE;
+      this(/* context= */ null);
+    }
+
+    /**
+     * Creates a builder with default parameters and without listener.
+     *
+     * @param context A context.
+     */
+    public Builder(@Nullable Context context) {
+      this.context = context == null ? null : context.getApplicationContext();
+      initialBitrateEstimates = getInitialBitrateEstimatesForCountry(Util.getCountryCode(context));
       slidingWindowMaxWeight = DEFAULT_SLIDING_WINDOW_MAX_WEIGHT;
       clock = Clock.DEFAULT;
     }
@@ -83,7 +134,38 @@ public Builder setSlidingWindowMaxWeight(int slidingWindowMaxWeight) {
      * @return This builder.
      */
     public Builder setInitialBitrateEstimate(long initialBitrateEstimate) {
-      this.initialBitrateEstimate = initialBitrateEstimate;
+      for (int i = 0; i < initialBitrateEstimates.size(); i++) {
+        initialBitrateEstimates.setValueAt(i, initialBitrateEstimate);
+      }
+      return this;
+    }
+
+    /**
+     * Sets the initial bitrate estimate in bits per second for a network type that should be
+     * assumed when a bandwidth estimate is unavailable and the current network connection is of the
+     * specified type.
+     *
+     * @param networkType The {@link C.NetworkType} this initial estimate is for.
+     * @param initialBitrateEstimate The initial bitrate estimate in bits per second.
+     * @return This builder.
+     */
+    public Builder setInitialBitrateEstimate(
+        @C.NetworkType int networkType, long initialBitrateEstimate) {
+      initialBitrateEstimates.put(networkType, initialBitrateEstimate);
+      return this;
+    }
+
+    /**
+     * Sets the initial bitrate estimates to the default values of the specified country. The
+     * initial estimates are used when a bandwidth estimate is unavailable.
+     *
+     * @param countryCode The ISO 3166-1 alpha-2 country code of the country whose default bitrate
+     *     estimates should be used.
+     * @return This builder.
+     */
+    public Builder setInitialBitrateEstimate(String countryCode) {
+      initialBitrateEstimates =
+          getInitialBitrateEstimatesForCountry(Util.toUpperInvariant(countryCode));
       return this;
     }
 
@@ -105,16 +187,43 @@ public Builder setClock(Clock clock) {
      * @return A bandwidth meter with the configured properties.
      */
     public DefaultBandwidthMeter build() {
-      return new DefaultBandwidthMeter(
-          eventHandler, eventListener, initialBitrateEstimate, slidingWindowMaxWeight, clock);
+      Long initialBitrateEstimate = initialBitrateEstimates.get(Util.getNetworkType(context));
+      if (initialBitrateEstimate == null) {
+        initialBitrateEstimate = initialBitrateEstimates.get(C.NETWORK_TYPE_UNKNOWN);
+      }
+      DefaultBandwidthMeter bandwidthMeter =
+          new DefaultBandwidthMeter(initialBitrateEstimate, slidingWindowMaxWeight, clock);
+      if (eventHandler != null && eventListener != null) {
+        bandwidthMeter.addEventListener(eventHandler, eventListener);
+      }
+      return bandwidthMeter;
+    }
+
+    private static SparseArray<Long> getInitialBitrateEstimatesForCountry(String countryCode) {
+      int[] groupIndices = getCountryGroupIndices(countryCode);
+      SparseArray<Long> result = new SparseArray<>(/* initialCapacity= */ 6);
+      result.append(C.NETWORK_TYPE_UNKNOWN, DEFAULT_INITIAL_BITRATE_ESTIMATE);
+      result.append(C.NETWORK_TYPE_WIFI, DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI[groupIndices[0]]);
+      result.append(C.NETWORK_TYPE_2G, DEFAULT_INITIAL_BITRATE_ESTIMATES_2G[groupIndices[1]]);
+      result.append(C.NETWORK_TYPE_3G, DEFAULT_INITIAL_BITRATE_ESTIMATES_3G[groupIndices[2]]);
+      result.append(C.NETWORK_TYPE_4G, DEFAULT_INITIAL_BITRATE_ESTIMATES_4G[groupIndices[3]]);
+      // Assume default Wifi bitrate for Ethernet to prevent using the slower fallback bitrate.
+      result.append(
+          C.NETWORK_TYPE_ETHERNET, DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI[groupIndices[0]]);
+      return result;
+    }
+
+    private static int[] getCountryGroupIndices(String countryCode) {
+      int[] groupIndices = DEFAULT_INITIAL_BITRATE_COUNTRY_GROUPS.get(countryCode);
+      // Assume median group if not found.
+      return groupIndices == null ? new int[] {2, 2, 2, 2} : groupIndices;
     }
   }
 
   private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
   private static final int BYTES_TRANSFERRED_FOR_ESTIMATE = 512 * 1024;
 
-  private final @Nullable Handler eventHandler;
-  private final @Nullable EventListener eventListener;
+  private final EventDispatcher<EventListener> eventDispatcher;
   private final SlidingPercentile slidingPercentile;
   private final Clock clock;
 
@@ -128,39 +237,29 @@ public DefaultBandwidthMeter build() {
 
   /** Creates a bandwidth meter with default parameters. */
   public DefaultBandwidthMeter() {
-    this(
-        /* eventHandler= */ null,
-        /* eventListener= */ null,
-        DEFAULT_INITIAL_BITRATE_ESTIMATE,
-        DEFAULT_SLIDING_WINDOW_MAX_WEIGHT,
-        Clock.DEFAULT);
+    this(DEFAULT_INITIAL_BITRATE_ESTIMATE, DEFAULT_SLIDING_WINDOW_MAX_WEIGHT, Clock.DEFAULT);
   }
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
   public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener) {
-    this(
-        eventHandler,
-        eventListener,
-        DEFAULT_INITIAL_BITRATE_ESTIMATE,
-        DEFAULT_SLIDING_WINDOW_MAX_WEIGHT,
-        Clock.DEFAULT);
+    this(DEFAULT_INITIAL_BITRATE_ESTIMATE, DEFAULT_SLIDING_WINDOW_MAX_WEIGHT, Clock.DEFAULT);
+    if (eventHandler != null && eventListener != null) {
+      addEventListener(eventHandler, eventListener);
+    }
   }
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
   public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener, int maxWeight) {
-    this(eventHandler, eventListener, DEFAULT_INITIAL_BITRATE_ESTIMATE, maxWeight, Clock.DEFAULT);
+    this(DEFAULT_INITIAL_BITRATE_ESTIMATE, maxWeight, Clock.DEFAULT);
+    if (eventHandler != null && eventListener != null) {
+      addEventListener(eventHandler, eventListener);
+    }
   }
 
-  private DefaultBandwidthMeter(
-      @Nullable Handler eventHandler,
-      @Nullable EventListener eventListener,
-      long initialBitrateEstimate,
-      int maxWeight,
-      Clock clock) {
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
+  private DefaultBandwidthMeter(long initialBitrateEstimate, int maxWeight, Clock clock) {
+    this.eventDispatcher = new EventDispatcher<>();
     this.slidingPercentile = new SlidingPercentile(maxWeight);
     this.clock = clock;
     bitrateEstimate = initialBitrateEstimate;
@@ -172,7 +271,32 @@ public synchronized long getBitrateEstimate() {
   }
 
   @Override
-  public synchronized void onTransferStart(Object source, DataSpec dataSpec) {
+  @Nullable
+  public TransferListener getTransferListener() {
+    return this;
+  }
+
+  @Override
+  public void addEventListener(Handler eventHandler, EventListener eventListener) {
+    eventDispatcher.addListener(eventHandler, eventListener);
+  }
+
+  @Override
+  public void removeEventListener(EventListener eventListener) {
+    eventDispatcher.removeListener(eventListener);
+  }
+
+  @Override
+  public void onTransferInitializing(DataSource source, DataSpec dataSpec, boolean isNetwork) {
+    // Do nothing.
+  }
+
+  @Override
+  public synchronized void onTransferStart(
+      DataSource source, DataSpec dataSpec, boolean isNetwork) {
+    if (!isNetwork) {
+      return;
+    }
     if (streamCount == 0) {
       sampleStartTimeMs = clock.elapsedRealtime();
     }
@@ -180,12 +304,19 @@ public synchronized void onTransferStart(Object source, DataSpec dataSpec) {
   }
 
   @Override
-  public synchronized void onBytesTransferred(Object source, int bytes) {
+  public synchronized void onBytesTransferred(
+      DataSource source, DataSpec dataSpec, boolean isNetwork, int bytes) {
+    if (!isNetwork) {
+      return;
+    }
     sampleBytesTransferred += bytes;
   }
 
   @Override
-  public synchronized void onTransferEnd(Object source) {
+  public synchronized void onTransferEnd(DataSource source, DataSpec dataSpec, boolean isNetwork) {
+    if (!isNetwork) {
+      return;
+    }
     Assertions.checkState(streamCount > 0);
     long nowMs = clock.elapsedRealtime();
     int sampleElapsedTimeMs = (int) (nowMs - sampleStartTimeMs);
@@ -206,14 +337,252 @@ public synchronized void onTransferEnd(Object source) {
     sampleBytesTransferred = 0;
   }
 
-  private void notifyBandwidthSample(final int elapsedMs, final long bytes, final long bitrate) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
-        @Override
-        public void run() {
-          eventListener.onBandwidthSample(elapsedMs, bytes, bitrate);
-        }
-      });
-    }
+  private void notifyBandwidthSample(int elapsedMs, long bytes, long bitrate) {
+    eventDispatcher.dispatch(listener -> listener.onBandwidthSample(elapsedMs, bytes, bitrate));
+  }
+
+  private static Map<String, int[]> createInitialBitrateCountryGroupAssignment() {
+    HashMap<String, int[]> countryGroupAssignment = new HashMap<>();
+    countryGroupAssignment.put("AD", new int[] {1, 0, 0, 0});
+    countryGroupAssignment.put("AE", new int[] {1, 3, 4, 4});
+    countryGroupAssignment.put("AF", new int[] {4, 4, 3, 2});
+    countryGroupAssignment.put("AG", new int[] {3, 2, 1, 2});
+    countryGroupAssignment.put("AI", new int[] {1, 0, 0, 2});
+    countryGroupAssignment.put("AL", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("AM", new int[] {2, 2, 4, 3});
+    countryGroupAssignment.put("AO", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("AR", new int[] {2, 3, 2, 3});
+    countryGroupAssignment.put("AS", new int[] {3, 4, 4, 1});
+    countryGroupAssignment.put("AT", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("AU", new int[] {0, 3, 0, 0});
+    countryGroupAssignment.put("AW", new int[] {1, 1, 0, 4});
+    countryGroupAssignment.put("AX", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("AZ", new int[] {3, 3, 2, 2});
+    countryGroupAssignment.put("BA", new int[] {1, 1, 1, 2});
+    countryGroupAssignment.put("BB", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("BD", new int[] {2, 1, 3, 2});
+    countryGroupAssignment.put("BE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("BF", new int[] {4, 4, 4, 1});
+    countryGroupAssignment.put("BG", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("BH", new int[] {2, 1, 3, 4});
+    countryGroupAssignment.put("BI", new int[] {4, 3, 4, 4});
+    countryGroupAssignment.put("BJ", new int[] {4, 3, 4, 3});
+    countryGroupAssignment.put("BL", new int[] {1, 0, 1, 2});
+    countryGroupAssignment.put("BM", new int[] {1, 0, 0, 0});
+    countryGroupAssignment.put("BN", new int[] {4, 3, 3, 3});
+    countryGroupAssignment.put("BO", new int[] {2, 2, 1, 2});
+    countryGroupAssignment.put("BQ", new int[] {1, 1, 2, 4});
+    countryGroupAssignment.put("BR", new int[] {2, 3, 2, 2});
+    countryGroupAssignment.put("BS", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("BT", new int[] {3, 0, 2, 1});
+    countryGroupAssignment.put("BW", new int[] {4, 4, 2, 3});
+    countryGroupAssignment.put("BY", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("BZ", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("CA", new int[] {0, 2, 2, 3});
+    countryGroupAssignment.put("CD", new int[] {4, 4, 2, 1});
+    countryGroupAssignment.put("CF", new int[] {4, 4, 3, 3});
+    countryGroupAssignment.put("CG", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("CH", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("CI", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("CK", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("CL", new int[] {2, 2, 2, 3});
+    countryGroupAssignment.put("CM", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("CN", new int[] {2, 0, 1, 2});
+    countryGroupAssignment.put("CO", new int[] {2, 3, 2, 1});
+    countryGroupAssignment.put("CR", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("CU", new int[] {4, 4, 4, 1});
+    countryGroupAssignment.put("CV", new int[] {2, 2, 2, 4});
+    countryGroupAssignment.put("CW", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("CX", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("CY", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("CZ", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("DE", new int[] {0, 2, 2, 2});
+    countryGroupAssignment.put("DJ", new int[] {3, 4, 4, 0});
+    countryGroupAssignment.put("DK", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("DM", new int[] {2, 0, 3, 4});
+    countryGroupAssignment.put("DO", new int[] {3, 3, 4, 4});
+    countryGroupAssignment.put("DZ", new int[] {3, 3, 4, 4});
+    countryGroupAssignment.put("EC", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("EE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("EG", new int[] {3, 3, 1, 1});
+    countryGroupAssignment.put("EH", new int[] {2, 0, 2, 3});
+    countryGroupAssignment.put("ER", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("ES", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("ET", new int[] {4, 4, 4, 0});
+    countryGroupAssignment.put("FI", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("FJ", new int[] {3, 2, 3, 3});
+    countryGroupAssignment.put("FK", new int[] {3, 4, 2, 1});
+    countryGroupAssignment.put("FM", new int[] {4, 2, 4, 0});
+    countryGroupAssignment.put("FO", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("FR", new int[] {1, 0, 2, 1});
+    countryGroupAssignment.put("GA", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("GB", new int[] {0, 1, 3, 2});
+    countryGroupAssignment.put("GD", new int[] {2, 0, 3, 0});
+    countryGroupAssignment.put("GE", new int[] {1, 1, 0, 3});
+    countryGroupAssignment.put("GF", new int[] {1, 2, 4, 4});
+    countryGroupAssignment.put("GG", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("GH", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("GI", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("GL", new int[] {2, 4, 1, 4});
+    countryGroupAssignment.put("GM", new int[] {4, 3, 3, 0});
+    countryGroupAssignment.put("GN", new int[] {4, 4, 3, 4});
+    countryGroupAssignment.put("GP", new int[] {2, 2, 1, 3});
+    countryGroupAssignment.put("GQ", new int[] {4, 4, 3, 1});
+    countryGroupAssignment.put("GR", new int[] {1, 1, 0, 1});
+    countryGroupAssignment.put("GT", new int[] {3, 2, 3, 4});
+    countryGroupAssignment.put("GU", new int[] {1, 0, 4, 4});
+    countryGroupAssignment.put("GW", new int[] {4, 4, 4, 0});
+    countryGroupAssignment.put("GY", new int[] {3, 4, 1, 0});
+    countryGroupAssignment.put("HK", new int[] {0, 2, 3, 4});
+    countryGroupAssignment.put("HN", new int[] {3, 3, 2, 2});
+    countryGroupAssignment.put("HR", new int[] {1, 0, 0, 2});
+    countryGroupAssignment.put("HT", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("HU", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("ID", new int[] {2, 3, 3, 4});
+    countryGroupAssignment.put("IE", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("IL", new int[] {0, 1, 1, 3});
+    countryGroupAssignment.put("IM", new int[] {0, 1, 0, 1});
+    countryGroupAssignment.put("IN", new int[] {2, 3, 3, 4});
+    countryGroupAssignment.put("IO", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("IQ", new int[] {3, 3, 4, 3});
+    countryGroupAssignment.put("IR", new int[] {3, 2, 4, 4});
+    countryGroupAssignment.put("IS", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("IT", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("JE", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("JM", new int[] {3, 3, 3, 2});
+    countryGroupAssignment.put("JO", new int[] {1, 1, 1, 2});
+    countryGroupAssignment.put("JP", new int[] {0, 1, 1, 2});
+    countryGroupAssignment.put("KE", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("KG", new int[] {2, 2, 3, 3});
+    countryGroupAssignment.put("KH", new int[] {1, 0, 4, 4});
+    countryGroupAssignment.put("KI", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("KM", new int[] {4, 4, 2, 2});
+    countryGroupAssignment.put("KN", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("KP", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("KR", new int[] {0, 4, 0, 2});
+    countryGroupAssignment.put("KW", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("KY", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("KZ", new int[] {1, 2, 2, 3});
+    countryGroupAssignment.put("LA", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("LB", new int[] {3, 2, 0, 0});
+    countryGroupAssignment.put("LC", new int[] {2, 2, 1, 0});
+    countryGroupAssignment.put("LI", new int[] {0, 0, 1, 2});
+    countryGroupAssignment.put("LK", new int[] {1, 1, 2, 2});
+    countryGroupAssignment.put("LR", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("LS", new int[] {3, 3, 2, 0});
+    countryGroupAssignment.put("LT", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("LU", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("LV", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("LY", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MA", new int[] {2, 1, 2, 2});
+    countryGroupAssignment.put("MC", new int[] {1, 0, 1, 0});
+    countryGroupAssignment.put("MD", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("ME", new int[] {1, 2, 2, 3});
+    countryGroupAssignment.put("MF", new int[] {1, 4, 3, 3});
+    countryGroupAssignment.put("MG", new int[] {3, 4, 1, 2});
+    countryGroupAssignment.put("MH", new int[] {4, 0, 2, 3});
+    countryGroupAssignment.put("MK", new int[] {1, 0, 0, 1});
+    countryGroupAssignment.put("ML", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MM", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("MN", new int[] {2, 2, 2, 4});
+    countryGroupAssignment.put("MO", new int[] {0, 1, 4, 4});
+    countryGroupAssignment.put("MP", new int[] {0, 0, 4, 4});
+    countryGroupAssignment.put("MQ", new int[] {1, 1, 1, 3});
+    countryGroupAssignment.put("MR", new int[] {4, 2, 4, 2});
+    countryGroupAssignment.put("MS", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("MT", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("MU", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("MV", new int[] {4, 2, 0, 1});
+    countryGroupAssignment.put("MW", new int[] {3, 2, 1, 1});
+    countryGroupAssignment.put("MX", new int[] {2, 4, 3, 1});
+    countryGroupAssignment.put("MY", new int[] {2, 3, 3, 3});
+    countryGroupAssignment.put("MZ", new int[] {3, 3, 2, 4});
+    countryGroupAssignment.put("NA", new int[] {4, 2, 1, 1});
+    countryGroupAssignment.put("NC", new int[] {2, 1, 3, 3});
+    countryGroupAssignment.put("NE", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("NF", new int[] {0, 2, 2, 2});
+    countryGroupAssignment.put("NG", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("NI", new int[] {3, 4, 3, 3});
+    countryGroupAssignment.put("NL", new int[] {0, 1, 3, 2});
+    countryGroupAssignment.put("NO", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("NP", new int[] {2, 3, 2, 2});
+    countryGroupAssignment.put("NR", new int[] {4, 3, 4, 1});
+    countryGroupAssignment.put("NU", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("NZ", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("OM", new int[] {2, 2, 1, 3});
+    countryGroupAssignment.put("PA", new int[] {1, 3, 2, 3});
+    countryGroupAssignment.put("PE", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("PF", new int[] {2, 2, 0, 1});
+    countryGroupAssignment.put("PG", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("PH", new int[] {3, 0, 4, 4});
+    countryGroupAssignment.put("PK", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("PL", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("PM", new int[] {0, 2, 2, 3});
+    countryGroupAssignment.put("PR", new int[] {2, 3, 4, 3});
+    countryGroupAssignment.put("PS", new int[] {2, 3, 0, 4});
+    countryGroupAssignment.put("PT", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("PW", new int[] {3, 2, 3, 0});
+    countryGroupAssignment.put("PY", new int[] {2, 1, 3, 3});
+    countryGroupAssignment.put("QA", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("RE", new int[] {1, 1, 2, 2});
+    countryGroupAssignment.put("RO", new int[] {0, 1, 1, 3});
+    countryGroupAssignment.put("RS", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("RU", new int[] {0, 1, 1, 1});
+    countryGroupAssignment.put("RW", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("SA", new int[] {3, 2, 2, 3});
+    countryGroupAssignment.put("SB", new int[] {4, 4, 3, 0});
+    countryGroupAssignment.put("SC", new int[] {4, 2, 0, 1});
+    countryGroupAssignment.put("SD", new int[] {3, 4, 4, 4});
+    countryGroupAssignment.put("SE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("SG", new int[] {1, 2, 3, 3});
+    countryGroupAssignment.put("SH", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("SI", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("SJ", new int[] {3, 2, 0, 2});
+    countryGroupAssignment.put("SK", new int[] {0, 1, 0, 1});
+    countryGroupAssignment.put("SL", new int[] {4, 3, 2, 4});
+    countryGroupAssignment.put("SM", new int[] {1, 0, 1, 1});
+    countryGroupAssignment.put("SN", new int[] {4, 4, 4, 2});
+    countryGroupAssignment.put("SO", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("SR", new int[] {3, 2, 2, 3});
+    countryGroupAssignment.put("SS", new int[] {4, 3, 4, 2});
+    countryGroupAssignment.put("ST", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("SV", new int[] {2, 3, 2, 3});
+    countryGroupAssignment.put("SX", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("SY", new int[] {4, 4, 2, 0});
+    countryGroupAssignment.put("SZ", new int[] {3, 4, 1, 1});
+    countryGroupAssignment.put("TC", new int[] {2, 1, 2, 1});
+    countryGroupAssignment.put("TD", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("TG", new int[] {3, 2, 2, 0});
+    countryGroupAssignment.put("TH", new int[] {1, 3, 4, 4});
+    countryGroupAssignment.put("TJ", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("TL", new int[] {4, 2, 4, 4});
+    countryGroupAssignment.put("TM", new int[] {4, 1, 3, 3});
+    countryGroupAssignment.put("TN", new int[] {2, 2, 1, 2});
+    countryGroupAssignment.put("TO", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("TR", new int[] {1, 2, 0, 2});
+    countryGroupAssignment.put("TT", new int[] {2, 1, 1, 0});
+    countryGroupAssignment.put("TV", new int[] {4, 2, 2, 4});
+    countryGroupAssignment.put("TW", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("TZ", new int[] {3, 3, 3, 2});
+    countryGroupAssignment.put("UA", new int[] {0, 2, 1, 3});
+    countryGroupAssignment.put("UG", new int[] {4, 3, 2, 2});
+    countryGroupAssignment.put("US", new int[] {0, 1, 3, 3});
+    countryGroupAssignment.put("UY", new int[] {2, 1, 2, 2});
+    countryGroupAssignment.put("UZ", new int[] {4, 3, 2, 4});
+    countryGroupAssignment.put("VA", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("VC", new int[] {2, 0, 3, 2});
+    countryGroupAssignment.put("VE", new int[] {3, 4, 4, 3});
+    countryGroupAssignment.put("VG", new int[] {3, 1, 3, 4});
+    countryGroupAssignment.put("VI", new int[] {1, 0, 2, 4});
+    countryGroupAssignment.put("VN", new int[] {0, 2, 4, 4});
+    countryGroupAssignment.put("VU", new int[] {4, 1, 3, 2});
+    countryGroupAssignment.put("WS", new int[] {3, 2, 3, 0});
+    countryGroupAssignment.put("XK", new int[] {1, 2, 1, 0});
+    countryGroupAssignment.put("YE", new int[] {4, 4, 4, 2});
+    countryGroupAssignment.put("YT", new int[] {3, 1, 1, 2});
+    countryGroupAssignment.put("ZA", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("ZM", new int[] {3, 3, 3, 1});
+    countryGroupAssignment.put("ZW", new int[] {3, 3, 2, 1});
+    return Collections.unmodifiableMap(countryGroupAssignment);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index b5469db72e..6504562c58 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -17,10 +17,15 @@
 
 import android.content.Context;
 import android.net.Uri;
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A {@link DataSource} that supports multiple URI schemes. The supported schemes are:
@@ -53,31 +58,97 @@
   private static final String SCHEME_RAW = RawResourceDataSource.RAW_RESOURCE_SCHEME;
 
   private final Context context;
-  private final TransferListener<? super DataSource> listener;
-
+  private final List<TransferListener> transferListeners;
   private final DataSource baseDataSource;
 
   // Lazily initialized.
-  private DataSource fileDataSource;
-  private DataSource assetDataSource;
-  private DataSource contentDataSource;
-  private DataSource rtmpDataSource;
-  private DataSource dataSchemeDataSource;
-  private DataSource rawResourceDataSource;
+  private @Nullable DataSource fileDataSource;
+  private @Nullable DataSource assetDataSource;
+  private @Nullable DataSource contentDataSource;
+  private @Nullable DataSource rtmpDataSource;
+  private @Nullable DataSource dataSchemeDataSource;
+  private @Nullable DataSource rawResourceDataSource;
 
-  private DataSource dataSource;
+  private @Nullable DataSource dataSource;
+
+  /**
+   * Constructs a new instance, optionally configured to follow cross-protocol redirects.
+   *
+   * @param context A context.
+   * @param userAgent The User-Agent to use when requesting remote data.
+   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+   *     to HTTPS and vice versa) are enabled when fetching remote data.
+   */
+  public DefaultDataSource(Context context, String userAgent, boolean allowCrossProtocolRedirects) {
+    this(
+        context,
+        userAgent,
+        DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS,
+        allowCrossProtocolRedirects);
+  }
+
+  /**
+   * Constructs a new instance, optionally configured to follow cross-protocol redirects.
+   *
+   * @param context A context.
+   * @param userAgent The User-Agent to use when requesting remote data.
+   * @param connectTimeoutMillis The connection timeout that should be used when requesting remote
+   *     data, in milliseconds. A timeout of zero is interpreted as an infinite timeout.
+   * @param readTimeoutMillis The read timeout that should be used when requesting remote data, in
+   *     milliseconds. A timeout of zero is interpreted as an infinite timeout.
+   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+   *     to HTTPS and vice versa) are enabled when fetching remote data.
+   */
+  public DefaultDataSource(
+      Context context,
+      String userAgent,
+      int connectTimeoutMillis,
+      int readTimeoutMillis,
+      boolean allowCrossProtocolRedirects) {
+    this(
+        context,
+        new DefaultHttpDataSource(
+            userAgent,
+            /* contentTypePredicate= */ null,
+            connectTimeoutMillis,
+            readTimeoutMillis,
+            allowCrossProtocolRedirects,
+            /* defaultRequestProperties= */ null));
+  }
+
+  /**
+   * Constructs a new instance that delegates to a provided {@link DataSource} for URI schemes other
+   * than file, asset and content.
+   *
+   * @param context A context.
+   * @param baseDataSource A {@link DataSource} to use for URI schemes other than file, asset and
+   *     content. This {@link DataSource} should normally support at least http(s).
+   */
+  public DefaultDataSource(Context context, DataSource baseDataSource) {
+    this.context = context.getApplicationContext();
+    this.baseDataSource = Assertions.checkNotNull(baseDataSource);
+    transferListeners = new ArrayList<>();
+  }
 
   /**
    * Constructs a new instance, optionally configured to follow cross-protocol redirects.
    *
    * @param context A context.
    * @param listener An optional listener.
-   * @param userAgent The User-Agent string that should be used when requesting remote data.
+   * @param userAgent The User-Agent to use when requesting remote data.
    * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
    *     to HTTPS and vice versa) are enabled when fetching remote data.
+   * @deprecated Use {@link #DefaultDataSource(Context, String, boolean)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public DefaultDataSource(Context context, TransferListener<? super DataSource> listener,
-      String userAgent, boolean allowCrossProtocolRedirects) {
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public DefaultDataSource(
+      Context context,
+      @Nullable TransferListener listener,
+      String userAgent,
+      boolean allowCrossProtocolRedirects) {
     this(context, listener, userAgent, DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS,
         DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS, allowCrossProtocolRedirects);
   }
@@ -87,20 +158,36 @@ public DefaultDataSource(Context context, TransferListener<? super DataSource> l
    *
    * @param context A context.
    * @param listener An optional listener.
-   * @param userAgent The User-Agent string that should be used when requesting remote data.
+   * @param userAgent The User-Agent to use when requesting remote data.
    * @param connectTimeoutMillis The connection timeout that should be used when requesting remote
    *     data, in milliseconds. A timeout of zero is interpreted as an infinite timeout.
-   * @param readTimeoutMillis The read timeout that should be used when requesting remote data,
-   *     in milliseconds. A timeout of zero is interpreted as an infinite timeout.
+   * @param readTimeoutMillis The read timeout that should be used when requesting remote data, in
+   *     milliseconds. A timeout of zero is interpreted as an infinite timeout.
    * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
    *     to HTTPS and vice versa) are enabled when fetching remote data.
+   * @deprecated Use {@link #DefaultDataSource(Context, String, int, int, boolean)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public DefaultDataSource(Context context, TransferListener<? super DataSource> listener,
-      String userAgent, int connectTimeoutMillis, int readTimeoutMillis,
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public DefaultDataSource(
+      Context context,
+      @Nullable TransferListener listener,
+      String userAgent,
+      int connectTimeoutMillis,
+      int readTimeoutMillis,
       boolean allowCrossProtocolRedirects) {
-    this(context, listener,
-        new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
-            readTimeoutMillis, allowCrossProtocolRedirects, null));
+    this(
+        context,
+        listener,
+        new DefaultHttpDataSource(
+            userAgent,
+            /* contentTypePredicate= */ null,
+            listener,
+            connectTimeoutMillis,
+            readTimeoutMillis,
+            allowCrossProtocolRedirects,
+            /* defaultRequestProperties= */ null));
   }
 
   /**
@@ -111,12 +198,28 @@ public DefaultDataSource(Context context, TransferListener<? super DataSource> l
    * @param listener An optional listener.
    * @param baseDataSource A {@link DataSource} to use for URI schemes other than file, asset and
    *     content. This {@link DataSource} should normally support at least http(s).
+   * @deprecated Use {@link #DefaultDataSource(Context, DataSource)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public DefaultDataSource(Context context, TransferListener<? super DataSource> listener,
-      DataSource baseDataSource) {
-    this.context = context.getApplicationContext();
-    this.listener = listener;
-    this.baseDataSource = Assertions.checkNotNull(baseDataSource);
+  @Deprecated
+  public DefaultDataSource(
+      Context context, @Nullable TransferListener listener, DataSource baseDataSource) {
+    this(context, baseDataSource);
+    if (listener != null) {
+      transferListeners.add(listener);
+    }
+  }
+
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    baseDataSource.addTransferListener(transferListener);
+    transferListeners.add(transferListener);
+    maybeAddListenerToDataSource(fileDataSource, transferListener);
+    maybeAddListenerToDataSource(assetDataSource, transferListener);
+    maybeAddListenerToDataSource(contentDataSource, transferListener);
+    maybeAddListenerToDataSource(rtmpDataSource, transferListener);
+    maybeAddListenerToDataSource(dataSchemeDataSource, transferListener);
+    maybeAddListenerToDataSource(rawResourceDataSource, transferListener);
   }
 
   @Override
@@ -149,14 +252,19 @@ public long open(DataSpec dataSpec) throws IOException {
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws IOException {
-    return dataSource.read(buffer, offset, readLength);
+    return Assertions.checkNotNull(dataSource).read(buffer, offset, readLength);
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return dataSource == null ? null : dataSource.getUri();
   }
 
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return dataSource == null ? Collections.emptyMap() : dataSource.getResponseHeaders();
+  }
+
   @Override
   public void close() throws IOException {
     if (dataSource != null) {
@@ -170,21 +278,24 @@ public void close() throws IOException {
 
   private DataSource getFileDataSource() {
     if (fileDataSource == null) {
-      fileDataSource = new FileDataSource(listener);
+      fileDataSource = new FileDataSource();
+      addListenersToDataSource(fileDataSource);
     }
     return fileDataSource;
   }
 
   private DataSource getAssetDataSource() {
     if (assetDataSource == null) {
-      assetDataSource = new AssetDataSource(context, listener);
+      assetDataSource = new AssetDataSource(context);
+      addListenersToDataSource(assetDataSource);
     }
     return assetDataSource;
   }
 
   private DataSource getContentDataSource() {
     if (contentDataSource == null) {
-      contentDataSource = new ContentDataSource(context, listener);
+      contentDataSource = new ContentDataSource(context);
+      addListenersToDataSource(contentDataSource);
     }
     return contentDataSource;
   }
@@ -196,6 +307,7 @@ private DataSource getRtmpDataSource() {
         Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.rtmp.RtmpDataSource");
         rtmpDataSource = (DataSource) clazz.getConstructor().newInstance();
         // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+        addListenersToDataSource(rtmpDataSource);
       } catch (ClassNotFoundException e) {
         // Expected if the app was built without the RTMP extension.
         Log.w(TAG, "Attempting to play RTMP stream without depending on the RTMP extension");
@@ -213,14 +325,29 @@ private DataSource getRtmpDataSource() {
   private DataSource getDataSchemeDataSource() {
     if (dataSchemeDataSource == null) {
       dataSchemeDataSource = new DataSchemeDataSource();
+      addListenersToDataSource(dataSchemeDataSource);
     }
     return dataSchemeDataSource;
   }
 
   private DataSource getRawResourceDataSource() {
     if (rawResourceDataSource == null) {
-      rawResourceDataSource = new RawResourceDataSource(context, listener);
+      rawResourceDataSource = new RawResourceDataSource(context);
+      addListenersToDataSource(rawResourceDataSource);
     }
     return rawResourceDataSource;
   }
+
+  private void addListenersToDataSource(DataSource dataSource) {
+    for (int i = 0; i < transferListeners.size(); i++) {
+      dataSource.addTransferListener(transferListeners.get(i));
+    }
+  }
+
+  private void maybeAddListenerToDataSource(
+      @Nullable DataSource dataSource, TransferListener listener) {
+    if (dataSource != null) {
+      dataSource.addTransferListener(listener);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java
index 34d60e4b81..8183a89064 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.content.Context;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DataSource.Factory;
 
 /**
@@ -25,7 +26,7 @@
 public final class DefaultDataSourceFactory implements Factory {
 
   private final Context context;
-  private final TransferListener<? super DataSource> listener;
+  private final @Nullable TransferListener listener;
   private final DataSource.Factory baseDataSourceFactory;
 
   /**
@@ -33,7 +34,7 @@
    * @param userAgent The User-Agent string that should be used.
    */
   public DefaultDataSourceFactory(Context context, String userAgent) {
-    this(context, userAgent, null);
+    this(context, userAgent, /* listener= */ null);
   }
 
   /**
@@ -41,11 +42,21 @@ public DefaultDataSourceFactory(Context context, String userAgent) {
    * @param userAgent The User-Agent string that should be used.
    * @param listener An optional listener.
    */
-  public DefaultDataSourceFactory(Context context, String userAgent,
-      TransferListener<? super DataSource> listener) {
+  public DefaultDataSourceFactory(
+      Context context, String userAgent, @Nullable TransferListener listener) {
     this(context, listener, new DefaultHttpDataSourceFactory(userAgent, listener));
   }
 
+  /**
+   * @param context A context.
+   * @param baseDataSourceFactory A {@link Factory} to be used to create a base {@link DataSource}
+   *     for {@link DefaultDataSource}.
+   * @see DefaultDataSource#DefaultDataSource(Context, TransferListener, DataSource)
+   */
+  public DefaultDataSourceFactory(Context context, DataSource.Factory baseDataSourceFactory) {
+    this(context, /* listener= */ null, baseDataSourceFactory);
+  }
+
   /**
    * @param context A context.
    * @param listener An optional listener.
@@ -53,7 +64,9 @@ public DefaultDataSourceFactory(Context context, String userAgent,
    *     for {@link DefaultDataSource}.
    * @see DefaultDataSource#DefaultDataSource(Context, TransferListener, DataSource)
    */
-  public DefaultDataSourceFactory(Context context, TransferListener<? super DataSource> listener,
+  public DefaultDataSourceFactory(
+      Context context,
+      @Nullable TransferListener listener,
       DataSource.Factory baseDataSourceFactory) {
     this.context = context.getApplicationContext();
     this.listener = listener;
@@ -62,7 +75,11 @@ public DefaultDataSourceFactory(Context context, TransferListener<? super DataSo
 
   @Override
   public DefaultDataSource createDataSource() {
-    return new DefaultDataSource(context, listener, baseDataSourceFactory.createDataSource());
+    DefaultDataSource dataSource =
+        new DefaultDataSource(context, baseDataSourceFactory.createDataSource());
+    if (listener != null) {
+      dataSource.addTransferListener(listener);
+    }
+    return dataSource;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index a47a5b5348..c6749e6c8f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -16,10 +16,12 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSpec.HttpMethod;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
@@ -32,6 +34,7 @@
 import java.net.NoRouteToHostException;
 import java.net.ProtocolException;
 import java.net.URL;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -40,13 +43,13 @@
 
 /**
  * An {@link HttpDataSource} that uses Android's {@link HttpURLConnection}.
- * <p>
- * By default this implementation will not follow cross-protocol redirects (i.e. redirects from
- * HTTP to HTTPS or vice versa). Cross-protocol redirects can be enabled by using the
- * {@link #DefaultHttpDataSource(String, Predicate, TransferListener, int, int, boolean,
+ *
+ * <p>By default this implementation will not follow cross-protocol redirects (i.e. redirects from
+ * HTTP to HTTPS or vice versa). Cross-protocol redirects can be enabled by using the {@link
+ * #DefaultHttpDataSource(String, Predicate, TransferListener, int, int, boolean,
  * RequestProperties)} constructor and passing {@code true} as the second last argument.
  */
-public class DefaultHttpDataSource implements HttpDataSource {
+public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSource {
 
   /**
    * The default connection timeout, in milliseconds.
@@ -59,6 +62,8 @@
 
   private static final String TAG = "DefaultHttpDataSource";
   private static final int MAX_REDIRECTS = 20; // Same limit as okhttp.
+  private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;
+  private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;
   private static final long MAX_BYTES_TO_DRAIN = 2048;
   private static final Pattern CONTENT_RANGE_HEADER =
       Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
@@ -68,14 +73,13 @@
   private final int connectTimeoutMillis;
   private final int readTimeoutMillis;
   private final String userAgent;
-  private final Predicate<String> contentTypePredicate;
-  private final RequestProperties defaultRequestProperties;
+  private final @Nullable Predicate<String> contentTypePredicate;
+  private final @Nullable RequestProperties defaultRequestProperties;
   private final RequestProperties requestProperties;
-  private final TransferListener<? super DefaultHttpDataSource> listener;
 
-  private DataSpec dataSpec;
-  private HttpURLConnection connection;
-  private InputStream inputStream;
+  private @Nullable DataSpec dataSpec;
+  private @Nullable HttpURLConnection connection;
+  private @Nullable InputStream inputStream;
   private boolean opened;
 
   private long bytesToSkip;
@@ -87,22 +91,88 @@
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
+   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
+   */
+  public DefaultHttpDataSource(String userAgent, @Nullable Predicate<String> contentTypePredicate) {
+    this(
+        userAgent,
+        contentTypePredicate,
+        DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS);
+  }
+
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
+   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
+   *     interpreted as an infinite timeout.
+   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted as
+   *     an infinite timeout.
    */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate) {
-    this(userAgent, contentTypePredicate, null);
+  public DefaultHttpDataSource(
+      String userAgent,
+      @Nullable Predicate<String> contentTypePredicate,
+      int connectTimeoutMillis,
+      int readTimeoutMillis) {
+    this(
+        userAgent,
+        contentTypePredicate,
+        connectTimeoutMillis,
+        readTimeoutMillis,
+        /* allowCrossProtocolRedirects= */ false,
+        /* defaultRequestProperties= */ null);
+  }
+
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
+   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
+   *     interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use the
+   *     default value.
+   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted as
+   *     an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
+   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+   *     to HTTPS and vice versa) are enabled.
+   * @param defaultRequestProperties The default request properties to be sent to the server as HTTP
+   *     headers or {@code null} if not required.
+   */
+  public DefaultHttpDataSource(
+      String userAgent,
+      @Nullable Predicate<String> contentTypePredicate,
+      int connectTimeoutMillis,
+      int readTimeoutMillis,
+      boolean allowCrossProtocolRedirects,
+      @Nullable RequestProperties defaultRequestProperties) {
+    super(/* isNetwork= */ true);
+    this.userAgent = Assertions.checkNotEmpty(userAgent);
+    this.contentTypePredicate = contentTypePredicate;
+    this.requestProperties = new RequestProperties();
+    this.connectTimeoutMillis = connectTimeoutMillis;
+    this.readTimeoutMillis = readTimeoutMillis;
+    this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
+    this.defaultRequestProperties = defaultRequestProperties;
   }
 
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
+   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    * @param listener An optional listener.
+   * @deprecated Use {@link #DefaultHttpDataSource(String, Predicate)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener<? super DefaultHttpDataSource> listener) {
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public DefaultHttpDataSource(
+      String userAgent,
+      @Nullable Predicate<String> contentTypePredicate,
+      @Nullable TransferListener listener) {
     this(userAgent, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
         DEFAULT_READ_TIMEOUT_MILLIS);
   }
@@ -110,16 +180,23 @@ public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePred
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
+   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    * @param listener An optional listener.
    * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
    *     interpreted as an infinite timeout.
-   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
-   *     as an infinite timeout.
+   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted as
+   *     an infinite timeout.
+   * @deprecated Use {@link #DefaultHttpDataSource(String, Predicate, int, int)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public DefaultHttpDataSource(
+      String userAgent,
+      @Nullable Predicate<String> contentTypePredicate,
+      @Nullable TransferListener listener,
+      int connectTimeoutMillis,
       int readTimeoutMillis) {
     this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false,
         null);
@@ -128,41 +205,50 @@ public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePred
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
+   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from {@link
+   *     #open(DataSpec)}.
    * @param listener An optional listener.
    * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
-   *     interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use
-   *     the default value.
-   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
-   *     as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
+   *     interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use the
+   *     default value.
+   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted as
+   *     an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
    * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
    *     to HTTPS and vice versa) are enabled.
-   * @param defaultRequestProperties The default request properties to be sent to the server as
-   *     HTTP headers or {@code null} if not required.
+   * @param defaultRequestProperties The default request properties to be sent to the server as HTTP
+   *     headers or {@code null} if not required.
+   * @deprecated Use {@link #DefaultHttpDataSource(String, Predicate, int, int, boolean,
+   *     RequestProperties)} and {@link #addTransferListener(TransferListener)}.
    */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
-      int readTimeoutMillis, boolean allowCrossProtocolRedirects,
-      RequestProperties defaultRequestProperties) {
-    this.userAgent = Assertions.checkNotEmpty(userAgent);
-    this.contentTypePredicate = contentTypePredicate;
-    this.listener = listener;
-    this.requestProperties = new RequestProperties();
-    this.connectTimeoutMillis = connectTimeoutMillis;
-    this.readTimeoutMillis = readTimeoutMillis;
-    this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
-    this.defaultRequestProperties = defaultRequestProperties;
+  @Deprecated
+  public DefaultHttpDataSource(
+      String userAgent,
+      @Nullable Predicate<String> contentTypePredicate,
+      @Nullable TransferListener listener,
+      int connectTimeoutMillis,
+      int readTimeoutMillis,
+      boolean allowCrossProtocolRedirects,
+      @Nullable RequestProperties defaultRequestProperties) {
+    this(
+        userAgent,
+        contentTypePredicate,
+        connectTimeoutMillis,
+        readTimeoutMillis,
+        allowCrossProtocolRedirects,
+        defaultRequestProperties);
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return connection == null ? null : Uri.parse(connection.getURL().toString());
   }
 
   @Override
   public Map<String, List<String>> getResponseHeaders() {
-    return connection == null ? null : connection.getHeaderFields();
+    return connection == null ? Collections.emptyMap() : connection.getHeaderFields();
   }
 
   @Override
@@ -188,6 +274,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.dataSpec = dataSpec;
     this.bytesRead = 0;
     this.bytesSkipped = 0;
+    transferInitializing(dataSpec);
     try {
       connection = makeConnection(dataSpec);
     } catch (IOException e) {
@@ -196,8 +283,10 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
 
     int responseCode;
+    String responseMessage;
     try {
       responseCode = connection.getResponseCode();
+      responseMessage = connection.getResponseMessage();
     } catch (IOException e) {
       closeConnectionQuietly();
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
@@ -209,7 +298,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       Map<String, List<String>> headers = connection.getHeaderFields();
       closeConnectionQuietly();
       InvalidResponseCodeException exception =
-          new InvalidResponseCodeException(responseCode, headers, dataSpec);
+          new InvalidResponseCodeException(responseCode, responseMessage, headers, dataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
@@ -253,9 +342,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
 
     return bytesToRead;
   }
@@ -286,9 +373,7 @@ public void close() throws HttpDataSourceException {
       closeConnectionQuietly();
       if (opened) {
         opened = false;
-        if (listener != null) {
-          listener.onTransferEnd(this);
-        }
+        transferEnded();
       }
     }
   }
@@ -298,7 +383,7 @@ public void close() throws HttpDataSourceException {
    *
    * @return The current open connection, or null.
    */
-  protected final HttpURLConnection getConnection() {
+  protected final @Nullable HttpURLConnection getConnection() {
     return connection;
   }
 
@@ -339,7 +424,8 @@ protected final long bytesRemaining() {
    */
   private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     URL url = new URL(dataSpec.uri.toString());
-    byte[] postBody = dataSpec.postBody;
+    @HttpMethod int httpMethod = dataSpec.httpMethod;
+    byte[] httpBody = dataSpec.httpBody;
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
@@ -347,27 +433,36 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
       // automatically. This is the behavior we want, so use it.
-      return makeConnection(url, postBody, position, length, allowGzip, true /* followRedirects */);
+      return makeConnection(
+          url, httpMethod, httpBody, position, length, allowGzip, true /* followRedirects */);
     }
 
     // We need to handle redirects ourselves to allow cross-protocol redirects.
     int redirectCount = 0;
     while (redirectCount++ <= MAX_REDIRECTS) {
-      HttpURLConnection connection = makeConnection(
-          url, postBody, position, length, allowGzip, false /* followRedirects */);
+      HttpURLConnection connection =
+          makeConnection(
+              url, httpMethod, httpBody, position, length, allowGzip, false /* followRedirects */);
       int responseCode = connection.getResponseCode();
-      if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
-          || responseCode == HttpURLConnection.HTTP_MOVED_PERM
-          || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
-          || responseCode == HttpURLConnection.HTTP_SEE_OTHER
-          || (postBody == null
-              && (responseCode == 307 /* HTTP_TEMP_REDIRECT */
-                  || responseCode == 308 /* HTTP_PERM_REDIRECT */))) {
-        // For 300, 301, 302, and 303 POST requests follow the redirect and are transformed into
-        // GET requests. For 307 and 308 POST requests are not redirected.
-        postBody = null;
-        String location = connection.getHeaderField("Location");
+      String location = connection.getHeaderField("Location");
+      if ((httpMethod == DataSpec.HTTP_METHOD_GET || httpMethod == DataSpec.HTTP_METHOD_HEAD)
+          && (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
+              || responseCode == HttpURLConnection.HTTP_MOVED_PERM
+              || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
+              || responseCode == HttpURLConnection.HTTP_SEE_OTHER
+              || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT
+              || responseCode == HTTP_STATUS_PERMANENT_REDIRECT)) {
+        connection.disconnect();
+        url = handleRedirect(url, location);
+      } else if (httpMethod == DataSpec.HTTP_METHOD_POST
+          && (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
+              || responseCode == HttpURLConnection.HTTP_MOVED_PERM
+              || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
+              || responseCode == HttpURLConnection.HTTP_SEE_OTHER)) {
+        // POST request follows the redirect and is transformed into a GET request.
         connection.disconnect();
+        httpMethod = DataSpec.HTTP_METHOD_GET;
+        httpBody = null;
         url = handleRedirect(url, location);
       } else {
         return connection;
@@ -382,14 +477,22 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
    * Configures a connection and opens it.
    *
    * @param url The url to connect to.
-   * @param postBody The body data for a POST request.
+   * @param httpMethod The http method.
+   * @param httpBody The body data.
    * @param position The byte offset of the requested data.
    * @param length The length of the requested data, or {@link C#LENGTH_UNSET}.
    * @param allowGzip Whether to allow the use of gzip.
    * @param followRedirects Whether to follow redirects.
    */
-  private HttpURLConnection makeConnection(URL url, byte[] postBody, long position,
-      long length, boolean allowGzip, boolean followRedirects) throws IOException {
+  private HttpURLConnection makeConnection(
+      URL url,
+      @HttpMethod int httpMethod,
+      byte[] httpBody,
+      long position,
+      long length,
+      boolean allowGzip,
+      boolean followRedirects)
+      throws IOException {
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setConnectTimeout(connectTimeoutMillis);
     connection.setReadTimeout(readTimeoutMillis);
@@ -413,18 +516,14 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
       connection.setRequestProperty("Accept-Encoding", "identity");
     }
     connection.setInstanceFollowRedirects(followRedirects);
-    connection.setDoOutput(postBody != null);
-    if (postBody != null) {
-      connection.setRequestMethod("POST");
-      if (postBody.length == 0) {
-        connection.connect();
-      } else  {
-        connection.setFixedLengthStreamingMode(postBody.length);
-        connection.connect();
-        OutputStream os = connection.getOutputStream();
-        os.write(postBody);
-        os.close();
-      }
+    connection.setDoOutput(httpBody != null);
+    connection.setRequestMethod(DataSpec.getStringForHttpMethod(httpMethod));
+    if (httpBody != null) {
+      connection.setFixedLengthStreamingMode(httpBody.length);
+      connection.connect();
+      OutputStream os = connection.getOutputStream();
+      os.write(httpBody);
+      os.close();
     } else {
       connection.connect();
     }
@@ -533,9 +632,7 @@ private void skipInternal() throws IOException {
         throw new EOFException();
       }
       bytesSkipped += read;
-      if (listener != null) {
-        listener.onBytesTransferred(this, read);
-      }
+      bytesTransferred(read);
     }
 
     // Release the shared skip buffer.
@@ -578,9 +675,7 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
     }
 
     bytesRead += read;
-    if (listener != null) {
-      listener.onBytesTransferred(this, read);
-    }
+    bytesTransferred(read);
     return read;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
index 3b3a5a1c16..95ea49132d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 
@@ -22,7 +23,7 @@
 public final class DefaultHttpDataSourceFactory extends BaseFactory {
 
   private final String userAgent;
-  private final TransferListener<? super DataSource> listener;
+  private final @Nullable TransferListener listener;
   private final int connectTimeoutMillis;
   private final int readTimeoutMillis;
   private final boolean allowCrossProtocolRedirects;
@@ -49,12 +50,33 @@ public DefaultHttpDataSourceFactory(String userAgent) {
    * @param listener An optional listener.
    * @see #DefaultHttpDataSourceFactory(String, TransferListener, int, int, boolean)
    */
-  public DefaultHttpDataSourceFactory(
-      String userAgent, TransferListener<? super DataSource> listener) {
+  public DefaultHttpDataSourceFactory(String userAgent, @Nullable TransferListener listener) {
     this(userAgent, listener, DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS,
         DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS, false);
   }
 
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param connectTimeoutMillis The connection timeout that should be used when requesting remote
+   *     data, in milliseconds. A timeout of zero is interpreted as an infinite timeout.
+   * @param readTimeoutMillis The read timeout that should be used when requesting remote data, in
+   *     milliseconds. A timeout of zero is interpreted as an infinite timeout.
+   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+   *     to HTTPS and vice versa) are enabled.
+   */
+  public DefaultHttpDataSourceFactory(
+      String userAgent,
+      int connectTimeoutMillis,
+      int readTimeoutMillis,
+      boolean allowCrossProtocolRedirects) {
+    this(
+        userAgent,
+        /* listener= */ null,
+        connectTimeoutMillis,
+        readTimeoutMillis,
+        allowCrossProtocolRedirects);
+  }
+
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param listener An optional listener.
@@ -65,9 +87,12 @@ public DefaultHttpDataSourceFactory(
    * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
    *     to HTTPS and vice versa) are enabled.
    */
-  public DefaultHttpDataSourceFactory(String userAgent,
-      TransferListener<? super DataSource> listener, int connectTimeoutMillis,
-      int readTimeoutMillis, boolean allowCrossProtocolRedirects) {
+  public DefaultHttpDataSourceFactory(
+      String userAgent,
+      @Nullable TransferListener listener,
+      int connectTimeoutMillis,
+      int readTimeoutMillis,
+      boolean allowCrossProtocolRedirects) {
     this.userAgent = userAgent;
     this.listener = listener;
     this.connectTimeoutMillis = connectTimeoutMillis;
@@ -78,8 +103,17 @@ public DefaultHttpDataSourceFactory(String userAgent,
   @Override
   protected DefaultHttpDataSource createDataSourceInternal(
       HttpDataSource.RequestProperties defaultRequestProperties) {
-    return new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
-        readTimeoutMillis, allowCrossProtocolRedirects, defaultRequestProperties);
+    DefaultHttpDataSource dataSource =
+        new DefaultHttpDataSource(
+            userAgent,
+            /* contentTypePredicate= */ null,
+            connectTimeoutMillis,
+            readTimeoutMillis,
+            allowCrossProtocolRedirects,
+            defaultRequestProperties);
+    if (listener != null) {
+      dataSource.addTransferListener(listener);
+    }
+    return dataSource;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
new file mode 100644
index 0000000000..e2c5f3ef88
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
+import java.io.IOException;
+
+/** Default implementation of {@link LoadErrorHandlingPolicy}. */
+public class DefaultLoadErrorHandlingPolicy implements LoadErrorHandlingPolicy {
+
+  /** The default minimum number of times to retry loading data prior to propagating the error. */
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+  /**
+   * The default minimum number of times to retry loading prior to failing for progressive live
+   * streams.
+   */
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT_PROGRESSIVE_LIVE = 6;
+  /** The default duration for which a track is blacklisted in milliseconds. */
+  public static final long DEFAULT_TRACK_BLACKLIST_MS = 60000;
+
+  private static final int DEFAULT_BEHAVIOR_MIN_LOADABLE_RETRY_COUNT = -1;
+
+  private final int minimumLoadableRetryCount;
+
+  /**
+   * Creates an instance with default behavior.
+   *
+   * <p>{@link #getMinimumLoadableRetryCount} will return {@link
+   * #DEFAULT_MIN_LOADABLE_RETRY_COUNT_PROGRESSIVE_LIVE} for {@code dataType} {@link
+   * C#DATA_TYPE_MEDIA_PROGRESSIVE_LIVE}. For other {@code dataType} values, it will return {@link
+   * #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+   */
+  public DefaultLoadErrorHandlingPolicy() {
+    this(DEFAULT_BEHAVIOR_MIN_LOADABLE_RETRY_COUNT);
+  }
+
+  /**
+   * Creates an instance with the given value for {@link #getMinimumLoadableRetryCount(int)}.
+   *
+   * @param minimumLoadableRetryCount See {@link #getMinimumLoadableRetryCount}.
+   */
+  public DefaultLoadErrorHandlingPolicy(int minimumLoadableRetryCount) {
+    this.minimumLoadableRetryCount = minimumLoadableRetryCount;
+  }
+
+  /**
+   * Blacklists resources whose load error was an {@link InvalidResponseCodeException} with response
+   * code HTTP 404 or 410. The duration of the blacklisting is {@link #DEFAULT_TRACK_BLACKLIST_MS}.
+   */
+  @Override
+  public long getBlacklistDurationMsFor(
+      int dataType, long loadDurationMs, IOException exception, int errorCount) {
+    if (exception instanceof InvalidResponseCodeException) {
+      int responseCode = ((InvalidResponseCodeException) exception).responseCode;
+      return responseCode == 404 // HTTP 404 Not Found.
+              || responseCode == 410 // HTTP 410 Gone.
+          ? DEFAULT_TRACK_BLACKLIST_MS
+          : C.TIME_UNSET;
+    }
+    return C.TIME_UNSET;
+  }
+
+  /**
+   * Retries for any exception that is not a subclass of {@link ParserException}. The retry delay is
+   * calculated as {@code Math.min((errorCount - 1) * 1000, 5000)}.
+   */
+  @Override
+  public long getRetryDelayMsFor(
+      int dataType, long loadDurationMs, IOException exception, int errorCount) {
+    return exception instanceof ParserException
+        ? C.TIME_UNSET
+        : Math.min((errorCount - 1) * 1000, 5000);
+  }
+
+  /**
+   * See {@link #DefaultLoadErrorHandlingPolicy()} and {@link #DefaultLoadErrorHandlingPolicy(int)}
+   * for documentation about the behavior of this method.
+   */
+  @Override
+  public int getMinimumLoadableRetryCount(int dataType) {
+    if (minimumLoadableRetryCount == DEFAULT_BEHAVIOR_MIN_LOADABLE_RETRY_COUNT) {
+      return dataType == C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE
+          ? DEFAULT_MIN_LOADABLE_RETRY_COUNT_PROGRESSIVE_LIVE
+          : DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+    } else {
+      return minimumLoadableRetryCount;
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
index fa3e14f1c9..13c5732a62 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import java.io.IOException;
 
 /**
@@ -26,15 +27,15 @@
   public static final DummyDataSource INSTANCE = new DummyDataSource();
 
   /** A factory that produces {@link DummyDataSource}. */
-  public static final Factory FACTORY = new Factory() {
-    @Override
-    public DataSource createDataSource() {
-      return new DummyDataSource();
-    }
-  };
+  public static final Factory FACTORY = DummyDataSource::new;
 
   private DummyDataSource() {}
 
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    // Do nothing.
+  }
+
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     throw new IOException("Dummy source");
@@ -46,7 +47,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return null;
   }
 
@@ -54,5 +55,4 @@ public Uri getUri() {
   public void close() throws IOException {
     // do nothing.
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index 898d2169b3..582b2b06da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -16,15 +16,14 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 
-/**
- * A {@link DataSource} for reading local files.
- */
-public final class FileDataSource implements DataSource {
+/** A {@link DataSource} for reading local files. */
+public final class FileDataSource extends BaseDataSource {
 
   /**
    * Thrown when IOException is encountered during local file read operation.
@@ -37,28 +36,32 @@ public FileDataSourceException(IOException cause) {
 
   }
 
-  private final TransferListener<? super FileDataSource> listener;
-
-  private RandomAccessFile file;
-  private Uri uri;
+  private @Nullable RandomAccessFile file;
+  private @Nullable Uri uri;
   private long bytesRemaining;
   private boolean opened;
 
   public FileDataSource() {
-    this(null);
+    super(/* isNetwork= */ false);
   }
 
   /**
    * @param listener An optional listener.
+   * @deprecated Use {@link #FileDataSource()} and {@link #addTransferListener(TransferListener)}
    */
-  public FileDataSource(TransferListener<? super FileDataSource> listener) {
-    this.listener = listener;
+  @Deprecated
+  public FileDataSource(@Nullable TransferListener listener) {
+    this();
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
   public long open(DataSpec dataSpec) throws FileDataSourceException {
     try {
       uri = dataSpec.uri;
+      transferInitializing(dataSpec);
       file = new RandomAccessFile(dataSpec.uri.getPath(), "r");
       file.seek(dataSpec.position);
       bytesRemaining = dataSpec.length == C.LENGTH_UNSET ? file.length() - dataSpec.position
@@ -71,9 +74,7 @@ public long open(DataSpec dataSpec) throws FileDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
 
     return bytesRemaining;
   }
@@ -94,9 +95,7 @@ public int read(byte[] buffer, int offset, int readLength) throws FileDataSource
 
       if (bytesRead > 0) {
         bytesRemaining -= bytesRead;
-        if (listener != null) {
-          listener.onBytesTransferred(this, bytesRead);
-        }
+        bytesTransferred(bytesRead);
       }
 
       return bytesRead;
@@ -104,7 +103,7 @@ public int read(byte[] buffer, int offset, int readLength) throws FileDataSource
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return uri;
   }
 
@@ -121,9 +120,7 @@ public void close() throws FileDataSourceException {
       file = null;
       if (opened) {
         opened = false;
-        if (listener != null) {
-          listener.onTransferEnd(this);
-        }
+        transferEnded();
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
index 2accbfc584..fd1920991e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
@@ -15,24 +15,30 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.support.annotation.Nullable;
+
 /**
  * A {@link DataSource.Factory} that produces {@link FileDataSource}.
  */
 public final class FileDataSourceFactory implements DataSource.Factory {
 
-  private final TransferListener<? super FileDataSource> listener;
+  private final @Nullable TransferListener listener;
 
   public FileDataSourceFactory() {
     this(null);
   }
 
-  public FileDataSourceFactory(TransferListener<? super FileDataSource> listener) {
+  public FileDataSourceFactory(@Nullable TransferListener listener) {
     this.listener = listener;
   }
 
   @Override
   public DataSource createDataSource() {
-    return new FileDataSource(listener);
+    FileDataSource dataSource = new FileDataSource();
+    if (listener != null) {
+      dataSource.addTransferListener(listener);
+    }
+    return dataSource;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index 3725fc0052..e3e93bd6fb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -16,10 +16,12 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -211,29 +213,26 @@ protected abstract HttpDataSource createDataSourceInternal(RequestProperties
 
   }
 
-  /**
-   * A {@link Predicate} that rejects content types often used for pay-walls.
-   */
-  Predicate<String> REJECT_PAYWALL_TYPES = new Predicate<String>() {
-
-    @Override
-    public boolean evaluate(String contentType) {
-      contentType = Util.toLowerInvariant(contentType);
-      return !TextUtils.isEmpty(contentType)
-          && (!contentType.contains("text") || contentType.contains("text/vtt"))
-          && !contentType.contains("html") && !contentType.contains("xml");
-    }
-
-  };
+  /** A {@link Predicate} that rejects content types often used for pay-walls. */
+  Predicate<String> REJECT_PAYWALL_TYPES =
+      contentType -> {
+        contentType = Util.toLowerInvariant(contentType);
+        return !TextUtils.isEmpty(contentType)
+            && (!contentType.contains("text") || contentType.contains("text/vtt"))
+            && !contentType.contains("html")
+            && !contentType.contains("xml");
+      };
 
   /**
    * Thrown when an error is encountered when trying to read from a {@link HttpDataSource}.
    */
   class HttpDataSourceException extends IOException {
 
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({TYPE_OPEN, TYPE_READ, TYPE_CLOSE})
     public @interface Type {}
+
     public static final int TYPE_OPEN = 1;
     public static final int TYPE_READ = 2;
     public static final int TYPE_CLOSE = 3;
@@ -296,15 +295,29 @@ public InvalidContentTypeException(String contentType, DataSpec dataSpec) {
      */
     public final int responseCode;
 
+    /** The http status message. */
+    @Nullable public final String responseMessage;
+
     /**
      * An unmodifiable map of the response header fields and values.
      */
     public final Map<String, List<String>> headerFields;
 
-    public InvalidResponseCodeException(int responseCode, Map<String, List<String>> headerFields,
+    /** @deprecated Use {@link #InvalidResponseCodeException(int, String, Map, DataSpec)}. */
+    @Deprecated
+    public InvalidResponseCodeException(
+        int responseCode, Map<String, List<String>> headerFields, DataSpec dataSpec) {
+      this(responseCode, /* responseMessage= */ null, headerFields, dataSpec);
+    }
+
+    public InvalidResponseCodeException(
+        int responseCode,
+        @Nullable String responseMessage,
+        Map<String, List<String>> headerFields,
         DataSpec dataSpec) {
       super("Response code: " + responseCode, dataSpec, TYPE_OPEN);
       this.responseCode = responseCode;
+      this.responseMessage = responseMessage;
       this.headerFields = headerFields;
     }
 
@@ -341,10 +354,6 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
    */
   void clearAllRequestProperties();
 
-  /**
-   * Returns the headers provided in the response, or {@code null} if response headers are
-   * unavailable.
-   */
+  @Override
   Map<String, List<String>> getResponseHeaders();
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.java
new file mode 100644
index 0000000000..3432935d5f
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.Loader.Callback;
+import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import java.io.IOException;
+
+/**
+ * Defines how errors encountered by {@link Loader Loaders} are handled.
+ *
+ * <p>Loader clients may blacklist a resource when a load error occurs. Blacklisting works around
+ * load errors by loading an alternative resource. Clients do not try blacklisting when a resource
+ * does not have an alternative. When a resource does have valid alternatives, {@link
+ * #getBlacklistDurationMsFor(int, long, IOException, int)} defines whether the resource should be
+ * blacklisted. Blacklisting will succeed if any of the alternatives is not in the black list.
+ *
+ * <p>When blacklisting does not take place, {@link #getRetryDelayMsFor(int, long, IOException,
+ * int)} defines whether the load is retried. Errors whose load is not retried are propagated. Load
+ * errors whose load is retried are propagated according to {@link
+ * #getMinimumLoadableRetryCount(int)}.
+ *
+ * <p>Methods are invoked on the playback thread.
+ */
+public interface LoadErrorHandlingPolicy {
+
+  /**
+   * Returns the number of milliseconds for which a resource associated to a provided load error
+   * should be blacklisted, or {@link C#TIME_UNSET} if the resource should not be blacklisted.
+   *
+   * @param dataType One of the {@link C C.DATA_TYPE_*} constants indicating the type of data to
+   *     load.
+   * @param loadDurationMs The duration in milliseconds of the load up to the point at which the
+   *     error occurred, including any previous attempts.
+   * @param exception The load error.
+   * @param errorCount The number of errors this load has encountered, including this one.
+   * @return The blacklist duration in milliseconds, or {@link C#TIME_UNSET} if the resource should
+   *     not be blacklisted.
+   */
+  long getBlacklistDurationMsFor(
+      int dataType, long loadDurationMs, IOException exception, int errorCount);
+
+  /**
+   * Returns the number of milliseconds to wait before attempting the load again, or {@link
+   * C#TIME_UNSET} if the error is fatal and should not be retried.
+   *
+   * <p>{@link Loader} clients may ignore the retry delay returned by this method in order to wait
+   * for a specific event before retrying. However, the load is retried if and only if this method
+   * does not return {@link C#TIME_UNSET}.
+   *
+   * @param dataType One of the {@link C C.DATA_TYPE_*} constants indicating the type of data to
+   *     load.
+   * @param loadDurationMs The duration in milliseconds of the load up to the point at which the
+   *     error occurred, including any previous attempts.
+   * @param exception The load error.
+   * @param errorCount The number of errors this load has encountered, including this one.
+   * @return The number of milliseconds to wait before attempting the load again, or {@link
+   *     C#TIME_UNSET} if the error is fatal and should not be retried.
+   */
+  long getRetryDelayMsFor(int dataType, long loadDurationMs, IOException exception, int errorCount);
+
+  /**
+   * Returns the minimum number of times to retry a load in the case of a load error, before
+   * propagating the error.
+   *
+   * @param dataType One of the {@link C C.DATA_TYPE_*} constants indicating the type of data to
+   *     load.
+   * @return The minimum number of times to retry a load in the case of a load error, before
+   *     propagating the error.
+   * @see Loader#startLoading(Loadable, Callback, int)
+   */
+  int getMinimumLoadableRetryCount(int dataType);
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 430948c875..ac3b3c5c5e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -22,11 +22,13 @@
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.util.Log;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.concurrent.ExecutorService;
@@ -74,27 +76,29 @@ public UnexpectedLoaderException(Throwable cause) {
 
     /**
      * Called when a load has completed.
-     * <p>
-     * Note: There is guaranteed to be a memory barrier between {@link Loadable#load()} exiting and
-     * this callback being called.
+     *
+     * <p>Note: There is guaranteed to be a memory barrier between {@link Loadable#load()} exiting
+     * and this callback being called.
      *
      * @param loadable The loadable whose load has completed.
      * @param elapsedRealtimeMs {@link SystemClock#elapsedRealtime} when the load ended.
-     * @param loadDurationMs The duration of the load.
+     * @param loadDurationMs The duration in milliseconds of the load since {@link #startLoading}
+     *     was called.
      */
     void onLoadCompleted(T loadable, long elapsedRealtimeMs, long loadDurationMs);
 
     /**
      * Called when a load has been canceled.
-     * <p>
-     * Note: If the {@link Loader} has not been released then there is guaranteed to be a memory
-     * barrier between {@link Loadable#load()} exiting and this callback being called. If the
-     * {@link Loader} has been released then this callback may be called before
-     * {@link Loadable#load()} exits.
+     *
+     * <p>Note: If the {@link Loader} has not been released then there is guaranteed to be a memory
+     * barrier between {@link Loadable#load()} exiting and this callback being called. If the {@link
+     * Loader} has been released then this callback may be called before {@link Loadable#load()}
+     * exits.
      *
      * @param loadable The loadable whose load has been canceled.
      * @param elapsedRealtimeMs {@link SystemClock#elapsedRealtime} when the load was canceled.
-     * @param loadDurationMs The duration of the load up to the point at which it was canceled.
+     * @param loadDurationMs The duration in milliseconds of the load since {@link #startLoading}
+     *     was called up to the point at which it was canceled.
      * @param released True if the load was canceled because the {@link Loader} was released. False
      *     otherwise.
      */
@@ -108,14 +112,16 @@ public UnexpectedLoaderException(Throwable cause) {
      *
      * @param loadable The loadable whose load has encountered an error.
      * @param elapsedRealtimeMs {@link SystemClock#elapsedRealtime} when the error occurred.
-     * @param loadDurationMs The duration of the load up to the point at which the error occurred.
+     * @param loadDurationMs The duration in milliseconds of the load since {@link #startLoading}
+     *     was called up to the point at which the error occurred.
      * @param error The load error.
-     * @return The desired retry action. One of {@link Loader#RETRY}, {@link
-     *     Loader#RETRY_RESET_ERROR_COUNT}, {@link Loader#DONT_RETRY} and {@link
-     *     Loader#DONT_RETRY_FATAL}.
+     * @param errorCount The number of errors this load has encountered, including this one.
+     * @return The desired error handling action. One of {@link Loader#RETRY}, {@link
+     *     Loader#RETRY_RESET_ERROR_COUNT}, {@link Loader#DONT_RETRY}, {@link
+     *     Loader#DONT_RETRY_FATAL} or a retry action created by {@link #createRetryAction}.
      */
-    @RetryAction
-    int onLoadError(T loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error);
+    LoadErrorAction onLoadError(
+        T loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error, int errorCount);
   }
 
   /**
@@ -130,15 +136,57 @@ public UnexpectedLoaderException(Throwable cause) {
 
   }
 
-  /** Actions that can be taken in response to a load error. */
+  /** Types of action that can be taken in response to a load error. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({RETRY, RETRY_RESET_ERROR_COUNT, DONT_RETRY, DONT_RETRY_FATAL})
-  public @interface RetryAction {}
+  @IntDef({
+    ACTION_TYPE_RETRY,
+    ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT,
+    ACTION_TYPE_DONT_RETRY,
+    ACTION_TYPE_DONT_RETRY_FATAL
+  })
+  private @interface RetryActionType {}
+
+  private static final int ACTION_TYPE_RETRY = 0;
+  private static final int ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT = 1;
+  private static final int ACTION_TYPE_DONT_RETRY = 2;
+  private static final int ACTION_TYPE_DONT_RETRY_FATAL = 3;
+
+  /** Retries the load using the default delay. */
+  public static final LoadErrorAction RETRY =
+      createRetryAction(/* resetErrorCount= */ false, C.TIME_UNSET);
+  /** Retries the load using the default delay and resets the error count. */
+  public static final LoadErrorAction RETRY_RESET_ERROR_COUNT =
+      createRetryAction(/* resetErrorCount= */ true, C.TIME_UNSET);
+  /** Discards the failed loading task and ignores any errors that have occurred. */
+  public static final LoadErrorAction DONT_RETRY =
+      new LoadErrorAction(ACTION_TYPE_DONT_RETRY, C.TIME_UNSET);
+  /**
+   * Discards the failed load. The next call to {@link #maybeThrowError()} will throw the last load
+   * error.
+   */
+  public static final LoadErrorAction DONT_RETRY_FATAL =
+      new LoadErrorAction(ACTION_TYPE_DONT_RETRY_FATAL, C.TIME_UNSET);
 
-  public static final int RETRY = 0;
-  public static final int RETRY_RESET_ERROR_COUNT = 1;
-  public static final int DONT_RETRY = 2;
-  public static final int DONT_RETRY_FATAL = 3;
+  /**
+   * Action that can be taken in response to {@link Callback#onLoadError(Loadable, long, long,
+   * IOException, int)}.
+   */
+  public static final class LoadErrorAction {
+
+    private final @RetryActionType int type;
+    private final long retryDelayMillis;
+
+    private LoadErrorAction(@RetryActionType int type, long retryDelayMillis) {
+      this.type = type;
+      this.retryDelayMillis = retryDelayMillis;
+    }
+
+    /** Returns whether this is a retry action. */
+    public boolean isRetry() {
+      return type == ACTION_TYPE_RETRY || type == ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT;
+    }
+  }
 
   private final ExecutorService downloadExecutorService;
 
@@ -152,6 +200,19 @@ public Loader(String threadName) {
     this.downloadExecutorService = Util.newSingleThreadExecutor(threadName);
   }
 
+  /**
+   * Creates a {@link LoadErrorAction} for retrying with the given parameters.
+   *
+   * @param resetErrorCount Whether the previous error count should be set to zero.
+   * @param retryDelayMillis The number of milliseconds to wait before retrying.
+   * @return A {@link LoadErrorAction} for retrying with the given parameters.
+   */
+  public static LoadErrorAction createRetryAction(boolean resetErrorCount, long retryDelayMillis) {
+    return new LoadErrorAction(
+        resetErrorCount ? ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT : ACTION_TYPE_RETRY,
+        retryDelayMillis);
+  }
+
   /**
    * Starts loading a {@link Loadable}.
    *
@@ -395,12 +456,19 @@ public void handleMessage(Message msg) {
           break;
         case MSG_IO_EXCEPTION:
           currentError = (IOException) msg.obj;
-          int retryAction = callback.onLoadError(loadable, nowMs, durationMs, currentError);
-          if (retryAction == DONT_RETRY_FATAL) {
+          errorCount++;
+          LoadErrorAction action =
+              callback.onLoadError(loadable, nowMs, durationMs, currentError, errorCount);
+          if (action.type == ACTION_TYPE_DONT_RETRY_FATAL) {
             fatalError = currentError;
-          } else if (retryAction != DONT_RETRY) {
-            errorCount = retryAction == RETRY_RESET_ERROR_COUNT ? 1 : errorCount + 1;
-            start(getRetryDelayMillis());
+          } else if (action.type != ACTION_TYPE_DONT_RETRY) {
+            if (action.type == ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT) {
+              errorCount = 1;
+            }
+            start(
+                action.retryDelayMillis != C.TIME_UNSET
+                    ? action.retryDelayMillis
+                    : getRetryDelayMillis());
           }
           break;
         default:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index 987effcf43..cdcb3787fa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -16,12 +16,16 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A {@link Loadable} for objects that can be parsed from binary data using a {@link Parser}.
@@ -52,16 +56,17 @@
    * Loads a single parsable object.
    *
    * @param dataSource The {@link DataSource} through which the object should be read.
+   * @param parser The {@link Parser} to parse the object from the response.
    * @param uri The {@link Uri} of the object to read.
+   * @param type The type of the data. One of the {@link C}{@code DATA_TYPE_*} constants.
    * @return The parsed object
    * @throws IOException Thrown if there is an error while loading or parsing.
    */
-  public static <T> T load(DataSource dataSource, Parser<? extends T> parser, Uri uri)
+  public static <T> T load(DataSource dataSource, Parser<? extends T> parser, Uri uri, int type)
       throws IOException {
-    ParsingLoadable<T> loadable =
-        new ParsingLoadable<>(dataSource, uri, C.DATA_TYPE_UNKNOWN, parser);
+    ParsingLoadable<T> loadable = new ParsingLoadable<>(dataSource, uri, type, parser);
     loadable.load();
-    return loadable.getResult();
+    return Assertions.checkNotNull(loadable.getResult());
   }
 
   /**
@@ -74,11 +79,10 @@
    */
   public final int type;
 
-  private final DataSource dataSource;
+  private final StatsDataSource dataSource;
   private final Parser<? extends T> parser;
 
-  private volatile T result;
-  private volatile long bytesLoaded;
+  private volatile @Nullable T result;
 
   /**
    * @param dataSource A {@link DataSource} to use when loading the data.
@@ -102,27 +106,40 @@ public ParsingLoadable(DataSource dataSource, Uri uri, int type, Parser<? extend
    */
   public ParsingLoadable(DataSource dataSource, DataSpec dataSpec, int type,
       Parser<? extends T> parser) {
-    this.dataSource = dataSource;
+    this.dataSource = new StatsDataSource(dataSource);
     this.dataSpec = dataSpec;
     this.type = type;
     this.parser = parser;
   }
 
-  /**
-   * Returns the loaded object, or null if an object has not been loaded.
-   */
-  public final T getResult() {
+  /** Returns the loaded object, or null if an object has not been loaded. */
+  public final @Nullable T getResult() {
     return result;
   }
 
   /**
    * Returns the number of bytes loaded. In the case that the network response was compressed, the
-   * value returned is the size of the data <em>after</em> decompression.
-   *
-   * @return The number of bytes loaded.
+   * value returned is the size of the data <em>after</em> decompression. Must only be called after
+   * the load completed, failed, or was canceled.
    */
   public long bytesLoaded() {
-    return bytesLoaded;
+    return dataSource.getBytesRead();
+  }
+
+  /**
+   * Returns the {@link Uri} from which data was read. If redirection occurred, this is the
+   * redirected uri. Must only be called after the load completed, failed, or was canceled.
+   */
+  public Uri getUri() {
+    return dataSource.getLastOpenedUri();
+  }
+
+  /**
+   * Returns the response headers associated with the load. Must only be called after the load
+   * completed, failed, or was canceled.
+   */
+  public Map<String, List<String>> getResponseHeaders() {
+    return dataSource.getLastResponseHeaders();
   }
 
   @Override
@@ -132,14 +149,15 @@ public final void cancelLoad() {
 
   @Override
   public final void load() throws IOException {
+    // We always load from the beginning, so reset bytesRead to 0.
+    dataSource.resetBytesRead();
     DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
     try {
       inputStream.open();
-      result = parser.parse(dataSource.getUri(), inputStream);
+      Uri dataSourceUri = Assertions.checkNotNull(dataSource.getUri());
+      result = parser.parse(dataSourceUri, inputStream);
     } finally {
-      bytesLoaded = inputStream.bytesRead();
       Util.closeQuietly(inputStream);
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
index 729f7fe179..9f9a3f9a91 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 import java.io.IOException;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A {@link DataSource} that can be used as part of a task registered with a
@@ -51,6 +53,11 @@ public PriorityDataSource(DataSource upstream, PriorityTaskManager priorityTaskM
     this.priority = priority;
   }
 
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstream.addTransferListener(transferListener);
+  }
+
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     priorityTaskManager.proceedOrThrow(priority);
@@ -68,6 +75,11 @@ public int read(byte[] buffer, int offset, int max) throws IOException {
     return upstream.getUri();
   }
 
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstream.getResponseHeaders();
+  }
+
   @Override
   public void close() throws IOException {
     upstream.close();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
index 1b58c7e095..7f51efda0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
@@ -19,6 +19,7 @@
 import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
@@ -28,12 +29,12 @@
 
 /**
  * A {@link DataSource} for reading a raw resource inside the APK.
- * <p>
- * URIs supported by this source are of the form {@code rawresource:///rawResourceId}, where
+ *
+ * <p>URIs supported by this source are of the form {@code rawresource:///rawResourceId}, where
  * rawResourceId is the integer identifier of a raw resource. {@link #buildRawResourceUri(int)} can
  * be used to build {@link Uri}s in this format.
  */
-public final class RawResourceDataSource implements DataSource {
+public final class RawResourceDataSource extends BaseDataSource {
 
   /**
    * Thrown when an {@link IOException} is encountered reading from a raw resource.
@@ -62,11 +63,10 @@ public static Uri buildRawResourceUri(int rawResourceId) {
   public static final String RAW_RESOURCE_SCHEME = "rawresource";
 
   private final Resources resources;
-  private final TransferListener<? super RawResourceDataSource> listener;
 
-  private Uri uri;
-  private AssetFileDescriptor assetFileDescriptor;
-  private InputStream inputStream;
+  private @Nullable Uri uri;
+  private @Nullable AssetFileDescriptor assetFileDescriptor;
+  private @Nullable InputStream inputStream;
   private long bytesRemaining;
   private boolean opened;
 
@@ -74,17 +74,22 @@ public static Uri buildRawResourceUri(int rawResourceId) {
    * @param context A context.
    */
   public RawResourceDataSource(Context context) {
-    this(context, null);
+    super(/* isNetwork= */ false);
+    this.resources = context.getResources();
   }
 
   /**
    * @param context A context.
    * @param listener An optional listener.
+   * @deprecated Use {@link #RawResourceDataSource(Context)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public RawResourceDataSource(Context context,
-      TransferListener<? super RawResourceDataSource> listener) {
-    this.resources = context.getResources();
-    this.listener = listener;
+  @Deprecated
+  public RawResourceDataSource(Context context, @Nullable TransferListener listener) {
+    this(context);
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
@@ -102,6 +107,7 @@ public long open(DataSpec dataSpec) throws RawResourceDataSourceException {
         throw new RawResourceDataSourceException("Resource identifier must be an integer.");
       }
 
+      transferInitializing(dataSpec);
       assetFileDescriptor = resources.openRawResourceFd(resourceId);
       inputStream = new FileInputStream(assetFileDescriptor.getFileDescriptor());
       inputStream.skip(assetFileDescriptor.getStartOffset());
@@ -124,9 +130,7 @@ public long open(DataSpec dataSpec) throws RawResourceDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
 
     return bytesRemaining;
   }
@@ -158,17 +162,16 @@ public int read(byte[] buffer, int offset, int readLength) throws RawResourceDat
     if (bytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining -= bytesRead;
     }
-    if (listener != null) {
-      listener.onBytesTransferred(this, bytesRead);
-    }
+    bytesTransferred(bytesRead);
     return bytesRead;
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return uri;
   }
 
+  @SuppressWarnings("Finally")
   @Override
   public void close() throws RawResourceDataSourceException {
     uri = null;
@@ -190,9 +193,7 @@ public void close() throws RawResourceDataSourceException {
         assetFileDescriptor = null;
         if (opened) {
           opened = false;
-          if (listener != null) {
-            listener.onTransferEnd(this);
-          }
+          transferEnded();
         }
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java
new file mode 100644
index 0000000000..04b29b531c
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * {@link DataSource} wrapper which keeps track of bytes transferred, redirected uris, and response
+ * headers.
+ */
+public final class StatsDataSource implements DataSource {
+
+  private final DataSource dataSource;
+
+  private long bytesRead;
+  private Uri lastOpenedUri;
+  private Map<String, List<String>> lastResponseHeaders;
+
+  /**
+   * Creates the stats data source.
+   *
+   * @param dataSource The wrapped {@link DataSource}.
+   */
+  public StatsDataSource(DataSource dataSource) {
+    this.dataSource = Assertions.checkNotNull(dataSource);
+    lastOpenedUri = Uri.EMPTY;
+    lastResponseHeaders = Collections.emptyMap();
+  }
+
+  /** Resets the number of bytes read as returned from {@link #getBytesRead()} to zero. */
+  public void resetBytesRead() {
+    bytesRead = 0;
+  }
+
+  /** Returns the total number of bytes that have been read from the data source. */
+  public long getBytesRead() {
+    return bytesRead;
+  }
+
+  /**
+   * Returns the {@link Uri} associated with the last {@link #open(DataSpec)} call. If redirection
+   * occurred, this is the redirected uri.
+   */
+  public Uri getLastOpenedUri() {
+    return lastOpenedUri;
+  }
+
+  /** Returns the response headers associated with the last {@link #open(DataSpec)} call. */
+  public Map<String, List<String>> getLastResponseHeaders() {
+    return lastResponseHeaders;
+  }
+
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    dataSource.addTransferListener(transferListener);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    // Reassign defaults in case dataSource.open throws an exception.
+    lastOpenedUri = dataSpec.uri;
+    lastResponseHeaders = Collections.emptyMap();
+    long availableBytes = dataSource.open(dataSpec);
+    lastOpenedUri = Assertions.checkNotNull(getUri());
+    lastResponseHeaders = getResponseHeaders();
+    return availableBytes;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    int bytesRead = dataSource.read(buffer, offset, readLength);
+    if (bytesRead != C.RESULT_END_OF_INPUT) {
+      this.bytesRead += bytesRead;
+    }
+    return bytesRead;
+  }
+
+  @Override
+  public @Nullable Uri getUri() {
+    return dataSource.getUri();
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return dataSource.getResponseHeaders();
+  }
+
+  @Override
+  public void close() throws IOException {
+    dataSource.close();
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
index 6fcb08e6b5..3c021b0b74 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
@@ -16,9 +16,12 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.util.List;
+import java.util.Map;
 
 /**
  * Tees data into a {@link DataSink} as the data is read.
@@ -40,6 +43,11 @@ public TeeDataSource(DataSource upstream, DataSink dataSink) {
     this.dataSink = Assertions.checkNotNull(dataSink);
   }
 
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstream.addTransferListener(transferListener);
+  }
+
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     bytesRemaining = upstream.open(dataSpec);
@@ -48,14 +56,7 @@ public long open(DataSpec dataSpec) throws IOException {
     }
     if (dataSpec.length == C.LENGTH_UNSET && bytesRemaining != C.LENGTH_UNSET) {
       // Reconstruct dataSpec in order to provide the resolved length to the sink.
-      dataSpec =
-          new DataSpec(
-              dataSpec.uri,
-              dataSpec.absoluteStreamPosition,
-              dataSpec.position,
-              bytesRemaining,
-              dataSpec.key,
-              dataSpec.flags);
+      dataSpec = dataSpec.subrange(0, bytesRemaining);
     }
     dataSinkNeedsClosing = true;
     dataSink.open(dataSpec);
@@ -79,10 +80,15 @@ public int read(byte[] buffer, int offset, int max) throws IOException {
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return upstream.getUri();
   }
 
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstream.getResponseHeaders();
+  }
+
   @Override
   public void close() throws IOException {
     try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java
index e061f0c7d0..a8971e71a4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java
@@ -17,31 +17,61 @@
 
 /**
  * A listener of data transfer events.
+ *
+ * <p>A transfer usually progresses through multiple steps:
+ *
+ * <ol>
+ *   <li>Initializing the underlying resource (e.g. opening a HTTP connection). {@link
+ *       #onTransferInitializing(DataSource, DataSpec, boolean)} is called before the initialization
+ *       starts.
+ *   <li>Starting the transfer after successfully initializing the resource. {@link
+ *       #onTransferStart(DataSource, DataSpec, boolean)} is called. Note that this only happens if
+ *       the initialization was successful.
+ *   <li>Transferring data. {@link #onBytesTransferred(DataSource, DataSpec, boolean, int)} is
+ *       called frequently during the transfer to indicate progress.
+ *   <li>Closing the transfer and the underlying resource. {@link #onTransferEnd(DataSource,
+ *       DataSpec, boolean)} is called. Note that each {@link #onTransferStart(DataSource, DataSpec,
+ *       boolean)} will have exactly one corresponding call to {@link #onTransferEnd(DataSource,
+ *       DataSpec, boolean)}.
+ * </ol>
  */
-public interface TransferListener<S> {
+public interface TransferListener {
+
+  /**
+   * Called when a transfer is being initialized.
+   *
+   * @param source The source performing the transfer.
+   * @param dataSpec Describes the data for which the transfer is initialized.
+   * @param isNetwork Whether the data is transferred through a network.
+   */
+  void onTransferInitializing(DataSource source, DataSpec dataSpec, boolean isNetwork);
 
   /**
    * Called when a transfer starts.
    *
    * @param source The source performing the transfer.
    * @param dataSpec Describes the data being transferred.
+   * @param isNetwork Whether the data is transferred through a network.
    */
-  void onTransferStart(S source, DataSpec dataSpec);
+  void onTransferStart(DataSource source, DataSpec dataSpec, boolean isNetwork);
 
   /**
    * Called incrementally during a transfer.
    *
    * @param source The source performing the transfer.
-   * @param bytesTransferred The number of bytes transferred since the previous call to this
-   *     method (or if the first call, since the transfer was started).
+   * @param dataSpec Describes the data being transferred.
+   * @param isNetwork Whether the data is transferred through a network.
+   * @param bytesTransferred The number of bytes transferred since the previous call to this method
    */
-  void onBytesTransferred(S source, int bytesTransferred);
+  void onBytesTransferred(
+      DataSource source, DataSpec dataSpec, boolean isNetwork, int bytesTransferred);
 
   /**
    * Called when a transfer ends.
    *
    * @param source The source performing the transfer.
+   * @param dataSpec Describes the data being transferred.
+   * @param isNetwork Whether the data is transferred through a network.
    */
-  void onTransferEnd(S source);
-
+  void onTransferEnd(DataSource source, DataSpec dataSpec, boolean isNetwork);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
index 68a04d9182..8d6b39fa98 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 import java.net.DatagramPacket;
@@ -25,10 +26,8 @@
 import java.net.MulticastSocket;
 import java.net.SocketException;
 
-/**
- * A UDP {@link DataSource}.
- */
-public final class UdpDataSource implements DataSource {
+/** A UDP {@link DataSource}. */
+public final class UdpDataSource extends BaseDataSource {
 
   /**
    * Thrown when an error is encountered when trying to read from a {@link UdpDataSource}.
@@ -46,52 +45,91 @@ public UdpDataSourceException(IOException cause) {
    */
   public static final int DEFAULT_MAX_PACKET_SIZE = 2000;
 
-  /**
-   * The default socket timeout, in milliseconds.
-   */
-  public static final int DEAFULT_SOCKET_TIMEOUT_MILLIS = 8 * 1000;
+  /** The default socket timeout, in milliseconds. */
+  public static final int DEFAULT_SOCKET_TIMEOUT_MILLIS = 8 * 1000;
 
-  private final TransferListener<? super UdpDataSource> listener;
   private final int socketTimeoutMillis;
   private final byte[] packetBuffer;
   private final DatagramPacket packet;
 
-  private Uri uri;
-  private DatagramSocket socket;
-  private MulticastSocket multicastSocket;
-  private InetAddress address;
-  private InetSocketAddress socketAddress;
+  private @Nullable Uri uri;
+  private @Nullable DatagramSocket socket;
+  private @Nullable MulticastSocket multicastSocket;
+  private @Nullable InetAddress address;
+  private @Nullable InetSocketAddress socketAddress;
   private boolean opened;
 
   private int packetRemaining;
 
+  public UdpDataSource() {
+    this(DEFAULT_MAX_PACKET_SIZE);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param maxPacketSize The maximum datagram packet size, in bytes.
+   */
+  public UdpDataSource(int maxPacketSize) {
+    this(maxPacketSize, DEFAULT_SOCKET_TIMEOUT_MILLIS);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param maxPacketSize The maximum datagram packet size, in bytes.
+   * @param socketTimeoutMillis The socket timeout in milliseconds. A timeout of zero is interpreted
+   *     as an infinite timeout.
+   */
+  public UdpDataSource(int maxPacketSize, int socketTimeoutMillis) {
+    super(/* isNetwork= */ true);
+    this.socketTimeoutMillis = socketTimeoutMillis;
+    packetBuffer = new byte[maxPacketSize];
+    packet = new DatagramPacket(packetBuffer, 0, maxPacketSize);
+  }
+
   /**
+   * Constructs a new instance.
+   *
    * @param listener An optional listener.
+   * @deprecated Use {@link #UdpDataSource()} and {@link #addTransferListener(TransferListener)}.
    */
-  public UdpDataSource(TransferListener<? super UdpDataSource> listener) {
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public UdpDataSource(@Nullable TransferListener listener) {
     this(listener, DEFAULT_MAX_PACKET_SIZE);
   }
 
   /**
+   * Constructs a new instance.
+   *
    * @param listener An optional listener.
    * @param maxPacketSize The maximum datagram packet size, in bytes.
+   * @deprecated Use {@link #UdpDataSource(int)} and {@link #addTransferListener(TransferListener)}.
    */
-  public UdpDataSource(TransferListener<? super UdpDataSource> listener, int maxPacketSize) {
-    this(listener, maxPacketSize, DEAFULT_SOCKET_TIMEOUT_MILLIS);
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public UdpDataSource(@Nullable TransferListener listener, int maxPacketSize) {
+    this(listener, maxPacketSize, DEFAULT_SOCKET_TIMEOUT_MILLIS);
   }
 
   /**
+   * Constructs a new instance.
+   *
    * @param listener An optional listener.
    * @param maxPacketSize The maximum datagram packet size, in bytes.
    * @param socketTimeoutMillis The socket timeout in milliseconds. A timeout of zero is interpreted
    *     as an infinite timeout.
+   * @deprecated Use {@link #UdpDataSource(int, int)} and {@link
+   *     #addTransferListener(TransferListener)}.
    */
-  public UdpDataSource(TransferListener<? super UdpDataSource> listener, int maxPacketSize,
-      int socketTimeoutMillis) {
-    this.listener = listener;
-    this.socketTimeoutMillis = socketTimeoutMillis;
-    packetBuffer = new byte[maxPacketSize];
-    packet = new DatagramPacket(packetBuffer, 0, maxPacketSize);
+  @Deprecated
+  public UdpDataSource(
+      @Nullable TransferListener listener, int maxPacketSize, int socketTimeoutMillis) {
+    this(maxPacketSize, socketTimeoutMillis);
+    if (listener != null) {
+      addTransferListener(listener);
+    }
   }
 
   @Override
@@ -99,7 +137,7 @@ public long open(DataSpec dataSpec) throws UdpDataSourceException {
     uri = dataSpec.uri;
     String host = uri.getHost();
     int port = uri.getPort();
-
+    transferInitializing(dataSpec);
     try {
       address = InetAddress.getByName(host);
       socketAddress = new InetSocketAddress(address, port);
@@ -121,9 +159,7 @@ public long open(DataSpec dataSpec) throws UdpDataSourceException {
     }
 
     opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+    transferStarted(dataSpec);
     return C.LENGTH_UNSET;
   }
 
@@ -141,9 +177,7 @@ public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceE
         throw new UdpDataSourceException(e);
       }
       packetRemaining = packet.getLength();
-      if (listener != null) {
-        listener.onBytesTransferred(this, packetRemaining);
-      }
+      bytesTransferred(packetRemaining);
     }
 
     int packetOffset = packet.getLength() - packetRemaining;
@@ -154,7 +188,7 @@ public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceE
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return uri;
   }
 
@@ -178,9 +212,7 @@ public void close() {
     packetRemaining = 0;
     if (opened) {
       opened = false;
-      if (listener != null) {
-        listener.onTransferEnd(this);
-      }
+      transferEnded();
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index 584939fdc7..b5b5dc64e6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import java.io.File;
 import java.io.IOException;
@@ -83,7 +82,7 @@ public CacheException(Throwable cause) {
    * Releases the cache. This method must be called when the cache is no longer required. The cache
    * must not be used after calling this method.
    */
-  void release() throws CacheException;
+  void release();
 
   /**
    * Registers a listener to listen for changes to a given key.
@@ -96,7 +95,6 @@ public CacheException(Throwable cause) {
    * @param listener The listener to add.
    * @return The current spans for the key.
    */
-  @NonNull
   NavigableSet<CacheSpan> addListener(String key, Listener listener);
 
   /**
@@ -113,7 +111,6 @@ public CacheException(Throwable cause) {
    * @param key The key for which spans should be returned.
    * @return The spans for the key.
    */
-  @NonNull
   NavigableSet<CacheSpan> getCachedSpans(String key);
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 045fc25338..3a96544c54 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -23,14 +23,20 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DataSpec.HttpMethod;
 import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.upstream.TeeDataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A {@link DataSource} that reads and writes a {@link Cache}. Requests are fulfilled from the cache
@@ -52,32 +58,43 @@
   public static final long DEFAULT_MAX_CACHE_FILE_SIZE = 2 * 1024 * 1024;
 
   /**
-   * Flags controlling the cache's behavior.
+   * Flags controlling the cache's behavior. Possible flag values are {@link #FLAG_BLOCK_ON_CACHE},
+   * {@link #FLAG_IGNORE_CACHE_ON_ERROR} and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_BLOCK_ON_CACHE, FLAG_IGNORE_CACHE_ON_ERROR,
-      FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS})
+  @IntDef(
+      flag = true,
+      value = {
+        FLAG_BLOCK_ON_CACHE,
+        FLAG_IGNORE_CACHE_ON_ERROR,
+        FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS
+      })
   public @interface Flags {}
   /**
    * A flag indicating whether we will block reads if the cache key is locked. If unset then data is
    * read from upstream if the cache key is locked, regardless of whether the data is cached.
    */
-  public static final int FLAG_BLOCK_ON_CACHE = 1 << 0;
+  public static final int FLAG_BLOCK_ON_CACHE = 1;
 
   /**
    * A flag indicating whether the cache is bypassed following any cache related error. If set
    * then cache related exceptions may be thrown for one cycle of open, read and close calls.
    * Subsequent cycles of these calls will then bypass the cache.
    */
-  public static final int FLAG_IGNORE_CACHE_ON_ERROR = 1 << 1;
+  public static final int FLAG_IGNORE_CACHE_ON_ERROR = 1 << 1; // 2
 
   /**
    * A flag indicating that the cache should be bypassed for requests whose lengths are unset. This
    * flag is provided for legacy reasons only.
    */
-  public static final int FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS = 1 << 2;
+  public static final int FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS = 1 << 2; // 4
 
-  /** Reasons the cache may be ignored. */
+  /**
+   * Reasons the cache may be ignored. One of {@link #CACHE_IGNORED_REASON_ERROR} or {@link
+   * #CACHE_IGNORED_REASON_UNSET_LENGTH}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({CACHE_IGNORED_REASON_ERROR, CACHE_IGNORED_REASON_UNSET_LENGTH})
   public @interface CacheIgnoredReason {}
@@ -117,23 +134,25 @@
 
   private final Cache cache;
   private final DataSource cacheReadDataSource;
-  private final DataSource cacheWriteDataSource;
+  private final @Nullable DataSource cacheWriteDataSource;
   private final DataSource upstreamDataSource;
+  private final CacheKeyFactory cacheKeyFactory;
   @Nullable private final EventListener eventListener;
 
   private final boolean blockOnCache;
   private final boolean ignoreCacheOnError;
   private final boolean ignoreCacheForUnsetLengthRequests;
 
-  private DataSource currentDataSource;
+  private @Nullable DataSource currentDataSource;
   private boolean currentDataSpecLengthUnset;
-  private Uri uri;
-  private Uri actualUri;
+  private @Nullable Uri uri;
+  private @Nullable Uri actualUri;
+  private @HttpMethod int httpMethod;
   private int flags;
-  private String key;
+  private @Nullable String key;
   private long readPosition;
   private long bytesRemaining;
-  private CacheSpan currentHoleSpan;
+  private @Nullable CacheSpan currentHoleSpan;
   private boolean seenCacheError;
   private boolean currentRequestIgnoresCache;
   private long totalCachedBytesRead;
@@ -178,8 +197,13 @@ public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags) {
    */
   public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
       long maxCacheFileSize) {
-    this(cache, upstream, new FileDataSource(), new CacheDataSink(cache, maxCacheFileSize),
-        flags, null);
+    this(
+        cache,
+        upstream,
+        new FileDataSource(),
+        new CacheDataSink(cache, maxCacheFileSize),
+        flags,
+        /* eventListener= */ null);
   }
 
   /**
@@ -198,8 +222,43 @@ public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
    */
   public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDataSource,
       DataSink cacheWriteDataSink, @Flags int flags, @Nullable EventListener eventListener) {
+    this(
+        cache,
+        upstream,
+        cacheReadDataSource,
+        cacheWriteDataSink,
+        flags,
+        eventListener,
+        /* cacheKeyFactory= */ null);
+  }
+
+  /**
+   * Constructs an instance with arbitrary {@link DataSource} and {@link DataSink} instances for
+   * reading and writing the cache. One use of this constructor is to allow data to be transformed
+   * before it is written to disk.
+   *
+   * @param cache The cache.
+   * @param upstream A {@link DataSource} for reading data not in the cache.
+   * @param cacheReadDataSource A {@link DataSource} for reading data from the cache.
+   * @param cacheWriteDataSink A {@link DataSink} for writing data to the cache. If null, cache is
+   *     accessed read-only.
+   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
+   *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
+   * @param eventListener An optional {@link EventListener} to receive events.
+   * @param cacheKeyFactory An optional factory for cache keys.
+   */
+  public CacheDataSource(
+      Cache cache,
+      DataSource upstream,
+      DataSource cacheReadDataSource,
+      DataSink cacheWriteDataSink,
+      @Flags int flags,
+      @Nullable EventListener eventListener,
+      @Nullable CacheKeyFactory cacheKeyFactory) {
     this.cache = cache;
     this.cacheReadDataSource = cacheReadDataSource;
+    this.cacheKeyFactory =
+        cacheKeyFactory != null ? cacheKeyFactory : CacheUtil.DEFAULT_CACHE_KEY_FACTORY;
     this.blockOnCache = (flags & FLAG_BLOCK_ON_CACHE) != 0;
     this.ignoreCacheOnError = (flags & FLAG_IGNORE_CACHE_ON_ERROR) != 0;
     this.ignoreCacheForUnsetLengthRequests =
@@ -213,12 +272,19 @@ public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDat
     this.eventListener = eventListener;
   }
 
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    cacheReadDataSource.addTransferListener(transferListener);
+    upstreamDataSource.addTransferListener(transferListener);
+  }
+
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     try {
-      key = CacheUtil.getKey(dataSpec);
+      key = cacheKeyFactory.buildCacheKey(dataSpec);
       uri = dataSpec.uri;
       actualUri = getRedirectedUriOrDefault(cache, key, /* defaultUri= */ uri);
+      httpMethod = dataSpec.httpMethod;
       flags = dataSpec.flags;
       readPosition = dataSpec.position;
 
@@ -287,14 +353,23 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
   }
 
   @Override
-  public Uri getUri() {
+  public @Nullable Uri getUri() {
     return actualUri;
   }
 
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    // TODO: Implement.
+    return isReadingFromUpstream()
+        ? upstreamDataSource.getResponseHeaders()
+        : Collections.emptyMap();
+  }
+
   @Override
   public void close() throws IOException {
     uri = null;
     actualUri = null;
+    httpMethod = DataSpec.HTTP_METHOD_GET;
     notifyBytesRead();
     try {
       closeCurrentSource();
@@ -339,7 +414,9 @@ private void openNextSource(boolean checkCache) throws IOException {
       // The data is locked in the cache, or we're ignoring the cache. Bypass the cache and read
       // from upstream.
       nextDataSource = upstreamDataSource;
-      nextDataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
+      nextDataSpec =
+          new DataSpec(
+              uri, httpMethod, null, readPosition, readPosition, bytesRemaining, key, flags);
     } else if (nextSpan.isCached) {
       // Data is cached, read from cache.
       Uri fileUri = Uri.fromFile(nextSpan.file);
@@ -361,7 +438,8 @@ private void openNextSource(boolean checkCache) throws IOException {
           length = Math.min(length, bytesRemaining);
         }
       }
-      nextDataSpec = new DataSpec(uri, readPosition, length, key, flags);
+      nextDataSpec =
+          new DataSpec(uri, httpMethod, null, readPosition, readPosition, length, key, flags);
       if (cacheWriteDataSource != null) {
         nextDataSource = cacheWriteDataSource;
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderException.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheKeyFactory.java
similarity index 50%
rename from library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderException.java
rename to library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheKeyFactory.java
index 433a656982..bfa404c074 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheKeyFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2018 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,26 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.metadata;
+package com.google.android.exoplayer2.upstream.cache;
 
-/**
- * Thrown when an error occurs decoding metadata.
- */
-public class MetadataDecoderException extends Exception {
+import com.google.android.exoplayer2.upstream.DataSpec;
 
-  /**
-   * @param message The detail message for this exception.
-   */
-  public MetadataDecoderException(String message) {
-    super(message);
-  }
+/** Factory for cache keys. */
+public interface CacheKeyFactory {
 
   /**
-   * @param message The detail message for this exception.
-   * @param cause The cause of this exception.
+   * Returns a cache key for the given {@link DataSpec}.
+   *
+   * @param dataSpec The data being cached.
    */
-  public MetadataDecoderException(String message, Throwable cause) {
-    super(message, cause);
-  }
-
+  String buildCacheKey(DataSpec dataSpec);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index c46fcd87a5..cee22375a9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -54,6 +54,9 @@ public long totalCachedBytes() {
   /** Default buffer size to be used while caching. */
   public static final int DEFAULT_BUFFER_SIZE_BYTES = 128 * 1024;
 
+  /** Default {@link CacheKeyFactory} that calls through to {@link #getKey}. */
+  public static final CacheKeyFactory DEFAULT_CACHE_KEY_FACTORY = CacheUtil::getKey;
+
   /**
    * Generates a cache key out of the given {@link Uri}.
    *
@@ -186,9 +189,7 @@ public static void cache(
     long start = dataSpec.absoluteStreamPosition;
     long left = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : cache.getContentLength(key);
     while (left != 0) {
-      if (isCanceled != null && isCanceled.get()) {
-        throw new InterruptedException();
-      }
+      throwExceptionIfInterruptedOrCancelled(isCanceled);
       long blockLength =
           cache.getCachedLength(key, start, left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
       if (blockLength > 0) {
@@ -196,8 +197,17 @@ public static void cache(
       } else {
         // There is a hole in the cache which is at least "-blockLength" long.
         blockLength = -blockLength;
-        long read = readAndDiscard(dataSpec, start, blockLength, dataSource, buffer,
-            priorityTaskManager, priority, counters);
+        long read =
+            readAndDiscard(
+                dataSpec,
+                start,
+                blockLength,
+                dataSource,
+                buffer,
+                priorityTaskManager,
+                priority,
+                counters,
+                isCanceled);
         if (read < blockLength) {
           // Reached to the end of the data.
           if (enableEOFException && left != C.LENGTH_UNSET) {
@@ -224,36 +234,47 @@ public static void cache(
    *     caching.
    * @param priority The priority of this task.
    * @param counters Counters to be set during reading.
+   * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @return Number of read bytes, or 0 if no data is available because the end of the opened range
    *     has been reached.
    */
-  private static long readAndDiscard(DataSpec dataSpec, long absoluteStreamPosition, long length,
-      DataSource dataSource, byte[] buffer, PriorityTaskManager priorityTaskManager, int priority,
-      CachingCounters counters) throws IOException, InterruptedException {
+  private static long readAndDiscard(
+      DataSpec dataSpec,
+      long absoluteStreamPosition,
+      long length,
+      DataSource dataSource,
+      byte[] buffer,
+      PriorityTaskManager priorityTaskManager,
+      int priority,
+      CachingCounters counters,
+      AtomicBoolean isCanceled)
+      throws IOException, InterruptedException {
     while (true) {
       if (priorityTaskManager != null) {
         // Wait for any other thread with higher priority to finish its job.
         priorityTaskManager.proceed(priority);
       }
       try {
-        if (Thread.interrupted()) {
-          throw new InterruptedException();
-        }
+        throwExceptionIfInterruptedOrCancelled(isCanceled);
         // Create a new dataSpec setting length to C.LENGTH_UNSET to prevent getting an error in
         // case the given length exceeds the end of input.
-        dataSpec = new DataSpec(dataSpec.uri, dataSpec.postBody, absoluteStreamPosition,
-            dataSpec.position + absoluteStreamPosition - dataSpec.absoluteStreamPosition,
-            C.LENGTH_UNSET, dataSpec.key,
-            dataSpec.flags | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+        dataSpec =
+            new DataSpec(
+                dataSpec.uri,
+                dataSpec.httpMethod,
+                dataSpec.httpBody,
+                absoluteStreamPosition,
+                dataSpec.position + absoluteStreamPosition - dataSpec.absoluteStreamPosition,
+                C.LENGTH_UNSET,
+                dataSpec.key,
+                dataSpec.flags | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
         long resolvedLength = dataSource.open(dataSpec);
         if (counters.contentLength == C.LENGTH_UNSET && resolvedLength != C.LENGTH_UNSET) {
           counters.contentLength = dataSpec.absoluteStreamPosition + resolvedLength;
         }
         long totalRead = 0;
         while (totalRead != length) {
-          if (Thread.interrupted()) {
-            throw new InterruptedException();
-          }
+          throwExceptionIfInterruptedOrCancelled(isCanceled);
           int read = dataSource.read(buffer, 0,
               length != C.LENGTH_UNSET ? (int) Math.min(buffer.length, length - totalRead)
                   : buffer.length);
@@ -287,6 +308,13 @@ public static void remove(Cache cache, String key) {
     }
   }
 
+  private static void throwExceptionIfInterruptedOrCancelled(AtomicBoolean isCanceled)
+      throws InterruptedException {
+    if (Thread.interrupted() || (isCanceled != null && isCanceled.get())) {
+      throw new InterruptedException();
+    }
+  }
+
   private CacheUtil() {}
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
index 89835f31de..97a7828a22 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
@@ -185,16 +185,13 @@ public long getCachedBytesLength(long position, long length) {
    * @throws CacheException If renaming of the underlying span file failed.
    */
   public SimpleCacheSpan touch(SimpleCacheSpan cacheSpan) throws CacheException {
-    // Remove the old span from the in-memory representation.
-    Assertions.checkState(cachedSpans.remove(cacheSpan));
-    // Obtain a new span with updated last access timestamp.
     SimpleCacheSpan newCacheSpan = cacheSpan.copyWithUpdatedLastAccessTime(id);
-    // Rename the cache file
     if (!cacheSpan.file.renameTo(newCacheSpan.file)) {
       throw new CacheException("Renaming of " + cacheSpan.file + " to " + newCacheSpan.file
           + " failed.");
     }
-    // Add the updated span back into the in-memory representation.
+    // Replace the in-memory representation of the span.
+    Assertions.checkState(cachedSpans.remove(cacheSpan));
     cachedSpans.add(newCacheSpan);
     return newCacheSpan;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 3bcfac5053..43e6730844 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.util.SparseArray;
+import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.AtomicFile;
@@ -41,6 +42,7 @@
 import javax.crypto.NoSuchPaddingException;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** Maintains the index of cached content. */
 /*package*/ class CachedContentIndex {
@@ -52,7 +54,30 @@
   private static final int FLAG_ENCRYPTED_INDEX = 1;
 
   private final HashMap<String, CachedContent> keyToContent;
-  private final SparseArray<String> idToKey;
+  /**
+   * Maps assigned ids to their corresponding keys. Also contains (id -> null) entries for ids that
+   * have been removed from the index since it was last stored. This prevents reuse of these ids,
+   * which is necessary to avoid clashes that could otherwise occur as a result of the sequence:
+   *
+   * <p>[1] (key1, id1) is removed from the in-memory index ... the index is not stored to disk ...
+   * [2] id1 is reused for a different key2 ... the index is not stored to disk ... [3] A file for
+   * key2 is partially written using a path corresponding to id1 ... the process is killed before
+   * the index is stored to disk ... [4] The index is read from disk, causing the partially written
+   * file to be incorrectly associated to key1
+   *
+   * <p>By avoiding id reuse in step [2], a new id2 will be used instead. Step [4] will then delete
+   * the partially written file because the index does not contain an entry for id2.
+   *
+   * <p>When the index is next stored (id -> null) entries are removed, making the ids eligible for
+   * reuse.
+   */
+  private final SparseArray<@NullableType String> idToKey;
+  /**
+   * Tracks ids for which (id -> null) entries are present in idToKey, so that they can be removed
+   * efficiently when the index is next stored.
+   */
+  private final SparseBooleanArray removedIds;
+
   private final AtomicFile atomicFile;
   private final Cipher cipher;
   private final SecretKeySpec secretKeySpec;
@@ -104,6 +129,7 @@ public CachedContentIndex(File cacheDir, byte[] secretKey, boolean encrypt) {
     }
     keyToContent = new HashMap<>();
     idToKey = new SparseArray<>();
+    removedIds = new SparseBooleanArray();
     atomicFile = new AtomicFile(new File(cacheDir, FILE_NAME));
   }
 
@@ -124,6 +150,12 @@ public void store() throws CacheException {
     }
     writeFile();
     changed = false;
+    // Make ids that were removed since the index was last stored eligible for re-use.
+    int removedIdCount = removedIds.size();
+    for (int i = 0; i < removedIdCount; i++) {
+      idToKey.remove(removedIds.keyAt(i));
+    }
+    removedIds.clear();
   }
 
   /**
@@ -168,8 +200,11 @@ public void maybeRemove(String key) {
     CachedContent cachedContent = keyToContent.get(key);
     if (cachedContent != null && cachedContent.isEmpty() && !cachedContent.isLocked()) {
       keyToContent.remove(key);
-      idToKey.remove(cachedContent.id);
       changed = true;
+      // Keep an entry in idToKey to stop the id from being reused until the index is next stored.
+      idToKey.put(cachedContent.id, /* value= */ null);
+      // Track that the entry should be removed from idToKey when the index is next stored.
+      removedIds.put(cachedContent.id, /* value= */ true);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
index 9455aed11b..6d090d073e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.support.annotation.NonNull;
-import android.util.Log;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.util.Log;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NavigableSet;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java
index aefb0f6852..e16ff5483a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java
@@ -34,7 +34,7 @@
 
   /** An empty DefaultContentMetadata. */
   public static final DefaultContentMetadata EMPTY =
-      new DefaultContentMetadata(Collections.<String, byte[]>emptyMap());
+      new DefaultContentMetadata(Collections.emptyMap());
 
   private static final int MAX_VALUE_LENGTH = 10 * 1024 * 1024;
   private int hashCode;
@@ -188,9 +188,12 @@ private static void addValues(HashMap<String, byte[]> metadata, Map<String, Obje
       byte[] bytes = getBytes(value);
       if (bytes.length > MAX_VALUE_LENGTH) {
         throw new IllegalArgumentException(
-            String.format(
-                "The size of %s (%d) is greater than maximum allowed: %d",
-                name, bytes.length, MAX_VALUE_LENGTH));
+            "The size of "
+                + name
+                + " ("
+                + bytes.length
+                + ") is greater than maximum allowed: "
+                + MAX_VALUE_LENGTH);
       }
       metadata.put(name, bytes);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index 7d2d5b79a9..ab60be2b4b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -17,9 +17,10 @@
 
 import android.os.ConditionVariable;
 import android.support.annotation.NonNull;
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -145,13 +146,16 @@ public void run() {
   }
 
   @Override
-  public synchronized void release() throws CacheException {
+  public synchronized void release() {
     if (released) {
       return;
     }
     listeners.clear();
+    removeStaleSpans();
     try {
-      removeStaleSpansAndCachedContents();
+      index.store();
+    } catch (CacheException e) {
+      Log.e(TAG, "Storing index file failed", e);
     } finally {
       unlockFolder(cacheDir);
       released = true;
@@ -190,7 +194,7 @@ public synchronized void removeListener(String key, Listener listener) {
     Assertions.checkState(!released);
     CachedContent cachedContent = index.get(key);
     return cachedContent == null || cachedContent.isEmpty()
-        ? new TreeSet<CacheSpan>()
+        ? new TreeSet<>()
         : new TreeSet<CacheSpan>(cachedContent.getSpans());
   }
 
@@ -224,17 +228,23 @@ public synchronized SimpleCacheSpan startReadWrite(String key, long position)
   }
 
   @Override
-  public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
+  public synchronized @Nullable SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
       throws CacheException {
     Assertions.checkState(!released);
     SimpleCacheSpan cacheSpan = getSpan(key, position);
 
     // Read case.
     if (cacheSpan.isCached) {
-      // Obtain a new span with updated last access timestamp.
-      SimpleCacheSpan newCacheSpan = index.get(key).touch(cacheSpan);
-      notifySpanTouched(cacheSpan, newCacheSpan);
-      return newCacheSpan;
+      try {
+        // Obtain a new span with updated last access timestamp.
+        SimpleCacheSpan newCacheSpan = index.get(key).touch(cacheSpan);
+        notifySpanTouched(cacheSpan, newCacheSpan);
+        return newCacheSpan;
+      } catch (CacheException e) {
+        // Ignore. In worst case the cache span is evicted early.
+        // This happens very rarely [Internal: b/38351639]
+        return cacheSpan;
+      }
     }
 
     CachedContent cachedContent = index.getOrAdd(key);
@@ -258,7 +268,7 @@ public synchronized File startFile(String key, long position, long maxLength)
     if (!cacheDir.exists()) {
       // For some reason the cache directory doesn't exist. Make a best effort to create it.
       cacheDir.mkdirs();
-      removeStaleSpansAndCachedContents();
+      removeStaleSpans();
     }
     evictor.onStartFile(this, key, position, maxLength);
     return SimpleCacheSpan.getCacheFile(
@@ -304,9 +314,9 @@ public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
   }
 
   @Override
-  public synchronized void removeSpan(CacheSpan span) throws CacheException {
+  public synchronized void removeSpan(CacheSpan span) {
     Assertions.checkState(!released);
-    removeSpan(span, true);
+    removeSpanInternal(span);
   }
 
   @Override
@@ -372,7 +382,7 @@ private SimpleCacheSpan getSpan(String key, long position) throws CacheException
       if (span.isCached && !span.file.exists()) {
         // The file has been deleted from under us. It's likely that other files will have been
         // deleted too, so scan the whole in-memory representation.
-        removeStaleSpansAndCachedContents();
+        removeStaleSpans();
         continue;
       }
       return span;
@@ -424,27 +434,21 @@ private void addSpan(SimpleCacheSpan span) {
     notifySpanAdded(span);
   }
 
-  private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws CacheException {
+  private void removeSpanInternal(CacheSpan span) {
     CachedContent cachedContent = index.get(span.key);
     if (cachedContent == null || !cachedContent.removeSpan(span)) {
       return;
     }
     totalSpace -= span.length;
-    try {
-      if (removeEmptyCachedContent) {
-        index.maybeRemove(cachedContent.key);
-        index.store();
-      }
-    } finally {
-      notifySpanRemoved(span);
-    }
+    index.maybeRemove(cachedContent.key);
+    notifySpanRemoved(span);
   }
 
   /**
    * Scans all of the cached spans in the in-memory representation, removing any for which files no
    * longer exist.
    */
-  private void removeStaleSpansAndCachedContents() throws CacheException {
+  private void removeStaleSpans() {
     ArrayList<CacheSpan> spansToBeRemoved = new ArrayList<>();
     for (CachedContent cachedContent : index.getAll()) {
       for (CacheSpan span : cachedContent.getSpans()) {
@@ -454,11 +458,8 @@ private void removeStaleSpansAndCachedContents() throws CacheException {
       }
     }
     for (int i = 0; i < spansToBeRemoved.size(); i++) {
-      // Remove span but not CachedContent to prevent multiple index.store() calls.
-      removeSpan(spansToBeRemoved.get(i), false);
+      removeSpanInternal(spansToBeRemoved.get(i));
     }
-    index.removeEmpty();
-    index.store();
   }
 
   private void notifySpanRemoved(CacheSpan span) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
index 26ac3b38fa..801c84dc51 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
@@ -16,10 +16,14 @@
 package com.google.android.exoplayer2.upstream.crypto;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
+import java.util.List;
+import java.util.Map;
 import javax.crypto.Cipher;
 
 /**
@@ -30,13 +34,18 @@
   private final DataSource upstream;
   private final byte[] secretKey;
 
-  private AesFlushingCipher cipher;
+  private @Nullable AesFlushingCipher cipher;
 
   public AesCipherDataSource(byte[] secretKey, DataSource upstream) {
     this.upstream = upstream;
     this.secretKey = secretKey;
   }
 
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstream.addTransferListener(transferListener);
+  }
+
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     long dataLength = upstream.open(dataSpec);
@@ -60,14 +69,18 @@ public int read(byte[] data, int offset, int readLength) throws IOException {
   }
 
   @Override
-  public void close() throws IOException {
-    cipher = null;
-    upstream.close();
+  public @Nullable Uri getUri() {
+    return upstream.getUri();
   }
 
   @Override
-  public Uri getUri() {
-    return upstream.getUri();
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstream.getResponseHeaders();
   }
 
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    upstream.close();
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
index 53c196a14f..c6ad5dfe52 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
@@ -104,6 +104,7 @@ public static void checkState(boolean expression, Object errorMessage) {
    * @return The non-null reference that was validated.
    * @throws NullPointerException If {@code reference} is null.
    */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
   @EnsuresNonNull({"#1"})
   public static <T> T checkNotNull(@Nullable T reference) {
     if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && reference == null) {
@@ -122,6 +123,7 @@ public static void checkState(boolean expression, Object errorMessage) {
    * @return The non-null reference that was validated.
    * @throws NullPointerException If {@code reference} is null.
    */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
   @EnsuresNonNull({"#1"})
   public static <T> T checkNotNull(@Nullable T reference, Object errorMessage) {
     if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && reference == null) {
@@ -137,6 +139,7 @@ public static void checkState(boolean expression, Object errorMessage) {
    * @return The non-null, non-empty string that was validated.
    * @throws IllegalArgumentException If {@code string} is null or 0-length.
    */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
   @EnsuresNonNull({"#1"})
   public static String checkNotEmpty(@Nullable String string) {
     if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && TextUtils.isEmpty(string)) {
@@ -154,6 +157,7 @@ public static String checkNotEmpty(@Nullable String string) {
    * @return The non-null, non-empty string that was validated.
    * @throws IllegalArgumentException If {@code string} is null or 0-length.
    */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
   @EnsuresNonNull({"#1"})
   public static String checkNotEmpty(@Nullable String string, Object errorMessage) {
     if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && TextUtils.isEmpty(string)) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
index b33fc2b922..4bdee5ceea 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.util;
 
 import android.support.annotation.NonNull;
-import android.util.Log;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -103,7 +102,7 @@ public OutputStream startWrite() throws IOException {
       str = new AtomicFileOutputStream(baseName);
     } catch (FileNotFoundException e) {
       File parent = baseName.getParentFile();
-      if (!parent.mkdirs()) {
+      if (parent == null || !parent.mkdirs()) {
         throw new IOException("Couldn't create directory " + baseName, e);
       }
       try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
index 0514d9dbdc..627cf7e070 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.support.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
@@ -204,6 +205,21 @@ private CodecSpecificDataUtil() {}
     return specificConfig;
   }
 
+  /**
+   * Builds an RFC 6381 AVC codec string using the provided parameters.
+   *
+   * @param profileIdc The encoding profile.
+   * @param constraintsFlagsAndReservedZero2Bits The constraint flags followed by the reserved zero
+   *     2 bits, all contained in the least significant byte of the integer.
+   * @param levelIdc The encoding level.
+   * @return An RFC 6381 AVC codec string built using the provided parameters.
+   */
+  public static String buildAvcCodecString(
+      int profileIdc, int constraintsFlagsAndReservedZero2Bits, int levelIdc) {
+    return String.format(
+        "avc1.%02X%02X%02X", profileIdc, constraintsFlagsAndReservedZero2Bits, levelIdc);
+  }
+
   /**
    * Constructs a NAL unit consisting of the NAL start code followed by the specified data.
    *
@@ -221,8 +237,8 @@ private CodecSpecificDataUtil() {}
 
   /**
    * Splits an array of NAL units.
-   * <p>
-   * If the input consists of NAL start code delimited units, then the returned array consists of
+   *
+   * <p>If the input consists of NAL start code delimited units, then the returned array consists of
    * the split NAL units, each of which is still prefixed with the NAL start code. For any other
    * input, null is returned.
    *
@@ -230,7 +246,7 @@ private CodecSpecificDataUtil() {}
    * @return The individual NAL units, or null if the input did not consist of NAL start code
    *     delimited units.
    */
-  public static byte[][] splitNalUnits(byte[] data) {
+  public static @Nullable byte[][] splitNalUnits(byte[] data) {
     if (!isNalStartCode(data, 0)) {
       // data does not consist of NAL start code delimited units.
       return null;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
index 4bed17fc55..deb981f0e8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
@@ -26,6 +26,7 @@
 import android.os.Handler;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -33,7 +34,17 @@
 @TargetApi(17)
 public final class EGLSurfaceTexture implements SurfaceTexture.OnFrameAvailableListener, Runnable {
 
-  /** Secure mode to be used by the EGL surface and context. */
+  /** Listener to be called when the texture image on {@link SurfaceTexture} has been updated. */
+  public interface TextureImageListener {
+    /** Called when the {@link SurfaceTexture} receives a new frame from its image producer. */
+    void onFrameAvailable();
+  }
+
+  /**
+   * Secure mode to be used by the EGL surface and context. One of {@link #SECURE_MODE_NONE}, {@link
+   * #SECURE_MODE_SURFACELESS_CONTEXT} or {@link #SECURE_MODE_PROTECTED_PBUFFER}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({SECURE_MODE_NONE, SECURE_MODE_SURFACELESS_CONTEXT, SECURE_MODE_PROTECTED_PBUFFER})
   public @interface SecureMode {}
@@ -45,6 +56,9 @@
   /** Creating a secure surface backed by a pixel buffer. */
   public static final int SECURE_MODE_PROTECTED_PBUFFER = 2;
 
+  private static final int EGL_SURFACE_WIDTH = 1;
+  private static final int EGL_SURFACE_HEIGHT = 1;
+
   private static final int[] EGL_CONFIG_ATTRIBUTES =
       new int[] {
         EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,
@@ -69,6 +83,7 @@ private GlException(String msg) {
 
   private final Handler handler;
   private final int[] textureIdHolder;
+  private final @Nullable TextureImageListener callback;
 
   private @Nullable EGLDisplay display;
   private @Nullable EGLContext context;
@@ -82,7 +97,21 @@ private GlException(String msg) {
    *     looper.
    */
   public EGLSurfaceTexture(Handler handler) {
+    this(handler, /* callback= */ null);
+  }
+
+  /**
+   * @param handler The {@link Handler} that will be used to call {@link
+   *     SurfaceTexture#updateTexImage()} to update images on the {@link SurfaceTexture}. Note that
+   *     {@link #init(int)} has to be called on the same looper thread as the looper of the {@link
+   *     Handler}.
+   * @param callback The {@link TextureImageListener} to be called when the texture image on {@link
+   *     SurfaceTexture} has been updated. This callback will be called on the same handler thread
+   *     as the {@code handler}.
+   */
+  public EGLSurfaceTexture(Handler handler, @Nullable TextureImageListener callback) {
     this.handler = handler;
+    this.callback = callback;
     textureIdHolder = new int[1];
   }
 
@@ -125,6 +154,11 @@ public void release() {
       if (Util.SDK_INT >= 19) {
         EGL14.eglReleaseThread();
       }
+      if (display != null && !display.equals(EGL14.EGL_NO_DISPLAY)) {
+        // Android is unusual in that it uses a reference-counted EGLDisplay.  So for
+        // every eglInitialize() we need an eglTerminate().
+        EGL14.eglTerminate(display);
+      }
       display = null;
       context = null;
       surface = null;
@@ -150,8 +184,20 @@ public void onFrameAvailable(SurfaceTexture surfaceTexture) {
 
   @Override
   public void run() {
+    // Run on the provided handler thread when a new image frame is available.
+    dispatchOnFrameAvailable();
     if (texture != null) {
-      texture.updateTexImage();
+      try {
+        texture.updateTexImage();
+      } catch (RuntimeException e) {
+        // Ignore
+      }
+    }
+  }
+
+  private void dispatchOnFrameAvailable() {
+    if (callback != null) {
+      callback.onFrameAvailable();
     }
   }
 
@@ -228,9 +274,9 @@ private static EGLSurface createEGLSurface(
         pbufferAttributes =
             new int[] {
               EGL14.EGL_WIDTH,
-              1,
+              EGL_SURFACE_WIDTH,
               EGL14.EGL_HEIGHT,
-              1,
+              EGL_SURFACE_HEIGHT,
               EGL_PROTECTED_CONTENT_EXT,
               EGL14.EGL_TRUE,
               EGL14.EGL_NONE
@@ -238,8 +284,10 @@ private static EGLSurface createEGLSurface(
       } else {
         pbufferAttributes =
             new int[] {
-              EGL14.EGL_WIDTH, 1,
-              EGL14.EGL_HEIGHT, 1,
+              EGL14.EGL_WIDTH,
+              EGL_SURFACE_WIDTH,
+              EGL14.EGL_HEIGHT,
+              EGL_SURFACE_HEIGHT,
               EGL14.EGL_NONE
             };
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java
new file mode 100644
index 0000000000..07f278c808
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.os.Handler;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * Event dispatcher which allows listener registration.
+ *
+ * @param <T> The type of listener.
+ */
+public final class EventDispatcher<T> {
+
+  /** Functional interface to send an event. */
+  public interface Event<T> {
+
+    /**
+     * Sends the event to a listener.
+     *
+     * @param listener The listener to send the event to.
+     */
+    void sendTo(T listener);
+  }
+
+  /** The list of listeners and handlers. */
+  private final CopyOnWriteArrayList<HandlerAndListener<T>> listeners;
+
+  /** Creates an event dispatcher. */
+  public EventDispatcher() {
+    listeners = new CopyOnWriteArrayList<>();
+  }
+
+  /** Adds a listener to the event dispatcher. */
+  public void addListener(Handler handler, T eventListener) {
+    Assertions.checkArgument(handler != null && eventListener != null);
+    removeListener(eventListener);
+    listeners.add(new HandlerAndListener<>(handler, eventListener));
+  }
+
+  /** Removes a listener from the event dispatcher. */
+  public void removeListener(T eventListener) {
+    for (HandlerAndListener<T> handlerAndListener : listeners) {
+      if (handlerAndListener.listener == eventListener) {
+        handlerAndListener.release();
+        listeners.remove(handlerAndListener);
+      }
+    }
+  }
+
+  /**
+   * Dispatches an event to all registered listeners.
+   *
+   * @param event The {@link Event}.
+   */
+  public void dispatch(Event<T> event) {
+    for (HandlerAndListener<T> handlerAndListener : listeners) {
+      handlerAndListener.dispatch(event);
+    }
+  }
+
+  private static final class HandlerAndListener<T> {
+
+    private final Handler handler;
+    private final T listener;
+
+    private boolean released;
+
+    public HandlerAndListener(Handler handler, T eventListener) {
+      this.handler = handler;
+      this.listener = eventListener;
+    }
+
+    public void release() {
+      released = true;
+    }
+
+    public void dispatch(Event<T> event) {
+      handler.post(
+          () -> {
+            if (!released) {
+              event.sendTo(listener);
+            }
+          });
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
index deb09f8074..25f3a0c100 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
@@ -15,10 +15,8 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.net.NetworkInfo;
 import android.os.SystemClock;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -43,9 +41,10 @@
 import java.util.Locale;
 
 /** Logs events from {@link Player} and other core components using {@link Log}. */
+@SuppressWarnings("UngroupedOverloads")
 public class EventLogger implements AnalyticsListener {
 
-  private static final String TAG = "EventLogger";
+  private static final String DEFAULT_TAG = "EventLogger";
   private static final int MAX_TIMELINE_ITEM_LINES = 3;
   private static final NumberFormat TIME_FORMAT;
   static {
@@ -56,6 +55,7 @@
   }
 
   private final @Nullable MappingTrackSelector trackSelector;
+  private final String tag;
   private final Timeline.Window window;
   private final Timeline.Period period;
   private final long startTimeMs;
@@ -67,7 +67,19 @@
    *     logging of track mapping is not required.
    */
   public EventLogger(@Nullable MappingTrackSelector trackSelector) {
+    this(trackSelector, DEFAULT_TAG);
+  }
+
+  /**
+   * Creates event logger.
+   *
+   * @param trackSelector The mapping track selector used by the player. May be null if detailed
+   *     logging of track mapping is not required.
+   * @param tag The tag used for logging.
+   */
+  public EventLogger(@Nullable MappingTrackSelector trackSelector, String tag) {
     this.trackSelector = trackSelector;
+    this.tag = tag;
     window = new Timeline.Window();
     period = new Timeline.Period();
     startTimeMs = SystemClock.elapsedRealtime();
@@ -310,8 +322,8 @@ public void onVideoSizeChanged(
   }
 
   @Override
-  public void onRenderedFirstFrame(EventTime eventTime, Surface surface) {
-    logd(eventTime, "renderedFirstFrame", surface.toString());
+  public void onRenderedFirstFrame(EventTime eventTime, @Nullable Surface surface) {
+    logd(eventTime, "renderedFirstFrame", String.valueOf(surface));
   }
 
   @Override
@@ -364,13 +376,8 @@ public void onBandwidthEstimate(
   }
 
   @Override
-  public void onViewportSizeChange(EventTime eventTime, int width, int height) {
-    logd(eventTime, "viewportSizeChanged", width + ", " + height);
-  }
-
-  @Override
-  public void onNetworkTypeChanged(EventTime eventTime, @Nullable NetworkInfo networkInfo) {
-    logd(eventTime, "networkTypeChanged", networkInfo == null ? "none" : networkInfo.toString());
+  public void onSurfaceSizeChanged(EventTime eventTime, int width, int height) {
+    logd(eventTime, "surfaceSizeChanged", width + ", " + height);
   }
 
   @Override
@@ -383,6 +390,11 @@ public void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLo
     logd(eventTime, "downstreamFormatChanged", Format.toLogString(mediaLoadData.trackFormat));
   }
 
+  @Override
+  public void onDrmSessionAcquired(EventTime eventTime) {
+    logd(eventTime, "drmSessionAcquired");
+  }
+
   @Override
   public void onDrmSessionManagerError(EventTime eventTime, Exception e) {
     printInternalError(eventTime, "drmSessionManagerError", e);
@@ -403,13 +415,18 @@ public void onDrmKeysLoaded(EventTime eventTime) {
     logd(eventTime, "drmKeysLoaded");
   }
 
+  @Override
+  public void onDrmSessionReleased(EventTime eventTime) {
+    logd(eventTime, "drmSessionReleased");
+  }
+
   /**
    * Logs a debug message.
    *
    * @param msg The message to log.
    */
   protected void logd(String msg) {
-    Log.d(TAG, msg);
+    Log.d(tag, msg);
   }
 
   /**
@@ -418,8 +435,8 @@ protected void logd(String msg) {
    * @param msg The message to log.
    * @param tr The exception to log.
    */
-  protected void loge(String msg, Throwable tr) {
-    Log.e(TAG, msg, tr);
+  protected void loge(String msg, @Nullable Throwable tr) {
+    Log.e(tag, msg, tr);
   }
 
   // Internal methods
@@ -432,12 +449,15 @@ private void logd(EventTime eventTime, String eventName, String eventDescription
     logd(getEventString(eventTime, eventName, eventDescription));
   }
 
-  private void loge(EventTime eventTime, String eventName, Throwable throwable) {
+  private void loge(EventTime eventTime, String eventName, @Nullable Throwable throwable) {
     loge(getEventString(eventTime, eventName), throwable);
   }
 
   private void loge(
-      EventTime eventTime, String eventName, String eventDescription, Throwable throwable) {
+      EventTime eventTime,
+      String eventName,
+      String eventDescription,
+      @Nullable Throwable throwable) {
     loge(getEventString(eventTime, eventName, eventDescription), throwable);
   }
 
@@ -462,7 +482,8 @@ private String getEventString(EventTime eventTime, String eventName, String even
   private String getEventTimeString(EventTime eventTime) {
     String windowPeriodString = "window=" + eventTime.windowIndex;
     if (eventTime.mediaPeriodId != null) {
-      windowPeriodString += ", period=" + eventTime.mediaPeriodId.periodIndex;
+      windowPeriodString +=
+          ", period=" + eventTime.timeline.getIndexOfPeriod(eventTime.mediaPeriodId.periodUid);
       if (eventTime.mediaPeriodId.isAd()) {
         windowPeriodString += ", adGroup=" + eventTime.mediaPeriodId.adGroupIndex;
         windowPeriodString += ", ad=" + eventTime.mediaPeriodId.adIndexInAdGroup;
@@ -530,8 +551,8 @@ private static String getAdaptiveSupportString(int trackCount, int adaptiveSuppo
   // Suppressing reference equality warning because the track group stored in the track selection
   // must point to the exact track group object to be considered part of it.
   @SuppressWarnings("ReferenceEquality")
-  private static String getTrackStatusString(TrackSelection selection, TrackGroup group,
-      int trackIndex) {
+  private static String getTrackStatusString(
+      @Nullable TrackSelection selection, TrackGroup group, int trackIndex) {
     return getTrackStatusString(selection != null && selection.getTrackGroup() == group
         && selection.indexOf(trackIndex) != C.INDEX_UNSET);
   }
@@ -591,6 +612,8 @@ private static String getTrackTypeString(int trackType) {
         return "default";
       case C.TRACK_TYPE_METADATA:
         return "metadata";
+      case C.TRACK_TYPE_CAMERA_MOTION:
+        return "camera motion";
       case C.TRACK_TYPE_NONE:
         return "none";
       case C.TRACK_TYPE_TEXT:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
new file mode 100644
index 0000000000..34fb684d25
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** Wrapper around {@link android.util.Log} which allows to set the log level. */
+public final class Log {
+
+  /**
+   * Log level for ExoPlayer logcat logging. One of {@link #LOG_LEVEL_ALL}, {@link #LOG_LEVEL_INFO},
+   * {@link #LOG_LEVEL_WARNING}, {@link #LOG_LEVEL_ERROR} or {@link #LOG_LEVEL_OFF}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({LOG_LEVEL_ALL, LOG_LEVEL_INFO, LOG_LEVEL_WARNING, LOG_LEVEL_ERROR, LOG_LEVEL_OFF})
+  @interface LogLevel {}
+  /** Log level to log all messages. */
+  public static final int LOG_LEVEL_ALL = 0;
+  /** Log level to only log informative, warning and error messages. */
+  public static final int LOG_LEVEL_INFO = 1;
+  /** Log level to only log warning and error messages. */
+  public static final int LOG_LEVEL_WARNING = 2;
+  /** Log level to only log error messages. */
+  public static final int LOG_LEVEL_ERROR = 3;
+  /** Log level to disable all logging. */
+  public static final int LOG_LEVEL_OFF = Integer.MAX_VALUE;
+
+  private static int logLevel = LOG_LEVEL_ALL;
+  private static boolean logStackTraces = true;
+
+  private Log() {}
+
+  /** Returns current {@link LogLevel} for ExoPlayer logcat logging. */
+  public static @LogLevel int getLogLevel() {
+    return logLevel;
+  }
+
+  /** Returns whether stack traces of {@link Throwable}s will be logged to logcat. */
+  public boolean getLogStackTraces() {
+    return logStackTraces;
+  }
+
+  /**
+   * Sets the {@link LogLevel} for ExoPlayer logcat logging.
+   *
+   * @param logLevel The new {@link LogLevel}.
+   */
+  public static void setLogLevel(@LogLevel int logLevel) {
+    Log.logLevel = logLevel;
+  }
+
+  /**
+   * Sets whether stack traces of {@link Throwable}s will be logged to logcat.
+   *
+   * @param logStackTraces Whether stack traces will be logged.
+   */
+  public static void setLogStackTraces(boolean logStackTraces) {
+    Log.logStackTraces = logStackTraces;
+  }
+
+  /** @see android.util.Log#d(String, String) */
+  public static void d(String tag, String message) {
+    if (logLevel == LOG_LEVEL_ALL) {
+      android.util.Log.d(tag, message);
+    }
+  }
+
+  /** @see android.util.Log#d(String, String, Throwable) */
+  public static void d(String tag, String message, @Nullable Throwable throwable) {
+    if (!logStackTraces) {
+      d(tag, appendThrowableMessage(message, throwable));
+    }
+    if (logLevel == LOG_LEVEL_ALL) {
+      android.util.Log.d(tag, message, throwable);
+    }
+  }
+
+  /** @see android.util.Log#i(String, String) */
+  public static void i(String tag, String message) {
+    if (logLevel <= LOG_LEVEL_INFO) {
+      android.util.Log.i(tag, message);
+    }
+  }
+
+  /** @see android.util.Log#i(String, String, Throwable) */
+  public static void i(String tag, String message, @Nullable Throwable throwable) {
+    if (!logStackTraces) {
+      i(tag, appendThrowableMessage(message, throwable));
+    }
+    if (logLevel <= LOG_LEVEL_INFO) {
+      android.util.Log.i(tag, message, throwable);
+    }
+  }
+
+  /** @see android.util.Log#w(String, String) */
+  public static void w(String tag, String message) {
+    if (logLevel <= LOG_LEVEL_WARNING) {
+      android.util.Log.w(tag, message);
+    }
+  }
+
+  /** @see android.util.Log#w(String, String, Throwable) */
+  public static void w(String tag, String message, @Nullable Throwable throwable) {
+    if (!logStackTraces) {
+      w(tag, appendThrowableMessage(message, throwable));
+    }
+    if (logLevel <= LOG_LEVEL_WARNING) {
+      android.util.Log.w(tag, message, throwable);
+    }
+  }
+
+  /** @see android.util.Log#e(String, String) */
+  public static void e(String tag, String message) {
+    if (logLevel <= LOG_LEVEL_ERROR) {
+      android.util.Log.e(tag, message);
+    }
+  }
+
+  /** @see android.util.Log#e(String, String, Throwable) */
+  public static void e(String tag, String message, @Nullable Throwable throwable) {
+    if (!logStackTraces) {
+      e(tag, appendThrowableMessage(message, throwable));
+    }
+    if (logLevel <= LOG_LEVEL_ERROR) {
+      android.util.Log.e(tag, message, throwable);
+    }
+  }
+
+  private static String appendThrowableMessage(String message, @Nullable Throwable throwable) {
+    if (throwable == null) {
+      return message;
+    }
+    String throwableMessage = throwable.getMessage();
+    return TextUtils.isEmpty(throwableMessage) ? message : message + " - " + throwableMessage;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index d0c08f9bd7..e506ae1b19 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -123,7 +123,7 @@ public static void registerCustomMimeType(String mimeType, String codecPrefix, i
    * @param mimeType The mimeType to test.
    * @return Whether the top level type is audio.
    */
-  public static boolean isAudio(String mimeType) {
+  public static boolean isAudio(@Nullable String mimeType) {
     return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));
   }
 
@@ -133,7 +133,7 @@ public static boolean isAudio(String mimeType) {
    * @param mimeType The mimeType to test.
    * @return Whether the top level type is video.
    */
-  public static boolean isVideo(String mimeType) {
+  public static boolean isVideo(@Nullable String mimeType) {
     return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));
   }
 
@@ -143,7 +143,7 @@ public static boolean isVideo(String mimeType) {
    * @param mimeType The mimeType to test.
    * @return Whether the top level type is text.
    */
-  public static boolean isText(String mimeType) {
+  public static boolean isText(@Nullable String mimeType) {
     return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType));
   }
 
@@ -153,7 +153,7 @@ public static boolean isText(String mimeType) {
    * @param mimeType The mimeType to test.
    * @return Whether the top level type is application.
    */
-  public static boolean isApplication(String mimeType) {
+  public static boolean isApplication(@Nullable String mimeType) {
     return BASE_TYPE_APPLICATION.equals(getTopLevelType(mimeType));
   }
 
@@ -167,7 +167,7 @@ public static boolean isApplication(String mimeType) {
     if (codecs == null) {
       return null;
     }
-    String[] codecList = Util.split(codecs, ",");
+    String[] codecList = Util.splitCodecs(codecs);
     for (String codec : codecList) {
       String mimeType = getMediaMimeType(codec);
       if (mimeType != null && isVideo(mimeType)) {
@@ -187,7 +187,7 @@ public static boolean isApplication(String mimeType) {
     if (codecs == null) {
       return null;
     }
-    String[] codecList = Util.split(codecs, ",");
+    String[] codecList = Util.splitCodecs(codecs);
     for (String codec : codecList) {
       String mimeType = getMediaMimeType(codec);
       if (mimeType != null && isAudio(mimeType)) {
@@ -207,7 +207,7 @@ public static boolean isApplication(String mimeType) {
     if (codec == null) {
       return null;
     }
-    codec = codec.trim();
+    codec = Util.toLowerInvariant(codec.trim());
     if (codec.startsWith("avc1") || codec.startsWith("avc3")) {
       return MimeTypes.VIDEO_H264;
     } else if (codec.startsWith("hev1") || codec.startsWith("hvc1")) {
@@ -245,6 +245,8 @@ public static boolean isApplication(String mimeType) {
       return MimeTypes.AUDIO_OPUS;
     } else if (codec.startsWith("vorbis")) {
       return MimeTypes.AUDIO_VORBIS;
+    } else if (codec.startsWith("flac")) {
+      return MimeTypes.AUDIO_FLAC;
     } else {
       return getCustomMimeTypeForCodec(codec);
     }
@@ -252,7 +254,7 @@ public static boolean isApplication(String mimeType) {
 
   /**
    * Derives a mimeType from MP4 object type identifier, as defined in RFC 6381 and
-   * http://www.mp4ra.org/object.html.
+   * https://mp4ra.org/#/object_types.
    *
    * @param objectType The objectType identifier to derive.
    * @return The mimeType, or null if it could not be derived.
@@ -312,7 +314,7 @@ public static String getMimeTypeFromMp4ObjectType(int objectType) {
    * @param mimeType The MIME type.
    * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified MIME type.
    */
-  public static int getTrackType(String mimeType) {
+  public static int getTrackType(@Nullable String mimeType) {
     if (TextUtils.isEmpty(mimeType)) {
       return C.TRACK_TYPE_UNKNOWN;
     } else if (isAudio(mimeType)) {
@@ -328,9 +330,10 @@ public static int getTrackType(String mimeType) {
       return C.TRACK_TYPE_TEXT;
     } else if (APPLICATION_ID3.equals(mimeType)
         || APPLICATION_EMSG.equals(mimeType)
-        || APPLICATION_SCTE35.equals(mimeType)
-        || APPLICATION_CAMERA_MOTION.equals(mimeType)) {
+        || APPLICATION_SCTE35.equals(mimeType)) {
       return C.TRACK_TYPE_METADATA;
+    } else if (APPLICATION_CAMERA_MOTION.equals(mimeType)) {
+      return C.TRACK_TYPE_CAMERA_MOTION;
     } else {
       return getTrackTypeForCustomMimeType(mimeType);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java
index c4ed20546d..05585d5301 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.util.Log;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
@@ -31,6 +30,9 @@
    */
   public static final class SpsData {
 
+    public final int profileIdc;
+    public final int constraintsFlagsAndReservedZero2Bits;
+    public final int levelIdc;
     public final int seqParameterSetId;
     public final int width;
     public final int height;
@@ -42,9 +44,23 @@
     public final int picOrderCntLsbLength;
     public final boolean deltaPicOrderAlwaysZeroFlag;
 
-    public SpsData(int seqParameterSetId, int width, int height, float pixelWidthAspectRatio,
-        boolean separateColorPlaneFlag, boolean frameMbsOnlyFlag, int frameNumLength,
-        int picOrderCountType, int picOrderCntLsbLength, boolean deltaPicOrderAlwaysZeroFlag) {
+    public SpsData(
+        int profileIdc,
+        int constraintsFlagsAndReservedZero2Bits,
+        int levelIdc,
+        int seqParameterSetId,
+        int width,
+        int height,
+        float pixelWidthAspectRatio,
+        boolean separateColorPlaneFlag,
+        boolean frameMbsOnlyFlag,
+        int frameNumLength,
+        int picOrderCountType,
+        int picOrderCntLsbLength,
+        boolean deltaPicOrderAlwaysZeroFlag) {
+      this.profileIdc = profileIdc;
+      this.constraintsFlagsAndReservedZero2Bits = constraintsFlagsAndReservedZero2Bits;
+      this.levelIdc = levelIdc;
       this.seqParameterSetId = seqParameterSetId;
       this.width = width;
       this.height = height;
@@ -251,7 +267,8 @@ public static SpsData parseSpsNalUnit(byte[] nalData, int nalOffset, int nalLimi
     ParsableNalUnitBitArray data = new ParsableNalUnitBitArray(nalData, nalOffset, nalLimit);
     data.skipBits(8); // nal_unit
     int profileIdc = data.readBits(8);
-    data.skipBits(16); // constraint bits (6), reserved (2) and level_idc (8)
+    int constraintsFlagsAndReservedZero2Bits = data.readBits(8);
+    int levelIdc = data.readBits(8);
     int seqParameterSetId = data.readUnsignedExpGolombCodedInt();
 
     int chromaFormatIdc = 1; // Default is 4:2:0
@@ -349,9 +366,20 @@ public static SpsData parseSpsNalUnit(byte[] nalData, int nalOffset, int nalLimi
       }
     }
 
-    return new SpsData(seqParameterSetId, frameWidth, frameHeight, pixelWidthHeightRatio,
-        separateColorPlaneFlag, frameMbsOnlyFlag, frameNumLength, picOrderCntType,
-        picOrderCntLsbLength, deltaPicOrderAlwaysZeroFlag);
+    return new SpsData(
+        profileIdc,
+        constraintsFlagsAndReservedZero2Bits,
+        levelIdc,
+        seqParameterSetId,
+        frameWidth,
+        frameHeight,
+        pixelWidthHeightRatio,
+        separateColorPlaneFlag,
+        frameMbsOnlyFlag,
+        frameNumLength,
+        picOrderCntType,
+        picOrderCntLsbLength,
+        deltaPicOrderAlwaysZeroFlag);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
index c93d7cd72e..e45ab0952e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
@@ -24,6 +24,7 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import android.support.annotation.StringRes;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -31,7 +32,12 @@
 @SuppressLint("InlinedApi")
 public final class NotificationUtil {
 
-  /** Notification channel importance levels. */
+  /**
+   * Notification channel importance levels. One of {@link #IMPORTANCE_UNSPECIFIED}, {@link
+   * #IMPORTANCE_NONE}, {@link #IMPORTANCE_MIN}, {@link #IMPORTANCE_LOW}, {@link
+   * #IMPORTANCE_DEFAULT} or {@link #IMPORTANCE_HIGH}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     IMPORTANCE_UNSPECIFIED,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
index c60caf9ba8..2d8bf95fd1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
@@ -28,10 +28,10 @@
   private int bitOffset;
   private int byteLimit;
 
-  /**
-   * Creates a new instance that initially has no backing data.
-   */
-  public ParsableBitArray() {}
+  /** Creates a new instance that initially has no backing data. */
+  public ParsableBitArray() {
+    data = Util.EMPTY_BYTE_ARRAY;
+  }
 
   /**
    * Creates a new instance that wraps an existing array.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index 5190896d9f..b928ffc02b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
@@ -30,10 +31,10 @@
   private int position;
   private int limit;
 
-  /**
-   * Creates a new instance that initially has no backing data.
-   */
-  public ParsableByteArray() {}
+  /** Creates a new instance that initially has no backing data. */
+  public ParsableByteArray() {
+    data = Util.EMPTY_BYTE_ARRAY;
+  }
 
   /**
    * Creates a new instance with {@code limit} bytes and sets the limit.
@@ -66,6 +67,12 @@ public ParsableByteArray(byte[] data, int limit) {
     this.limit = limit;
   }
 
+  /** Sets the position and limit to zero. */
+  public void reset() {
+    position = 0;
+    limit = 0;
+  }
+
   /**
    * Resets the position to zero and the limit to the specified value. If the limit exceeds the
    * capacity, {@code data} is replaced with a new array of sufficient size.
@@ -76,6 +83,16 @@ public void reset(int limit) {
     reset(capacity() < limit ? new byte[limit] : data, limit);
   }
 
+  /**
+   * Updates the instance to wrap {@code data}, and resets the position to zero and the limit to
+   * {@code data.length}.
+   *
+   * @param data The array to wrap.
+   */
+  public void reset(byte[] data) {
+    reset(data, data.length);
+  }
+
   /**
    * Updates the instance to wrap {@code data}, and resets the position to zero.
    *
@@ -88,14 +105,6 @@ public void reset(byte[] data, int limit) {
     position = 0;
   }
 
-  /**
-   * Sets the position and limit to zero.
-   */
-  public void reset() {
-    position = 0;
-    limit = 0;
-  }
-
   /**
    * Returns the number of bytes yet to be read.
    */
@@ -131,7 +140,7 @@ public int getPosition() {
    * Returns the capacity of the array, which may be larger than the limit.
    */
   public int capacity() {
-    return data == null ? 0 : data.length;
+    return data.length;
   }
 
   /**
@@ -481,7 +490,7 @@ public String readNullTerminatedString(int length) {
    * @return The string not including any terminating NUL byte, or null if the end of the data has
    *     already been reached.
    */
-  public String readNullTerminatedString() {
+  public @Nullable String readNullTerminatedString() {
     if (bytesLeft() == 0) {
       return null;
     }
@@ -499,15 +508,15 @@ public String readNullTerminatedString() {
 
   /**
    * Reads a line of text.
-   * <p>
-   * A line is considered to be terminated by any one of a carriage return ('\r'), a line feed
+   *
+   * <p>A line is considered to be terminated by any one of a carriage return ('\r'), a line feed
    * ('\n'), or a carriage return followed immediately by a line feed ('\r\n'). The system's default
-   * charset (UTF-8) is used.
+   * charset (UTF-8) is used. This method discards leading UTF-8 byte order marks, if present.
    *
    * @return The line not including any line-termination characters, or null if the end of the data
    *     has already been reached.
    */
-  public String readLine() {
+  public @Nullable String readLine() {
     if (bytesLeft() == 0) {
       return null;
     }
@@ -517,7 +526,7 @@ public String readLine() {
     }
     if (lineLimit - position >= 3 && data[position] == (byte) 0xEF
         && data[position + 1] == (byte) 0xBB && data[position + 2] == (byte) 0xBF) {
-      // There's a byte order mark at the start of the line. Discard it.
+      // There's a UTF-8 byte order mark at the start of the line. Discard it.
       position += 3;
     }
     String line = Util.fromUtf8Bytes(data, position, lineLimit - position);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java
index 3a7202c674..6d34a4190e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java
@@ -35,6 +35,7 @@
    * @param offset The byte offset in {@code data} to start reading from.
    * @param limit The byte offset of the end of the bitstream in {@code data}.
    */
+  @SuppressWarnings({"initialization.fields.uninitialized", "method.invocation.invalid"})
   public ParsableNalUnitBitArray(byte[] data, int offset, int limit) {
     reset(data, offset, limit);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Predicate.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Predicate.java
index 889b19f3c3..b582cf3f7c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Predicate.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Predicate.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.util;
 
 /**
- * Determines a true of false value for a given input.
+ * Determines a true or false value for a given input.
  *
  * @param <T> The input type of the predicate.
  */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java b/library/core/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java
index 2516b538c6..2ebda60821 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java
@@ -111,7 +111,7 @@ public void proceedOrThrow(int priority) throws PriorityTooLowException {
   public void remove(int priority) {
     synchronized (lock) {
       queue.remove(priority);
-      highestPriority = queue.isEmpty() ? Integer.MIN_VALUE : queue.peek();
+      highestPriority = queue.isEmpty() ? Integer.MIN_VALUE : Util.castNonNull(queue.peek());
       lock.notifyAll();
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
index 53cb051230..cc23c9763c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.Player;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -25,12 +26,17 @@
  */
 public final class RepeatModeUtil {
 
+  // LINT.IfChange
   /**
-   * Set of repeat toggle modes. Can be combined using bit-wise operations.
+   * Set of repeat toggle modes. Can be combined using bit-wise operations. Possible flag values are
+   * {@link #REPEAT_TOGGLE_MODE_NONE}, {@link #REPEAT_TOGGLE_MODE_ONE} and {@link
+   * #REPEAT_TOGGLE_MODE_ALL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {REPEAT_TOGGLE_MODE_NONE, REPEAT_TOGGLE_MODE_ONE,
-      REPEAT_TOGGLE_MODE_ALL})
+  @IntDef(
+      flag = true,
+      value = {REPEAT_TOGGLE_MODE_NONE, REPEAT_TOGGLE_MODE_ONE, REPEAT_TOGGLE_MODE_ALL})
   public @interface RepeatToggleModes {}
   /**
    * All repeat mode buttons disabled.
@@ -40,10 +46,9 @@
    * "Repeat One" button enabled.
    */
   public static final int REPEAT_TOGGLE_MODE_ONE = 1;
-  /**
-   * "Repeat All" button enabled.
-   */
-  public static final int REPEAT_TOGGLE_MODE_ALL = 2;
+  /** "Repeat All" button enabled. */
+  public static final int REPEAT_TOGGLE_MODE_ALL = 1 << 1; // 2
+  // LINT.ThenChange(../../../../../../../../../ui/src/main/res/values/attrs.xml)
 
   private RepeatModeUtil() {
     // Prevent instantiation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
index c43b1929cb..f9be1a53b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
@@ -35,19 +35,9 @@
 public class SlidingPercentile {
 
   // Orderings.
-  private static final Comparator<Sample> INDEX_COMPARATOR = new Comparator<Sample>() {
-    @Override
-    public int compare(Sample a, Sample b) {
-      return a.index - b.index;
-    }
-  };
-
-  private static final Comparator<Sample> VALUE_COMPARATOR = new Comparator<Sample>() {
-    @Override
-    public int compare(Sample a, Sample b) {
-      return a.value < b.value ? -1 : b.value < a.value ? 1 : 0;
-    }
-  };
+  private static final Comparator<Sample> INDEX_COMPARATOR = (a, b) -> a.index - b.index;
+  private static final Comparator<Sample> VALUE_COMPARATOR =
+      (a, b) -> Float.compare(a.value, b.value);
 
   private static final int SORT_ORDER_NONE = -1;
   private static final int SORT_ORDER_BY_VALUE = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java
new file mode 100644
index 0000000000..3fe3c56c15
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.support.annotation.Nullable;
+import java.util.Arrays;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+
+/** A utility class to keep a queue of values with timestamps. This class is thread safe. */
+public final class TimedValueQueue<V> {
+  private static final int INITIAL_BUFFER_SIZE = 10;
+
+  // Looping buffer for timestamps and values
+  private long[] timestamps;
+  private @NullableType V[] values;
+  private int first;
+  private int size;
+
+  public TimedValueQueue() {
+    this(INITIAL_BUFFER_SIZE);
+  }
+
+  /** Creates a TimedValueBuffer with the given initial buffer size. */
+  public TimedValueQueue(int initialBufferSize) {
+    timestamps = new long[initialBufferSize];
+    values = newArray(initialBufferSize);
+  }
+
+  /**
+   * Associates the specified value with the specified timestamp. All new values should have a
+   * greater timestamp than the previously added values. Otherwise all values are removed before
+   * adding the new one.
+   */
+  public synchronized void add(long timestamp, V value) {
+    clearBufferOnTimeDiscontinuity(timestamp);
+    doubleCapacityIfFull();
+    addUnchecked(timestamp, value);
+  }
+
+  /** Removes all of the values. */
+  public synchronized void clear() {
+    first = 0;
+    size = 0;
+    Arrays.fill(values, null);
+  }
+
+  /** Returns number of the values buffered. */
+  public synchronized int size() {
+    return size;
+  }
+
+  /**
+   * Returns the value with the greatest timestamp which is less than or equal to the given
+   * timestamp. Removes all older values and the returned one from the buffer.
+   *
+   * @param timestamp The timestamp value.
+   * @return The value with the greatest timestamp which is less than or equal to the given
+   *     timestamp or null if there is no such value.
+   * @see #poll(long)
+   */
+  public synchronized @Nullable V pollFloor(long timestamp) {
+    return poll(timestamp, /* onlyOlder= */ true);
+  }
+
+  /**
+   * Returns the value with the closest timestamp to the given timestamp. Removes all older values
+   * including the returned one from the buffer.
+   *
+   * @param timestamp The timestamp value.
+   * @return The value with the closest timestamp or null if the buffer is empty.
+   * @see #pollFloor(long)
+   */
+  public synchronized @Nullable V poll(long timestamp) {
+    return poll(timestamp, /* onlyOlder= */ false);
+  }
+
+  /**
+   * Returns the value with the closest timestamp to the given timestamp. Removes all older values
+   * including the returned one from the buffer.
+   *
+   * @param timestamp The timestamp value.
+   * @param onlyOlder Whether this method can return a new value in case its timestamp value is
+   *     closest to {@code timestamp}.
+   * @return The value with the closest timestamp or null if the buffer is empty or there is no
+   *     older value and {@code onlyOlder} is true.
+   */
+  private @Nullable V poll(long timestamp, boolean onlyOlder) {
+    V value = null;
+    long previousTimeDiff = Long.MAX_VALUE;
+    while (size > 0) {
+      long timeDiff = timestamp - timestamps[first];
+      if (timeDiff < 0 && (onlyOlder || -timeDiff >= previousTimeDiff)) {
+        break;
+      }
+      previousTimeDiff = timeDiff;
+      value = values[first];
+      values[first] = null;
+      first = (first + 1) % values.length;
+      size--;
+    }
+    return value;
+  }
+
+  private void clearBufferOnTimeDiscontinuity(long timestamp) {
+    if (size > 0) {
+      int last = (first + size - 1) % values.length;
+      if (timestamp <= timestamps[last]) {
+        clear();
+      }
+    }
+  }
+
+  private void doubleCapacityIfFull() {
+    int capacity = values.length;
+    if (size < capacity) {
+      return;
+    }
+    int newCapacity = capacity * 2;
+    long[] newTimestamps = new long[newCapacity];
+    V[] newValues = newArray(newCapacity);
+    // Reset the loop starting index to 0 while coping to the new buffer.
+    // First copy the values from 'first' index to the end of original array.
+    int length = capacity - first;
+    System.arraycopy(timestamps, first, newTimestamps, 0, length);
+    System.arraycopy(values, first, newValues, 0, length);
+    // Then the values from index 0 to 'first' index.
+    if (first > 0) {
+      System.arraycopy(timestamps, 0, newTimestamps, length, first);
+      System.arraycopy(values, 0, newValues, length, first);
+    }
+    timestamps = newTimestamps;
+    values = newValues;
+    first = 0;
+  }
+
+  private void addUnchecked(long timestamp, V value) {
+    int next = (first + size) % values.length;
+    timestamps[next] = timestamp;
+    values[next] = value;
+    size++;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <V> V[] newArray(int length) {
+    return (V[]) new Object[length];
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java b/library/core/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
index 08e2bd0669..439374a086 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
@@ -30,7 +30,8 @@
   public static final long DO_NOT_OFFSET = Long.MAX_VALUE;
 
   /**
-   * The value one greater than the largest representable (33 bit) MPEG-2 TS presentation timestamp.
+   * The value one greater than the largest representable (33 bit) MPEG-2 TS 90 kHz clock
+   * presentation timestamp.
    */
   private static final long MAX_PTS_PLUS_ONE = 0x200000000L;
 
@@ -38,13 +39,13 @@
   private long timestampOffsetUs;
 
   // Volatile to allow isInitialized to be called on a different thread to adjustSampleTimestamp.
-  private volatile long lastSampleTimestamp;
+  private volatile long lastSampleTimestampUs;
 
   /**
    * @param firstSampleTimestampUs See {@link #setFirstSampleTimestampUs(long)}.
    */
   public TimestampAdjuster(long firstSampleTimestampUs) {
-    lastSampleTimestamp = C.TIME_UNSET;
+    lastSampleTimestampUs = C.TIME_UNSET;
     setFirstSampleTimestampUs(firstSampleTimestampUs);
   }
 
@@ -56,30 +57,24 @@ public TimestampAdjuster(long firstSampleTimestampUs) {
    *     {@link #DO_NOT_OFFSET} if presentation timestamps should not be offset.
    */
   public synchronized void setFirstSampleTimestampUs(long firstSampleTimestampUs) {
-    Assertions.checkState(lastSampleTimestamp == C.TIME_UNSET);
+    Assertions.checkState(lastSampleTimestampUs == C.TIME_UNSET);
     this.firstSampleTimestampUs = firstSampleTimestampUs;
   }
 
-  /**
-   * Returns the first adjusted sample timestamp in microseconds.
-   *
-   * @return The first adjusted sample timestamp in microseconds.
-   */
+  /** Returns the last value passed to {@link #setFirstSampleTimestampUs(long)}. */
   public long getFirstSampleTimestampUs() {
     return firstSampleTimestampUs;
   }
 
   /**
-   * Returns the last adjusted timestamp. If no timestamp has been adjusted, returns
-   * {@code firstSampleTimestampUs} as provided to the constructor. If this value is
-   * {@link #DO_NOT_OFFSET}, returns {@link C#TIME_UNSET}.
-   *
-   * @return The last adjusted timestamp. If not present, {@code firstSampleTimestampUs} is
-   *     returned unless equal to {@link #DO_NOT_OFFSET}, in which case {@link C#TIME_UNSET} is
-   *     returned.
+   * Returns the last value obtained from {@link #adjustSampleTimestamp}. If {@link
+   * #adjustSampleTimestamp} has not been called, returns the result of calling {@link
+   * #getFirstSampleTimestampUs()}. If this value is {@link #DO_NOT_OFFSET}, returns {@link
+   * C#TIME_UNSET}.
    */
   public long getLastAdjustedTimestampUs() {
-    return lastSampleTimestamp != C.TIME_UNSET ? lastSampleTimestamp
+    return lastSampleTimestampUs != C.TIME_UNSET
+        ? (lastSampleTimestampUs + timestampOffsetUs)
         : firstSampleTimestampUs != DO_NOT_OFFSET ? firstSampleTimestampUs : C.TIME_UNSET;
   }
 
@@ -93,44 +88,47 @@ public long getLastAdjustedTimestampUs() {
    *     be offset.
    */
   public long getTimestampOffsetUs() {
-    return firstSampleTimestampUs == DO_NOT_OFFSET ? 0
-        : lastSampleTimestamp == C.TIME_UNSET ? C.TIME_UNSET : timestampOffsetUs;
+    return firstSampleTimestampUs == DO_NOT_OFFSET
+        ? 0
+        : lastSampleTimestampUs == C.TIME_UNSET ? C.TIME_UNSET : timestampOffsetUs;
   }
 
   /**
    * Resets the instance to its initial state.
    */
   public void reset() {
-    lastSampleTimestamp = C.TIME_UNSET;
+    lastSampleTimestampUs = C.TIME_UNSET;
   }
 
   /**
    * Scales and offsets an MPEG-2 TS presentation timestamp considering wraparound.
    *
-   * @param pts The MPEG-2 TS presentation timestamp.
+   * @param pts90Khz A 90 kHz clock MPEG-2 TS presentation timestamp.
    * @return The adjusted timestamp in microseconds.
    */
-  public long adjustTsTimestamp(long pts) {
-    if (pts == C.TIME_UNSET) {
+  public long adjustTsTimestamp(long pts90Khz) {
+    if (pts90Khz == C.TIME_UNSET) {
       return C.TIME_UNSET;
     }
-    if (lastSampleTimestamp != C.TIME_UNSET) {
+    if (lastSampleTimestampUs != C.TIME_UNSET) {
       // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
-      // and we need to snap to the one closest to lastSampleTimestamp.
-      long lastPts = usToPts(lastSampleTimestamp);
+      // and we need to snap to the one closest to lastSampleTimestampUs.
+      long lastPts = usToPts(lastSampleTimestampUs);
       long closestWrapCount = (lastPts + (MAX_PTS_PLUS_ONE / 2)) / MAX_PTS_PLUS_ONE;
-      long ptsWrapBelow = pts + (MAX_PTS_PLUS_ONE * (closestWrapCount - 1));
-      long ptsWrapAbove = pts + (MAX_PTS_PLUS_ONE * closestWrapCount);
-      pts = Math.abs(ptsWrapBelow - lastPts) < Math.abs(ptsWrapAbove - lastPts)
-          ? ptsWrapBelow : ptsWrapAbove;
+      long ptsWrapBelow = pts90Khz + (MAX_PTS_PLUS_ONE * (closestWrapCount - 1));
+      long ptsWrapAbove = pts90Khz + (MAX_PTS_PLUS_ONE * closestWrapCount);
+      pts90Khz =
+          Math.abs(ptsWrapBelow - lastPts) < Math.abs(ptsWrapAbove - lastPts)
+              ? ptsWrapBelow
+              : ptsWrapAbove;
     }
-    return adjustSampleTimestamp(ptsToUs(pts));
+    return adjustSampleTimestamp(ptsToUs(pts90Khz));
   }
 
   /**
-   * Offsets a sample timestamp in microseconds.
+   * Offsets a timestamp in microseconds.
    *
-   * @param timeUs The timestamp of a sample to adjust.
+   * @param timeUs The timestamp to adjust in microseconds.
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustSampleTimestamp(long timeUs) {
@@ -138,15 +136,15 @@ public long adjustSampleTimestamp(long timeUs) {
       return C.TIME_UNSET;
     }
     // Record the adjusted PTS to adjust for wraparound next time.
-    if (lastSampleTimestamp != C.TIME_UNSET) {
-      lastSampleTimestamp = timeUs;
+    if (lastSampleTimestampUs != C.TIME_UNSET) {
+      lastSampleTimestampUs = timeUs;
     } else {
       if (firstSampleTimestampUs != DO_NOT_OFFSET) {
         // Calculate the timestamp offset.
         timestampOffsetUs = firstSampleTimestampUs - timeUs;
       }
       synchronized (this) {
-        lastSampleTimestamp = timeUs;
+        lastSampleTimestampUs = timeUs;
         // Notify threads waiting for this adjuster to be initialized.
         notifyAll();
       }
@@ -160,15 +158,15 @@ public long adjustSampleTimestamp(long timeUs) {
    * @throws InterruptedException If the thread was interrupted.
    */
   public synchronized void waitUntilInitialized() throws InterruptedException {
-    while (lastSampleTimestamp == C.TIME_UNSET) {
+    while (lastSampleTimestampUs == C.TIME_UNSET) {
       wait();
     }
   }
 
   /**
-   * Converts a value in MPEG-2 timestamp units to the corresponding value in microseconds.
+   * Converts a 90 kHz clock timestamp to a timestamp in microseconds.
    *
-   * @param pts A value in MPEG-2 timestamp units.
+   * @param pts A 90 kHz clock timestamp.
    * @return The corresponding value in microseconds.
    */
   public static long ptsToUs(long pts) {
@@ -176,10 +174,10 @@ public static long ptsToUs(long pts) {
   }
 
   /**
-   * Converts a value in microseconds to the corresponding values in MPEG-2 timestamp units.
+   * Converts a timestamp in microseconds to a 90 kHz clock timestamp.
    *
    * @param us A value in microseconds.
-   * @return The corresponding value in MPEG-2 timestamp units.
+   * @return The corresponding value as a 90 kHz clock timestamp.
    */
   public static long usToPts(long us) {
     return (us * 90000) / C.MICROS_PER_SECOND;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index 90c5d17b6d..f7c045dbb0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.util;
 
 import android.Manifest.permission;
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ComponentName;
@@ -25,13 +26,18 @@
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.graphics.Point;
+import android.media.AudioFormat;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
 import android.net.Uri;
 import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
 import android.os.Parcel;
-import android.support.annotation.NonNull;
+import android.security.NetworkSecurityPolicy;
 import android.support.annotation.Nullable;
+import android.telephony.TelephonyManager;
 import android.text.TextUtils;
-import android.util.Log;
 import android.view.Display;
 import android.view.WindowManager;
 import com.google.android.exoplayer2.C;
@@ -60,9 +66,14 @@
 import java.util.UUID;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+import org.checkerframework.checker.initialization.qual.UnknownInitialization;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
+import org.checkerframework.checker.nullness.qual.PolyNull;
 
 /**
  * Miscellaneous utility methods.
@@ -73,9 +84,7 @@
    * Like {@link android.os.Build.VERSION#SDK_INT}, but in a place where it can be conveniently
    * overridden for local testing.
    */
-  public static final int SDK_INT =
-      (Build.VERSION.SDK_INT == 25 && Build.VERSION.CODENAME.charAt(0) == 'O') ? 26
-      : Build.VERSION.SDK_INT;
+  public static final int SDK_INT = Build.VERSION.SDK_INT;
 
   /**
    * Like {@link Build#DEVICE}, but in a place where it can be conveniently overridden for local
@@ -101,6 +110,9 @@
   public static final String DEVICE_DEBUG_INFO = DEVICE + ", " + MODEL + ", " + MANUFACTURER + ", "
       + SDK_INT;
 
+  /** An empty byte array. */
+  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
   private static final String TAG = "Util";
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
@@ -173,6 +185,29 @@ public static boolean maybeRequestReadExternalStoragePermission(Activity activit
     return false;
   }
 
+  /**
+   * Returns whether it may be possible to load the given URIs based on the network security
+   * policy's cleartext traffic permissions.
+   *
+   * @param uris A list of URIs that will be loaded.
+   * @return Whether it may be possible to load the given URIs.
+   */
+  @TargetApi(24)
+  public static boolean checkCleartextTrafficPermitted(Uri... uris) {
+    if (Util.SDK_INT < 24) {
+      // We assume cleartext traffic is permitted.
+      return true;
+    }
+    for (Uri uri : uris) {
+      if ("http".equals(uri.getScheme())
+          && !NetworkSecurityPolicy.getInstance().isCleartextTrafficPermitted(uri.getHost())) {
+        // The security policy prevents cleartext traffic.
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * Returns true if the URI is a path to a local file or a reference to a local file.
    *
@@ -217,12 +252,39 @@ public static boolean contains(Object[] items, Object item) {
   /**
    * Removes an indexed range from a List.
    *
+   * <p>Does nothing if the provided range is valid and {@code fromIndex == toIndex}.
+   *
    * @param list The List to remove the range from.
    * @param fromIndex The first index to be removed (inclusive).
    * @param toIndex The last index to be removed (exclusive).
+   * @throws IllegalArgumentException If {@code fromIndex} &lt; 0, {@code toIndex} &gt; {@code
+   *     list.size()}, or {@code fromIndex} &gt; {@code toIndex}.
    */
   public static <T> void removeRange(List<T> list, int fromIndex, int toIndex) {
-    list.subList(fromIndex, toIndex).clear();
+    if (fromIndex < 0 || toIndex > list.size() || fromIndex > toIndex) {
+      throw new IllegalArgumentException();
+    } else if (fromIndex != toIndex) {
+      // Checking index inequality prevents an unnecessary allocation.
+      list.subList(fromIndex, toIndex).clear();
+    }
+  }
+
+  /**
+   * Casts a nullable variable to a non-null variable without runtime null check.
+   *
+   * <p>Use {@link Assertions#checkNotNull(Object)} to throw if the value is null.
+   */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
+  @EnsuresNonNull("#1")
+  public static <T> T castNonNull(@Nullable T value) {
+    return value;
+  }
+
+  /** Casts a nullable type array to a non-null type array without runtime null check. */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
+  @EnsuresNonNull("#1")
+  public static <T> T[] castNonNullTypeArray(@NullableType T[] value) {
+    return value;
   }
 
   /**
@@ -233,12 +295,53 @@ public static boolean contains(Object[] items, Object item) {
    * @param length The output array length. Must be less or equal to the length of the input array.
    * @return The copied array.
    */
-  @SuppressWarnings("nullness:assignment.type.incompatible")
+  @SuppressWarnings({"nullness:argument.type.incompatible", "nullness:return.type.incompatible"})
   public static <T> T[] nullSafeArrayCopy(T[] input, int length) {
     Assertions.checkArgument(length <= input.length);
     return Arrays.copyOf(input, length);
   }
 
+  /**
+   * Creates a {@link Handler} with the specified {@link Handler.Callback} on the current {@link
+   * Looper} thread. The method accepts partially initialized objects as callback under the
+   * assumption that the Handler won't be used to send messages until the callback is fully
+   * initialized.
+   *
+   * <p>If the current thread doesn't have a {@link Looper}, the application's main thread {@link
+   * Looper} is used.
+   *
+   * @param callback A {@link Handler.Callback}. May be a partially initialized class.
+   * @return A {@link Handler} with the specified callback on the current {@link Looper} thread.
+   */
+  public static Handler createHandler(Handler.@UnknownInitialization Callback callback) {
+    return createHandler(getLooper(), callback);
+  }
+
+  /**
+   * Creates a {@link Handler} with the specified {@link Handler.Callback} on the specified {@link
+   * Looper} thread. The method accepts partially initialized objects as callback under the
+   * assumption that the Handler won't be used to send messages until the callback is fully
+   * initialized.
+   *
+   * @param looper A {@link Looper} to run the callback on.
+   * @param callback A {@link Handler.Callback}. May be a partially initialized class.
+   * @return A {@link Handler} with the specified callback on the current {@link Looper} thread.
+   */
+  @SuppressWarnings({"nullness:argument.type.incompatible", "nullness:return.type.incompatible"})
+  public static Handler createHandler(
+      Looper looper, Handler.@UnknownInitialization Callback callback) {
+    return new Handler(looper, callback);
+  }
+
+  /**
+   * Returns the {@link Looper} associated with the current thread, or the {@link Looper} of the
+   * application's main thread if the current thread doesn't have a {@link Looper}.
+   */
+  public static Looper getLooper() {
+    Looper myLooper = Looper.myLooper();
+    return myLooper != null ? myLooper : Looper.getMainLooper();
+  }
+
   /**
    * Instantiates a new single threaded executor whose thread has the specified name.
    *
@@ -246,12 +349,7 @@ public static boolean contains(Object[] items, Object item) {
    * @return The executor.
    */
   public static ExecutorService newSingleThreadExecutor(final String threadName) {
-    return Executors.newSingleThreadExecutor(new ThreadFactory() {
-      @Override
-      public Thread newThread(@NonNull Runnable r) {
-        return new Thread(r, threadName);
-      }
-    });
+    return Executors.newSingleThreadExecutor(runnable -> new Thread(runnable, threadName));
   }
 
   /**
@@ -397,8 +495,8 @@ public static boolean isLinebreak(int c) {
    * @param text The text to convert.
    * @return The lower case text, or null if {@code text} is null.
    */
-  public static String toLowerInvariant(String text) {
-    return text == null ? null : text.toLowerCase(Locale.US);
+  public static @PolyNull String toLowerInvariant(@PolyNull String text) {
+    return text == null ? text : text.toLowerCase(Locale.US);
   }
 
   /**
@@ -407,8 +505,8 @@ public static String toLowerInvariant(String text) {
    * @param text The text to convert.
    * @return The upper case text, or null if {@code text} is null.
    */
-  public static String toUpperInvariant(String text) {
-    return text == null ? null : text.toUpperCase(Locale.US);
+  public static @PolyNull String toUpperInvariant(@PolyNull String text) {
+    return text == null ? text : text.toUpperCase(Locale.US);
   }
 
   /**
@@ -579,10 +677,10 @@ public static int binarySearchFloor(long[] array, long value, boolean inclusive,
   /**
    * Returns the index of the largest element in {@code list} that is less than (or optionally equal
    * to) a specified {@code value}.
-   * <p>
-   * The search is performed using a binary search algorithm, so the list must be sorted. If the
-   * list contains multiple elements equal to {@code value} and {@code inclusive} is true, the
-   * index of the first one will be returned.
+   *
+   * <p>The search is performed using a binary search algorithm, so the list must be sorted. If the
+   * list contains multiple elements equal to {@code value} and {@code inclusive} is true, the index
+   * of the first one will be returned.
    *
    * @param <T> The type of values being searched.
    * @param list The list to search.
@@ -595,8 +693,11 @@ public static int binarySearchFloor(long[] array, long value, boolean inclusive,
    * @return The index of the largest element in {@code list} that is less than (or optionally equal
    *     to) {@code value}.
    */
-  public static <T> int binarySearchFloor(List<? extends Comparable<? super T>> list, T value,
-      boolean inclusive, boolean stayInBounds) {
+  public static <T extends Comparable<? super T>> int binarySearchFloor(
+      List<? extends Comparable<? super T>> list,
+      T value,
+      boolean inclusive,
+      boolean stayInBounds) {
     int index = Collections.binarySearch(list, value);
     if (index < 0) {
       index = -(index + 2);
@@ -645,10 +746,10 @@ public static int binarySearchCeil(
   /**
    * Returns the index of the smallest element in {@code list} that is greater than (or optionally
    * equal to) a specified value.
-   * <p>
-   * The search is performed using a binary search algorithm, so the list must be sorted. If the
-   * list contains multiple elements equal to {@code value} and {@code inclusive} is true, the
-   * index of the last one will be returned.
+   *
+   * <p>The search is performed using a binary search algorithm, so the list must be sorted. If the
+   * list contains multiple elements equal to {@code value} and {@code inclusive} is true, the index
+   * of the last one will be returned.
    *
    * @param <T> The type of values being searched.
    * @param list The list to search.
@@ -657,13 +758,16 @@ public static int binarySearchCeil(
    *     index. If false then the returned index corresponds to the smallest element strictly
    *     greater than the value.
    * @param stayInBounds If true, then {@code (list.size() - 1)} will be returned in the case that
-   *     the value is greater than the largest element in the list. If false then
-   *     {@code list.size()} will be returned.
+   *     the value is greater than the largest element in the list. If false then {@code
+   *     list.size()} will be returned.
    * @return The index of the smallest element in {@code list} that is greater than (or optionally
    *     equal to) {@code value}.
    */
-  public static <T> int binarySearchCeil(List<? extends Comparable<? super T>> list, T value,
-      boolean inclusive, boolean stayInBounds) {
+  public static <T extends Comparable<? super T>> int binarySearchCeil(
+      List<? extends Comparable<? super T>> list,
+      T value,
+      boolean inclusive,
+      boolean stayInBounds) {
     int index = Collections.binarySearch(list, value);
     if (index < 0) {
       index = ~index;
@@ -922,7 +1026,7 @@ public static long resolveSeekPositionUs(
    * @param list A list of integers.
    * @return The list in array form, or null if the input list was null.
    */
-  public static int[] toArray(List<Integer> list) {
+  public static int @PolyNull [] toArray(@PolyNull List<Integer> list) {
     if (list == null) {
       return null;
     }
@@ -1005,19 +1109,19 @@ public static String getUserAgent(Context context, String applicationName) {
   }
 
   /**
-   * Returns a copy of {@code codecs} without the codecs whose track type doesn't match
-   * {@code trackType}.
+   * Returns a copy of {@code codecs} without the codecs whose track type doesn't match {@code
+   * trackType}.
    *
    * @param codecs A codec sequence string, as defined in RFC 6381.
    * @param trackType One of {@link C}{@code .TRACK_TYPE_*}.
-   * @return A copy of {@code codecs} without the codecs whose track type doesn't match
-   *     {@code trackType}.
+   * @return A copy of {@code codecs} without the codecs whose track type doesn't match {@code
+   *     trackType}.
    */
-  public static String getCodecsOfType(String codecs, int trackType) {
-    if (TextUtils.isEmpty(codecs)) {
+  public static @Nullable String getCodecsOfType(String codecs, int trackType) {
+    String[] codecArray = splitCodecs(codecs);
+    if (codecArray.length == 0) {
       return null;
     }
-    String[] codecArray = split(codecs.trim(), "(\\s*,\\s*)");
     StringBuilder builder = new StringBuilder();
     for (String codec : codecArray) {
       if (trackType == MimeTypes.getTrackTypeOfCodec(codec)) {
@@ -1030,6 +1134,19 @@ public static String getCodecsOfType(String codecs, int trackType) {
     return builder.length() > 0 ? builder.toString() : null;
   }
 
+  /**
+   * Splits a codecs sequence string, as defined in RFC 6381, into individual codec strings.
+   *
+   * @param codecs A codec sequence string, as defined in RFC 6381.
+   * @return The split codecs, or an array of length zero if the input was empty.
+   */
+  public static String[] splitCodecs(String codecs) {
+    if (TextUtils.isEmpty(codecs)) {
+      return new String[0];
+    }
+    return split(codecs.trim(), "(\\s*,\\s*)");
+  }
+
   /**
    * Converts a sample bit depth to a corresponding PCM encoding constant.
    *
@@ -1056,12 +1173,12 @@ public static int getPcmEncoding(int bitDepth) {
   }
 
   /**
-   * Returns whether {@code encoding} is one of the PCM encodings.
+   * Returns whether {@code encoding} is one of the linear PCM encodings.
    *
    * @param encoding The encoding of the audio data.
    * @return Whether the encoding is one of the PCM encodings.
    */
-  public static boolean isEncodingPcm(@C.Encoding int encoding) {
+  public static boolean isEncodingLinearPcm(@C.Encoding int encoding) {
     return encoding == C.ENCODING_PCM_8BIT
         || encoding == C.ENCODING_PCM_16BIT
         || encoding == C.ENCODING_PCM_24BIT
@@ -1079,6 +1196,47 @@ public static boolean isEncodingHighResolutionIntegerPcm(@C.PcmEncoding int enco
     return encoding == C.ENCODING_PCM_24BIT || encoding == C.ENCODING_PCM_32BIT;
   }
 
+  /**
+   * Returns the audio track channel configuration for the given channel count, or {@link
+   * AudioFormat#CHANNEL_INVALID} if output is not poossible.
+   *
+   * @param channelCount The number of channels in the input audio.
+   * @return The channel configuration or {@link AudioFormat#CHANNEL_INVALID} if output is not
+   *     possible.
+   */
+  public static int getAudioTrackChannelConfig(int channelCount) {
+    switch (channelCount) {
+      case 1:
+        return AudioFormat.CHANNEL_OUT_MONO;
+      case 2:
+        return AudioFormat.CHANNEL_OUT_STEREO;
+      case 3:
+        return AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER;
+      case 4:
+        return AudioFormat.CHANNEL_OUT_QUAD;
+      case 5:
+        return AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER;
+      case 6:
+        return AudioFormat.CHANNEL_OUT_5POINT1;
+      case 7:
+        return AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER;
+      case 8:
+        if (Util.SDK_INT >= 23) {
+          return AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
+        } else if (Util.SDK_INT >= 21) {
+          // Equal to AudioFormat.CHANNEL_OUT_7POINT1_SURROUND, which is hidden before Android M.
+          return AudioFormat.CHANNEL_OUT_5POINT1
+              | AudioFormat.CHANNEL_OUT_SIDE_LEFT
+              | AudioFormat.CHANNEL_OUT_SIDE_RIGHT;
+        } else {
+          // 8 ch output is not supported before Android L.
+          return AudioFormat.CHANNEL_INVALID;
+        }
+      default:
+        return AudioFormat.CHANNEL_INVALID;
+    }
+  }
+
   /**
    * Returns the frame size for audio with {@code channelCount} channels in the specified encoding.
    *
@@ -1097,6 +1255,8 @@ public static int getPcmFrameSize(@C.PcmEncoding int pcmEncoding, int channelCou
       case C.ENCODING_PCM_32BIT:
       case C.ENCODING_PCM_FLOAT:
         return channelCount * 4;
+      case C.ENCODING_PCM_A_LAW:
+      case C.ENCODING_PCM_MU_LAW:
       case C.ENCODING_INVALID:
       case Format.NO_VALUE:
       default:
@@ -1177,6 +1337,7 @@ public static int getStreamTypeForAudioUsage(@C.AudioUsage int usage) {
       case C.USAGE_NOTIFICATION_EVENT:
         return C.STREAM_TYPE_NOTIFICATION;
       case C.USAGE_ASSISTANCE_ACCESSIBILITY:
+      case C.USAGE_ASSISTANT:
       case C.USAGE_UNKNOWN:
       default:
         return C.STREAM_TYPE_DEFAULT;
@@ -1190,7 +1351,7 @@ public static int getStreamTypeForAudioUsage(@C.AudioUsage int usage) {
    *     "clearkey"}.
    * @return The derived {@link UUID}, or {@code null} if one could not be derived.
    */
-  public static UUID getDrmUuid(String drmScheme) {
+  public static @Nullable UUID getDrmUuid(String drmScheme) {
     switch (Util.toLowerInvariant(drmScheme)) {
       case "widevine":
         return C.WIDEVINE_UUID;
@@ -1275,11 +1436,12 @@ public static String getStringForTime(StringBuilder builder, Formatter formatter
   }
 
   /**
-   * Maps a {@link C} {@code TRACK_TYPE_*} constant to the corresponding {@link C}
-   * {@code DEFAULT_*_BUFFER_SIZE} constant.
+   * Maps a {@link C} {@code TRACK_TYPE_*} constant to the corresponding {@link C} {@code
+   * DEFAULT_*_BUFFER_SIZE} constant.
    *
    * @param trackType The track type.
    * @return The corresponding default buffer size in bytes.
+   * @throws IllegalArgumentException If the track type is an unrecognized or custom track type.
    */
   public static int getDefaultBufferSize(int trackType) {
     switch (trackType) {
@@ -1293,8 +1455,12 @@ public static int getDefaultBufferSize(int trackType) {
         return C.DEFAULT_TEXT_BUFFER_SIZE;
       case C.TRACK_TYPE_METADATA:
         return C.DEFAULT_METADATA_BUFFER_SIZE;
+      case C.TRACK_TYPE_CAMERA_MOTION:
+        return C.DEFAULT_CAMERA_MOTION_BUFFER_SIZE;
+      case C.TRACK_TYPE_NONE:
+        return 0;
       default:
-        throw new IllegalStateException();
+        throw new IllegalArgumentException();
     }
   }
 
@@ -1366,7 +1532,7 @@ private static boolean shouldEscapeCharacter(char c) {
    * @return The original value of the file name before it was escaped, or null if the escaped
    *     fileName seems invalid.
    */
-  public static String unescapeFileName(String fileName) {
+  public static @Nullable String unescapeFileName(String fileName) {
     int length = fileName.length();
     int percentCharacterCount = 0;
     for (int i = 0; i < length; i++) {
@@ -1402,7 +1568,7 @@ public static String unescapeFileName(String fileName) {
    * and is not declared to be thrown.
    */
   public static void sneakyThrow(Throwable t) {
-    Util.<RuntimeException>sneakyThrowInternal(t);
+    Util.sneakyThrowInternal(t);
   }
 
   @SuppressWarnings("unchecked")
@@ -1412,8 +1578,9 @@ public static void sneakyThrow(Throwable t) {
 
   /** Recursively deletes a directory and its content. */
   public static void recursiveDelete(File fileOrDirectory) {
-    if (fileOrDirectory.isDirectory()) {
-      for (File child : fileOrDirectory.listFiles()) {
+    File[] directoryFiles = fileOrDirectory.listFiles();
+    if (directoryFiles != null) {
+      for (File child : directoryFiles) {
         recursiveDelete(child);
       }
     }
@@ -1451,6 +1618,119 @@ public static int crc(byte[] bytes, int start, int end, int initialValue) {
     return initialValue;
   }
 
+  /**
+   * Returns the {@link C.NetworkType} of the current network connection. {@link
+   * C#NETWORK_TYPE_UNKNOWN} will be returned if the {@code ACCESS_NETWORK_STATE} permission is not
+   * granted or the network connection type couldn't be determined.
+   *
+   * @param context A context to access the connectivity manager.
+   * @return The {@link C.NetworkType} of the current network connection, or {@link
+   *     C#NETWORK_TYPE_UNKNOWN} if the {@code ACCESS_NETWORK_STATE} permission is not granted or
+   *     {@code context} is null.
+   */
+  public static @C.NetworkType int getNetworkType(@Nullable Context context) {
+    if (context == null) {
+      return C.NETWORK_TYPE_UNKNOWN;
+    }
+    NetworkInfo networkInfo;
+    try {
+      ConnectivityManager connectivityManager =
+          (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+      if (connectivityManager == null) {
+        return C.NETWORK_TYPE_UNKNOWN;
+      }
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (SecurityException e) {
+      // Permission ACCESS_NETWORK_STATE not granted.
+      return C.NETWORK_TYPE_UNKNOWN;
+    }
+    if (networkInfo == null || !networkInfo.isConnected()) {
+      return C.NETWORK_TYPE_OFFLINE;
+    }
+    switch (networkInfo.getType()) {
+      case ConnectivityManager.TYPE_WIFI:
+        return C.NETWORK_TYPE_WIFI;
+      case ConnectivityManager.TYPE_WIMAX:
+        return C.NETWORK_TYPE_4G;
+      case ConnectivityManager.TYPE_MOBILE:
+      case ConnectivityManager.TYPE_MOBILE_DUN:
+      case ConnectivityManager.TYPE_MOBILE_HIPRI:
+        return getMobileNetworkType(networkInfo);
+      case ConnectivityManager.TYPE_ETHERNET:
+        return C.NETWORK_TYPE_ETHERNET;
+      default: // Ethernet, VPN, Bluetooth, Dummy.
+        return C.NETWORK_TYPE_OTHER;
+    }
+  }
+
+  /**
+   * Returns the upper-case ISO 3166-1 alpha-2 country code of the current registered operator's MCC
+   * (Mobile Country Code), or the country code of the default Locale if not available.
+   *
+   * @param context A context to access the telephony service. If null, only the Locale can be used.
+   * @return The upper-case ISO 3166-1 alpha-2 country code, or an empty String if unavailable.
+   */
+  public static String getCountryCode(@Nullable Context context) {
+    if (context != null) {
+      TelephonyManager telephonyManager =
+          (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+      if (telephonyManager != null) {
+        String countryCode = telephonyManager.getNetworkCountryIso();
+        if (!TextUtils.isEmpty(countryCode)) {
+          return toUpperInvariant(countryCode);
+        }
+      }
+    }
+    return toUpperInvariant(Locale.getDefault().getCountry());
+  }
+
+  /**
+   * Uncompresses the data in {@code input}.
+   *
+   * @param input Wraps the compressed input data.
+   * @param output Wraps an output buffer to be used to store the uncompressed data. If {@code
+   *     output.data} isn't big enough to hold the uncompressed data, a new array is created. If
+   *     {@code true} is returned then the output's position will be set to 0 and its limit will be
+   *     set to the length of the uncompressed data.
+   * @param inflater If not null, used to uncompressed the input. Otherwise a new {@link Inflater}
+   *     is created.
+   * @return Whether the input is uncompressed successfully.
+   */
+  public static boolean inflate(
+      ParsableByteArray input, ParsableByteArray output, @Nullable Inflater inflater) {
+    if (input.bytesLeft() <= 0) {
+      return false;
+    }
+    byte[] outputData = output.data;
+    if (outputData.length < input.bytesLeft()) {
+      outputData = new byte[2 * input.bytesLeft()];
+    }
+    if (inflater == null) {
+      inflater = new Inflater();
+    }
+    inflater.setInput(input.data, input.getPosition(), input.bytesLeft());
+    try {
+      int outputSize = 0;
+      while (true) {
+        outputSize += inflater.inflate(outputData, outputSize, outputData.length - outputSize);
+        if (inflater.finished()) {
+          output.reset(outputData, outputSize);
+          return true;
+        }
+        if (inflater.needsDictionary() || inflater.needsInput()) {
+          return false;
+        }
+        if (outputSize == outputData.length) {
+          outputData = Arrays.copyOf(outputData, outputData.length * 2);
+        }
+      }
+    } catch (DataFormatException e) {
+      return false;
+    } finally {
+      inflater.reset();
+    }
+  }
+
   /**
    * Gets the physical size of the default display, in pixels.
    *
@@ -1484,6 +1764,7 @@ public static Point getPhysicalDisplaySize(Context context, Display display) {
         // Attempt to read sys.display-size.
         String sysDisplaySize = null;
         try {
+          @SuppressLint("PrivateApi")
           Class<?> systemProperties = Class.forName("android.os.SystemProperties");
           Method getMethod = systemProperties.getMethod("get", String.class);
           sysDisplaySize = (String) getMethod.invoke(systemProperties, "sys.display-size");
@@ -1545,6 +1826,36 @@ private static void getDisplaySizeV9(Display display, Point outSize) {
     outSize.y = display.getHeight();
   }
 
+  private static @C.NetworkType int getMobileNetworkType(NetworkInfo networkInfo) {
+    switch (networkInfo.getSubtype()) {
+      case TelephonyManager.NETWORK_TYPE_EDGE:
+      case TelephonyManager.NETWORK_TYPE_GPRS:
+        return C.NETWORK_TYPE_2G;
+      case TelephonyManager.NETWORK_TYPE_1xRTT:
+      case TelephonyManager.NETWORK_TYPE_CDMA:
+      case TelephonyManager.NETWORK_TYPE_EVDO_0:
+      case TelephonyManager.NETWORK_TYPE_EVDO_A:
+      case TelephonyManager.NETWORK_TYPE_EVDO_B:
+      case TelephonyManager.NETWORK_TYPE_HSDPA:
+      case TelephonyManager.NETWORK_TYPE_HSPA:
+      case TelephonyManager.NETWORK_TYPE_HSUPA:
+      case TelephonyManager.NETWORK_TYPE_IDEN:
+      case TelephonyManager.NETWORK_TYPE_UMTS:
+      case TelephonyManager.NETWORK_TYPE_EHRPD:
+      case TelephonyManager.NETWORK_TYPE_HSPAP:
+      case TelephonyManager.NETWORK_TYPE_TD_SCDMA:
+        return C.NETWORK_TYPE_3G;
+      case TelephonyManager.NETWORK_TYPE_LTE:
+        return C.NETWORK_TYPE_4G;
+      case TelephonyManager.NETWORK_TYPE_IWLAN:
+        return C.NETWORK_TYPE_WIFI;
+      case TelephonyManager.NETWORK_TYPE_GSM:
+      case TelephonyManager.NETWORK_TYPE_UNKNOWN:
+      default: // Future mobile network types.
+        return C.NETWORK_TYPE_CELLULAR_UNKNOWN;
+    }
+  }
+
   /**
    * Allows the CRC calculation to be done byte by byte instead of bit per bit being the order
    * "most significant bit first".
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java
index 84a6e4cebf..3b72a60fb9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.support.annotation.Nullable;
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
@@ -56,8 +57,7 @@ public static boolean isEndTag(XmlPullParser xpp) throws XmlPullParserException
    * @return Whether the current event is a start tag with the specified name.
    * @throws XmlPullParserException If an error occurs querying the parser.
    */
-  public static boolean isStartTag(XmlPullParser xpp, String name)
-      throws XmlPullParserException {
+  public static boolean isStartTag(XmlPullParser xpp, String name) throws XmlPullParserException {
     return isStartTag(xpp) && xpp.getName().equals(name);
   }
 
@@ -72,22 +72,60 @@ public static boolean isStartTag(XmlPullParser xpp) throws XmlPullParserExceptio
     return xpp.getEventType() == XmlPullParser.START_TAG;
   }
 
+  /**
+   * Returns whether the current event is a start tag with the specified name. If the current event
+   * has a raw name then its prefix is stripped before matching.
+   *
+   * @param xpp The {@link XmlPullParser} to query.
+   * @param name The specified name.
+   * @return Whether the current event is a start tag with the specified name.
+   * @throws XmlPullParserException If an error occurs querying the parser.
+   */
+  public static boolean isStartTagIgnorePrefix(XmlPullParser xpp, String name)
+      throws XmlPullParserException {
+    return isStartTag(xpp) && stripPrefix(xpp.getName()).equals(name);
+  }
+
   /**
    * Returns the value of an attribute of the current start tag.
    *
    * @param xpp The {@link XmlPullParser} to query.
    * @param attributeName The name of the attribute.
    * @return The value of the attribute, or null if the current event is not a start tag or if no
-   *     no such attribute was found.
+   *     such attribute was found.
+   */
+  public static @Nullable String getAttributeValue(XmlPullParser xpp, String attributeName) {
+    int attributeCount = xpp.getAttributeCount();
+    for (int i = 0; i < attributeCount; i++) {
+      if (xpp.getAttributeName(i).equals(attributeName)) {
+        return xpp.getAttributeValue(i);
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns the value of an attribute of the current start tag. Any raw attribute names in the
+   * current start tag have their prefixes stripped before matching.
+   *
+   * @param xpp The {@link XmlPullParser} to query.
+   * @param attributeName The name of the attribute.
+   * @return The value of the attribute, or null if the current event is not a start tag or if no
+   *     such attribute was found.
    */
-  public static String getAttributeValue(XmlPullParser xpp, String attributeName) {
+  public static @Nullable String getAttributeValueIgnorePrefix(
+      XmlPullParser xpp, String attributeName) {
     int attributeCount = xpp.getAttributeCount();
     for (int i = 0; i < attributeCount; i++) {
-      if (attributeName.equals(xpp.getAttributeName(i))) {
+      if (stripPrefix(xpp.getAttributeName(i)).equals(attributeName)) {
         return xpp.getAttributeValue(i);
       }
     }
     return null;
   }
 
+  private static String stripPrefix(String name) {
+    int prefixSeparatorIndex = name.indexOf(':');
+    return prefixSeparatorIndex == -1 ? name : name.substring(prefixSeparatorIndex + 1);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
index faedaaf273..77ca936a90 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
@@ -50,10 +50,8 @@
   @C.ColorTransfer
   public final int colorTransfer;
 
-  /**
-   * HdrStaticInfo as defined in CTA-861.3.
-   */
-  public final byte[] hdrStaticInfo;
+  /** HdrStaticInfo as defined in CTA-861.3, or null if none specified. */
+  public final @Nullable byte[] hdrStaticInfo;
 
   // Lazily initialized hashcode.
   private int hashCode;
@@ -64,10 +62,13 @@
    * @param colorSpace The color space of the video.
    * @param colorRange The color range of the video.
    * @param colorTransfer The color transfer characteristics of the video.
-   * @param hdrStaticInfo HdrStaticInfo as defined in CTA-861.3.
+   * @param hdrStaticInfo HdrStaticInfo as defined in CTA-861.3, or null if none specified.
    */
-  public ColorInfo(@C.ColorSpace int colorSpace, @C.ColorRange int colorRange,
-      @C.ColorTransfer int colorTransfer, byte[] hdrStaticInfo) {
+  public ColorInfo(
+      @C.ColorSpace int colorSpace,
+      @C.ColorRange int colorRange,
+      @C.ColorTransfer int colorTransfer,
+      @Nullable byte[] hdrStaticInfo) {
     this.colorSpace = colorSpace;
     this.colorRange = colorRange;
     this.colorTransfer = colorTransfer;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
index 996e6f30ae..c43d81010f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
@@ -30,11 +30,11 @@
 import android.os.HandlerThread;
 import android.os.Message;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.EGLSurfaceTexture;
 import com.google.android.exoplayer2.util.EGLSurfaceTexture.SecureMode;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import javax.microedition.khronos.egl.EGL10;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java b/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java
index 0982589866..089ff6343f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.video;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -26,7 +27,7 @@
  */
 public final class HevcConfig {
 
-  public final List<byte[]> initializationData;
+  public final @Nullable List<byte[]> initializationData;
   public final int nalUnitLengthFieldLength;
 
   /**
@@ -82,7 +83,7 @@ public static HevcConfig parse(ParsableByteArray data) throws ParserException {
     }
   }
 
-  private HevcConfig(List<byte[]> initializationData, int nalUnitLengthFieldLength) {
+  private HevcConfig(@Nullable List<byte[]> initializationData, int nalUnitLengthFieldLength) {
     this.initializationData = initializationData;
     this.nalUnitLengthFieldLength = nalUnitLengthFieldLength;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 3fba10a718..962bf33533 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -28,7 +28,6 @@
 import android.support.annotation.CallSuper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -46,11 +45,13 @@
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.mediacodec.MediaFormatUtil;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 /**
  * Decodes and renders video using {@link MediaCodec}.
@@ -83,13 +84,21 @@
   // Generally there is zero or one pending output stream offset. We track more offsets to allow for
   // pending output streams that have fewer frames than the codec latency.
   private static final int MAX_PENDING_OUTPUT_STREAM_OFFSET_COUNT = 10;
+  /**
+   * Scale factor for the initial maximum input size used to configure the codec in non-adaptive
+   * playbacks. See {@link #getCodecMaxValues(MediaCodecInfo, Format, Format[])}.
+   */
+  private static final float INITIAL_FORMAT_MAX_INPUT_SIZE_SCALE_FACTOR = 1.5f;
+
+  private static boolean evaluatedDeviceNeedsSetOutputSurfaceWorkaround;
+  private static boolean deviceNeedsSetOutputSurfaceWorkaround;
 
   private final Context context;
   private final VideoFrameReleaseTimeHelper frameReleaseTimeHelper;
   private final EventDispatcher eventDispatcher;
   private final long allowedJoiningTimeMs;
   private final int maxDroppedFramesToNotify;
-  private final boolean deviceNeedsAutoFrcWorkaround;
+  private final boolean deviceNeedsNoPostProcessWorkaround;
   private final long[] pendingOutputStreamOffsetsUs;
   private final long[] pendingOutputStreamSwitchTimesUs;
 
@@ -127,6 +136,7 @@
   private long lastInputTimeUs;
   private long outputStreamOffsetUs;
   private int pendingOutputStreamOffsetCount;
+  private @Nullable VideoFrameMetadataListener frameMetadataListener;
 
   /**
    * @param context A context.
@@ -150,7 +160,7 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
         allowedJoiningTimeMs,
         /* eventHandler= */ null,
         /* eventListener= */ null,
-        -1);
+        /* maxDroppedFramesToNotify= */ -1);
   }
 
   /**
@@ -161,12 +171,16 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param maxDroppedFrameCountToNotify The maximum number of frames that can be dropped between
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
-  public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      long allowedJoiningTimeMs, @Nullable Handler eventHandler,
-      @Nullable VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
+  public MediaCodecVideoRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      long allowedJoiningTimeMs,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify) {
     this(
         context,
         mediaCodecSelector,
@@ -175,7 +189,7 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
         /* playClearSamplesWithoutKeys= */ false,
         eventHandler,
         eventListener,
-        maxDroppedFrameCountToNotify);
+        maxDroppedFramesToNotify);
   }
 
   /**
@@ -201,13 +215,18 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
       @Nullable VideoRendererEventListener eventListener, int maxDroppedFramesToNotify) {
-    super(C.TRACK_TYPE_VIDEO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
+    super(
+        C.TRACK_TYPE_VIDEO,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        /* assumedMinimumCodecOperatingRate= */ 30);
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
     this.context = context.getApplicationContext();
     frameReleaseTimeHelper = new VideoFrameReleaseTimeHelper(this.context);
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    deviceNeedsAutoFrcWorkaround = deviceNeedsAutoFrcWorkaround();
+    deviceNeedsNoPostProcessWorkaround = deviceNeedsNoPostProcessWorkaround();
     pendingOutputStreamOffsetsUs = new long[MAX_PENDING_OUTPUT_STREAM_OFFSET_COUNT];
     pendingOutputStreamSwitchTimesUs = new long[MAX_PENDING_OUTPUT_STREAM_OFFSET_COUNT];
     outputStreamOffsetUs = C.TIME_UNSET;
@@ -236,32 +255,28 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         requiresSecureDecryption |= drmInitData.get(i).requiresSecureDecryption;
       }
     }
-    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType,
-        requiresSecureDecryption);
-    if (decoderInfo == null) {
-      return requiresSecureDecryption && mediaCodecSelector.getDecoderInfo(mimeType, false) != null
-          ? FORMAT_UNSUPPORTED_DRM : FORMAT_UNSUPPORTED_SUBTYPE;
+    List<MediaCodecInfo> decoderInfos =
+        mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecryption);
+    if (decoderInfos.isEmpty()) {
+      return requiresSecureDecryption
+              && !mediaCodecSelector
+                  .getDecoderInfos(format.sampleMimeType, /* requiresSecureDecoder= */ false)
+                  .isEmpty()
+          ? FORMAT_UNSUPPORTED_DRM
+          : FORMAT_UNSUPPORTED_SUBTYPE;
     }
     if (!supportsFormatDrm(drmSessionManager, drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
     }
-    boolean decoderCapable = decoderInfo.isCodecSupported(format.codecs);
-    if (decoderCapable && format.width > 0 && format.height > 0) {
-      if (Util.SDK_INT >= 21) {
-        decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
-            format.frameRate);
-      } else {
-        decoderCapable = format.width * format.height <= MediaCodecUtil.maxH264DecodableFrameSize();
-        if (!decoderCapable) {
-          Log.d(TAG, "FalseCheck [legacyFrameSize, " + format.width + "x" + format.height + "] ["
-              + Util.DEVICE_DEBUG_INFO + "]");
-        }
-      }
-    }
-
-    int adaptiveSupport = decoderInfo.adaptive ? ADAPTIVE_SEAMLESS : ADAPTIVE_NOT_SEAMLESS;
+    // Check capabilities for the first decoder in the list, which takes priority.
+    MediaCodecInfo decoderInfo = decoderInfos.get(0);
+    boolean isFormatSupported = decoderInfo.isFormatSupported(format);
+    int adaptiveSupport =
+        decoderInfo.isSeamlessAdaptationSupported(format)
+            ? ADAPTIVE_SEAMLESS
+            : ADAPTIVE_NOT_SEAMLESS;
     int tunnelingSupport = decoderInfo.tunneling ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
-    int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
+    int formatSupport = isFormatSupported ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
     return adaptiveSupport | tunnelingSupport | formatSupport;
   }
 
@@ -367,7 +382,7 @@ protected void onDisabled() {
   }
 
   @Override
-  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+  public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
       setSurface((Surface) message);
     } else if (messageType == C.MSG_SET_SCALING_MODE) {
@@ -376,6 +391,8 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
       if (codec != null) {
         codec.setVideoScalingMode(scalingMode);
       }
+    } else if (messageType == C.MSG_SET_VIDEO_FRAME_METADATA_LISTENER) {
+      frameMetadataListener = (VideoFrameMetadataListener) message;
     } else {
       super.handleMessage(messageType, message);
     }
@@ -435,11 +452,27 @@ protected boolean shouldInitCodec(MediaCodecInfo codecInfo) {
   }
 
   @Override
-  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
-      MediaCrypto crypto) throws DecoderQueryException {
+  protected boolean getCodecNeedsEosPropagation() {
+    // In tunneling mode we can't dequeue an end-of-stream buffer, so propagate it in the renderer.
+    return tunneling;
+  }
+
+  @Override
+  protected void configureCodec(
+      MediaCodecInfo codecInfo,
+      MediaCodec codec,
+      Format format,
+      MediaCrypto crypto,
+      float codecOperatingRate)
+      throws DecoderQueryException {
     codecMaxValues = getCodecMaxValues(codecInfo, format, getStreamFormats());
-    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround,
-        tunnelingAudioSessionId);
+    MediaFormat mediaFormat =
+        getMediaFormat(
+            format,
+            codecMaxValues,
+            codecOperatingRate,
+            deviceNeedsNoPostProcessWorkaround,
+            tunnelingAudioSessionId);
     if (surface == null) {
       Assertions.checkState(shouldUseDummySurface(codecInfo));
       if (dummySurface == null) {
@@ -456,10 +489,11 @@ protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format
   @Override
   protected @KeepCodecResult int canKeepCodec(
       MediaCodec codec, MediaCodecInfo codecInfo, Format oldFormat, Format newFormat) {
-    if (areAdaptationCompatible(codecInfo.adaptive, oldFormat, newFormat)
+    if (codecInfo.isSeamlessAdaptationSupported(
+            oldFormat, newFormat, /* isNewFormatComplete= */ true)
         && newFormat.width <= codecMaxValues.width
         && newFormat.height <= codecMaxValues.height
-        && getMaxInputSize(newFormat) <= codecMaxValues.inputSize) {
+        && getMaxInputSize(codecInfo, newFormat) <= codecMaxValues.inputSize) {
       return oldFormat.initializationDataEquals(newFormat)
           ? KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION
           : KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION;
@@ -491,6 +525,21 @@ protected void flushCodec() throws ExoPlaybackException {
     buffersInCodecCount = 0;
   }
 
+  @Override
+  protected float getCodecOperatingRate(
+      float operatingRate, Format format, Format[] streamFormats) {
+    // Use the highest known stream frame-rate up front, to avoid having to reconfigure the codec
+    // should an adaptive switch to that stream occur.
+    float maxFrameRate = -1;
+    for (Format streamFormat : streamFormats) {
+      float streamFrameRate = streamFormat.frameRate;
+      if (streamFrameRate != Format.NO_VALUE) {
+        maxFrameRate = Math.max(maxFrameRate, streamFrameRate);
+      }
+    }
+    return maxFrameRate == -1 ? CODEC_OPERATING_RATE_UNSET : (maxFrameRate * operatingRate);
+  }
+
   @Override
   protected void onCodecInitialized(String name, long initializedTimestampMs,
       long initializationDurationMs) {
@@ -517,7 +566,9 @@ protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
     buffersInCodecCount++;
     lastInputTimeUs = Math.max(buffer.timeUs, lastInputTimeUs);
     if (Util.SDK_INT < 23 && tunneling) {
-      maybeNotifyRenderedFirstFrame();
+      // In tunneled mode before API 23 we don't have a way to know when the buffer is output, so
+      // treat it as if it were output immediately.
+      onProcessedTunneledBuffer(buffer.timeUs);
     }
   }
 
@@ -526,35 +577,29 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
         && outputFormat.containsKey(KEY_CROP_LEFT) && outputFormat.containsKey(KEY_CROP_BOTTOM)
         && outputFormat.containsKey(KEY_CROP_TOP);
-    currentWidth = hasCrop
-        ? outputFormat.getInteger(KEY_CROP_RIGHT) - outputFormat.getInteger(KEY_CROP_LEFT) + 1
-        : outputFormat.getInteger(MediaFormat.KEY_WIDTH);
-    currentHeight = hasCrop
-        ? outputFormat.getInteger(KEY_CROP_BOTTOM) - outputFormat.getInteger(KEY_CROP_TOP) + 1
-        : outputFormat.getInteger(MediaFormat.KEY_HEIGHT);
-    currentPixelWidthHeightRatio = pendingPixelWidthHeightRatio;
-    if (Util.SDK_INT >= 21) {
-      // On API level 21 and above the decoder applies the rotation when rendering to the surface.
-      // Hence currentUnappliedRotation should always be 0. For 90 and 270 degree rotations, we need
-      // to flip the width, height and pixel aspect ratio to reflect the rotation that was applied.
-      if (pendingRotationDegrees == 90 || pendingRotationDegrees == 270) {
-        int rotatedHeight = currentWidth;
-        currentWidth = currentHeight;
-        currentHeight = rotatedHeight;
-        currentPixelWidthHeightRatio = 1 / currentPixelWidthHeightRatio;
-      }
-    } else {
-      // On API level 20 and below the decoder does not apply the rotation.
-      currentUnappliedRotationDegrees = pendingRotationDegrees;
-    }
-    // Must be applied each time the output format changes.
-    codec.setVideoScalingMode(scalingMode);
+    int width =
+        hasCrop
+            ? outputFormat.getInteger(KEY_CROP_RIGHT) - outputFormat.getInteger(KEY_CROP_LEFT) + 1
+            : outputFormat.getInteger(MediaFormat.KEY_WIDTH);
+    int height =
+        hasCrop
+            ? outputFormat.getInteger(KEY_CROP_BOTTOM) - outputFormat.getInteger(KEY_CROP_TOP) + 1
+            : outputFormat.getInteger(MediaFormat.KEY_HEIGHT);
+    processOutputFormat(codec, width, height);
   }
 
   @Override
-  protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
-      ByteBuffer buffer, int bufferIndex, int bufferFlags, long bufferPresentationTimeUs,
-      boolean shouldSkip) throws ExoPlaybackException {
+  protected boolean processOutputBuffer(
+      long positionUs,
+      long elapsedRealtimeUs,
+      MediaCodec codec,
+      ByteBuffer buffer,
+      int bufferIndex,
+      int bufferFlags,
+      long bufferPresentationTimeUs,
+      boolean shouldSkip,
+      Format format)
+      throws ExoPlaybackException {
     if (initialPositionUs == C.TIME_UNSET) {
       initialPositionUs = positionUs;
     }
@@ -581,8 +626,10 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (!renderedFirstFrame
         || (isStarted
             && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
+      long releaseTimeNs = System.nanoTime();
+      notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format);
       if (Util.SDK_INT >= 21) {
-        renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, System.nanoTime());
+        renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, releaseTimeNs);
       } else {
         renderOutputBuffer(codec, bufferIndex, presentationTimeUs);
       }
@@ -618,6 +665,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (Util.SDK_INT >= 21) {
       // Let the underlying framework time the release.
       if (earlyUs < 50000) {
+        notifyFrameMetadataListener(presentationTimeUs, adjustedReleaseTimeNs, format);
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, adjustedReleaseTimeNs);
         return true;
       }
@@ -635,6 +683,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
             return false;
           }
         }
+        notifyFrameMetadataListener(presentationTimeUs, adjustedReleaseTimeNs, format);
         renderOutputBuffer(codec, bufferIndex, presentationTimeUs);
         return true;
       }
@@ -644,6 +693,56 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
+  private void processOutputFormat(MediaCodec codec, int width, int height) {
+    currentWidth = width;
+    currentHeight = height;
+    currentPixelWidthHeightRatio = pendingPixelWidthHeightRatio;
+    if (Util.SDK_INT >= 21) {
+      // On API level 21 and above the decoder applies the rotation when rendering to the surface.
+      // Hence currentUnappliedRotation should always be 0. For 90 and 270 degree rotations, we need
+      // to flip the width, height and pixel aspect ratio to reflect the rotation that was applied.
+      if (pendingRotationDegrees == 90 || pendingRotationDegrees == 270) {
+        int rotatedHeight = currentWidth;
+        currentWidth = currentHeight;
+        currentHeight = rotatedHeight;
+        currentPixelWidthHeightRatio = 1 / currentPixelWidthHeightRatio;
+      }
+    } else {
+      // On API level 20 and below the decoder does not apply the rotation.
+      currentUnappliedRotationDegrees = pendingRotationDegrees;
+    }
+    // Must be applied each time the output format changes.
+    codec.setVideoScalingMode(scalingMode);
+  }
+
+  private void notifyFrameMetadataListener(
+      long presentationTimeUs, long releaseTimeNs, Format format) {
+    if (frameMetadataListener != null) {
+      frameMetadataListener.onVideoFrameAboutToBeRendered(
+          presentationTimeUs, releaseTimeNs, format);
+    }
+  }
+
+  /**
+   * Returns the offset that should be subtracted from {@code bufferPresentationTimeUs} in {@link
+   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, Format)} to
+   * get the playback position with respect to the media.
+   */
+  protected long getOutputStreamOffsetUs() {
+    return outputStreamOffsetUs;
+  }
+
+  /** Called when a buffer was processed in tunneling mode. */
+  protected void onProcessedTunneledBuffer(long presentationTimeUs) {
+    @Nullable Format format = updateOutputFormatForTime(presentationTimeUs);
+    if (format != null) {
+      processOutputFormat(getCodec(), format.width, format.height);
+    }
+    maybeNotifyVideoSizeChanged();
+    maybeNotifyRenderedFirstFrame();
+    onProcessedOutputBuffer(presentationTimeUs);
+  }
+
   /**
    * Called when an output buffer is successfully processed.
    *
@@ -776,7 +875,7 @@ protected void updateDroppedBufferCounters(int droppedBufferCount) {
     consecutiveDroppedFrameCount += droppedBufferCount;
     decoderCounters.maxConsecutiveDroppedBufferCount = Math.max(consecutiveDroppedFrameCount,
         decoderCounters.maxConsecutiveDroppedBufferCount);
-    if (droppedFrames >= maxDroppedFramesToNotify) {
+    if (maxDroppedFramesToNotify > 0 && droppedFrames >= maxDroppedFramesToNotify) {
       maybeNotifyDroppedFrames();
     }
   }
@@ -926,8 +1025,10 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
    *
    * @param format The format of media.
    * @param codecMaxValues Codec max values that should be used when configuring the decoder.
-   * @param deviceNeedsAutoFrcWorkaround Whether the device is known to enable frame-rate conversion
-   *     logic that negatively impacts ExoPlayer.
+   * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
+   *     no codec operating rate should be set.
+   * @param deviceNeedsNoPostProcessWorkaround Whether the device is known to do post processing by
+   *     default that isn't compatible with ExoPlayer.
    * @param tunnelingAudioSessionId The audio session id to use for tunneling, or {@link
    *     C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
    * @return The framework {@link MediaFormat} that should be used to configure the decoder.
@@ -936,7 +1037,8 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
   protected MediaFormat getMediaFormat(
       Format format,
       CodecMaxValues codecMaxValues,
-      boolean deviceNeedsAutoFrcWorkaround,
+      float codecOperatingRate,
+      boolean deviceNeedsNoPostProcessWorkaround,
       int tunnelingAudioSessionId) {
     MediaFormat mediaFormat = new MediaFormat();
     // Set format parameters that should always be set.
@@ -956,8 +1058,12 @@ protected MediaFormat getMediaFormat(
     // Set codec configuration values.
     if (Util.SDK_INT >= 23) {
       mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 /* realtime priority */);
+      if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET) {
+        mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
+      }
     }
-    if (deviceNeedsAutoFrcWorkaround) {
+    if (deviceNeedsNoPostProcessWorkaround) {
+      mediaFormat.setInteger("no-post-process", 1);
       mediaFormat.setInteger("auto-frc", 0);
     }
     if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
@@ -981,20 +1087,34 @@ protected CodecMaxValues getCodecMaxValues(
       throws DecoderQueryException {
     int maxWidth = format.width;
     int maxHeight = format.height;
-    int maxInputSize = getMaxInputSize(format);
+    int maxInputSize = getMaxInputSize(codecInfo, format);
     if (streamFormats.length == 1) {
       // The single entry in streamFormats must correspond to the format for which the codec is
       // being configured.
+      if (maxInputSize != Format.NO_VALUE) {
+        int codecMaxInputSize =
+            getCodecMaxInputSize(codecInfo, format.sampleMimeType, format.width, format.height);
+        if (codecMaxInputSize != Format.NO_VALUE) {
+          // Scale up the initial video decoder maximum input size so playlist item transitions with
+          // small increases in maximum sample size don't require reinitialization. This only makes
+          // a difference if the exact maximum sample sizes are known from the container.
+          int scaledMaxInputSize =
+              (int) (maxInputSize * INITIAL_FORMAT_MAX_INPUT_SIZE_SCALE_FACTOR);
+          // Avoid exceeding the maximum expected for the codec.
+          maxInputSize = Math.min(scaledMaxInputSize, codecMaxInputSize);
+        }
+      }
       return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
     }
     boolean haveUnknownDimensions = false;
     for (Format streamFormat : streamFormats) {
-      if (areAdaptationCompatible(codecInfo.adaptive, format, streamFormat)) {
+      if (codecInfo.isSeamlessAdaptationSupported(
+          format, streamFormat, /* isNewFormatComplete= */ false)) {
         haveUnknownDimensions |=
             (streamFormat.width == Format.NO_VALUE || streamFormat.height == Format.NO_VALUE);
         maxWidth = Math.max(maxWidth, streamFormat.width);
         maxHeight = Math.max(maxHeight, streamFormat.height);
-        maxInputSize = Math.max(maxInputSize, getMaxInputSize(streamFormat));
+        maxInputSize = Math.max(maxInputSize, getMaxInputSize(codecInfo, streamFormat));
       }
     }
     if (haveUnknownDimensions) {
@@ -1004,7 +1124,9 @@ protected CodecMaxValues getCodecMaxValues(
         maxWidth = Math.max(maxWidth, codecMaxSize.x);
         maxHeight = Math.max(maxHeight, codecMaxSize.y);
         maxInputSize =
-            Math.max(maxInputSize, getMaxInputSize(format.sampleMimeType, maxWidth, maxHeight));
+            Math.max(
+                maxInputSize,
+                getCodecMaxInputSize(codecInfo, format.sampleMimeType, maxWidth, maxHeight));
         Log.w(TAG, "Codec max resolution adjusted to: " + maxWidth + "x" + maxHeight);
       }
     }
@@ -1053,13 +1175,14 @@ private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
   }
 
   /**
-   * Returns a maximum input buffer size for a given format.
+   * Returns a maximum input buffer size for a given codec and format.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format.
    * @return A maximum input buffer size in bytes, or {@link Format#NO_VALUE} if a maximum could not
    *     be determined.
    */
-  private static int getMaxInputSize(Format format) {
+  private static int getMaxInputSize(MediaCodecInfo codecInfo, Format format) {
     if (format.maxInputSize != Format.NO_VALUE) {
       // The format defines an explicit maximum input size. Add the total size of initialization
       // data buffers, as they may need to be queued in the same input buffer as the largest sample.
@@ -1072,20 +1195,22 @@ private static int getMaxInputSize(Format format) {
     } else {
       // Calculated maximum input sizes are overestimates, so it's not necessary to add the size of
       // initialization data.
-      return getMaxInputSize(format.sampleMimeType, format.width, format.height);
+      return getCodecMaxInputSize(codecInfo, format.sampleMimeType, format.width, format.height);
     }
   }
 
   /**
-   * Returns a maximum input size for a given mime type, width and height.
+   * Returns a maximum input size for a given codec, MIME type, width and height.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param sampleMimeType The format mime type.
    * @param width The width in pixels.
    * @param height The height in pixels.
    * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
    *     determined.
    */
-  private static int getMaxInputSize(String sampleMimeType, int width, int height) {
+  private static int getCodecMaxInputSize(
+      MediaCodecInfo codecInfo, String sampleMimeType, int width, int height) {
     if (width == Format.NO_VALUE || height == Format.NO_VALUE) {
       // We can't infer a maximum input size without video dimensions.
       return Format.NO_VALUE;
@@ -1101,9 +1226,12 @@ private static int getMaxInputSize(String sampleMimeType, int width, int height)
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H264:
-        if ("BRAVIA 4K 2015".equals(Util.MODEL)) {
-          // The Sony BRAVIA 4k TV has input buffers that are too small for the calculated 4k video
-          // maximum input size, so use the default value.
+        if ("BRAVIA 4K 2015".equals(Util.MODEL) // Sony Bravia 4K
+            || ("Amazon".equals(Util.MANUFACTURER)
+                && ("KFSOWI".equals(Util.MODEL) // Kindle Soho
+                    || ("AFTS".equals(Util.MODEL) && codecInfo.secure)))) { // Fire TV Gen 2
+          // Use the default value for cases where platform limitations may prevent buffers of the
+          // calculated maximum input size from being allocated.
           return Format.NO_VALUE;
         }
         // Round up width/height to an integer number of macroblocks.
@@ -1129,78 +1257,223 @@ private static int getMaxInputSize(String sampleMimeType, int width, int height)
   }
 
   /**
-   * Returns whether a codec with suitable {@link CodecMaxValues} will support adaptation between
-   * two {@link Format}s.
-   *
-   * @param codecIsAdaptive Whether the codec supports seamless resolution switches.
-   * @param first The first format.
-   * @param second The second format.
-   * @return Whether the codec will support adaptation between the two {@link Format}s.
-   */
-  private static boolean areAdaptationCompatible(
-      boolean codecIsAdaptive, Format first, Format second) {
-    return first.sampleMimeType.equals(second.sampleMimeType)
-        && first.rotationDegrees == second.rotationDegrees
-        && (codecIsAdaptive || (first.width == second.width && first.height == second.height))
-        && Util.areEqual(first.colorInfo, second.colorInfo);
-  }
-
-  /**
-   * Returns whether the device is known to enable frame-rate conversion logic that negatively
-   * impacts ExoPlayer.
-   * <p>
-   * If true is returned then we explicitly disable the feature.
+   * Returns whether the device is known to do post processing by default that isn't compatible with
+   * ExoPlayer.
    *
-   * @return True if the device is known to enable frame-rate conversion logic that negatively
-   *     impacts ExoPlayer. False otherwise.
+   * @return Whether the device is known to do post processing by default that isn't compatible with
+   *     ExoPlayer.
    */
-  private static boolean deviceNeedsAutoFrcWorkaround() {
-    // nVidia Shield prior to M tries to adjust the playback rate to better map the frame-rate of
+  private static boolean deviceNeedsNoPostProcessWorkaround() {
+    // Nvidia devices prior to M try to adjust the playback rate to better map the frame-rate of
     // content to the refresh rate of the display. For example playback of 23.976fps content is
     // adjusted to play at 1.001x speed when the output display is 60Hz. Unfortunately the
     // implementation causes ExoPlayer's reported playback position to drift out of sync. Captions
-    // also lose sync [Internal: b/26453592].
-    return Util.SDK_INT <= 22 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER);
+    // also lose sync [Internal: b/26453592]. Even after M, the devices may apply post processing
+    // operations that can modify frame output timestamps, which is incompatible with ExoPlayer's
+    // logic for skipping decode-only frames.
+    return "NVIDIA".equals(Util.MANUFACTURER);
   }
 
+  /*
+   * TODO:
+   *
+   * 1. Validate that Android device certification now ensures correct behavior, and add a
+   *    corresponding SDK_INT upper bound for applying the workaround (probably SDK_INT < 26).
+   * 2. Determine a complete list of affected devices.
+   * 3. Some of the devices in this list only fail to support setOutputSurface when switching from
+   *    a SurfaceView provided Surface to a Surface of another type (e.g. TextureView/DummySurface),
+   *    and vice versa. One hypothesis is that setOutputSurface fails when the surfaces have
+   *    different pixel formats. If we can find a way to query the Surface instances to determine
+   *    whether this case applies, then we'll be able to provide a more targeted workaround.
+   */
   /**
-   * Returns whether the device is known to implement {@link MediaCodec#setOutputSurface(Surface)}
+   * Returns whether the codec is known to implement {@link MediaCodec#setOutputSurface(Surface)}
    * incorrectly.
-   * <p>
-   * If true is returned then we fall back to releasing and re-instantiating the codec instead.
+   *
+   * <p>If true is returned then we fall back to releasing and re-instantiating the codec instead.
+   *
+   * @param name The name of the codec.
+   * @return True if the device is known to implement {@link MediaCodec#setOutputSurface(Surface)}
+   *     incorrectly.
    */
-  private static boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
-    // Work around https://github.com/google/ExoPlayer/issues/3236,
-    // https://github.com/google/ExoPlayer/issues/3355,
-    // https://github.com/google/ExoPlayer/issues/3439,
-    // https://github.com/google/ExoPlayer/issues/3724,
-    // https://github.com/google/ExoPlayer/issues/3835,
-    // https://github.com/google/ExoPlayer/issues/4006,
-    // https://github.com/google/ExoPlayer/issues/4084,
-    // https://github.com/google/ExoPlayer/issues/4104,
-    // https://github.com/google/ExoPlayer/issues/4134,
-    // https://github.com/google/ExoPlayer/issues/4315.
-    return (("deb".equals(Util.DEVICE) // Nexus 7 (2013)
-                || "flo".equals(Util.DEVICE) // Nexus 7 (2013)
-                || "mido".equals(Util.DEVICE) // Redmi Note 4
-                || "santoni".equals(Util.DEVICE)) // Redmi 4X
-            && "OMX.qcom.video.decoder.avc".equals(name))
-        || (("tcl_eu".equals(Util.DEVICE) // TCL Percee TV
-                || "SVP-DTV15".equals(Util.DEVICE) // Sony Bravia 4K 2015
-                || "BRAVIA_ATV2".equals(Util.DEVICE) // Sony Bravia 4K GB
-                || Util.DEVICE.startsWith("panell_") // Motorola Moto C Plus
-                || "F3311".equals(Util.DEVICE) // Sony Xperia E5
-                || "M5c".equals(Util.DEVICE) // Meizu M5C
-                || "QM16XE_U".equals(Util.DEVICE) // Philips QM163E
-                || "A7010a48".equals(Util.DEVICE) // Lenovo K4 Note
-                || "woods_f".equals(Util.MODEL) // Moto E (4)
-                || "watson".equals(Util.DEVICE)) // Moto C
-            && "OMX.MTK.VIDEO.DECODER.AVC".equals(name))
-        || (("ALE-L21".equals(Util.MODEL) // Huawei P8 Lite
-                || "CAM-L21".equals(Util.MODEL)) // Huawei Y6II
-            && "OMX.k3.video.decoder.avc".equals(name))
-        || "OMX.amlogic.avc.decoder.awesome".equals(name) // ShiningWorth G9SX (amlogic) Android 6.0.1, Milo DX5, Milo DX5 Plus, Milo TVOne
-        || "OMX.amlogic.hevc.decoder.awesome".equals(name); // h265 for woplay amlogic devices
+
+  protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
+    if (name.startsWith("OMX.google")) {
+      // Google OMX decoders are not known to have this issue on any API level.
+      return false;
+    }
+    synchronized (MediaCodecVideoRenderer.class) {
+      if (!evaluatedDeviceNeedsSetOutputSurfaceWorkaround) {
+        if (Util.SDK_INT <= 27 && "dangal".equals(Util.DEVICE)) {
+          // Dangal is affected on API level 27: https://github.com/google/ExoPlayer/issues/5169.
+          deviceNeedsSetOutputSurfaceWorkaround = true;
+        } else if (Util.SDK_INT >= 27) {
+          // In general, devices running API level 27 or later should be unaffected. Do nothing.
+        } else {
+          // Enable the workaround on a per-device basis. Works around:
+          // https://github.com/google/ExoPlayer/issues/3236,
+          // https://github.com/google/ExoPlayer/issues/3355,
+          // https://github.com/google/ExoPlayer/issues/3439,
+          // https://github.com/google/ExoPlayer/issues/3724,
+          // https://github.com/google/ExoPlayer/issues/3835,
+          // https://github.com/google/ExoPlayer/issues/4006,
+          // https://github.com/google/ExoPlayer/issues/4084,
+          // https://github.com/google/ExoPlayer/issues/4104,
+          // https://github.com/google/ExoPlayer/issues/4134,
+          // https://github.com/google/ExoPlayer/issues/4315,
+          // https://github.com/google/ExoPlayer/issues/4419,
+          // https://github.com/google/ExoPlayer/issues/4460,
+          // https://github.com/google/ExoPlayer/issues/4468.
+          switch (Util.DEVICE) {
+            case "1601":
+            case "1713":
+            case "1714":
+            case "A10-70F":
+            case "A1601":
+            case "A2016a40":
+            case "A7000-a":
+            case "A7000plus":
+            case "A7010a48":
+            case "A7020a48":
+            case "AquaPowerM":
+            case "ASUS_X00AD_2":
+            case "Aura_Note_2":
+            case "BLACK-1X":
+            case "BRAVIA_ATV2":
+            case "BRAVIA_ATV3_4K":
+            case "C1":
+            case "ComioS1":
+            case "CP8676_I02":
+            case "CPH1609":
+            case "CPY83_I00":
+            case "cv1":
+            case "cv3":
+            case "deb":
+            case "E5643":
+            case "ELUGA_A3_Pro":
+            case "ELUGA_Note":
+            case "ELUGA_Prim":
+            case "ELUGA_Ray_X":
+            case "EverStar_S":
+            case "F3111":
+            case "F3113":
+            case "F3116":
+            case "F3211":
+            case "F3213":
+            case "F3215":
+            case "F3311":
+            case "flo":
+            case "fugu":
+            case "GiONEE_CBL7513":
+            case "GiONEE_GBL7319":
+            case "GIONEE_GBL7360":
+            case "GIONEE_SWW1609":
+            case "GIONEE_SWW1627":
+            case "GIONEE_SWW1631":
+            case "GIONEE_WBL5708":
+            case "GIONEE_WBL7365":
+            case "GIONEE_WBL7519":
+            case "griffin":
+            case "htc_e56ml_dtul":
+            case "hwALE-H":
+            case "HWBLN-H":
+            case "HWCAM-H":
+            case "HWVNS-H":
+            case "i9031":
+            case "iball8735_9806":
+            case "Infinix-X572":
+            case "iris60":
+            case "itel_S41":
+            case "j2xlteins":
+            case "JGZ":
+            case "K50a40":
+            case "kate":
+            case "le_x6":
+            case "LS-5017":
+            case "M5c":
+            case "manning":
+            case "marino_f":
+            case "MEIZU_M5":
+            case "mh":
+            case "mido":
+            case "MX6":
+            case "namath":
+            case "nicklaus_f":
+            case "NX541J":
+            case "NX573J":
+            case "OnePlus5T":
+            case "p212":
+            case "P681":
+            case "P85":
+            case "panell_d":
+            case "panell_dl":
+            case "panell_ds":
+            case "panell_dt":
+            case "PB2-670M":
+            case "PGN528":
+            case "PGN610":
+            case "PGN611":
+            case "Phantom6":
+            case "Pixi4-7_3G":
+            case "Pixi5-10_4G":
+            case "PLE":
+            case "PRO7S":
+            case "Q350":
+            case "Q4260":
+            case "Q427":
+            case "Q4310":
+            case "Q5":
+            case "QM16XE_U":
+            case "QX1":
+            case "santoni":
+            case "Slate_Pro":
+            case "SVP-DTV15":
+            case "s905x018":
+            case "taido_row":
+            case "TB3-730F":
+            case "TB3-730X":
+            case "TB3-850F":
+            case "TB3-850M":
+            case "tcl_eu":
+            case "V1":
+            case "V23GB":
+            case "V5":
+            case "vernee_M5":
+            case "watson":
+            case "whyred":
+            case "woods_f":
+            case "woods_fn":
+            case "X3_HK":
+            case "XE2X":
+            case "XT1663":
+            case "Z12_PRO":
+            case "Z80":
+              deviceNeedsSetOutputSurfaceWorkaround = true;
+              break;
+            default:
+              // Do nothing.
+              break;
+          }
+          switch (Util.MODEL) {
+            case "AFTA":
+            case "AFTN":
+              deviceNeedsSetOutputSurfaceWorkaround = true;
+              break;
+            default:
+              // Do nothing.
+              break;
+          }
+          if (
+               "OMX.amlogic.avc.decoder.awesome".equals(name) // ShiningWorth G9SX (amlogic) Android 6.0.1, Milo DX5, Milo DX5 Plus, Milo TVOne
+            || "OMX.amlogic.hevc.decoder.awesome".equals(name) // h265 for woplay amlogic devices)
+          ) {
+            deviceNeedsSetOutputSurfaceWorkaround = true;
+          }
+        }
+        evaluatedDeviceNeedsSetOutputSurfaceWorkaround = true;
+      }
+    }
+    return deviceNeedsSetOutputSurfaceWorkaround;
   }
 
   protected static final class CodecMaxValues {
@@ -1230,7 +1503,7 @@ public void onFrameRendered(@NonNull MediaCodec codec, long presentationTimeUs,
         // Stale event.
         return;
       }
-      maybeNotifyRenderedFirstFrame();
+      onProcessedTunneledBuffer(presentationTimeUs);
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
new file mode 100644
index 0000000000..b467d0f421
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import com.google.android.exoplayer2.Format;
+
+/** A listener for metadata corresponding to video frame being rendered. */
+public interface VideoFrameMetadataListener {
+  /**
+   * Called when the video frame about to be rendered. This method is called on the playback thread.
+   *
+   * @param presentationTimeUs The presentation time of the output buffer, in microseconds.
+   * @param releaseTimeNs The wallclock time at which the frame should be displayed, in nanoseconds.
+   *     If the platform API version of the device is less than 21, then this is the best effort.
+   * @param format The format associated with the frame.
+   */
+  void onVideoFrameAboutToBeRendered(long presentationTimeUs, long releaseTimeNs, Format format);
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
index b4835186ff..3c0fb92191 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
@@ -291,7 +291,7 @@ private VSyncSampler() {
       sampledVsyncTimeNs = C.TIME_UNSET;
       choreographerOwnerThread = new HandlerThread("ChoreographerOwner:Handler");
       choreographerOwnerThread.start();
-      handler = new Handler(choreographerOwnerThread.getLooper(), this);
+      handler = Util.createHandler(choreographerOwnerThread.getLooper(), /* callback= */ this);
       handler.sendEmptyMessage(CREATE_CHOREOGRAPHER);
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java
index ab09e0bbc2..6f492c3975 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java
@@ -34,12 +34,25 @@
    *     square pixels this will be equal to 1.0. Different values are indicative of anamorphic
    *     content.
    */
-  void onVideoSizeChanged(
-      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio);
+  default void onVideoSizeChanged(
+      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {}
+
+  /**
+   * Called each time there's a change in the size of the surface onto which the video is being
+   * rendered.
+   *
+   * @param width The surface width in pixels. May be {@link
+   *     com.google.android.exoplayer2.C#LENGTH_UNSET} if unknown, or 0 if the video is not rendered
+   *     onto a surface.
+   * @param height The surface height in pixels. May be {@link
+   *     com.google.android.exoplayer2.C#LENGTH_UNSET} if unknown, or 0 if the video is not rendered
+   *     onto a surface.
+   */
+  default void onSurfaceSizeChanged(int width, int height) {}
 
   /**
    * Called when a frame is rendered for the first time since setting the surface, and when a frame
    * is rendered for the first time since a video track was selected.
    */
-  void onRenderedFirstFrame();
+  default void onRenderedFirstFrame() {}
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
index d6ea0ebae2..7d78ba03c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
@@ -26,7 +26,8 @@
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
- * Listener of video {@link Renderer} events.
+ * Listener of video {@link Renderer} events. All methods have no-op default implementations to
+ * allow selective overrides.
  */
 public interface VideoRendererEventListener {
 
@@ -36,7 +37,7 @@
    * @param counters {@link DecoderCounters} that will be updated by the renderer for as long as it
    *     remains enabled.
    */
-  void onVideoEnabled(DecoderCounters counters);
+  default void onVideoEnabled(DecoderCounters counters) {}
 
   /**
    * Called when a decoder is created.
@@ -46,15 +47,15 @@
    *     finished.
    * @param initializationDurationMs The time taken to initialize the decoder in milliseconds.
    */
-  void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
-      long initializationDurationMs);
+  default void onVideoDecoderInitialized(
+      String decoderName, long initializedTimestampMs, long initializationDurationMs) {}
 
   /**
    * Called when the format of the media being consumed by the renderer changes.
    *
    * @param format The new format.
    */
-  void onVideoInputFormatChanged(Format format);
+  default void onVideoInputFormatChanged(Format format) {}
 
   /**
    * Called to report the number of frames dropped by the renderer. Dropped frames are reported
@@ -62,12 +63,11 @@ void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
    * reaches a specified threshold whilst the renderer is started.
    *
    * @param count The number of dropped frames.
-   * @param elapsedMs The duration in milliseconds over which the frames were dropped. This
-   *     duration is timed from when the renderer was started or from when dropped frames were
-   *     last reported (whichever was more recent), and not from when the first of the reported
-   *     drops occurred.
+   * @param elapsedMs The duration in milliseconds over which the frames were dropped. This duration
+   *     is timed from when the renderer was started or from when dropped frames were last reported
+   *     (whichever was more recent), and not from when the first of the reported drops occurred.
    */
-  void onDroppedFrames(int count, long elapsedMs);
+  default void onDroppedFrames(int count, long elapsedMs) {}
 
   /**
    * Called before a frame is rendered for the first time since setting the surface, and each time
@@ -82,12 +82,12 @@ void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
    *     this is not possible. Applications that use {@link TextureView} can apply the rotation by
    *     calling {@link TextureView#setTransform}. Applications that do not expect to encounter
    *     rotated videos can safely ignore this parameter.
-   * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case
-   *     of square pixels this will be equal to 1.0. Different values are indicative of anamorphic
+   * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case of
+   *     square pixels this will be equal to 1.0. Different values are indicative of anamorphic
    *     content.
    */
-  void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-      float pixelWidthHeightRatio);
+  default void onVideoSizeChanged(
+      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {}
 
   /**
    * Called when a frame is rendered for the first time since setting the surface, and when a frame
@@ -96,14 +96,14 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
    * @param surface The {@link Surface} to which a first frame has been rendered, or {@code null} if
    *     the renderer renders to something that isn't a {@link Surface}.
    */
-  void onRenderedFirstFrame(Surface surface);
+  default void onRenderedFirstFrame(@Nullable Surface surface) {}
 
   /**
    * Called when the renderer is disabled.
    *
    * @param counters {@link DecoderCounters} that were updated by the renderer.
    */
-  void onVideoDisabled(DecoderCounters counters);
+  default void onVideoDisabled(DecoderCounters counters) {}
 
   /**
    * Dispatches events to a {@link VideoRendererEventListener}.
@@ -124,106 +124,67 @@ public EventDispatcher(@Nullable Handler handler,
       this.listener = listener;
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onVideoEnabled(DecoderCounters)}.
-     */
-    public void enabled(final DecoderCounters decoderCounters) {
+    /** Invokes {@link VideoRendererEventListener#onVideoEnabled(DecoderCounters)}. */
+    public void enabled(DecoderCounters decoderCounters) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onVideoEnabled(decoderCounters);
-          }
-        });
+        handler.post(() -> listener.onVideoEnabled(decoderCounters));
       }
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onVideoDecoderInitialized(String, long, long)}.
-     */
-    public void decoderInitialized(final String decoderName,
-        final long initializedTimestampMs, final long initializationDurationMs) {
+    /** Invokes {@link VideoRendererEventListener#onVideoDecoderInitialized(String, long, long)}. */
+    public void decoderInitialized(
+        String decoderName, long initializedTimestampMs, long initializationDurationMs) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onVideoDecoderInitialized(decoderName, initializedTimestampMs,
-                initializationDurationMs);
-          }
-        });
+        handler.post(
+            () ->
+                listener.onVideoDecoderInitialized(
+                    decoderName, initializedTimestampMs, initializationDurationMs));
       }
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onVideoInputFormatChanged(Format)}.
-     */
-    public void inputFormatChanged(final Format format) {
+    /** Invokes {@link VideoRendererEventListener#onVideoInputFormatChanged(Format)}. */
+    public void inputFormatChanged(Format format) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            listener.onVideoInputFormatChanged(format);
-          }
-        });
+        handler.post(() -> listener.onVideoInputFormatChanged(format));
       }
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
-     */
-    public void droppedFrames(final int droppedFrameCount, final long elapsedMs) {
+    /** Invokes {@link VideoRendererEventListener#onDroppedFrames(int, long)}. */
+    public void droppedFrames(int droppedFrameCount, long elapsedMs) {
       if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onDroppedFrames(droppedFrameCount, elapsedMs);
-          }
-        });
+        handler.post(() -> listener.onDroppedFrames(droppedFrameCount, elapsedMs));
       }
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onVideoSizeChanged(int, int, int, float)}.
-     */
-    public void videoSizeChanged(final int width, final int height,
-        final int unappliedRotationDegrees, final float pixelWidthHeightRatio) {
+    /** Invokes {@link VideoRendererEventListener#onVideoSizeChanged(int, int, int, float)}. */
+    public void videoSizeChanged(
+        int width,
+        int height,
+        final int unappliedRotationDegrees,
+        final float pixelWidthHeightRatio) {
       if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
-                pixelWidthHeightRatio);
-          }
-        });
+        handler.post(
+            () ->
+                listener.onVideoSizeChanged(
+                    width, height, unappliedRotationDegrees, pixelWidthHeightRatio));
       }
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onRenderedFirstFrame(Surface)}.
-     */
-    public void renderedFirstFrame(final Surface surface) {
+    /** Invokes {@link VideoRendererEventListener#onRenderedFirstFrame(Surface)}. */
+    public void renderedFirstFrame(@Nullable Surface surface) {
       if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onRenderedFirstFrame(surface);
-          }
-        });
+        handler.post(() -> listener.onRenderedFirstFrame(surface));
       }
     }
 
-    /**
-     * Invokes {@link VideoRendererEventListener#onVideoDisabled(DecoderCounters)}.
-     */
-    public void disabled(final DecoderCounters counters) {
+    /** Invokes {@link VideoRendererEventListener#onVideoDisabled(DecoderCounters)}. */
+    public void disabled(DecoderCounters counters) {
       if (listener != null) {
-        handler.post(new Runnable() {
-          @Override
-          public void run() {
-            counters.ensureUpdated();
-            listener.onVideoDisabled(counters);
-          }
-        });
+        handler.post(
+            () -> {
+              counters.ensureUpdated();
+              listener.onVideoDisabled(counters);
+            });
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionListener.java
new file mode 100644
index 0000000000..3e9362c227
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionListener.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+/** Listens camera motion. */
+public interface CameraMotionListener {
+
+  /**
+   * Called when a new camera motion is read. This method is called on the playback thread.
+   *
+   * @param timeUs The presentation time of the data.
+   * @param rotation Angle axis orientation in radians representing the rotation from camera
+   *     coordinate system to world coordinate system.
+   */
+  void onCameraMotion(long timeUs, float[] rotation);
+
+  /** Called when the camera motion track position is reset or the track is disabled. */
+  void onCameraMotionReset();
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
new file mode 100644
index 0000000000..4a8354d17f
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.BaseRenderer;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
+
+/** A {@link Renderer} that parses the camera motion track. */
+public class CameraMotionRenderer extends BaseRenderer {
+
+  // The amount of time to read samples ahead of the current time.
+  private static final int SAMPLE_WINDOW_DURATION_US = 100000;
+
+  private final FormatHolder formatHolder;
+  private final DecoderInputBuffer buffer;
+  private final ParsableByteArray scratch;
+
+  private long offsetUs;
+  private @Nullable CameraMotionListener listener;
+  private long lastTimestampUs;
+
+  public CameraMotionRenderer() {
+    super(C.TRACK_TYPE_CAMERA_MOTION);
+    formatHolder = new FormatHolder();
+    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+    scratch = new ParsableByteArray();
+  }
+
+  @Override
+  public int supportsFormat(Format format) {
+    return MimeTypes.APPLICATION_CAMERA_MOTION.equals(format.sampleMimeType)
+        ? FORMAT_HANDLED
+        : FORMAT_UNSUPPORTED_TYPE;
+  }
+
+  @Override
+  public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
+    if (messageType == C.MSG_SET_CAMERA_MOTION_LISTENER) {
+      listener = (CameraMotionListener) message;
+    } else {
+      super.handleMessage(messageType, message);
+    }
+  }
+
+  @Override
+  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
+    this.offsetUs = offsetUs;
+  }
+
+  @Override
+  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+    reset();
+  }
+
+  @Override
+  protected void onDisabled() {
+    reset();
+  }
+
+  @Override
+  public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+    // Keep reading available samples as long as the sample time is not too far into the future.
+    while (!hasReadStreamToEnd() && lastTimestampUs < positionUs + SAMPLE_WINDOW_DURATION_US) {
+      buffer.clear();
+      int result = readSource(formatHolder, buffer, /* formatRequired= */ false);
+      if (result != C.RESULT_BUFFER_READ || buffer.isEndOfStream()) {
+        return;
+      }
+
+      buffer.flip();
+      lastTimestampUs = buffer.timeUs;
+      if (listener != null) {
+        float[] rotation = parseMetadata(buffer.data);
+        if (rotation != null) {
+          Util.castNonNull(listener).onCameraMotion(lastTimestampUs - offsetUs, rotation);
+        }
+      }
+    }
+  }
+
+  @Override
+  public boolean isEnded() {
+    return hasReadStreamToEnd();
+  }
+
+  @Override
+  public boolean isReady() {
+    return true;
+  }
+
+  private @Nullable float[] parseMetadata(ByteBuffer data) {
+    if (data.remaining() != 16) {
+      return null;
+    }
+    scratch.reset(data.array(), data.limit());
+    scratch.setPosition(data.arrayOffset() + 4); // skip reserved bytes too.
+    float[] result = new float[3];
+    for (int i = 0; i < 3; i++) {
+      result[i] = Float.intBitsToFloat(scratch.readLittleEndianInt());
+    }
+    return result;
+  }
+
+  private void reset() {
+    lastTimestampUs = 0;
+    if (listener != null) {
+      listener.onCameraMotionReset();
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java
new file mode 100644
index 0000000000..d7404cbce4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import android.opengl.Matrix;
+import com.google.android.exoplayer2.util.TimedValueQueue;
+
+/**
+ * This class serves multiple purposes:
+ *
+ * <ul>
+ *   <li>Queues the rotation metadata extracted from camera motion track.
+ *   <li>Converts the metadata to rotation matrices in OpenGl coordinate system.
+ *   <li>Recenters the rotations to componsate the yaw of the initial rotation.
+ * </ul>
+ */
+public final class FrameRotationQueue {
+  private final float[] recenterMatrix;
+  private final float[] rotationMatrix;
+  private final TimedValueQueue<float[]> rotations;
+  private boolean recenterMatrixComputed;
+
+  public FrameRotationQueue() {
+    recenterMatrix = new float[16];
+    rotationMatrix = new float[16];
+    rotations = new TimedValueQueue<>();
+  }
+
+  /**
+   * Sets a rotation for a given timestamp.
+   *
+   * @param timestampUs Timestamp of the rotation.
+   * @param angleAxis Angle axis orientation in radians representing the rotation from camera
+   *     coordinate system to world coordinate system.
+   */
+  public void setRotation(long timestampUs, float[] angleAxis) {
+    rotations.add(timestampUs, angleAxis);
+  }
+
+  /** Removes all of the rotations and forces rotations to be recentered. */
+  public void reset() {
+    rotations.clear();
+    recenterMatrixComputed = false;
+  }
+
+  /**
+   * Copies the rotation matrix with the greatest timestamp which is less than or equal to the given
+   * timestamp to {@code matrix}. Removes all older rotations and the returned one from the queue.
+   * Does nothing if there is no such rotation.
+   *
+   * @param matrix A float array to hold the rotation matrix.
+   * @param timestampUs The time in microseconds to query the rotation.
+   * @return Whether a rotation matrix is copied to {@code matrix}.
+   */
+  public boolean pollRotationMatrix(float[] matrix, long timestampUs) {
+    float[] rotation = rotations.pollFloor(timestampUs);
+    if (rotation == null) {
+      return false;
+    }
+    // TODO [Internal: b/113315546]: Slerp between the floor and ceil rotation.
+    getRotationMatrixFromAngleAxis(rotationMatrix, rotation);
+    if (!recenterMatrixComputed) {
+      computeRecenterMatrix(recenterMatrix, rotationMatrix);
+      recenterMatrixComputed = true;
+    }
+    Matrix.multiplyMM(matrix, 0, recenterMatrix, 0, rotationMatrix, 0);
+    return true;
+  }
+
+  /**
+   * Computes a recentering matrix from the given angle-axis rotation only accounting for yaw. Roll
+   * and tilt will not be compensated.
+   */
+  private static void computeRecenterMatrix(float[] recenterMatrix, float[] rotationMatrix) {
+    // The re-centering matrix is computed as follows:
+    // recenter.row(2) = temp.col(2).transpose();
+    // recenter.row(0) = recenter.row(1).cross(recenter.row(2)).normalized();
+    // recenter.row(2) = recenter.row(0).cross(recenter.row(1)).normalized();
+    //             | temp[10]  0   -temp[8]    0|
+    //             | 0         1    0          0|
+    // recenter =  | temp[8]   0    temp[10]   0|
+    //             | 0         0    0          1|
+    Matrix.setIdentityM(recenterMatrix, 0);
+    float normRowSqr =
+        rotationMatrix[10] * rotationMatrix[10] + rotationMatrix[8] * rotationMatrix[8];
+    float normRow = (float) Math.sqrt(normRowSqr);
+    recenterMatrix[0] = rotationMatrix[10] / normRow;
+    recenterMatrix[2] = rotationMatrix[8] / normRow;
+    recenterMatrix[8] = -rotationMatrix[8] / normRow;
+    recenterMatrix[10] = rotationMatrix[10] / normRow;
+  }
+
+  private static void getRotationMatrixFromAngleAxis(float[] matrix, float[] angleAxis) {
+    // Convert coordinates to OpenGL coordinates.
+    // CAMM motion metadata: +x right, +y down, and +z forward.
+    // OpenGL: +x right, +y up, -z forwards
+    float x = angleAxis[0];
+    float y = -angleAxis[1];
+    float z = -angleAxis[2];
+    float angleRad = Matrix.length(x, y, z);
+    if (angleRad != 0) {
+      float angleDeg = (float) Math.toDegrees(angleRad);
+      Matrix.setRotateM(matrix, 0, angleDeg, x / angleRad, y / angleRad, z / angleRad);
+    } else {
+      Matrix.setIdentityM(matrix, 0);
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
new file mode 100644
index 0000000000..3d4879d50a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import android.support.annotation.IntDef;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.C.StereoMode;
+import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** The projection mesh used with 360/VR videos. */
+public final class Projection {
+
+  /** Enforces allowed (sub) mesh draw modes. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({DRAW_MODE_TRIANGLES, DRAW_MODE_TRIANGLES_STRIP, DRAW_MODE_TRIANGLES_FAN})
+  public @interface DrawMode {}
+  /** Triangle draw mode. */
+  public static final int DRAW_MODE_TRIANGLES = 0;
+  /** Triangle strip draw mode. */
+  public static final int DRAW_MODE_TRIANGLES_STRIP = 1;
+  /** Triangle fan draw mode. */
+  public static final int DRAW_MODE_TRIANGLES_FAN = 2;
+
+  /** Number of position coordinates per vertex. */
+  public static final int TEXTURE_COORDS_PER_VERTEX = 2;
+  /** Number of texture coordinates per vertex. */
+  public static final int POSITION_COORDS_PER_VERTEX = 3;
+
+  /**
+   * Generates a complete sphere equirectangular projection.
+   *
+   * @param stereoMode A {@link C.StereoMode} value.
+   */
+  public static Projection createEquirectangular(@C.StereoMode int stereoMode) {
+    return createEquirectangular(
+        /* radius= */ 50, // Should be large enough that there are no stereo artifacts.
+        /* latitudes= */ 36, // Should be large enough to prevent videos looking wavy.
+        /* longitudes= */ 72, // Should be large enough to prevent videos looking wavy.
+        /* verticalFovDegrees= */ 180,
+        /* horizontalFovDegrees= */ 360,
+        stereoMode);
+  }
+
+  /**
+   * Generates an equirectangular projection.
+   *
+   * @param radius Size of the sphere. Must be &gt; 0.
+   * @param latitudes Number of rows that make up the sphere. Must be &gt;= 1.
+   * @param longitudes Number of columns that make up the sphere. Must be &gt;= 1.
+   * @param verticalFovDegrees Total latitudinal degrees that are covered by the sphere. Must be in
+   *     (0, 180].
+   * @param horizontalFovDegrees Total longitudinal degrees that are covered by the sphere.Must be
+   *     in (0, 360].
+   * @param stereoMode A {@link C.StereoMode} value.
+   * @return an equirectangular projection.
+   */
+  public static Projection createEquirectangular(
+      float radius,
+      int latitudes,
+      int longitudes,
+      float verticalFovDegrees,
+      float horizontalFovDegrees,
+      @C.StereoMode int stereoMode) {
+    Assertions.checkArgument(radius > 0);
+    Assertions.checkArgument(latitudes >= 1);
+    Assertions.checkArgument(longitudes >= 1);
+    Assertions.checkArgument(verticalFovDegrees > 0 && verticalFovDegrees <= 180);
+    Assertions.checkArgument(horizontalFovDegrees > 0 && horizontalFovDegrees <= 360);
+
+    // Compute angular size in radians of each UV quad.
+    float verticalFovRads = (float) Math.toRadians(verticalFovDegrees);
+    float horizontalFovRads = (float) Math.toRadians(horizontalFovDegrees);
+    float quadHeightRads = verticalFovRads / latitudes;
+    float quadWidthRads = horizontalFovRads / longitudes;
+
+    // Each latitude strip has 2 * (longitudes quads + extra edge) vertices + 2 degenerate vertices.
+    int vertexCount = (2 * (longitudes + 1) + 2) * latitudes;
+    // Buffer to return.
+    float[] vertexData = new float[vertexCount * POSITION_COORDS_PER_VERTEX];
+    float[] textureData = new float[vertexCount * TEXTURE_COORDS_PER_VERTEX];
+
+    // Generate the data for the sphere which is a set of triangle strips representing each
+    // latitude band.
+    int vOffset = 0; // Offset into the vertexData array.
+    int tOffset = 0; // Offset into the textureData array.
+    // (i, j) represents a quad in the equirectangular sphere.
+    for (int j = 0; j < latitudes; ++j) { // For each horizontal triangle strip.
+      // Each latitude band lies between the two phi values. Each vertical edge on a band lies on
+      // a theta value.
+      float phiLow = quadHeightRads * j - verticalFovRads / 2;
+      float phiHigh = quadHeightRads * (j + 1) - verticalFovRads / 2;
+
+      for (int i = 0; i < longitudes + 1; ++i) { // For each vertical edge in the band.
+        for (int k = 0; k < 2; ++k) { // For low and high points on an edge.
+          // For each point, determine it's position in polar coordinates.
+          float phi = k == 0 ? phiLow : phiHigh;
+          float theta = quadWidthRads * i + (float) Math.PI - horizontalFovRads / 2;
+
+          // Set vertex position data as Cartesian coordinates.
+          vertexData[vOffset++] = -(float) (radius * Math.sin(theta) * Math.cos(phi));
+          vertexData[vOffset++] = (float) (radius * Math.sin(phi));
+          vertexData[vOffset++] = (float) (radius * Math.cos(theta) * Math.cos(phi));
+
+          textureData[tOffset++] = i * quadWidthRads / horizontalFovRads;
+          textureData[tOffset++] = (j + k) * quadHeightRads / verticalFovRads;
+
+          // Break up the triangle strip with degenerate vertices by copying first and last points.
+          if ((i == 0 && k == 0) || (i == longitudes && k == 1)) {
+            System.arraycopy(
+                vertexData,
+                vOffset - POSITION_COORDS_PER_VERTEX,
+                vertexData,
+                vOffset,
+                POSITION_COORDS_PER_VERTEX);
+            vOffset += POSITION_COORDS_PER_VERTEX;
+            System.arraycopy(
+                textureData,
+                tOffset - TEXTURE_COORDS_PER_VERTEX,
+                textureData,
+                tOffset,
+                TEXTURE_COORDS_PER_VERTEX);
+            tOffset += TEXTURE_COORDS_PER_VERTEX;
+          }
+        }
+        // Move on to the next vertical edge in the triangle strip.
+      }
+      // Move on to the next triangle strip.
+    }
+    SubMesh subMesh =
+        new SubMesh(SubMesh.VIDEO_TEXTURE_ID, vertexData, textureData, DRAW_MODE_TRIANGLES_STRIP);
+    return new Projection(new Mesh(subMesh), stereoMode);
+  }
+
+  /** The Mesh corresponding to the left eye. */
+  public final Mesh leftMesh;
+  /**
+   * The Mesh corresponding to the right eye. If {@code singleMesh} is true then this mesh is
+   * identical to {@link #leftMesh}.
+   */
+  public final Mesh rightMesh;
+  /** The stereo mode. */
+  public final @StereoMode int stereoMode;
+  /** Whether the left and right mesh are identical. */
+  public final boolean singleMesh;
+
+  /**
+   * Creates a Projection with single mesh.
+   *
+   * @param mesh the Mesh for both eyes.
+   * @param stereoMode A {@link StereoMode} value.
+   */
+  public Projection(Mesh mesh, int stereoMode) {
+    this(mesh, mesh, stereoMode);
+  }
+
+  /**
+   * Creates a Projection with dual mesh. Use {@link #Projection(Mesh, int)} if there is single mesh
+   * for both eyes.
+   *
+   * @param leftMesh the Mesh corresponding to the left eye.
+   * @param rightMesh the Mesh corresponding to the right eye.
+   * @param stereoMode A {@link C.StereoMode} value.
+   */
+  public Projection(Mesh leftMesh, Mesh rightMesh, int stereoMode) {
+    this.leftMesh = leftMesh;
+    this.rightMesh = rightMesh;
+    this.stereoMode = stereoMode;
+    this.singleMesh = leftMesh == rightMesh;
+  }
+
+  /** The sub mesh associated with the {@link Mesh}. */
+  public static final class SubMesh {
+    /** Texture ID for video frames. */
+    public static final int VIDEO_TEXTURE_ID = 0;
+
+    /** Texture ID. */
+    public final int textureId;
+    /** The drawing mode. One of {@link DrawMode}. */
+    public final @DrawMode int mode;
+    /** The SubMesh vertices. */
+    public final float[] vertices;
+    /** The SubMesh texture coordinates. */
+    public final float[] textureCoords;
+
+    public SubMesh(int textureId, float[] vertices, float[] textureCoords, @DrawMode int mode) {
+      this.textureId = textureId;
+      Assertions.checkArgument(
+          vertices.length * (long) TEXTURE_COORDS_PER_VERTEX
+              == textureCoords.length * (long) POSITION_COORDS_PER_VERTEX);
+      this.vertices = vertices;
+      this.textureCoords = textureCoords;
+      this.mode = mode;
+    }
+
+    /** Returns the SubMesh vertex count. */
+    public int getVertexCount() {
+      return vertices.length / POSITION_COORDS_PER_VERTEX;
+    }
+  }
+
+  /** A Mesh associated with the projection scene. */
+  public static final class Mesh {
+    private final SubMesh[] subMeshes;
+
+    public Mesh(SubMesh... subMeshes) {
+      this.subMeshes = subMeshes;
+    }
+
+    /** Returns the number of sub meshes. */
+    public int getSubMeshCount() {
+      return subMeshes.length;
+    }
+
+    /** Returns the SubMesh for the given index. */
+    public SubMesh getSubMesh(int index) {
+      return subMeshes[index];
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java
new file mode 100644
index 0000000000..7a3c4998b3
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.spherical.Projection.Mesh;
+import com.google.android.exoplayer2.video.spherical.Projection.SubMesh;
+import java.util.ArrayList;
+import java.util.zip.Inflater;
+
+/**
+ * A decoder for the projection mesh.
+ *
+ * <p>The mesh boxes parsed are described at <a
+ * href="https://github.com/google/spatial-media/blob/master/docs/spherical-video-v2-rfc.md">
+ * Spherical Video V2 RFC</a>.
+ *
+ * <p>The decoder does not perform CRC checks at the moment.
+ */
+public final class ProjectionDecoder {
+
+  private static final int TYPE_YTMP = Util.getIntegerCodeForString("ytmp");
+  private static final int TYPE_MSHP = Util.getIntegerCodeForString("mshp");
+  private static final int TYPE_RAW = Util.getIntegerCodeForString("raw ");
+  private static final int TYPE_DFL8 = Util.getIntegerCodeForString("dfl8");
+  private static final int TYPE_MESH = Util.getIntegerCodeForString("mesh");
+  private static final int TYPE_PROJ = Util.getIntegerCodeForString("proj");
+
+  // Sanity limits to prevent a bad file from creating an OOM situation. We don't expect a mesh to
+  // exceed these limits.
+  private static final int MAX_COORDINATE_COUNT = 10000;
+  private static final int MAX_VERTEX_COUNT = 32 * 1000;
+  private static final int MAX_TRIANGLE_INDICES = 128 * 1000;
+
+  private ProjectionDecoder() {}
+
+  /*
+   * Decodes the projection data.
+   *
+   * @param projectionData The projection data.
+   * @param stereoMode A {@link C.StereoMode} value.
+   * @return The projection or null if the data can't be decoded.
+   */
+  public static @Nullable Projection decode(byte[] projectionData, @C.StereoMode int stereoMode) {
+    ParsableByteArray input = new ParsableByteArray(projectionData);
+    // MP4 containers include the proj box but webm containers do not.
+    // Both containers use mshp.
+    ArrayList<Mesh> meshes = null;
+    try {
+      meshes = isProj(input) ? parseProj(input) : parseMshp(input);
+    } catch (ArrayIndexOutOfBoundsException ignored) {
+      // Do nothing.
+    }
+    if (meshes == null) {
+      return null;
+    } else {
+      switch (meshes.size()) {
+        case 1:
+          return new Projection(meshes.get(0), stereoMode);
+        case 2:
+          return new Projection(meshes.get(0), meshes.get(1), stereoMode);
+        case 0:
+        default:
+          return null;
+      }
+    }
+  }
+
+  /** Returns true if the input contains a proj box. Indicates MP4 container. */
+  private static boolean isProj(ParsableByteArray input) {
+    input.skipBytes(4); // size
+    int type = input.readInt();
+    input.setPosition(0);
+    return type == TYPE_PROJ;
+  }
+
+  private static @Nullable ArrayList<Mesh> parseProj(ParsableByteArray input) {
+    input.skipBytes(8); // size and type.
+    int position = input.getPosition();
+    int limit = input.limit();
+    while (position < limit) {
+      int childEnd = position + input.readInt();
+      if (childEnd <= position || childEnd > limit) {
+        return null;
+      }
+      int childAtomType = input.readInt();
+      // Some early files named the atom ytmp rather than mshp.
+      if (childAtomType == TYPE_YTMP || childAtomType == TYPE_MSHP) {
+        input.setLimit(childEnd);
+        return parseMshp(input);
+      }
+      position = childEnd;
+      input.setPosition(position);
+    }
+    return null;
+  }
+
+  private static @Nullable ArrayList<Mesh> parseMshp(ParsableByteArray input) {
+    int version = input.readUnsignedByte();
+    if (version != 0) {
+      return null;
+    }
+    input.skipBytes(7); // flags + crc.
+    int encoding = input.readInt();
+    if (encoding == TYPE_DFL8) {
+      ParsableByteArray output = new ParsableByteArray();
+      Inflater inflater = new Inflater(true);
+      try {
+        if (!Util.inflate(input, output, inflater)) {
+          return null;
+        }
+      } finally {
+        inflater.end();
+      }
+      input = output;
+    } else if (encoding != TYPE_RAW) {
+      return null;
+    }
+    return parseRawMshpData(input);
+  }
+
+  /** Parses MSHP data after the encoding_four_cc field. */
+  private static @Nullable ArrayList<Mesh> parseRawMshpData(ParsableByteArray input) {
+    ArrayList<Mesh> meshes = new ArrayList<>();
+    int position = input.getPosition();
+    int limit = input.limit();
+    while (position < limit) {
+      int childEnd = position + input.readInt();
+      if (childEnd <= position || childEnd > limit) {
+        return null;
+      }
+      int childAtomType = input.readInt();
+      if (childAtomType == TYPE_MESH) {
+        Mesh mesh = parseMesh(input);
+        if (mesh == null) {
+          return null;
+        }
+        meshes.add(mesh);
+      }
+      position = childEnd;
+      input.setPosition(position);
+    }
+    return meshes;
+  }
+
+  private static @Nullable Mesh parseMesh(ParsableByteArray input) {
+    // Read the coordinates.
+    int coordinateCount = input.readInt();
+    if (coordinateCount > MAX_COORDINATE_COUNT) {
+      return null;
+    }
+    float[] coordinates = new float[coordinateCount];
+    for (int coordinate = 0; coordinate < coordinateCount; coordinate++) {
+      coordinates[coordinate] = input.readFloat();
+    }
+    // Read the vertices.
+    int vertexCount = input.readInt();
+    if (vertexCount > MAX_VERTEX_COUNT) {
+      return null;
+    }
+
+    final double log2 = Math.log(2.0);
+    int coordinateCountSizeBits = (int) Math.ceil(Math.log(2.0 * coordinateCount) / log2);
+
+    ParsableBitArray bitInput = new ParsableBitArray(input.data);
+    bitInput.setPosition(input.getPosition() * 8);
+    float[] vertices = new float[vertexCount * 5];
+    int[] coordinateIndices = new int[5];
+    int vertexIndex = 0;
+    for (int vertex = 0; vertex < vertexCount; vertex++) {
+      for (int i = 0; i < 5; i++) {
+        int coordinateIndex =
+            coordinateIndices[i] + decodeZigZag(bitInput.readBits(coordinateCountSizeBits));
+        if (coordinateIndex >= coordinateCount || coordinateIndex < 0) {
+          return null;
+        }
+        vertices[vertexIndex++] = coordinates[coordinateIndex];
+        coordinateIndices[i] = coordinateIndex;
+      }
+    }
+
+    // Pad to next byte boundary
+    bitInput.setPosition(((bitInput.getPosition() + 7) & ~7));
+
+    int subMeshCount = bitInput.readBits(32);
+    SubMesh[] subMeshes = new SubMesh[subMeshCount];
+    for (int i = 0; i < subMeshCount; i++) {
+      int textureId = bitInput.readBits(8);
+      int drawMode = bitInput.readBits(8);
+      int triangleIndexCount = bitInput.readBits(32);
+      if (triangleIndexCount > MAX_TRIANGLE_INDICES) {
+        return null;
+      }
+      int vertexCountSizeBits = (int) Math.ceil(Math.log(2.0 * vertexCount) / log2);
+      int index = 0;
+      float[] triangleVertices = new float[triangleIndexCount * 3];
+      float[] textureCoords = new float[triangleIndexCount * 2];
+      for (int counter = 0; counter < triangleIndexCount; counter++) {
+        index += decodeZigZag(bitInput.readBits(vertexCountSizeBits));
+        if (index < 0 || index >= vertexCount) {
+          return null;
+        }
+        triangleVertices[counter * 3] = vertices[index * 5];
+        triangleVertices[counter * 3 + 1] = vertices[index * 5 + 1];
+        triangleVertices[counter * 3 + 2] = vertices[index * 5 + 2];
+        textureCoords[counter * 2] = vertices[index * 5 + 3];
+        textureCoords[counter * 2 + 1] = vertices[index * 5 + 4];
+      }
+      subMeshes[i] = new SubMesh(textureId, triangleVertices, textureCoords, drawMode);
+    }
+    return new Mesh(subMeshes);
+  }
+
+  /**
+   * Decodes Zigzag encoding as described in
+   * https://developers.google.com/protocol-buffers/docs/encoding#signed-integers
+   */
+  private static int decodeZigZag(int n) {
+    return (n >> 1) ^ -(n & 1);
+  }
+}
diff --git a/library/core/src/test/assets/amr/sample_nb_cbr.amr b/library/core/src/test/assets/amr/sample_nb_cbr.amr
new file mode 100644
index 0000000000..2e21cc843c
Binary files /dev/null and b/library/core/src/test/assets/amr/sample_nb_cbr.amr differ
diff --git a/library/core/src/test/assets/amr/sample_nb_cbr.amr.0.dump b/library/core/src/test/assets/amr/sample_nb_cbr.amr.0.dump
new file mode 100644
index 0000000000..e8ba3c3588
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_nb_cbr.amr.0.dump
@@ -0,0 +1,902 @@
+seekMap:
+  isSeekable = true
+  duration = 4360000
+  getPosition(0) = [[timeUs=0, position=6]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/3gpp
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 8000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 2834
+  sample count = 218
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 13, hash 371B046C
+  sample 1:
+    time = 20000
+    flags = 1
+    data = length 13, hash CE30BF5B
+  sample 2:
+    time = 40000
+    flags = 1
+    data = length 13, hash 19A59975
+  sample 3:
+    time = 60000
+    flags = 1
+    data = length 13, hash 4879773C
+  sample 4:
+    time = 80000
+    flags = 1
+    data = length 13, hash E8F83019
+  sample 5:
+    time = 100000
+    flags = 1
+    data = length 13, hash D265CDC9
+  sample 6:
+    time = 120000
+    flags = 1
+    data = length 13, hash 91653DAA
+  sample 7:
+    time = 140000
+    flags = 1
+    data = length 13, hash C79456F6
+  sample 8:
+    time = 160000
+    flags = 1
+    data = length 13, hash CDDC4422
+  sample 9:
+    time = 180000
+    flags = 1
+    data = length 13, hash D9ED3AF1
+  sample 10:
+    time = 200000
+    flags = 1
+    data = length 13, hash BAB75A33
+  sample 11:
+    time = 220000
+    flags = 1
+    data = length 13, hash 2221B4FF
+  sample 12:
+    time = 240000
+    flags = 1
+    data = length 13, hash 96400A0B
+  sample 13:
+    time = 260000
+    flags = 1
+    data = length 13, hash 582E6FB
+  sample 14:
+    time = 280000
+    flags = 1
+    data = length 13, hash C4E878E5
+  sample 15:
+    time = 300000
+    flags = 1
+    data = length 13, hash C849A1BD
+  sample 16:
+    time = 320000
+    flags = 1
+    data = length 13, hash CFA8A9ED
+  sample 17:
+    time = 340000
+    flags = 1
+    data = length 13, hash 70CA4907
+  sample 18:
+    time = 360000
+    flags = 1
+    data = length 13, hash B47D4454
+  sample 19:
+    time = 380000
+    flags = 1
+    data = length 13, hash 282998C1
+  sample 20:
+    time = 400000
+    flags = 1
+    data = length 13, hash 3F3F7A65
+  sample 21:
+    time = 420000
+    flags = 1
+    data = length 13, hash CC2EAB58
+  sample 22:
+    time = 440000
+    flags = 1
+    data = length 13, hash 279EF712
+  sample 23:
+    time = 460000
+    flags = 1
+    data = length 13, hash AA2F4B29
+  sample 24:
+    time = 480000
+    flags = 1
+    data = length 13, hash F6F658C4
+  sample 25:
+    time = 500000
+    flags = 1
+    data = length 13, hash D7DEBD17
+  sample 26:
+    time = 520000
+    flags = 1
+    data = length 13, hash 6DAB9A17
+  sample 27:
+    time = 540000
+    flags = 1
+    data = length 13, hash 6ECE1571
+  sample 28:
+    time = 560000
+    flags = 1
+    data = length 13, hash B3D0507F
+  sample 29:
+    time = 580000
+    flags = 1
+    data = length 13, hash 21E356B9
+  sample 30:
+    time = 600000
+    flags = 1
+    data = length 13, hash 410EA12
+  sample 31:
+    time = 620000
+    flags = 1
+    data = length 13, hash 533895A8
+  sample 32:
+    time = 640000
+    flags = 1
+    data = length 13, hash C61B3E5A
+  sample 33:
+    time = 660000
+    flags = 1
+    data = length 13, hash 982170E6
+  sample 34:
+    time = 680000
+    flags = 1
+    data = length 13, hash 7A0468C5
+  sample 35:
+    time = 700000
+    flags = 1
+    data = length 13, hash 9C85EAA7
+  sample 36:
+    time = 720000
+    flags = 1
+    data = length 13, hash B6B341B6
+  sample 37:
+    time = 740000
+    flags = 1
+    data = length 13, hash 6937532E
+  sample 38:
+    time = 760000
+    flags = 1
+    data = length 13, hash 8CF2A3A0
+  sample 39:
+    time = 780000
+    flags = 1
+    data = length 13, hash D2682AC6
+  sample 40:
+    time = 800000
+    flags = 1
+    data = length 13, hash BBC5710F
+  sample 41:
+    time = 820000
+    flags = 1
+    data = length 13, hash 59080B6C
+  sample 42:
+    time = 840000
+    flags = 1
+    data = length 13, hash E4118291
+  sample 43:
+    time = 860000
+    flags = 1
+    data = length 13, hash A1E5B296
+  sample 44:
+    time = 880000
+    flags = 1
+    data = length 13, hash D7B8F95B
+  sample 45:
+    time = 900000
+    flags = 1
+    data = length 13, hash CC839BE1
+  sample 46:
+    time = 920000
+    flags = 1
+    data = length 13, hash D459DFCE
+  sample 47:
+    time = 940000
+    flags = 1
+    data = length 13, hash D6AD19EC
+  sample 48:
+    time = 960000
+    flags = 1
+    data = length 13, hash D05E373D
+  sample 49:
+    time = 980000
+    flags = 1
+    data = length 13, hash 6A4460C7
+  sample 50:
+    time = 1000000
+    flags = 1
+    data = length 13, hash C9A0D93F
+  sample 51:
+    time = 1020000
+    flags = 1
+    data = length 13, hash 3FA819E7
+  sample 52:
+    time = 1040000
+    flags = 1
+    data = length 13, hash 1D3CBDFC
+  sample 53:
+    time = 1060000
+    flags = 1
+    data = length 13, hash 8BBBB403
+  sample 54:
+    time = 1080000
+    flags = 1
+    data = length 13, hash 21B4A0F9
+  sample 55:
+    time = 1100000
+    flags = 1
+    data = length 13, hash C0F921D1
+  sample 56:
+    time = 1120000
+    flags = 1
+    data = length 13, hash 5D812AAB
+  sample 57:
+    time = 1140000
+    flags = 1
+    data = length 13, hash 50C9F3F8
+  sample 58:
+    time = 1160000
+    flags = 1
+    data = length 13, hash 5C2BB5D1
+  sample 59:
+    time = 1180000
+    flags = 1
+    data = length 13, hash 6BF9BEA5
+  sample 60:
+    time = 1200000
+    flags = 1
+    data = length 13, hash 2738C1E6
+  sample 61:
+    time = 1220000
+    flags = 1
+    data = length 13, hash 5FC288A6
+  sample 62:
+    time = 1240000
+    flags = 1
+    data = length 13, hash 7E8E442A
+  sample 63:
+    time = 1260000
+    flags = 1
+    data = length 13, hash AEAA2BBA
+  sample 64:
+    time = 1280000
+    flags = 1
+    data = length 13, hash 4E2ACD2F
+  sample 65:
+    time = 1300000
+    flags = 1
+    data = length 13, hash D6C90ACF
+  sample 66:
+    time = 1320000
+    flags = 1
+    data = length 13, hash 6FD8A944
+  sample 67:
+    time = 1340000
+    flags = 1
+    data = length 13, hash A835BBF9
+  sample 68:
+    time = 1360000
+    flags = 1
+    data = length 13, hash F7713830
+  sample 69:
+    time = 1380000
+    flags = 1
+    data = length 13, hash 3AA966E5
+  sample 70:
+    time = 1400000
+    flags = 1
+    data = length 13, hash F939E829
+  sample 71:
+    time = 1420000
+    flags = 1
+    data = length 13, hash 7676DE49
+  sample 72:
+    time = 1440000
+    flags = 1
+    data = length 13, hash 93BB890A
+  sample 73:
+    time = 1460000
+    flags = 1
+    data = length 13, hash B57DBEC8
+  sample 74:
+    time = 1480000
+    flags = 1
+    data = length 13, hash 66B0A5B6
+  sample 75:
+    time = 1500000
+    flags = 1
+    data = length 13, hash D733E0D
+  sample 76:
+    time = 1520000
+    flags = 1
+    data = length 13, hash 80941726
+  sample 77:
+    time = 1540000
+    flags = 1
+    data = length 13, hash 556ED633
+  sample 78:
+    time = 1560000
+    flags = 1
+    data = length 13, hash C5EDF4E1
+  sample 79:
+    time = 1580000
+    flags = 1
+    data = length 13, hash 6B287445
+  sample 80:
+    time = 1600000
+    flags = 1
+    data = length 13, hash DC97C4A7
+  sample 81:
+    time = 1620000
+    flags = 1
+    data = length 13, hash DA8CBDF4
+  sample 82:
+    time = 1640000
+    flags = 1
+    data = length 13, hash 6F60FF77
+  sample 83:
+    time = 1660000
+    flags = 1
+    data = length 13, hash 3EB22B96
+  sample 84:
+    time = 1680000
+    flags = 1
+    data = length 13, hash B3C31AF5
+  sample 85:
+    time = 1700000
+    flags = 1
+    data = length 13, hash 1854AA92
+  sample 86:
+    time = 1720000
+    flags = 1
+    data = length 13, hash 6488264B
+  sample 87:
+    time = 1740000
+    flags = 1
+    data = length 13, hash 4CC8C5C1
+  sample 88:
+    time = 1760000
+    flags = 1
+    data = length 13, hash 19CC7523
+  sample 89:
+    time = 1780000
+    flags = 1
+    data = length 13, hash 9BE7B928
+  sample 90:
+    time = 1800000
+    flags = 1
+    data = length 13, hash 47EC7CFD
+  sample 91:
+    time = 1820000
+    flags = 1
+    data = length 13, hash EC940120
+  sample 92:
+    time = 1840000
+    flags = 1
+    data = length 13, hash 73BDA6D0
+  sample 93:
+    time = 1860000
+    flags = 1
+    data = length 13, hash FACB3314
+  sample 94:
+    time = 1880000
+    flags = 1
+    data = length 13, hash EC61D13B
+  sample 95:
+    time = 1900000
+    flags = 1
+    data = length 13, hash B28C7B6C
+  sample 96:
+    time = 1920000
+    flags = 1
+    data = length 13, hash B1A4CECD
+  sample 97:
+    time = 1940000
+    flags = 1
+    data = length 13, hash 56D41BA6
+  sample 98:
+    time = 1960000
+    flags = 1
+    data = length 13, hash 90499F4
+  sample 99:
+    time = 1980000
+    flags = 1
+    data = length 13, hash 65D9A9D3
+  sample 100:
+    time = 2000000
+    flags = 1
+    data = length 13, hash D9004CC
+  sample 101:
+    time = 2020000
+    flags = 1
+    data = length 13, hash 4139C6ED
+  sample 102:
+    time = 2040000
+    flags = 1
+    data = length 13, hash C4F8097C
+  sample 103:
+    time = 2060000
+    flags = 1
+    data = length 13, hash 94D424FA
+  sample 104:
+    time = 2080000
+    flags = 1
+    data = length 13, hash C2C6F5FD
+  sample 105:
+    time = 2100000
+    flags = 1
+    data = length 13, hash 15719008
+  sample 106:
+    time = 2120000
+    flags = 1
+    data = length 13, hash 4F64F524
+  sample 107:
+    time = 2140000
+    flags = 1
+    data = length 13, hash F9E01C1E
+  sample 108:
+    time = 2160000
+    flags = 1
+    data = length 13, hash 74C4EE74
+  sample 109:
+    time = 2180000
+    flags = 1
+    data = length 13, hash 7EE7553D
+  sample 110:
+    time = 2200000
+    flags = 1
+    data = length 13, hash 62DE6539
+  sample 111:
+    time = 2220000
+    flags = 1
+    data = length 13, hash 7F5EC222
+  sample 112:
+    time = 2240000
+    flags = 1
+    data = length 13, hash 644067F
+  sample 113:
+    time = 2260000
+    flags = 1
+    data = length 13, hash CDF6C9DC
+  sample 114:
+    time = 2280000
+    flags = 1
+    data = length 13, hash 8B5DBC80
+  sample 115:
+    time = 2300000
+    flags = 1
+    data = length 13, hash AD4BBA03
+  sample 116:
+    time = 2320000
+    flags = 1
+    data = length 13, hash 7A76340
+  sample 117:
+    time = 2340000
+    flags = 1
+    data = length 13, hash 3610F5B0
+  sample 118:
+    time = 2360000
+    flags = 1
+    data = length 13, hash 430BC60B
+  sample 119:
+    time = 2380000
+    flags = 1
+    data = length 13, hash 99CF1CA6
+  sample 120:
+    time = 2400000
+    flags = 1
+    data = length 13, hash 1331C70B
+  sample 121:
+    time = 2420000
+    flags = 1
+    data = length 13, hash BD76E69D
+  sample 122:
+    time = 2440000
+    flags = 1
+    data = length 13, hash 5DA652AC
+  sample 123:
+    time = 2460000
+    flags = 1
+    data = length 13, hash 3B7BF6CE
+  sample 124:
+    time = 2480000
+    flags = 1
+    data = length 13, hash ABBFD143
+  sample 125:
+    time = 2500000
+    flags = 1
+    data = length 13, hash E9447166
+  sample 126:
+    time = 2520000
+    flags = 1
+    data = length 13, hash EC40068C
+  sample 127:
+    time = 2540000
+    flags = 1
+    data = length 13, hash A2869400
+  sample 128:
+    time = 2560000
+    flags = 1
+    data = length 13, hash C7E0746B
+  sample 129:
+    time = 2580000
+    flags = 1
+    data = length 13, hash 60601BB1
+  sample 130:
+    time = 2600000
+    flags = 1
+    data = length 13, hash 975AAE9B
+  sample 131:
+    time = 2620000
+    flags = 1
+    data = length 13, hash 8BBC0EB2
+  sample 132:
+    time = 2640000
+    flags = 1
+    data = length 13, hash 57FB39E5
+  sample 133:
+    time = 2660000
+    flags = 1
+    data = length 13, hash 4CDCEEDB
+  sample 134:
+    time = 2680000
+    flags = 1
+    data = length 13, hash EA16E256
+  sample 135:
+    time = 2700000
+    flags = 1
+    data = length 13, hash 287E7D9E
+  sample 136:
+    time = 2720000
+    flags = 1
+    data = length 13, hash 55AB8FB9
+  sample 137:
+    time = 2740000
+    flags = 1
+    data = length 13, hash 129890EF
+  sample 138:
+    time = 2760000
+    flags = 1
+    data = length 13, hash 90834F57
+  sample 139:
+    time = 2780000
+    flags = 1
+    data = length 13, hash 5B3228E0
+  sample 140:
+    time = 2800000
+    flags = 1
+    data = length 13, hash DD19E175
+  sample 141:
+    time = 2820000
+    flags = 1
+    data = length 13, hash EE7EA342
+  sample 142:
+    time = 2840000
+    flags = 1
+    data = length 13, hash DB3AF473
+  sample 143:
+    time = 2860000
+    flags = 1
+    data = length 13, hash 25AEC43F
+  sample 144:
+    time = 2880000
+    flags = 1
+    data = length 13, hash EE9BF97F
+  sample 145:
+    time = 2900000
+    flags = 1
+    data = length 13, hash FFFBE047
+  sample 146:
+    time = 2920000
+    flags = 1
+    data = length 13, hash BEACFCB0
+  sample 147:
+    time = 2940000
+    flags = 1
+    data = length 13, hash AEB5096C
+  sample 148:
+    time = 2960000
+    flags = 1
+    data = length 13, hash B0D381B
+  sample 149:
+    time = 2980000
+    flags = 1
+    data = length 13, hash 3D9D5122
+  sample 150:
+    time = 3000000
+    flags = 1
+    data = length 13, hash 6C1DDB95
+  sample 151:
+    time = 3020000
+    flags = 1
+    data = length 13, hash ADACADCF
+  sample 152:
+    time = 3040000
+    flags = 1
+    data = length 13, hash 159E321E
+  sample 153:
+    time = 3060000
+    flags = 1
+    data = length 13, hash B1466264
+  sample 154:
+    time = 3080000
+    flags = 1
+    data = length 13, hash 4DDF7223
+  sample 155:
+    time = 3100000
+    flags = 1
+    data = length 13, hash C9BDB82A
+  sample 156:
+    time = 3120000
+    flags = 1
+    data = length 13, hash A49B2D9D
+  sample 157:
+    time = 3140000
+    flags = 1
+    data = length 13, hash D645E7E5
+  sample 158:
+    time = 3160000
+    flags = 1
+    data = length 13, hash 1C4232DC
+  sample 159:
+    time = 3180000
+    flags = 1
+    data = length 13, hash 83078219
+  sample 160:
+    time = 3200000
+    flags = 1
+    data = length 13, hash D6D8B072
+  sample 161:
+    time = 3220000
+    flags = 1
+    data = length 13, hash 975DB40
+  sample 162:
+    time = 3240000
+    flags = 1
+    data = length 13, hash A15FDD05
+  sample 163:
+    time = 3260000
+    flags = 1
+    data = length 13, hash 4B839E41
+  sample 164:
+    time = 3280000
+    flags = 1
+    data = length 13, hash 7418F499
+  sample 165:
+    time = 3300000
+    flags = 1
+    data = length 13, hash 7A4945E4
+  sample 166:
+    time = 3320000
+    flags = 1
+    data = length 13, hash 6249558C
+  sample 167:
+    time = 3340000
+    flags = 1
+    data = length 13, hash BD4C5BE3
+  sample 168:
+    time = 3360000
+    flags = 1
+    data = length 13, hash BAB30F1D
+  sample 169:
+    time = 3380000
+    flags = 1
+    data = length 13, hash 1E1C7012
+  sample 170:
+    time = 3400000
+    flags = 1
+    data = length 13, hash 9A3F8A89
+  sample 171:
+    time = 3420000
+    flags = 1
+    data = length 13, hash 20BE6D7B
+  sample 172:
+    time = 3440000
+    flags = 1
+    data = length 13, hash CAA0591D
+  sample 173:
+    time = 3460000
+    flags = 1
+    data = length 13, hash 6D554D17
+  sample 174:
+    time = 3480000
+    flags = 1
+    data = length 13, hash D97C3B31
+  sample 175:
+    time = 3500000
+    flags = 1
+    data = length 13, hash 75BC5C3
+  sample 176:
+    time = 3520000
+    flags = 1
+    data = length 13, hash 7BA1784B
+  sample 177:
+    time = 3540000
+    flags = 1
+    data = length 13, hash 1D175D92
+  sample 178:
+    time = 3560000
+    flags = 1
+    data = length 13, hash ADCA60FD
+  sample 179:
+    time = 3580000
+    flags = 1
+    data = length 13, hash 37018693
+  sample 180:
+    time = 3600000
+    flags = 1
+    data = length 13, hash 4553606F
+  sample 181:
+    time = 3620000
+    flags = 1
+    data = length 13, hash CF434565
+  sample 182:
+    time = 3640000
+    flags = 1
+    data = length 13, hash D264D757
+  sample 183:
+    time = 3660000
+    flags = 1
+    data = length 13, hash 4FB493EF
+  sample 184:
+    time = 3680000
+    flags = 1
+    data = length 13, hash 919F53A
+  sample 185:
+    time = 3700000
+    flags = 1
+    data = length 13, hash C22B009B
+  sample 186:
+    time = 3720000
+    flags = 1
+    data = length 13, hash 5981470
+  sample 187:
+    time = 3740000
+    flags = 1
+    data = length 13, hash A5D3937C
+  sample 188:
+    time = 3760000
+    flags = 1
+    data = length 13, hash A2504429
+  sample 189:
+    time = 3780000
+    flags = 1
+    data = length 13, hash AD1B70BE
+  sample 190:
+    time = 3800000
+    flags = 1
+    data = length 13, hash 2E39ED5E
+  sample 191:
+    time = 3820000
+    flags = 1
+    data = length 13, hash 13A8BE8E
+  sample 192:
+    time = 3840000
+    flags = 1
+    data = length 13, hash 1ACD740B
+  sample 193:
+    time = 3860000
+    flags = 1
+    data = length 13, hash 80F38B3
+  sample 194:
+    time = 3880000
+    flags = 1
+    data = length 13, hash DA9DA79F
+  sample 195:
+    time = 3900000
+    flags = 1
+    data = length 13, hash 21B95B7E
+  sample 196:
+    time = 3920000
+    flags = 1
+    data = length 13, hash CD22497B
+  sample 197:
+    time = 3940000
+    flags = 1
+    data = length 13, hash 718BB35D
+  sample 198:
+    time = 3960000
+    flags = 1
+    data = length 13, hash 69ABA6AD
+  sample 199:
+    time = 3980000
+    flags = 1
+    data = length 13, hash BAE19549
+  sample 200:
+    time = 4000000
+    flags = 1
+    data = length 13, hash 2A792FB3
+  sample 201:
+    time = 4020000
+    flags = 1
+    data = length 13, hash 71FCD8
+  sample 202:
+    time = 4040000
+    flags = 1
+    data = length 13, hash 44D2B5B3
+  sample 203:
+    time = 4060000
+    flags = 1
+    data = length 13, hash 1E87B11B
+  sample 204:
+    time = 4080000
+    flags = 1
+    data = length 13, hash 78CD2C11
+  sample 205:
+    time = 4100000
+    flags = 1
+    data = length 13, hash 9F198DF0
+  sample 206:
+    time = 4120000
+    flags = 1
+    data = length 13, hash B291F16A
+  sample 207:
+    time = 4140000
+    flags = 1
+    data = length 13, hash CF820EE0
+  sample 208:
+    time = 4160000
+    flags = 1
+    data = length 13, hash 4E24F683
+  sample 209:
+    time = 4180000
+    flags = 1
+    data = length 13, hash 52BCD68F
+  sample 210:
+    time = 4200000
+    flags = 1
+    data = length 13, hash 42588CB0
+  sample 211:
+    time = 4220000
+    flags = 1
+    data = length 13, hash EBBFECA2
+  sample 212:
+    time = 4240000
+    flags = 1
+    data = length 13, hash C11050CF
+  sample 213:
+    time = 4260000
+    flags = 1
+    data = length 13, hash 6F738603
+  sample 214:
+    time = 4280000
+    flags = 1
+    data = length 13, hash DAD06E5
+  sample 215:
+    time = 4300000
+    flags = 1
+    data = length 13, hash 5B036C64
+  sample 216:
+    time = 4320000
+    flags = 1
+    data = length 13, hash A58DC12E
+  sample 217:
+    time = 4340000
+    flags = 1
+    data = length 13, hash AC59BA7C
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_nb_cbr.amr.1.dump b/library/core/src/test/assets/amr/sample_nb_cbr.amr.1.dump
new file mode 100644
index 0000000000..d00ae65c7e
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_nb_cbr.amr.1.dump
@@ -0,0 +1,614 @@
+seekMap:
+  isSeekable = true
+  duration = 4360000
+  getPosition(0) = [[timeUs=0, position=6]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/3gpp
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 8000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 1898
+  sample count = 146
+  sample 0:
+    time = 1440000
+    flags = 1
+    data = length 13, hash 93BB890A
+  sample 1:
+    time = 1460000
+    flags = 1
+    data = length 13, hash B57DBEC8
+  sample 2:
+    time = 1480000
+    flags = 1
+    data = length 13, hash 66B0A5B6
+  sample 3:
+    time = 1500000
+    flags = 1
+    data = length 13, hash D733E0D
+  sample 4:
+    time = 1520000
+    flags = 1
+    data = length 13, hash 80941726
+  sample 5:
+    time = 1540000
+    flags = 1
+    data = length 13, hash 556ED633
+  sample 6:
+    time = 1560000
+    flags = 1
+    data = length 13, hash C5EDF4E1
+  sample 7:
+    time = 1580000
+    flags = 1
+    data = length 13, hash 6B287445
+  sample 8:
+    time = 1600000
+    flags = 1
+    data = length 13, hash DC97C4A7
+  sample 9:
+    time = 1620000
+    flags = 1
+    data = length 13, hash DA8CBDF4
+  sample 10:
+    time = 1640000
+    flags = 1
+    data = length 13, hash 6F60FF77
+  sample 11:
+    time = 1660000
+    flags = 1
+    data = length 13, hash 3EB22B96
+  sample 12:
+    time = 1680000
+    flags = 1
+    data = length 13, hash B3C31AF5
+  sample 13:
+    time = 1700000
+    flags = 1
+    data = length 13, hash 1854AA92
+  sample 14:
+    time = 1720000
+    flags = 1
+    data = length 13, hash 6488264B
+  sample 15:
+    time = 1740000
+    flags = 1
+    data = length 13, hash 4CC8C5C1
+  sample 16:
+    time = 1760000
+    flags = 1
+    data = length 13, hash 19CC7523
+  sample 17:
+    time = 1780000
+    flags = 1
+    data = length 13, hash 9BE7B928
+  sample 18:
+    time = 1800000
+    flags = 1
+    data = length 13, hash 47EC7CFD
+  sample 19:
+    time = 1820000
+    flags = 1
+    data = length 13, hash EC940120
+  sample 20:
+    time = 1840000
+    flags = 1
+    data = length 13, hash 73BDA6D0
+  sample 21:
+    time = 1860000
+    flags = 1
+    data = length 13, hash FACB3314
+  sample 22:
+    time = 1880000
+    flags = 1
+    data = length 13, hash EC61D13B
+  sample 23:
+    time = 1900000
+    flags = 1
+    data = length 13, hash B28C7B6C
+  sample 24:
+    time = 1920000
+    flags = 1
+    data = length 13, hash B1A4CECD
+  sample 25:
+    time = 1940000
+    flags = 1
+    data = length 13, hash 56D41BA6
+  sample 26:
+    time = 1960000
+    flags = 1
+    data = length 13, hash 90499F4
+  sample 27:
+    time = 1980000
+    flags = 1
+    data = length 13, hash 65D9A9D3
+  sample 28:
+    time = 2000000
+    flags = 1
+    data = length 13, hash D9004CC
+  sample 29:
+    time = 2020000
+    flags = 1
+    data = length 13, hash 4139C6ED
+  sample 30:
+    time = 2040000
+    flags = 1
+    data = length 13, hash C4F8097C
+  sample 31:
+    time = 2060000
+    flags = 1
+    data = length 13, hash 94D424FA
+  sample 32:
+    time = 2080000
+    flags = 1
+    data = length 13, hash C2C6F5FD
+  sample 33:
+    time = 2100000
+    flags = 1
+    data = length 13, hash 15719008
+  sample 34:
+    time = 2120000
+    flags = 1
+    data = length 13, hash 4F64F524
+  sample 35:
+    time = 2140000
+    flags = 1
+    data = length 13, hash F9E01C1E
+  sample 36:
+    time = 2160000
+    flags = 1
+    data = length 13, hash 74C4EE74
+  sample 37:
+    time = 2180000
+    flags = 1
+    data = length 13, hash 7EE7553D
+  sample 38:
+    time = 2200000
+    flags = 1
+    data = length 13, hash 62DE6539
+  sample 39:
+    time = 2220000
+    flags = 1
+    data = length 13, hash 7F5EC222
+  sample 40:
+    time = 2240000
+    flags = 1
+    data = length 13, hash 644067F
+  sample 41:
+    time = 2260000
+    flags = 1
+    data = length 13, hash CDF6C9DC
+  sample 42:
+    time = 2280000
+    flags = 1
+    data = length 13, hash 8B5DBC80
+  sample 43:
+    time = 2300000
+    flags = 1
+    data = length 13, hash AD4BBA03
+  sample 44:
+    time = 2320000
+    flags = 1
+    data = length 13, hash 7A76340
+  sample 45:
+    time = 2340000
+    flags = 1
+    data = length 13, hash 3610F5B0
+  sample 46:
+    time = 2360000
+    flags = 1
+    data = length 13, hash 430BC60B
+  sample 47:
+    time = 2380000
+    flags = 1
+    data = length 13, hash 99CF1CA6
+  sample 48:
+    time = 2400000
+    flags = 1
+    data = length 13, hash 1331C70B
+  sample 49:
+    time = 2420000
+    flags = 1
+    data = length 13, hash BD76E69D
+  sample 50:
+    time = 2440000
+    flags = 1
+    data = length 13, hash 5DA652AC
+  sample 51:
+    time = 2460000
+    flags = 1
+    data = length 13, hash 3B7BF6CE
+  sample 52:
+    time = 2480000
+    flags = 1
+    data = length 13, hash ABBFD143
+  sample 53:
+    time = 2500000
+    flags = 1
+    data = length 13, hash E9447166
+  sample 54:
+    time = 2520000
+    flags = 1
+    data = length 13, hash EC40068C
+  sample 55:
+    time = 2540000
+    flags = 1
+    data = length 13, hash A2869400
+  sample 56:
+    time = 2560000
+    flags = 1
+    data = length 13, hash C7E0746B
+  sample 57:
+    time = 2580000
+    flags = 1
+    data = length 13, hash 60601BB1
+  sample 58:
+    time = 2600000
+    flags = 1
+    data = length 13, hash 975AAE9B
+  sample 59:
+    time = 2620000
+    flags = 1
+    data = length 13, hash 8BBC0EB2
+  sample 60:
+    time = 2640000
+    flags = 1
+    data = length 13, hash 57FB39E5
+  sample 61:
+    time = 2660000
+    flags = 1
+    data = length 13, hash 4CDCEEDB
+  sample 62:
+    time = 2680000
+    flags = 1
+    data = length 13, hash EA16E256
+  sample 63:
+    time = 2700000
+    flags = 1
+    data = length 13, hash 287E7D9E
+  sample 64:
+    time = 2720000
+    flags = 1
+    data = length 13, hash 55AB8FB9
+  sample 65:
+    time = 2740000
+    flags = 1
+    data = length 13, hash 129890EF
+  sample 66:
+    time = 2760000
+    flags = 1
+    data = length 13, hash 90834F57
+  sample 67:
+    time = 2780000
+    flags = 1
+    data = length 13, hash 5B3228E0
+  sample 68:
+    time = 2800000
+    flags = 1
+    data = length 13, hash DD19E175
+  sample 69:
+    time = 2820000
+    flags = 1
+    data = length 13, hash EE7EA342
+  sample 70:
+    time = 2840000
+    flags = 1
+    data = length 13, hash DB3AF473
+  sample 71:
+    time = 2860000
+    flags = 1
+    data = length 13, hash 25AEC43F
+  sample 72:
+    time = 2880000
+    flags = 1
+    data = length 13, hash EE9BF97F
+  sample 73:
+    time = 2900000
+    flags = 1
+    data = length 13, hash FFFBE047
+  sample 74:
+    time = 2920000
+    flags = 1
+    data = length 13, hash BEACFCB0
+  sample 75:
+    time = 2940000
+    flags = 1
+    data = length 13, hash AEB5096C
+  sample 76:
+    time = 2960000
+    flags = 1
+    data = length 13, hash B0D381B
+  sample 77:
+    time = 2980000
+    flags = 1
+    data = length 13, hash 3D9D5122
+  sample 78:
+    time = 3000000
+    flags = 1
+    data = length 13, hash 6C1DDB95
+  sample 79:
+    time = 3020000
+    flags = 1
+    data = length 13, hash ADACADCF
+  sample 80:
+    time = 3040000
+    flags = 1
+    data = length 13, hash 159E321E
+  sample 81:
+    time = 3060000
+    flags = 1
+    data = length 13, hash B1466264
+  sample 82:
+    time = 3080000
+    flags = 1
+    data = length 13, hash 4DDF7223
+  sample 83:
+    time = 3100000
+    flags = 1
+    data = length 13, hash C9BDB82A
+  sample 84:
+    time = 3120000
+    flags = 1
+    data = length 13, hash A49B2D9D
+  sample 85:
+    time = 3140000
+    flags = 1
+    data = length 13, hash D645E7E5
+  sample 86:
+    time = 3160000
+    flags = 1
+    data = length 13, hash 1C4232DC
+  sample 87:
+    time = 3180000
+    flags = 1
+    data = length 13, hash 83078219
+  sample 88:
+    time = 3200000
+    flags = 1
+    data = length 13, hash D6D8B072
+  sample 89:
+    time = 3220000
+    flags = 1
+    data = length 13, hash 975DB40
+  sample 90:
+    time = 3240000
+    flags = 1
+    data = length 13, hash A15FDD05
+  sample 91:
+    time = 3260000
+    flags = 1
+    data = length 13, hash 4B839E41
+  sample 92:
+    time = 3280000
+    flags = 1
+    data = length 13, hash 7418F499
+  sample 93:
+    time = 3300000
+    flags = 1
+    data = length 13, hash 7A4945E4
+  sample 94:
+    time = 3320000
+    flags = 1
+    data = length 13, hash 6249558C
+  sample 95:
+    time = 3340000
+    flags = 1
+    data = length 13, hash BD4C5BE3
+  sample 96:
+    time = 3360000
+    flags = 1
+    data = length 13, hash BAB30F1D
+  sample 97:
+    time = 3380000
+    flags = 1
+    data = length 13, hash 1E1C7012
+  sample 98:
+    time = 3400000
+    flags = 1
+    data = length 13, hash 9A3F8A89
+  sample 99:
+    time = 3420000
+    flags = 1
+    data = length 13, hash 20BE6D7B
+  sample 100:
+    time = 3440000
+    flags = 1
+    data = length 13, hash CAA0591D
+  sample 101:
+    time = 3460000
+    flags = 1
+    data = length 13, hash 6D554D17
+  sample 102:
+    time = 3480000
+    flags = 1
+    data = length 13, hash D97C3B31
+  sample 103:
+    time = 3500000
+    flags = 1
+    data = length 13, hash 75BC5C3
+  sample 104:
+    time = 3520000
+    flags = 1
+    data = length 13, hash 7BA1784B
+  sample 105:
+    time = 3540000
+    flags = 1
+    data = length 13, hash 1D175D92
+  sample 106:
+    time = 3560000
+    flags = 1
+    data = length 13, hash ADCA60FD
+  sample 107:
+    time = 3580000
+    flags = 1
+    data = length 13, hash 37018693
+  sample 108:
+    time = 3600000
+    flags = 1
+    data = length 13, hash 4553606F
+  sample 109:
+    time = 3620000
+    flags = 1
+    data = length 13, hash CF434565
+  sample 110:
+    time = 3640000
+    flags = 1
+    data = length 13, hash D264D757
+  sample 111:
+    time = 3660000
+    flags = 1
+    data = length 13, hash 4FB493EF
+  sample 112:
+    time = 3680000
+    flags = 1
+    data = length 13, hash 919F53A
+  sample 113:
+    time = 3700000
+    flags = 1
+    data = length 13, hash C22B009B
+  sample 114:
+    time = 3720000
+    flags = 1
+    data = length 13, hash 5981470
+  sample 115:
+    time = 3740000
+    flags = 1
+    data = length 13, hash A5D3937C
+  sample 116:
+    time = 3760000
+    flags = 1
+    data = length 13, hash A2504429
+  sample 117:
+    time = 3780000
+    flags = 1
+    data = length 13, hash AD1B70BE
+  sample 118:
+    time = 3800000
+    flags = 1
+    data = length 13, hash 2E39ED5E
+  sample 119:
+    time = 3820000
+    flags = 1
+    data = length 13, hash 13A8BE8E
+  sample 120:
+    time = 3840000
+    flags = 1
+    data = length 13, hash 1ACD740B
+  sample 121:
+    time = 3860000
+    flags = 1
+    data = length 13, hash 80F38B3
+  sample 122:
+    time = 3880000
+    flags = 1
+    data = length 13, hash DA9DA79F
+  sample 123:
+    time = 3900000
+    flags = 1
+    data = length 13, hash 21B95B7E
+  sample 124:
+    time = 3920000
+    flags = 1
+    data = length 13, hash CD22497B
+  sample 125:
+    time = 3940000
+    flags = 1
+    data = length 13, hash 718BB35D
+  sample 126:
+    time = 3960000
+    flags = 1
+    data = length 13, hash 69ABA6AD
+  sample 127:
+    time = 3980000
+    flags = 1
+    data = length 13, hash BAE19549
+  sample 128:
+    time = 4000000
+    flags = 1
+    data = length 13, hash 2A792FB3
+  sample 129:
+    time = 4020000
+    flags = 1
+    data = length 13, hash 71FCD8
+  sample 130:
+    time = 4040000
+    flags = 1
+    data = length 13, hash 44D2B5B3
+  sample 131:
+    time = 4060000
+    flags = 1
+    data = length 13, hash 1E87B11B
+  sample 132:
+    time = 4080000
+    flags = 1
+    data = length 13, hash 78CD2C11
+  sample 133:
+    time = 4100000
+    flags = 1
+    data = length 13, hash 9F198DF0
+  sample 134:
+    time = 4120000
+    flags = 1
+    data = length 13, hash B291F16A
+  sample 135:
+    time = 4140000
+    flags = 1
+    data = length 13, hash CF820EE0
+  sample 136:
+    time = 4160000
+    flags = 1
+    data = length 13, hash 4E24F683
+  sample 137:
+    time = 4180000
+    flags = 1
+    data = length 13, hash 52BCD68F
+  sample 138:
+    time = 4200000
+    flags = 1
+    data = length 13, hash 42588CB0
+  sample 139:
+    time = 4220000
+    flags = 1
+    data = length 13, hash EBBFECA2
+  sample 140:
+    time = 4240000
+    flags = 1
+    data = length 13, hash C11050CF
+  sample 141:
+    time = 4260000
+    flags = 1
+    data = length 13, hash 6F738603
+  sample 142:
+    time = 4280000
+    flags = 1
+    data = length 13, hash DAD06E5
+  sample 143:
+    time = 4300000
+    flags = 1
+    data = length 13, hash 5B036C64
+  sample 144:
+    time = 4320000
+    flags = 1
+    data = length 13, hash A58DC12E
+  sample 145:
+    time = 4340000
+    flags = 1
+    data = length 13, hash AC59BA7C
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_nb_cbr.amr.2.dump b/library/core/src/test/assets/amr/sample_nb_cbr.amr.2.dump
new file mode 100644
index 0000000000..f68b6df3a3
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_nb_cbr.amr.2.dump
@@ -0,0 +1,322 @@
+seekMap:
+  isSeekable = true
+  duration = 4360000
+  getPosition(0) = [[timeUs=0, position=6]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/3gpp
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 8000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 949
+  sample count = 73
+  sample 0:
+    time = 2900000
+    flags = 1
+    data = length 13, hash FFFBE047
+  sample 1:
+    time = 2920000
+    flags = 1
+    data = length 13, hash BEACFCB0
+  sample 2:
+    time = 2940000
+    flags = 1
+    data = length 13, hash AEB5096C
+  sample 3:
+    time = 2960000
+    flags = 1
+    data = length 13, hash B0D381B
+  sample 4:
+    time = 2980000
+    flags = 1
+    data = length 13, hash 3D9D5122
+  sample 5:
+    time = 3000000
+    flags = 1
+    data = length 13, hash 6C1DDB95
+  sample 6:
+    time = 3020000
+    flags = 1
+    data = length 13, hash ADACADCF
+  sample 7:
+    time = 3040000
+    flags = 1
+    data = length 13, hash 159E321E
+  sample 8:
+    time = 3060000
+    flags = 1
+    data = length 13, hash B1466264
+  sample 9:
+    time = 3080000
+    flags = 1
+    data = length 13, hash 4DDF7223
+  sample 10:
+    time = 3100000
+    flags = 1
+    data = length 13, hash C9BDB82A
+  sample 11:
+    time = 3120000
+    flags = 1
+    data = length 13, hash A49B2D9D
+  sample 12:
+    time = 3140000
+    flags = 1
+    data = length 13, hash D645E7E5
+  sample 13:
+    time = 3160000
+    flags = 1
+    data = length 13, hash 1C4232DC
+  sample 14:
+    time = 3180000
+    flags = 1
+    data = length 13, hash 83078219
+  sample 15:
+    time = 3200000
+    flags = 1
+    data = length 13, hash D6D8B072
+  sample 16:
+    time = 3220000
+    flags = 1
+    data = length 13, hash 975DB40
+  sample 17:
+    time = 3240000
+    flags = 1
+    data = length 13, hash A15FDD05
+  sample 18:
+    time = 3260000
+    flags = 1
+    data = length 13, hash 4B839E41
+  sample 19:
+    time = 3280000
+    flags = 1
+    data = length 13, hash 7418F499
+  sample 20:
+    time = 3300000
+    flags = 1
+    data = length 13, hash 7A4945E4
+  sample 21:
+    time = 3320000
+    flags = 1
+    data = length 13, hash 6249558C
+  sample 22:
+    time = 3340000
+    flags = 1
+    data = length 13, hash BD4C5BE3
+  sample 23:
+    time = 3360000
+    flags = 1
+    data = length 13, hash BAB30F1D
+  sample 24:
+    time = 3380000
+    flags = 1
+    data = length 13, hash 1E1C7012
+  sample 25:
+    time = 3400000
+    flags = 1
+    data = length 13, hash 9A3F8A89
+  sample 26:
+    time = 3420000
+    flags = 1
+    data = length 13, hash 20BE6D7B
+  sample 27:
+    time = 3440000
+    flags = 1
+    data = length 13, hash CAA0591D
+  sample 28:
+    time = 3460000
+    flags = 1
+    data = length 13, hash 6D554D17
+  sample 29:
+    time = 3480000
+    flags = 1
+    data = length 13, hash D97C3B31
+  sample 30:
+    time = 3500000
+    flags = 1
+    data = length 13, hash 75BC5C3
+  sample 31:
+    time = 3520000
+    flags = 1
+    data = length 13, hash 7BA1784B
+  sample 32:
+    time = 3540000
+    flags = 1
+    data = length 13, hash 1D175D92
+  sample 33:
+    time = 3560000
+    flags = 1
+    data = length 13, hash ADCA60FD
+  sample 34:
+    time = 3580000
+    flags = 1
+    data = length 13, hash 37018693
+  sample 35:
+    time = 3600000
+    flags = 1
+    data = length 13, hash 4553606F
+  sample 36:
+    time = 3620000
+    flags = 1
+    data = length 13, hash CF434565
+  sample 37:
+    time = 3640000
+    flags = 1
+    data = length 13, hash D264D757
+  sample 38:
+    time = 3660000
+    flags = 1
+    data = length 13, hash 4FB493EF
+  sample 39:
+    time = 3680000
+    flags = 1
+    data = length 13, hash 919F53A
+  sample 40:
+    time = 3700000
+    flags = 1
+    data = length 13, hash C22B009B
+  sample 41:
+    time = 3720000
+    flags = 1
+    data = length 13, hash 5981470
+  sample 42:
+    time = 3740000
+    flags = 1
+    data = length 13, hash A5D3937C
+  sample 43:
+    time = 3760000
+    flags = 1
+    data = length 13, hash A2504429
+  sample 44:
+    time = 3780000
+    flags = 1
+    data = length 13, hash AD1B70BE
+  sample 45:
+    time = 3800000
+    flags = 1
+    data = length 13, hash 2E39ED5E
+  sample 46:
+    time = 3820000
+    flags = 1
+    data = length 13, hash 13A8BE8E
+  sample 47:
+    time = 3840000
+    flags = 1
+    data = length 13, hash 1ACD740B
+  sample 48:
+    time = 3860000
+    flags = 1
+    data = length 13, hash 80F38B3
+  sample 49:
+    time = 3880000
+    flags = 1
+    data = length 13, hash DA9DA79F
+  sample 50:
+    time = 3900000
+    flags = 1
+    data = length 13, hash 21B95B7E
+  sample 51:
+    time = 3920000
+    flags = 1
+    data = length 13, hash CD22497B
+  sample 52:
+    time = 3940000
+    flags = 1
+    data = length 13, hash 718BB35D
+  sample 53:
+    time = 3960000
+    flags = 1
+    data = length 13, hash 69ABA6AD
+  sample 54:
+    time = 3980000
+    flags = 1
+    data = length 13, hash BAE19549
+  sample 55:
+    time = 4000000
+    flags = 1
+    data = length 13, hash 2A792FB3
+  sample 56:
+    time = 4020000
+    flags = 1
+    data = length 13, hash 71FCD8
+  sample 57:
+    time = 4040000
+    flags = 1
+    data = length 13, hash 44D2B5B3
+  sample 58:
+    time = 4060000
+    flags = 1
+    data = length 13, hash 1E87B11B
+  sample 59:
+    time = 4080000
+    flags = 1
+    data = length 13, hash 78CD2C11
+  sample 60:
+    time = 4100000
+    flags = 1
+    data = length 13, hash 9F198DF0
+  sample 61:
+    time = 4120000
+    flags = 1
+    data = length 13, hash B291F16A
+  sample 62:
+    time = 4140000
+    flags = 1
+    data = length 13, hash CF820EE0
+  sample 63:
+    time = 4160000
+    flags = 1
+    data = length 13, hash 4E24F683
+  sample 64:
+    time = 4180000
+    flags = 1
+    data = length 13, hash 52BCD68F
+  sample 65:
+    time = 4200000
+    flags = 1
+    data = length 13, hash 42588CB0
+  sample 66:
+    time = 4220000
+    flags = 1
+    data = length 13, hash EBBFECA2
+  sample 67:
+    time = 4240000
+    flags = 1
+    data = length 13, hash C11050CF
+  sample 68:
+    time = 4260000
+    flags = 1
+    data = length 13, hash 6F738603
+  sample 69:
+    time = 4280000
+    flags = 1
+    data = length 13, hash DAD06E5
+  sample 70:
+    time = 4300000
+    flags = 1
+    data = length 13, hash 5B036C64
+  sample 71:
+    time = 4320000
+    flags = 1
+    data = length 13, hash A58DC12E
+  sample 72:
+    time = 4340000
+    flags = 1
+    data = length 13, hash AC59BA7C
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_nb_cbr.amr.3.dump b/library/core/src/test/assets/amr/sample_nb_cbr.amr.3.dump
new file mode 100644
index 0000000000..da907e004f
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_nb_cbr.amr.3.dump
@@ -0,0 +1,34 @@
+seekMap:
+  isSeekable = true
+  duration = 4360000
+  getPosition(0) = [[timeUs=0, position=6]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/3gpp
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 8000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 13
+  sample count = 1
+  sample 0:
+    time = 4340000
+    flags = 1
+    data = length 13, hash AC59BA7C
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_nb_cbr.amr.unklen.dump b/library/core/src/test/assets/amr/sample_nb_cbr.amr.unklen.dump
new file mode 100644
index 0000000000..e0dec9c62c
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_nb_cbr.amr.unklen.dump
@@ -0,0 +1,902 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/3gpp
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 8000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 2834
+  sample count = 218
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 13, hash 371B046C
+  sample 1:
+    time = 20000
+    flags = 1
+    data = length 13, hash CE30BF5B
+  sample 2:
+    time = 40000
+    flags = 1
+    data = length 13, hash 19A59975
+  sample 3:
+    time = 60000
+    flags = 1
+    data = length 13, hash 4879773C
+  sample 4:
+    time = 80000
+    flags = 1
+    data = length 13, hash E8F83019
+  sample 5:
+    time = 100000
+    flags = 1
+    data = length 13, hash D265CDC9
+  sample 6:
+    time = 120000
+    flags = 1
+    data = length 13, hash 91653DAA
+  sample 7:
+    time = 140000
+    flags = 1
+    data = length 13, hash C79456F6
+  sample 8:
+    time = 160000
+    flags = 1
+    data = length 13, hash CDDC4422
+  sample 9:
+    time = 180000
+    flags = 1
+    data = length 13, hash D9ED3AF1
+  sample 10:
+    time = 200000
+    flags = 1
+    data = length 13, hash BAB75A33
+  sample 11:
+    time = 220000
+    flags = 1
+    data = length 13, hash 2221B4FF
+  sample 12:
+    time = 240000
+    flags = 1
+    data = length 13, hash 96400A0B
+  sample 13:
+    time = 260000
+    flags = 1
+    data = length 13, hash 582E6FB
+  sample 14:
+    time = 280000
+    flags = 1
+    data = length 13, hash C4E878E5
+  sample 15:
+    time = 300000
+    flags = 1
+    data = length 13, hash C849A1BD
+  sample 16:
+    time = 320000
+    flags = 1
+    data = length 13, hash CFA8A9ED
+  sample 17:
+    time = 340000
+    flags = 1
+    data = length 13, hash 70CA4907
+  sample 18:
+    time = 360000
+    flags = 1
+    data = length 13, hash B47D4454
+  sample 19:
+    time = 380000
+    flags = 1
+    data = length 13, hash 282998C1
+  sample 20:
+    time = 400000
+    flags = 1
+    data = length 13, hash 3F3F7A65
+  sample 21:
+    time = 420000
+    flags = 1
+    data = length 13, hash CC2EAB58
+  sample 22:
+    time = 440000
+    flags = 1
+    data = length 13, hash 279EF712
+  sample 23:
+    time = 460000
+    flags = 1
+    data = length 13, hash AA2F4B29
+  sample 24:
+    time = 480000
+    flags = 1
+    data = length 13, hash F6F658C4
+  sample 25:
+    time = 500000
+    flags = 1
+    data = length 13, hash D7DEBD17
+  sample 26:
+    time = 520000
+    flags = 1
+    data = length 13, hash 6DAB9A17
+  sample 27:
+    time = 540000
+    flags = 1
+    data = length 13, hash 6ECE1571
+  sample 28:
+    time = 560000
+    flags = 1
+    data = length 13, hash B3D0507F
+  sample 29:
+    time = 580000
+    flags = 1
+    data = length 13, hash 21E356B9
+  sample 30:
+    time = 600000
+    flags = 1
+    data = length 13, hash 410EA12
+  sample 31:
+    time = 620000
+    flags = 1
+    data = length 13, hash 533895A8
+  sample 32:
+    time = 640000
+    flags = 1
+    data = length 13, hash C61B3E5A
+  sample 33:
+    time = 660000
+    flags = 1
+    data = length 13, hash 982170E6
+  sample 34:
+    time = 680000
+    flags = 1
+    data = length 13, hash 7A0468C5
+  sample 35:
+    time = 700000
+    flags = 1
+    data = length 13, hash 9C85EAA7
+  sample 36:
+    time = 720000
+    flags = 1
+    data = length 13, hash B6B341B6
+  sample 37:
+    time = 740000
+    flags = 1
+    data = length 13, hash 6937532E
+  sample 38:
+    time = 760000
+    flags = 1
+    data = length 13, hash 8CF2A3A0
+  sample 39:
+    time = 780000
+    flags = 1
+    data = length 13, hash D2682AC6
+  sample 40:
+    time = 800000
+    flags = 1
+    data = length 13, hash BBC5710F
+  sample 41:
+    time = 820000
+    flags = 1
+    data = length 13, hash 59080B6C
+  sample 42:
+    time = 840000
+    flags = 1
+    data = length 13, hash E4118291
+  sample 43:
+    time = 860000
+    flags = 1
+    data = length 13, hash A1E5B296
+  sample 44:
+    time = 880000
+    flags = 1
+    data = length 13, hash D7B8F95B
+  sample 45:
+    time = 900000
+    flags = 1
+    data = length 13, hash CC839BE1
+  sample 46:
+    time = 920000
+    flags = 1
+    data = length 13, hash D459DFCE
+  sample 47:
+    time = 940000
+    flags = 1
+    data = length 13, hash D6AD19EC
+  sample 48:
+    time = 960000
+    flags = 1
+    data = length 13, hash D05E373D
+  sample 49:
+    time = 980000
+    flags = 1
+    data = length 13, hash 6A4460C7
+  sample 50:
+    time = 1000000
+    flags = 1
+    data = length 13, hash C9A0D93F
+  sample 51:
+    time = 1020000
+    flags = 1
+    data = length 13, hash 3FA819E7
+  sample 52:
+    time = 1040000
+    flags = 1
+    data = length 13, hash 1D3CBDFC
+  sample 53:
+    time = 1060000
+    flags = 1
+    data = length 13, hash 8BBBB403
+  sample 54:
+    time = 1080000
+    flags = 1
+    data = length 13, hash 21B4A0F9
+  sample 55:
+    time = 1100000
+    flags = 1
+    data = length 13, hash C0F921D1
+  sample 56:
+    time = 1120000
+    flags = 1
+    data = length 13, hash 5D812AAB
+  sample 57:
+    time = 1140000
+    flags = 1
+    data = length 13, hash 50C9F3F8
+  sample 58:
+    time = 1160000
+    flags = 1
+    data = length 13, hash 5C2BB5D1
+  sample 59:
+    time = 1180000
+    flags = 1
+    data = length 13, hash 6BF9BEA5
+  sample 60:
+    time = 1200000
+    flags = 1
+    data = length 13, hash 2738C1E6
+  sample 61:
+    time = 1220000
+    flags = 1
+    data = length 13, hash 5FC288A6
+  sample 62:
+    time = 1240000
+    flags = 1
+    data = length 13, hash 7E8E442A
+  sample 63:
+    time = 1260000
+    flags = 1
+    data = length 13, hash AEAA2BBA
+  sample 64:
+    time = 1280000
+    flags = 1
+    data = length 13, hash 4E2ACD2F
+  sample 65:
+    time = 1300000
+    flags = 1
+    data = length 13, hash D6C90ACF
+  sample 66:
+    time = 1320000
+    flags = 1
+    data = length 13, hash 6FD8A944
+  sample 67:
+    time = 1340000
+    flags = 1
+    data = length 13, hash A835BBF9
+  sample 68:
+    time = 1360000
+    flags = 1
+    data = length 13, hash F7713830
+  sample 69:
+    time = 1380000
+    flags = 1
+    data = length 13, hash 3AA966E5
+  sample 70:
+    time = 1400000
+    flags = 1
+    data = length 13, hash F939E829
+  sample 71:
+    time = 1420000
+    flags = 1
+    data = length 13, hash 7676DE49
+  sample 72:
+    time = 1440000
+    flags = 1
+    data = length 13, hash 93BB890A
+  sample 73:
+    time = 1460000
+    flags = 1
+    data = length 13, hash B57DBEC8
+  sample 74:
+    time = 1480000
+    flags = 1
+    data = length 13, hash 66B0A5B6
+  sample 75:
+    time = 1500000
+    flags = 1
+    data = length 13, hash D733E0D
+  sample 76:
+    time = 1520000
+    flags = 1
+    data = length 13, hash 80941726
+  sample 77:
+    time = 1540000
+    flags = 1
+    data = length 13, hash 556ED633
+  sample 78:
+    time = 1560000
+    flags = 1
+    data = length 13, hash C5EDF4E1
+  sample 79:
+    time = 1580000
+    flags = 1
+    data = length 13, hash 6B287445
+  sample 80:
+    time = 1600000
+    flags = 1
+    data = length 13, hash DC97C4A7
+  sample 81:
+    time = 1620000
+    flags = 1
+    data = length 13, hash DA8CBDF4
+  sample 82:
+    time = 1640000
+    flags = 1
+    data = length 13, hash 6F60FF77
+  sample 83:
+    time = 1660000
+    flags = 1
+    data = length 13, hash 3EB22B96
+  sample 84:
+    time = 1680000
+    flags = 1
+    data = length 13, hash B3C31AF5
+  sample 85:
+    time = 1700000
+    flags = 1
+    data = length 13, hash 1854AA92
+  sample 86:
+    time = 1720000
+    flags = 1
+    data = length 13, hash 6488264B
+  sample 87:
+    time = 1740000
+    flags = 1
+    data = length 13, hash 4CC8C5C1
+  sample 88:
+    time = 1760000
+    flags = 1
+    data = length 13, hash 19CC7523
+  sample 89:
+    time = 1780000
+    flags = 1
+    data = length 13, hash 9BE7B928
+  sample 90:
+    time = 1800000
+    flags = 1
+    data = length 13, hash 47EC7CFD
+  sample 91:
+    time = 1820000
+    flags = 1
+    data = length 13, hash EC940120
+  sample 92:
+    time = 1840000
+    flags = 1
+    data = length 13, hash 73BDA6D0
+  sample 93:
+    time = 1860000
+    flags = 1
+    data = length 13, hash FACB3314
+  sample 94:
+    time = 1880000
+    flags = 1
+    data = length 13, hash EC61D13B
+  sample 95:
+    time = 1900000
+    flags = 1
+    data = length 13, hash B28C7B6C
+  sample 96:
+    time = 1920000
+    flags = 1
+    data = length 13, hash B1A4CECD
+  sample 97:
+    time = 1940000
+    flags = 1
+    data = length 13, hash 56D41BA6
+  sample 98:
+    time = 1960000
+    flags = 1
+    data = length 13, hash 90499F4
+  sample 99:
+    time = 1980000
+    flags = 1
+    data = length 13, hash 65D9A9D3
+  sample 100:
+    time = 2000000
+    flags = 1
+    data = length 13, hash D9004CC
+  sample 101:
+    time = 2020000
+    flags = 1
+    data = length 13, hash 4139C6ED
+  sample 102:
+    time = 2040000
+    flags = 1
+    data = length 13, hash C4F8097C
+  sample 103:
+    time = 2060000
+    flags = 1
+    data = length 13, hash 94D424FA
+  sample 104:
+    time = 2080000
+    flags = 1
+    data = length 13, hash C2C6F5FD
+  sample 105:
+    time = 2100000
+    flags = 1
+    data = length 13, hash 15719008
+  sample 106:
+    time = 2120000
+    flags = 1
+    data = length 13, hash 4F64F524
+  sample 107:
+    time = 2140000
+    flags = 1
+    data = length 13, hash F9E01C1E
+  sample 108:
+    time = 2160000
+    flags = 1
+    data = length 13, hash 74C4EE74
+  sample 109:
+    time = 2180000
+    flags = 1
+    data = length 13, hash 7EE7553D
+  sample 110:
+    time = 2200000
+    flags = 1
+    data = length 13, hash 62DE6539
+  sample 111:
+    time = 2220000
+    flags = 1
+    data = length 13, hash 7F5EC222
+  sample 112:
+    time = 2240000
+    flags = 1
+    data = length 13, hash 644067F
+  sample 113:
+    time = 2260000
+    flags = 1
+    data = length 13, hash CDF6C9DC
+  sample 114:
+    time = 2280000
+    flags = 1
+    data = length 13, hash 8B5DBC80
+  sample 115:
+    time = 2300000
+    flags = 1
+    data = length 13, hash AD4BBA03
+  sample 116:
+    time = 2320000
+    flags = 1
+    data = length 13, hash 7A76340
+  sample 117:
+    time = 2340000
+    flags = 1
+    data = length 13, hash 3610F5B0
+  sample 118:
+    time = 2360000
+    flags = 1
+    data = length 13, hash 430BC60B
+  sample 119:
+    time = 2380000
+    flags = 1
+    data = length 13, hash 99CF1CA6
+  sample 120:
+    time = 2400000
+    flags = 1
+    data = length 13, hash 1331C70B
+  sample 121:
+    time = 2420000
+    flags = 1
+    data = length 13, hash BD76E69D
+  sample 122:
+    time = 2440000
+    flags = 1
+    data = length 13, hash 5DA652AC
+  sample 123:
+    time = 2460000
+    flags = 1
+    data = length 13, hash 3B7BF6CE
+  sample 124:
+    time = 2480000
+    flags = 1
+    data = length 13, hash ABBFD143
+  sample 125:
+    time = 2500000
+    flags = 1
+    data = length 13, hash E9447166
+  sample 126:
+    time = 2520000
+    flags = 1
+    data = length 13, hash EC40068C
+  sample 127:
+    time = 2540000
+    flags = 1
+    data = length 13, hash A2869400
+  sample 128:
+    time = 2560000
+    flags = 1
+    data = length 13, hash C7E0746B
+  sample 129:
+    time = 2580000
+    flags = 1
+    data = length 13, hash 60601BB1
+  sample 130:
+    time = 2600000
+    flags = 1
+    data = length 13, hash 975AAE9B
+  sample 131:
+    time = 2620000
+    flags = 1
+    data = length 13, hash 8BBC0EB2
+  sample 132:
+    time = 2640000
+    flags = 1
+    data = length 13, hash 57FB39E5
+  sample 133:
+    time = 2660000
+    flags = 1
+    data = length 13, hash 4CDCEEDB
+  sample 134:
+    time = 2680000
+    flags = 1
+    data = length 13, hash EA16E256
+  sample 135:
+    time = 2700000
+    flags = 1
+    data = length 13, hash 287E7D9E
+  sample 136:
+    time = 2720000
+    flags = 1
+    data = length 13, hash 55AB8FB9
+  sample 137:
+    time = 2740000
+    flags = 1
+    data = length 13, hash 129890EF
+  sample 138:
+    time = 2760000
+    flags = 1
+    data = length 13, hash 90834F57
+  sample 139:
+    time = 2780000
+    flags = 1
+    data = length 13, hash 5B3228E0
+  sample 140:
+    time = 2800000
+    flags = 1
+    data = length 13, hash DD19E175
+  sample 141:
+    time = 2820000
+    flags = 1
+    data = length 13, hash EE7EA342
+  sample 142:
+    time = 2840000
+    flags = 1
+    data = length 13, hash DB3AF473
+  sample 143:
+    time = 2860000
+    flags = 1
+    data = length 13, hash 25AEC43F
+  sample 144:
+    time = 2880000
+    flags = 1
+    data = length 13, hash EE9BF97F
+  sample 145:
+    time = 2900000
+    flags = 1
+    data = length 13, hash FFFBE047
+  sample 146:
+    time = 2920000
+    flags = 1
+    data = length 13, hash BEACFCB0
+  sample 147:
+    time = 2940000
+    flags = 1
+    data = length 13, hash AEB5096C
+  sample 148:
+    time = 2960000
+    flags = 1
+    data = length 13, hash B0D381B
+  sample 149:
+    time = 2980000
+    flags = 1
+    data = length 13, hash 3D9D5122
+  sample 150:
+    time = 3000000
+    flags = 1
+    data = length 13, hash 6C1DDB95
+  sample 151:
+    time = 3020000
+    flags = 1
+    data = length 13, hash ADACADCF
+  sample 152:
+    time = 3040000
+    flags = 1
+    data = length 13, hash 159E321E
+  sample 153:
+    time = 3060000
+    flags = 1
+    data = length 13, hash B1466264
+  sample 154:
+    time = 3080000
+    flags = 1
+    data = length 13, hash 4DDF7223
+  sample 155:
+    time = 3100000
+    flags = 1
+    data = length 13, hash C9BDB82A
+  sample 156:
+    time = 3120000
+    flags = 1
+    data = length 13, hash A49B2D9D
+  sample 157:
+    time = 3140000
+    flags = 1
+    data = length 13, hash D645E7E5
+  sample 158:
+    time = 3160000
+    flags = 1
+    data = length 13, hash 1C4232DC
+  sample 159:
+    time = 3180000
+    flags = 1
+    data = length 13, hash 83078219
+  sample 160:
+    time = 3200000
+    flags = 1
+    data = length 13, hash D6D8B072
+  sample 161:
+    time = 3220000
+    flags = 1
+    data = length 13, hash 975DB40
+  sample 162:
+    time = 3240000
+    flags = 1
+    data = length 13, hash A15FDD05
+  sample 163:
+    time = 3260000
+    flags = 1
+    data = length 13, hash 4B839E41
+  sample 164:
+    time = 3280000
+    flags = 1
+    data = length 13, hash 7418F499
+  sample 165:
+    time = 3300000
+    flags = 1
+    data = length 13, hash 7A4945E4
+  sample 166:
+    time = 3320000
+    flags = 1
+    data = length 13, hash 6249558C
+  sample 167:
+    time = 3340000
+    flags = 1
+    data = length 13, hash BD4C5BE3
+  sample 168:
+    time = 3360000
+    flags = 1
+    data = length 13, hash BAB30F1D
+  sample 169:
+    time = 3380000
+    flags = 1
+    data = length 13, hash 1E1C7012
+  sample 170:
+    time = 3400000
+    flags = 1
+    data = length 13, hash 9A3F8A89
+  sample 171:
+    time = 3420000
+    flags = 1
+    data = length 13, hash 20BE6D7B
+  sample 172:
+    time = 3440000
+    flags = 1
+    data = length 13, hash CAA0591D
+  sample 173:
+    time = 3460000
+    flags = 1
+    data = length 13, hash 6D554D17
+  sample 174:
+    time = 3480000
+    flags = 1
+    data = length 13, hash D97C3B31
+  sample 175:
+    time = 3500000
+    flags = 1
+    data = length 13, hash 75BC5C3
+  sample 176:
+    time = 3520000
+    flags = 1
+    data = length 13, hash 7BA1784B
+  sample 177:
+    time = 3540000
+    flags = 1
+    data = length 13, hash 1D175D92
+  sample 178:
+    time = 3560000
+    flags = 1
+    data = length 13, hash ADCA60FD
+  sample 179:
+    time = 3580000
+    flags = 1
+    data = length 13, hash 37018693
+  sample 180:
+    time = 3600000
+    flags = 1
+    data = length 13, hash 4553606F
+  sample 181:
+    time = 3620000
+    flags = 1
+    data = length 13, hash CF434565
+  sample 182:
+    time = 3640000
+    flags = 1
+    data = length 13, hash D264D757
+  sample 183:
+    time = 3660000
+    flags = 1
+    data = length 13, hash 4FB493EF
+  sample 184:
+    time = 3680000
+    flags = 1
+    data = length 13, hash 919F53A
+  sample 185:
+    time = 3700000
+    flags = 1
+    data = length 13, hash C22B009B
+  sample 186:
+    time = 3720000
+    flags = 1
+    data = length 13, hash 5981470
+  sample 187:
+    time = 3740000
+    flags = 1
+    data = length 13, hash A5D3937C
+  sample 188:
+    time = 3760000
+    flags = 1
+    data = length 13, hash A2504429
+  sample 189:
+    time = 3780000
+    flags = 1
+    data = length 13, hash AD1B70BE
+  sample 190:
+    time = 3800000
+    flags = 1
+    data = length 13, hash 2E39ED5E
+  sample 191:
+    time = 3820000
+    flags = 1
+    data = length 13, hash 13A8BE8E
+  sample 192:
+    time = 3840000
+    flags = 1
+    data = length 13, hash 1ACD740B
+  sample 193:
+    time = 3860000
+    flags = 1
+    data = length 13, hash 80F38B3
+  sample 194:
+    time = 3880000
+    flags = 1
+    data = length 13, hash DA9DA79F
+  sample 195:
+    time = 3900000
+    flags = 1
+    data = length 13, hash 21B95B7E
+  sample 196:
+    time = 3920000
+    flags = 1
+    data = length 13, hash CD22497B
+  sample 197:
+    time = 3940000
+    flags = 1
+    data = length 13, hash 718BB35D
+  sample 198:
+    time = 3960000
+    flags = 1
+    data = length 13, hash 69ABA6AD
+  sample 199:
+    time = 3980000
+    flags = 1
+    data = length 13, hash BAE19549
+  sample 200:
+    time = 4000000
+    flags = 1
+    data = length 13, hash 2A792FB3
+  sample 201:
+    time = 4020000
+    flags = 1
+    data = length 13, hash 71FCD8
+  sample 202:
+    time = 4040000
+    flags = 1
+    data = length 13, hash 44D2B5B3
+  sample 203:
+    time = 4060000
+    flags = 1
+    data = length 13, hash 1E87B11B
+  sample 204:
+    time = 4080000
+    flags = 1
+    data = length 13, hash 78CD2C11
+  sample 205:
+    time = 4100000
+    flags = 1
+    data = length 13, hash 9F198DF0
+  sample 206:
+    time = 4120000
+    flags = 1
+    data = length 13, hash B291F16A
+  sample 207:
+    time = 4140000
+    flags = 1
+    data = length 13, hash CF820EE0
+  sample 208:
+    time = 4160000
+    flags = 1
+    data = length 13, hash 4E24F683
+  sample 209:
+    time = 4180000
+    flags = 1
+    data = length 13, hash 52BCD68F
+  sample 210:
+    time = 4200000
+    flags = 1
+    data = length 13, hash 42588CB0
+  sample 211:
+    time = 4220000
+    flags = 1
+    data = length 13, hash EBBFECA2
+  sample 212:
+    time = 4240000
+    flags = 1
+    data = length 13, hash C11050CF
+  sample 213:
+    time = 4260000
+    flags = 1
+    data = length 13, hash 6F738603
+  sample 214:
+    time = 4280000
+    flags = 1
+    data = length 13, hash DAD06E5
+  sample 215:
+    time = 4300000
+    flags = 1
+    data = length 13, hash 5B036C64
+  sample 216:
+    time = 4320000
+    flags = 1
+    data = length 13, hash A58DC12E
+  sample 217:
+    time = 4340000
+    flags = 1
+    data = length 13, hash AC59BA7C
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_wb_cbr.amr b/library/core/src/test/assets/amr/sample_wb_cbr.amr
new file mode 100644
index 0000000000..14b85b553c
Binary files /dev/null and b/library/core/src/test/assets/amr/sample_wb_cbr.amr differ
diff --git a/library/core/src/test/assets/amr/sample_wb_cbr.amr.0.dump b/library/core/src/test/assets/amr/sample_wb_cbr.amr.0.dump
new file mode 100644
index 0000000000..c987c6e357
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_wb_cbr.amr.0.dump
@@ -0,0 +1,706 @@
+seekMap:
+  isSeekable = true
+  duration = 3380000
+  getPosition(0) = [[timeUs=0, position=9]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/amr-wb
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 16000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 4056
+  sample count = 169
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 24, hash C3025798
+  sample 1:
+    time = 20000
+    flags = 1
+    data = length 24, hash 39CABAE9
+  sample 2:
+    time = 40000
+    flags = 1
+    data = length 24, hash 2752F470
+  sample 3:
+    time = 60000
+    flags = 1
+    data = length 24, hash 394F76F6
+  sample 4:
+    time = 80000
+    flags = 1
+    data = length 24, hash FF9EEF
+  sample 5:
+    time = 100000
+    flags = 1
+    data = length 24, hash 54ECB1B4
+  sample 6:
+    time = 120000
+    flags = 1
+    data = length 24, hash 6D7A3A5F
+  sample 7:
+    time = 140000
+    flags = 1
+    data = length 24, hash 684CD144
+  sample 8:
+    time = 160000
+    flags = 1
+    data = length 24, hash 87B7D176
+  sample 9:
+    time = 180000
+    flags = 1
+    data = length 24, hash 4C02F9A5
+  sample 10:
+    time = 200000
+    flags = 1
+    data = length 24, hash B4154108
+  sample 11:
+    time = 220000
+    flags = 1
+    data = length 24, hash 4448F477
+  sample 12:
+    time = 240000
+    flags = 1
+    data = length 24, hash 755A4939
+  sample 13:
+    time = 260000
+    flags = 1
+    data = length 24, hash 8C8BC6C3
+  sample 14:
+    time = 280000
+    flags = 1
+    data = length 24, hash BC37F63F
+  sample 15:
+    time = 300000
+    flags = 1
+    data = length 24, hash 3352C43C
+  sample 16:
+    time = 320000
+    flags = 1
+    data = length 24, hash 7998E1F2
+  sample 17:
+    time = 340000
+    flags = 1
+    data = length 24, hash A8ECBEFC
+  sample 18:
+    time = 360000
+    flags = 1
+    data = length 24, hash 944AC118
+  sample 19:
+    time = 380000
+    flags = 1
+    data = length 24, hash FD2C8E1F
+  sample 20:
+    time = 400000
+    flags = 1
+    data = length 24, hash B3D867AF
+  sample 21:
+    time = 420000
+    flags = 1
+    data = length 24, hash 3DC6E592
+  sample 22:
+    time = 440000
+    flags = 1
+    data = length 24, hash 32B276CD
+  sample 23:
+    time = 460000
+    flags = 1
+    data = length 24, hash 5488AEF3
+  sample 24:
+    time = 480000
+    flags = 1
+    data = length 24, hash 7A4D516
+  sample 25:
+    time = 500000
+    flags = 1
+    data = length 24, hash 570AE83F
+  sample 26:
+    time = 520000
+    flags = 1
+    data = length 24, hash E5CB3477
+  sample 27:
+    time = 540000
+    flags = 1
+    data = length 24, hash E04C00E4
+  sample 28:
+    time = 560000
+    flags = 1
+    data = length 24, hash 21B7C97
+  sample 29:
+    time = 580000
+    flags = 1
+    data = length 24, hash 1633F470
+  sample 30:
+    time = 600000
+    flags = 1
+    data = length 24, hash 28D65CA6
+  sample 31:
+    time = 620000
+    flags = 1
+    data = length 24, hash CC6A675C
+  sample 32:
+    time = 640000
+    flags = 1
+    data = length 24, hash 4C91080A
+  sample 33:
+    time = 660000
+    flags = 1
+    data = length 24, hash F6482FB5
+  sample 34:
+    time = 680000
+    flags = 1
+    data = length 24, hash 2C76F48C
+  sample 35:
+    time = 700000
+    flags = 1
+    data = length 24, hash 6E3B0D72
+  sample 36:
+    time = 720000
+    flags = 1
+    data = length 24, hash 799AA003
+  sample 37:
+    time = 740000
+    flags = 1
+    data = length 24, hash DFC0BA81
+  sample 38:
+    time = 760000
+    flags = 1
+    data = length 24, hash CBDF3826
+  sample 39:
+    time = 780000
+    flags = 1
+    data = length 24, hash 16862B75
+  sample 40:
+    time = 800000
+    flags = 1
+    data = length 24, hash 865A828E
+  sample 41:
+    time = 820000
+    flags = 1
+    data = length 24, hash 336BBDC9
+  sample 42:
+    time = 840000
+    flags = 1
+    data = length 24, hash 6CFC6C34
+  sample 43:
+    time = 860000
+    flags = 1
+    data = length 24, hash 32C8CD46
+  sample 44:
+    time = 880000
+    flags = 1
+    data = length 24, hash 9FE11C4C
+  sample 45:
+    time = 900000
+    flags = 1
+    data = length 24, hash AA5A12B7
+  sample 46:
+    time = 920000
+    flags = 1
+    data = length 24, hash AA0F4A4D
+  sample 47:
+    time = 940000
+    flags = 1
+    data = length 24, hash 34415484
+  sample 48:
+    time = 960000
+    flags = 1
+    data = length 24, hash 5018928E
+  sample 49:
+    time = 980000
+    flags = 1
+    data = length 24, hash 4A04D162
+  sample 50:
+    time = 1000000
+    flags = 1
+    data = length 24, hash 4C70F9F0
+  sample 51:
+    time = 1020000
+    flags = 1
+    data = length 24, hash 99EF3168
+  sample 52:
+    time = 1040000
+    flags = 1
+    data = length 24, hash C600DAF
+  sample 53:
+    time = 1060000
+    flags = 1
+    data = length 24, hash FDBB192E
+  sample 54:
+    time = 1080000
+    flags = 1
+    data = length 24, hash 99096A48
+  sample 55:
+    time = 1100000
+    flags = 1
+    data = length 24, hash D793F88B
+  sample 56:
+    time = 1120000
+    flags = 1
+    data = length 24, hash EEB921BD
+  sample 57:
+    time = 1140000
+    flags = 1
+    data = length 24, hash 8B941A4C
+  sample 58:
+    time = 1160000
+    flags = 1
+    data = length 24, hash ED5F5FEE
+  sample 59:
+    time = 1180000
+    flags = 1
+    data = length 24, hash A588E0BB
+  sample 60:
+    time = 1200000
+    flags = 1
+    data = length 24, hash 588CBC01
+  sample 61:
+    time = 1220000
+    flags = 1
+    data = length 24, hash DE22266C
+  sample 62:
+    time = 1240000
+    flags = 1
+    data = length 24, hash 921B6E5C
+  sample 63:
+    time = 1260000
+    flags = 1
+    data = length 24, hash EC11F041
+  sample 64:
+    time = 1280000
+    flags = 1
+    data = length 24, hash 5BA9E0A3
+  sample 65:
+    time = 1300000
+    flags = 1
+    data = length 24, hash DB6D52F3
+  sample 66:
+    time = 1320000
+    flags = 1
+    data = length 24, hash 8EEBE525
+  sample 67:
+    time = 1340000
+    flags = 1
+    data = length 24, hash 47A742AE
+  sample 68:
+    time = 1360000
+    flags = 1
+    data = length 24, hash E93F1E03
+  sample 69:
+    time = 1380000
+    flags = 1
+    data = length 24, hash 3251F57C
+  sample 70:
+    time = 1400000
+    flags = 1
+    data = length 24, hash 3EDBBBDD
+  sample 71:
+    time = 1420000
+    flags = 1
+    data = length 24, hash 2E98465A
+  sample 72:
+    time = 1440000
+    flags = 1
+    data = length 24, hash A09EA52E
+  sample 73:
+    time = 1460000
+    flags = 1
+    data = length 24, hash A2A86FA6
+  sample 74:
+    time = 1480000
+    flags = 1
+    data = length 24, hash 71DCD51C
+  sample 75:
+    time = 1500000
+    flags = 1
+    data = length 24, hash 2B02DEE1
+  sample 76:
+    time = 1520000
+    flags = 1
+    data = length 24, hash 7A725192
+  sample 77:
+    time = 1540000
+    flags = 1
+    data = length 24, hash 929AD483
+  sample 78:
+    time = 1560000
+    flags = 1
+    data = length 24, hash 68440BF5
+  sample 79:
+    time = 1580000
+    flags = 1
+    data = length 24, hash 5BD41AD6
+  sample 80:
+    time = 1600000
+    flags = 1
+    data = length 24, hash 91A381
+  sample 81:
+    time = 1620000
+    flags = 1
+    data = length 24, hash 8010C408
+  sample 82:
+    time = 1640000
+    flags = 1
+    data = length 24, hash 482274BE
+  sample 83:
+    time = 1660000
+    flags = 1
+    data = length 24, hash D7DB8BCC
+  sample 84:
+    time = 1680000
+    flags = 1
+    data = length 24, hash 680BD9DD
+  sample 85:
+    time = 1700000
+    flags = 1
+    data = length 24, hash E313577C
+  sample 86:
+    time = 1720000
+    flags = 1
+    data = length 24, hash 9C10B0CD
+  sample 87:
+    time = 1740000
+    flags = 1
+    data = length 24, hash 2D90AC02
+  sample 88:
+    time = 1760000
+    flags = 1
+    data = length 24, hash 64E8C245
+  sample 89:
+    time = 1780000
+    flags = 1
+    data = length 24, hash 3954AC1B
+  sample 90:
+    time = 1800000
+    flags = 1
+    data = length 24, hash ACB8999F
+  sample 91:
+    time = 1820000
+    flags = 1
+    data = length 24, hash 43AE3957
+  sample 92:
+    time = 1840000
+    flags = 1
+    data = length 24, hash 3C664DB7
+  sample 93:
+    time = 1860000
+    flags = 1
+    data = length 24, hash 9354B576
+  sample 94:
+    time = 1880000
+    flags = 1
+    data = length 24, hash B5B9C14E
+  sample 95:
+    time = 1900000
+    flags = 1
+    data = length 24, hash 7DA9C98F
+  sample 96:
+    time = 1920000
+    flags = 1
+    data = length 24, hash EFEE54C6
+  sample 97:
+    time = 1940000
+    flags = 1
+    data = length 24, hash 79DC8CBD
+  sample 98:
+    time = 1960000
+    flags = 1
+    data = length 24, hash A71A475C
+  sample 99:
+    time = 1980000
+    flags = 1
+    data = length 24, hash CA1CBB94
+  sample 100:
+    time = 2000000
+    flags = 1
+    data = length 24, hash 91922226
+  sample 101:
+    time = 2020000
+    flags = 1
+    data = length 24, hash C90278BC
+  sample 102:
+    time = 2040000
+    flags = 1
+    data = length 24, hash BD51986F
+  sample 103:
+    time = 2060000
+    flags = 1
+    data = length 24, hash 90AEF368
+  sample 104:
+    time = 2080000
+    flags = 1
+    data = length 24, hash 1D83C955
+  sample 105:
+    time = 2100000
+    flags = 1
+    data = length 24, hash 8FA9A915
+  sample 106:
+    time = 2120000
+    flags = 1
+    data = length 24, hash C6C753E0
+  sample 107:
+    time = 2140000
+    flags = 1
+    data = length 24, hash 85FA27A7
+  sample 108:
+    time = 2160000
+    flags = 1
+    data = length 24, hash A0277324
+  sample 109:
+    time = 2180000
+    flags = 1
+    data = length 24, hash B7696535
+  sample 110:
+    time = 2200000
+    flags = 1
+    data = length 24, hash D69D668C
+  sample 111:
+    time = 2220000
+    flags = 1
+    data = length 24, hash 34C057CD
+  sample 112:
+    time = 2240000
+    flags = 1
+    data = length 24, hash 4EC5E974
+  sample 113:
+    time = 2260000
+    flags = 1
+    data = length 24, hash 1C1CD40D
+  sample 114:
+    time = 2280000
+    flags = 1
+    data = length 24, hash 76CC54BC
+  sample 115:
+    time = 2300000
+    flags = 1
+    data = length 24, hash D497ACF5
+  sample 116:
+    time = 2320000
+    flags = 1
+    data = length 24, hash A1386080
+  sample 117:
+    time = 2340000
+    flags = 1
+    data = length 24, hash 7ED36954
+  sample 118:
+    time = 2360000
+    flags = 1
+    data = length 24, hash C11A3BF9
+  sample 119:
+    time = 2380000
+    flags = 1
+    data = length 24, hash 8FB69488
+  sample 120:
+    time = 2400000
+    flags = 1
+    data = length 24, hash C6225F59
+  sample 121:
+    time = 2420000
+    flags = 1
+    data = length 24, hash 122AB6D2
+  sample 122:
+    time = 2440000
+    flags = 1
+    data = length 24, hash 1E195E7D
+  sample 123:
+    time = 2460000
+    flags = 1
+    data = length 24, hash BD3DF418
+  sample 124:
+    time = 2480000
+    flags = 1
+    data = length 24, hash D8AE4A5
+  sample 125:
+    time = 2500000
+    flags = 1
+    data = length 24, hash 977BD182
+  sample 126:
+    time = 2520000
+    flags = 1
+    data = length 24, hash F361F060
+  sample 127:
+    time = 2540000
+    flags = 1
+    data = length 24, hash 11EC8CD0
+  sample 128:
+    time = 2560000
+    flags = 1
+    data = length 24, hash 3798F3D2
+  sample 129:
+    time = 2580000
+    flags = 1
+    data = length 24, hash B2C2517C
+  sample 130:
+    time = 2600000
+    flags = 1
+    data = length 24, hash FBE0D0D8
+  sample 131:
+    time = 2620000
+    flags = 1
+    data = length 24, hash 7033172F
+  sample 132:
+    time = 2640000
+    flags = 1
+    data = length 24, hash BE760029
+  sample 133:
+    time = 2660000
+    flags = 1
+    data = length 24, hash 590AF28C
+  sample 134:
+    time = 2680000
+    flags = 1
+    data = length 24, hash AD28C48F
+  sample 135:
+    time = 2700000
+    flags = 1
+    data = length 24, hash 640AA61B
+  sample 136:
+    time = 2720000
+    flags = 1
+    data = length 24, hash ABE659B
+  sample 137:
+    time = 2740000
+    flags = 1
+    data = length 24, hash ED2691D2
+  sample 138:
+    time = 2760000
+    flags = 1
+    data = length 24, hash D998C80E
+  sample 139:
+    time = 2780000
+    flags = 1
+    data = length 24, hash 8DC0DF5C
+  sample 140:
+    time = 2800000
+    flags = 1
+    data = length 24, hash 7692247B
+  sample 141:
+    time = 2820000
+    flags = 1
+    data = length 24, hash C1D1CCB9
+  sample 142:
+    time = 2840000
+    flags = 1
+    data = length 24, hash 362CE78E
+  sample 143:
+    time = 2860000
+    flags = 1
+    data = length 24, hash 54FA84A
+  sample 144:
+    time = 2880000
+    flags = 1
+    data = length 24, hash 29E88C84
+  sample 145:
+    time = 2900000
+    flags = 1
+    data = length 24, hash 1CD848AC
+  sample 146:
+    time = 2920000
+    flags = 1
+    data = length 24, hash 5C3D4A79
+  sample 147:
+    time = 2940000
+    flags = 1
+    data = length 24, hash 1AA8E604
+  sample 148:
+    time = 2960000
+    flags = 1
+    data = length 24, hash 186A4316
+  sample 149:
+    time = 2980000
+    flags = 1
+    data = length 24, hash 61ACE481
+  sample 150:
+    time = 3000000
+    flags = 1
+    data = length 24, hash D0C42780
+  sample 151:
+    time = 3020000
+    flags = 1
+    data = length 24, hash FAD51BA1
+  sample 152:
+    time = 3040000
+    flags = 1
+    data = length 24, hash F1A9AC71
+  sample 153:
+    time = 3060000
+    flags = 1
+    data = length 24, hash 24425449
+  sample 154:
+    time = 3080000
+    flags = 1
+    data = length 24, hash 37AAC3E6
+  sample 155:
+    time = 3100000
+    flags = 1
+    data = length 24, hash 91F68CB4
+  sample 156:
+    time = 3120000
+    flags = 1
+    data = length 24, hash F8C92820
+  sample 157:
+    time = 3140000
+    flags = 1
+    data = length 24, hash ECD39C3E
+  sample 158:
+    time = 3160000
+    flags = 1
+    data = length 24, hash B27D8F78
+  sample 159:
+    time = 3180000
+    flags = 1
+    data = length 24, hash C9EB3DFB
+  sample 160:
+    time = 3200000
+    flags = 1
+    data = length 24, hash 88DC54A2
+  sample 161:
+    time = 3220000
+    flags = 1
+    data = length 24, hash 7FC4C5BE
+  sample 162:
+    time = 3240000
+    flags = 1
+    data = length 24, hash E4F684EF
+  sample 163:
+    time = 3260000
+    flags = 1
+    data = length 24, hash 55C08B56
+  sample 164:
+    time = 3280000
+    flags = 1
+    data = length 24, hash E5A0F006
+  sample 165:
+    time = 3300000
+    flags = 1
+    data = length 24, hash DE3F3AA7
+  sample 166:
+    time = 3320000
+    flags = 1
+    data = length 24, hash 3F28AE7F
+  sample 167:
+    time = 3340000
+    flags = 1
+    data = length 24, hash 3949CAFF
+  sample 168:
+    time = 3360000
+    flags = 1
+    data = length 24, hash 772665A0
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_wb_cbr.amr.1.dump b/library/core/src/test/assets/amr/sample_wb_cbr.amr.1.dump
new file mode 100644
index 0000000000..fad4565195
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_wb_cbr.amr.1.dump
@@ -0,0 +1,482 @@
+seekMap:
+  isSeekable = true
+  duration = 3380000
+  getPosition(0) = [[timeUs=0, position=9]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/amr-wb
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 16000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 2712
+  sample count = 113
+  sample 0:
+    time = 1120000
+    flags = 1
+    data = length 24, hash EEB921BD
+  sample 1:
+    time = 1140000
+    flags = 1
+    data = length 24, hash 8B941A4C
+  sample 2:
+    time = 1160000
+    flags = 1
+    data = length 24, hash ED5F5FEE
+  sample 3:
+    time = 1180000
+    flags = 1
+    data = length 24, hash A588E0BB
+  sample 4:
+    time = 1200000
+    flags = 1
+    data = length 24, hash 588CBC01
+  sample 5:
+    time = 1220000
+    flags = 1
+    data = length 24, hash DE22266C
+  sample 6:
+    time = 1240000
+    flags = 1
+    data = length 24, hash 921B6E5C
+  sample 7:
+    time = 1260000
+    flags = 1
+    data = length 24, hash EC11F041
+  sample 8:
+    time = 1280000
+    flags = 1
+    data = length 24, hash 5BA9E0A3
+  sample 9:
+    time = 1300000
+    flags = 1
+    data = length 24, hash DB6D52F3
+  sample 10:
+    time = 1320000
+    flags = 1
+    data = length 24, hash 8EEBE525
+  sample 11:
+    time = 1340000
+    flags = 1
+    data = length 24, hash 47A742AE
+  sample 12:
+    time = 1360000
+    flags = 1
+    data = length 24, hash E93F1E03
+  sample 13:
+    time = 1380000
+    flags = 1
+    data = length 24, hash 3251F57C
+  sample 14:
+    time = 1400000
+    flags = 1
+    data = length 24, hash 3EDBBBDD
+  sample 15:
+    time = 1420000
+    flags = 1
+    data = length 24, hash 2E98465A
+  sample 16:
+    time = 1440000
+    flags = 1
+    data = length 24, hash A09EA52E
+  sample 17:
+    time = 1460000
+    flags = 1
+    data = length 24, hash A2A86FA6
+  sample 18:
+    time = 1480000
+    flags = 1
+    data = length 24, hash 71DCD51C
+  sample 19:
+    time = 1500000
+    flags = 1
+    data = length 24, hash 2B02DEE1
+  sample 20:
+    time = 1520000
+    flags = 1
+    data = length 24, hash 7A725192
+  sample 21:
+    time = 1540000
+    flags = 1
+    data = length 24, hash 929AD483
+  sample 22:
+    time = 1560000
+    flags = 1
+    data = length 24, hash 68440BF5
+  sample 23:
+    time = 1580000
+    flags = 1
+    data = length 24, hash 5BD41AD6
+  sample 24:
+    time = 1600000
+    flags = 1
+    data = length 24, hash 91A381
+  sample 25:
+    time = 1620000
+    flags = 1
+    data = length 24, hash 8010C408
+  sample 26:
+    time = 1640000
+    flags = 1
+    data = length 24, hash 482274BE
+  sample 27:
+    time = 1660000
+    flags = 1
+    data = length 24, hash D7DB8BCC
+  sample 28:
+    time = 1680000
+    flags = 1
+    data = length 24, hash 680BD9DD
+  sample 29:
+    time = 1700000
+    flags = 1
+    data = length 24, hash E313577C
+  sample 30:
+    time = 1720000
+    flags = 1
+    data = length 24, hash 9C10B0CD
+  sample 31:
+    time = 1740000
+    flags = 1
+    data = length 24, hash 2D90AC02
+  sample 32:
+    time = 1760000
+    flags = 1
+    data = length 24, hash 64E8C245
+  sample 33:
+    time = 1780000
+    flags = 1
+    data = length 24, hash 3954AC1B
+  sample 34:
+    time = 1800000
+    flags = 1
+    data = length 24, hash ACB8999F
+  sample 35:
+    time = 1820000
+    flags = 1
+    data = length 24, hash 43AE3957
+  sample 36:
+    time = 1840000
+    flags = 1
+    data = length 24, hash 3C664DB7
+  sample 37:
+    time = 1860000
+    flags = 1
+    data = length 24, hash 9354B576
+  sample 38:
+    time = 1880000
+    flags = 1
+    data = length 24, hash B5B9C14E
+  sample 39:
+    time = 1900000
+    flags = 1
+    data = length 24, hash 7DA9C98F
+  sample 40:
+    time = 1920000
+    flags = 1
+    data = length 24, hash EFEE54C6
+  sample 41:
+    time = 1940000
+    flags = 1
+    data = length 24, hash 79DC8CBD
+  sample 42:
+    time = 1960000
+    flags = 1
+    data = length 24, hash A71A475C
+  sample 43:
+    time = 1980000
+    flags = 1
+    data = length 24, hash CA1CBB94
+  sample 44:
+    time = 2000000
+    flags = 1
+    data = length 24, hash 91922226
+  sample 45:
+    time = 2020000
+    flags = 1
+    data = length 24, hash C90278BC
+  sample 46:
+    time = 2040000
+    flags = 1
+    data = length 24, hash BD51986F
+  sample 47:
+    time = 2060000
+    flags = 1
+    data = length 24, hash 90AEF368
+  sample 48:
+    time = 2080000
+    flags = 1
+    data = length 24, hash 1D83C955
+  sample 49:
+    time = 2100000
+    flags = 1
+    data = length 24, hash 8FA9A915
+  sample 50:
+    time = 2120000
+    flags = 1
+    data = length 24, hash C6C753E0
+  sample 51:
+    time = 2140000
+    flags = 1
+    data = length 24, hash 85FA27A7
+  sample 52:
+    time = 2160000
+    flags = 1
+    data = length 24, hash A0277324
+  sample 53:
+    time = 2180000
+    flags = 1
+    data = length 24, hash B7696535
+  sample 54:
+    time = 2200000
+    flags = 1
+    data = length 24, hash D69D668C
+  sample 55:
+    time = 2220000
+    flags = 1
+    data = length 24, hash 34C057CD
+  sample 56:
+    time = 2240000
+    flags = 1
+    data = length 24, hash 4EC5E974
+  sample 57:
+    time = 2260000
+    flags = 1
+    data = length 24, hash 1C1CD40D
+  sample 58:
+    time = 2280000
+    flags = 1
+    data = length 24, hash 76CC54BC
+  sample 59:
+    time = 2300000
+    flags = 1
+    data = length 24, hash D497ACF5
+  sample 60:
+    time = 2320000
+    flags = 1
+    data = length 24, hash A1386080
+  sample 61:
+    time = 2340000
+    flags = 1
+    data = length 24, hash 7ED36954
+  sample 62:
+    time = 2360000
+    flags = 1
+    data = length 24, hash C11A3BF9
+  sample 63:
+    time = 2380000
+    flags = 1
+    data = length 24, hash 8FB69488
+  sample 64:
+    time = 2400000
+    flags = 1
+    data = length 24, hash C6225F59
+  sample 65:
+    time = 2420000
+    flags = 1
+    data = length 24, hash 122AB6D2
+  sample 66:
+    time = 2440000
+    flags = 1
+    data = length 24, hash 1E195E7D
+  sample 67:
+    time = 2460000
+    flags = 1
+    data = length 24, hash BD3DF418
+  sample 68:
+    time = 2480000
+    flags = 1
+    data = length 24, hash D8AE4A5
+  sample 69:
+    time = 2500000
+    flags = 1
+    data = length 24, hash 977BD182
+  sample 70:
+    time = 2520000
+    flags = 1
+    data = length 24, hash F361F060
+  sample 71:
+    time = 2540000
+    flags = 1
+    data = length 24, hash 11EC8CD0
+  sample 72:
+    time = 2560000
+    flags = 1
+    data = length 24, hash 3798F3D2
+  sample 73:
+    time = 2580000
+    flags = 1
+    data = length 24, hash B2C2517C
+  sample 74:
+    time = 2600000
+    flags = 1
+    data = length 24, hash FBE0D0D8
+  sample 75:
+    time = 2620000
+    flags = 1
+    data = length 24, hash 7033172F
+  sample 76:
+    time = 2640000
+    flags = 1
+    data = length 24, hash BE760029
+  sample 77:
+    time = 2660000
+    flags = 1
+    data = length 24, hash 590AF28C
+  sample 78:
+    time = 2680000
+    flags = 1
+    data = length 24, hash AD28C48F
+  sample 79:
+    time = 2700000
+    flags = 1
+    data = length 24, hash 640AA61B
+  sample 80:
+    time = 2720000
+    flags = 1
+    data = length 24, hash ABE659B
+  sample 81:
+    time = 2740000
+    flags = 1
+    data = length 24, hash ED2691D2
+  sample 82:
+    time = 2760000
+    flags = 1
+    data = length 24, hash D998C80E
+  sample 83:
+    time = 2780000
+    flags = 1
+    data = length 24, hash 8DC0DF5C
+  sample 84:
+    time = 2800000
+    flags = 1
+    data = length 24, hash 7692247B
+  sample 85:
+    time = 2820000
+    flags = 1
+    data = length 24, hash C1D1CCB9
+  sample 86:
+    time = 2840000
+    flags = 1
+    data = length 24, hash 362CE78E
+  sample 87:
+    time = 2860000
+    flags = 1
+    data = length 24, hash 54FA84A
+  sample 88:
+    time = 2880000
+    flags = 1
+    data = length 24, hash 29E88C84
+  sample 89:
+    time = 2900000
+    flags = 1
+    data = length 24, hash 1CD848AC
+  sample 90:
+    time = 2920000
+    flags = 1
+    data = length 24, hash 5C3D4A79
+  sample 91:
+    time = 2940000
+    flags = 1
+    data = length 24, hash 1AA8E604
+  sample 92:
+    time = 2960000
+    flags = 1
+    data = length 24, hash 186A4316
+  sample 93:
+    time = 2980000
+    flags = 1
+    data = length 24, hash 61ACE481
+  sample 94:
+    time = 3000000
+    flags = 1
+    data = length 24, hash D0C42780
+  sample 95:
+    time = 3020000
+    flags = 1
+    data = length 24, hash FAD51BA1
+  sample 96:
+    time = 3040000
+    flags = 1
+    data = length 24, hash F1A9AC71
+  sample 97:
+    time = 3060000
+    flags = 1
+    data = length 24, hash 24425449
+  sample 98:
+    time = 3080000
+    flags = 1
+    data = length 24, hash 37AAC3E6
+  sample 99:
+    time = 3100000
+    flags = 1
+    data = length 24, hash 91F68CB4
+  sample 100:
+    time = 3120000
+    flags = 1
+    data = length 24, hash F8C92820
+  sample 101:
+    time = 3140000
+    flags = 1
+    data = length 24, hash ECD39C3E
+  sample 102:
+    time = 3160000
+    flags = 1
+    data = length 24, hash B27D8F78
+  sample 103:
+    time = 3180000
+    flags = 1
+    data = length 24, hash C9EB3DFB
+  sample 104:
+    time = 3200000
+    flags = 1
+    data = length 24, hash 88DC54A2
+  sample 105:
+    time = 3220000
+    flags = 1
+    data = length 24, hash 7FC4C5BE
+  sample 106:
+    time = 3240000
+    flags = 1
+    data = length 24, hash E4F684EF
+  sample 107:
+    time = 3260000
+    flags = 1
+    data = length 24, hash 55C08B56
+  sample 108:
+    time = 3280000
+    flags = 1
+    data = length 24, hash E5A0F006
+  sample 109:
+    time = 3300000
+    flags = 1
+    data = length 24, hash DE3F3AA7
+  sample 110:
+    time = 3320000
+    flags = 1
+    data = length 24, hash 3F28AE7F
+  sample 111:
+    time = 3340000
+    flags = 1
+    data = length 24, hash 3949CAFF
+  sample 112:
+    time = 3360000
+    flags = 1
+    data = length 24, hash 772665A0
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_wb_cbr.amr.2.dump b/library/core/src/test/assets/amr/sample_wb_cbr.amr.2.dump
new file mode 100644
index 0000000000..1f00a90739
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_wb_cbr.amr.2.dump
@@ -0,0 +1,258 @@
+seekMap:
+  isSeekable = true
+  duration = 3380000
+  getPosition(0) = [[timeUs=0, position=9]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/amr-wb
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 16000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 1368
+  sample count = 57
+  sample 0:
+    time = 2240000
+    flags = 1
+    data = length 24, hash 4EC5E974
+  sample 1:
+    time = 2260000
+    flags = 1
+    data = length 24, hash 1C1CD40D
+  sample 2:
+    time = 2280000
+    flags = 1
+    data = length 24, hash 76CC54BC
+  sample 3:
+    time = 2300000
+    flags = 1
+    data = length 24, hash D497ACF5
+  sample 4:
+    time = 2320000
+    flags = 1
+    data = length 24, hash A1386080
+  sample 5:
+    time = 2340000
+    flags = 1
+    data = length 24, hash 7ED36954
+  sample 6:
+    time = 2360000
+    flags = 1
+    data = length 24, hash C11A3BF9
+  sample 7:
+    time = 2380000
+    flags = 1
+    data = length 24, hash 8FB69488
+  sample 8:
+    time = 2400000
+    flags = 1
+    data = length 24, hash C6225F59
+  sample 9:
+    time = 2420000
+    flags = 1
+    data = length 24, hash 122AB6D2
+  sample 10:
+    time = 2440000
+    flags = 1
+    data = length 24, hash 1E195E7D
+  sample 11:
+    time = 2460000
+    flags = 1
+    data = length 24, hash BD3DF418
+  sample 12:
+    time = 2480000
+    flags = 1
+    data = length 24, hash D8AE4A5
+  sample 13:
+    time = 2500000
+    flags = 1
+    data = length 24, hash 977BD182
+  sample 14:
+    time = 2520000
+    flags = 1
+    data = length 24, hash F361F060
+  sample 15:
+    time = 2540000
+    flags = 1
+    data = length 24, hash 11EC8CD0
+  sample 16:
+    time = 2560000
+    flags = 1
+    data = length 24, hash 3798F3D2
+  sample 17:
+    time = 2580000
+    flags = 1
+    data = length 24, hash B2C2517C
+  sample 18:
+    time = 2600000
+    flags = 1
+    data = length 24, hash FBE0D0D8
+  sample 19:
+    time = 2620000
+    flags = 1
+    data = length 24, hash 7033172F
+  sample 20:
+    time = 2640000
+    flags = 1
+    data = length 24, hash BE760029
+  sample 21:
+    time = 2660000
+    flags = 1
+    data = length 24, hash 590AF28C
+  sample 22:
+    time = 2680000
+    flags = 1
+    data = length 24, hash AD28C48F
+  sample 23:
+    time = 2700000
+    flags = 1
+    data = length 24, hash 640AA61B
+  sample 24:
+    time = 2720000
+    flags = 1
+    data = length 24, hash ABE659B
+  sample 25:
+    time = 2740000
+    flags = 1
+    data = length 24, hash ED2691D2
+  sample 26:
+    time = 2760000
+    flags = 1
+    data = length 24, hash D998C80E
+  sample 27:
+    time = 2780000
+    flags = 1
+    data = length 24, hash 8DC0DF5C
+  sample 28:
+    time = 2800000
+    flags = 1
+    data = length 24, hash 7692247B
+  sample 29:
+    time = 2820000
+    flags = 1
+    data = length 24, hash C1D1CCB9
+  sample 30:
+    time = 2840000
+    flags = 1
+    data = length 24, hash 362CE78E
+  sample 31:
+    time = 2860000
+    flags = 1
+    data = length 24, hash 54FA84A
+  sample 32:
+    time = 2880000
+    flags = 1
+    data = length 24, hash 29E88C84
+  sample 33:
+    time = 2900000
+    flags = 1
+    data = length 24, hash 1CD848AC
+  sample 34:
+    time = 2920000
+    flags = 1
+    data = length 24, hash 5C3D4A79
+  sample 35:
+    time = 2940000
+    flags = 1
+    data = length 24, hash 1AA8E604
+  sample 36:
+    time = 2960000
+    flags = 1
+    data = length 24, hash 186A4316
+  sample 37:
+    time = 2980000
+    flags = 1
+    data = length 24, hash 61ACE481
+  sample 38:
+    time = 3000000
+    flags = 1
+    data = length 24, hash D0C42780
+  sample 39:
+    time = 3020000
+    flags = 1
+    data = length 24, hash FAD51BA1
+  sample 40:
+    time = 3040000
+    flags = 1
+    data = length 24, hash F1A9AC71
+  sample 41:
+    time = 3060000
+    flags = 1
+    data = length 24, hash 24425449
+  sample 42:
+    time = 3080000
+    flags = 1
+    data = length 24, hash 37AAC3E6
+  sample 43:
+    time = 3100000
+    flags = 1
+    data = length 24, hash 91F68CB4
+  sample 44:
+    time = 3120000
+    flags = 1
+    data = length 24, hash F8C92820
+  sample 45:
+    time = 3140000
+    flags = 1
+    data = length 24, hash ECD39C3E
+  sample 46:
+    time = 3160000
+    flags = 1
+    data = length 24, hash B27D8F78
+  sample 47:
+    time = 3180000
+    flags = 1
+    data = length 24, hash C9EB3DFB
+  sample 48:
+    time = 3200000
+    flags = 1
+    data = length 24, hash 88DC54A2
+  sample 49:
+    time = 3220000
+    flags = 1
+    data = length 24, hash 7FC4C5BE
+  sample 50:
+    time = 3240000
+    flags = 1
+    data = length 24, hash E4F684EF
+  sample 51:
+    time = 3260000
+    flags = 1
+    data = length 24, hash 55C08B56
+  sample 52:
+    time = 3280000
+    flags = 1
+    data = length 24, hash E5A0F006
+  sample 53:
+    time = 3300000
+    flags = 1
+    data = length 24, hash DE3F3AA7
+  sample 54:
+    time = 3320000
+    flags = 1
+    data = length 24, hash 3F28AE7F
+  sample 55:
+    time = 3340000
+    flags = 1
+    data = length 24, hash 3949CAFF
+  sample 56:
+    time = 3360000
+    flags = 1
+    data = length 24, hash 772665A0
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_wb_cbr.amr.3.dump b/library/core/src/test/assets/amr/sample_wb_cbr.amr.3.dump
new file mode 100644
index 0000000000..1ec8c6fdb7
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_wb_cbr.amr.3.dump
@@ -0,0 +1,34 @@
+seekMap:
+  isSeekable = true
+  duration = 3380000
+  getPosition(0) = [[timeUs=0, position=9]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/amr-wb
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 16000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 24
+  sample count = 1
+  sample 0:
+    time = 3360000
+    flags = 1
+    data = length 24, hash 772665A0
+tracksEnded = true
diff --git a/library/core/src/test/assets/amr/sample_wb_cbr.amr.unklen.dump b/library/core/src/test/assets/amr/sample_wb_cbr.amr.unklen.dump
new file mode 100644
index 0000000000..1b3b8bd0dd
--- /dev/null
+++ b/library/core/src/test/assets/amr/sample_wb_cbr.amr.unklen.dump
@@ -0,0 +1,706 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/amr-wb
+    maxInputSize = 61
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 16000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 4056
+  sample count = 169
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 24, hash C3025798
+  sample 1:
+    time = 20000
+    flags = 1
+    data = length 24, hash 39CABAE9
+  sample 2:
+    time = 40000
+    flags = 1
+    data = length 24, hash 2752F470
+  sample 3:
+    time = 60000
+    flags = 1
+    data = length 24, hash 394F76F6
+  sample 4:
+    time = 80000
+    flags = 1
+    data = length 24, hash FF9EEF
+  sample 5:
+    time = 100000
+    flags = 1
+    data = length 24, hash 54ECB1B4
+  sample 6:
+    time = 120000
+    flags = 1
+    data = length 24, hash 6D7A3A5F
+  sample 7:
+    time = 140000
+    flags = 1
+    data = length 24, hash 684CD144
+  sample 8:
+    time = 160000
+    flags = 1
+    data = length 24, hash 87B7D176
+  sample 9:
+    time = 180000
+    flags = 1
+    data = length 24, hash 4C02F9A5
+  sample 10:
+    time = 200000
+    flags = 1
+    data = length 24, hash B4154108
+  sample 11:
+    time = 220000
+    flags = 1
+    data = length 24, hash 4448F477
+  sample 12:
+    time = 240000
+    flags = 1
+    data = length 24, hash 755A4939
+  sample 13:
+    time = 260000
+    flags = 1
+    data = length 24, hash 8C8BC6C3
+  sample 14:
+    time = 280000
+    flags = 1
+    data = length 24, hash BC37F63F
+  sample 15:
+    time = 300000
+    flags = 1
+    data = length 24, hash 3352C43C
+  sample 16:
+    time = 320000
+    flags = 1
+    data = length 24, hash 7998E1F2
+  sample 17:
+    time = 340000
+    flags = 1
+    data = length 24, hash A8ECBEFC
+  sample 18:
+    time = 360000
+    flags = 1
+    data = length 24, hash 944AC118
+  sample 19:
+    time = 380000
+    flags = 1
+    data = length 24, hash FD2C8E1F
+  sample 20:
+    time = 400000
+    flags = 1
+    data = length 24, hash B3D867AF
+  sample 21:
+    time = 420000
+    flags = 1
+    data = length 24, hash 3DC6E592
+  sample 22:
+    time = 440000
+    flags = 1
+    data = length 24, hash 32B276CD
+  sample 23:
+    time = 460000
+    flags = 1
+    data = length 24, hash 5488AEF3
+  sample 24:
+    time = 480000
+    flags = 1
+    data = length 24, hash 7A4D516
+  sample 25:
+    time = 500000
+    flags = 1
+    data = length 24, hash 570AE83F
+  sample 26:
+    time = 520000
+    flags = 1
+    data = length 24, hash E5CB3477
+  sample 27:
+    time = 540000
+    flags = 1
+    data = length 24, hash E04C00E4
+  sample 28:
+    time = 560000
+    flags = 1
+    data = length 24, hash 21B7C97
+  sample 29:
+    time = 580000
+    flags = 1
+    data = length 24, hash 1633F470
+  sample 30:
+    time = 600000
+    flags = 1
+    data = length 24, hash 28D65CA6
+  sample 31:
+    time = 620000
+    flags = 1
+    data = length 24, hash CC6A675C
+  sample 32:
+    time = 640000
+    flags = 1
+    data = length 24, hash 4C91080A
+  sample 33:
+    time = 660000
+    flags = 1
+    data = length 24, hash F6482FB5
+  sample 34:
+    time = 680000
+    flags = 1
+    data = length 24, hash 2C76F48C
+  sample 35:
+    time = 700000
+    flags = 1
+    data = length 24, hash 6E3B0D72
+  sample 36:
+    time = 720000
+    flags = 1
+    data = length 24, hash 799AA003
+  sample 37:
+    time = 740000
+    flags = 1
+    data = length 24, hash DFC0BA81
+  sample 38:
+    time = 760000
+    flags = 1
+    data = length 24, hash CBDF3826
+  sample 39:
+    time = 780000
+    flags = 1
+    data = length 24, hash 16862B75
+  sample 40:
+    time = 800000
+    flags = 1
+    data = length 24, hash 865A828E
+  sample 41:
+    time = 820000
+    flags = 1
+    data = length 24, hash 336BBDC9
+  sample 42:
+    time = 840000
+    flags = 1
+    data = length 24, hash 6CFC6C34
+  sample 43:
+    time = 860000
+    flags = 1
+    data = length 24, hash 32C8CD46
+  sample 44:
+    time = 880000
+    flags = 1
+    data = length 24, hash 9FE11C4C
+  sample 45:
+    time = 900000
+    flags = 1
+    data = length 24, hash AA5A12B7
+  sample 46:
+    time = 920000
+    flags = 1
+    data = length 24, hash AA0F4A4D
+  sample 47:
+    time = 940000
+    flags = 1
+    data = length 24, hash 34415484
+  sample 48:
+    time = 960000
+    flags = 1
+    data = length 24, hash 5018928E
+  sample 49:
+    time = 980000
+    flags = 1
+    data = length 24, hash 4A04D162
+  sample 50:
+    time = 1000000
+    flags = 1
+    data = length 24, hash 4C70F9F0
+  sample 51:
+    time = 1020000
+    flags = 1
+    data = length 24, hash 99EF3168
+  sample 52:
+    time = 1040000
+    flags = 1
+    data = length 24, hash C600DAF
+  sample 53:
+    time = 1060000
+    flags = 1
+    data = length 24, hash FDBB192E
+  sample 54:
+    time = 1080000
+    flags = 1
+    data = length 24, hash 99096A48
+  sample 55:
+    time = 1100000
+    flags = 1
+    data = length 24, hash D793F88B
+  sample 56:
+    time = 1120000
+    flags = 1
+    data = length 24, hash EEB921BD
+  sample 57:
+    time = 1140000
+    flags = 1
+    data = length 24, hash 8B941A4C
+  sample 58:
+    time = 1160000
+    flags = 1
+    data = length 24, hash ED5F5FEE
+  sample 59:
+    time = 1180000
+    flags = 1
+    data = length 24, hash A588E0BB
+  sample 60:
+    time = 1200000
+    flags = 1
+    data = length 24, hash 588CBC01
+  sample 61:
+    time = 1220000
+    flags = 1
+    data = length 24, hash DE22266C
+  sample 62:
+    time = 1240000
+    flags = 1
+    data = length 24, hash 921B6E5C
+  sample 63:
+    time = 1260000
+    flags = 1
+    data = length 24, hash EC11F041
+  sample 64:
+    time = 1280000
+    flags = 1
+    data = length 24, hash 5BA9E0A3
+  sample 65:
+    time = 1300000
+    flags = 1
+    data = length 24, hash DB6D52F3
+  sample 66:
+    time = 1320000
+    flags = 1
+    data = length 24, hash 8EEBE525
+  sample 67:
+    time = 1340000
+    flags = 1
+    data = length 24, hash 47A742AE
+  sample 68:
+    time = 1360000
+    flags = 1
+    data = length 24, hash E93F1E03
+  sample 69:
+    time = 1380000
+    flags = 1
+    data = length 24, hash 3251F57C
+  sample 70:
+    time = 1400000
+    flags = 1
+    data = length 24, hash 3EDBBBDD
+  sample 71:
+    time = 1420000
+    flags = 1
+    data = length 24, hash 2E98465A
+  sample 72:
+    time = 1440000
+    flags = 1
+    data = length 24, hash A09EA52E
+  sample 73:
+    time = 1460000
+    flags = 1
+    data = length 24, hash A2A86FA6
+  sample 74:
+    time = 1480000
+    flags = 1
+    data = length 24, hash 71DCD51C
+  sample 75:
+    time = 1500000
+    flags = 1
+    data = length 24, hash 2B02DEE1
+  sample 76:
+    time = 1520000
+    flags = 1
+    data = length 24, hash 7A725192
+  sample 77:
+    time = 1540000
+    flags = 1
+    data = length 24, hash 929AD483
+  sample 78:
+    time = 1560000
+    flags = 1
+    data = length 24, hash 68440BF5
+  sample 79:
+    time = 1580000
+    flags = 1
+    data = length 24, hash 5BD41AD6
+  sample 80:
+    time = 1600000
+    flags = 1
+    data = length 24, hash 91A381
+  sample 81:
+    time = 1620000
+    flags = 1
+    data = length 24, hash 8010C408
+  sample 82:
+    time = 1640000
+    flags = 1
+    data = length 24, hash 482274BE
+  sample 83:
+    time = 1660000
+    flags = 1
+    data = length 24, hash D7DB8BCC
+  sample 84:
+    time = 1680000
+    flags = 1
+    data = length 24, hash 680BD9DD
+  sample 85:
+    time = 1700000
+    flags = 1
+    data = length 24, hash E313577C
+  sample 86:
+    time = 1720000
+    flags = 1
+    data = length 24, hash 9C10B0CD
+  sample 87:
+    time = 1740000
+    flags = 1
+    data = length 24, hash 2D90AC02
+  sample 88:
+    time = 1760000
+    flags = 1
+    data = length 24, hash 64E8C245
+  sample 89:
+    time = 1780000
+    flags = 1
+    data = length 24, hash 3954AC1B
+  sample 90:
+    time = 1800000
+    flags = 1
+    data = length 24, hash ACB8999F
+  sample 91:
+    time = 1820000
+    flags = 1
+    data = length 24, hash 43AE3957
+  sample 92:
+    time = 1840000
+    flags = 1
+    data = length 24, hash 3C664DB7
+  sample 93:
+    time = 1860000
+    flags = 1
+    data = length 24, hash 9354B576
+  sample 94:
+    time = 1880000
+    flags = 1
+    data = length 24, hash B5B9C14E
+  sample 95:
+    time = 1900000
+    flags = 1
+    data = length 24, hash 7DA9C98F
+  sample 96:
+    time = 1920000
+    flags = 1
+    data = length 24, hash EFEE54C6
+  sample 97:
+    time = 1940000
+    flags = 1
+    data = length 24, hash 79DC8CBD
+  sample 98:
+    time = 1960000
+    flags = 1
+    data = length 24, hash A71A475C
+  sample 99:
+    time = 1980000
+    flags = 1
+    data = length 24, hash CA1CBB94
+  sample 100:
+    time = 2000000
+    flags = 1
+    data = length 24, hash 91922226
+  sample 101:
+    time = 2020000
+    flags = 1
+    data = length 24, hash C90278BC
+  sample 102:
+    time = 2040000
+    flags = 1
+    data = length 24, hash BD51986F
+  sample 103:
+    time = 2060000
+    flags = 1
+    data = length 24, hash 90AEF368
+  sample 104:
+    time = 2080000
+    flags = 1
+    data = length 24, hash 1D83C955
+  sample 105:
+    time = 2100000
+    flags = 1
+    data = length 24, hash 8FA9A915
+  sample 106:
+    time = 2120000
+    flags = 1
+    data = length 24, hash C6C753E0
+  sample 107:
+    time = 2140000
+    flags = 1
+    data = length 24, hash 85FA27A7
+  sample 108:
+    time = 2160000
+    flags = 1
+    data = length 24, hash A0277324
+  sample 109:
+    time = 2180000
+    flags = 1
+    data = length 24, hash B7696535
+  sample 110:
+    time = 2200000
+    flags = 1
+    data = length 24, hash D69D668C
+  sample 111:
+    time = 2220000
+    flags = 1
+    data = length 24, hash 34C057CD
+  sample 112:
+    time = 2240000
+    flags = 1
+    data = length 24, hash 4EC5E974
+  sample 113:
+    time = 2260000
+    flags = 1
+    data = length 24, hash 1C1CD40D
+  sample 114:
+    time = 2280000
+    flags = 1
+    data = length 24, hash 76CC54BC
+  sample 115:
+    time = 2300000
+    flags = 1
+    data = length 24, hash D497ACF5
+  sample 116:
+    time = 2320000
+    flags = 1
+    data = length 24, hash A1386080
+  sample 117:
+    time = 2340000
+    flags = 1
+    data = length 24, hash 7ED36954
+  sample 118:
+    time = 2360000
+    flags = 1
+    data = length 24, hash C11A3BF9
+  sample 119:
+    time = 2380000
+    flags = 1
+    data = length 24, hash 8FB69488
+  sample 120:
+    time = 2400000
+    flags = 1
+    data = length 24, hash C6225F59
+  sample 121:
+    time = 2420000
+    flags = 1
+    data = length 24, hash 122AB6D2
+  sample 122:
+    time = 2440000
+    flags = 1
+    data = length 24, hash 1E195E7D
+  sample 123:
+    time = 2460000
+    flags = 1
+    data = length 24, hash BD3DF418
+  sample 124:
+    time = 2480000
+    flags = 1
+    data = length 24, hash D8AE4A5
+  sample 125:
+    time = 2500000
+    flags = 1
+    data = length 24, hash 977BD182
+  sample 126:
+    time = 2520000
+    flags = 1
+    data = length 24, hash F361F060
+  sample 127:
+    time = 2540000
+    flags = 1
+    data = length 24, hash 11EC8CD0
+  sample 128:
+    time = 2560000
+    flags = 1
+    data = length 24, hash 3798F3D2
+  sample 129:
+    time = 2580000
+    flags = 1
+    data = length 24, hash B2C2517C
+  sample 130:
+    time = 2600000
+    flags = 1
+    data = length 24, hash FBE0D0D8
+  sample 131:
+    time = 2620000
+    flags = 1
+    data = length 24, hash 7033172F
+  sample 132:
+    time = 2640000
+    flags = 1
+    data = length 24, hash BE760029
+  sample 133:
+    time = 2660000
+    flags = 1
+    data = length 24, hash 590AF28C
+  sample 134:
+    time = 2680000
+    flags = 1
+    data = length 24, hash AD28C48F
+  sample 135:
+    time = 2700000
+    flags = 1
+    data = length 24, hash 640AA61B
+  sample 136:
+    time = 2720000
+    flags = 1
+    data = length 24, hash ABE659B
+  sample 137:
+    time = 2740000
+    flags = 1
+    data = length 24, hash ED2691D2
+  sample 138:
+    time = 2760000
+    flags = 1
+    data = length 24, hash D998C80E
+  sample 139:
+    time = 2780000
+    flags = 1
+    data = length 24, hash 8DC0DF5C
+  sample 140:
+    time = 2800000
+    flags = 1
+    data = length 24, hash 7692247B
+  sample 141:
+    time = 2820000
+    flags = 1
+    data = length 24, hash C1D1CCB9
+  sample 142:
+    time = 2840000
+    flags = 1
+    data = length 24, hash 362CE78E
+  sample 143:
+    time = 2860000
+    flags = 1
+    data = length 24, hash 54FA84A
+  sample 144:
+    time = 2880000
+    flags = 1
+    data = length 24, hash 29E88C84
+  sample 145:
+    time = 2900000
+    flags = 1
+    data = length 24, hash 1CD848AC
+  sample 146:
+    time = 2920000
+    flags = 1
+    data = length 24, hash 5C3D4A79
+  sample 147:
+    time = 2940000
+    flags = 1
+    data = length 24, hash 1AA8E604
+  sample 148:
+    time = 2960000
+    flags = 1
+    data = length 24, hash 186A4316
+  sample 149:
+    time = 2980000
+    flags = 1
+    data = length 24, hash 61ACE481
+  sample 150:
+    time = 3000000
+    flags = 1
+    data = length 24, hash D0C42780
+  sample 151:
+    time = 3020000
+    flags = 1
+    data = length 24, hash FAD51BA1
+  sample 152:
+    time = 3040000
+    flags = 1
+    data = length 24, hash F1A9AC71
+  sample 153:
+    time = 3060000
+    flags = 1
+    data = length 24, hash 24425449
+  sample 154:
+    time = 3080000
+    flags = 1
+    data = length 24, hash 37AAC3E6
+  sample 155:
+    time = 3100000
+    flags = 1
+    data = length 24, hash 91F68CB4
+  sample 156:
+    time = 3120000
+    flags = 1
+    data = length 24, hash F8C92820
+  sample 157:
+    time = 3140000
+    flags = 1
+    data = length 24, hash ECD39C3E
+  sample 158:
+    time = 3160000
+    flags = 1
+    data = length 24, hash B27D8F78
+  sample 159:
+    time = 3180000
+    flags = 1
+    data = length 24, hash C9EB3DFB
+  sample 160:
+    time = 3200000
+    flags = 1
+    data = length 24, hash 88DC54A2
+  sample 161:
+    time = 3220000
+    flags = 1
+    data = length 24, hash 7FC4C5BE
+  sample 162:
+    time = 3240000
+    flags = 1
+    data = length 24, hash E4F684EF
+  sample 163:
+    time = 3260000
+    flags = 1
+    data = length 24, hash 55C08B56
+  sample 164:
+    time = 3280000
+    flags = 1
+    data = length 24, hash E5A0F006
+  sample 165:
+    time = 3300000
+    flags = 1
+    data = length 24, hash DE3F3AA7
+  sample 166:
+    time = 3320000
+    flags = 1
+    data = length 24, hash 3F28AE7F
+  sample 167:
+    time = 3340000
+    flags = 1
+    data = length 24, hash 3949CAFF
+  sample 168:
+    time = 3360000
+    flags = 1
+    data = length 24, hash 772665A0
+tracksEnded = true
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp4/testvid_1022ms.mp4 b/library/core/src/test/assets/mp4/testvid_1022ms.mp4
new file mode 100644
index 0000000000..bbd2729c4d
Binary files /dev/null and b/library/core/src/test/assets/mp4/testvid_1022ms.mp4 differ
diff --git a/library/core/src/test/assets/subrip/typical_with_tags b/library/core/src/test/assets/subrip/typical_with_tags
new file mode 100644
index 0000000000..85e304b498
--- /dev/null
+++ b/library/core/src/test/assets/subrip/typical_with_tags
@@ -0,0 +1,56 @@
+1
+00:00:00,000 --> 00:00:01,234
+This is {\an1} the first subtitle.
+
+2
+00:00:02,345 --> 00:00:03,456
+This is the second subtitle.
+Second {\ an 2} subtitle with second line.
+
+3
+00:00:04,567 --> 00:00:08,901
+This {\an2} is the third {\ tag} subtitle.
+
+4
+00:00:09,567 --> 00:00:12,901
+This { \an2} is not a valid tag due to the space after the opening bracket.
+
+5
+00:00:013,567 --> 00:00:14,901
+This {\an2} is the fifth subtitle with multiple {\xyz} valid {\qwe} tags.
+
+6
+00:00:015,567 --> 00:00:15,901
+This {\an1} is a lines.
+
+7
+00:00:016,567 --> 00:00:16,901
+This {\an2} is a line.
+
+8
+00:00:017,567 --> 00:00:17,901
+This {\an3} is a line.
+
+9
+00:00:018,567 --> 00:00:18,901
+This {\an4} is a line.
+
+10
+00:00:019,567 --> 00:00:19,901
+This {\an5} is a line.
+
+11
+00:00:020,567 --> 00:00:20,901
+This {\an6} is a line.
+
+12
+00:00:021,567 --> 00:00:22,901
+This {\an7} is a line.
+
+13
+00:00:023,567 --> 00:00:23,901
+This {\an8} is a line.
+
+14
+00:00:024,567 --> 00:00:24,901
+This {\an9} is a line.
diff --git a/library/core/src/test/assets/ts/bbb_2500ms.ts b/library/core/src/test/assets/ts/bbb_2500ms.ts
new file mode 100644
index 0000000000..34ab2e9bc3
Binary files /dev/null and b/library/core/src/test/assets/ts/bbb_2500ms.ts differ
diff --git a/library/core/src/test/assets/ts/elephants_dream.mpg b/library/core/src/test/assets/ts/elephants_dream.mpg
new file mode 100644
index 0000000000..05a1d17f4b
Binary files /dev/null and b/library/core/src/test/assets/ts/elephants_dream.mpg differ
diff --git a/library/core/src/test/assets/ts/sample.eac3 b/library/core/src/test/assets/ts/sample.eac3
new file mode 100644
index 0000000000..3b7082cac8
Binary files /dev/null and b/library/core/src/test/assets/ts/sample.eac3 differ
diff --git a/library/core/src/test/assets/ts/sample.eac3.0.dump b/library/core/src/test/assets/ts/sample.eac3.0.dump
new file mode 100644
index 0000000000..b0b2779958
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.eac3.0.dump
@@ -0,0 +1,246 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/eac3
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 6
+    sampleRate = 48000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 216000
+  sample count = 54
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 4000, hash BAEAFB2A
+  sample 1:
+    time = 5333
+    flags = 1
+    data = length 4000, hash E3C5EBF0
+  sample 2:
+    time = 10666
+    flags = 1
+    data = length 4000, hash 32E0F957
+  sample 3:
+    time = 15999
+    flags = 1
+    data = length 4000, hash 5354CC5D
+  sample 4:
+    time = 21332
+    flags = 1
+    data = length 4000, hash FF834906
+  sample 5:
+    time = 26665
+    flags = 1
+    data = length 4000, hash 6F571E61
+  sample 6:
+    time = 31998
+    flags = 1
+    data = length 4000, hash 5C931F6B
+  sample 7:
+    time = 37331
+    flags = 1
+    data = length 4000, hash B1FB2E57
+  sample 8:
+    time = 42664
+    flags = 1
+    data = length 4000, hash C71240EB
+  sample 9:
+    time = 47997
+    flags = 1
+    data = length 4000, hash C3E302EE
+  sample 10:
+    time = 53330
+    flags = 1
+    data = length 4000, hash 7994C27B
+  sample 11:
+    time = 58663
+    flags = 1
+    data = length 4000, hash 1ED4E6F3
+  sample 12:
+    time = 63996
+    flags = 1
+    data = length 4000, hash 1D5E6AAC
+  sample 13:
+    time = 69329
+    flags = 1
+    data = length 4000, hash 30058F51
+  sample 14:
+    time = 74662
+    flags = 1
+    data = length 4000, hash 15DD0E4A
+  sample 15:
+    time = 79995
+    flags = 1
+    data = length 4000, hash 37BE7C15
+  sample 16:
+    time = 85328
+    flags = 1
+    data = length 4000, hash 7CFDD34B
+  sample 17:
+    time = 90661
+    flags = 1
+    data = length 4000, hash 27F20D29
+  sample 18:
+    time = 95994
+    flags = 1
+    data = length 4000, hash 6F565894
+  sample 19:
+    time = 101327
+    flags = 1
+    data = length 4000, hash A6F07C4A
+  sample 20:
+    time = 106660
+    flags = 1
+    data = length 4000, hash 3A0CA15C
+  sample 21:
+    time = 111993
+    flags = 1
+    data = length 4000, hash DB365414
+  sample 22:
+    time = 117326
+    flags = 1
+    data = length 4000, hash 31E08469
+  sample 23:
+    time = 122659
+    flags = 1
+    data = length 4000, hash 315F5C28
+  sample 24:
+    time = 127992
+    flags = 1
+    data = length 4000, hash CC65DF80
+  sample 25:
+    time = 133325
+    flags = 1
+    data = length 4000, hash 503FB64C
+  sample 26:
+    time = 138658
+    flags = 1
+    data = length 4000, hash 817CF735
+  sample 27:
+    time = 143991
+    flags = 1
+    data = length 4000, hash 37391ADA
+  sample 28:
+    time = 149324
+    flags = 1
+    data = length 4000, hash 37391ADA
+  sample 29:
+    time = 154657
+    flags = 1
+    data = length 4000, hash 64DBF751
+  sample 30:
+    time = 159990
+    flags = 1
+    data = length 4000, hash 81AE828E
+  sample 31:
+    time = 165323
+    flags = 1
+    data = length 4000, hash 767D6C98
+  sample 32:
+    time = 170656
+    flags = 1
+    data = length 4000, hash A5F6D4E
+  sample 33:
+    time = 175989
+    flags = 1
+    data = length 4000, hash EABC6B0D
+  sample 34:
+    time = 181322
+    flags = 1
+    data = length 4000, hash F47EF742
+  sample 35:
+    time = 186655
+    flags = 1
+    data = length 4000, hash 9B2549DA
+  sample 36:
+    time = 191988
+    flags = 1
+    data = length 4000, hash A12733C9
+  sample 37:
+    time = 197321
+    flags = 1
+    data = length 4000, hash 95F62E99
+  sample 38:
+    time = 202654
+    flags = 1
+    data = length 4000, hash A4D858
+  sample 39:
+    time = 207987
+    flags = 1
+    data = length 4000, hash A4D858
+  sample 40:
+    time = 213320
+    flags = 1
+    data = length 4000, hash 22C1A129
+  sample 41:
+    time = 218653
+    flags = 1
+    data = length 4000, hash 2C51E4A1
+  sample 42:
+    time = 223986
+    flags = 1
+    data = length 4000, hash 3782E8BB
+  sample 43:
+    time = 229319
+    flags = 1
+    data = length 4000, hash 2C51E4A1
+  sample 44:
+    time = 234652
+    flags = 1
+    data = length 4000, hash BDB3D129
+  sample 45:
+    time = 239985
+    flags = 1
+    data = length 4000, hash F642A55
+  sample 46:
+    time = 245318
+    flags = 1
+    data = length 4000, hash 32F259F4
+  sample 47:
+    time = 250651
+    flags = 1
+    data = length 4000, hash 4C987B7C
+  sample 48:
+    time = 255984
+    flags = 1
+    data = length 4000, hash 57C98E1C
+  sample 49:
+    time = 261317
+    flags = 1
+    data = length 4000, hash 4C987B7C
+  sample 50:
+    time = 266650
+    flags = 1
+    data = length 4000, hash 4C987B7C
+  sample 51:
+    time = 271983
+    flags = 1
+    data = length 4000, hash 4C987B7C
+  sample 52:
+    time = 277316
+    flags = 1
+    data = length 4000, hash 4C987B7C
+  sample 53:
+    time = 282649
+    flags = 1
+    data = length 4000, hash 4C987B7C
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ps.0.dump b/library/core/src/test/assets/ts/sample.ps.0.dump
index dda6de8ab4..06ef48de7a 100644
--- a/library/core/src/test/assets/ts/sample.ps.0.dump
+++ b/library/core/src/test/assets/ts/sample.ps.0.dump
@@ -1,6 +1,6 @@
 seekMap:
-  isSeekable = false
-  duration = UNSET TIME
+  isSeekable = true
+  duration = 766
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 2
 track 192:
diff --git a/library/core/src/test/assets/ts/sample.ps.1.dump b/library/core/src/test/assets/ts/sample.ps.1.dump
new file mode 100644
index 0000000000..ce0f223bd4
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ps.1.dump
@@ -0,0 +1,59 @@
+seekMap:
+  isSeekable = true
+  duration = 766
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 192:
+  format:
+    bitrate = -1
+    id = 192
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+track 224:
+  format:
+    bitrate = -1
+    id = 224
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash 743CC6F8
+  total output bytes = 33949
+  sample count = 1
+  sample 0:
+    time = 80000
+    flags = 0
+    data = length 17831, hash 5C5A57F5
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ps.2.dump b/library/core/src/test/assets/ts/sample.ps.2.dump
new file mode 100644
index 0000000000..7d0a77037d
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ps.2.dump
@@ -0,0 +1,55 @@
+seekMap:
+  isSeekable = true
+  duration = 766
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 192:
+  format:
+    bitrate = -1
+    id = 192
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+track 224:
+  format:
+    bitrate = -1
+    id = 224
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash 743CC6F8
+  total output bytes = 19791
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ps.3.dump b/library/core/src/test/assets/ts/sample.ps.3.dump
new file mode 100644
index 0000000000..a7258cd7ef
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ps.3.dump
@@ -0,0 +1,55 @@
+seekMap:
+  isSeekable = true
+  duration = 766
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 192:
+  format:
+    bitrate = -1
+    id = 192
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+track 224:
+  format:
+    bitrate = -1
+    id = 224
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash 743CC6F8
+  total output bytes = 1585
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ps.unklen.dump b/library/core/src/test/assets/ts/sample.ps.unklen.dump
new file mode 100644
index 0000000000..dda6de8ab4
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ps.unklen.dump
@@ -0,0 +1,79 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 192:
+  format:
+    bitrate = -1
+    id = 192
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 1671
+  sample count = 4
+  sample 0:
+    time = 29088
+    flags = 1
+    data = length 417, hash 5C710F78
+  sample 1:
+    time = 55210
+    flags = 1
+    data = length 418, hash 79CF71F8
+  sample 2:
+    time = 81332
+    flags = 1
+    data = length 418, hash 79CF71F8
+  sample 3:
+    time = 107454
+    flags = 1
+    data = length 418, hash 79CF71F8
+track 224:
+  format:
+    bitrate = -1
+    id = 224
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash 743CC6F8
+  total output bytes = 44056
+  sample count = 2
+  sample 0:
+    time = 40000
+    flags = 1
+    data = length 20646, hash 576390B
+  sample 1:
+    time = 80000
+    flags = 0
+    data = length 17831, hash 5C5A57F5
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ts.0.dump b/library/core/src/test/assets/ts/sample.ts.0.dump
index a74268a702..b45a32fd3a 100644
--- a/library/core/src/test/assets/ts/sample.ts.0.dump
+++ b/library/core/src/test/assets/ts/sample.ts.0.dump
@@ -1,8 +1,8 @@
 seekMap:
-  isSeekable = false
-  duration = UNSET TIME
+  isSeekable = true
+  duration = 66733
   getPosition(0) = [[timeUs=0, position=0]]
-numberOfTracks = 2
+numberOfTracks = 3
 track 256:
   format:
     bitrate = -1
@@ -76,4 +76,28 @@ track 257:
     time = 100822
     flags = 1
     data = length 1254, hash 73FB07B8
+track 8448:
+  format:
+    bitrate = -1
+    id = 1/8448
+    containerMimeType = null
+    sampleMimeType = application/cea-608
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
 tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ts.1.dump b/library/core/src/test/assets/ts/sample.ts.1.dump
new file mode 100644
index 0000000000..5c361e1246
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ts.1.dump
@@ -0,0 +1,103 @@
+seekMap:
+  isSeekable = true
+  duration = 66733
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 3
+track 256:
+  format:
+    bitrate = -1
+    id = 1/256
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash CE183139
+  total output bytes = 45026
+  sample count = 2
+  sample 0:
+    time = 55610
+    flags = 1
+    data = length 20711, hash 34341E8
+  sample 1:
+    time = 88977
+    flags = 0
+    data = length 18112, hash EC44B35B
+track 257:
+  format:
+    bitrate = -1
+    id = 1/257
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = und
+    drmInitData = -
+    initializationData:
+  total output bytes = 5015
+  sample count = 4
+  sample 0:
+    time = 44699
+    flags = 1
+    data = length 1253, hash 727FD1C6
+  sample 1:
+    time = 70821
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 2:
+    time = 96944
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 3:
+    time = 123066
+    flags = 1
+    data = length 1254, hash 73FB07B8
+track 8448:
+  format:
+    bitrate = -1
+    id = 1/8448
+    containerMimeType = null
+    sampleMimeType = application/cea-608
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ts.2.dump b/library/core/src/test/assets/ts/sample.ts.2.dump
new file mode 100644
index 0000000000..cec91ae2b9
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ts.2.dump
@@ -0,0 +1,103 @@
+seekMap:
+  isSeekable = true
+  duration = 66733
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 3
+track 256:
+  format:
+    bitrate = -1
+    id = 1/256
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash CE183139
+  total output bytes = 45026
+  sample count = 2
+  sample 0:
+    time = 77854
+    flags = 1
+    data = length 20711, hash 34341E8
+  sample 1:
+    time = 111221
+    flags = 0
+    data = length 18112, hash EC44B35B
+track 257:
+  format:
+    bitrate = -1
+    id = 1/257
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = und
+    drmInitData = -
+    initializationData:
+  total output bytes = 5015
+  sample count = 4
+  sample 0:
+    time = 66943
+    flags = 1
+    data = length 1253, hash 727FD1C6
+  sample 1:
+    time = 93065
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 2:
+    time = 119188
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 3:
+    time = 145310
+    flags = 1
+    data = length 1254, hash 73FB07B8
+track 8448:
+  format:
+    bitrate = -1
+    id = 1/8448
+    containerMimeType = null
+    sampleMimeType = application/cea-608
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ts.3.dump b/library/core/src/test/assets/ts/sample.ts.3.dump
new file mode 100644
index 0000000000..d8238e1626
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ts.3.dump
@@ -0,0 +1,87 @@
+seekMap:
+  isSeekable = true
+  duration = 66733
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 3
+track 256:
+  format:
+    bitrate = -1
+    id = 1/256
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash CE183139
+  total output bytes = 0
+  sample count = 0
+track 257:
+  format:
+    bitrate = -1
+    id = 1/257
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = und
+    drmInitData = -
+    initializationData:
+  total output bytes = 2508
+  sample count = 2
+  sample 0:
+    time = 66733
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 1:
+    time = 92855
+    flags = 1
+    data = length 1254, hash 73FB07B8
+track 8448:
+  format:
+    bitrate = -1
+    id = 1/8448
+    containerMimeType = null
+    sampleMimeType = application/cea-608
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample.ts.unklen.dump b/library/core/src/test/assets/ts/sample.ts.unklen.dump
new file mode 100644
index 0000000000..56f6b01a9c
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ts.unklen.dump
@@ -0,0 +1,103 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 3
+track 256:
+  format:
+    bitrate = -1
+    id = 1/256
+    containerMimeType = null
+    sampleMimeType = video/mpeg2
+    maxInputSize = -1
+    width = 640
+    height = 426
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 22, hash CE183139
+  total output bytes = 45026
+  sample count = 2
+  sample 0:
+    time = 33366
+    flags = 1
+    data = length 20711, hash 34341E8
+  sample 1:
+    time = 66733
+    flags = 0
+    data = length 18112, hash EC44B35B
+track 257:
+  format:
+    bitrate = -1
+    id = 1/257
+    containerMimeType = null
+    sampleMimeType = audio/mpeg-L2
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = und
+    drmInitData = -
+    initializationData:
+  total output bytes = 5015
+  sample count = 4
+  sample 0:
+    time = 22455
+    flags = 1
+    data = length 1253, hash 727FD1C6
+  sample 1:
+    time = 48577
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 2:
+    time = 74700
+    flags = 1
+    data = length 1254, hash 73FB07B8
+  sample 3:
+    time = 100822
+    flags = 1
+    data = length 1254, hash 73FB07B8
+track 8448:
+  format:
+    bitrate = -1
+    id = 1/8448
+    containerMimeType = null
+    sampleMimeType = application/cea-608
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample_cbs.adts b/library/core/src/test/assets/ts/sample_cbs.adts
new file mode 100644
index 0000000000..abbaad0daf
Binary files /dev/null and b/library/core/src/test/assets/ts/sample_cbs.adts differ
diff --git a/library/core/src/test/assets/ts/sample_cbs.adts.0.dump b/library/core/src/test/assets/ts/sample_cbs.adts.0.dump
new file mode 100644
index 0000000000..e535aa8cd7
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample_cbs.adts.0.dump
@@ -0,0 +1,631 @@
+seekMap:
+  isSeekable = true
+  duration = 3356772
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/mp4a-latm
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 2, hash 5F7
+  total output bytes = 30797
+  sample count = 144
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 23, hash 47DE9131
+  sample 1:
+    time = 23219
+    flags = 1
+    data = length 6, hash 31CF3A46
+  sample 2:
+    time = 46438
+    flags = 1
+    data = length 6, hash 31CF3A46
+  sample 3:
+    time = 69657
+    flags = 1
+    data = length 6, hash 31CF3A46
+  sample 4:
+    time = 92876
+    flags = 1
+    data = length 6, hash 31EC5206
+  sample 5:
+    time = 116095
+    flags = 1
+    data = length 171, hash 4F6478F6
+  sample 6:
+    time = 139314
+    flags = 1
+    data = length 202, hash AF4068A3
+  sample 7:
+    time = 162533
+    flags = 1
+    data = length 210, hash E4C10618
+  sample 8:
+    time = 185752
+    flags = 1
+    data = length 217, hash 9ECCD0D9
+  sample 9:
+    time = 208971
+    flags = 1
+    data = length 212, hash 6BAC2CD9
+  sample 10:
+    time = 232190
+    flags = 1
+    data = length 223, hash 188B6010
+  sample 11:
+    time = 255409
+    flags = 1
+    data = length 222, hash C1A04D0C
+  sample 12:
+    time = 278628
+    flags = 1
+    data = length 220, hash D65F9768
+  sample 13:
+    time = 301847
+    flags = 1
+    data = length 227, hash B96C9E14
+  sample 14:
+    time = 325066
+    flags = 1
+    data = length 229, hash 9FB09972
+  sample 15:
+    time = 348285
+    flags = 1
+    data = length 220, hash 2271F053
+  sample 16:
+    time = 371504
+    flags = 1
+    data = length 226, hash 5EDD2F4F
+  sample 17:
+    time = 394723
+    flags = 1
+    data = length 239, hash 957510E0
+  sample 18:
+    time = 417942
+    flags = 1
+    data = length 224, hash 718A8F47
+  sample 19:
+    time = 441161
+    flags = 1
+    data = length 225, hash 5E11E293
+  sample 20:
+    time = 464380
+    flags = 1
+    data = length 227, hash FCE50D27
+  sample 21:
+    time = 487599
+    flags = 1
+    data = length 212, hash 77908C40
+  sample 22:
+    time = 510818
+    flags = 1
+    data = length 227, hash 34C4EB32
+  sample 23:
+    time = 534037
+    flags = 1
+    data = length 231, hash 95488307
+  sample 24:
+    time = 557256
+    flags = 1
+    data = length 226, hash 97F12D6F
+  sample 25:
+    time = 580475
+    flags = 1
+    data = length 236, hash 91A9D9A2
+  sample 26:
+    time = 603694
+    flags = 1
+    data = length 227, hash 27A608F9
+  sample 27:
+    time = 626913
+    flags = 1
+    data = length 229, hash 57DAAE4
+  sample 28:
+    time = 650132
+    flags = 1
+    data = length 235, hash ED30AC34
+  sample 29:
+    time = 673351
+    flags = 1
+    data = length 227, hash BD3D6280
+  sample 30:
+    time = 696570
+    flags = 1
+    data = length 233, hash 694B1087
+  sample 31:
+    time = 719789
+    flags = 1
+    data = length 232, hash 1EDFE047
+  sample 32:
+    time = 743008
+    flags = 1
+    data = length 228, hash E2A831F4
+  sample 33:
+    time = 766227
+    flags = 1
+    data = length 231, hash 757E6012
+  sample 34:
+    time = 789446
+    flags = 1
+    data = length 223, hash 4003D791
+  sample 35:
+    time = 812665
+    flags = 1
+    data = length 232, hash 3CF9A07C
+  sample 36:
+    time = 835884
+    flags = 1
+    data = length 228, hash 25AC3FF7
+  sample 37:
+    time = 859103
+    flags = 1
+    data = length 220, hash 2C1824CE
+  sample 38:
+    time = 882322
+    flags = 1
+    data = length 229, hash 46FDD8FB
+  sample 39:
+    time = 905541
+    flags = 1
+    data = length 237, hash F6988018
+  sample 40:
+    time = 928760
+    flags = 1
+    data = length 242, hash 60436B6B
+  sample 41:
+    time = 951979
+    flags = 1
+    data = length 275, hash 90EDFA8E
+  sample 42:
+    time = 975198
+    flags = 1
+    data = length 242, hash 5C86EFCB
+  sample 43:
+    time = 998417
+    flags = 1
+    data = length 233, hash E0A51B82
+  sample 44:
+    time = 1021636
+    flags = 1
+    data = length 235, hash 590DF14F
+  sample 45:
+    time = 1044855
+    flags = 1
+    data = length 238, hash 69AF4E6E
+  sample 46:
+    time = 1068074
+    flags = 1
+    data = length 235, hash E745AE8D
+  sample 47:
+    time = 1091293
+    flags = 1
+    data = length 223, hash 295F2A13
+  sample 48:
+    time = 1114512
+    flags = 1
+    data = length 228, hash E2F47B21
+  sample 49:
+    time = 1137731
+    flags = 1
+    data = length 229, hash 262C3CFE
+  sample 50:
+    time = 1160950
+    flags = 1
+    data = length 232, hash 4B5BF5E8
+  sample 51:
+    time = 1184169
+    flags = 1
+    data = length 233, hash F3D80836
+  sample 52:
+    time = 1207388
+    flags = 1
+    data = length 237, hash 32E0A11E
+  sample 53:
+    time = 1230607
+    flags = 1
+    data = length 228, hash E1B89F13
+  sample 54:
+    time = 1253826
+    flags = 1
+    data = length 237, hash 8BDD9E38
+  sample 55:
+    time = 1277045
+    flags = 1
+    data = length 235, hash 3C84161F
+  sample 56:
+    time = 1300264
+    flags = 1
+    data = length 227, hash A47E1789
+  sample 57:
+    time = 1323483
+    flags = 1
+    data = length 228, hash 869FDFD3
+  sample 58:
+    time = 1346702
+    flags = 1
+    data = length 233, hash 272ECE2
+  sample 59:
+    time = 1369921
+    flags = 1
+    data = length 227, hash DB6B9618
+  sample 60:
+    time = 1393140
+    flags = 1
+    data = length 212, hash 63214325
+  sample 61:
+    time = 1416359
+    flags = 1
+    data = length 221, hash 9BA588A1
+  sample 62:
+    time = 1439578
+    flags = 1
+    data = length 225, hash 21EFD50C
+  sample 63:
+    time = 1462797
+    flags = 1
+    data = length 231, hash F3AD0BF
+  sample 64:
+    time = 1486016
+    flags = 1
+    data = length 224, hash 822C9210
+  sample 65:
+    time = 1509235
+    flags = 1
+    data = length 195, hash D4EF53EE
+  sample 66:
+    time = 1532454
+    flags = 1
+    data = length 195, hash A816647A
+  sample 67:
+    time = 1555673
+    flags = 1
+    data = length 184, hash 9A2B7E6
+  sample 68:
+    time = 1578892
+    flags = 1
+    data = length 210, hash 956E3600
+  sample 69:
+    time = 1602111
+    flags = 1
+    data = length 234, hash 35CFDA0A
+  sample 70:
+    time = 1625330
+    flags = 1
+    data = length 239, hash 9E15AC1E
+  sample 71:
+    time = 1648549
+    flags = 1
+    data = length 228, hash F3B70641
+  sample 72:
+    time = 1671768
+    flags = 1
+    data = length 237, hash 124E3194
+  sample 73:
+    time = 1694987
+    flags = 1
+    data = length 231, hash 950CD7C8
+  sample 74:
+    time = 1718206
+    flags = 1
+    data = length 236, hash A12E49AF
+  sample 75:
+    time = 1741425
+    flags = 1
+    data = length 242, hash 43BC9C24
+  sample 76:
+    time = 1764644
+    flags = 1
+    data = length 241, hash DCF0B17
+  sample 77:
+    time = 1787863
+    flags = 1
+    data = length 251, hash C0B99968
+  sample 78:
+    time = 1811082
+    flags = 1
+    data = length 245, hash 9B38ED1C
+  sample 79:
+    time = 1834301
+    flags = 1
+    data = length 238, hash 1BA69079
+  sample 80:
+    time = 1857520
+    flags = 1
+    data = length 233, hash 44C8C6BF
+  sample 81:
+    time = 1880739
+    flags = 1
+    data = length 231, hash EABBEE02
+  sample 82:
+    time = 1903958
+    flags = 1
+    data = length 226, hash D09C44FB
+  sample 83:
+    time = 1927177
+    flags = 1
+    data = length 235, hash BE6A6608
+  sample 84:
+    time = 1950396
+    flags = 1
+    data = length 235, hash 2735F454
+  sample 85:
+    time = 1973615
+    flags = 1
+    data = length 238, hash B160DFE7
+  sample 86:
+    time = 1996834
+    flags = 1
+    data = length 232, hash 1B217D2E
+  sample 87:
+    time = 2020053
+    flags = 1
+    data = length 251, hash D1C14CEA
+  sample 88:
+    time = 2043272
+    flags = 1
+    data = length 256, hash 97C87F08
+  sample 89:
+    time = 2066491
+    flags = 1
+    data = length 237, hash 6645DB3
+  sample 90:
+    time = 2089710
+    flags = 1
+    data = length 235, hash 727A1C82
+  sample 91:
+    time = 2112929
+    flags = 1
+    data = length 234, hash 5015F8B5
+  sample 92:
+    time = 2136148
+    flags = 1
+    data = length 241, hash 9102144B
+  sample 93:
+    time = 2159367
+    flags = 1
+    data = length 224, hash 64E0D807
+  sample 94:
+    time = 2182586
+    flags = 1
+    data = length 228, hash 1922B852
+  sample 95:
+    time = 2205805
+    flags = 1
+    data = length 224, hash 953502D8
+  sample 96:
+    time = 2229024
+    flags = 1
+    data = length 214, hash 92B87FE7
+  sample 97:
+    time = 2252243
+    flags = 1
+    data = length 213, hash BB0C8D86
+  sample 98:
+    time = 2275462
+    flags = 1
+    data = length 206, hash 9AD21017
+  sample 99:
+    time = 2298681
+    flags = 1
+    data = length 209, hash C479FE94
+  sample 100:
+    time = 2321900
+    flags = 1
+    data = length 220, hash 3033DCE1
+  sample 101:
+    time = 2345119
+    flags = 1
+    data = length 217, hash 7D589C94
+  sample 102:
+    time = 2368338
+    flags = 1
+    data = length 216, hash AAF6C183
+  sample 103:
+    time = 2391557
+    flags = 1
+    data = length 206, hash 1EE1207F
+  sample 104:
+    time = 2414776
+    flags = 1
+    data = length 204, hash 4BEB1210
+  sample 105:
+    time = 2437995
+    flags = 1
+    data = length 213, hash 21A841C9
+  sample 106:
+    time = 2461214
+    flags = 1
+    data = length 207, hash B80B0424
+  sample 107:
+    time = 2484433
+    flags = 1
+    data = length 212, hash 4785A1C3
+  sample 108:
+    time = 2507652
+    flags = 1
+    data = length 205, hash 59BF7229
+  sample 109:
+    time = 2530871
+    flags = 1
+    data = length 208, hash FA313DDE
+  sample 110:
+    time = 2554090
+    flags = 1
+    data = length 211, hash 190D85FD
+  sample 111:
+    time = 2577309
+    flags = 1
+    data = length 211, hash BA050052
+  sample 112:
+    time = 2600528
+    flags = 1
+    data = length 211, hash F3080F10
+  sample 113:
+    time = 2623747
+    flags = 1
+    data = length 210, hash F41B7BE7
+  sample 114:
+    time = 2646966
+    flags = 1
+    data = length 207, hash 2176C97E
+  sample 115:
+    time = 2670185
+    flags = 1
+    data = length 220, hash 32087455
+  sample 116:
+    time = 2693404
+    flags = 1
+    data = length 213, hash 4E5649A8
+  sample 117:
+    time = 2716623
+    flags = 1
+    data = length 213, hash 5F12FDCF
+  sample 118:
+    time = 2739842
+    flags = 1
+    data = length 204, hash 1E895C2A
+  sample 119:
+    time = 2763061
+    flags = 1
+    data = length 219, hash 45382270
+  sample 120:
+    time = 2786280
+    flags = 1
+    data = length 205, hash D66C6A1D
+  sample 121:
+    time = 2809499
+    flags = 1
+    data = length 204, hash 467AD01F
+  sample 122:
+    time = 2832718
+    flags = 1
+    data = length 211, hash F0435574
+  sample 123:
+    time = 2855937
+    flags = 1
+    data = length 206, hash 8C96B75F
+  sample 124:
+    time = 2879156
+    flags = 1
+    data = length 200, hash 82553248
+  sample 125:
+    time = 2902375
+    flags = 1
+    data = length 180, hash 1E51E6CE
+  sample 126:
+    time = 2925594
+    flags = 1
+    data = length 196, hash 33151DC4
+  sample 127:
+    time = 2948813
+    flags = 1
+    data = length 197, hash 1E62A7D6
+  sample 128:
+    time = 2972032
+    flags = 1
+    data = length 206, hash 6A6C4CC9
+  sample 129:
+    time = 2995251
+    flags = 1
+    data = length 209, hash A72FABAA
+  sample 130:
+    time = 3018470
+    flags = 1
+    data = length 217, hash BA33B985
+  sample 131:
+    time = 3041689
+    flags = 1
+    data = length 235, hash 9919CFD9
+  sample 132:
+    time = 3064908
+    flags = 1
+    data = length 236, hash A22C7267
+  sample 133:
+    time = 3088127
+    flags = 1
+    data = length 213, hash 3D57C901
+  sample 134:
+    time = 3111346
+    flags = 1
+    data = length 205, hash 47F68FDE
+  sample 135:
+    time = 3134565
+    flags = 1
+    data = length 210, hash 9A756E9C
+  sample 136:
+    time = 3157784
+    flags = 1
+    data = length 210, hash BD45C31F
+  sample 137:
+    time = 3181003
+    flags = 1
+    data = length 207, hash 8774FF7B
+  sample 138:
+    time = 3204222
+    flags = 1
+    data = length 149, hash 4678C0E5
+  sample 139:
+    time = 3227441
+    flags = 1
+    data = length 161, hash E991035D
+  sample 140:
+    time = 3250660
+    flags = 1
+    data = length 197, hash C3013689
+  sample 141:
+    time = 3273879
+    flags = 1
+    data = length 208, hash E6C0237
+  sample 142:
+    time = 3297098
+    flags = 1
+    data = length 232, hash A330F188
+  sample 143:
+    time = 3320317
+    flags = 1
+    data = length 174, hash 2B69C34E
+track 1:
+  format:
+    bitrate = -1
+    id = 1
+    containerMimeType = null
+    sampleMimeType = application/id3
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample_cbs.adts.1.dump b/library/core/src/test/assets/ts/sample_cbs.adts.1.dump
new file mode 100644
index 0000000000..96d2fcfb39
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample_cbs.adts.1.dump
@@ -0,0 +1,431 @@
+seekMap:
+  isSeekable = true
+  duration = 3356772
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/mp4a-latm
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 2, hash 5F7
+  total output bytes = 20533
+  sample count = 94
+  sample 0:
+    time = 1118924
+    flags = 1
+    data = length 232, hash 4B5BF5E8
+  sample 1:
+    time = 1142143
+    flags = 1
+    data = length 233, hash F3D80836
+  sample 2:
+    time = 1165362
+    flags = 1
+    data = length 237, hash 32E0A11E
+  sample 3:
+    time = 1188581
+    flags = 1
+    data = length 228, hash E1B89F13
+  sample 4:
+    time = 1211800
+    flags = 1
+    data = length 237, hash 8BDD9E38
+  sample 5:
+    time = 1235019
+    flags = 1
+    data = length 235, hash 3C84161F
+  sample 6:
+    time = 1258238
+    flags = 1
+    data = length 227, hash A47E1789
+  sample 7:
+    time = 1281457
+    flags = 1
+    data = length 228, hash 869FDFD3
+  sample 8:
+    time = 1304676
+    flags = 1
+    data = length 233, hash 272ECE2
+  sample 9:
+    time = 1327895
+    flags = 1
+    data = length 227, hash DB6B9618
+  sample 10:
+    time = 1351114
+    flags = 1
+    data = length 212, hash 63214325
+  sample 11:
+    time = 1374333
+    flags = 1
+    data = length 221, hash 9BA588A1
+  sample 12:
+    time = 1397552
+    flags = 1
+    data = length 225, hash 21EFD50C
+  sample 13:
+    time = 1420771
+    flags = 1
+    data = length 231, hash F3AD0BF
+  sample 14:
+    time = 1443990
+    flags = 1
+    data = length 224, hash 822C9210
+  sample 15:
+    time = 1467209
+    flags = 1
+    data = length 195, hash D4EF53EE
+  sample 16:
+    time = 1490428
+    flags = 1
+    data = length 195, hash A816647A
+  sample 17:
+    time = 1513647
+    flags = 1
+    data = length 184, hash 9A2B7E6
+  sample 18:
+    time = 1536866
+    flags = 1
+    data = length 210, hash 956E3600
+  sample 19:
+    time = 1560085
+    flags = 1
+    data = length 234, hash 35CFDA0A
+  sample 20:
+    time = 1583304
+    flags = 1
+    data = length 239, hash 9E15AC1E
+  sample 21:
+    time = 1606523
+    flags = 1
+    data = length 228, hash F3B70641
+  sample 22:
+    time = 1629742
+    flags = 1
+    data = length 237, hash 124E3194
+  sample 23:
+    time = 1652961
+    flags = 1
+    data = length 231, hash 950CD7C8
+  sample 24:
+    time = 1676180
+    flags = 1
+    data = length 236, hash A12E49AF
+  sample 25:
+    time = 1699399
+    flags = 1
+    data = length 242, hash 43BC9C24
+  sample 26:
+    time = 1722618
+    flags = 1
+    data = length 241, hash DCF0B17
+  sample 27:
+    time = 1745837
+    flags = 1
+    data = length 251, hash C0B99968
+  sample 28:
+    time = 1769056
+    flags = 1
+    data = length 245, hash 9B38ED1C
+  sample 29:
+    time = 1792275
+    flags = 1
+    data = length 238, hash 1BA69079
+  sample 30:
+    time = 1815494
+    flags = 1
+    data = length 233, hash 44C8C6BF
+  sample 31:
+    time = 1838713
+    flags = 1
+    data = length 231, hash EABBEE02
+  sample 32:
+    time = 1861932
+    flags = 1
+    data = length 226, hash D09C44FB
+  sample 33:
+    time = 1885151
+    flags = 1
+    data = length 235, hash BE6A6608
+  sample 34:
+    time = 1908370
+    flags = 1
+    data = length 235, hash 2735F454
+  sample 35:
+    time = 1931589
+    flags = 1
+    data = length 238, hash B160DFE7
+  sample 36:
+    time = 1954808
+    flags = 1
+    data = length 232, hash 1B217D2E
+  sample 37:
+    time = 1978027
+    flags = 1
+    data = length 251, hash D1C14CEA
+  sample 38:
+    time = 2001246
+    flags = 1
+    data = length 256, hash 97C87F08
+  sample 39:
+    time = 2024465
+    flags = 1
+    data = length 237, hash 6645DB3
+  sample 40:
+    time = 2047684
+    flags = 1
+    data = length 235, hash 727A1C82
+  sample 41:
+    time = 2070903
+    flags = 1
+    data = length 234, hash 5015F8B5
+  sample 42:
+    time = 2094122
+    flags = 1
+    data = length 241, hash 9102144B
+  sample 43:
+    time = 2117341
+    flags = 1
+    data = length 224, hash 64E0D807
+  sample 44:
+    time = 2140560
+    flags = 1
+    data = length 228, hash 1922B852
+  sample 45:
+    time = 2163779
+    flags = 1
+    data = length 224, hash 953502D8
+  sample 46:
+    time = 2186998
+    flags = 1
+    data = length 214, hash 92B87FE7
+  sample 47:
+    time = 2210217
+    flags = 1
+    data = length 213, hash BB0C8D86
+  sample 48:
+    time = 2233436
+    flags = 1
+    data = length 206, hash 9AD21017
+  sample 49:
+    time = 2256655
+    flags = 1
+    data = length 209, hash C479FE94
+  sample 50:
+    time = 2279874
+    flags = 1
+    data = length 220, hash 3033DCE1
+  sample 51:
+    time = 2303093
+    flags = 1
+    data = length 217, hash 7D589C94
+  sample 52:
+    time = 2326312
+    flags = 1
+    data = length 216, hash AAF6C183
+  sample 53:
+    time = 2349531
+    flags = 1
+    data = length 206, hash 1EE1207F
+  sample 54:
+    time = 2372750
+    flags = 1
+    data = length 204, hash 4BEB1210
+  sample 55:
+    time = 2395969
+    flags = 1
+    data = length 213, hash 21A841C9
+  sample 56:
+    time = 2419188
+    flags = 1
+    data = length 207, hash B80B0424
+  sample 57:
+    time = 2442407
+    flags = 1
+    data = length 212, hash 4785A1C3
+  sample 58:
+    time = 2465626
+    flags = 1
+    data = length 205, hash 59BF7229
+  sample 59:
+    time = 2488845
+    flags = 1
+    data = length 208, hash FA313DDE
+  sample 60:
+    time = 2512064
+    flags = 1
+    data = length 211, hash 190D85FD
+  sample 61:
+    time = 2535283
+    flags = 1
+    data = length 211, hash BA050052
+  sample 62:
+    time = 2558502
+    flags = 1
+    data = length 211, hash F3080F10
+  sample 63:
+    time = 2581721
+    flags = 1
+    data = length 210, hash F41B7BE7
+  sample 64:
+    time = 2604940
+    flags = 1
+    data = length 207, hash 2176C97E
+  sample 65:
+    time = 2628159
+    flags = 1
+    data = length 220, hash 32087455
+  sample 66:
+    time = 2651378
+    flags = 1
+    data = length 213, hash 4E5649A8
+  sample 67:
+    time = 2674597
+    flags = 1
+    data = length 213, hash 5F12FDCF
+  sample 68:
+    time = 2697816
+    flags = 1
+    data = length 204, hash 1E895C2A
+  sample 69:
+    time = 2721035
+    flags = 1
+    data = length 219, hash 45382270
+  sample 70:
+    time = 2744254
+    flags = 1
+    data = length 205, hash D66C6A1D
+  sample 71:
+    time = 2767473
+    flags = 1
+    data = length 204, hash 467AD01F
+  sample 72:
+    time = 2790692
+    flags = 1
+    data = length 211, hash F0435574
+  sample 73:
+    time = 2813911
+    flags = 1
+    data = length 206, hash 8C96B75F
+  sample 74:
+    time = 2837130
+    flags = 1
+    data = length 200, hash 82553248
+  sample 75:
+    time = 2860349
+    flags = 1
+    data = length 180, hash 1E51E6CE
+  sample 76:
+    time = 2883568
+    flags = 1
+    data = length 196, hash 33151DC4
+  sample 77:
+    time = 2906787
+    flags = 1
+    data = length 197, hash 1E62A7D6
+  sample 78:
+    time = 2930006
+    flags = 1
+    data = length 206, hash 6A6C4CC9
+  sample 79:
+    time = 2953225
+    flags = 1
+    data = length 209, hash A72FABAA
+  sample 80:
+    time = 2976444
+    flags = 1
+    data = length 217, hash BA33B985
+  sample 81:
+    time = 2999663
+    flags = 1
+    data = length 235, hash 9919CFD9
+  sample 82:
+    time = 3022882
+    flags = 1
+    data = length 236, hash A22C7267
+  sample 83:
+    time = 3046101
+    flags = 1
+    data = length 213, hash 3D57C901
+  sample 84:
+    time = 3069320
+    flags = 1
+    data = length 205, hash 47F68FDE
+  sample 85:
+    time = 3092539
+    flags = 1
+    data = length 210, hash 9A756E9C
+  sample 86:
+    time = 3115758
+    flags = 1
+    data = length 210, hash BD45C31F
+  sample 87:
+    time = 3138977
+    flags = 1
+    data = length 207, hash 8774FF7B
+  sample 88:
+    time = 3162196
+    flags = 1
+    data = length 149, hash 4678C0E5
+  sample 89:
+    time = 3185415
+    flags = 1
+    data = length 161, hash E991035D
+  sample 90:
+    time = 3208634
+    flags = 1
+    data = length 197, hash C3013689
+  sample 91:
+    time = 3231853
+    flags = 1
+    data = length 208, hash E6C0237
+  sample 92:
+    time = 3255072
+    flags = 1
+    data = length 232, hash A330F188
+  sample 93:
+    time = 3278291
+    flags = 1
+    data = length 174, hash 2B69C34E
+track 1:
+  format:
+    bitrate = -1
+    id = 1
+    containerMimeType = null
+    sampleMimeType = application/id3
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample_cbs.adts.2.dump b/library/core/src/test/assets/ts/sample_cbs.adts.2.dump
new file mode 100644
index 0000000000..2e581bca28
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample_cbs.adts.2.dump
@@ -0,0 +1,251 @@
+seekMap:
+  isSeekable = true
+  duration = 3356772
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/mp4a-latm
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 2, hash 5F7
+  total output bytes = 10161
+  sample count = 49
+  sample 0:
+    time = 2237848
+    flags = 1
+    data = length 224, hash 953502D8
+  sample 1:
+    time = 2261067
+    flags = 1
+    data = length 214, hash 92B87FE7
+  sample 2:
+    time = 2284286
+    flags = 1
+    data = length 213, hash BB0C8D86
+  sample 3:
+    time = 2307505
+    flags = 1
+    data = length 206, hash 9AD21017
+  sample 4:
+    time = 2330724
+    flags = 1
+    data = length 209, hash C479FE94
+  sample 5:
+    time = 2353943
+    flags = 1
+    data = length 220, hash 3033DCE1
+  sample 6:
+    time = 2377162
+    flags = 1
+    data = length 217, hash 7D589C94
+  sample 7:
+    time = 2400381
+    flags = 1
+    data = length 216, hash AAF6C183
+  sample 8:
+    time = 2423600
+    flags = 1
+    data = length 206, hash 1EE1207F
+  sample 9:
+    time = 2446819
+    flags = 1
+    data = length 204, hash 4BEB1210
+  sample 10:
+    time = 2470038
+    flags = 1
+    data = length 213, hash 21A841C9
+  sample 11:
+    time = 2493257
+    flags = 1
+    data = length 207, hash B80B0424
+  sample 12:
+    time = 2516476
+    flags = 1
+    data = length 212, hash 4785A1C3
+  sample 13:
+    time = 2539695
+    flags = 1
+    data = length 205, hash 59BF7229
+  sample 14:
+    time = 2562914
+    flags = 1
+    data = length 208, hash FA313DDE
+  sample 15:
+    time = 2586133
+    flags = 1
+    data = length 211, hash 190D85FD
+  sample 16:
+    time = 2609352
+    flags = 1
+    data = length 211, hash BA050052
+  sample 17:
+    time = 2632571
+    flags = 1
+    data = length 211, hash F3080F10
+  sample 18:
+    time = 2655790
+    flags = 1
+    data = length 210, hash F41B7BE7
+  sample 19:
+    time = 2679009
+    flags = 1
+    data = length 207, hash 2176C97E
+  sample 20:
+    time = 2702228
+    flags = 1
+    data = length 220, hash 32087455
+  sample 21:
+    time = 2725447
+    flags = 1
+    data = length 213, hash 4E5649A8
+  sample 22:
+    time = 2748666
+    flags = 1
+    data = length 213, hash 5F12FDCF
+  sample 23:
+    time = 2771885
+    flags = 1
+    data = length 204, hash 1E895C2A
+  sample 24:
+    time = 2795104
+    flags = 1
+    data = length 219, hash 45382270
+  sample 25:
+    time = 2818323
+    flags = 1
+    data = length 205, hash D66C6A1D
+  sample 26:
+    time = 2841542
+    flags = 1
+    data = length 204, hash 467AD01F
+  sample 27:
+    time = 2864761
+    flags = 1
+    data = length 211, hash F0435574
+  sample 28:
+    time = 2887980
+    flags = 1
+    data = length 206, hash 8C96B75F
+  sample 29:
+    time = 2911199
+    flags = 1
+    data = length 200, hash 82553248
+  sample 30:
+    time = 2934418
+    flags = 1
+    data = length 180, hash 1E51E6CE
+  sample 31:
+    time = 2957637
+    flags = 1
+    data = length 196, hash 33151DC4
+  sample 32:
+    time = 2980856
+    flags = 1
+    data = length 197, hash 1E62A7D6
+  sample 33:
+    time = 3004075
+    flags = 1
+    data = length 206, hash 6A6C4CC9
+  sample 34:
+    time = 3027294
+    flags = 1
+    data = length 209, hash A72FABAA
+  sample 35:
+    time = 3050513
+    flags = 1
+    data = length 217, hash BA33B985
+  sample 36:
+    time = 3073732
+    flags = 1
+    data = length 235, hash 9919CFD9
+  sample 37:
+    time = 3096951
+    flags = 1
+    data = length 236, hash A22C7267
+  sample 38:
+    time = 3120170
+    flags = 1
+    data = length 213, hash 3D57C901
+  sample 39:
+    time = 3143389
+    flags = 1
+    data = length 205, hash 47F68FDE
+  sample 40:
+    time = 3166608
+    flags = 1
+    data = length 210, hash 9A756E9C
+  sample 41:
+    time = 3189827
+    flags = 1
+    data = length 210, hash BD45C31F
+  sample 42:
+    time = 3213046
+    flags = 1
+    data = length 207, hash 8774FF7B
+  sample 43:
+    time = 3236265
+    flags = 1
+    data = length 149, hash 4678C0E5
+  sample 44:
+    time = 3259484
+    flags = 1
+    data = length 161, hash E991035D
+  sample 45:
+    time = 3282703
+    flags = 1
+    data = length 197, hash C3013689
+  sample 46:
+    time = 3305922
+    flags = 1
+    data = length 208, hash E6C0237
+  sample 47:
+    time = 3329141
+    flags = 1
+    data = length 232, hash A330F188
+  sample 48:
+    time = 3352360
+    flags = 1
+    data = length 174, hash 2B69C34E
+track 1:
+  format:
+    bitrate = -1
+    id = 1
+    containerMimeType = null
+    sampleMimeType = application/id3
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample_cbs.adts.3.dump b/library/core/src/test/assets/ts/sample_cbs.adts.3.dump
new file mode 100644
index 0000000000..e134a711bf
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample_cbs.adts.3.dump
@@ -0,0 +1,59 @@
+seekMap:
+  isSeekable = true
+  duration = 3356772
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/mp4a-latm
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 2, hash 5F7
+  total output bytes = 174
+  sample count = 1
+  sample 0:
+    time = 3356772
+    flags = 1
+    data = length 174, hash 2B69C34E
+track 1:
+  format:
+    bitrate = -1
+    id = 1
+    containerMimeType = null
+    sampleMimeType = application/id3
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ts/sample_cbs.adts.unklen.dump b/library/core/src/test/assets/ts/sample_cbs.adts.unklen.dump
new file mode 100644
index 0000000000..93d7b776c0
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample_cbs.adts.unklen.dump
@@ -0,0 +1,631 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 2
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/mp4a-latm
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 2, hash 5F7
+  total output bytes = 30797
+  sample count = 144
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 23, hash 47DE9131
+  sample 1:
+    time = 23219
+    flags = 1
+    data = length 6, hash 31CF3A46
+  sample 2:
+    time = 46438
+    flags = 1
+    data = length 6, hash 31CF3A46
+  sample 3:
+    time = 69657
+    flags = 1
+    data = length 6, hash 31CF3A46
+  sample 4:
+    time = 92876
+    flags = 1
+    data = length 6, hash 31EC5206
+  sample 5:
+    time = 116095
+    flags = 1
+    data = length 171, hash 4F6478F6
+  sample 6:
+    time = 139314
+    flags = 1
+    data = length 202, hash AF4068A3
+  sample 7:
+    time = 162533
+    flags = 1
+    data = length 210, hash E4C10618
+  sample 8:
+    time = 185752
+    flags = 1
+    data = length 217, hash 9ECCD0D9
+  sample 9:
+    time = 208971
+    flags = 1
+    data = length 212, hash 6BAC2CD9
+  sample 10:
+    time = 232190
+    flags = 1
+    data = length 223, hash 188B6010
+  sample 11:
+    time = 255409
+    flags = 1
+    data = length 222, hash C1A04D0C
+  sample 12:
+    time = 278628
+    flags = 1
+    data = length 220, hash D65F9768
+  sample 13:
+    time = 301847
+    flags = 1
+    data = length 227, hash B96C9E14
+  sample 14:
+    time = 325066
+    flags = 1
+    data = length 229, hash 9FB09972
+  sample 15:
+    time = 348285
+    flags = 1
+    data = length 220, hash 2271F053
+  sample 16:
+    time = 371504
+    flags = 1
+    data = length 226, hash 5EDD2F4F
+  sample 17:
+    time = 394723
+    flags = 1
+    data = length 239, hash 957510E0
+  sample 18:
+    time = 417942
+    flags = 1
+    data = length 224, hash 718A8F47
+  sample 19:
+    time = 441161
+    flags = 1
+    data = length 225, hash 5E11E293
+  sample 20:
+    time = 464380
+    flags = 1
+    data = length 227, hash FCE50D27
+  sample 21:
+    time = 487599
+    flags = 1
+    data = length 212, hash 77908C40
+  sample 22:
+    time = 510818
+    flags = 1
+    data = length 227, hash 34C4EB32
+  sample 23:
+    time = 534037
+    flags = 1
+    data = length 231, hash 95488307
+  sample 24:
+    time = 557256
+    flags = 1
+    data = length 226, hash 97F12D6F
+  sample 25:
+    time = 580475
+    flags = 1
+    data = length 236, hash 91A9D9A2
+  sample 26:
+    time = 603694
+    flags = 1
+    data = length 227, hash 27A608F9
+  sample 27:
+    time = 626913
+    flags = 1
+    data = length 229, hash 57DAAE4
+  sample 28:
+    time = 650132
+    flags = 1
+    data = length 235, hash ED30AC34
+  sample 29:
+    time = 673351
+    flags = 1
+    data = length 227, hash BD3D6280
+  sample 30:
+    time = 696570
+    flags = 1
+    data = length 233, hash 694B1087
+  sample 31:
+    time = 719789
+    flags = 1
+    data = length 232, hash 1EDFE047
+  sample 32:
+    time = 743008
+    flags = 1
+    data = length 228, hash E2A831F4
+  sample 33:
+    time = 766227
+    flags = 1
+    data = length 231, hash 757E6012
+  sample 34:
+    time = 789446
+    flags = 1
+    data = length 223, hash 4003D791
+  sample 35:
+    time = 812665
+    flags = 1
+    data = length 232, hash 3CF9A07C
+  sample 36:
+    time = 835884
+    flags = 1
+    data = length 228, hash 25AC3FF7
+  sample 37:
+    time = 859103
+    flags = 1
+    data = length 220, hash 2C1824CE
+  sample 38:
+    time = 882322
+    flags = 1
+    data = length 229, hash 46FDD8FB
+  sample 39:
+    time = 905541
+    flags = 1
+    data = length 237, hash F6988018
+  sample 40:
+    time = 928760
+    flags = 1
+    data = length 242, hash 60436B6B
+  sample 41:
+    time = 951979
+    flags = 1
+    data = length 275, hash 90EDFA8E
+  sample 42:
+    time = 975198
+    flags = 1
+    data = length 242, hash 5C86EFCB
+  sample 43:
+    time = 998417
+    flags = 1
+    data = length 233, hash E0A51B82
+  sample 44:
+    time = 1021636
+    flags = 1
+    data = length 235, hash 590DF14F
+  sample 45:
+    time = 1044855
+    flags = 1
+    data = length 238, hash 69AF4E6E
+  sample 46:
+    time = 1068074
+    flags = 1
+    data = length 235, hash E745AE8D
+  sample 47:
+    time = 1091293
+    flags = 1
+    data = length 223, hash 295F2A13
+  sample 48:
+    time = 1114512
+    flags = 1
+    data = length 228, hash E2F47B21
+  sample 49:
+    time = 1137731
+    flags = 1
+    data = length 229, hash 262C3CFE
+  sample 50:
+    time = 1160950
+    flags = 1
+    data = length 232, hash 4B5BF5E8
+  sample 51:
+    time = 1184169
+    flags = 1
+    data = length 233, hash F3D80836
+  sample 52:
+    time = 1207388
+    flags = 1
+    data = length 237, hash 32E0A11E
+  sample 53:
+    time = 1230607
+    flags = 1
+    data = length 228, hash E1B89F13
+  sample 54:
+    time = 1253826
+    flags = 1
+    data = length 237, hash 8BDD9E38
+  sample 55:
+    time = 1277045
+    flags = 1
+    data = length 235, hash 3C84161F
+  sample 56:
+    time = 1300264
+    flags = 1
+    data = length 227, hash A47E1789
+  sample 57:
+    time = 1323483
+    flags = 1
+    data = length 228, hash 869FDFD3
+  sample 58:
+    time = 1346702
+    flags = 1
+    data = length 233, hash 272ECE2
+  sample 59:
+    time = 1369921
+    flags = 1
+    data = length 227, hash DB6B9618
+  sample 60:
+    time = 1393140
+    flags = 1
+    data = length 212, hash 63214325
+  sample 61:
+    time = 1416359
+    flags = 1
+    data = length 221, hash 9BA588A1
+  sample 62:
+    time = 1439578
+    flags = 1
+    data = length 225, hash 21EFD50C
+  sample 63:
+    time = 1462797
+    flags = 1
+    data = length 231, hash F3AD0BF
+  sample 64:
+    time = 1486016
+    flags = 1
+    data = length 224, hash 822C9210
+  sample 65:
+    time = 1509235
+    flags = 1
+    data = length 195, hash D4EF53EE
+  sample 66:
+    time = 1532454
+    flags = 1
+    data = length 195, hash A816647A
+  sample 67:
+    time = 1555673
+    flags = 1
+    data = length 184, hash 9A2B7E6
+  sample 68:
+    time = 1578892
+    flags = 1
+    data = length 210, hash 956E3600
+  sample 69:
+    time = 1602111
+    flags = 1
+    data = length 234, hash 35CFDA0A
+  sample 70:
+    time = 1625330
+    flags = 1
+    data = length 239, hash 9E15AC1E
+  sample 71:
+    time = 1648549
+    flags = 1
+    data = length 228, hash F3B70641
+  sample 72:
+    time = 1671768
+    flags = 1
+    data = length 237, hash 124E3194
+  sample 73:
+    time = 1694987
+    flags = 1
+    data = length 231, hash 950CD7C8
+  sample 74:
+    time = 1718206
+    flags = 1
+    data = length 236, hash A12E49AF
+  sample 75:
+    time = 1741425
+    flags = 1
+    data = length 242, hash 43BC9C24
+  sample 76:
+    time = 1764644
+    flags = 1
+    data = length 241, hash DCF0B17
+  sample 77:
+    time = 1787863
+    flags = 1
+    data = length 251, hash C0B99968
+  sample 78:
+    time = 1811082
+    flags = 1
+    data = length 245, hash 9B38ED1C
+  sample 79:
+    time = 1834301
+    flags = 1
+    data = length 238, hash 1BA69079
+  sample 80:
+    time = 1857520
+    flags = 1
+    data = length 233, hash 44C8C6BF
+  sample 81:
+    time = 1880739
+    flags = 1
+    data = length 231, hash EABBEE02
+  sample 82:
+    time = 1903958
+    flags = 1
+    data = length 226, hash D09C44FB
+  sample 83:
+    time = 1927177
+    flags = 1
+    data = length 235, hash BE6A6608
+  sample 84:
+    time = 1950396
+    flags = 1
+    data = length 235, hash 2735F454
+  sample 85:
+    time = 1973615
+    flags = 1
+    data = length 238, hash B160DFE7
+  sample 86:
+    time = 1996834
+    flags = 1
+    data = length 232, hash 1B217D2E
+  sample 87:
+    time = 2020053
+    flags = 1
+    data = length 251, hash D1C14CEA
+  sample 88:
+    time = 2043272
+    flags = 1
+    data = length 256, hash 97C87F08
+  sample 89:
+    time = 2066491
+    flags = 1
+    data = length 237, hash 6645DB3
+  sample 90:
+    time = 2089710
+    flags = 1
+    data = length 235, hash 727A1C82
+  sample 91:
+    time = 2112929
+    flags = 1
+    data = length 234, hash 5015F8B5
+  sample 92:
+    time = 2136148
+    flags = 1
+    data = length 241, hash 9102144B
+  sample 93:
+    time = 2159367
+    flags = 1
+    data = length 224, hash 64E0D807
+  sample 94:
+    time = 2182586
+    flags = 1
+    data = length 228, hash 1922B852
+  sample 95:
+    time = 2205805
+    flags = 1
+    data = length 224, hash 953502D8
+  sample 96:
+    time = 2229024
+    flags = 1
+    data = length 214, hash 92B87FE7
+  sample 97:
+    time = 2252243
+    flags = 1
+    data = length 213, hash BB0C8D86
+  sample 98:
+    time = 2275462
+    flags = 1
+    data = length 206, hash 9AD21017
+  sample 99:
+    time = 2298681
+    flags = 1
+    data = length 209, hash C479FE94
+  sample 100:
+    time = 2321900
+    flags = 1
+    data = length 220, hash 3033DCE1
+  sample 101:
+    time = 2345119
+    flags = 1
+    data = length 217, hash 7D589C94
+  sample 102:
+    time = 2368338
+    flags = 1
+    data = length 216, hash AAF6C183
+  sample 103:
+    time = 2391557
+    flags = 1
+    data = length 206, hash 1EE1207F
+  sample 104:
+    time = 2414776
+    flags = 1
+    data = length 204, hash 4BEB1210
+  sample 105:
+    time = 2437995
+    flags = 1
+    data = length 213, hash 21A841C9
+  sample 106:
+    time = 2461214
+    flags = 1
+    data = length 207, hash B80B0424
+  sample 107:
+    time = 2484433
+    flags = 1
+    data = length 212, hash 4785A1C3
+  sample 108:
+    time = 2507652
+    flags = 1
+    data = length 205, hash 59BF7229
+  sample 109:
+    time = 2530871
+    flags = 1
+    data = length 208, hash FA313DDE
+  sample 110:
+    time = 2554090
+    flags = 1
+    data = length 211, hash 190D85FD
+  sample 111:
+    time = 2577309
+    flags = 1
+    data = length 211, hash BA050052
+  sample 112:
+    time = 2600528
+    flags = 1
+    data = length 211, hash F3080F10
+  sample 113:
+    time = 2623747
+    flags = 1
+    data = length 210, hash F41B7BE7
+  sample 114:
+    time = 2646966
+    flags = 1
+    data = length 207, hash 2176C97E
+  sample 115:
+    time = 2670185
+    flags = 1
+    data = length 220, hash 32087455
+  sample 116:
+    time = 2693404
+    flags = 1
+    data = length 213, hash 4E5649A8
+  sample 117:
+    time = 2716623
+    flags = 1
+    data = length 213, hash 5F12FDCF
+  sample 118:
+    time = 2739842
+    flags = 1
+    data = length 204, hash 1E895C2A
+  sample 119:
+    time = 2763061
+    flags = 1
+    data = length 219, hash 45382270
+  sample 120:
+    time = 2786280
+    flags = 1
+    data = length 205, hash D66C6A1D
+  sample 121:
+    time = 2809499
+    flags = 1
+    data = length 204, hash 467AD01F
+  sample 122:
+    time = 2832718
+    flags = 1
+    data = length 211, hash F0435574
+  sample 123:
+    time = 2855937
+    flags = 1
+    data = length 206, hash 8C96B75F
+  sample 124:
+    time = 2879156
+    flags = 1
+    data = length 200, hash 82553248
+  sample 125:
+    time = 2902375
+    flags = 1
+    data = length 180, hash 1E51E6CE
+  sample 126:
+    time = 2925594
+    flags = 1
+    data = length 196, hash 33151DC4
+  sample 127:
+    time = 2948813
+    flags = 1
+    data = length 197, hash 1E62A7D6
+  sample 128:
+    time = 2972032
+    flags = 1
+    data = length 206, hash 6A6C4CC9
+  sample 129:
+    time = 2995251
+    flags = 1
+    data = length 209, hash A72FABAA
+  sample 130:
+    time = 3018470
+    flags = 1
+    data = length 217, hash BA33B985
+  sample 131:
+    time = 3041689
+    flags = 1
+    data = length 235, hash 9919CFD9
+  sample 132:
+    time = 3064908
+    flags = 1
+    data = length 236, hash A22C7267
+  sample 133:
+    time = 3088127
+    flags = 1
+    data = length 213, hash 3D57C901
+  sample 134:
+    time = 3111346
+    flags = 1
+    data = length 205, hash 47F68FDE
+  sample 135:
+    time = 3134565
+    flags = 1
+    data = length 210, hash 9A756E9C
+  sample 136:
+    time = 3157784
+    flags = 1
+    data = length 210, hash BD45C31F
+  sample 137:
+    time = 3181003
+    flags = 1
+    data = length 207, hash 8774FF7B
+  sample 138:
+    time = 3204222
+    flags = 1
+    data = length 149, hash 4678C0E5
+  sample 139:
+    time = 3227441
+    flags = 1
+    data = length 161, hash E991035D
+  sample 140:
+    time = 3250660
+    flags = 1
+    data = length 197, hash C3013689
+  sample 141:
+    time = 3273879
+    flags = 1
+    data = length 208, hash E6C0237
+  sample 142:
+    time = 3297098
+    flags = 1
+    data = length 232, hash A330F188
+  sample 143:
+    time = 3320317
+    flags = 1
+    data = length 174, hash 2B69C34E
+track 1:
+  format:
+    bitrate = -1
+    id = 1
+    containerMimeType = null
+    sampleMimeType = application/id3
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 0
+  sample count = 0
+tracksEnded = true
diff --git a/library/core/src/test/assets/ttml/bitmap_percentage_region.xml b/library/core/src/test/assets/ttml/bitmap_percentage_region.xml
new file mode 100644
index 0000000000..9631650178
--- /dev/null
+++ b/library/core/src/test/assets/ttml/bitmap_percentage_region.xml
@@ -0,0 +1,26 @@
+<tt xmlns="http://www.w3.org/ns/ttml" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" xmlns:tts="http://www.w3.org/ns/ttml#styling" xmlns:smpte="http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" xml:lang="eng">
+    <head>
+        <metadata>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_0">
+                iVBORw0KGgoAAAANSUhEUgAAAXAAAABICAYAAADvR65LAAAACXBIWXMAAAsTAAALEwEAmpwYAAANIUlEQVR4nO2d/5GjSA+GNVVfALMh4EyucAIXxDiGCWFiwKngukwghA1h74/vxMia/t3qNtjvU7W1u8Ygtbp53agFvL2/v/8hAAAAh+N/j3YAAABAGRBwAAA4KBBwAAA4KC8j4MMwEBHRuq4P9qQ/vdv+yrFOBTECFhxawFNPgnEc6Xw+ExHRPM90u92a+7YXerZ9HEc6nU50Op2IiGhZFprnGSKleOXxCGwxE/BxHLd/uwYkb1+WpeqE1iLBLMuy/XEdX54wRyEW01RCbbeyMQwDnc/nzRYRBfvjWUmN517Ho9V4eDTP0o4YJgLOJ+/pdHLOKMZxpMvlQkRE0zQVn9B8HC3eknmeq2zsBSmI8zw3EUJLG1K85Y/psiyWLu+aHn3WkqP7zzxLO1IwEXB92ezbzsEsQYu3Fge2wX+etcNKaC2iwzDc9cs0TU896wFgL5gKuEug9cldIqxyhk/0c5bNNng7xOMbGYuWcZF9jPgD0IdqAY8JdGx2nkJsYWxdV1rXFcLhoXVcQiktAEA7igScqz+I6MeCotwmt7N4l5ZP+VIntZT4k7NP7Luu7fqKQsc4N3Ytbej+1p9pm67PYrYs4l3SDzlYx7PVeAwdI8f/Hn1Zsm9tP9SOtdz21WYosgVclkAR3QdIpjnkdv77crls4ltaPlU72/N1bKzkTadxUvaRsXItrLrKyfgzPQhLY9fShus4cmzIdms/2Cbvp+NTG2+XDT4Gp3lcNlLbHotDajx7jkcr/3v0Zcm+pf1gNdb02A+NI+mrhO2mjr9sAT+dTj8cldtCAqtn4yVwh5T+ALDvLj9Pp5NTaIdhoMvl4my3r/KGbZ3PZ1qWxbuw6ion89kpzTO3suEbC7IaRbbb98Ovv1cab2lDnsCaZVl+nOjaBlFe6qk0nj3Ho6X/PfqyZN/cdliNtZxxFKqmy52NZws4/0IwoXpWKdhStHMFiG2yLT75SsqE2B9XG/h4evYgO1jvJ39FLXLNXMWhxVHarU0hWdmQcdQlhPrfEletuEyxWcQ71M/yhJPb+XP+k9qfNfFsMR7ZXuo5UeN/bV/6fC3ZN7cd1mONjy3HEJdP8/5sU44/uV8u2QJ+u902Zz4+PojIPe2XjnJgS3N067rSPM/O3JYMXsol2TzPd6I/DAMty7IFWp+4crDI6he5Hw8YCwFf15Wu1+uWS+OT2LK23coGjwV5c1VKX8v+4v/LWbpFvGP9zPblmJEzo9PplJTTJaqLp+V4lNuXZaHr9Rr1vdb/0r6M+Vqyb247rMeaFmk50eRtevLgSjdxW1KoqkKJXR5KR2vFh4/vynHJf8cuH7Wv67pug1BfCukFBtkO/lGR/ozjiEoYig8+LZyMZbxj/ewSDbm9FzXjUZ78epLjmr23ILUvc3zt0c7WY0366JsMuK48mi9iMjIAOemTGm632zawXTnMlEueHF907kzvyyebLwcG3Pgu7y3jbVmp1JKa8ejL70vhaC3gqX2Z42uPdrYea/pHWPooNYy/V9pPxQIuBVrDq7rsrCWy5lteusv8plU6g48nbWtk+3LypsAN4h2G48OTFR0PGb9Hx6fG1x7tbDnWfIKshf3r62ubAJfc9p8s4PohUvJvmUti5Hadd7SaFXAOVua82GavdIbuZNAWxPubI1351fj6qHa2GGvrutI0TbQsy12OnOg7Z9+kjNAl0nKbD520b4Er5wTAM5OSmtxLGqnG1yO1MxVebNV5dpkaJkqraksWcLnSHMofhbbV5HpS/Ou9AEV0/8t8tIF0RBDv/1Nb2dWTGl8f2c6asea6Q1nDQk70fWOPq3IlRLKAy/IcLq/hMhgJp0x4u5x1t+4Ea/HW+Sq9kiwXcvn7oBzEO8yjJikl1Pjao509xlpokVQjq+ykDzHNzFrElHWY7Jg2oJ22EG25KOrLoctLD6vKF70SfT6f70rPdHrIZ9M1EGWbYvSoKOhVtRDCKt57oEU8ZXxC5XMWz0ap9b/GV8t2+tphOdZ4kVXa0Hokt43jGNTOHIpupWeHXY3i7ZYnmMwNuWzLhQAim7pzeSxd6cK29fPJXXWejBbr0JoC0f2g1O2z+mHsYSOXmng/mh7xlPGRN8oxfJ7M85x8I08r/2t8rdk3tR1WY01mHLRNmXom+r5ZjO3IK4GSeBcLuEugLZ79HUM3kn1ipmkyXSzlSxvuJA5+ik3dOVz3mfpL63p8AH+ee3I+0kYONfHeA63j6YsP0f154EoL9Pa/xtfadqa0w3Ks+c5v12STv+9Dp55DFAl4LD1ilcJg5G2orudZsL1QmWLIH+mv63syP6UvjXx3ovF+8upB2tPPEPH5patrSuIaa3utjVj8UvyQlMY7xb6ln759U+LZajzGzoMe/lv5WrNvajtqxpq0JdMxof154it1TB8np+/e3t/f/yR98z94lu0TcIv8W4p9TWzGzy85DT35LNQul+3UqwzffvLzmF+S3Pr21LbX2EiJX8yPmF8p8a7t55R25Prt8qfFeCSyufK18D/lmKXnT+q+OeM6d6yN40hfX19E9D1Lzz2HdMaCKF83swUcAABeHSngn5+fD7vj1eSdmAAAAPoDAQcAgIMCAQcAgIMCAQcAgIMCAQcAgAL2cCcwBBwAADKRVSePfOY6yggBAOCgvP39B/od4p9fvxAgAB7EX79/vz3ahz2DFAoAABwUCDgAABwUCDgAABwUCPhOaP0QsBb08Hnvcdm7f6141XbvDQh4Q1IHOb8Pj4iy3kj9SHr4vPe47N2/Vrxqu/cIBNyYcRzvngvMyGcY+14JR0S7fVGBi5DP/LhRoro62UfFJdX/I/abBa/a7r0BATeEX5cUeuMOvwj6mS89+X2f/D7DPb7+LMTR/QevAwTcCC3erlcpyT+h92cehR4+HzEurwD6ZR9AwA3gGZt8756cZfObN3xv39nLbbk59PD5iHF5BdAv+wECboDrXXhyhr2uK63rGhzsRzwRevh8xLi8AuiXfQABN8KXOkklVLHi25ZbyuX6fk05mO948gdNL+jm2ukRF72vhf8lPliW5vn6JnRs3ifFh979AtxAwI0JLWD6CJVl6W1sw/WW+9DLhF37SH9zy8FcPvNnWgAvl8tmL8dO67j47JX47xP8mA86/Vbit68d7K/2Sy+iy+9LH5Zlcba1d78APxBwY/iEzxXEUFkWb5Mi4bLrqm5JqYzx2S3xWQsB+yavUPYQl5g9fYyY/9qXFB+GYaDL5eK1WVNjLY+p/ZeL6LLiRsM/WqH29uoX4AYCbgDPKHjg8ozKugztdDptthhpU89q9OxOpndcteq1LMtC0zRtbWekvy2qF3Lj4qPG/5K+keKt9+PPa8eObIe8F0GjhViO4VIfrPoF+IGAG7CuK83z7Myd8iC2uGyc5/nuB2EYBlqWhS6Xy2ZTzpakEPC+t9tty/P6Zl6lrOtK1+t1y3XySdp6ppUblxb+1/YN25C2WTyv12t+UP5Djj3+v15gn6Zp+zcR3flQ8yNv1S/ADwTcCB6Irhyq/HfNZbG+fF/XdTtB9YyaRZr3k3a5KsZ6Bv4ocuKyBx9038gfCD0ZqJ2psoiG9tfb2Hei7/FbYn8P/fLsQMANud1u2+DUQk50P6MpEfGc9INv0bL0eHtmD+0o7RseL67jhW78yvErp3ImlLcusQ3aAgE3RtZ8y+oPubBzPp+7XDpKkUCucV9w3/CPuuuuXfn/VuNFVyhZCjhoDwS8Ibfbbcs5E92vzo/jiPwfIKI2C8opyAol1wInRHz/QMA7oPOaODEAk3LjV4tUhBbvaZrurtQ+Pj62xUawXyDgnZCLNwAwehGzF/rGHn01iPz1MYCAd6S3eMsfjNht1KAfe/gxl+sj4LhAwA3gG2aIyFuy5buhphVSJHw3kvQQkNoqikfTwn8up4uVCbZ8doguE9QzcFwpHgMIuAG6bNC1GKTv7GstaLKWl4ju8p1E9TdpxGwzuu1HqIjp4b9cE9F9Q/TdP/M8V93I40Pbkp/pNoP9AgE3Rp/sRPezmWmaur2GikWCxYAfytRjduV6tAB/3kKQrGntP894WbzlA7N0CWGL9Jd8/EPIPtg3EHAD+GTU9d46ZRK6nT6UUolt4+36e/I2adet/UTuhzelEvNLV96UpI1axCXVbor/NT7Iu3ddKbaaxy/E2sxjY1mWH1eP8imCJcdv2S/gnre///x5tA+75p9fv7IC5Mstxy69+SW6vsd3+rZJmyEb8iW97M/5fN5KxT4/P7Pr0lP9kljasIhLiBT/LXxw2alN1cT8cn1X2ib6FvDc2Fv2y1+/f79F3H9pIOARcgX8SIzjSF9fX0RUJuAAtAYCHgYplBcGuU4Ajg0E/ImRl8b6clU/EQ8AcDwg4E+MrECRz2Ym+vnSAIg4AMcDAv7E6OdK88KRrpDBm1EAOCYQ8CeGH6JF9PNFE0Q/X/QAADgWqEKJ8AxVKJzv1nXgR7grErw2qEIJAwGP8AwCDsBRgYCH+RdHEwkWLXE/8gAAAABJRU5ErkJggg==
+            </smpte:image>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_1">
+                iVBORw0KGgoAAAANSUhEUgAAAaAAAAAkCAIAAABAAnl0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAIBklEQVR4nO1d65GrPAz1nfkKSAu4FWglqeXWQFohrZhW7o8zaBS/kB+QhE/nx86uA5YsnT1+CHb/3G43o1AoFFfEf592QKFQKI6CCpxCobgsVOAUCsVloQL3SxiGwRizruuht5TiBBM/hJ+Lxs85XAQVuJ/BOI7TNBljlmV5vV4H3XKCVxfGz0Xj5xwuRaXAjeOIb7ygoN05J58QqCuOoh7+PyAu8sZULjK3lOIEE5fBB6ORT1MK105fjcANwzBNk7XWU/1xHB+PhzFmnmehPOEWa63X7pxblsU5d8lZpSOQi2maEK4jZoUTTCjaoWmKokbgrLWQJOdc2I74VnRLd6Gfx+OBWUU1jlAXWMWZ0Bx9FeoFzhOyYRhI9Spmj2VZaJGM/jEdoU/VOMOCoNH4WmiOvg3FApcSstSyTg5ODpwmQOCmaVK6ABqH74fm6KsgFTjUkg0TMt5I7VC39sIzWGI3jOMY5Q05kLIVeiL0TXJZx4c2hO3hj5QOnpeObh9qopon8rTmTVTctbtT2R1U46hTDlekqdHDipHWpanuSkAkcFRLNix8tH+kdnx9PB6QucbC8+v1ggkgLNeSS8YY51xYkeAlcPOeeBQxUkShnqPdUo0l31WIYRhQhHHOPZ/PqJ/c1v1+hxUUbbzL8COndSbyIfUlbh9kojqAYbhCi8iXZyLqMPXj1cRS6aBoUAs8D6+JmpNQa3fI0XuL0pRC9/T1SlOR0RAigeOJ4Y3cM6+9y1Hrsiywa60dhoGvXHBCxy+GRS86dDt95X56zIYAhd1aa0mPotfYoKCcAepcfDh8LNQJL1XzKw2r6Idu0OIiE4dMBKLe9jXRHkCTTatzjv+2cxPmnR4IO/LrBSF8ciJa7o8u5aJPXUiolYKE7fI0pXBE+rqkqdSoB5HAQS+5017+SNRI17o84YEOU0rKfaDTuujGAb55Q4DQcNGkINJAaP0IPeLX8N7orrxY0KfoEz9623wSPs7RVHDmeeZzD7kU3iKJwAkmGgMosUhx82pWQB0n4TZ1S9wouj1Prd1OMmwvSlMKjemLClOmZ3maGjkjErjX6wWT9/vdBCtzSj8C3fcBHAicMYZPs+u6zvNsNsmARnhrXQ6UaBGLYRicc9gq8lDyiNPo6MAFhiisy7JgpGQabNudjbEm5Vnk8s2Fj9QtxdF1XZ/PJzlALlVH4AQT7QGUWAQ/6TeTFl9yNfHAucEjIDwPklArg122F6Upher04UqbLgY2pqmRM2VVVJtY91L+Tnu8kBvCJGbeBYKDO4yLvYUh7Qc97V7X1TvRN9u6Bu3rui7Lgq52F0TkTChq9Cn4RLZMp+eqdiNwgoleAdy16JGe2ruM0SPe7i0Sau2iiO11KEofpQnpozk7WgxsSVM7ZwoEjozt7k9PA7mUp++uY5TIzCj4NZ45osIu4XgWMU3xkIIomKDIVhcGn5CaoiBXB7DIYkfAQywZipIioZYQQrbXofp3BJqVmSxbRt3OmQKBIyHjjZigzGFsiy5kxnGkkfdKOfWQCZZl5WPyx1uO5U95vOnXMCHzevPar4H2AH4EfDnz9+9fzEbyN6Ik1MrgCLbXITUQnsru6WvkzI7ARYPr1XSonW+tu6w7UupGR358Mjkz65n5aheOHVHTnIFGbyb8yKL4HLQE8HzgFMxthT9+AN/4LNQuvoHtuzjHqzrO7AhcWJ82QU3aM790/bME3qTB8w3Oof1+v0NeT0BGdyR6RMsBCqPX4eUFrjGAHwEO8vl5EzJo09XDdnwD278E1ZzZETi31Xf5ZjhcKPLGXsdGtPk1QS3ZGDPPM2fVyccxjcXicKWG3kLhO61ocybaA/gpQObM9hTrdPCrhN/AdgmiO62+qObMjsBR+RkzCSq19Cm2pWgnDepFXL4k9NbA3ePID1lSTxLw+kAL+DEc9ex9E/3x19ErgN8AyA1NRZmnTyTUSuGrzmFTA+le8Y8are5hv8hAD56YYE3Bl299J2T+4Dg/0eMn9HxOa/y14ZWgaZqiT9bQNdHKdNErcjxt3uKXtxcNAc4fuixqNNExgB3hMYfvGzjGcYySfxcSaqVQx/aDmJAaSHQh0t1oNWekr2rZ2IMgaO8yMGvt/X53rPRLi3PeOX3PS7c29iZZKfiTNaEhLI/pGjoZoWsQByF9vRFx+Y4KXwb87YiD9rYdTfQKYBd4KabvQy5hunVbIaj0JEFCLYmHebafwIToQGghctCJSiNnCgRu6foH4EIT3rmpe3/QmTdibMS5Lrue1+tlt2Njr2fafWMWRaBD6/I9CM1L5l3saPdqSqK6bG/s0pl3d6XoZaJXALuAS9W0vZQavdJuTyqEH/HDmRQk1Ep5WMT2o5kQpo+cmee5b3UxY9SUcEYqcKl9qHChkULqdrf9yXLPolewt+w1t2jiU53TbMzbn8+ne38HGFdykaXDF+KQ21D0cAzmpdCHlG/54dAsZ4MHFYsikEJHE10CWDGosJHrDh+mCbQMVJzeX0dP+Ry1LqFWiAq2Z9KUQnv6woVIRc+ZW1o48+d2u2U+BrBYC+Wmy7kJP6QEJIsX/q9quKhH/wlOWORKjSj0J/XHW/g18tWW51vKAZOIan44UZ8rIhBFXxONASy1KPTEbe9LRrlk3nctpjBHRkatKIRsrzPRmL5M7jqmKRyakDMigVMoFIpfhP5fVIVCcVmowCkUistCBU6hUFwWKnAKheKyUIFTKBSXhQqcQqG4LFTgFArFZfEPuuTdBr3uWzgAAAAASUVORK5CYII=
+            </smpte:image>
+        </metadata>
+        <styling>
+            <style/>
+        </styling>
+        <layout>
+            <region xml:id="region_0" tts:extent="51% 12%" tts:origin="24% 78%"/>
+            <region xml:id="region_1" tts:extent="57% 6%" tts:origin="21% 85%"/>
+            <region xml:id="region_2" tts:extent="51% 12%" tts:origin="24% 28%"/>
+            <region xml:id="region_3" tts:extent="57% 6%" tts:origin="21% 35%"/>
+        </layout>
+    </head>
+    <body>
+        <div begin="00:00:00.200" end="00:00:03.000" region="region_2" smpte:backgroundImage="#img_0"/>
+        <div begin="00:00:03.200" end="00:00:06.937" region="region_3" smpte:backgroundImage="#img_1"/>
+        <div begin="00:00:07.200" end="00:59:03.000" region="region_2" smpte:backgroundImage="#img_0"/>
+    </body>
+</tt>
diff --git a/library/core/src/test/assets/ttml/bitmap_pixel_region.xml b/library/core/src/test/assets/ttml/bitmap_pixel_region.xml
new file mode 100644
index 0000000000..c724c46626
--- /dev/null
+++ b/library/core/src/test/assets/ttml/bitmap_pixel_region.xml
@@ -0,0 +1,23 @@
+<tt xmlns="http://www.w3.org/ns/ttml" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" xmlns:tts="http://www.w3.org/ns/ttml#styling" xmlns:smpte="http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" xml:lang="eng" tts:extent="1280px 720px">
+    <head>
+        <metadata>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_0">
+                iVBORw0KGgoAAAANSUhEUgAAAXAAAABICAYAAADvR65LAAAACXBIWXMAAAsTAAALEwEAmpwYAAANIUlEQVR4nO2d/5GjSA+GNVVfALMh4EyucAIXxDiGCWFiwKngukwghA1h74/vxMia/t3qNtjvU7W1u8Ygtbp53agFvL2/v/8hAAAAh+N/j3YAAABAGRBwAAA4KBBwAAA4KC8j4MMwEBHRuq4P9qQ/vdv+yrFOBTECFhxawFNPgnEc6Xw+ExHRPM90u92a+7YXerZ9HEc6nU50Op2IiGhZFprnGSKleOXxCGwxE/BxHLd/uwYkb1+WpeqE1iLBLMuy/XEdX54wRyEW01RCbbeyMQwDnc/nzRYRBfvjWUmN517Ho9V4eDTP0o4YJgLOJ+/pdHLOKMZxpMvlQkRE0zQVn9B8HC3eknmeq2zsBSmI8zw3EUJLG1K85Y/psiyWLu+aHn3WkqP7zzxLO1IwEXB92ezbzsEsQYu3Fge2wX+etcNKaC2iwzDc9cs0TU896wFgL5gKuEug9cldIqxyhk/0c5bNNng7xOMbGYuWcZF9jPgD0IdqAY8JdGx2nkJsYWxdV1rXFcLhoXVcQiktAEA7igScqz+I6MeCotwmt7N4l5ZP+VIntZT4k7NP7Luu7fqKQsc4N3Ytbej+1p9pm67PYrYs4l3SDzlYx7PVeAwdI8f/Hn1Zsm9tP9SOtdz21WYosgVclkAR3QdIpjnkdv77crls4ltaPlU72/N1bKzkTadxUvaRsXItrLrKyfgzPQhLY9fShus4cmzIdms/2Cbvp+NTG2+XDT4Gp3lcNlLbHotDajx7jkcr/3v0Zcm+pf1gNdb02A+NI+mrhO2mjr9sAT+dTj8cldtCAqtn4yVwh5T+ALDvLj9Pp5NTaIdhoMvl4my3r/KGbZ3PZ1qWxbuw6ion89kpzTO3suEbC7IaRbbb98Ovv1cab2lDnsCaZVl+nOjaBlFe6qk0nj3Ho6X/PfqyZN/cdliNtZxxFKqmy52NZws4/0IwoXpWKdhStHMFiG2yLT75SsqE2B9XG/h4evYgO1jvJ39FLXLNXMWhxVHarU0hWdmQcdQlhPrfEletuEyxWcQ71M/yhJPb+XP+k9qfNfFsMR7ZXuo5UeN/bV/6fC3ZN7cd1mONjy3HEJdP8/5sU44/uV8u2QJ+u902Zz4+PojIPe2XjnJgS3N067rSPM/O3JYMXsol2TzPd6I/DAMty7IFWp+4crDI6he5Hw8YCwFf15Wu1+uWS+OT2LK23coGjwV5c1VKX8v+4v/LWbpFvGP9zPblmJEzo9PplJTTJaqLp+V4lNuXZaHr9Rr1vdb/0r6M+Vqyb247rMeaFmk50eRtevLgSjdxW1KoqkKJXR5KR2vFh4/vynHJf8cuH7Wv67pug1BfCukFBtkO/lGR/ozjiEoYig8+LZyMZbxj/ewSDbm9FzXjUZ78epLjmr23ILUvc3zt0c7WY0366JsMuK48mi9iMjIAOemTGm632zawXTnMlEueHF907kzvyyebLwcG3Pgu7y3jbVmp1JKa8ejL70vhaC3gqX2Z42uPdrYea/pHWPooNYy/V9pPxQIuBVrDq7rsrCWy5lteusv8plU6g48nbWtk+3LypsAN4h2G48OTFR0PGb9Hx6fG1x7tbDnWfIKshf3r62ubAJfc9p8s4PohUvJvmUti5Hadd7SaFXAOVua82GavdIbuZNAWxPubI1351fj6qHa2GGvrutI0TbQsy12OnOg7Z9+kjNAl0nKbD520b4Er5wTAM5OSmtxLGqnG1yO1MxVebNV5dpkaJkqraksWcLnSHMofhbbV5HpS/Ou9AEV0/8t8tIF0RBDv/1Nb2dWTGl8f2c6asea6Q1nDQk70fWOPq3IlRLKAy/IcLq/hMhgJp0x4u5x1t+4Ea/HW+Sq9kiwXcvn7oBzEO8yjJikl1Pjao509xlpokVQjq+ykDzHNzFrElHWY7Jg2oJ22EG25KOrLoctLD6vKF70SfT6f70rPdHrIZ9M1EGWbYvSoKOhVtRDCKt57oEU8ZXxC5XMWz0ap9b/GV8t2+tphOdZ4kVXa0Hokt43jGNTOHIpupWeHXY3i7ZYnmMwNuWzLhQAim7pzeSxd6cK29fPJXXWejBbr0JoC0f2g1O2z+mHsYSOXmng/mh7xlPGRN8oxfJ7M85x8I08r/2t8rdk3tR1WY01mHLRNmXom+r5ZjO3IK4GSeBcLuEugLZ79HUM3kn1ipmkyXSzlSxvuJA5+ik3dOVz3mfpL63p8AH+ee3I+0kYONfHeA63j6YsP0f154EoL9Pa/xtfadqa0w3Ks+c5v12STv+9Dp55DFAl4LD1ilcJg5G2orudZsL1QmWLIH+mv63syP6UvjXx3ovF+8upB2tPPEPH5patrSuIaa3utjVj8UvyQlMY7xb6ln759U+LZajzGzoMe/lv5WrNvajtqxpq0JdMxof154it1TB8np+/e3t/f/yR98z94lu0TcIv8W4p9TWzGzy85DT35LNQul+3UqwzffvLzmF+S3Pr21LbX2EiJX8yPmF8p8a7t55R25Prt8qfFeCSyufK18D/lmKXnT+q+OeM6d6yN40hfX19E9D1Lzz2HdMaCKF83swUcAABeHSngn5+fD7vj1eSdmAAAAPoDAQcAgIMCAQcAgIMCAQcAgIMCAQcAgAL2cCcwBBwAADKRVSePfOY6yggBAOCgvP39B/od4p9fvxAgAB7EX79/vz3ahz2DFAoAABwUCDgAABwUCDgAABwUCPhOaP0QsBb08Hnvcdm7f6141XbvDQh4Q1IHOb8Pj4iy3kj9SHr4vPe47N2/Vrxqu/cIBNyYcRzvngvMyGcY+14JR0S7fVGBi5DP/LhRoro62UfFJdX/I/abBa/a7r0BATeEX5cUeuMOvwj6mS89+X2f/D7DPb7+LMTR/QevAwTcCC3erlcpyT+h92cehR4+HzEurwD6ZR9AwA3gGZt8756cZfObN3xv39nLbbk59PD5iHF5BdAv+wECboDrXXhyhr2uK63rGhzsRzwRevh8xLi8AuiXfQABN8KXOkklVLHi25ZbyuX6fk05mO948gdNL+jm2ukRF72vhf8lPliW5vn6JnRs3ifFh979AtxAwI0JLWD6CJVl6W1sw/WW+9DLhF37SH9zy8FcPvNnWgAvl8tmL8dO67j47JX47xP8mA86/Vbit68d7K/2Sy+iy+9LH5Zlcba1d78APxBwY/iEzxXEUFkWb5Mi4bLrqm5JqYzx2S3xWQsB+yavUPYQl5g9fYyY/9qXFB+GYaDL5eK1WVNjLY+p/ZeL6LLiRsM/WqH29uoX4AYCbgDPKHjg8ozKugztdDptthhpU89q9OxOpndcteq1LMtC0zRtbWekvy2qF3Lj4qPG/5K+keKt9+PPa8eObIe8F0GjhViO4VIfrPoF+IGAG7CuK83z7Myd8iC2uGyc5/nuB2EYBlqWhS6Xy2ZTzpakEPC+t9tty/P6Zl6lrOtK1+t1y3XySdp6ppUblxb+1/YN25C2WTyv12t+UP5Djj3+v15gn6Zp+zcR3flQ8yNv1S/ADwTcCB6Irhyq/HfNZbG+fF/XdTtB9YyaRZr3k3a5KsZ6Bv4ocuKyBx9038gfCD0ZqJ2psoiG9tfb2Hei7/FbYn8P/fLsQMANud1u2+DUQk50P6MpEfGc9INv0bL0eHtmD+0o7RseL67jhW78yvErp3ImlLcusQ3aAgE3RtZ8y+oPubBzPp+7XDpKkUCucV9w3/CPuuuuXfn/VuNFVyhZCjhoDwS8Ibfbbcs5E92vzo/jiPwfIKI2C8opyAol1wInRHz/QMA7oPOaODEAk3LjV4tUhBbvaZrurtQ+Pj62xUawXyDgnZCLNwAwehGzF/rGHn01iPz1MYCAd6S3eMsfjNht1KAfe/gxl+sj4LhAwA3gG2aIyFuy5buhphVSJHw3kvQQkNoqikfTwn8up4uVCbZ8doguE9QzcFwpHgMIuAG6bNC1GKTv7GstaLKWl4ju8p1E9TdpxGwzuu1HqIjp4b9cE9F9Q/TdP/M8V93I40Pbkp/pNoP9AgE3Rp/sRPezmWmaur2GikWCxYAfytRjduV6tAB/3kKQrGntP894WbzlA7N0CWGL9Jd8/EPIPtg3EHAD+GTU9d46ZRK6nT6UUolt4+36e/I2adet/UTuhzelEvNLV96UpI1axCXVbor/NT7Iu3ddKbaaxy/E2sxjY1mWH1eP8imCJcdv2S/gnre///x5tA+75p9fv7IC5Mstxy69+SW6vsd3+rZJmyEb8iW97M/5fN5KxT4/P7Pr0lP9kljasIhLiBT/LXxw2alN1cT8cn1X2ib6FvDc2Fv2y1+/f79F3H9pIOARcgX8SIzjSF9fX0RUJuAAtAYCHgYplBcGuU4Ajg0E/ImRl8b6clU/EQ8AcDwg4E+MrECRz2Ym+vnSAIg4AMcDAv7E6OdK88KRrpDBm1EAOCYQ8CeGH6JF9PNFE0Q/X/QAADgWqEKJ8AxVKJzv1nXgR7grErw2qEIJAwGP8AwCDsBRgYCH+RdHEwkWLXE/8gAAAABJRU5ErkJggg==
+            </smpte:image>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_1">
+                iVBORw0KGgoAAAANSUhEUgAAAaAAAAAkCAIAAABAAnl0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAIBklEQVR4nO1d65GrPAz1nfkKSAu4FWglqeXWQFohrZhW7o8zaBS/kB+QhE/nx86uA5YsnT1+CHb/3G43o1AoFFfEf592QKFQKI6CCpxCobgsVOAUCsVloQL3SxiGwRizruuht5TiBBM/hJ+Lxs85XAQVuJ/BOI7TNBljlmV5vV4H3XKCVxfGz0Xj5xwuRaXAjeOIb7ygoN05J58QqCuOoh7+PyAu8sZULjK3lOIEE5fBB6ORT1MK105fjcANwzBNk7XWU/1xHB+PhzFmnmehPOEWa63X7pxblsU5d8lZpSOQi2maEK4jZoUTTCjaoWmKokbgrLWQJOdc2I74VnRLd6Gfx+OBWUU1jlAXWMWZ0Bx9FeoFzhOyYRhI9Spmj2VZaJGM/jEdoU/VOMOCoNH4WmiOvg3FApcSstSyTg5ODpwmQOCmaVK6ABqH74fm6KsgFTjUkg0TMt5I7VC39sIzWGI3jOMY5Q05kLIVeiL0TXJZx4c2hO3hj5QOnpeObh9qopon8rTmTVTctbtT2R1U46hTDlekqdHDipHWpanuSkAkcFRLNix8tH+kdnx9PB6QucbC8+v1ggkgLNeSS8YY51xYkeAlcPOeeBQxUkShnqPdUo0l31WIYRhQhHHOPZ/PqJ/c1v1+hxUUbbzL8COndSbyIfUlbh9kojqAYbhCi8iXZyLqMPXj1cRS6aBoUAs8D6+JmpNQa3fI0XuL0pRC9/T1SlOR0RAigeOJ4Y3cM6+9y1Hrsiywa60dhoGvXHBCxy+GRS86dDt95X56zIYAhd1aa0mPotfYoKCcAepcfDh8LNQJL1XzKw2r6Idu0OIiE4dMBKLe9jXRHkCTTatzjv+2cxPmnR4IO/LrBSF8ciJa7o8u5aJPXUiolYKE7fI0pXBE+rqkqdSoB5HAQS+5017+SNRI17o84YEOU0rKfaDTuujGAb55Q4DQcNGkINJAaP0IPeLX8N7orrxY0KfoEz9623wSPs7RVHDmeeZzD7kU3iKJwAkmGgMosUhx82pWQB0n4TZ1S9wouj1Prd1OMmwvSlMKjemLClOmZ3maGjkjErjX6wWT9/vdBCtzSj8C3fcBHAicMYZPs+u6zvNsNsmARnhrXQ6UaBGLYRicc9gq8lDyiNPo6MAFhiisy7JgpGQabNudjbEm5Vnk8s2Fj9QtxdF1XZ/PJzlALlVH4AQT7QGUWAQ/6TeTFl9yNfHAucEjIDwPklArg122F6Upher04UqbLgY2pqmRM2VVVJtY91L+Tnu8kBvCJGbeBYKDO4yLvYUh7Qc97V7X1TvRN9u6Bu3rui7Lgq52F0TkTChq9Cn4RLZMp+eqdiNwgoleAdy16JGe2ruM0SPe7i0Sau2iiO11KEofpQnpozk7WgxsSVM7ZwoEjozt7k9PA7mUp++uY5TIzCj4NZ45osIu4XgWMU3xkIIomKDIVhcGn5CaoiBXB7DIYkfAQywZipIioZYQQrbXofp3BJqVmSxbRt3OmQKBIyHjjZigzGFsiy5kxnGkkfdKOfWQCZZl5WPyx1uO5U95vOnXMCHzevPar4H2AH4EfDnz9+9fzEbyN6Ik1MrgCLbXITUQnsru6WvkzI7ARYPr1XSonW+tu6w7UupGR358Mjkz65n5aheOHVHTnIFGbyb8yKL4HLQE8HzgFMxthT9+AN/4LNQuvoHtuzjHqzrO7AhcWJ82QU3aM790/bME3qTB8w3Oof1+v0NeT0BGdyR6RMsBCqPX4eUFrjGAHwEO8vl5EzJo09XDdnwD278E1ZzZETi31Xf5ZjhcKPLGXsdGtPk1QS3ZGDPPM2fVyccxjcXicKWG3kLhO61ocybaA/gpQObM9hTrdPCrhN/AdgmiO62+qObMjsBR+RkzCSq19Cm2pWgnDepFXL4k9NbA3ePID1lSTxLw+kAL+DEc9ex9E/3x19ErgN8AyA1NRZmnTyTUSuGrzmFTA+le8Y8are5hv8hAD56YYE3Bl299J2T+4Dg/0eMn9HxOa/y14ZWgaZqiT9bQNdHKdNErcjxt3uKXtxcNAc4fuixqNNExgB3hMYfvGzjGcYySfxcSaqVQx/aDmJAaSHQh0t1oNWekr2rZ2IMgaO8yMGvt/X53rPRLi3PeOX3PS7c29iZZKfiTNaEhLI/pGjoZoWsQByF9vRFx+Y4KXwb87YiD9rYdTfQKYBd4KabvQy5hunVbIaj0JEFCLYmHebafwIToQGghctCJSiNnCgRu6foH4EIT3rmpe3/QmTdibMS5Lrue1+tlt2Njr2fafWMWRaBD6/I9CM1L5l3saPdqSqK6bG/s0pl3d6XoZaJXALuAS9W0vZQavdJuTyqEH/HDmRQk1Ep5WMT2o5kQpo+cmee5b3UxY9SUcEYqcKl9qHChkULqdrf9yXLPolewt+w1t2jiU53TbMzbn8+ne38HGFdykaXDF+KQ21D0cAzmpdCHlG/54dAsZ4MHFYsikEJHE10CWDGosJHrDh+mCbQMVJzeX0dP+Ry1LqFWiAq2Z9KUQnv6woVIRc+ZW1o48+d2u2U+BrBYC+Wmy7kJP6QEJIsX/q9quKhH/wlOWORKjSj0J/XHW/g18tWW51vKAZOIan44UZ8rIhBFXxONASy1KPTEbe9LRrlk3nctpjBHRkatKIRsrzPRmL5M7jqmKRyakDMigVMoFIpfhP5fVIVCcVmowCkUistCBU6hUFwWKnAKheKyUIFTKBSXhQqcQqG4LFTgFArFZfEPuuTdBr3uWzgAAAAASUVORK5CYII=
+            </smpte:image>
+        </metadata>
+        <styling>
+            <style/>
+        </styling>
+        <layout>
+            <region xml:id="region_0" tts:extent="653px 86px" tts:origin="307px 562px"/>
+            <region xml:id="region_1" tts:extent="730px 43px" tts:origin="269px 612px"/>
+        </layout>
+    </head>
+    <body>
+        <div begin="00:00:00.200" end="00:00:03.000" region="region_0" smpte:backgroundImage="#img_0"/>
+        <div begin="00:00:03.200" end="00:00:06.937" region="region_1" smpte:backgroundImage="#img_1"/>
+    </body>
+</tt>
diff --git a/library/core/src/test/assets/ttml/bitmap_unsupported_region.xml b/library/core/src/test/assets/ttml/bitmap_unsupported_region.xml
new file mode 100644
index 0000000000..5e72d706fc
--- /dev/null
+++ b/library/core/src/test/assets/ttml/bitmap_unsupported_region.xml
@@ -0,0 +1,23 @@
+<tt xmlns="http://www.w3.org/ns/ttml" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" xmlns:tts="http://www.w3.org/ns/ttml#styling" xmlns:smpte="http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" xml:lang="eng">
+    <head>
+        <metadata>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_0">
+                iVBORw0KGgoAAAANSUhEUgAAAXAAAABICAYAAADvR65LAAAACXBIWXMAAAsTAAALEwEAmpwYAAANIUlEQVR4nO2d/5GjSA+GNVVfALMh4EyucAIXxDiGCWFiwKngukwghA1h74/vxMia/t3qNtjvU7W1u8Ygtbp53agFvL2/v/8hAAAAh+N/j3YAAABAGRBwAAA4KBBwAAA4KC8j4MMwEBHRuq4P9qQ/vdv+yrFOBTECFhxawFNPgnEc6Xw+ExHRPM90u92a+7YXerZ9HEc6nU50Op2IiGhZFprnGSKleOXxCGwxE/BxHLd/uwYkb1+WpeqE1iLBLMuy/XEdX54wRyEW01RCbbeyMQwDnc/nzRYRBfvjWUmN517Ho9V4eDTP0o4YJgLOJ+/pdHLOKMZxpMvlQkRE0zQVn9B8HC3eknmeq2zsBSmI8zw3EUJLG1K85Y/psiyWLu+aHn3WkqP7zzxLO1IwEXB92ezbzsEsQYu3Fge2wX+etcNKaC2iwzDc9cs0TU896wFgL5gKuEug9cldIqxyhk/0c5bNNng7xOMbGYuWcZF9jPgD0IdqAY8JdGx2nkJsYWxdV1rXFcLhoXVcQiktAEA7igScqz+I6MeCotwmt7N4l5ZP+VIntZT4k7NP7Luu7fqKQsc4N3Ytbej+1p9pm67PYrYs4l3SDzlYx7PVeAwdI8f/Hn1Zsm9tP9SOtdz21WYosgVclkAR3QdIpjnkdv77crls4ltaPlU72/N1bKzkTadxUvaRsXItrLrKyfgzPQhLY9fShus4cmzIdms/2Cbvp+NTG2+XDT4Gp3lcNlLbHotDajx7jkcr/3v0Zcm+pf1gNdb02A+NI+mrhO2mjr9sAT+dTj8cldtCAqtn4yVwh5T+ALDvLj9Pp5NTaIdhoMvl4my3r/KGbZ3PZ1qWxbuw6ion89kpzTO3suEbC7IaRbbb98Ovv1cab2lDnsCaZVl+nOjaBlFe6qk0nj3Ho6X/PfqyZN/cdliNtZxxFKqmy52NZws4/0IwoXpWKdhStHMFiG2yLT75SsqE2B9XG/h4evYgO1jvJ39FLXLNXMWhxVHarU0hWdmQcdQlhPrfEletuEyxWcQ71M/yhJPb+XP+k9qfNfFsMR7ZXuo5UeN/bV/6fC3ZN7cd1mONjy3HEJdP8/5sU44/uV8u2QJ+u902Zz4+PojIPe2XjnJgS3N067rSPM/O3JYMXsol2TzPd6I/DAMty7IFWp+4crDI6he5Hw8YCwFf15Wu1+uWS+OT2LK23coGjwV5c1VKX8v+4v/LWbpFvGP9zPblmJEzo9PplJTTJaqLp+V4lNuXZaHr9Rr1vdb/0r6M+Vqyb247rMeaFmk50eRtevLgSjdxW1KoqkKJXR5KR2vFh4/vynHJf8cuH7Wv67pug1BfCukFBtkO/lGR/ozjiEoYig8+LZyMZbxj/ewSDbm9FzXjUZ78epLjmr23ILUvc3zt0c7WY0366JsMuK48mi9iMjIAOemTGm632zawXTnMlEueHF907kzvyyebLwcG3Pgu7y3jbVmp1JKa8ejL70vhaC3gqX2Z42uPdrYea/pHWPooNYy/V9pPxQIuBVrDq7rsrCWy5lteusv8plU6g48nbWtk+3LypsAN4h2G48OTFR0PGb9Hx6fG1x7tbDnWfIKshf3r62ubAJfc9p8s4PohUvJvmUti5Hadd7SaFXAOVua82GavdIbuZNAWxPubI1351fj6qHa2GGvrutI0TbQsy12OnOg7Z9+kjNAl0nKbD520b4Er5wTAM5OSmtxLGqnG1yO1MxVebNV5dpkaJkqraksWcLnSHMofhbbV5HpS/Ou9AEV0/8t8tIF0RBDv/1Nb2dWTGl8f2c6asea6Q1nDQk70fWOPq3IlRLKAy/IcLq/hMhgJp0x4u5x1t+4Ea/HW+Sq9kiwXcvn7oBzEO8yjJikl1Pjao509xlpokVQjq+ykDzHNzFrElHWY7Jg2oJ22EG25KOrLoctLD6vKF70SfT6f70rPdHrIZ9M1EGWbYvSoKOhVtRDCKt57oEU8ZXxC5XMWz0ap9b/GV8t2+tphOdZ4kVXa0Hokt43jGNTOHIpupWeHXY3i7ZYnmMwNuWzLhQAim7pzeSxd6cK29fPJXXWejBbr0JoC0f2g1O2z+mHsYSOXmng/mh7xlPGRN8oxfJ7M85x8I08r/2t8rdk3tR1WY01mHLRNmXom+r5ZjO3IK4GSeBcLuEugLZ79HUM3kn1ipmkyXSzlSxvuJA5+ik3dOVz3mfpL63p8AH+ee3I+0kYONfHeA63j6YsP0f154EoL9Pa/xtfadqa0w3Ks+c5v12STv+9Dp55DFAl4LD1ilcJg5G2orudZsL1QmWLIH+mv63syP6UvjXx3ovF+8upB2tPPEPH5patrSuIaa3utjVj8UvyQlMY7xb6ln759U+LZajzGzoMe/lv5WrNvajtqxpq0JdMxof154it1TB8np+/e3t/f/yR98z94lu0TcIv8W4p9TWzGzy85DT35LNQul+3UqwzffvLzmF+S3Pr21LbX2EiJX8yPmF8p8a7t55R25Prt8qfFeCSyufK18D/lmKXnT+q+OeM6d6yN40hfX19E9D1Lzz2HdMaCKF83swUcAABeHSngn5+fD7vj1eSdmAAAAPoDAQcAgIMCAQcAgIMCAQcAgIMCAQcAgAL2cCcwBBwAADKRVSePfOY6yggBAOCgvP39B/od4p9fvxAgAB7EX79/vz3ahz2DFAoAABwUCDgAABwUCDgAABwUCPhOaP0QsBb08Hnvcdm7f6141XbvDQh4Q1IHOb8Pj4iy3kj9SHr4vPe47N2/Vrxqu/cIBNyYcRzvngvMyGcY+14JR0S7fVGBi5DP/LhRoro62UfFJdX/I/abBa/a7r0BATeEX5cUeuMOvwj6mS89+X2f/D7DPb7+LMTR/QevAwTcCC3erlcpyT+h92cehR4+HzEurwD6ZR9AwA3gGZt8756cZfObN3xv39nLbbk59PD5iHF5BdAv+wECboDrXXhyhr2uK63rGhzsRzwRevh8xLi8AuiXfQABN8KXOkklVLHi25ZbyuX6fk05mO948gdNL+jm2ukRF72vhf8lPliW5vn6JnRs3ifFh979AtxAwI0JLWD6CJVl6W1sw/WW+9DLhF37SH9zy8FcPvNnWgAvl8tmL8dO67j47JX47xP8mA86/Vbit68d7K/2Sy+iy+9LH5Zlcba1d78APxBwY/iEzxXEUFkWb5Mi4bLrqm5JqYzx2S3xWQsB+yavUPYQl5g9fYyY/9qXFB+GYaDL5eK1WVNjLY+p/ZeL6LLiRsM/WqH29uoX4AYCbgDPKHjg8ozKugztdDptthhpU89q9OxOpndcteq1LMtC0zRtbWekvy2qF3Lj4qPG/5K+keKt9+PPa8eObIe8F0GjhViO4VIfrPoF+IGAG7CuK83z7Myd8iC2uGyc5/nuB2EYBlqWhS6Xy2ZTzpakEPC+t9tty/P6Zl6lrOtK1+t1y3XySdp6ppUblxb+1/YN25C2WTyv12t+UP5Djj3+v15gn6Zp+zcR3flQ8yNv1S/ADwTcCB6Irhyq/HfNZbG+fF/XdTtB9YyaRZr3k3a5KsZ6Bv4ocuKyBx9038gfCD0ZqJ2psoiG9tfb2Hei7/FbYn8P/fLsQMANud1u2+DUQk50P6MpEfGc9INv0bL0eHtmD+0o7RseL67jhW78yvErp3ImlLcusQ3aAgE3RtZ8y+oPubBzPp+7XDpKkUCucV9w3/CPuuuuXfn/VuNFVyhZCjhoDwS8Ibfbbcs5E92vzo/jiPwfIKI2C8opyAol1wInRHz/QMA7oPOaODEAk3LjV4tUhBbvaZrurtQ+Pj62xUawXyDgnZCLNwAwehGzF/rGHn01iPz1MYCAd6S3eMsfjNht1KAfe/gxl+sj4LhAwA3gG2aIyFuy5buhphVSJHw3kvQQkNoqikfTwn8up4uVCbZ8doguE9QzcFwpHgMIuAG6bNC1GKTv7GstaLKWl4ju8p1E9TdpxGwzuu1HqIjp4b9cE9F9Q/TdP/M8V93I40Pbkp/pNoP9AgE3Rp/sRPezmWmaur2GikWCxYAfytRjduV6tAB/3kKQrGntP894WbzlA7N0CWGL9Jd8/EPIPtg3EHAD+GTU9d46ZRK6nT6UUolt4+36e/I2adet/UTuhzelEvNLV96UpI1axCXVbor/NT7Iu3ddKbaaxy/E2sxjY1mWH1eP8imCJcdv2S/gnre///x5tA+75p9fv7IC5Mstxy69+SW6vsd3+rZJmyEb8iW97M/5fN5KxT4/P7Pr0lP9kljasIhLiBT/LXxw2alN1cT8cn1X2ib6FvDc2Fv2y1+/f79F3H9pIOARcgX8SIzjSF9fX0RUJuAAtAYCHgYplBcGuU4Ajg0E/ImRl8b6clU/EQ8AcDwg4E+MrECRz2Ym+vnSAIg4AMcDAv7E6OdK88KRrpDBm1EAOCYQ8CeGH6JF9PNFE0Q/X/QAADgWqEKJ8AxVKJzv1nXgR7grErw2qEIJAwGP8AwCDsBRgYCH+RdHEwkWLXE/8gAAAABJRU5ErkJggg==
+            </smpte:image>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_1">
+                iVBORw0KGgoAAAANSUhEUgAAAaAAAAAkCAIAAABAAnl0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAIBklEQVR4nO1d65GrPAz1nfkKSAu4FWglqeXWQFohrZhW7o8zaBS/kB+QhE/nx86uA5YsnT1+CHb/3G43o1AoFFfEf592QKFQKI6CCpxCobgsVOAUCsVloQL3SxiGwRizruuht5TiBBM/hJ+Lxs85XAQVuJ/BOI7TNBljlmV5vV4H3XKCVxfGz0Xj5xwuRaXAjeOIb7ygoN05J58QqCuOoh7+PyAu8sZULjK3lOIEE5fBB6ORT1MK105fjcANwzBNk7XWU/1xHB+PhzFmnmehPOEWa63X7pxblsU5d8lZpSOQi2maEK4jZoUTTCjaoWmKokbgrLWQJOdc2I74VnRLd6Gfx+OBWUU1jlAXWMWZ0Bx9FeoFzhOyYRhI9Spmj2VZaJGM/jEdoU/VOMOCoNH4WmiOvg3FApcSstSyTg5ODpwmQOCmaVK6ABqH74fm6KsgFTjUkg0TMt5I7VC39sIzWGI3jOMY5Q05kLIVeiL0TXJZx4c2hO3hj5QOnpeObh9qopon8rTmTVTctbtT2R1U46hTDlekqdHDipHWpanuSkAkcFRLNix8tH+kdnx9PB6QucbC8+v1ggkgLNeSS8YY51xYkeAlcPOeeBQxUkShnqPdUo0l31WIYRhQhHHOPZ/PqJ/c1v1+hxUUbbzL8COndSbyIfUlbh9kojqAYbhCi8iXZyLqMPXj1cRS6aBoUAs8D6+JmpNQa3fI0XuL0pRC9/T1SlOR0RAigeOJ4Y3cM6+9y1Hrsiywa60dhoGvXHBCxy+GRS86dDt95X56zIYAhd1aa0mPotfYoKCcAepcfDh8LNQJL1XzKw2r6Idu0OIiE4dMBKLe9jXRHkCTTatzjv+2cxPmnR4IO/LrBSF8ciJa7o8u5aJPXUiolYKE7fI0pXBE+rqkqdSoB5HAQS+5017+SNRI17o84YEOU0rKfaDTuujGAb55Q4DQcNGkINJAaP0IPeLX8N7orrxY0KfoEz9623wSPs7RVHDmeeZzD7kU3iKJwAkmGgMosUhx82pWQB0n4TZ1S9wouj1Prd1OMmwvSlMKjemLClOmZ3maGjkjErjX6wWT9/vdBCtzSj8C3fcBHAicMYZPs+u6zvNsNsmARnhrXQ6UaBGLYRicc9gq8lDyiNPo6MAFhiisy7JgpGQabNudjbEm5Vnk8s2Fj9QtxdF1XZ/PJzlALlVH4AQT7QGUWAQ/6TeTFl9yNfHAucEjIDwPklArg122F6Upher04UqbLgY2pqmRM2VVVJtY91L+Tnu8kBvCJGbeBYKDO4yLvYUh7Qc97V7X1TvRN9u6Bu3rui7Lgq52F0TkTChq9Cn4RLZMp+eqdiNwgoleAdy16JGe2ruM0SPe7i0Sau2iiO11KEofpQnpozk7WgxsSVM7ZwoEjozt7k9PA7mUp++uY5TIzCj4NZ45osIu4XgWMU3xkIIomKDIVhcGn5CaoiBXB7DIYkfAQywZipIioZYQQrbXofp3BJqVmSxbRt3OmQKBIyHjjZigzGFsiy5kxnGkkfdKOfWQCZZl5WPyx1uO5U95vOnXMCHzevPar4H2AH4EfDnz9+9fzEbyN6Ik1MrgCLbXITUQnsru6WvkzI7ARYPr1XSonW+tu6w7UupGR358Mjkz65n5aheOHVHTnIFGbyb8yKL4HLQE8HzgFMxthT9+AN/4LNQuvoHtuzjHqzrO7AhcWJ82QU3aM790/bME3qTB8w3Oof1+v0NeT0BGdyR6RMsBCqPX4eUFrjGAHwEO8vl5EzJo09XDdnwD278E1ZzZETi31Xf5ZjhcKPLGXsdGtPk1QS3ZGDPPM2fVyccxjcXicKWG3kLhO61ocybaA/gpQObM9hTrdPCrhN/AdgmiO62+qObMjsBR+RkzCSq19Cm2pWgnDepFXL4k9NbA3ePID1lSTxLw+kAL+DEc9ex9E/3x19ErgN8AyA1NRZmnTyTUSuGrzmFTA+le8Y8are5hv8hAD56YYE3Bl299J2T+4Dg/0eMn9HxOa/y14ZWgaZqiT9bQNdHKdNErcjxt3uKXtxcNAc4fuixqNNExgB3hMYfvGzjGcYySfxcSaqVQx/aDmJAaSHQh0t1oNWekr2rZ2IMgaO8yMGvt/X53rPRLi3PeOX3PS7c29iZZKfiTNaEhLI/pGjoZoWsQByF9vRFx+Y4KXwb87YiD9rYdTfQKYBd4KabvQy5hunVbIaj0JEFCLYmHebafwIToQGghctCJSiNnCgRu6foH4EIT3rmpe3/QmTdibMS5Lrue1+tlt2Njr2fafWMWRaBD6/I9CM1L5l3saPdqSqK6bG/s0pl3d6XoZaJXALuAS9W0vZQavdJuTyqEH/HDmRQk1Ep5WMT2o5kQpo+cmee5b3UxY9SUcEYqcKl9qHChkULqdrf9yXLPolewt+w1t2jiU53TbMzbn8+ne38HGFdykaXDF+KQ21D0cAzmpdCHlG/54dAsZ4MHFYsikEJHE10CWDGosJHrDh+mCbQMVJzeX0dP+Ry1LqFWiAq2Z9KUQnv6woVIRc+ZW1o48+d2u2U+BrBYC+Wmy7kJP6QEJIsX/q9quKhH/wlOWORKjSj0J/XHW/g18tWW51vKAZOIan44UZ8rIhBFXxONASy1KPTEbe9LRrlk3nctpjBHRkatKIRsrzPRmL5M7jqmKRyakDMigVMoFIpfhP5fVIVCcVmowCkUistCBU6hUFwWKnAKheKyUIFTKBSXhQqcQqG4LFTgFArFZfEPuuTdBr3uWzgAAAAASUVORK5CYII=
+            </smpte:image>
+        </metadata>
+        <styling>
+            <style/>
+        </styling>
+        <layout>
+            <region xml:id="region_0" tts:extent="653px 86px" tts:origin="307px 562px"/>
+            <region xml:id="region_1" tts:extent="730px 43px" tts:origin="269px 612px"/>
+        </layout>
+    </head>
+    <body>
+        <div begin="00:00:00.200" end="00:00:03.000" region="region_0" smpte:backgroundImage="#img_0"/>
+        <div begin="00:00:03.200" end="00:00:06.937" region="region_1" smpte:backgroundImage="#img_1"/>
+    </body>
+</tt>
diff --git a/library/core/src/test/assets/webvtt/with_bom b/library/core/src/test/assets/webvtt/with_bom
new file mode 100644
index 0000000000..b7110ec015
--- /dev/null
+++ b/library/core/src/test/assets/webvtt/with_bom
@@ -0,0 +1,7 @@
+WEBVTT # This comment is allowed
+
+00:00.000 --> 00:01.234
+This is the first subtitle.
+
+00:02.345 --> 00:03.456
+This is the second subtitle.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java b/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
index b066cc263a..93ec5e0264 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
@@ -48,15 +48,15 @@ public void testShouldContinueLoading_untilMaxBufferExceeded() {
     createDefaultLoadControl();
     assertThat(loadControl.shouldContinueLoading(/* bufferedDurationUs= */ 0, SPEED)).isTrue();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isTrue();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isTrue();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US - 1, SPEED)).isTrue();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
   }
 
   @Test
   public void testShouldNotContinueLoadingOnceBufferingStopped_untilBelowMinBuffer() {
     createDefaultLoadControl();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US - 1, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US - 1, SPEED)).isTrue();
   }
@@ -69,7 +69,7 @@ public void testShouldContinueLoadingWithTargetBufferBytesReached_untilMinBuffer
     assertThat(loadControl.shouldContinueLoading(/* bufferedDurationUs= */ 0, SPEED)).isTrue();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US - 1, SPEED)).isTrue();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isFalse();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
   }
 
   @Test
@@ -82,7 +82,7 @@ public void testShouldNeverContinueLoading_ifMaxBufferReachedAndNotPrioritizeTim
 
     assertThat(loadControl.shouldContinueLoading(/* bufferedDurationUs= */ 0, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isFalse();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
   }
 
   @Test
@@ -100,7 +100,7 @@ public void testShouldContinueLoadingWithMinBufferReached_inFastPlayback() {
   public void testShouldNotContinueLoadingWithMaxBufferReached_inFastPlayback() {
     createDefaultLoadControl();
 
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, /* playbackSpeed= */ 100f))
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, /* playbackSpeed= */ 100f))
         .isFalse();
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index c05f8914f5..d131ed0f51 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -18,10 +18,13 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import android.content.Context;
+import android.support.annotation.Nullable;
 import android.view.Surface;
-import com.google.android.exoplayer2.Player.DefaultEventListener;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.Player.EventListener;
 import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.source.ClippingMediaSource;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
@@ -32,6 +35,7 @@
 import com.google.android.exoplayer2.testutil.ActionSchedule;
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerRunnable;
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerTarget;
+import com.google.android.exoplayer2.testutil.AutoAdvancingFakeClock;
 import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner;
 import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder;
 import com.google.android.exoplayer2.testutil.FakeMediaClockRenderer;
@@ -44,17 +48,25 @@
 import com.google.android.exoplayer2.testutil.FakeTrackSelection;
 import com.google.android.exoplayer2.testutil.FakeTrackSelector;
 import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Clock;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Unit test for {@link ExoPlayer}. */
@@ -69,6 +81,13 @@
    */
   private static final int TIMEOUT_MS = 10000;
 
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = RuntimeEnvironment.application;
+  }
+
   /**
    * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
    * error.
@@ -81,7 +100,7 @@ public void testPlayEmptyTimeline() throws Exception {
         new Builder()
             .setTimeline(timeline)
             .setRenderers(renderer)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertNoPositionDiscontinuities();
@@ -102,7 +121,7 @@ public void testPlaySinglePeriodTimeline() throws Exception {
             .setTimeline(timeline)
             .setManifest(manifest)
             .setRenderers(renderer)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertNoPositionDiscontinuities();
@@ -124,7 +143,7 @@ public void testPlayMultiPeriodTimeline() throws Exception {
         new Builder()
             .setTimeline(timeline)
             .setRenderers(renderer)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPositionDiscontinuityReasonsEqual(
@@ -148,7 +167,7 @@ public void testPlayShortDurationPeriods() throws Exception {
         new Builder()
             .setTimeline(timeline)
             .setRenderers(renderer)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     Integer[] expectedReasons = new Integer[99];
@@ -168,10 +187,28 @@ public void testPlayShortDurationPeriods() throws Exception {
   @Test
   public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
     // Use sufficiently short periods to ensure the player attempts to read all at once.
-    TimelineWindowDefinition windowDefinition =
+    TimelineWindowDefinition windowDefinition0 =
         new TimelineWindowDefinition(
-            /* isSeekable= */ false, /* isDynamic= */ false, /* durationUs= */ 100_000);
-    Timeline timeline = new FakeTimeline(windowDefinition, windowDefinition, windowDefinition);
+            /* periodCount= */ 1,
+            /* id= */ 0,
+            /* isSeekable= */ false,
+            /* isDynamic= */ false,
+            /* durationUs= */ 100_000);
+    TimelineWindowDefinition windowDefinition1 =
+        new TimelineWindowDefinition(
+            /* periodCount= */ 1,
+            /* id= */ 1,
+            /* isSeekable= */ false,
+            /* isDynamic= */ false,
+            /* durationUs= */ 100_000);
+    TimelineWindowDefinition windowDefinition2 =
+        new TimelineWindowDefinition(
+            /* periodCount= */ 1,
+            /* id= */ 2,
+            /* isSeekable= */ false,
+            /* isDynamic= */ false,
+            /* durationUs= */ 100_000);
+    Timeline timeline = new FakeTimeline(windowDefinition0, windowDefinition1, windowDefinition2);
     final FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
     FakeMediaClockRenderer audioRenderer =
         new FakeMediaClockRenderer(Builder.AUDIO_FORMAT) {
@@ -205,7 +242,7 @@ public boolean isEnded() {
             .setTimeline(timeline)
             .setRenderers(videoRenderer, audioRenderer)
             .setSupportedFormats(Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPositionDiscontinuityReasonsEqual(
@@ -230,8 +267,10 @@ public void testRepreparationGivesFreshSourceInfo() throws Exception {
         new FakeMediaSource(timeline, new Object(), Builder.VIDEO_FORMAT) {
           @Override
           public synchronized void prepareSourceInternal(
-              ExoPlayer player, boolean isTopLevelSource) {
-            super.prepareSourceInternal(player, isTopLevelSource);
+              ExoPlayer player,
+              boolean isTopLevelSource,
+              @Nullable TransferListener mediaTransferListener) {
+            super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
             // We've queued a source info refresh on the playback thread's event queue. Allow the
             // test thread to prepare the player with the third source, and block this thread (the
             // playback thread) until the test thread's call to prepare() has returned.
@@ -256,31 +295,22 @@ public synchronized void prepareSourceInternal(
             .waitForTimelineChanged(timeline)
             .prepareSource(secondSource)
             .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    try {
-                      queuedSourceInfoCountDownLatch.await();
-                    } catch (InterruptedException e) {
-                      // Ignore.
-                    }
+                () -> {
+                  try {
+                    queuedSourceInfoCountDownLatch.await();
+                  } catch (InterruptedException e) {
+                    // Ignore.
                   }
                 })
             .prepareSource(thirdSource)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    completePreparationCountDownLatch.countDown();
-                  }
-                })
+            .executeRunnable(completePreparationCountDownLatch::countDown)
             .build();
     ExoPlayerTestRunner testRunner =
         new Builder()
             .setMediaSource(firstSource)
             .setRenderers(renderer)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertNoPositionDiscontinuities();
@@ -325,7 +355,7 @@ public void testRepeatModeChanges() throws Exception {
             .setTimeline(timeline)
             .setRenderers(renderer)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPlayedPeriodIndices(0, 1, 1, 2, 2, 0, 0, 0, 1, 2);
@@ -372,7 +402,7 @@ public void testShuffleModeEnabledChanges() throws Exception {
             .setMediaSource(mediaSource)
             .setRenderers(renderer)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPlayedPeriodIndices(0, 1, 0, 2, 1, 2);
@@ -415,13 +445,7 @@ public void testAdGroupWithLoadErrorIsSkipped() throws Exception {
         new ActionSchedule.Builder("testAdGroupWithLoadErrorIsSkipped")
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    fakeMediaSource.setNewSourceInfo(adErrorTimeline, null);
-                  }
-                })
+            .executeRunnable(() -> fakeMediaSource.setNewSourceInfo(adErrorTimeline, null))
             .waitForTimelineChanged(adErrorTimeline)
             .play()
             .build();
@@ -429,7 +453,7 @@ public void run() {
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(fakeMediaSource)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     // There is still one discontinuity from content to content for the failed ad insertion.
@@ -450,7 +474,7 @@ public void testPeriodHoldersReleasedAfterSeekWithRepeatModeAll() throws Excepti
     new Builder()
         .setRenderers(renderer)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(renderer.isEnded).isTrue();
@@ -483,7 +507,7 @@ public void testSeekProcessedCallback() throws Exception {
             .build();
     final List<Integer> playbackStatesWhenSeekProcessed = new ArrayList<>();
     EventListener eventListener =
-        new DefaultEventListener() {
+        new EventListener() {
           private int currentPlaybackState = Player.STATE_IDLE;
 
           @Override
@@ -501,7 +525,7 @@ public void onSeekProcessed() {
             .setTimeline(timeline)
             .setEventListener(eventListener)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPositionDiscontinuityReasonsEqual(
@@ -535,19 +559,20 @@ public void testSeekProcessedCalledWithIllegalSeekPosition() throws Exception {
             .build();
     final boolean[] onSeekProcessedCalled = new boolean[1];
     EventListener listener =
-        new DefaultEventListener() {
+        new EventListener() {
           @Override
           public void onSeekProcessed() {
             onSeekProcessedCalled[0] = true;
           }
         };
     ExoPlayerTestRunner testRunner =
-        new Builder().setActionSchedule(actionSchedule).setEventListener(listener).build();
+        new Builder().setActionSchedule(actionSchedule).setEventListener(listener).build(context);
     try {
       testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
       fail();
     } catch (ExoPlaybackException e) {
       // Expected exception.
+      assertThat(e.getUnexpectedException()).isInstanceOf(IllegalSeekPositionException.class);
     }
     assertThat(onSeekProcessedCalled[0]).isTrue();
   }
@@ -561,7 +586,7 @@ public void testSeekDiscontinuity() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
@@ -577,7 +602,8 @@ protected FakeMediaPeriod createFakeMediaPeriod(
               MediaPeriodId id,
               TrackGroupArray trackGroupArray,
               Allocator allocator,
-              EventDispatcher eventDispatcher) {
+              EventDispatcher eventDispatcher,
+              @Nullable TransferListener transferListener) {
             FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray, eventDispatcher);
             mediaPeriod.setSeekToUsOffset(10);
             return mediaPeriod;
@@ -594,7 +620,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPositionDiscontinuityReasonsEqual(
@@ -611,7 +637,8 @@ protected FakeMediaPeriod createFakeMediaPeriod(
               MediaPeriodId id,
               TrackGroupArray trackGroupArray,
               Allocator allocator,
-              EventDispatcher eventDispatcher) {
+              EventDispatcher eventDispatcher,
+              @Nullable TransferListener transferListener) {
             FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray, eventDispatcher);
             mediaPeriod.setDiscontinuityPositionUs(10);
             return mediaPeriod;
@@ -620,7 +647,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_INTERNAL);
@@ -636,7 +663,8 @@ protected FakeMediaPeriod createFakeMediaPeriod(
               MediaPeriodId id,
               TrackGroupArray trackGroupArray,
               Allocator allocator,
-              EventDispatcher eventDispatcher) {
+              EventDispatcher eventDispatcher,
+              @Nullable TransferListener transferListener) {
             FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray, eventDispatcher);
             mediaPeriod.setDiscontinuityPositionUs(0);
             return mediaPeriod;
@@ -645,7 +673,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     // If the position is unchanged we do not expect the discontinuity to be reported externally.
@@ -665,7 +693,7 @@ public void testAllActivatedTrackSelectionAreReleasedForSinglePeriod() throws Ex
         .setMediaSource(mediaSource)
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
 
@@ -694,7 +722,7 @@ public void testAllActivatedTrackSelectionAreReleasedForMultiPeriods() throws Ex
         .setMediaSource(mediaSource)
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
 
@@ -732,7 +760,7 @@ public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreRemad
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
         .setActionSchedule(disableTrackAction)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
 
@@ -771,7 +799,7 @@ public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreReuse
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
         .setActionSchedule(disableTrackAction)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
 
@@ -798,13 +826,7 @@ public void testDynamicTimelineChangeReason() throws Exception {
         new ActionSchedule.Builder("testDynamicTimelineChangeReason")
             .pause()
             .waitForTimelineChanged(timeline1)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    mediaSource.setNewSourceInfo(timeline2, null);
-                  }
-                })
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline2, null))
             .waitForTimelineChanged(timeline2)
             .play()
             .build();
@@ -812,7 +834,7 @@ public void run() {
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertTimelinesEqual(timeline1, timeline2);
@@ -853,7 +875,7 @@ public void testRepreparationWithPositionResetAndShufflingUsesFirstPeriod() thro
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(firstMediaSource)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPlayedPeriodIndices(0, 1, 0);
@@ -872,7 +894,8 @@ protected FakeMediaPeriod createFakeMediaPeriod(
               MediaPeriodId id,
               TrackGroupArray trackGroupArray,
               Allocator allocator,
-              EventDispatcher eventDispatcher) {
+              EventDispatcher eventDispatcher,
+              @Nullable TransferListener transferListener) {
             // Defer completing preparation of the period until playback parameters have been set.
             fakeMediaPeriodHolder[0] =
                 new FakeMediaPeriod(trackGroupArray, eventDispatcher, /* deferOnPrepared= */ true);
@@ -885,31 +908,22 @@ protected FakeMediaPeriod createFakeMediaPeriod(
             .waitForPlaybackState(Player.STATE_BUFFERING)
             // Block until createPeriod has been called on the fake media source.
             .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    try {
-                      createPeriodCalledCountDownLatch.await();
-                    } catch (InterruptedException e) {
-                      throw new IllegalStateException(e);
-                    }
+                () -> {
+                  try {
+                    createPeriodCalledCountDownLatch.await();
+                  } catch (InterruptedException e) {
+                    throw new IllegalStateException(e);
                   }
                 })
             // Set playback parameters (while the fake media period is not yet prepared).
             .setPlaybackParameters(new PlaybackParameters(/* speed= */ 2f, /* pitch= */ 2f))
             // Complete preparation of the fake media period.
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    fakeMediaPeriodHolder[0].setPreparationComplete();
-                  }
-                })
+            .executeRunnable(() -> fakeMediaPeriodHolder[0].setPreparationComplete())
             .build();
     new ExoPlayerTestRunner.Builder()
         .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
   }
@@ -936,7 +950,7 @@ public void run(SimpleExoPlayer player) {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
@@ -968,7 +982,7 @@ public void run(SimpleExoPlayer player) {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
@@ -1000,7 +1014,7 @@ public void run(SimpleExoPlayer player) {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
@@ -1025,7 +1039,7 @@ public void testStopWithoutResetReleasesMediaSource() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS);
     mediaSource.assertReleased();
@@ -1046,7 +1060,7 @@ public void testStopWithResetReleasesMediaSource() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS);
     mediaSource.assertReleased();
@@ -1069,7 +1083,7 @@ public void testRepreparationDoesNotResetAfterStopWithReset() throws Exception {
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
             .setExpectedPlayerEndedCount(2)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, timeline);
@@ -1099,7 +1113,7 @@ public void testSeekBeforeRepreparationPossibleAfterStopWithReset() throws Excep
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
             .setExpectedPlayerEndedCount(2)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, secondTimeline);
@@ -1125,7 +1139,7 @@ public void testStopDuringPreparationOverwritesPreparation() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
@@ -1151,7 +1165,7 @@ public void testStopAndSeekAfterStopDoesNotResetTimeline() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
@@ -1178,7 +1192,7 @@ public void testReprepareAfterPlaybackError() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build();
+            .build(context);
     try {
       testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
       fail();
@@ -1227,7 +1241,7 @@ public void run(SimpleExoPlayer player) {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build();
+            .build(context);
     try {
       testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
       fail();
@@ -1254,30 +1268,104 @@ public void testPlaybackErrorDuringSourceInfoRefreshStillUpdatesTimeline() throw
             // is still being prepared. The error will be thrown while the player handles the new
             // source info.
             .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null);
-                  }
-                })
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
             .waitForPlaybackState(Player.STATE_IDLE)
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
-            .build();
+            .build(context);
     try {
       testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
       fail();
     } catch (ExoPlaybackException e) {
       // Expected exception.
+      assertThat(e.getUnexpectedException()).isInstanceOf(IllegalSeekPositionException.class);
     }
     testRunner.assertTimelinesEqual(timeline);
     testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
   }
 
+  @Test
+  public void testPlaybackErrorDuringSourceInfoRefreshWithShuffleModeEnabledUsesCorrectFirstPeriod()
+      throws Exception {
+    FakeMediaSource mediaSource =
+        new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1), /* manifest= */ null);
+    ConcatenatingMediaSource concatenatingMediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false, new FakeShuffleOrder(0), mediaSource, mediaSource);
+    AtomicInteger windowIndexAfterError = new AtomicInteger();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testPlaybackErrorDuringSourceInfoRefreshUsesCorrectFirstPeriod")
+            .setShuffleModeEnabled(true)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Cause an internal exception by seeking to an invalid position while the media source
+            // is still being prepared. The error will be thrown while the player handles the new
+            // source info.
+            .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    windowIndexAfterError.set(player.getCurrentWindowIndex());
+                  }
+                })
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(concatenatingMediaSource)
+            .setActionSchedule(actionSchedule)
+            .build(context);
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+      assertThat(e.getUnexpectedException()).isInstanceOf(IllegalSeekPositionException.class);
+    }
+    assertThat(windowIndexAfterError.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void testRestartAfterEmptyTimelineWithShuffleModeEnabledUsesCorrectFirstPeriod()
+      throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    FakeMediaSource mediaSource = new FakeMediaSource(timeline, /* manifest= */ null);
+    ConcatenatingMediaSource concatenatingMediaSource =
+        new ConcatenatingMediaSource(/* isAtomic= */ false, new FakeShuffleOrder(0));
+    AtomicInteger windowIndexAfterAddingSources = new AtomicInteger();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testRestartAfterEmptyTimelineUsesCorrectFirstPeriod")
+            .setShuffleModeEnabled(true)
+            // Preparing with an empty media source will transition to ended state.
+            .waitForPlaybackState(Player.STATE_ENDED)
+            // Add two sources at once such that the default start position in the shuffled order
+            // will be the second source.
+            .executeRunnable(
+                () ->
+                    concatenatingMediaSource.addMediaSources(
+                        Arrays.asList(mediaSource, mediaSource)))
+            .waitForTimelineChanged()
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    windowIndexAfterAddingSources.set(player.getCurrentWindowIndex());
+                  }
+                })
+            .build();
+    new ExoPlayerTestRunner.Builder()
+        .setMediaSource(concatenatingMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilActionScheduleFinished(TIMEOUT_MS)
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(windowIndexAfterAddingSources.get()).isEqualTo(1);
+  }
+
   @Test
   public void testPlaybackErrorAndReprepareDoesNotResetPosition() throws Exception {
     final Timeline timeline = new FakeTimeline(/* windowCount= */ 2);
@@ -1329,7 +1417,7 @@ public void run(SimpleExoPlayer player) {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build();
+            .build(context);
     try {
       testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
       fail();
@@ -1364,7 +1452,7 @@ public void testPlaybackErrorTwiceStillKeepsTimeline() throws Exception {
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
-            .build();
+            .build(context);
     try {
       testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
       fail();
@@ -1390,10 +1478,10 @@ public void testSendMessagesDuringPreparation() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1410,10 +1498,10 @@ public void testSendMessagesAfterPreparation() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1432,11 +1520,11 @@ public void testMultipleSendMessages() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target50.positionMs >= 50).isTrue();
-    assertThat(target80.positionMs >= 80).isTrue();
+    assertThat(target50.positionMs).isAtLeast(50L);
+    assertThat(target80.positionMs).isAtLeast(80L);
     assertThat(target80.positionMs).isAtLeast(target50.positionMs);
   }
 
@@ -1456,11 +1544,11 @@ public void testMultipleSendMessagesAtSameTime() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target1.positionMs >= 50).isTrue();
-    assertThat(target2.positionMs >= 50).isTrue();
+    assertThat(target1.positionMs).isAtLeast(50L);
+    assertThat(target2.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1478,10 +1566,10 @@ public void testSendMessagesMultiPeriodResolution() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1515,7 +1603,7 @@ public void testSendMessagesAtStartAndEndOfPeriod() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilActionScheduleFinished(TIMEOUT_MS)
         .blockUntilEnded(TIMEOUT_MS);
@@ -1542,10 +1630,10 @@ public void testSendMessagesSeekOnDeliveryTimeDuringPreparation() throws Excepti
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1562,10 +1650,10 @@ public void testSendMessagesSeekOnDeliveryTimeAfterPreparation() throws Exceptio
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1583,7 +1671,7 @@ public void testSendMessagesSeekAfterDeliveryTimeDuringPreparation() throws Exce
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target.positionMs).isEqualTo(C.POSITION_UNSET);
@@ -1604,7 +1692,7 @@ public void testSendMessagesSeekAfterDeliveryTimeAfterPreparation() throws Excep
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target.positionMs).isEqualTo(C.POSITION_UNSET);
@@ -1627,11 +1715,11 @@ public void testSendMessagesRepeatDoesNotRepost() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target.messageCount).isEqualTo(1);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1656,11 +1744,11 @@ public void testSendMessagesRepeatWithoutDeletingDoesRepost() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target.messageCount).isEqualTo(2);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1678,23 +1766,17 @@ public void testSendMessagesMoveCurrentWindowIndex() throws Exception {
             .pause()
             .waitForTimelineChanged(timeline)
             .sendMessage(target, /* positionMs= */ 50)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    mediaSource.setNewSourceInfo(secondTimeline, null);
-                  }
-                })
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(secondTimeline, null))
             .waitForTimelineChanged(secondTimeline)
             .play()
             .build();
     new Builder()
         .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
     assertThat(target.windowIndex).isEqualTo(1);
   }
 
@@ -1712,11 +1794,11 @@ public void testSendMessagesMultiWindowDuringPreparation() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target.windowIndex).isEqualTo(2);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1733,11 +1815,11 @@ public void testSendMessagesMultiWindowAfterPreparation() throws Exception {
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target.windowIndex).isEqualTo(2);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
   }
 
   @Test
@@ -1757,13 +1839,7 @@ public void testSendMessagesMoveWindowIndex() throws Exception {
             .pause()
             .waitForTimelineChanged(timeline)
             .sendMessage(target, /* windowIndex = */ 1, /* positionMs= */ 50)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    mediaSource.setNewSourceInfo(secondTimeline, null);
-                  }
-                })
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(secondTimeline, null))
             .waitForTimelineChanged(secondTimeline)
             .seek(/* windowIndex= */ 0, /* positionMs= */ 0)
             .play()
@@ -1771,10 +1847,10 @@ public void run() {
     new Builder()
         .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
-    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.positionMs).isAtLeast(50L);
     assertThat(target.windowIndex).isEqualTo(0);
   }
 
@@ -1805,7 +1881,7 @@ public void testSendMessagesNonLinearPeriodOrder() throws Exception {
     new ExoPlayerTestRunner.Builder()
         .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(target1.windowIndex).isEqualTo(0);
@@ -1832,19 +1908,13 @@ public void run(SimpleExoPlayer player) {
                 })
             // Play a bit to ensure message arrived in internal player.
             .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 30)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    message.get().cancel();
-                  }
-                })
+            .executeRunnable(() -> message.get().cancel())
             .play()
             .build();
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(message.get().isCanceled()).isTrue();
@@ -1876,19 +1946,13 @@ public void run(SimpleExoPlayer player) {
             .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 51)
             // Seek back, cancel the message, and play past the same position again.
             .seek(/* positionMs= */ 0)
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    message.get().cancel();
-                  }
-                })
+            .executeRunnable(() -> message.get().cancel())
             .play()
             .build();
     new Builder()
         .setTimeline(timeline)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
     assertThat(message.get().isCanceled()).isTrue();
@@ -1901,7 +1965,7 @@ public void testSetAndSwitchSurface() throws Exception {
     Renderer videoRenderer =
         new FakeRenderer(Builder.VIDEO_FORMAT) {
           @Override
-          public void handleMessage(int what, Object object) throws ExoPlaybackException {
+          public void handleMessage(int what, @Nullable Object object) throws ExoPlaybackException {
             super.handleMessage(what, object);
             rendererMessages.add(what);
           }
@@ -1911,7 +1975,7 @@ public void handleMessage(int what, Object object) throws ExoPlaybackException {
     new ExoPlayerTestRunner.Builder()
         .setRenderers(videoRenderer)
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilActionScheduleFinished(TIMEOUT_MS)
         .blockUntilEnded(TIMEOUT_MS);
@@ -1927,7 +1991,7 @@ public void testSwitchSurfaceOnEndedState() throws Exception {
     new ExoPlayerTestRunner.Builder()
         .setTimeline(Timeline.EMPTY)
         .setActionSchedule(waitForEndedAndSwitchSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilActionScheduleFinished(TIMEOUT_MS)
         .blockUntilEnded(TIMEOUT_MS);
@@ -1953,13 +2017,7 @@ public void testTimelineUpdateDropsPrebufferedPeriods() throws Exception {
             .playUntilPosition(
                 /* windowIndex= */ 0,
                 /* positionMs= */ C.usToMs(TimelineWindowDefinition.DEFAULT_WINDOW_DURATION_US))
-            .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    mediaSource.setNewSourceInfo(timeline2, /* newManifest= */ null);
-                  }
-                })
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline2, /* newManifest= */ null))
             .waitForTimelineChanged(timeline2)
             .play()
             .build();
@@ -1967,19 +2025,64 @@ public void run() {
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
-            .build()
+            .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPlayedPeriodIndices(0, 1);
     // Assert that the second period was re-created from the new timeline.
     assertThat(mediaSource.getCreatedMediaPeriods())
         .containsExactly(
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0),
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1),
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 2))
+            new MediaPeriodId(
+                timeline1.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0),
+            new MediaPeriodId(
+                timeline1.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 1),
+            new MediaPeriodId(
+                timeline2.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 2))
         .inOrder();
   }
 
+  @Test
+  public void testRepeatedSeeksToUnpreparedPeriodInSameWindowKeepsWindowSequenceNumber()
+      throws Exception {
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount= */ 2,
+                /* id= */ 0,
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 10 * C.MICROS_PER_SECOND));
+    FakeMediaSource mediaSource = new FakeMediaSource(timeline, /* manifest= */ null);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSeekToUnpreparedPeriod")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .seek(/* windowIndex= */ 0, /* positionMs= */ 9999)
+            .seek(/* windowIndex= */ 0, /* positionMs= */ 1)
+            .seek(/* windowIndex= */ 0, /* positionMs= */ 9999)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .build(context)
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+
+    testRunner.assertPlayedPeriodIndices(0, 1, 0, 1);
+    assertThat(mediaSource.getCreatedMediaPeriods())
+        .containsAllOf(
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0),
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 0));
+    assertThat(mediaSource.getCreatedMediaPeriods())
+        .doesNotContain(
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 1));
+  }
+
   @Test
   public void testRecursivePlayerChangesReportConsistentValuesForAllListeners() throws Exception {
     // We add two listeners to the player. The first stops the player as soon as it's ready and both
@@ -1988,7 +2091,7 @@ public void testRecursivePlayerChangesReportConsistentValuesForAllListeners() th
     final List<Integer> eventListener1States = new ArrayList<>();
     final List<Integer> eventListener2States = new ArrayList<>();
     final EventListener eventListener1 =
-        new DefaultEventListener() {
+        new EventListener() {
           @Override
           public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
             eventListener1States.add(playbackState);
@@ -1998,7 +2101,7 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
           }
         };
     final EventListener eventListener2 =
-        new DefaultEventListener() {
+        new EventListener() {
           @Override
           public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
             eventListener2States.add(playbackState);
@@ -2018,7 +2121,7 @@ public void run(SimpleExoPlayer player) {
             .build();
     new ExoPlayerTestRunner.Builder()
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
 
@@ -2038,9 +2141,9 @@ public void testRecursivePlayerChangesAreReportedInCorrectOrder() throws Excepti
     final List<Boolean> eventListenerPlayWhenReady = new ArrayList<>();
     final List<Integer> eventListenerStates = new ArrayList<>();
     final EventListener eventListener =
-        new DefaultEventListener() {
+        new EventListener() {
           @Override
-          public void onTimelineChanged(Timeline timeline, Object manifest, int reason) {
+          public void onTimelineChanged(Timeline timeline, @Nullable Object manifest, int reason) {
             if (timeline.isEmpty()) {
               playerReference.get().setPlayWhenReady(/* playWhenReady= */ false);
             }
@@ -2068,7 +2171,7 @@ public void run(SimpleExoPlayer player) {
             .build();
     new ExoPlayerTestRunner.Builder()
         .setActionSchedule(actionSchedule)
-        .build()
+        .build(context)
         .start()
         .blockUntilEnded(TIMEOUT_MS);
 
@@ -2079,6 +2182,411 @@ public void run(SimpleExoPlayer player) {
     assertThat(eventListenerPlayWhenReady).containsExactly(true, true, true, false).inOrder();
   }
 
+  @Test
+  public void testClippedLoopedPeriodsArePlayedFully() throws Exception {
+    long startPositionUs = 300_000;
+    long expectedDurationUs = 700_000;
+    MediaSource mediaSource =
+        new ClippingMediaSource(
+            new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1), /* manifest= */ null),
+            startPositionUs,
+            startPositionUs + expectedDurationUs);
+    Clock clock = new AutoAdvancingFakeClock();
+    AtomicReference<Player> playerReference = new AtomicReference<>();
+    AtomicLong positionAtDiscontinuityMs = new AtomicLong(C.TIME_UNSET);
+    AtomicLong clockAtStartMs = new AtomicLong(C.TIME_UNSET);
+    AtomicLong clockAtDiscontinuityMs = new AtomicLong(C.TIME_UNSET);
+    EventListener eventListener =
+        new EventListener() {
+          @Override
+          public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+            if (playbackState == Player.STATE_READY && clockAtStartMs.get() == C.TIME_UNSET) {
+              clockAtStartMs.set(clock.elapsedRealtime());
+            }
+          }
+
+          @Override
+          public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+            if (reason == Player.DISCONTINUITY_REASON_PERIOD_TRANSITION) {
+              positionAtDiscontinuityMs.set(playerReference.get().getCurrentPosition());
+              clockAtDiscontinuityMs.set(clock.elapsedRealtime());
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testClippedLoopedPeriodsArePlayedFully")
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    playerReference.set(player);
+                    player.addListener(eventListener);
+                  }
+                })
+            .pause()
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            .waitForPlaybackState(Player.STATE_READY)
+            // Play until the media repeats once.
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 1)
+            .playUntilStartOfWindow(/* windowIndex= */ 0)
+            .setRepeatMode(Player.REPEAT_MODE_OFF)
+            .play()
+            .build();
+    new ExoPlayerTestRunner.Builder()
+        .setClock(clock)
+        .setMediaSource(mediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(positionAtDiscontinuityMs.get()).isAtLeast(0L);
+    assertThat(clockAtDiscontinuityMs.get() - clockAtStartMs.get())
+        .isAtLeast(C.usToMs(expectedDurationUs));
+  }
+
+  @Test
+  public void testUpdateTrackSelectorThenSeekToUnpreparedPeriod_returnsEmptyTrackGroups()
+      throws Exception {
+    // Use unset duration to prevent pre-loading of the second window.
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true, /* isDynamic= */ false, /* durationUs= */ C.TIME_UNSET));
+    MediaSource[] fakeMediaSources = {
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+      new FakeMediaSource(fakeTimeline, null, Builder.AUDIO_FORMAT)
+    };
+    MediaSource mediaSource = new ConcatenatingMediaSource(fakeMediaSources);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testUpdateTrackSelectorThenSeekToUnpreparedPeriod")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .seek(/* windowIndex= */ 1, /* positionMs= */ 0)
+            .play()
+            .build();
+    List<TrackGroupArray> trackGroupsList = new ArrayList<>();
+    List<TrackSelectionArray> trackSelectionsList = new ArrayList<>();
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setTrackSelector(trackSelector)
+        .setRenderers(renderer)
+        .setActionSchedule(actionSchedule)
+        .setEventListener(
+            new EventListener() {
+              @Override
+              public void onTracksChanged(
+                  TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+                trackGroupsList.add(trackGroups);
+                trackSelectionsList.add(trackSelections);
+              }
+            })
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(trackGroupsList).hasSize(3);
+    // First track groups of the 1st period are reported.
+    // Then the seek to an unprepared period will result in empty track groups and selections being
+    // returned.
+    // Then the track groups of the 2nd period are reported.
+    assertThat(trackGroupsList.get(0).get(0).getFormat(0)).isEqualTo(Builder.VIDEO_FORMAT);
+    assertThat(trackGroupsList.get(1)).isEqualTo(TrackGroupArray.EMPTY);
+    assertThat(trackSelectionsList.get(1).get(0)).isNull();
+    assertThat(trackGroupsList.get(2).get(0).getFormat(0)).isEqualTo(Builder.AUDIO_FORMAT);
+  }
+
+  @Test
+  public void testSecondMediaSourceInPlaylistOnlyThrowsWhenPreviousPeriodIsFullyRead()
+      throws Exception {
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 10 * C.MICROS_PER_SECOND));
+    MediaSource workingMediaSource =
+        new FakeMediaSource(fakeTimeline, /* manifest= */ null, Builder.VIDEO_FORMAT);
+    MediaSource failingMediaSource =
+        new FakeMediaSource(/* timeline= */ null, /* manifest= */ null, Builder.VIDEO_FORMAT) {
+          @Override
+          public void maybeThrowSourceInfoRefreshError() throws IOException {
+            throw new IOException();
+          }
+        };
+    ConcatenatingMediaSource concatenatingMediaSource =
+        new ConcatenatingMediaSource(workingMediaSource, failingMediaSource);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setMediaSource(concatenatingMediaSource)
+            .setRenderers(renderer)
+            .build(context);
+    try {
+      testRunner.start().blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(renderer.sampleBufferReadCount).isAtLeast(1);
+    assertThat(renderer.hasReadStreamToEnd()).isTrue();
+  }
+
+  @Test
+  public void
+      testDynamicallyAddedSecondMediaSourceInPlaylistOnlyThrowsWhenPreviousPeriodIsFullyRead()
+          throws Exception {
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 10 * C.MICROS_PER_SECOND));
+    MediaSource workingMediaSource =
+        new FakeMediaSource(fakeTimeline, /* manifest= */ null, Builder.VIDEO_FORMAT);
+    MediaSource failingMediaSource =
+        new FakeMediaSource(/* timeline= */ null, /* manifest= */ null, Builder.VIDEO_FORMAT) {
+          @Override
+          public void maybeThrowSourceInfoRefreshError() throws IOException {
+            throw new IOException();
+          }
+        };
+    ConcatenatingMediaSource concatenatingMediaSource =
+        new ConcatenatingMediaSource(workingMediaSource);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testFailingSecondMediaSourceInPlaylistOnlyThrowsLater")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(() -> concatenatingMediaSource.addMediaSource(failingMediaSource))
+            .play()
+            .build();
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setMediaSource(concatenatingMediaSource)
+            .setActionSchedule(actionSchedule)
+            .setRenderers(renderer)
+            .build(context);
+    try {
+      testRunner.start().blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(renderer.sampleBufferReadCount).isAtLeast(1);
+    assertThat(renderer.hasReadStreamToEnd()).isTrue();
+  }
+
+  @Test
+  public void failingDynamicUpdateOnlyThrowsWhenAvailablePeriodHasBeenFullyRead() throws Exception {
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true,
+                /* isDynamic= */ true,
+                /* durationUs= */ 10 * C.MICROS_PER_SECOND));
+    AtomicReference<Boolean> wasReadyOnce = new AtomicReference<>(false);
+    MediaSource mediaSource =
+        new FakeMediaSource(fakeTimeline, /* manifest= */ null, Builder.VIDEO_FORMAT) {
+          @Override
+          public void maybeThrowSourceInfoRefreshError() throws IOException {
+            if (wasReadyOnce.get()) {
+              throw new IOException();
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testFailingDynamicMediaSourceInTimelineOnlyThrowsLater")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(() -> wasReadyOnce.set(true))
+            .play()
+            .build();
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .setRenderers(renderer)
+            .build(context);
+    try {
+      testRunner.start().blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(renderer.sampleBufferReadCount).isAtLeast(1);
+    assertThat(renderer.hasReadStreamToEnd()).isTrue();
+  }
+
+  @Test
+  public void removingLoopingLastPeriodFromPlaylistDoesNotThrow() throws Exception {
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true, /* isDynamic= */ true, /* durationUs= */ 100_000));
+    MediaSource mediaSource = new FakeMediaSource(timeline, /* manifest= */ null);
+    ConcatenatingMediaSource concatenatingMediaSource = new ConcatenatingMediaSource(mediaSource);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("removingLoopingLastPeriodFromPlaylistDoesNotThrow")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            // Play almost to end to ensure the current period is fully buffered.
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 90)
+            // Enable repeat mode to trigger the creation of new media periods.
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            // Remove the media source.
+            .executeRunnable(concatenatingMediaSource::clear)
+            .build();
+    new Builder()
+        .setMediaSource(concatenatingMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+  }
+
+  @Test
+  public void seekToUnpreparedWindowWithNonZeroOffsetInConcatenationStartsAtCorrectPosition()
+      throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    FakeMediaSource mediaSource = new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    MediaSource clippedMediaSource =
+        new ClippingMediaSource(
+            mediaSource,
+            /* startPositionUs= */ 3 * C.MICROS_PER_SECOND,
+            /* endPositionUs= */ C.TIME_END_OF_SOURCE);
+    MediaSource concatenatedMediaSource = new ConcatenatingMediaSource(clippedMediaSource);
+    AtomicLong positionWhenReady = new AtomicLong();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("seekToUnpreparedWindowWithNonZeroOffsetInConcatenation")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .seek(/* positionMs= */ 10)
+            .waitForTimelineChanged()
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
+            .waitForTimelineChanged()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionWhenReady.set(player.getContentPosition());
+                  }
+                })
+            .play()
+            .build();
+    new Builder()
+        .setMediaSource(concatenatedMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(positionWhenReady.get()).isEqualTo(10);
+  }
+
+  @Test
+  public void seekToUnpreparedWindowWithMultiplePeriodsInConcatenationStartsAtCorrectPeriod()
+      throws Exception {
+    long periodDurationMs = 5000;
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount =*/ 2,
+                /* id= */ new Object(),
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 2 * periodDurationMs * 1000));
+    FakeMediaSource mediaSource = new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    MediaSource concatenatedMediaSource = new ConcatenatingMediaSource(mediaSource);
+    AtomicInteger periodIndexWhenReady = new AtomicInteger();
+    AtomicLong positionWhenReady = new AtomicLong();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("seekToUnpreparedWindowWithMultiplePeriodsInConcatenation")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Seek 10ms into the second period.
+            .seek(/* positionMs= */ periodDurationMs + 10)
+            .waitForTimelineChanged()
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
+            .waitForTimelineChanged()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    periodIndexWhenReady.set(player.getCurrentPeriodIndex());
+                    positionWhenReady.set(player.getContentPosition());
+                  }
+                })
+            .play()
+            .build();
+    new Builder()
+        .setMediaSource(concatenatedMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(periodIndexWhenReady.get()).isEqualTo(1);
+    assertThat(positionWhenReady.get()).isEqualTo(periodDurationMs + 10);
+  }
+
+  @Test
+  public void periodTransitionReportsCorrectBufferedPosition() throws Exception {
+    int periodCount = 3;
+    long periodDurationUs = 5 * C.MICROS_PER_SECOND;
+    long windowDurationUs = periodCount * periodDurationUs;
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                periodCount,
+                /* id= */ new Object(),
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                windowDurationUs));
+    AtomicReference<Player> playerReference = new AtomicReference<>();
+    AtomicLong bufferedPositionAtFirstDiscontinuityMs = new AtomicLong(C.TIME_UNSET);
+    EventListener eventListener =
+        new EventListener() {
+          @Override
+          public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+            if (reason == Player.DISCONTINUITY_REASON_PERIOD_TRANSITION) {
+              if (bufferedPositionAtFirstDiscontinuityMs.get() == C.TIME_UNSET) {
+                bufferedPositionAtFirstDiscontinuityMs.set(
+                    playerReference.get().getBufferedPosition());
+              }
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("periodTransitionReportsCorrectBufferedPosition")
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    playerReference.set(player);
+                    player.addListener(eventListener);
+                  }
+                })
+            .pause()
+            // Wait until all periods are fully buffered.
+            .waitForIsLoading(/* targetIsLoading= */ true)
+            .waitForIsLoading(/* targetIsLoading= */ false)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(bufferedPositionAtFirstDiscontinuityMs.get()).isEqualTo(C.usToMs(windowDurationUs));
+  }
+
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
@@ -2115,7 +2623,7 @@ public PositionGrabbingMessageTarget() {
     }
 
     @Override
-    public void handleMessage(SimpleExoPlayer player, int messageType, Object message) {
+    public void handleMessage(SimpleExoPlayer player, int messageType, @Nullable Object message) {
       if (player != null) {
         windowIndex = player.getCurrentWindowIndex();
         positionMs = player.getCurrentPosition();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
index 7ca2181ebf..33e6ed0838 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
@@ -64,10 +64,35 @@ public void testParcelable() {
     ColorInfo colorInfo =  new ColorInfo(C.COLOR_SPACE_BT709,
         C.COLOR_RANGE_LIMITED, C.COLOR_TRANSFER_SDR, new byte[] {1, 2, 3, 4, 5, 6, 7});
 
-    Format formatToParcel = new Format("id", MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null,
-        1024, 2048, 1920, 1080, 24, 90, 2, projectionData, C.STEREO_MODE_TOP_BOTTOM, colorInfo, 6,
-        44100, C.ENCODING_PCM_24BIT, 1001, 1002, 0, "und", Format.NO_VALUE,
-        Format.OFFSET_SAMPLE_RELATIVE, INIT_DATA, drmInitData, metadata);
+    Format formatToParcel =
+        new Format(
+            "id",
+            "label",
+            /* containerMimeType= */ MimeTypes.VIDEO_MP4,
+            /* sampleMimeType= */ MimeTypes.VIDEO_H264,
+            "codec",
+            /* bitrate= */ 1024,
+            /* maxInputSize= */ 2048,
+            /* width= */ 1920,
+            /* height= */ 1080,
+            /* frameRate= */ 24,
+            /* rotationDegrees= */ 90,
+            /* pixelWidthHeightRatio= */ 2,
+            projectionData,
+            C.STEREO_MODE_TOP_BOTTOM,
+            colorInfo,
+            /* channelCount= */ 6,
+            /* sampleRate= */ 44100,
+            C.ENCODING_PCM_24BIT,
+            /* encoderDelay= */ 1001,
+            /* encoderPadding= */ 1002,
+            C.SELECTION_FLAG_DEFAULT,
+            "language",
+            /* accessibilityChannel= */ Format.NO_VALUE,
+            Format.OFFSET_SAMPLE_RELATIVE,
+            INIT_DATA,
+            drmInitData,
+            metadata);
 
     Parcel parcel = Parcel.obtain();
     formatToParcel.writeToParcel(parcel, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
index 623506ad0d..3649685f3e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
@@ -17,9 +17,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
 import android.os.Handler;
 import android.os.SystemClock;
 import android.support.annotation.Nullable;
@@ -35,10 +32,7 @@
 import com.google.android.exoplayer2.Timeline.Window;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
@@ -53,7 +47,6 @@
 import com.google.android.exoplayer2.testutil.FakeRenderer;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.RobolectricUtil;
-import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
@@ -93,8 +86,7 @@
   private static final int EVENT_MEDIA_PERIOD_RELEASED = 18;
   private static final int EVENT_READING_STARTED = 19;
   private static final int EVENT_BANDWIDTH_ESTIMATE = 20;
-  private static final int EVENT_VIEWPORT_SIZE_CHANGED = 21;
-  private static final int EVENT_NETWORK_TYPE_CHANGED = 22;
+  private static final int EVENT_SURFACE_SIZE_CHANGED = 21;
   private static final int EVENT_METADATA = 23;
   private static final int EVENT_DECODER_ENABLED = 24;
   private static final int EVENT_DECODER_INIT = 25;
@@ -109,6 +101,8 @@
   private static final int EVENT_DRM_ERROR = 34;
   private static final int EVENT_DRM_KEYS_RESTORED = 35;
   private static final int EVENT_DRM_KEYS_REMOVED = 36;
+  private static final int EVENT_DRM_SESSION_ACQUIRED = 37;
+  private static final int EVENT_DRM_SESSION_RELEASED = 38;
 
   private static final int TIMEOUT_MS = 10000;
   private static final Timeline SINGLE_PERIOD_TIMELINE = new FakeTimeline(/* windowCount= */ 1);
@@ -116,28 +110,16 @@
       new EventWindowAndPeriodId(/* windowIndex= */ 0, /* mediaPeriodId= */ null);
   private static final EventWindowAndPeriodId WINDOW_1 =
       new EventWindowAndPeriodId(/* windowIndex= */ 1, /* mediaPeriodId= */ null);
-  private static final EventWindowAndPeriodId PERIOD_0 =
-      new EventWindowAndPeriodId(
-          /* windowIndex= */ 0,
-          new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
-  private static final EventWindowAndPeriodId PERIOD_1 =
-      new EventWindowAndPeriodId(
-          /* windowIndex= */ 1,
-          new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1));
-  private static final EventWindowAndPeriodId PERIOD_0_SEQ_0 = PERIOD_0;
-  private static final EventWindowAndPeriodId PERIOD_1_SEQ_1 = PERIOD_1;
-  private static final EventWindowAndPeriodId PERIOD_0_SEQ_1 =
-      new EventWindowAndPeriodId(
-          /* windowIndex= */ 0,
-          new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 1));
-  private static final EventWindowAndPeriodId PERIOD_1_SEQ_0 =
-      new EventWindowAndPeriodId(
-          /* windowIndex= */ 1,
-          new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 0));
-  private static final EventWindowAndPeriodId PERIOD_1_SEQ_2 =
-      new EventWindowAndPeriodId(
-          /* windowIndex= */ 1,
-          new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 2));
+
+  private EventWindowAndPeriodId period0;
+  private EventWindowAndPeriodId period1;
+  private EventWindowAndPeriodId period0Seq0;
+  private EventWindowAndPeriodId period1Seq1;
+  private EventWindowAndPeriodId period0Seq1;
+  private EventWindowAndPeriodId period1Seq0;
+  private EventWindowAndPeriodId period1Seq2;
+  private EventWindowAndPeriodId window0Period1Seq0;
+  private EventWindowAndPeriodId window1Period0Seq1;
 
   @Test
   public void testEmptyTimeline() throws Exception {
@@ -163,34 +145,35 @@ public void testSinglePeriod() throws Exception {
             Builder.AUDIO_FORMAT);
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource);
 
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady */,
             WINDOW_0 /* BUFFERING */,
-            PERIOD_0 /* READY */,
-            PERIOD_0 /* ENDED */);
+            period0 /* READY */,
+            period0 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0 /* started */, PERIOD_0 /* stopped */);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(PERIOD_0);
+        .containsExactly(period0 /* started */, period0 /* stopped */);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
-        .containsExactly(WINDOW_0 /* manifest */, PERIOD_0 /* media */);
+        .containsExactly(WINDOW_0 /* manifest */, period0 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
-        .containsExactly(WINDOW_0 /* manifest */, PERIOD_0 /* media */);
+        .containsExactly(WINDOW_0 /* manifest */, period0 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0 /* audio */, PERIOD_0 /* video */);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(PERIOD_0);
+        .containsExactly(period0 /* audio */, period0 /* video */);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(period0);
     assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0 /* audio */, PERIOD_0 /* video */);
+        .containsExactly(period0 /* audio */, period0 /* video */);
     assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0 /* audio */, PERIOD_0 /* video */);
+        .containsExactly(period0 /* audio */, period0 /* video */);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0 /* audio */, PERIOD_0 /* video */);
-    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(PERIOD_0);
+        .containsExactly(period0 /* audio */, period0 /* video */);
+    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(period0);
     listener.assertNoMoreEvents();
   }
 
@@ -210,47 +193,48 @@ public void testAutomaticPeriodTransition() throws Exception {
                 Builder.AUDIO_FORMAT));
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource);
 
+    populateEventIds(listener.lastReportedTimeline);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady */,
             WINDOW_0 /* BUFFERING */,
-            PERIOD_0 /* READY */,
-            PERIOD_1 /* ENDED */);
+            period0 /* READY */,
+            period1 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
-    assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(PERIOD_1);
+    assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(period1);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0, PERIOD_0, PERIOD_0, PERIOD_0);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(PERIOD_0, PERIOD_1);
+        .containsExactly(period0, period0, period0, period0);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0, period1);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1 /* media */);
+            period1 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1 /* media */);
+            period1 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
         .containsExactly(
-            PERIOD_0 /* audio */, PERIOD_0 /* video */, PERIOD_1 /* audio */, PERIOD_1 /* video */);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(PERIOD_0, PERIOD_1);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(PERIOD_0, PERIOD_1);
+            period0 /* audio */, period0 /* video */, period1 /* audio */, period1 /* video */);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(period0, period1);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(period0, period1);
     assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0 /* audio */, PERIOD_0 /* video */);
+        .containsExactly(period0 /* audio */, period0 /* video */);
     assertThat(listener.getEvents(EVENT_DECODER_INIT))
         .containsExactly(
-            PERIOD_0 /* audio */, PERIOD_0 /* video */, PERIOD_1 /* audio */, PERIOD_1 /* video */);
+            period0 /* audio */, period0 /* video */, period1 /* audio */, period1 /* video */);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
         .containsExactly(
-            PERIOD_0 /* audio */, PERIOD_0 /* video */, PERIOD_1 /* audio */, PERIOD_1 /* video */);
-    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(PERIOD_1);
-    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(PERIOD_0);
+            period0 /* audio */, period0 /* video */, period1 /* audio */, period1 /* video */);
+    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(period1);
+    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(period0);
     listener.assertNoMoreEvents();
   }
 
@@ -263,47 +247,48 @@ public void testPeriodTransitionWithRendererChange() throws Exception {
                 SINGLE_PERIOD_TIMELINE, /* manifest= */ null, Builder.AUDIO_FORMAT));
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource);
 
+    populateEventIds(listener.lastReportedTimeline);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady */,
             WINDOW_0 /* BUFFERING */,
-            PERIOD_0 /* READY */,
-            PERIOD_1 /* BUFFERING */,
-            PERIOD_1 /* READY */,
-            PERIOD_1 /* ENDED */);
+            period0 /* READY */,
+            period1 /* BUFFERING */,
+            period1 /* READY */,
+            period1 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
-    assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(PERIOD_1);
+    assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(period1);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0, PERIOD_0, PERIOD_0, PERIOD_0);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(PERIOD_0, PERIOD_1);
+        .containsExactly(period0, period0, period0, period0);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0, period1);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1 /* media */);
+            period1 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1 /* media */);
+            period1 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(PERIOD_0, PERIOD_1);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(PERIOD_0, PERIOD_1);
+        .containsExactly(period0 /* video */, period1 /* audio */);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(period0, period1);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(period0, period1);
     assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
+        .containsExactly(period0 /* video */, period1 /* audio */);
     assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
+        .containsExactly(period0 /* video */, period1 /* audio */);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
-    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(PERIOD_1);
-    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(PERIOD_0);
+        .containsExactly(period0 /* video */, period1 /* audio */);
+    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(period1);
+    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(period0);
     listener.assertNoMoreEvents();
   }
 
@@ -323,51 +308,52 @@ public void testSeekToOtherPeriod() throws Exception {
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource, actionSchedule);
 
+    populateEventIds(listener.lastReportedTimeline);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
             WINDOW_0 /* BUFFERING */,
             WINDOW_0 /* setPlayWhenReady=false */,
-            PERIOD_0 /* READY */,
-            PERIOD_1 /* BUFFERING */,
-            PERIOD_1 /* READY */,
-            PERIOD_1 /* setPlayWhenReady=true */,
-            PERIOD_1 /* ENDED */);
+            period0 /* READY */,
+            period1 /* BUFFERING */,
+            period1 /* READY */,
+            period1 /* setPlayWhenReady=true */,
+            period1 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
-    assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(PERIOD_1);
-    assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(PERIOD_1);
+    assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(period1);
+    assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(period1);
     List<EventWindowAndPeriodId> loadingEvents = listener.getEvents(EVENT_LOADING_CHANGED);
     assertThat(loadingEvents).hasSize(4);
-    assertThat(loadingEvents).containsAllOf(PERIOD_0, PERIOD_0);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(PERIOD_0, PERIOD_1);
+    assertThat(loadingEvents).containsAllOf(period0, period0);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0, period1);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1 /* media */);
+            period1 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1 /* media */);
+            period1 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(PERIOD_0, PERIOD_1);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(PERIOD_0, PERIOD_1);
+        .containsExactly(period0 /* video */, period1 /* audio */);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED)).containsExactly(period0, period1);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(period0, period1);
     assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
+        .containsExactly(period0 /* video */, period1 /* audio */);
     assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
+        .containsExactly(period0 /* video */, period1 /* audio */);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0 /* video */, PERIOD_1 /* audio */);
-    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(PERIOD_1);
-    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(PERIOD_0);
+        .containsExactly(period0 /* video */, period1 /* audio */);
+    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(period1);
+    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(period0);
     listener.assertNoMoreEvents();
   }
 
@@ -394,64 +380,64 @@ public void testSeekBackAfterReadingAhead() throws Exception {
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource, actionSchedule);
 
+    populateEventIds(listener.lastReportedTimeline);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
             WINDOW_0 /* BUFFERING */,
             WINDOW_0 /* setPlayWhenReady=false */,
-            PERIOD_0 /* READY */,
-            PERIOD_0 /* setPlayWhenReady=true */,
-            PERIOD_0 /* setPlayWhenReady=false */,
-            PERIOD_0 /* BUFFERING */,
-            PERIOD_0 /* READY */,
-            PERIOD_0 /* setPlayWhenReady=true */,
-            PERIOD_1_SEQ_2 /* BUFFERING */,
-            PERIOD_1_SEQ_2 /* READY */,
-            PERIOD_1_SEQ_2 /* ENDED */);
+            period0 /* READY */,
+            period0 /* setPlayWhenReady=true */,
+            period0 /* setPlayWhenReady=false */,
+            period0 /* BUFFERING */,
+            period0 /* READY */,
+            period0 /* setPlayWhenReady=true */,
+            period1Seq2 /* BUFFERING */,
+            period1Seq2 /* READY */,
+            period1Seq2 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_2);
-    assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(PERIOD_0);
+        .containsExactly(period0, period1Seq2);
+    assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(period0);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0, PERIOD_0, PERIOD_0, PERIOD_0, PERIOD_0, PERIOD_0);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(PERIOD_0, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period0, period0, period0, period0, period0);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0, period1Seq2);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1_SEQ_1 /* media */,
-            PERIOD_1_SEQ_2 /* media */);
+            period1Seq1 /* media */,
+            period1Seq2 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0 /* media */,
+            period0 /* media */,
             WINDOW_1 /* manifest */,
-            PERIOD_1_SEQ_1 /* media */,
-            PERIOD_1_SEQ_2 /* media */);
+            period1Seq1 /* media */,
+            period1Seq2 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_1, PERIOD_1_SEQ_2, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period1Seq1, period1Seq2, period1Seq2);
     assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_1, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period1Seq1, period1Seq2);
     assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_1);
+        .containsExactly(period0, period1Seq1);
     assertThat(listener.getEvents(EVENT_READING_STARTED))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_1, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period1Seq1, period1Seq2);
     assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0, PERIOD_0, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period0, period1Seq2);
     assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_1, PERIOD_1_SEQ_2, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period1Seq1, period1Seq2, period1Seq2);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_1, PERIOD_1_SEQ_2, PERIOD_1_SEQ_2);
-    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(PERIOD_1_SEQ_2);
+        .containsExactly(period0, period1Seq1, period1Seq2, period1Seq2);
+    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_AUDIO_SESSION_ID)).containsExactly(period1Seq2);
     assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES))
-        .containsExactly(PERIOD_0, PERIOD_0, PERIOD_1_SEQ_2);
-    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period0, period1Seq2);
+    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(period0, period1Seq2);
     assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME))
-        .containsExactly(PERIOD_0, PERIOD_1_SEQ_2);
+        .containsExactly(period0, period1Seq2);
     listener.assertNoMoreEvents();
   }
 
@@ -470,54 +456,52 @@ public void testPrepareNewSource() throws Exception {
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource1, actionSchedule);
 
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
             WINDOW_0 /* BUFFERING */,
             WINDOW_0 /* setPlayWhenReady=false */,
-            PERIOD_0_SEQ_0 /* READY */,
+            period0Seq0 /* READY */,
             WINDOW_0 /* BUFFERING */,
             WINDOW_0 /* setPlayWhenReady=true */,
-            PERIOD_0_SEQ_1 /* READY */,
-            PERIOD_0_SEQ_1 /* ENDED */);
+            period0Seq1 /* READY */,
+            period0Seq1 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
         .containsExactly(WINDOW_0 /* prepared */, WINDOW_0 /* reset */, WINDOW_0 /* prepared */);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0, PERIOD_0_SEQ_1, PERIOD_0_SEQ_1);
+        .containsExactly(period0Seq0, period0Seq0, period0Seq1, period0Seq1);
     assertThat(listener.getEvents(EVENT_TRACKS_CHANGED))
         .containsExactly(
-            PERIOD_0_SEQ_0 /* prepared */, WINDOW_0 /* reset */, PERIOD_0_SEQ_1 /* prepared */);
+            period0Seq0 /* prepared */, WINDOW_0 /* reset */, period0Seq1 /* prepared */);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_0 /* media */,
+            period0Seq0 /* media */,
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_1 /* media */);
+            period0Seq1 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_0 /* media */,
+            period0Seq0 /* media */,
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_1 /* media */);
+            period0Seq1 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
+        .containsExactly(period0Seq0, period0Seq1);
     assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_READING_STARTED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
-    assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
-    assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
+        .containsExactly(period0Seq0, period0Seq1);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(period0Seq0);
+    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(period0Seq0, period0Seq1);
+    assertThat(listener.getEvents(EVENT_DECODER_ENABLED)).containsExactly(period0Seq0, period0Seq1);
+    assertThat(listener.getEvents(EVENT_DECODER_INIT)).containsExactly(period0Seq0, period0Seq1);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
-    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(PERIOD_0_SEQ_1);
+        .containsExactly(period0Seq0, period0Seq1);
+    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(period0Seq0);
+    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(period0Seq1);
     assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
+        .containsExactly(period0Seq0, period0Seq1);
     assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_1);
+        .containsExactly(period0Seq0, period0Seq1);
     listener.assertNoMoreEvents();
   }
 
@@ -535,55 +519,51 @@ public void testReprepareAfterError() throws Exception {
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource, actionSchedule);
 
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
             WINDOW_0 /* BUFFERING */,
-            PERIOD_0_SEQ_0 /* READY */,
+            period0Seq0 /* READY */,
             WINDOW_0 /* IDLE */,
             WINDOW_0 /* BUFFERING */,
-            PERIOD_0_SEQ_0 /* READY */,
-            PERIOD_0_SEQ_0 /* ENDED */);
-    // assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED)).doesNotContain(PERIOD_0_SEQ_1);
+            period0Seq0 /* READY */,
+            period0Seq0 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
         .containsExactly(WINDOW_0 /* prepared */, WINDOW_0 /* prepared */);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0, PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0, period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_PLAYER_ERROR)).containsExactly(WINDOW_0);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_0 /* media */,
+            period0Seq0 /* media */,
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_0 /* media */);
+            period0Seq0 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_0 /* media */,
+            period0Seq0 /* media */,
             WINDOW_0 /* manifest */,
-            PERIOD_0_SEQ_0 /* media */);
+            period0Seq0 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_READING_STARTED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(period0Seq0);
+    assertThat(listener.getEvents(EVENT_READING_STARTED)).containsExactly(period0Seq0, period0Seq0);
+    assertThat(listener.getEvents(EVENT_DECODER_ENABLED)).containsExactly(period0Seq0, period0Seq0);
+    assertThat(listener.getEvents(EVENT_DECODER_INIT)).containsExactly(period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0);
+    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(period0Seq0);
     assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(period0Seq0, period0Seq0);
     listener.assertNoMoreEvents();
   }
 
@@ -602,67 +582,64 @@ public void testDynamicTimelineChange() throws Exception {
             // Ensure second period is already being read from.
             .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ periodDurationMs)
             .executeRunnable(
-                new Runnable() {
-                  @Override
-                  public void run() {
+                () ->
                     concatenatedMediaSource.moveMediaSource(
-                        /* currentIndex= */ 0, /* newIndex= */ 1);
-                  }
-                })
-            .waitForTimelineChanged(/* expectedTimeline= */ null)
+                        /* currentIndex= */ 0, /* newIndex= */ 1))
+            .waitForTimelineChanged()
             .play()
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(concatenatedMediaSource, actionSchedule);
 
+    populateEventIds(listener.lastReportedTimeline);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
             WINDOW_0 /* BUFFERING */,
             WINDOW_0 /* setPlayWhenReady=false */,
-            PERIOD_0_SEQ_0 /* READY */,
-            PERIOD_0_SEQ_0 /* setPlayWhenReady=true */,
-            PERIOD_0_SEQ_0 /* setPlayWhenReady=false */,
-            PERIOD_1_SEQ_0 /* setPlayWhenReady=true */,
-            PERIOD_1_SEQ_0 /* BUFFERING */,
-            PERIOD_1_SEQ_0 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0, PERIOD_1_SEQ_0);
+            window0Period1Seq0 /* READY */,
+            window0Period1Seq0 /* setPlayWhenReady=true */,
+            window0Period1Seq0 /* setPlayWhenReady=false */,
+            period1Seq0 /* setPlayWhenReady=true */,
+            period1Seq0 /* BUFFERING */,
+            period1Seq0 /* ENDED */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0, period1Seq0);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0, PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(PERIOD_0_SEQ_0);
+        .containsExactly(
+            window0Period1Seq0, window0Period1Seq0, window0Period1Seq0, window0Period1Seq0);
+    assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(window0Period1Seq0);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
-            WINDOW_0 /* manifest */, PERIOD_0_SEQ_0 /* media */, PERIOD_1_SEQ_1 /* media */);
+            WINDOW_0 /* manifest */,
+            window0Period1Seq0 /* media */,
+            window1Period0Seq1 /* media */);
     assertThat(listener.getEvents(EVENT_LOAD_COMPLETED))
         .containsExactly(
-            WINDOW_0 /* manifest */, PERIOD_0_SEQ_0 /* media */, PERIOD_1_SEQ_1 /* media */);
+            WINDOW_0 /* manifest */,
+            window0Period1Seq0 /* media */,
+            window1Period0Seq1 /* media */);
     assertThat(listener.getEvents(EVENT_DOWNSTREAM_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_1_SEQ_1);
+        .containsExactly(window0Period1Seq0, window1Period0Seq1);
     assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_CREATED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_1_SEQ_1);
-    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(PERIOD_0_SEQ_1);
+        .containsExactly(window0Period1Seq0, window1Period0Seq1);
+    assertThat(listener.getEvents(EVENT_MEDIA_PERIOD_RELEASED)).containsExactly(window1Period0Seq1);
     assertThat(listener.getEvents(EVENT_READING_STARTED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_1_SEQ_1);
+        .containsExactly(window0Period1Seq0, window1Period0Seq1);
     assertThat(listener.getEvents(EVENT_DECODER_ENABLED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_0_SEQ_0);
+        .containsExactly(window0Period1Seq0, window0Period1Seq0);
     assertThat(listener.getEvents(EVENT_DECODER_INIT))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_1_SEQ_1);
+        .containsExactly(window0Period1Seq0, window1Period0Seq1);
     assertThat(listener.getEvents(EVENT_DECODER_FORMAT_CHANGED))
-        .containsExactly(PERIOD_0_SEQ_0, PERIOD_1_SEQ_1);
-    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(PERIOD_0_SEQ_0);
-    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(PERIOD_0_SEQ_0);
+        .containsExactly(window0Period1Seq0, window1Period0Seq1);
+    assertThat(listener.getEvents(EVENT_DECODER_DISABLED)).containsExactly(window0Period1Seq0);
+    assertThat(listener.getEvents(EVENT_DROPPED_VIDEO_FRAMES)).containsExactly(window0Period1Seq0);
+    assertThat(listener.getEvents(EVENT_VIDEO_SIZE_CHANGED)).containsExactly(window0Period1Seq0);
+    assertThat(listener.getEvents(EVENT_RENDERED_FIRST_FRAME)).containsExactly(window0Period1Seq0);
     listener.assertNoMoreEvents();
   }
 
   @Test
   public void testNotifyExternalEvents() throws Exception {
     MediaSource mediaSource = new FakeMediaSource(SINGLE_PERIOD_TIMELINE, /* manifest= */ null);
-    final NetworkInfo networkInfo =
-        ((ConnectivityManager)
-                RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE))
-            .getActiveNetworkInfo();
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("AnalyticsCollectorTest")
             .pause()
@@ -671,10 +648,6 @@ public void testNotifyExternalEvents() throws Exception {
                 new PlayerRunnable() {
                   @Override
                   public void run(SimpleExoPlayer player) {
-                    player.getAnalyticsCollector().notifyNetworkTypeChanged(networkInfo);
-                    player
-                        .getAnalyticsCollector()
-                        .notifyViewportSizeChanged(/* width= */ 320, /* height= */ 240);
                     player.getAnalyticsCollector().notifySeekStarted();
                   }
                 })
@@ -683,10 +656,51 @@ public void run(SimpleExoPlayer player) {
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource, actionSchedule);
 
-    assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_VIEWPORT_SIZE_CHANGED)).containsExactly(PERIOD_0);
-    assertThat(listener.getEvents(EVENT_NETWORK_TYPE_CHANGED)).containsExactly(PERIOD_0);
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
+    assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(period0);
+    assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(period0);
+  }
+
+  private void populateEventIds(Timeline timeline) {
+    period0 =
+        new EventWindowAndPeriodId(
+            /* windowIndex= */ 0,
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
+    period0Seq0 = period0;
+    period0Seq1 =
+        new EventWindowAndPeriodId(
+            /* windowIndex= */ 0,
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 1));
+    window1Period0Seq1 =
+        new EventWindowAndPeriodId(
+            /* windowIndex= */ 1,
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 1));
+    if (timeline.getPeriodCount() > 1) {
+      period1 =
+          new EventWindowAndPeriodId(
+              /* windowIndex= */ 1,
+              new MediaPeriodId(
+                  timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 1));
+      period1Seq1 = period1;
+      period1Seq0 =
+          new EventWindowAndPeriodId(
+              /* windowIndex= */ 1,
+              new MediaPeriodId(
+                  timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 0));
+      period1Seq2 =
+          new EventWindowAndPeriodId(
+              /* windowIndex= */ 1,
+              new MediaPeriodId(
+                  timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 2));
+      window0Period1Seq0 =
+          new EventWindowAndPeriodId(
+              /* windowIndex= */ 0,
+              new MediaPeriodId(
+                  timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 0));
+    }
   }
 
   private static TestAnalyticsListener runAnalyticsTest(MediaSource mediaSource) throws Exception {
@@ -696,21 +710,16 @@ private static TestAnalyticsListener runAnalyticsTest(MediaSource mediaSource) t
   private static TestAnalyticsListener runAnalyticsTest(
       MediaSource mediaSource, @Nullable ActionSchedule actionSchedule) throws Exception {
     RenderersFactory renderersFactory =
-        new RenderersFactory() {
-          @Override
-          public Renderer[] createRenderers(
-              Handler eventHandler,
-              VideoRendererEventListener videoRendererEventListener,
-              AudioRendererEventListener audioRendererEventListener,
-              TextOutput textRendererOutput,
-              MetadataOutput metadataRendererOutput,
-              @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-            return new Renderer[] {
+        (eventHandler,
+            videoRendererEventListener,
+            audioRendererEventListener,
+            textRendererOutput,
+            metadataRendererOutput,
+            drmSessionManager) ->
+            new Renderer[] {
               new FakeVideoRenderer(eventHandler, videoRendererEventListener),
               new FakeAudioRenderer(eventHandler, audioRendererEventListener)
             };
-          }
-        };
     TestAnalyticsListener listener = new TestAnalyticsListener();
     try {
       new ExoPlayerTestRunner.Builder()
@@ -718,7 +727,7 @@ private static TestAnalyticsListener runAnalyticsTest(
           .setRenderersFactory(renderersFactory)
           .setAnalyticsListener(listener)
           .setActionSchedule(actionSchedule)
-          .build()
+          .build(RuntimeEnvironment.application)
           .start()
           .blockUntilActionScheduleFinished(TIMEOUT_MS)
           .blockUntilEnded(TIMEOUT_MS);
@@ -829,7 +838,7 @@ protected void onFormatChanged(Format format) {
     @Override
     protected void onBufferRead() {
       if (!notifiedAudioSessionId) {
-        eventDispatcher.audioSessionId(/* audioSessionId= */ 0);
+        eventDispatcher.audioSessionId(/* audioSessionId= */ 1);
         notifiedAudioSessionId = true;
       }
     }
@@ -861,7 +870,7 @@ public String toString() {
               + "window="
               + windowIndex
               + ", period="
-              + mediaPeriodId.periodIndex
+              + mediaPeriodId.periodUid
               + ", sequence="
               + mediaPeriodId.windowSequenceNumber
               + '}'
@@ -876,10 +885,13 @@ public int hashCode() {
 
   private static final class TestAnalyticsListener implements AnalyticsListener {
 
+    public Timeline lastReportedTimeline;
+
     private final ArrayList<ReportedEvent> reportedEvents;
 
     public TestAnalyticsListener() {
       reportedEvents = new ArrayList<>();
+      lastReportedTimeline = Timeline.EMPTY;
     }
 
     public List<EventWindowAndPeriodId> getEvents(int eventType) {
@@ -907,6 +919,7 @@ public void onPlayerStateChanged(
 
     @Override
     public void onTimelineChanged(EventTime eventTime, int reason) {
+      lastReportedTimeline = eventTime.timeline;
       reportedEvents.add(new ReportedEvent(EVENT_TIMELINE_CHANGED, eventTime));
     }
 
@@ -1017,13 +1030,8 @@ public void onBandwidthEstimate(
     }
 
     @Override
-    public void onViewportSizeChange(EventTime eventTime, int width, int height) {
-      reportedEvents.add(new ReportedEvent(EVENT_VIEWPORT_SIZE_CHANGED, eventTime));
-    }
-
-    @Override
-    public void onNetworkTypeChanged(EventTime eventTime, @Nullable NetworkInfo networkInfo) {
-      reportedEvents.add(new ReportedEvent(EVENT_NETWORK_TYPE_CHANGED, eventTime));
+    public void onSurfaceSizeChanged(EventTime eventTime, int width, int height) {
+      reportedEvents.add(new ReportedEvent(EVENT_SURFACE_SIZE_CHANGED, eventTime));
     }
 
     @Override
@@ -1085,6 +1093,11 @@ public void onRenderedFirstFrame(EventTime eventTime, Surface surface) {
       reportedEvents.add(new ReportedEvent(EVENT_RENDERED_FIRST_FRAME, eventTime));
     }
 
+    @Override
+    public void onDrmSessionAcquired(EventTime eventTime) {
+      reportedEvents.add(new ReportedEvent(EVENT_DRM_SESSION_ACQUIRED, eventTime));
+    }
+
     @Override
     public void onDrmKeysLoaded(EventTime eventTime) {
       reportedEvents.add(new ReportedEvent(EVENT_DRM_KEYS_LOADED, eventTime));
@@ -1105,6 +1118,11 @@ public void onDrmKeysRemoved(EventTime eventTime) {
       reportedEvents.add(new ReportedEvent(EVENT_DRM_KEYS_REMOVED, eventTime));
     }
 
+    @Override
+    public void onDrmSessionReleased(EventTime eventTime) {
+      reportedEvents.add(new ReportedEvent(EVENT_DRM_SESSION_RELEASED, eventTime));
+    }
+
     private static final class ReportedEvent {
 
       public final int eventType;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java
new file mode 100644
index 0000000000..e41e270966
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.util.Util;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit tests for {@link Ac3Util}. */
+@RunWith(RobolectricTestRunner.class)
+public final class Ac3UtilTest {
+
+  private static final int TRUEHD_SYNCFRAME_SAMPLE_COUNT = 40;
+  private static final byte[] TRUEHD_SYNCFRAME_HEADER =
+      Util.getBytesFromHexString("C07504D8F8726FBA0097C00FB7520000");
+  private static final byte[] TRUEHD_NON_SYNCFRAME_HEADER =
+      Util.getBytesFromHexString("A025048860224E6F6DEDB6D5B6DBAFE6");
+
+  @Test
+  public void testParseTrueHdSyncframeAudioSampleCount_nonSyncframe() {
+    assertThat(Ac3Util.parseTrueHdSyncframeAudioSampleCount(TRUEHD_NON_SYNCFRAME_HEADER))
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void testParseTrueHdSyncframeAudioSampleCount_syncframe() {
+    assertThat(Ac3Util.parseTrueHdSyncframeAudioSampleCount(TRUEHD_SYNCFRAME_HEADER))
+        .isEqualTo(TRUEHD_SYNCFRAME_SAMPLE_COUNT);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
new file mode 100644
index 0000000000..086c4ebc7f
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import static com.google.android.exoplayer2.audio.AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY;
+import static com.google.android.exoplayer2.audio.AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY;
+import static com.google.android.exoplayer2.audio.AudioFocusManager.PLAYER_COMMAND_WAIT_FOR_CALLBACK;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.content.Context;
+import android.media.AudioManager;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.shadows.ShadowAudioManager;
+
+/** Unit tests for {@link AudioFocusManager}. */
+@RunWith(RobolectricTestRunner.class)
+public class AudioFocusManagerTest {
+  private static final int NO_COMMAND_RECEIVED = ~PLAYER_COMMAND_WAIT_FOR_CALLBACK;
+
+  private AudioFocusManager audioFocusManager;
+  private TestPlayerControl testPlayerControl;
+
+  private AudioManager audioManager;
+
+  @Before
+  public void setUp() {
+    audioManager =
+        (AudioManager) RuntimeEnvironment.application.getSystemService(Context.AUDIO_SERVICE);
+
+    testPlayerControl = new TestPlayerControl();
+    audioFocusManager = new AudioFocusManager(RuntimeEnvironment.application, testPlayerControl);
+  }
+
+  @Test
+  public void setAudioAttributes_withNullUsage_doesNotManageAudioFocus() {
+    // Ensure that NULL audio attributes -> don't manage audio focus
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ false, Player.STATE_IDLE))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request).isNull();
+  }
+
+  @Test
+  public void setAudioAttributes_withNullUsage_releasesAudioFocus() {
+    // Create attributes and request audio focus.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request.durationHint).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+
+    // Ensure that setting null audio attributes with audio focus releases audio focus.
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    AudioManager.OnAudioFocusChangeListener lastRequest =
+        Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener();
+    assertThat(lastRequest).isNotNull();
+  }
+
+  @Test
+  public void setAudioAttributes_withUsageAlarm_throwsIllegalArgumentException() {
+    // Ensure that audio attributes that map to AUDIOFOCUS_GAIN_TRANSIENT* throw
+    AudioAttributes alarm = new AudioAttributes.Builder().setUsage(C.USAGE_ALARM).build();
+    try {
+      audioFocusManager.setAudioAttributes(alarm, /* playWhenReady= */ false, Player.STATE_IDLE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Expected
+    }
+  }
+
+  @Test
+  public void setAudioAttributes_withUsageMedia_usesAudioFocusGain() {
+    // Ensure setting media type audio attributes requests AUDIOFOCUS_GAIN.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request.durationHint).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+  }
+
+  @Test
+  public void setAudioAttributes_inStateEnded_requestsAudioFocus() {
+    // Ensure setting audio attributes when player is in STATE_ENDED requests audio focus.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_ENDED))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request.durationHint).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+  }
+
+  @Test
+  public void handlePrepare_afterSetAudioAttributes_setsPlayerCommandPlayWhenReady() {
+    // Ensure that when playWhenReady is true while the player is IDLE, audio focus is only
+    // requested after calling handlePrepare.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_IDLE))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAudioFocusRequest()).isNull();
+    assertThat(audioFocusManager.handlePrepare(/* playWhenReady= */ true))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+  }
+
+  @Test
+  public void handleSetPlayWhenReady_afterSetAudioAttributes_setsPlayerCommandPlayWhenReady() {
+    // Ensure that audio focus is not requested until playWhenReady is true.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+
+    assertThat(audioFocusManager.handlePrepare(/* playWhenReady= */ false))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAudioFocusRequest()).isNull();
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ false, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAudioFocusRequest()).isNull();
+    assertThat(
+            audioFocusManager.handleSetPlayWhenReady(/* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+  }
+
+  @Test
+  public void onAudioFocusChange_withDuckEnabled_volumeReducedAndRestored() {
+    // Ensure that the volume multiplier is adjusted when audio focus is lost to
+    // AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK, and returns to the default value after focus is
+    // regained.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+    assertThat(testPlayerControl.lastVolumeMultiplier).isLessThan(1.0f);
+    assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(NO_COMMAND_RECEIVED);
+    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+    assertThat(testPlayerControl.lastVolumeMultiplier).isEqualTo(1.0f);
+  }
+
+  @Test
+  public void onAudioFocusChange_withPausedWhenDucked_sendsCommandWaitForCallback() {
+    // Ensure that the player is commanded to pause when audio focus is lost with
+    // AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK and the content type is CONTENT_TYPE_SPEECH.
+    AudioAttributes media =
+        new AudioAttributes.Builder()
+            .setUsage(C.USAGE_MEDIA)
+            .setContentType(C.CONTENT_TYPE_SPEECH)
+            .build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+    assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
+    assertThat(testPlayerControl.lastVolumeMultiplier).isEqualTo(1.0f);
+    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+    assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+  }
+
+  @Test
+  public void onAudioFocusChange_withTransientLost_sendsCommandWaitForCallback() {
+    // Ensure that the player is commanded to pause when audio focus is lost with
+    // AUDIOFOCUS_LOSS_TRANSIENT.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);
+    assertThat(testPlayerControl.lastVolumeMultiplier).isEqualTo(1.0f);
+    assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
+  }
+
+  @Test
+  public void onAudioFocusChange_withAudioFocusLost_sendsDoNotPlayAndAbandondsFocus() {
+    // Ensure that AUDIOFOCUS_LOSS causes AudioFocusManager to pause playback and abandon audio
+    // focus.
+    AudioAttributes media =
+        new AudioAttributes.Builder()
+            .setUsage(C.USAGE_MEDIA)
+            .setContentType(C.CONTENT_TYPE_SPEECH)
+            .build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
+
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
+    assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener())
+        .isEqualTo(request.listener);
+  }
+
+  @Test
+  public void handleStop_withAudioFocus_abandonsAudioFocus() {
+    // Ensure that handleStop causes AudioFocusManager to abandon audio focus.
+    AudioAttributes media =
+        new AudioAttributes.Builder()
+            .setUsage(C.USAGE_MEDIA)
+            .setContentType(C.CONTENT_TYPE_SPEECH)
+            .build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
+
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    audioFocusManager.handleStop();
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener())
+        .isEqualTo(request.listener);
+  }
+
+  @Test
+  public void handleStop_withoutAudioFocus_stillAbandonsFocus() {
+    // Ensure that handleStop causes AudioFocusManager to call through to abandon audio focus
+    // even if focus wasn't requested.
+    AudioAttributes media =
+        new AudioAttributes.Builder()
+            .setUsage(C.USAGE_MEDIA)
+            .setContentType(C.CONTENT_TYPE_SPEECH)
+            .build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ false, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request).isNull();
+
+    audioFocusManager.handleStop();
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNotNull();
+  }
+
+  @Test
+  public void handleStop_withoutHandlingAudioFocus_isNoOp() {
+    // Ensure that handleStop is a no-op if audio focus isn't handled.
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ false, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request).isNull();
+
+    audioFocusManager.handleStop();
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
+  }
+
+  private static class TestPlayerControl implements AudioFocusManager.PlayerControl {
+    private float lastVolumeMultiplier = 1.0f;
+    private int lastPlayerCommand = NO_COMMAND_RECEIVED;
+
+    @Override
+    public void setVolumeMultiplier(float volumeMultiplier) {
+      lastVolumeMultiplier = volumeMultiplier;
+    }
+
+    @Override
+    public void executePlayerCommand(int playerCommand) {
+      lastPlayerCommand = playerCommand;
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java
index 115862074d..bd559218c6 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java
@@ -210,8 +210,8 @@ public void testSkipInAlternatingTestSignal_hasCorrectOutputAndSkippedFrameCount
         process(silenceSkippingAudioProcessor, inputBufferProvider, INPUT_BUFFER_SIZE);
 
     // The right number of frames are skipped/output.
-    assertThat(totalOutputFrames).isEqualTo(53990);
-    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(46010);
+    assertThat(totalOutputFrames).isEqualTo(57980);
+    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(42020);
   }
 
   @Test
@@ -240,8 +240,8 @@ public void testSkipWithSmallerInputBufferSize_hasCorrectOutputAndSkippedFrameCo
         process(silenceSkippingAudioProcessor, inputBufferProvider, /* inputBufferSize= */ 80);
 
     // The right number of frames are skipped/output.
-    assertThat(totalOutputFrames).isEqualTo(53990);
-    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(46010);
+    assertThat(totalOutputFrames).isEqualTo(57980);
+    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(42020);
   }
 
   @Test
@@ -270,8 +270,8 @@ public void testSkipWithLargerInputBufferSize_hasCorrectOutputAndSkippedFrameCou
         process(silenceSkippingAudioProcessor, inputBufferProvider, /* inputBufferSize= */ 120);
 
     // The right number of frames are skipped/output.
-    assertThat(totalOutputFrames).isEqualTo(53990);
-    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(46010);
+    assertThat(totalOutputFrames).isEqualTo(57980);
+    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(42020);
   }
 
   @Test
@@ -401,8 +401,8 @@ public Pcm16BitAudioBuilder(int channelCount, int frameCount) {
     public void appendFrames(int count, short... channelLevels) {
       Assertions.checkState(!built);
       for (int i = 0; i < count; i += channelCount) {
-        for (int j = 0; j < channelLevels.length; j++) {
-          buffer.put(channelLevels[j]);
+        for (short channelLevel : channelLevels) {
+          buffer.put(channelLevel);
         }
       }
     }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
index 2b3bdd6a2f..2b740de113 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
@@ -96,7 +96,7 @@ public void testEquals() {
   }
 
   @Test
-  @Deprecated
+  @SuppressWarnings("deprecation")
   public void testGetByUuid() {
     // Basic matching.
     DrmInitData testInitData = new DrmInitData(DATA_1, DATA_2);
@@ -130,6 +130,7 @@ public void testGetByIndex() {
   }
 
   @Test
+  @SuppressWarnings("deprecation")
   public void testSchemeDatasWithSameUuid() {
     DrmInitData testInitData = new DrmInitData(DATA_1, DATA_1B);
     assertThat(testInitData.schemeDataCount).isEqualTo(2);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java
new file mode 100644
index 0000000000..0fa33dd348
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.extractor;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link ConstantBitrateSeekMap}. */
+@RunWith(RobolectricTestRunner.class)
+public final class ConstantBitrateSeekMapTest {
+
+  private ConstantBitrateSeekMap constantBitrateSeekMap;
+
+  @Test
+  public void testIsSeekable_forKnownInputLength_returnSeekable() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 1000,
+            /* firstFrameBytePosition= */ 0,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    assertThat(constantBitrateSeekMap.isSeekable()).isTrue();
+  }
+
+  @Test
+  public void testIsSeekable_forUnknownInputLength_returnUnseekable() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ C.LENGTH_UNSET,
+            /* firstFrameBytePosition= */ 0,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    assertThat(constantBitrateSeekMap.isSeekable()).isFalse();
+  }
+
+  @Test
+  public void testGetSeekPoints_forUnseekableInput_returnSeekPoint0() {
+    int firstBytePosition = 100;
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ C.LENGTH_UNSET,
+            /* firstFrameBytePosition= */ firstBytePosition,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 123);
+    assertThat(seekPoints.first.timeUs).isEqualTo(0);
+    assertThat(seekPoints.first.position).isEqualTo(firstBytePosition);
+    assertThat(seekPoints.second).isEqualTo(seekPoints.first);
+  }
+
+  @Test
+  public void testGetDurationUs_forKnownInputLength_returnCorrectDuration() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    // Bitrate = 8000 (bits/s) = 1000 (bytes/s)
+    // FrameSize = 100 (bytes), so 1 frame = 1s = 100_000 us
+    // Input length = 2300 (bytes), first frame = 100, so duration = 2_200_000 us.
+    assertThat(constantBitrateSeekMap.getDurationUs()).isEqualTo(2_200_000);
+  }
+
+  @Test
+  public void testGetDurationUs_forUnnnownInputLength_returnUnknownDuration() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ C.LENGTH_UNSET,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    assertThat(constantBitrateSeekMap.getDurationUs()).isEqualTo(C.TIME_UNSET);
+  }
+
+  @Test
+  public void testGetSeekPoints_forSeekableInput_forSyncPosition0_return1SeekPoint() {
+    int firstBytePosition = 100;
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ firstBytePosition,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 0);
+    assertThat(seekPoints.first.timeUs).isEqualTo(0);
+    assertThat(seekPoints.first.position).isEqualTo(firstBytePosition);
+    assertThat(seekPoints.second).isEqualTo(seekPoints.first);
+  }
+
+  @Test
+  public void testGetSeekPoints_forSeekableInput_forSeekPointAtSyncPosition_return1SeekPoint() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 1_200_000);
+    // Bitrate = 8000 (bits/s) = 1000 (bytes/s)
+    // FrameSize = 100 (bytes), so 1 frame = 1s = 100_000 us
+    assertThat(seekPoints.first.timeUs).isEqualTo(1_200_000);
+    assertThat(seekPoints.first.position).isEqualTo(1300);
+    assertThat(seekPoints.second).isEqualTo(seekPoints.first);
+  }
+
+  @Test
+  public void testGetSeekPoints_forSeekableInput_forNonSyncSeekPosition_return2SeekPoints() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 345_678);
+    // Bitrate = 8000 (bits/s) = 1000 (bytes/s)
+    // FrameSize = 100 (bytes), so 1 frame = 1s = 100_000 us
+    assertThat(seekPoints.first.timeUs).isEqualTo(300_000);
+    assertThat(seekPoints.first.position).isEqualTo(400);
+    assertThat(seekPoints.second.timeUs).isEqualTo(400_000);
+    assertThat(seekPoints.second.position).isEqualTo(500);
+  }
+
+  @Test
+  public void testGetSeekPoints_forSeekableInput_forSeekPointWithinLastFrame_return1SeekPoint() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 2_123_456);
+    assertThat(seekPoints.first.timeUs).isEqualTo(2_100_000);
+    assertThat(seekPoints.first.position).isEqualTo(2_200);
+    assertThat(seekPoints.second).isEqualTo(seekPoints.first);
+  }
+
+  @Test
+  public void testGetSeekPoints_forSeekableInput_forSeekPointAtEndOfStream_return1SeekPoint() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 2_200_000);
+    assertThat(seekPoints.first.timeUs).isEqualTo(2_100_000);
+    assertThat(seekPoints.first.position).isEqualTo(2_200);
+    assertThat(seekPoints.second).isEqualTo(seekPoints.first);
+  }
+
+  @Test
+  public void testGetTimeUsAtPosition_forPosition0_return0() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    long timeUs = constantBitrateSeekMap.getTimeUsAtPosition(0);
+    assertThat(timeUs).isEqualTo(0);
+  }
+
+  @Test
+  public void testGetTimeUsAtPosition_forPositionWithinStream_returnCorrectTime() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    long timeUs = constantBitrateSeekMap.getTimeUsAtPosition(1234);
+    assertThat(timeUs).isEqualTo(1_134_000);
+  }
+
+  @Test
+  public void testGetTimeUsAtPosition_forPositionAtEndOfStream_returnStreamDuration() {
+    constantBitrateSeekMap =
+        new ConstantBitrateSeekMap(
+            /* inputLength= */ 2_300,
+            /* firstFrameBytePosition= */ 100,
+            /* bitrate= */ 8_000,
+            /* frameSize= */ 100);
+    long timeUs = constantBitrateSeekMap.getTimeUsAtPosition(2300);
+    assertThat(timeUs).isEqualTo(constantBitrateSeekMap.getDurationUs());
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
index a96dfaf2f8..8b26361578 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
@@ -338,6 +338,23 @@ public void testPeekFully() throws Exception {
     }
   }
 
+  @Test
+  public void testPeekFullyAfterEofExceptionPeeksAsExpected() throws Exception {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length + 10];
+
+    try {
+      input.peekFully(target, /* offset= */ 0, target.length);
+      fail();
+    } catch (EOFException expected) {
+      // Do nothing. Expected.
+    }
+    input.peekFully(target, /* offset= */ 0, /* length= */ TEST_DATA.length);
+
+    assertThat(input.getPeekPosition()).isEqualTo(TEST_DATA.length);
+    assertThat(Arrays.equals(TEST_DATA, Arrays.copyOf(target, TEST_DATA.length))).isTrue();
+  }
+
   @Test
   public void testResetPeekPosition() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java
index a397f70886..f43f356482 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
-import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.metadata.id3.Id3DecoderTest;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import java.io.IOException;
@@ -95,12 +94,8 @@ public void testPeekId3Data_returnId3TagAccordingToGivenPredicate_ifId3TagPresen
     Metadata metadata =
         id3Peeker.peekId3Data(
             input,
-            new Id3Decoder.FramePredicate() {
-              @Override
-              public boolean evaluate(int majorVersion, int id0, int id1, int id2, int id3) {
-                return id0 == 'C' && id1 == 'O' && id2 == 'M' && id3 == 'M';
-              }
-            });
+            (majorVersion, id0, id1, id2, id3) ->
+                id0 == 'C' && id1 == 'O' && id2 == 'M' && id3 == 'M');
     assertThat(metadata.length()).isEqualTo(1);
 
     CommentFrame commentFrame = (CommentFrame) metadata.get(0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java
new file mode 100644
index 0000000000..9f9051087d
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.amr;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer2.testutil.FakeTrackOutput;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import java.io.IOException;
+import java.util.List;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link AmrExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AmrExtractorSeekTest {
+
+  private static final Random random = new Random(1234L);
+
+  private static final String NARROW_BAND_AMR_FILE = "amr/sample_nb.amr";
+  private static final int NARROW_BAND_FILE_DURATION_US = 4_360_000;
+
+  private static final String WIDE_BAND_AMR_FILE = "amr/sample_wb.amr";
+  private static final int WIDE_BAND_FILE_DURATION_US = 3_380_000;
+
+  private FakeTrackOutput expectedTrackOutput;
+  private DefaultDataSource dataSource;
+
+  @Before
+  public void setUp() {
+    dataSource =
+        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+            .createDataSource();
+  }
+
+  @Test
+  public void testAmrExtractorReads_returnSeekableSeekMap_forNarrowBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = NARROW_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+
+    AmrExtractor extractor = createAmrExtractor();
+    SeekMap seekMap =
+        TestUtil.extractSeekMap(extractor, new FakeExtractorOutput(), dataSource, fileUri);
+
+    assertThat(seekMap).isNotNull();
+    assertThat(seekMap.getDurationUs()).isEqualTo(NARROW_BAND_FILE_DURATION_US);
+    assertThat(seekMap.isSeekable()).isTrue();
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingToPositionInFile_extractsCorrectFrame_forNarrowBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = NARROW_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long targetSeekTimeUs = 980_000;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekToEoF_extractsLastFrame_forNarrowBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = NARROW_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long targetSeekTimeUs = seekMap.getDurationUs();
+
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingBackward_extractsCorrectFrames_forNarrowBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = NARROW_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long firstSeekTimeUs = 980_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 0;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingForward_extractsCorrectFrames_forNarrowBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = NARROW_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long firstSeekTimeUs = 980_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 1_200_000;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesRandomSeeks_extractsCorrectFrames_forNarrowBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = NARROW_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(NARROW_BAND_FILE_DURATION_US + 1);
+      int extractedFrameIndex =
+          TestUtil.seekToTimeUs(
+              extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+      assertThat(extractedFrameIndex).isNotEqualTo(-1);
+      assertFirstFrameAfterSeekContainTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedFrameIndex);
+    }
+  }
+
+  @Test
+  public void testAmrExtractorReads_returnSeekableSeekMap_forWideBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = WIDE_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+
+    AmrExtractor extractor = createAmrExtractor();
+    SeekMap seekMap =
+        TestUtil.extractSeekMap(extractor, new FakeExtractorOutput(), dataSource, fileUri);
+
+    assertThat(seekMap).isNotNull();
+    assertThat(seekMap.getDurationUs()).isEqualTo(WIDE_BAND_FILE_DURATION_US);
+    assertThat(seekMap.isSeekable()).isTrue();
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingToPositionInFile_extractsCorrectFrame_forWideBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = WIDE_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long targetSeekTimeUs = 980_000;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekToEoF_extractsLastFrame_forWideBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = WIDE_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long targetSeekTimeUs = seekMap.getDurationUs();
+
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingBackward_extractsCorrectFrames_forWideBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = WIDE_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long firstSeekTimeUs = 980_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 0;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingForward_extractsCorrectFrames_forWideBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = WIDE_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long firstSeekTimeUs = 980_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 1_200_000;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesRandomSeeks_extractsCorrectFrames_forWideBandAmr()
+      throws IOException, InterruptedException {
+    String fileName = WIDE_BAND_AMR_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AmrExtractor extractor = createAmrExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(NARROW_BAND_FILE_DURATION_US + 1);
+      int extractedFrameIndex =
+          TestUtil.seekToTimeUs(
+              extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+      assertThat(extractedFrameIndex).isNotEqualTo(-1);
+      assertFirstFrameAfterSeekContainTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedFrameIndex);
+    }
+  }
+
+  // Internal methods
+
+  private AmrExtractor createAmrExtractor() {
+    return new AmrExtractor(AmrExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING);
+  }
+
+  private void assertFirstFrameAfterSeekContainTargetSeekTime(
+      FakeTrackOutput trackOutput, long seekTimeUs, int firstFrameIndexAfterSeek) {
+    int expectedSampleIndex = findTargetFrameInExpectedOutput(seekTimeUs);
+    // Assert that after seeking, the first sample frame written to output contains the sample
+    // at seek time.
+    trackOutput.assertSample(
+        firstFrameIndexAfterSeek,
+        expectedTrackOutput.getSampleData(expectedSampleIndex),
+        expectedTrackOutput.getSampleTimeUs(expectedSampleIndex),
+        expectedTrackOutput.getSampleFlags(expectedSampleIndex),
+        expectedTrackOutput.getSampleCryptoData(expectedSampleIndex));
+  }
+
+  private int findTargetFrameInExpectedOutput(long seekTimeUs) {
+    List<Long> sampleTimes = expectedTrackOutput.getSampleTimesUs();
+    for (int i = 0; i < sampleTimes.size() - 1; i++) {
+      long currentSampleTime = sampleTimes.get(i);
+      long nextSampleTime = sampleTimes.get(i + 1);
+      if (currentSampleTime <= seekTimeUs && nextSampleTime > seekTimeUs) {
+        return i;
+      }
+    }
+    return sampleTimes.size() - 1;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java
index b46612e7c3..c3c33e3350 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java
@@ -179,12 +179,26 @@ public void testRead_amrWb_returnParserException_forInvalidFrameHeader()
 
   @Test
   public void testExtractingNarrowBandSamples() throws Exception {
-    ExtractorAsserts.assertBehavior(createAmrExtractorFactory(), "amr/sample_nb.amr");
+    ExtractorAsserts.assertBehavior(
+        createAmrExtractorFactory(/* withSeeking= */ false), "amr/sample_nb.amr");
   }
 
   @Test
   public void testExtractingWideBandSamples() throws Exception {
-    ExtractorAsserts.assertBehavior(createAmrExtractorFactory(), "amr/sample_wb.amr");
+    ExtractorAsserts.assertBehavior(
+        createAmrExtractorFactory(/* withSeeking= */ false), "amr/sample_wb.amr");
+  }
+
+  @Test
+  public void testExtractingNarrowBandSamples_withSeeking() throws Exception {
+    ExtractorAsserts.assertBehavior(
+        createAmrExtractorFactory(/* withSeeking= */ true), "amr/sample_nb_cbr.amr");
+  }
+
+  @Test
+  public void testExtractingWideBandSamples_withSeeking() throws Exception {
+    ExtractorAsserts.assertBehavior(
+        createAmrExtractorFactory(/* withSeeking= */ true), "amr/sample_wb_cbr.amr");
   }
 
   private byte[] newWideBandAmrFrameWithType(int frameType) {
@@ -235,11 +249,12 @@ private static FakeExtractorInput fakeExtractorInputWithData(byte[] data) {
   }
 
   @NonNull
-  private static ExtractorAsserts.ExtractorFactory createAmrExtractorFactory() {
-    return new ExtractorAsserts.ExtractorFactory() {
-      @Override
-      public Extractor create() {
+  private static ExtractorAsserts.ExtractorFactory createAmrExtractorFactory(boolean withSeeking) {
+    return () -> {
+      if (!withSeeking) {
         return new AmrExtractor();
+      } else {
+        return new AmrExtractor(AmrExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING);
       }
     };
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
index 5a093988dd..316148d9b9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -28,13 +26,6 @@
 
   @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new FlvExtractor();
-          }
-        },
-        "flv/sample.flv");
+    ExtractorAsserts.assertBehavior(FlvExtractor::new, "flv/sample.flv");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
index 4a0f87a80a..2e673037d0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -28,37 +26,17 @@
 
   @Test
   public void testMkvSample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new MatroskaExtractor();
-          }
-        },
-        "mkv/sample.mkv");
+    ExtractorAsserts.assertBehavior(MatroskaExtractor::new, "mkv/sample.mkv");
   }
 
   @Test
   public void testWebmSubsampleEncryption() throws Exception {
     ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new MatroskaExtractor();
-          }
-        },
-        "mkv/subsample_encrypted_noaltref.webm");
+        MatroskaExtractor::new, "mkv/subsample_encrypted_noaltref.webm");
   }
 
   @Test
   public void testWebmSubsampleEncryptionWithAltrefFrames() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new MatroskaExtractor();
-          }
-        },
-        "mkv/subsample_encrypted_altref.webm");
+    ExtractorAsserts.assertBehavior(MatroskaExtractor::new, "mkv/subsample_encrypted_altref.webm");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
index b977766a1c..62a4f1a193 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -28,25 +26,11 @@
 
   @Test
   public void testMp3Sample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new Mp3Extractor();
-          }
-        },
-        "mp3/bear.mp3");
+    ExtractorAsserts.assertBehavior(Mp3Extractor::new, "mp3/bear.mp3");
   }
 
   @Test
   public void testTrimmedMp3Sample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new Mp3Extractor();
-          }
-        },
-        "mp3/play-trimmed.mp3");
+    ExtractorAsserts.assertBehavior(Mp3Extractor::new, "mp3/play-trimmed.mp3");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
index 176211acb8..f9362f9cda 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -33,13 +32,13 @@
   @Test
   public void testSample() throws Exception {
     ExtractorAsserts.assertBehavior(
-        getExtractorFactory(Collections.<Format>emptyList()), "mp4/sample_fragmented.mp4");
+        getExtractorFactory(Collections.emptyList()), "mp4/sample_fragmented.mp4");
   }
 
   @Test
   public void testSampleSeekable() throws Exception {
     ExtractorAsserts.assertBehavior(
-        getExtractorFactory(Collections.<Format>emptyList()), "mp4/sample_fragmented_seekable.mp4");
+        getExtractorFactory(Collections.emptyList()), "mp4/sample_fragmented_seekable.mp4");
   }
 
   @Test
@@ -53,11 +52,6 @@ public void testSampleWithSeiPayloadParsing() throws Exception {
   }
 
   private static ExtractorFactory getExtractorFactory(final List<Format> closedCaptionFormats) {
-    return new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new FragmentedMp4Extractor(0, null, null, null, closedCaptionFormats);
-      }
-    };
+    return () -> new FragmentedMp4Extractor(0, null, null, null, closedCaptionFormats);
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
index f1812a69c4..8850a755be 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
@@ -16,9 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.annotation.TargetApi;
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -30,13 +28,6 @@
 
   @Test
   public void testMp4Sample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new Mp4Extractor();
-          }
-        },
-        "mp4/sample.mp4");
+    ExtractorAsserts.assertBehavior(Mp4Extractor::new, "mp4/sample.mp4");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
index 993bb86b48..1b6df9c5a4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
@@ -35,7 +35,13 @@
   @Test
   public void testSetupWithUnsetEndPositionFails() {
     try {
-      new DefaultOggSeeker(0, C.LENGTH_UNSET, new TestStreamReader(), 1, 1);
+      new DefaultOggSeeker(
+          /* startPosition= */ 0,
+          /* endPosition= */ C.LENGTH_UNSET,
+          /* streamReader= */ new TestStreamReader(),
+          /* firstPayloadPageSize= */ 1,
+          /* firstPayloadPageGranulePosition= */ 1,
+          /* firstPayloadPageIsLastPage= */ false);
       fail();
     } catch (IllegalArgumentException e) {
       // ignored
@@ -56,11 +62,12 @@ private void testSeeking(Random random) throws IOException, InterruptedException
     TestStreamReader streamReader = new TestStreamReader();
     DefaultOggSeeker oggSeeker =
         new DefaultOggSeeker(
-            0,
-            testFile.data.length,
-            streamReader,
-            testFile.firstPayloadPageSize,
-            testFile.firstPayloadPageGranulePosition);
+            /* startPosition= */ 0,
+            /* endPosition= */ testFile.data.length,
+            /* streamReader= */ streamReader,
+            /* firstPayloadPageSize= */ testFile.firstPayloadPageSize,
+            /* firstPayloadPageGranulePosition= */ testFile.firstPayloadPageGranulePosition,
+            /* firstPayloadPageIsLastPage= */ false);
     OggPageHeader pageHeader = new OggPageHeader();
 
     while (true) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
index be771ac3b9..ef38282691 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
@@ -85,8 +85,14 @@ public void testSkipToNextPageNoMatch() throws Exception {
 
   private static void skipToNextPage(ExtractorInput extractorInput)
       throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, extractorInput.getLength(),
-        new FlacReader(), 1, 2);
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* startPosition= */ 0,
+            /* endPosition= */ extractorInput.getLength(),
+            /* streamReader= */ new FlacReader(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
     while (true) {
       try {
         oggSeeker.skipToNextPage(extractorInput);
@@ -157,7 +163,14 @@ public void testSkipToPageOfGranuleAfterTargetPage() throws IOException, Interru
 
   private void skipToPageOfGranule(ExtractorInput input, long granule,
       long elapsedSamplesExpected) throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader(), 1, 2);
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* startPosition= */ 0,
+            /* endPosition= */ input.getLength(),
+            /* streamReader= */ new FlacReader(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
     while (true) {
       try {
         assertThat(oggSeeker.skipToPageOfGranule(input, granule, -1))
@@ -211,7 +224,14 @@ public void testReadGranuleOfLastPageWithUnboundedLength()
 
   private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
       throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader(), 1, 2);
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* startPosition= */ 0,
+            /* endPosition= */ input.getLength(),
+            /* streamReader= */ new FlacReader(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
     while (true) {
       try {
         assertThat(oggSeeker.readGranuleOfLastPage(input)).isEqualTo(expected);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
index 20808f73f2..289c168725 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
@@ -17,7 +17,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
@@ -32,13 +31,7 @@
 @RunWith(RobolectricTestRunner.class)
 public final class OggExtractorTest {
 
-  private static final ExtractorFactory OGG_EXTRACTOR_FACTORY =
-      new ExtractorFactory() {
-        @Override
-        public Extractor create() {
-          return new OggExtractor();
-        }
-      };
+  private static final ExtractorFactory OGG_EXTRACTOR_FACTORY = OggExtractor::new;
 
   @Test
   public void testOpus() throws Exception {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
index 9632577e82..62ad774fd3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
@@ -17,9 +17,7 @@
 
 import android.annotation.TargetApi;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.util.MimeTypes;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,21 +31,18 @@
   @Test
   public void testRawCcSample() throws Exception {
     ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new RawCcExtractor(
+        () ->
+            new RawCcExtractor(
                 Format.createTextContainerFormat(
-                    null,
-                    null,
-                    MimeTypes.APPLICATION_CEA608,
-                    "cea608",
-                    Format.NO_VALUE,
-                    0,
-                    null,
-                    1));
-          }
-        },
+                    /* id= */ null,
+                    /* label= */ null,
+                    /* containerMimeType= */ null,
+                    /* sampleMimeType= */ MimeTypes.APPLICATION_CEA608,
+                    /* codecs= */ "cea608",
+                    /* bitrate= */ Format.NO_VALUE,
+                    /* selectionFlags= */ 0,
+                    /* language= */ null,
+                    /* accessibilityChannel= */ 1)),
         "rawcc/sample.rawcc");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
index ec7afeeeab..92dcf10f19 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -27,14 +25,12 @@
 public final class Ac3ExtractorTest {
 
   @Test
-  public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new Ac3Extractor();
-          }
-        },
-        "ts/sample.ac3");
+  public void testAc3Sample() throws Exception {
+    ExtractorAsserts.assertBehavior(Ac3Extractor::new, "ts/sample.ac3");
+  }
+
+  @Test
+  public void testEAc3Sample() throws Exception {
+    ExtractorAsserts.assertBehavior(Ac3Extractor::new, "ts/sample.eac3");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java
new file mode 100644
index 0000000000..c0a35427b0
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer2.testutil.FakeTrackOutput;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link AdtsExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AdtsExtractorSeekTest {
+
+  private static final Random random = new Random(1234L);
+
+  private static final String TEST_FILE = "ts/sample.adts";
+  private static final int FILE_DURATION_US = 3_356_772;
+  private static final long DELTA_TIMESTAMP_THRESHOLD_US = 200_000;
+
+  private FakeTrackOutput expectedTrackOutput;
+  private DefaultDataSource dataSource;
+
+  @Before
+  public void setUp() {
+    dataSource =
+        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+            .createDataSource();
+  }
+
+  @Test
+  public void testAdtsExtractorReads_returnSeekableSeekMap()
+      throws IOException, InterruptedException {
+    String fileName = TEST_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+
+    AdtsExtractor extractor = createAdtsExtractor();
+    SeekMap seekMap =
+        TestUtil.extractSeekMap(extractor, new FakeExtractorOutput(), dataSource, fileUri);
+
+    assertThat(seekMap).isNotNull();
+    assertThat(seekMap.getDurationUs()).isEqualTo(FILE_DURATION_US);
+    assertThat(seekMap.isSeekable()).isTrue();
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingToPositionInFile_extractsCorrectSample()
+      throws IOException, InterruptedException {
+    String fileName = TEST_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+
+    AdtsExtractor extractor = createAdtsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long targetSeekTimeUs = 980_000;
+    int extractedSampleIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedSampleIndex).isNotEqualTo(-1);
+    assertFirstSampleAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedSampleIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekToEoF_extractsLastSample()
+      throws IOException, InterruptedException {
+    String fileName = TEST_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AdtsExtractor extractor = createAdtsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long targetSeekTimeUs = seekMap.getDurationUs();
+
+    int extractedSampleIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedSampleIndex).isNotEqualTo(-1);
+    assertFirstSampleAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedSampleIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingBackward_extractsCorrectSamples()
+      throws IOException, InterruptedException {
+    String fileName = TEST_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AdtsExtractor extractor = createAdtsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long firstSeekTimeUs = 980_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 0;
+    int extractedSampleIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedSampleIndex).isNotEqualTo(-1);
+    assertFirstSampleAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedSampleIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesSeekingForward_extractsCorrectSamples()
+      throws IOException, InterruptedException {
+    String fileName = TEST_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AdtsExtractor extractor = createAdtsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long firstSeekTimeUs = 980_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 1_200_000;
+    int extractedSampleIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedSampleIndex).isNotEqualTo(-1);
+    assertFirstSampleAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedSampleIndex);
+  }
+
+  @Test
+  public void testSeeking_handlesRandomSeeks_extractsCorrectSamples()
+      throws IOException, InterruptedException {
+    String fileName = TEST_FILE;
+    Uri fileUri = TestUtil.buildAssetUri(fileName);
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+            .trackOutputs
+            .get(0);
+    AdtsExtractor extractor = createAdtsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(0);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(FILE_DURATION_US + 1);
+      int extractedSampleIndex =
+          TestUtil.seekToTimeUs(
+              extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+      assertThat(extractedSampleIndex).isNotEqualTo(-1);
+      assertFirstSampleAfterSeekContainTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedSampleIndex);
+    }
+  }
+
+  // Internal methods
+
+  private static AdtsExtractor createAdtsExtractor() {
+    return new AdtsExtractor(
+        /* firstStreamSampleTimestampUs= */ 0,
+        /* flags= */ AdtsExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING);
+  }
+
+  private void assertFirstSampleAfterSeekContainTargetSeekTime(
+      FakeTrackOutput trackOutput, long seekTimeUs, int firstSampleIndexAfterSeek) {
+    long outputSampleTimeUs = trackOutput.getSampleTimeUs(firstSampleIndexAfterSeek);
+    int expectedSampleIndex =
+        findOutputSampleInExpectedOutput(trackOutput.getSampleData(firstSampleIndexAfterSeek));
+    // Assert that after seeking, the first sample written to output exists in the sample list
+    assertThat(expectedSampleIndex).isNotEqualTo(-1);
+    // Assert that the timestamp output for first sample after seek is near the seek point.
+    // For ADTS seeking, unfortunately we can't guarantee exact sample seeking, since most ADTS
+    // stream use VBR.
+    assertThat(Math.abs(outputSampleTimeUs - seekTimeUs)).isLessThan(DELTA_TIMESTAMP_THRESHOLD_US);
+    assertThat(
+            Math.abs(outputSampleTimeUs - expectedTrackOutput.getSampleTimeUs(expectedSampleIndex)))
+        .isLessThan(DELTA_TIMESTAMP_THRESHOLD_US);
+    trackOutput.assertSample(
+        firstSampleIndexAfterSeek,
+        expectedTrackOutput.getSampleData(expectedSampleIndex),
+        outputSampleTimeUs,
+        expectedTrackOutput.getSampleFlags(expectedSampleIndex),
+        expectedTrackOutput.getSampleCryptoData(expectedSampleIndex));
+  }
+
+  private int findOutputSampleInExpectedOutput(byte[] sampleData) {
+    for (int i = 0; i < expectedTrackOutput.getSampleCount(); i++) {
+      byte[] currentSampleData = expectedTrackOutput.getSampleData(i);
+      if (Arrays.equals(currentSampleData, sampleData)) {
+        return i;
+      }
+    }
+    return -1;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
index 048a23cd67..7f0db67133 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -28,13 +26,16 @@
 
   @Test
   public void testSample() throws Exception {
+    ExtractorAsserts.assertBehavior(AdtsExtractor::new, "ts/sample.adts");
+  }
+
+  @Test
+  public void testSample_withSeeking() throws Exception {
     ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new AdtsExtractor();
-          }
-        },
-        "ts/sample.adts");
+        () ->
+            new AdtsExtractor(
+                /* firstStreamSampleTimestampUs= */ 0,
+                /* flags= */ AdtsExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING),
+        "ts/sample_cbs.adts");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index 1098ba7563..62da914f5b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
@@ -93,14 +95,26 @@ public void testSkipToNextSampleResetsState() throws Exception {
     data =
         new ParsableByteArray(
             TestUtil.joinByteArrays(
+                ADTS_HEADER,
+                ADTS_CONTENT,
                 ADTS_HEADER,
                 ADTS_CONTENT,
                 // Adts sample missing the first sync byte
+                // The Reader should be able to read the next sample.
                 Arrays.copyOfRange(ADTS_HEADER, 1, ADTS_HEADER.length),
+                ADTS_CONTENT,
+                ADTS_HEADER,
                 ADTS_CONTENT));
     feed();
-    assertSampleCounts(0, 1);
-    adtsOutput.assertSample(0, ADTS_CONTENT, 0, C.BUFFER_FLAG_KEY_FRAME, null);
+    assertSampleCounts(0, 3);
+    for (int i = 0; i < 3; i++) {
+      adtsOutput.assertSample(
+          /* index= */ i,
+          /* data= */ ADTS_CONTENT,
+          /* timeUs= */ ADTS_SAMPLE_DURATION * i,
+          /* flags= */ C.BUFFER_FLAG_KEY_FRAME,
+          /* cryptoData= */ null);
+    }
   }
 
   @Test
@@ -186,7 +200,7 @@ private void feed() throws ParserException {
 
   private void maybeStartPacket() {
     if (firstFeed) {
-      adtsReader.packetStarted(0, true);
+      adtsReader.packetStarted(0, FLAG_DATA_ALIGNMENT_INDICATOR);
       firstFeed = false;
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java
new file mode 100644
index 0000000000..418b2726bf
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link PsDurationReader}. */
+@RunWith(RobolectricTestRunner.class)
+public final class PsDurationReaderTest {
+
+  private PsDurationReader tsDurationReader;
+  private PositionHolder seekPositionHolder;
+
+  @Before
+  public void setUp() {
+    tsDurationReader = new PsDurationReader();
+    seekPositionHolder = new PositionHolder();
+  }
+
+  @Test
+  public void testIsDurationReadPending_returnFalseByDefault() {
+    assertThat(tsDurationReader.isDurationReadFinished()).isFalse();
+  }
+
+  @Test
+  public void testReadDuration_returnsCorrectDuration() throws IOException, InterruptedException {
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ps"))
+            .build();
+
+    int result = Extractor.RESULT_CONTINUE;
+    while (!tsDurationReader.isDurationReadFinished()) {
+      result = tsDurationReader.readDuration(input, seekPositionHolder);
+      if (result == Extractor.RESULT_SEEK) {
+        input.setPosition((int) seekPositionHolder.position);
+      }
+    }
+    assertThat(result).isNotEqualTo(Extractor.RESULT_END_OF_INPUT);
+    assertThat(tsDurationReader.getDurationUs()).isEqualTo(766);
+  }
+
+  @Test
+  public void testReadDuration_midStream_returnsCorrectDuration()
+      throws IOException, InterruptedException {
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ps"))
+            .build();
+
+    input.setPosition(1234);
+    int result = Extractor.RESULT_CONTINUE;
+    while (!tsDurationReader.isDurationReadFinished()) {
+      result = tsDurationReader.readDuration(input, seekPositionHolder);
+      if (result == Extractor.RESULT_SEEK) {
+        input.setPosition((int) seekPositionHolder.position);
+      }
+    }
+    assertThat(result).isNotEqualTo(Extractor.RESULT_END_OF_INPUT);
+    assertThat(tsDurationReader.getDurationUs()).isEqualTo(766);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java
new file mode 100644
index 0000000000..33be3a26fd
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer2.testutil.FakeTrackOutput;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Seeking tests for {@link PsExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class PsExtractorSeekTest {
+
+  private static final String PS_FILE_PATH = "ts/elephants_dream.mpg";
+  private static final int DURATION_US = 30436333;
+  private static final int VIDEO_TRACK_ID = 224;
+  private static final long DELTA_TIMESTAMP_THRESHOLD_US = 500_000L;
+  private static final Random random = new Random(1234L);
+
+  private FakeExtractorOutput expectedOutput;
+  private FakeTrackOutput expectedTrackOutput;
+
+  private DefaultDataSource dataSource;
+  private PositionHolder positionHolder;
+  private long totalInputLength;
+
+  @Before
+  public void setUp() throws IOException, InterruptedException {
+    expectedOutput = new FakeExtractorOutput();
+    positionHolder = new PositionHolder();
+    extractAllSamplesFromFileToExpectedOutput(RuntimeEnvironment.application, PS_FILE_PATH);
+    expectedTrackOutput = expectedOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    dataSource =
+        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+            .createDataSource();
+    totalInputLength = readInputLength();
+  }
+
+  @Test
+  public void testPsExtractorReads_nonSeekTableFile_returnSeekableSeekMap()
+      throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    SeekMap seekMap = extractSeekMapAndTracks(extractor, new FakeExtractorOutput());
+
+    assertThat(seekMap).isNotNull();
+    assertThat(seekMap.getDurationUs()).isEqualTo(DURATION_US);
+    assertThat(seekMap.isSeekable()).isTrue();
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekingToPositionInFile_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = extractSeekMapAndTracks(extractor, extractorOutput);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    long targetSeekTimeUs = 987_000;
+    int extractedFrameIndex = seekToTimeUs(extractor, seekMap, targetSeekTimeUs, trackOutput);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainsTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekToEoF() throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = extractSeekMapAndTracks(extractor, extractorOutput);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    long targetSeekTimeUs = seekMap.getDurationUs();
+
+    int extractedFrameIndex = seekToTimeUs(extractor, seekMap, targetSeekTimeUs, trackOutput);
+    // Assert that this seek will return a position at end of stream, without any frame.
+    assertThat(extractedFrameIndex).isEqualTo(-1);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekingBackward_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = extractSeekMapAndTracks(extractor, extractorOutput);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    long firstSeekTimeUs = 987_000;
+    seekToTimeUs(extractor, seekMap, firstSeekTimeUs, trackOutput);
+
+    long targetSeekTimeUs = 0;
+    int extractedFrameIndex = seekToTimeUs(extractor, seekMap, targetSeekTimeUs, trackOutput);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainsTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekingForward_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = extractSeekMapAndTracks(extractor, extractorOutput);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    long firstSeekTimeUs = 987_000;
+    seekToTimeUs(extractor, seekMap, firstSeekTimeUs, trackOutput);
+
+    long targetSeekTimeUs = 1_234_000;
+    int extractedFrameIndex = seekToTimeUs(extractor, seekMap, targetSeekTimeUs, trackOutput);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainsTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesRandomSeeks_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = extractSeekMapAndTracks(extractor, extractorOutput);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(DURATION_US + 1);
+      int extractedFrameIndex = seekToTimeUs(extractor, seekMap, targetSeekTimeUs, trackOutput);
+
+      assertThat(extractedFrameIndex).isNotEqualTo(-1);
+      assertFirstFrameAfterSeekContainsTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedFrameIndex);
+    }
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesRandomSeeksAfterReadingFileOnce_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    PsExtractor extractor = new PsExtractor();
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    readInputFileOnce(extractor, extractorOutput);
+    SeekMap seekMap = extractorOutput.seekMap;
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(VIDEO_TRACK_ID);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(DURATION_US + 1);
+      int extractedFrameIndex = seekToTimeUs(extractor, seekMap, targetSeekTimeUs, trackOutput);
+
+      assertThat(extractedFrameIndex).isNotEqualTo(-1);
+      assertFirstFrameAfterSeekContainsTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedFrameIndex);
+    }
+  }
+
+  // Internal methods
+
+  private long readInputLength() throws IOException {
+    DataSpec dataSpec =
+        new DataSpec(Uri.parse("asset:///" + PS_FILE_PATH), 0, C.LENGTH_UNSET, null);
+    long totalInputLength = dataSource.open(dataSpec);
+    Util.closeQuietly(dataSource);
+    return totalInputLength;
+  }
+
+  /**
+   * Seeks to the given seek time and keeps reading from input until we can extract at least one
+   * frame from the seek position, or until end-of-input is reached.
+   *
+   * @return The index of the first extracted frame written to the given {@code trackOutput} after
+   *     the seek is completed, or -1 if the seek is completed without any extracted frame.
+   */
+  private int seekToTimeUs(
+      PsExtractor psExtractor, SeekMap seekMap, long seekTimeUs, FakeTrackOutput trackOutput)
+      throws IOException, InterruptedException {
+    int numSampleBeforeSeek = trackOutput.getSampleCount();
+    SeekMap.SeekPoints seekPoints = seekMap.getSeekPoints(seekTimeUs);
+
+    long initialSeekLoadPosition = seekPoints.first.position;
+    psExtractor.seek(initialSeekLoadPosition, seekTimeUs);
+
+    positionHolder.position = C.POSITION_UNSET;
+    ExtractorInput extractorInput = getExtractorInputFromPosition(initialSeekLoadPosition);
+    int extractorReadResult = Extractor.RESULT_CONTINUE;
+    while (true) {
+      try {
+        // Keep reading until we can read at least one frame after seek
+        while (extractorReadResult == Extractor.RESULT_CONTINUE
+            && trackOutput.getSampleCount() == numSampleBeforeSeek) {
+          extractorReadResult = psExtractor.read(extractorInput, positionHolder);
+        }
+      } finally {
+        Util.closeQuietly(dataSource);
+      }
+
+      if (extractorReadResult == Extractor.RESULT_SEEK) {
+        extractorInput = getExtractorInputFromPosition(positionHolder.position);
+        extractorReadResult = Extractor.RESULT_CONTINUE;
+      } else if (extractorReadResult == Extractor.RESULT_END_OF_INPUT) {
+        return -1;
+      } else if (trackOutput.getSampleCount() > numSampleBeforeSeek) {
+        // First index after seek = num sample before seek.
+        return numSampleBeforeSeek;
+      }
+    }
+  }
+
+  private SeekMap extractSeekMapAndTracks(PsExtractor extractor, FakeExtractorOutput output)
+      throws IOException, InterruptedException {
+    ExtractorInput input = getExtractorInputFromPosition(0);
+    extractor.init(output);
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (true) {
+      try {
+        // Keep reading until we can get the seek map
+        while (readResult == Extractor.RESULT_CONTINUE
+            && (output.seekMap == null || !output.tracksEnded)) {
+          readResult = extractor.read(input, positionHolder);
+        }
+      } finally {
+        Util.closeQuietly(dataSource);
+      }
+
+      if (readResult == Extractor.RESULT_SEEK) {
+        input = getExtractorInputFromPosition(positionHolder.position);
+        readResult = Extractor.RESULT_CONTINUE;
+      } else if (readResult == Extractor.RESULT_END_OF_INPUT) {
+        throw new IOException("EOF encountered without seekmap");
+      }
+      if (output.seekMap != null) {
+        return output.seekMap;
+      }
+    }
+  }
+
+  private void readInputFileOnce(PsExtractor extractor, FakeExtractorOutput extractorOutput)
+      throws IOException, InterruptedException {
+    extractor.init(extractorOutput);
+    int readResult = Extractor.RESULT_CONTINUE;
+    ExtractorInput input = getExtractorInputFromPosition(0);
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      try {
+        while (readResult == Extractor.RESULT_CONTINUE) {
+          readResult = extractor.read(input, positionHolder);
+        }
+      } finally {
+        Util.closeQuietly(dataSource);
+      }
+      if (readResult == Extractor.RESULT_SEEK) {
+        input = getExtractorInputFromPosition(positionHolder.position);
+        readResult = Extractor.RESULT_CONTINUE;
+      }
+    }
+  }
+
+  private void assertFirstFrameAfterSeekContainsTargetSeekTime(
+      FakeTrackOutput trackOutput, long seekTimeUs, int firstFrameIndexAfterSeek) {
+    long outputSampleTimeUs = trackOutput.getSampleTimeUs(firstFrameIndexAfterSeek);
+    int expectedSampleIndex =
+        findOutputFrameInExpectedOutput(trackOutput.getSampleData(firstFrameIndexAfterSeek));
+    // Assert that after seeking, the first sample frame written to output exists in the sample list
+    assertThat(expectedSampleIndex).isNotEqualTo(C.INDEX_UNSET);
+
+    long sampleTimeUs = expectedTrackOutput.getSampleTimeUs(expectedSampleIndex);
+    if (sampleTimeUs != 0) {
+      // Assert that the timestamp output for first sample after seek is near the seek point.
+      // For Ps seeking, unfortunately we can't guarantee exact frame seeking, since PID timestamp
+      // is not too reliable.
+      assertThat(Math.abs(outputSampleTimeUs - seekTimeUs))
+          .isLessThan(DELTA_TIMESTAMP_THRESHOLD_US);
+    }
+    // Assert that the timestamp output for first sample after seek is near the actual sample
+    // at seek point.
+    // Note that the timestamp output for first sample after seek might *NOT* be equal to the
+    // timestamp of that same sample when reading from the beginning, because if first timestamp
+    // in the stream was not read before the seek, then the timestamp of the first sample after
+    // the seek is just approximated from the seek point.
+    assertThat(
+            Math.abs(outputSampleTimeUs - expectedTrackOutput.getSampleTimeUs(expectedSampleIndex)))
+        .isLessThan(DELTA_TIMESTAMP_THRESHOLD_US);
+    trackOutput.assertSample(
+        firstFrameIndexAfterSeek,
+        expectedTrackOutput.getSampleData(expectedSampleIndex),
+        outputSampleTimeUs,
+        expectedTrackOutput.getSampleFlags(expectedSampleIndex),
+        expectedTrackOutput.getSampleCryptoData(expectedSampleIndex));
+  }
+
+  private int findOutputFrameInExpectedOutput(byte[] sampleData) {
+    for (int i = 0; i < expectedTrackOutput.getSampleCount(); i++) {
+      byte[] currentSampleData = expectedTrackOutput.getSampleData(i);
+      if (Arrays.equals(currentSampleData, sampleData)) {
+        return i;
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
+  private ExtractorInput getExtractorInputFromPosition(long position) throws IOException {
+    DataSpec dataSpec =
+        new DataSpec(
+            Uri.parse("asset:///" + PS_FILE_PATH), position, C.LENGTH_UNSET, /* key= */ null);
+    dataSource.open(dataSpec);
+    return new DefaultExtractorInput(dataSource, position, totalInputLength);
+  }
+
+  private void extractAllSamplesFromFileToExpectedOutput(Context context, String fileName)
+      throws IOException, InterruptedException {
+    byte[] data = TestUtil.getByteArray(context, fileName);
+
+    PsExtractor extractor = new PsExtractor();
+    extractor.init(expectedOutput);
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
+
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      readResult = extractor.read(input, positionHolder);
+      if (readResult == Extractor.RESULT_SEEK) {
+        input.setPosition((int) positionHolder.position);
+      }
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
index 798f1ce5e3..0e0fd52175 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -28,13 +26,6 @@
 
   @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new PsExtractor();
-          }
-        },
-        "ts/sample.ps");
+    ExtractorAsserts.assertBehavior(PsExtractor::new, "ts/sample.ps");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index 713d986d21..7bff736b4a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_PAYLOAD_UNIT_START_INDICATOR;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
@@ -55,7 +56,7 @@ public void setUp() {
   public void testSingleOnePacketSection() {
     packetPayload[0] = 3;
     insertTableSection(4, (byte) 99, 3);
-    reader.consume(new ParsableByteArray(packetPayload), true);
+    reader.consume(new ParsableByteArray(packetPayload), FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(99));
   }
 
@@ -65,12 +66,12 @@ public void testHeaderSplitAcrossPackets() {
     insertTableSection(4, (byte) 100, 3); // This section header spreads across both packets.
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 5);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
     secondPacket.setPosition(5);
-    reader.consume(secondPacket, false);
+    reader.consume(secondPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(100));
   }
 
@@ -85,12 +86,12 @@ public void testFiveSectionsInTwoPackets() {
     insertTableSection(54, (byte) 105, 10);
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 40);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(asList(101, 102, 103));
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
     secondPacket.setPosition(40);
-    reader.consume(secondPacket, true);
+    reader.consume(secondPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(asList(101, 102, 103, 104, 105));
   }
 
@@ -105,22 +106,22 @@ public void testLongSectionAcrossFourPackets() {
     insertTableSection(318, (byte) 108, 10);
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
     secondPacket.setPosition(100);
-    reader.consume(secondPacket, false);
+    reader.consume(secondPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
     thirdPacket.setPosition(200);
-    reader.consume(thirdPacket, false);
+    reader.consume(thirdPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
     fourthPacket.setPosition(300);
-    reader.consume(fourthPacket, true);
+    reader.consume(fourthPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(asList(107, 108));
   }
 
@@ -135,24 +136,24 @@ public void testSeek() {
     insertTableSection(318, (byte) 111, 10);
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
     secondPacket.setPosition(100);
-    reader.consume(secondPacket, false);
+    reader.consume(secondPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
     thirdPacket.setPosition(200);
-    reader.consume(thirdPacket, false);
+    reader.consume(thirdPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     reader.seek();
 
     ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
     fourthPacket.setPosition(300);
-    reader.consume(fourthPacket, true);
+    reader.consume(fourthPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(111));
   }
 
@@ -165,9 +166,9 @@ public void testCrcChecks() {
     byte[] incorrectCrcPat = Arrays.copyOf(correctCrcPat, correctCrcPat.length);
     // Crc field is incorrect, and should not be passed to the payload reader.
     incorrectCrcPat[16]--;
-    reader.consume(new ParsableByteArray(correctCrcPat), true);
+    reader.consume(new ParsableByteArray(correctCrcPat), FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(0));
-    reader.consume(new ParsableByteArray(incorrectCrcPat), true);
+    reader.consume(new ParsableByteArray(incorrectCrcPat), FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(0));
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java
new file mode 100644
index 0000000000..e7e100f38c
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link TsDurationReader}. */
+@RunWith(RobolectricTestRunner.class)
+public final class TsDurationReaderTest {
+
+  private TsDurationReader tsDurationReader;
+  private PositionHolder seekPositionHolder;
+
+  @Before
+  public void setUp() {
+    tsDurationReader = new TsDurationReader();
+    seekPositionHolder = new PositionHolder();
+  }
+
+  @Test
+  public void testIsDurationReadPending_returnFalseByDefault() {
+    assertThat(tsDurationReader.isDurationReadFinished()).isFalse();
+  }
+
+  @Test
+  public void testReadDuration_returnsCorrectDuration() throws IOException, InterruptedException {
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/bbb_2500ms.ts"))
+            .setSimulateIOErrors(false)
+            .setSimulateUnknownLength(false)
+            .setSimulatePartialReads(false)
+            .build();
+
+    while (!tsDurationReader.isDurationReadFinished()) {
+      int result = tsDurationReader.readDuration(input, seekPositionHolder, /* pcrPid= */ 256);
+      if (result == Extractor.RESULT_END_OF_INPUT) {
+        break;
+      }
+      if (result == Extractor.RESULT_SEEK) {
+        input.setPosition((int) seekPositionHolder.position);
+      }
+    }
+    assertThat(tsDurationReader.getDurationUs() / 1000).isEqualTo(2500);
+  }
+
+  @Test
+  public void testReadDuration_midStream_returnsCorrectDuration()
+      throws IOException, InterruptedException {
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/bbb_2500ms.ts"))
+            .setSimulateIOErrors(false)
+            .setSimulateUnknownLength(false)
+            .setSimulatePartialReads(false)
+            .build();
+
+    input.setPosition(1234);
+    while (!tsDurationReader.isDurationReadFinished()) {
+      int result = tsDurationReader.readDuration(input, seekPositionHolder, /* pcrPid= */ 256);
+      if (result == Extractor.RESULT_END_OF_INPUT) {
+        break;
+      }
+      if (result == Extractor.RESULT_SEEK) {
+        input.setPosition((int) seekPositionHolder.position);
+      }
+    }
+    assertThat(tsDurationReader.getDurationUs() / 1000).isEqualTo(2500);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java
new file mode 100644
index 0000000000..4d421b05a4
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer2.testutil.FakeTrackOutput;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Seeking tests for {@link TsExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class TsExtractorSeekTest {
+
+  private static final String TEST_FILE = "ts/bbb_2500ms.ts";
+  private static final int DURATION_US = 2_500_000;
+  private static final int AUDIO_TRACK_ID = 257;
+  private static final long MAXIMUM_TIMESTAMP_DELTA_US = 500_000L;
+
+  private static final Random random = new Random(1234L);
+
+  private FakeTrackOutput expectedTrackOutput;
+  private DefaultDataSource dataSource;
+  private PositionHolder positionHolder;
+
+  @Before
+  public void setUp() throws IOException, InterruptedException {
+    positionHolder = new PositionHolder();
+    expectedTrackOutput =
+        TestUtil.extractAllSamplesFromFile(
+                new TsExtractor(), RuntimeEnvironment.application, TEST_FILE)
+            .trackOutputs
+            .get(AUDIO_TRACK_ID);
+
+    dataSource =
+        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+            .createDataSource();
+  }
+
+  @Test
+  public void testTsExtractorReads_nonSeekTableFile_returnSeekableSeekMap()
+      throws IOException, InterruptedException {
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+    TsExtractor extractor = new TsExtractor();
+
+    SeekMap seekMap =
+        TestUtil.extractSeekMap(extractor, new FakeExtractorOutput(), dataSource, fileUri);
+
+    assertThat(seekMap).isNotNull();
+    assertThat(seekMap.getDurationUs()).isEqualTo(DURATION_US);
+    assertThat(seekMap.isSeekable()).isTrue();
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekingToPositionInFile_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    TsExtractor extractor = new TsExtractor();
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
+
+    long targetSeekTimeUs = 987_000;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekToEoF_extractsLastFrame()
+      throws IOException, InterruptedException {
+    TsExtractor extractor = new TsExtractor();
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
+
+    long targetSeekTimeUs = seekMap.getDurationUs();
+
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekingBackward_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    TsExtractor extractor = new TsExtractor();
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
+
+    long firstSeekTimeUs = 987_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 0;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesSeekingForward_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    TsExtractor extractor = new TsExtractor();
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
+
+    long firstSeekTimeUs = 987_000;
+    TestUtil.seekToTimeUs(extractor, seekMap, firstSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    long targetSeekTimeUs = 1_234_000;
+    int extractedFrameIndex =
+        TestUtil.seekToTimeUs(
+            extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+    assertThat(extractedFrameIndex).isNotEqualTo(-1);
+    assertFirstFrameAfterSeekContainTargetSeekTime(
+        trackOutput, targetSeekTimeUs, extractedFrameIndex);
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesRandomSeeks_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    TsExtractor extractor = new TsExtractor();
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    SeekMap seekMap = TestUtil.extractSeekMap(extractor, extractorOutput, dataSource, fileUri);
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(DURATION_US + 1);
+      int extractedFrameIndex =
+          TestUtil.seekToTimeUs(
+              extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+      assertThat(extractedFrameIndex).isNotEqualTo(-1);
+      assertFirstFrameAfterSeekContainTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedFrameIndex);
+    }
+  }
+
+  @Test
+  public void testHandlePendingSeek_handlesRandomSeeksAfterReadingFileOnce_extractsCorrectFrame()
+      throws IOException, InterruptedException {
+    TsExtractor extractor = new TsExtractor();
+    Uri fileUri = TestUtil.buildAssetUri(TEST_FILE);
+
+    FakeExtractorOutput extractorOutput = new FakeExtractorOutput();
+    readInputFileOnce(extractor, extractorOutput, fileUri);
+    SeekMap seekMap = extractorOutput.seekMap;
+    FakeTrackOutput trackOutput = extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
+
+    long numSeek = 100;
+    for (long i = 0; i < numSeek; i++) {
+      long targetSeekTimeUs = random.nextInt(DURATION_US + 1);
+      int extractedFrameIndex =
+          TestUtil.seekToTimeUs(
+              extractor, seekMap, targetSeekTimeUs, dataSource, trackOutput, fileUri);
+
+      assertThat(extractedFrameIndex).isNotEqualTo(-1);
+      assertFirstFrameAfterSeekContainTargetSeekTime(
+          trackOutput, targetSeekTimeUs, extractedFrameIndex);
+    }
+  }
+
+  // Internal methods
+
+  private void readInputFileOnce(
+      TsExtractor extractor, FakeExtractorOutput extractorOutput, Uri fileUri)
+      throws IOException, InterruptedException {
+    extractor.init(extractorOutput);
+    int readResult = Extractor.RESULT_CONTINUE;
+    ExtractorInput input = TestUtil.getExtractorInputFromPosition(dataSource, 0, fileUri);
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      try {
+        while (readResult == Extractor.RESULT_CONTINUE) {
+          readResult = extractor.read(input, positionHolder);
+        }
+      } finally {
+        Util.closeQuietly(dataSource);
+      }
+      if (readResult == Extractor.RESULT_SEEK) {
+        input =
+            TestUtil.getExtractorInputFromPosition(dataSource, positionHolder.position, fileUri);
+        readResult = Extractor.RESULT_CONTINUE;
+      }
+    }
+  }
+
+  private void assertFirstFrameAfterSeekContainTargetSeekTime(
+      FakeTrackOutput trackOutput, long seekTimeUs, int firstFrameIndexAfterSeek) {
+    long outputSampleTimeUs = trackOutput.getSampleTimeUs(firstFrameIndexAfterSeek);
+    int expectedSampleIndex =
+        findOutputFrameInExpectedOutput(trackOutput.getSampleData(firstFrameIndexAfterSeek));
+    // Assert that after seeking, the first sample frame written to output exists in the sample list
+    assertThat(expectedSampleIndex).isNotEqualTo(-1);
+    // Assert that the timestamp output for first sample after seek is near the seek point.
+    // For Ts seeking, unfortunately we can't guarantee exact frame seeking, since PID timestamp is
+    // not too reliable.
+    assertThat(Math.abs(outputSampleTimeUs - seekTimeUs)).isLessThan(MAXIMUM_TIMESTAMP_DELTA_US);
+    // Assert that the timestamp output for first sample after seek is near the actual sample
+    // at seek point.
+    // Note that the timestamp output for first sample after seek might *NOT* be equal to the
+    // timestamp of that same sample when reading from the beginning, because if first timestamp in
+    // the stream was not read before the seek, then the timestamp of the first sample after the
+    // seek is just approximated from the seek point.
+    assertThat(
+            Math.abs(outputSampleTimeUs - expectedTrackOutput.getSampleTimeUs(expectedSampleIndex)))
+        .isLessThan(MAXIMUM_TIMESTAMP_DELTA_US);
+    trackOutput.assertSample(
+        firstFrameIndexAfterSeek,
+        expectedTrackOutput.getSampleData(expectedSampleIndex),
+        outputSampleTimeUs,
+        expectedTrackOutput.getSampleFlags(expectedSampleIndex),
+        expectedTrackOutput.getSampleCryptoData(expectedSampleIndex));
+  }
+
+  private int findOutputFrameInExpectedOutput(byte[] sampleData) {
+    for (int i = 0; i < expectedTrackOutput.getSampleCount(); i++) {
+      byte[] currentSampleData = expectedTrackOutput.getSampleData(i);
+      if (Arrays.equals(currentSampleData, sampleData)) {
+        return i;
+      }
+    }
+    return -1;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index 8394ed81a5..beaa5ffa83 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -27,7 +27,6 @@
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
@@ -50,41 +49,32 @@
 
   @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new TsExtractor();
-          }
-        },
-        "ts/sample.ts");
+    ExtractorAsserts.assertBehavior(TsExtractor::new, "ts/sample.ts");
   }
 
   @Test
-  public void testIncompleteSample() throws Exception {
+  public void testStreamWithJunkData() throws Exception {
     Random random = new Random(0);
     byte[] fileData = TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ts");
     ByteArrayOutputStream out = new ByteArrayOutputStream(fileData.length * 2);
+    int bytesLeft = fileData.length;
+
     writeJunkData(out, random.nextInt(TS_PACKET_SIZE - 1) + 1);
     out.write(fileData, 0, TS_PACKET_SIZE * 5);
-    for (int i = TS_PACKET_SIZE * 5; i < fileData.length; i += TS_PACKET_SIZE) {
+    bytesLeft -= TS_PACKET_SIZE * 5;
+
+    for (int i = TS_PACKET_SIZE * 5; i < fileData.length; i += 5 * TS_PACKET_SIZE) {
       writeJunkData(out, random.nextInt(TS_PACKET_SIZE));
-      out.write(fileData, i, TS_PACKET_SIZE);
+      int length = Math.min(5 * TS_PACKET_SIZE, bytesLeft);
+      out.write(fileData, i, length);
+      bytesLeft -= length;
     }
     out.write(TS_SYNC_BYTE);
     writeJunkData(out, random.nextInt(TS_PACKET_SIZE - 1) + 1);
     fileData = out.toByteArray();
 
     ExtractorAsserts.assertOutput(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new TsExtractor();
-          }
-        },
-        "ts/sample.ts",
-        fileData,
-        RuntimeEnvironment.application);
+        TsExtractor::new, "ts/sample.ts", fileData, RuntimeEnvironment.application);
   }
 
   @Test
@@ -105,6 +95,9 @@ public void testCustomPesReader() throws Exception {
     int readResult = Extractor.RESULT_CONTINUE;
     while (readResult != Extractor.RESULT_END_OF_INPUT) {
       readResult = tsExtractor.read(input, seekPositionHolder);
+      if (readResult == Extractor.RESULT_SEEK) {
+        input.setPosition((int) seekPositionHolder.position);
+      }
     }
     CustomEsReader reader = factory.esReader;
     assertThat(reader.packetsRead).isEqualTo(2);
@@ -131,8 +124,11 @@ public void testCustomInitialSectionReader() throws Exception {
     int readResult = Extractor.RESULT_CONTINUE;
     while (readResult != Extractor.RESULT_END_OF_INPUT) {
       readResult = tsExtractor.read(input, seekPositionHolder);
+      if (readResult == Extractor.RESULT_SEEK) {
+        input.setPosition((int) seekPositionHolder.position);
+      }
     }
-    assertThat(factory.sdtReader.consumedSdts).isEqualTo(1);
+    assertThat(factory.sdtReader.consumedSdts).isEqualTo(2);
   }
 
   private static void writeJunkData(ByteArrayOutputStream out, int length) {
@@ -206,7 +202,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
     }
 
     @Override
-    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {}
+    public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {}
 
     @Override
     public void consume(ParsableByteArray data) {}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
index e75525bb1e..f4df4036f6 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.wav;
 
-import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
-import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -28,13 +26,6 @@
 
   @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(
-        new ExtractorFactory() {
-          @Override
-          public Extractor create() {
-            return new WavExtractor();
-          }
-        },
-        "wav/sample.wav");
+    ExtractorAsserts.assertBehavior(WavExtractor::new, "wav/sample.wav");
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index 0b992f0981..3fa491ea50 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -19,7 +19,6 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.MetadataDecoderException;
 import com.google.android.exoplayer2.util.Assertions;
 import java.nio.charset.Charset;
 import java.util.Arrays;
@@ -38,7 +37,7 @@
   private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
 
   @Test
-  public void testDecodeTxxxFrame() throws MetadataDecoderException {
+  public void testDecodeTxxxFrame() {
     byte[] rawId3 = buildSingleFrameTag("TXXX", new byte[] {3, 0, 109, 100, 105, 97, 108, 111, 103,
         95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50, 55, 54, 54, 52, 95, 115, 116, 97, 114, 116, 0});
     Id3Decoder decoder = new Id3Decoder();
@@ -65,7 +64,7 @@ public void testDecodeTxxxFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodeTextInformationFrame() throws MetadataDecoderException {
+  public void testDecodeTextInformationFrame() {
     byte[] rawId3 = buildSingleFrameTag("TIT2", new byte[] {3, 72, 101, 108, 108, 111, 32, 87, 111,
         114, 108, 100, 0});
     Id3Decoder decoder = new Id3Decoder();
@@ -92,7 +91,7 @@ public void testDecodeTextInformationFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodeWxxxFrame() throws MetadataDecoderException {
+  public void testDecodeWxxxFrame() {
     byte[] rawId3 = buildSingleFrameTag("WXXX", new byte[] {ID3_TEXT_ENCODING_UTF_8, 116, 101, 115,
         116, 0, 104, 116, 116, 112, 115, 58, 47, 47, 116, 101, 115, 116, 46, 99, 111, 109, 47, 97,
         98, 99, 63, 100, 101, 102});
@@ -120,7 +119,7 @@ public void testDecodeWxxxFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodeUrlLinkFrame() throws MetadataDecoderException {
+  public void testDecodeUrlLinkFrame() {
     byte[] rawId3 = buildSingleFrameTag("WCOM", new byte[] {104, 116, 116, 112, 115, 58, 47, 47,
         116, 101, 115, 116, 46, 99, 111, 109, 47, 97, 98, 99, 63, 100, 101, 102});
     Id3Decoder decoder = new Id3Decoder();
@@ -142,7 +141,7 @@ public void testDecodeUrlLinkFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodePrivFrame() throws MetadataDecoderException {
+  public void testDecodePrivFrame() {
     byte[] rawId3 = buildSingleFrameTag("PRIV", new byte[] {116, 101, 115, 116, 0, 1, 2, 3, 4});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
@@ -161,7 +160,7 @@ public void testDecodePrivFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodeApicFrame() throws MetadataDecoderException {
+  public void testDecodeApicFrame() {
     byte[] rawId3 = buildSingleFrameTag("APIC", new byte[] {3, 105, 109, 97, 103, 101, 47, 106, 112,
         101, 103, 0, 16, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 0});
@@ -177,7 +176,7 @@ public void testDecodeApicFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodeCommentFrame() throws MetadataDecoderException {
+  public void testDecodeCommentFrame() {
     byte[] rawId3 = buildSingleFrameTag("COMM", new byte[] {ID3_TEXT_ENCODING_UTF_8, 101, 110, 103,
         100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 0, 116, 101, 120, 116, 0});
     Id3Decoder decoder = new Id3Decoder();
@@ -204,7 +203,7 @@ public void testDecodeCommentFrame() throws MetadataDecoderException {
   }
 
   @Test
-  public void testDecodeMultiFrames() throws MetadataDecoderException {
+  public void testDecodeMultiFrames() {
     byte[] rawId3 =
         buildMultiFramesTag(
             new FrameSpec(
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
new file mode 100644
index 0000000000..3e6520beca
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Test for {@link MlltFrame}. */
+@RunWith(RobolectricTestRunner.class)
+public final class MlltFrameTest {
+
+  @Test
+  public void testParcelable() {
+    MlltFrame mlltFrameToParcel =
+        new MlltFrame(
+            /* mpegFramesBetweenReference= */ 1,
+            /* bytesBetweenReference= */ 1,
+            /* millisecondsBetweenReference= */ 1,
+            /* bytesDeviations= */ new int[] {1, 2},
+            /* millisecondsDeviations= */ new int[] {1, 2});
+
+    Parcel parcel = Parcel.obtain();
+    mlltFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    MlltFrame mlltFrameFromParcel = MlltFrame.CREATOR.createFromParcel(parcel);
+    assertThat(mlltFrameFromParcel).isEqualTo(mlltFrameToParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
index 2afe80bb0a..d8a4e97791 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -19,7 +19,6 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.MetadataDecoderException;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.nio.ByteBuffer;
@@ -45,7 +44,7 @@ public void setUp() {
   }
 
   @Test
-  public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException {
+  public void testWrappedAroundTimeSignalCommand() {
     byte[] rawTimeSignalSection = new byte[] {
         0, // table_id.
         (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
@@ -72,7 +71,7 @@ public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException
   }
 
   @Test
-  public void test2SpliceInsertCommands() throws MetadataDecoderException {
+  public void test2SpliceInsertCommands() {
     byte[] rawSpliceInsertCommand1 = new byte[] {
         0, // table_id.
         (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
@@ -165,8 +164,7 @@ public void test2SpliceInsertCommands() throws MetadataDecoderException {
     assertThat(command.availsExpected).isEqualTo(2);
   }
 
-  private Metadata feedInputBuffer(byte[] data, long timeUs, long subsampleOffset)
-      throws MetadataDecoderException{
+  private Metadata feedInputBuffer(byte[] data, long timeUs, long subsampleOffset) {
     inputBuffer.clear();
     inputBuffer.data = ByteBuffer.allocate(data.length).put(data);
     inputBuffer.timeUs = timeUs;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java
index e821bc34a0..634d541d39 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java
@@ -33,9 +33,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit tests for {@link ProgressiveDownloadAction}.
- */
+/** Unit tests for {@link ActionFile}. */
 @RunWith(RobolectricTestRunner.class)
 public class ActionFileTest {
 
@@ -258,7 +256,7 @@ protected void writeToStream(DataOutputStream output) throws IOException {
     }
 
     @Override
-    protected Downloader createDownloader(DownloaderConstructorHelper downloaderConstructorHelper) {
+    public Downloader createDownloader(DownloaderConstructorHelper downloaderConstructorHelper) {
       return null;
     }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
index 0d0bf73d04..234377895f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
@@ -331,13 +331,7 @@ public void testStopAndResume() throws Throwable {
     remove2Action.post().assertStarted();
     download2Action.post().assertDoesNotStart();
 
-    runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            downloadManager.stopDownloads();
-          }
-        });
+    runOnMainThread(() -> downloadManager.stopDownloads());
 
     download1Action.assertStopped();
 
@@ -354,13 +348,7 @@ public void run() {
     // New download actions can be added but they don't start.
     download3Action.post().assertDoesNotStart();
 
-    runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            downloadManager.startDownloads();
-          }
-        });
+    runOnMainThread(() -> downloadManager.startDownloads());
 
     download2Action.assertStarted().unblock().assertCompleted();
     download3Action.assertStarted().unblock().assertCompleted();
@@ -380,24 +368,12 @@ public void testResumeBeforeTotallyStopped() throws Throwable {
     // download3Action doesn't start as DM was configured to run two downloads in parallel.
     download3Action.post().assertDoesNotStart();
 
-    runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            downloadManager.stopDownloads();
-          }
-        });
+    runOnMainThread(() -> downloadManager.stopDownloads());
 
     // download1Action doesn't stop yet as it ignores interrupts.
     download2Action.assertStopped();
 
-    runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            downloadManager.startDownloads();
-          }
-        });
+    runOnMainThread(() -> downloadManager.startDownloads());
 
     // download2Action starts immediately.
     download2Action.assertStarted();
@@ -421,22 +397,19 @@ private void setUpDownloadManager(final int maxActiveDownloadTasks) throws Excep
     }
     try {
       runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              downloadManager =
-                  new DownloadManager(
-                      new DownloaderConstructorHelper(
-                          Mockito.mock(Cache.class), DummyDataSource.FACTORY),
-                      maxActiveDownloadTasks,
-                      MIN_RETRY_COUNT,
-                      actionFile,
-                      ProgressiveDownloadAction.DESERIALIZER);
-              downloadManagerListener =
-                  new TestDownloadManagerListener(downloadManager, dummyMainThread);
-              downloadManager.addListener(downloadManagerListener);
-              downloadManager.startDownloads();
-            }
+          () -> {
+            downloadManager =
+                new DownloadManager(
+                    new DownloaderConstructorHelper(
+                        Mockito.mock(Cache.class), DummyDataSource.FACTORY),
+                    maxActiveDownloadTasks,
+                    MIN_RETRY_COUNT,
+                    actionFile,
+                    ProgressiveDownloadAction.DESERIALIZER);
+            downloadManagerListener =
+                new TestDownloadManagerListener(downloadManager, dummyMainThread);
+            downloadManager.addListener(downloadManagerListener);
+            downloadManager.startDownloads();
           });
     } catch (Throwable throwable) {
       throw new Exception(throwable);
@@ -445,13 +418,7 @@ public void run() {
 
   private void releaseDownloadManager() throws Exception {
     try {
-      runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              downloadManager.release();
-            }
-          });
+      runOnMainThread(() -> downloadManager.release());
     } catch (Throwable throwable) {
       throw new Exception(throwable);
     }
@@ -510,7 +477,7 @@ protected void writeToStream(DataOutputStream output) {
     }
 
     @Override
-    protected Downloader createDownloader(DownloaderConstructorHelper downloaderConstructorHelper) {
+    public Downloader createDownloader(DownloaderConstructorHelper downloaderConstructorHelper) {
       return downloader;
     }
 
@@ -519,13 +486,7 @@ private FakeDownloader getFakeDownloader() {
     }
 
     private FakeDownloadAction post() {
-      runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              downloadManager.handleAction(FakeDownloadAction.this);
-            }
-          });
+      runOnMainThread(() -> downloadManager.handleAction(FakeDownloadAction.this));
       return this;
     }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java
index bc3732e3d3..df5e7dd044 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java
@@ -32,9 +32,7 @@
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link ProgressiveDownloadAction}.
- */
+/** Unit tests for {@link ProgressiveDownloadAction}. */
 @RunWith(RobolectricTestRunner.class)
 public class ProgressiveDownloadActionTest {
 
@@ -49,112 +47,109 @@ public void setUp() {
 
   @Test
   public void testDownloadActionIsNotRemoveAction() throws Exception {
-    ProgressiveDownloadAction action = new ProgressiveDownloadAction(uri1, false, null, null);
+    DownloadAction action = createDownloadAction(uri1, null);
     assertThat(action.isRemoveAction).isFalse();
   }
 
   @Test
   public void testRemoveActionisRemoveAction() throws Exception {
-    ProgressiveDownloadAction action2 = new ProgressiveDownloadAction(uri1, true, null, null);
+    DownloadAction action2 = createRemoveAction(uri1, null);
     assertThat(action2.isRemoveAction).isTrue();
   }
 
   @Test
   public void testCreateDownloader() throws Exception {
     MockitoAnnotations.initMocks(this);
-    ProgressiveDownloadAction action = new ProgressiveDownloadAction(uri1, false, null, null);
-    DownloaderConstructorHelper constructorHelper = new DownloaderConstructorHelper(
-        Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    DownloadAction action = createDownloadAction(uri1, null);
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
     assertThat(action.createDownloader(constructorHelper)).isNotNull();
   }
 
   @Test
   public void testSameUriCacheKeyDifferentAction_IsSameMedia() throws Exception {
-    ProgressiveDownloadAction action1 = new ProgressiveDownloadAction(uri1, true, null, null);
-    ProgressiveDownloadAction action2 = new ProgressiveDownloadAction(uri1, false, null, null);
+    DownloadAction action1 = createRemoveAction(uri1, null);
+    DownloadAction action2 = createDownloadAction(uri1, null);
     assertSameMedia(action1, action2);
   }
 
   @Test
   public void testNullCacheKeyDifferentUriAction_IsNotSameMedia() throws Exception {
-    ProgressiveDownloadAction action3 = new ProgressiveDownloadAction(uri2, true, null, null);
-    ProgressiveDownloadAction action4 = new ProgressiveDownloadAction(uri1, false, null, null);
+    DownloadAction action3 = createRemoveAction(uri2, null);
+    DownloadAction action4 = createDownloadAction(uri1, null);
     assertNotSameMedia(action3, action4);
   }
 
   @Test
   public void testSameCacheKeyDifferentUriAction_IsSameMedia() throws Exception {
-    ProgressiveDownloadAction action5 = new ProgressiveDownloadAction(uri2, true, null, "key");
-    ProgressiveDownloadAction action6 = new ProgressiveDownloadAction(uri1, false, null, "key");
+    DownloadAction action5 = createRemoveAction(uri2, "key");
+    DownloadAction action6 = createDownloadAction(uri1, "key");
     assertSameMedia(action5, action6);
   }
 
   @Test
   public void testSameUriDifferentCacheKeyAction_IsNotSameMedia() throws Exception {
-    ProgressiveDownloadAction action7 = new ProgressiveDownloadAction(uri1, true, null, "key");
-    ProgressiveDownloadAction action8 = new ProgressiveDownloadAction(uri1, false, null, "key2");
+    DownloadAction action7 = createRemoveAction(uri1, "key");
+    DownloadAction action8 = createDownloadAction(uri1, "key2");
     assertNotSameMedia(action7, action8);
   }
 
   @Test
   public void testSameUriNullCacheKeyAction_IsNotSameMedia() throws Exception {
-    ProgressiveDownloadAction action1 = new ProgressiveDownloadAction(uri1, true, null, "key");
-    ProgressiveDownloadAction action2 = new ProgressiveDownloadAction(uri1, false, null, null);
+    DownloadAction action1 = createRemoveAction(uri1, "key");
+    DownloadAction action2 = createDownloadAction(uri1, null);
     assertNotSameMedia(action1, action2);
   }
 
   @Test
   public void testEquals() throws Exception {
-    ProgressiveDownloadAction action1 = new ProgressiveDownloadAction(uri1, true, null, null);
+    DownloadAction action1 = createRemoveAction(uri1, null);
     assertThat(action1.equals(action1)).isTrue();
 
-    ProgressiveDownloadAction action2 = new ProgressiveDownloadAction(uri1, true, null, null);
-    ProgressiveDownloadAction action3 = new ProgressiveDownloadAction(uri1, true, null, null);
+    DownloadAction action2 = createRemoveAction(uri1, null);
+    DownloadAction action3 = createRemoveAction(uri1, null);
     assertThat(action2.equals(action3)).isTrue();
 
-    ProgressiveDownloadAction action4 = new ProgressiveDownloadAction(uri1, true, null, null);
-    ProgressiveDownloadAction action5 = new ProgressiveDownloadAction(uri1, false, null, null);
+    DownloadAction action4 = createRemoveAction(uri1, null);
+    DownloadAction action5 = createDownloadAction(uri1, null);
     assertThat(action4.equals(action5)).isFalse();
 
-    ProgressiveDownloadAction action6 = new ProgressiveDownloadAction(uri1, true, null, null);
-    ProgressiveDownloadAction action7 = new ProgressiveDownloadAction(uri1, true, null, "key");
+    DownloadAction action6 = createRemoveAction(uri1, null);
+    DownloadAction action7 = createRemoveAction(uri1, "key");
     assertThat(action6.equals(action7)).isFalse();
 
-    ProgressiveDownloadAction action8 = new ProgressiveDownloadAction(uri1, true, null, "key2");
-    ProgressiveDownloadAction action9 = new ProgressiveDownloadAction(uri1, true, null, "key");
+    DownloadAction action8 = createRemoveAction(uri1, "key2");
+    DownloadAction action9 = createRemoveAction(uri1, "key");
     assertThat(action8.equals(action9)).isFalse();
 
-    ProgressiveDownloadAction action10 = new ProgressiveDownloadAction(uri1, true, null, null);
-    ProgressiveDownloadAction action11 = new ProgressiveDownloadAction(uri2, true, null, null);
+    DownloadAction action10 = createRemoveAction(uri1, null);
+    DownloadAction action11 = createRemoveAction(uri2, null);
     assertThat(action10.equals(action11)).isFalse();
   }
 
   @Test
   public void testSerializerGetType() throws Exception {
-    ProgressiveDownloadAction action = new ProgressiveDownloadAction(uri1, false, null, null);
+    DownloadAction action = createDownloadAction(uri1, null);
     assertThat(action.type).isNotNull();
   }
 
   @Test
   public void testSerializerWriteRead() throws Exception {
-    doTestSerializationRoundTrip(new ProgressiveDownloadAction(uri1, false, null, null));
-    doTestSerializationRoundTrip(new ProgressiveDownloadAction(uri2, true, null, "key"));
+    doTestSerializationRoundTrip(createDownloadAction(uri1, null));
+    doTestSerializationRoundTrip(createRemoveAction(uri2, "key"));
   }
 
-  private void assertSameMedia(
-      ProgressiveDownloadAction action1, ProgressiveDownloadAction action2) {
+  private void assertSameMedia(DownloadAction action1, DownloadAction action2) {
     assertThat(action1.isSameMedia(action2)).isTrue();
     assertThat(action2.isSameMedia(action1)).isTrue();
   }
 
-  private void assertNotSameMedia(
-      ProgressiveDownloadAction action1, ProgressiveDownloadAction action2) {
+  private void assertNotSameMedia(DownloadAction action1, DownloadAction action2) {
     assertThat(action1.isSameMedia(action2)).isFalse();
     assertThat(action2.isSameMedia(action1)).isFalse();
   }
 
-  private static void doTestSerializationRoundTrip(ProgressiveDownloadAction action)
-      throws IOException {
+  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream output = new DataOutputStream(out);
     DownloadAction.serializeToStream(action, output);
@@ -168,4 +163,11 @@ private static void doTestSerializationRoundTrip(ProgressiveDownloadAction actio
     assertThat(action2).isEqualTo(action);
   }
 
+  private static DownloadAction createDownloadAction(Uri uri1, String customCacheKey) {
+    return ProgressiveDownloadAction.createDownloadAction(uri1, null, customCacheKey);
+  }
+
+  private static DownloadAction createRemoveAction(Uri uri1, String customCacheKey) {
+    return ProgressiveDownloadAction.createRemoveAction(uri1, null, customCacheKey);
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
index e853529ae6..ee8cdf4887 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -37,6 +37,7 @@
 import com.google.android.exoplayer2.testutil.RobolectricUtil;
 import com.google.android.exoplayer2.testutil.TimelineAsserts;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -468,17 +469,18 @@ public void testEventTimeWithUnsetDuration() throws IOException {
   private static MediaLoadData getClippingMediaSourceMediaLoadData(
       long clippingStartUs, long clippingEndUs, final long eventStartUs, final long eventEndUs)
       throws IOException {
+    Timeline timeline =
+        new SinglePeriodTimeline(
+            TEST_PERIOD_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false);
     FakeMediaSource fakeMediaSource =
-        new FakeMediaSource(
-            new SinglePeriodTimeline(
-                TEST_PERIOD_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false),
-            /* manifest= */ null) {
+        new FakeMediaSource(timeline, /* manifest= */ null) {
           @Override
           protected FakeMediaPeriod createFakeMediaPeriod(
               MediaPeriodId id,
               TrackGroupArray trackGroupArray,
               Allocator allocator,
-              EventDispatcher eventDispatcher) {
+              EventDispatcher eventDispatcher,
+              @Nullable TransferListener transferListener) {
             eventDispatcher.downstreamFormatChanged(
                 new MediaLoadData(
                     C.DATA_TYPE_MEDIA,
@@ -488,7 +490,8 @@ protected FakeMediaPeriod createFakeMediaPeriod(
                     /* trackSelectionData= */ null,
                     C.usToMs(eventStartUs),
                     C.usToMs(eventEndUs)));
-            return super.createFakeMediaPeriod(id, trackGroupArray, allocator, eventDispatcher);
+            return super.createFakeMediaPeriod(
+                id, trackGroupArray, allocator, eventDispatcher, transferListener);
           }
         };
     final ClippingMediaSource clippingMediaSource =
@@ -498,9 +501,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
     final MediaLoadData[] reportedMediaLoadData = new MediaLoadData[1];
     try {
       testRunner.runOnPlaybackThread(
-          new Runnable() {
-            @Override
-            public void run() {
+          () ->
               clippingMediaSource.addEventListener(
                   new Handler(),
                   new DefaultMediaSourceEventListener() {
@@ -511,13 +512,12 @@ public void onDownstreamFormatChanged(
                         MediaLoadData mediaLoadData) {
                       reportedMediaLoadData[0] = mediaLoadData;
                     }
-                  });
-            }
-          });
+                  }));
       testRunner.prepareSource();
       // Create period to send the test event configured above.
       testRunner.createPeriod(
-          new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+          new MediaPeriodId(
+              timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
       assertThat(reportedMediaLoadData[0]).isNotNull();
     } finally {
       testRunner.release();
@@ -581,7 +581,9 @@ private static Timeline getClippedTimeline(Timeline timeline, long durationUs)
       clippedTimelines[0] = testRunner.prepareSource();
       MediaPeriod mediaPeriod =
           testRunner.createPeriod(
-              new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+              new MediaPeriodId(
+                  clippedTimelines[0].getUidOfPeriod(/* periodIndex= */ 0),
+                  /* windowSequenceNumber= */ 0));
       for (int i = 0; i < additionalTimelines.length; i++) {
         fakeMediaSource.setNewSourceInfo(additionalTimelines[i], /* newManifest= */ null);
         clippedTimelines[i + 1] = testRunner.assertTimelineChangeBlocking();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
index 5231fc22ed..dd1221f160 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
@@ -23,8 +23,8 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
 import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
@@ -97,7 +97,7 @@ public void testPlaylistChangesAfterPreparation() throws IOException, Interrupte
 
     // Add bulk.
     mediaSource.addMediaSources(
-        3, Arrays.<MediaSource>asList(childSources[4], childSources[5], childSources[6]));
+        3, Arrays.asList(childSources[4], childSources[5], childSources[6]));
     timeline = testRunner.assertTimelineChangeBlocking();
     TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
     TimelineAsserts.assertWindowTags(timeline, 222, 444, 111, 555, 666, 777, 333);
@@ -247,12 +247,7 @@ public void testPlaylistWithLazyMediaSource() throws IOException, InterruptedExc
     // Trigger source info refresh for lazy source and check that the timeline now contains all
     // information for all windows.
     testRunner.runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            lazySources[1].setNewSourceInfo(createFakeTimeline(8), null);
-          }
-        });
+        () -> lazySources[1].setNewSourceInfo(createFakeTimeline(8), null));
     timeline = testRunner.assertTimelineChangeBlocking();
     TimelineAsserts.assertPeriodCounts(timeline, 1, 9);
     TimelineAsserts.assertWindowTags(timeline, 111, 999);
@@ -279,25 +274,22 @@ public void run() {
     // called yet.
     MediaPeriod lazyPeriod =
         testRunner.createPeriod(
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
     CountDownLatch preparedCondition = testRunner.preparePeriod(lazyPeriod, 0);
     assertThat(preparedCondition.getCount()).isEqualTo(1);
 
     // Assert that a second period can also be created and released without problems.
     MediaPeriod secondLazyPeriod =
         testRunner.createPeriod(
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
     testRunner.releasePeriod(secondLazyPeriod);
 
     // Trigger source info refresh for lazy media source. Assert that now all information is
     // available again and the previously created period now also finished preparing.
     testRunner.runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            lazySources[3].setNewSourceInfo(createFakeTimeline(7), null);
-          }
-        });
+        () -> lazySources[3].setNewSourceInfo(createFakeTimeline(7), null));
     timeline = testRunner.assertTimelineChangeBlocking();
     TimelineAsserts.assertPeriodCounts(timeline, 8, 1, 2, 9);
     TimelineAsserts.assertWindowTags(timeline, 888, 111, 222, 999);
@@ -383,7 +375,7 @@ public void testDynamicChangeOfEmptyTimelines() throws IOException {
         };
     Timeline nonEmptyTimeline = new FakeTimeline(/* windowCount = */ 1);
 
-    mediaSource.addMediaSources(Arrays.<MediaSource>asList(childSources));
+    mediaSource.addMediaSources(Arrays.asList(childSources));
     Timeline timeline = testRunner.prepareSource();
     TimelineAsserts.assertEmpty(timeline);
 
@@ -484,12 +476,7 @@ public void testCustomCallbackAfterPreparationAddSingle() throws IOException {
       testRunner.prepareSource();
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              mediaSource.addMediaSource(createFakeMediaSource(), timelineGrabber);
-            }
-          });
+          () -> mediaSource.addMediaSource(createFakeMediaSource(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(1);
     } finally {
@@ -504,15 +491,11 @@ public void testCustomCallbackAfterPreparationAddMultiple() throws IOException {
       testRunner.prepareSource();
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
+          () ->
               mediaSource.addMediaSources(
                   Arrays.asList(
                       new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
-                  timelineGrabber);
-            }
-          });
+                  timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
     } finally {
@@ -527,12 +510,8 @@ public void testCustomCallbackAfterPreparationAddSingleWithIndex() throws IOExce
       testRunner.prepareSource();
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), timelineGrabber);
-            }
-          });
+          () ->
+              mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(1);
     } finally {
@@ -547,16 +526,12 @@ public void testCustomCallbackAfterPreparationAddMultipleWithIndex() throws IOEx
       testRunner.prepareSource();
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
+          () ->
               mediaSource.addMediaSources(
                   /* index */ 0,
                   Arrays.asList(
                       new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
-                  timelineGrabber);
-            }
-          });
+                  timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
     } finally {
@@ -569,23 +544,12 @@ public void testCustomCallbackAfterPreparationRemove() throws IOException {
     DummyMainThread dummyMainThread = new DummyMainThread();
     try {
       testRunner.prepareSource();
-      dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              mediaSource.addMediaSource(createFakeMediaSource());
-            }
-          });
+      dummyMainThread.runOnMainThread(() -> mediaSource.addMediaSource(createFakeMediaSource()));
       testRunner.assertTimelineChangeBlocking();
 
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              mediaSource.removeMediaSource(/* index */ 0, timelineGrabber);
-            }
-          });
+          () -> mediaSource.removeMediaSource(/* index */ 0, timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(0);
     } finally {
@@ -599,24 +563,15 @@ public void testCustomCallbackAfterPreparationMove() throws IOException {
     try {
       testRunner.prepareSource();
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
+          () ->
               mediaSource.addMediaSources(
                   Arrays.asList(
-                      new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}));
-            }
-          });
+                      new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()})));
       testRunner.assertTimelineChangeBlocking();
 
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          new Runnable() {
-            @Override
-            public void run() {
-              mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, timelineGrabber);
-            }
-          });
+          () -> mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
     } finally {
@@ -652,23 +607,27 @@ public void testPeriodCreationWithAds() throws IOException, InterruptedException
 
     // Create all periods and assert period creation of child media sources has been called.
     testRunner.assertPrepareAndReleaseAllPeriods();
+    Object timelineContentOnlyPeriodUid0 = timelineContentOnly.getUidOfPeriod(/* periodIndex= */ 0);
+    Object timelineContentOnlyPeriodUid1 = timelineContentOnly.getUidOfPeriod(/* periodIndex= */ 1);
+    Object timelineWithAdsPeriodUid0 = timelineWithAds.getUidOfPeriod(/* periodIndex= */ 0);
+    Object timelineWithAdsPeriodUid1 = timelineWithAds.getUidOfPeriod(/* periodIndex= */ 1);
     mediaSourceContentOnly.assertMediaPeriodCreated(
-        new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+        new MediaPeriodId(timelineContentOnlyPeriodUid0, /* windowSequenceNumber= */ 0));
     mediaSourceContentOnly.assertMediaPeriodCreated(
-        new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 0));
+        new MediaPeriodId(timelineContentOnlyPeriodUid1, /* windowSequenceNumber= */ 0));
     mediaSourceWithAds.assertMediaPeriodCreated(
-        new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 1));
+        new MediaPeriodId(timelineWithAdsPeriodUid0, /* windowSequenceNumber= */ 1));
     mediaSourceWithAds.assertMediaPeriodCreated(
-        new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1));
+        new MediaPeriodId(timelineWithAdsPeriodUid1, /* windowSequenceNumber= */ 1));
     mediaSourceWithAds.assertMediaPeriodCreated(
         new MediaPeriodId(
-            /* periodIndex= */ 0,
+            timelineWithAdsPeriodUid0,
             /* adGroupIndex= */ 0,
             /* adIndexInAdGroup= */ 0,
             /* windowSequenceNumber= */ 1));
     mediaSourceWithAds.assertMediaPeriodCreated(
         new MediaPeriodId(
-            /* periodIndex= */ 1,
+            timelineWithAdsPeriodUid1,
             /* adGroupIndex= */ 0,
             /* adIndexInAdGroup= */ 0,
             /* windowSequenceNumber= */ 1));
@@ -683,7 +642,7 @@ public void testAtomicTimelineWindowOrder() throws IOException {
     ConcatenatingMediaSource mediaSource =
         new ConcatenatingMediaSource(/* isAtomic= */ true, new FakeShuffleOrder(0));
     testRunner = new MediaSourceTestRunner(mediaSource, null);
-    mediaSource.addMediaSources(Arrays.<MediaSource>asList(createMediaSources(3)));
+    mediaSource.addMediaSources(Arrays.asList(createMediaSources(3)));
     Timeline timeline = testRunner.prepareSource();
     TimelineAsserts.assertWindowTags(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
@@ -768,10 +727,11 @@ public void testNestedTimeline() throws IOException {
   public void testRemoveChildSourceWithActiveMediaPeriod() throws IOException {
     FakeMediaSource childSource = createFakeMediaSource();
     mediaSource.addMediaSource(childSource);
-    testRunner.prepareSource();
+    Timeline timeline = testRunner.prepareSource();
     MediaPeriod mediaPeriod =
         testRunner.createPeriod(
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
     mediaSource.removeMediaSource(/* index= */ 0);
     testRunner.assertTimelineChangeBlocking();
     testRunner.releasePeriod(mediaPeriod);
@@ -781,27 +741,29 @@ public void testRemoveChildSourceWithActiveMediaPeriod() throws IOException {
 
   @Test
   public void testDuplicateMediaSources() throws IOException, InterruptedException {
-    FakeMediaSource childSource =
-        new FakeMediaSource(new FakeTimeline(/* windowCount= */ 2), /* manifest= */ null);
+    Timeline childTimeline = new FakeTimeline(/* windowCount= */ 2);
+    FakeMediaSource childSource = new FakeMediaSource(childTimeline, /* manifest= */ null);
 
     mediaSource.addMediaSource(childSource);
     mediaSource.addMediaSource(childSource);
     testRunner.prepareSource();
-    mediaSource.addMediaSources(Arrays.<MediaSource>asList(childSource, childSource));
+    mediaSource.addMediaSources(Arrays.asList(childSource, childSource));
     Timeline timeline = testRunner.assertTimelineChangeBlocking();
 
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1, 1, 1, 1, 1);
     testRunner.assertPrepareAndReleaseAllPeriods();
+    Object childPeriodUid0 = childTimeline.getUidOfPeriod(/* periodIndex= */ 0);
+    Object childPeriodUid1 = childTimeline.getUidOfPeriod(/* periodIndex= */ 1);
     assertThat(childSource.getCreatedMediaPeriods())
         .containsAllOf(
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 2),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 4),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 6),
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1),
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 3),
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 5),
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 7));
+            new MediaPeriodId(childPeriodUid0, /* windowSequenceNumber= */ 0),
+            new MediaPeriodId(childPeriodUid0, /* windowSequenceNumber= */ 2),
+            new MediaPeriodId(childPeriodUid0, /* windowSequenceNumber= */ 4),
+            new MediaPeriodId(childPeriodUid0, /* windowSequenceNumber= */ 6),
+            new MediaPeriodId(childPeriodUid1, /* windowSequenceNumber= */ 1),
+            new MediaPeriodId(childPeriodUid1, /* windowSequenceNumber= */ 3),
+            new MediaPeriodId(childPeriodUid1, /* windowSequenceNumber= */ 5),
+            new MediaPeriodId(childPeriodUid1, /* windowSequenceNumber= */ 7));
     // Assert that only one manifest load is reported because the source is reused.
     testRunner.assertCompletedManifestLoads(/* windowIndices= */ 0);
     assertCompletedAllMediaPeriodLoads(timeline);
@@ -812,13 +774,13 @@ public void testDuplicateMediaSources() throws IOException, InterruptedException
 
   @Test
   public void testDuplicateNestedMediaSources() throws IOException, InterruptedException {
-    FakeMediaSource childSource =
-        new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1), /* manifest= */ null);
+    Timeline childTimeline = new FakeTimeline(/* windowCount= */ 1);
+    FakeMediaSource childSource = new FakeMediaSource(childTimeline, /* manifest= */ null);
     ConcatenatingMediaSource nestedConcatenation = new ConcatenatingMediaSource();
 
     testRunner.prepareSource();
     mediaSource.addMediaSources(
-        Arrays.<MediaSource>asList(childSource, nestedConcatenation, nestedConcatenation));
+        Arrays.asList(childSource, nestedConcatenation, nestedConcatenation));
     testRunner.assertTimelineChangeBlocking();
     nestedConcatenation.addMediaSource(childSource);
     testRunner.assertTimelineChangeBlocking();
@@ -827,13 +789,14 @@ public void testDuplicateNestedMediaSources() throws IOException, InterruptedExc
 
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1, 1);
     testRunner.assertPrepareAndReleaseAllPeriods();
+    Object childPeriodUid = childTimeline.getUidOfPeriod(/* periodIndex= */ 0);
     assertThat(childSource.getCreatedMediaPeriods())
         .containsAllOf(
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 1),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 2),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 3),
-            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 4));
+            new MediaPeriodId(childPeriodUid, /* windowSequenceNumber= */ 0),
+            new MediaPeriodId(childPeriodUid, /* windowSequenceNumber= */ 1),
+            new MediaPeriodId(childPeriodUid, /* windowSequenceNumber= */ 2),
+            new MediaPeriodId(childPeriodUid, /* windowSequenceNumber= */ 3),
+            new MediaPeriodId(childPeriodUid, /* windowSequenceNumber= */ 4));
     // Assert that only one manifest load is needed because the source is reused.
     testRunner.assertCompletedManifestLoads(/* windowIndices= */ 0);
     assertCompletedAllMediaPeriodLoads(timeline);
@@ -849,23 +812,14 @@ public void testClear() throws IOException {
     final FakeMediaSource unpreparedChildSource =
         new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
     dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            mediaSource.addMediaSource(preparedChildSource);
-            mediaSource.addMediaSource(unpreparedChildSource);
-          }
+        () -> {
+          mediaSource.addMediaSource(preparedChildSource);
+          mediaSource.addMediaSource(unpreparedChildSource);
         });
     testRunner.prepareSource();
     final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
 
-    dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            mediaSource.clear(timelineGrabber);
-          }
-        });
+    dummyMainThread.runOnMainThread(() -> mediaSource.clear(timelineGrabber));
 
     Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
     assertThat(timeline.isEmpty()).isTrue();
@@ -875,21 +829,20 @@ public void run() {
 
   @Test
   public void testReleaseAndReprepareSource() throws IOException {
-    Period period = new Period();
     FakeMediaSource[] fakeMediaSources = createMediaSources(/* count= */ 2);
     mediaSource.addMediaSource(fakeMediaSources[0]); // Child source with 1 period.
     mediaSource.addMediaSource(fakeMediaSources[1]); // Child source with 2 periods.
     Timeline timeline = testRunner.prepareSource();
-    Object periodId0 = timeline.getPeriod(/* periodIndex= */ 0, period, /* setIds= */ true).uid;
-    Object periodId1 = timeline.getPeriod(/* periodIndex= */ 1, period, /* setIds= */ true).uid;
-    Object periodId2 = timeline.getPeriod(/* periodIndex= */ 2, period, /* setIds= */ true).uid;
+    Object periodId0 = timeline.getUidOfPeriod(/* periodIndex= */ 0);
+    Object periodId1 = timeline.getUidOfPeriod(/* periodIndex= */ 1);
+    Object periodId2 = timeline.getUidOfPeriod(/* periodIndex= */ 2);
     testRunner.releaseSource();
 
     mediaSource.moveMediaSource(/* currentIndex= */ 1, /* newIndex= */ 0);
     timeline = testRunner.prepareSource();
-    Object newPeriodId0 = timeline.getPeriod(/* periodIndex= */ 0, period, /* setIds= */ true).uid;
-    Object newPeriodId1 = timeline.getPeriod(/* periodIndex= */ 1, period, /* setIds= */ true).uid;
-    Object newPeriodId2 = timeline.getPeriod(/* periodIndex= */ 2, period, /* setIds= */ true).uid;
+    Object newPeriodId0 = timeline.getUidOfPeriod(/* periodIndex= */ 0);
+    Object newPeriodId1 = timeline.getUidOfPeriod(/* periodIndex= */ 1);
+    Object newPeriodId2 = timeline.getUidOfPeriod(/* periodIndex= */ 2);
     assertThat(newPeriodId0).isEqualTo(periodId1);
     assertThat(newPeriodId1).isEqualTo(periodId2);
     assertThat(newPeriodId2).isEqualTo(periodId0);
@@ -901,16 +854,139 @@ public void testChildTimelineChangeWithActiveMediaPeriod() throws IOException {
     ConcatenatingMediaSource childSource = new ConcatenatingMediaSource(nestedChildSources);
     mediaSource.addMediaSource(childSource);
 
-    testRunner.prepareSource();
+    Timeline timeline = testRunner.prepareSource();
     MediaPeriod mediaPeriod =
         testRunner.createPeriod(
-            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 0));
+            new MediaPeriodId(
+                timeline.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 0));
     childSource.moveMediaSource(/* currentIndex= */ 0, /* newIndex= */ 1);
-    testRunner.assertTimelineChangeBlocking();
+    timeline = testRunner.assertTimelineChangeBlocking();
     testRunner.preparePeriod(mediaPeriod, /* positionUs= */ 0);
 
     testRunner.assertCompletedMediaPeriodLoads(
-        new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+        new MediaPeriodId(
+            timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
+  }
+
+  @Test
+  public void testChildSourceIsNotPreparedWithLazyPreparation() throws IOException {
+    FakeMediaSource[] childSources = createMediaSources(/* count= */ 2);
+    mediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            /* useLazyPreparation= */ true,
+            new DefaultShuffleOrder(0),
+            childSources);
+    testRunner = new MediaSourceTestRunner(mediaSource, /* allocator= */ null);
+    testRunner.prepareSource();
+
+    assertThat(childSources[0].isPrepared()).isFalse();
+    assertThat(childSources[1].isPrepared()).isFalse();
+  }
+
+  @Test
+  public void testChildSourceIsPreparedWithLazyPreparationAfterPeriodCreation() throws IOException {
+    FakeMediaSource[] childSources = createMediaSources(/* count= */ 2);
+    mediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            /* useLazyPreparation= */ true,
+            new DefaultShuffleOrder(0),
+            childSources);
+    testRunner = new MediaSourceTestRunner(mediaSource, /* allocator= */ null);
+    Timeline timeline = testRunner.prepareSource();
+    testRunner.createPeriod(
+        new MediaPeriodId(
+            timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0));
+
+    assertThat(childSources[0].isPrepared()).isTrue();
+    assertThat(childSources[1].isPrepared()).isFalse();
+  }
+
+  @Test
+  public void testChildSourceWithLazyPreparationOnlyPreparesSourceOnce() throws IOException {
+    FakeMediaSource[] childSources = createMediaSources(/* count= */ 2);
+    mediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            /* useLazyPreparation= */ true,
+            new DefaultShuffleOrder(0),
+            childSources);
+    testRunner = new MediaSourceTestRunner(mediaSource, /* allocator= */ null);
+    Timeline timeline = testRunner.prepareSource();
+
+    // The lazy preparation must only be triggered once, even if we create multiple periods from
+    // the media source. FakeMediaSource.prepareSource asserts that it's not called twice, so
+    // creating two periods shouldn't throw.
+    MediaPeriodId mediaPeriodId =
+        new MediaPeriodId(
+            timeline.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0);
+    testRunner.createPeriod(mediaPeriodId);
+    testRunner.createPeriod(mediaPeriodId);
+  }
+
+  @Test
+  public void testRemoveUnpreparedChildSourceWithLazyPreparation() throws IOException {
+    FakeMediaSource[] childSources = createMediaSources(/* count= */ 2);
+    mediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            /* useLazyPreparation= */ true,
+            new DefaultShuffleOrder(0),
+            childSources);
+    testRunner = new MediaSourceTestRunner(mediaSource, /* allocator= */ null);
+    testRunner.prepareSource();
+
+    // Check that removal doesn't throw even though the child sources are unprepared.
+    mediaSource.removeMediaSource(0);
+  }
+
+  @Test
+  public void testSetShuffleOrderBeforePreparation() throws Exception {
+    mediaSource.setShuffleOrder(new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0));
+    mediaSource.addMediaSources(
+        Arrays.asList(createFakeMediaSource(), createFakeMediaSource(), createFakeMediaSource()));
+    Timeline timeline = testRunner.prepareSource();
+
+    assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(0);
+  }
+
+  @Test
+  public void testSetShuffleOrderAfterPreparation() throws Exception {
+    mediaSource.addMediaSources(
+        Arrays.asList(createFakeMediaSource(), createFakeMediaSource(), createFakeMediaSource()));
+    testRunner.prepareSource();
+    mediaSource.setShuffleOrder(new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 3));
+    Timeline timeline = testRunner.assertTimelineChangeBlocking();
+
+    assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(0);
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationSetShuffleOrder() throws Exception {
+    Runnable runnable = Mockito.mock(Runnable.class);
+    mediaSource.setShuffleOrder(new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0), runnable);
+
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationSetShuffleOrder() throws Exception {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      mediaSource.addMediaSources(
+          Arrays.asList(createFakeMediaSource(), createFakeMediaSource(), createFakeMediaSource()));
+      testRunner.prepareSource();
+      TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          () ->
+              mediaSource.setShuffleOrder(
+                  new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 3), timelineGrabber));
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(0);
+    } finally {
+      dummyMainThread.release();
+    }
   }
 
   private void assertCompletedAllMediaPeriodLoads(Timeline timeline) {
@@ -923,11 +999,12 @@ private void assertCompletedAllMediaPeriodLoads(Timeline timeline) {
           periodIndex <= window.lastPeriodIndex;
           periodIndex++) {
         timeline.getPeriod(periodIndex, period);
-        expectedMediaPeriodIds.add(new MediaPeriodId(periodIndex, windowIndex));
+        Object periodUid = timeline.getUidOfPeriod(periodIndex);
+        expectedMediaPeriodIds.add(new MediaPeriodId(periodUid, windowIndex));
         for (int adGroupIndex = 0; adGroupIndex < period.getAdGroupCount(); adGroupIndex++) {
           for (int adIndex = 0; adIndex < period.getAdCountInAdGroup(adGroupIndex); adIndex++) {
             expectedMediaPeriodIds.add(
-                new MediaPeriodId(periodIndex, adGroupIndex, adIndex, windowIndex));
+                new MediaPeriodId(periodUid, adGroupIndex, adIndex, windowIndex));
           }
         }
       }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
index d639bc168a..9b7455ee37 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
@@ -48,7 +48,7 @@ public void setUp() throws Exception {
   }
 
   @Test
-  public void testSingleLoop() throws IOException {
+  public void testSingleLoopTimeline() throws IOException {
     Timeline timeline = getLoopingTimeline(multiWindowTimeline, 1);
     TimelineAsserts.assertWindowTags(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
@@ -67,7 +67,7 @@ public void testSingleLoop() throws IOException {
   }
 
   @Test
-  public void testMultiLoop() throws IOException {
+  public void testMultiLoopTimeline() throws IOException {
     Timeline timeline = getLoopingTimeline(multiWindowTimeline, 3);
     TimelineAsserts.assertWindowTags(timeline, 111, 222, 333, 111, 222, 333, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1, 1, 1, 1, 1, 1);
@@ -88,7 +88,7 @@ public void testMultiLoop() throws IOException {
   }
 
   @Test
-  public void testInfiniteLoop() throws IOException {
+  public void testInfiniteLoopTimeline() throws IOException {
     Timeline timeline = getLoopingTimeline(multiWindowTimeline, Integer.MAX_VALUE);
     TimelineAsserts.assertWindowTags(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
@@ -117,6 +117,21 @@ public void testEmptyTimelineLoop() throws IOException {
     TimelineAsserts.assertEmpty(timeline);
   }
 
+  @Test
+  public void testSingleLoopPeriodCreation() throws Exception {
+    testMediaPeriodCreation(multiWindowTimeline, /* loopCount= */ 1);
+  }
+
+  @Test
+  public void testMultiLoopPeriodCreation() throws Exception {
+    testMediaPeriodCreation(multiWindowTimeline, /* loopCount= */ 3);
+  }
+
+  @Test
+  public void testInfiniteLoopPeriodCreation() throws Exception {
+    testMediaPeriodCreation(multiWindowTimeline, /* loopCount= */ Integer.MAX_VALUE);
+  }
+
   /**
    * Wraps the specified timeline in a {@link LoopingMediaSource} and returns the looping timeline.
    */
@@ -133,4 +148,21 @@ private static Timeline getLoopingTimeline(Timeline timeline, int loopCount) thr
       testRunner.release();
     }
   }
+
+  /**
+   * Wraps the specified timeline in a {@link LoopingMediaSource} and asserts that all periods of
+   * the looping timeline can be created and prepared.
+   */
+  private static void testMediaPeriodCreation(Timeline timeline, int loopCount) throws Exception {
+    FakeMediaSource fakeMediaSource = new FakeMediaSource(timeline, null);
+    LoopingMediaSource mediaSource = new LoopingMediaSource(fakeMediaSource, loopCount);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      testRunner.prepareSource();
+      testRunner.assertPrepareAndReleaseAllPeriods();
+      testRunner.releaseSource();
+    } finally {
+      testRunner.release();
+    }
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
index 839492f196..3318f5a42f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
@@ -65,6 +65,27 @@ public void testMergingTimelinesWithDifferentPeriodCounts() throws IOException {
     }
   }
 
+  @Test
+  public void testMergingMediaSourcePeriodCreation() throws Exception {
+    FakeMediaSource[] mediaSources = new FakeMediaSource[2];
+    for (int i = 0; i < mediaSources.length; i++) {
+      mediaSources[i] =
+          new FakeMediaSource(new FakeTimeline(/* windowCount= */ 2), /* manifest= */ null);
+    }
+    MergingMediaSource mediaSource = new MergingMediaSource(mediaSources);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      testRunner.prepareSource();
+      testRunner.assertPrepareAndReleaseAllPeriods();
+      for (FakeMediaSource element : mediaSources) {
+        assertThat(element.getCreatedMediaPeriods()).isNotEmpty();
+      }
+      testRunner.releaseSource();
+    } finally {
+      testRunner.release();
+    }
+  }
+
   /**
    * Wraps the specified timelines in a {@link MergingMediaSource}, prepares it and checks that it
    * forwards the first of the wrapped timelines.
@@ -74,15 +95,15 @@ private static void testMergingMediaSourcePrepare(Timeline... timelines) throws
     for (int i = 0; i < timelines.length; i++) {
       mediaSources[i] = new FakeMediaSource(timelines[i], null);
     }
-    MergingMediaSource mediaSource = new MergingMediaSource(mediaSources);
-    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    MergingMediaSource mergingMediaSource = new MergingMediaSource(mediaSources);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mergingMediaSource, null);
     try {
       Timeline timeline = testRunner.prepareSource();
       // The merged timeline should always be the one from the first child.
       assertThat(timeline).isEqualTo(timelines[0]);
       testRunner.releaseSource();
-      for (int i = 0; i < mediaSources.length; i++) {
-        mediaSources[i].assertReleased();
+      for (FakeMediaSource mediaSource : mediaSources) {
+        mediaSource.assertReleased();
       }
     } finally {
       testRunner.release();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
index 4d6b6dd72d..3d78ecfb4c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
@@ -23,6 +23,7 @@
 import static java.lang.Long.MIN_VALUE;
 import static java.util.Arrays.copyOfRange;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -45,41 +46,51 @@
 
   private static final int ALLOCATION_SIZE = 16;
 
-  private static final Format TEST_FORMAT_1 = Format.createSampleFormat("1", "mimeType", 0);
-  private static final Format TEST_FORMAT_2 = Format.createSampleFormat("2", "mimeType", 0);
-  private static final Format TEST_FORMAT_1_COPY = Format.createSampleFormat("1", "mimeType", 0);
-  private static final byte[] TEST_DATA = TestUtil.buildTestData(ALLOCATION_SIZE * 10);
+  private static final Format FORMAT_1 = Format.createSampleFormat("1", "mimeType", 0);
+  private static final Format FORMAT_2 = Format.createSampleFormat("2", "mimeType", 0);
+  private static final Format FORMAT_1_COPY = Format.createSampleFormat("1", "mimeType", 0);
+  private static final Format FORMAT_SPLICED = Format.createSampleFormat("spliced", "mimeType", 0);
+  private static final byte[] DATA = TestUtil.buildTestData(ALLOCATION_SIZE * 10);
 
   /*
-   * TEST_SAMPLE_SIZES and TEST_SAMPLE_OFFSETS are intended to test various boundary cases (with
-   * respect to the allocation size). TEST_SAMPLE_OFFSETS values are defined as the backward offsets
-   * (as expected by SampleQueue.sampleMetadata) assuming that TEST_DATA has been written to the
+   * SAMPLE_SIZES and SAMPLE_OFFSETS are intended to test various boundary cases (with
+   * respect to the allocation size). SAMPLE_OFFSETS values are defined as the backward offsets
+   * (as expected by SampleQueue.sampleMetadata) assuming that DATA has been written to the
    * sampleQueue in full. The allocations are filled as follows, where | indicates a boundary
    * between allocations and x indicates a byte that doesn't belong to a sample:
    *
    * x<s1>|x<s2>x|x<s3>|<s4>x|<s5>|<s6|s6>|x<s7|s7>x|<s8>
    */
-  private static final int[] TEST_SAMPLE_SIZES = new int[] {
-      ALLOCATION_SIZE - 1, ALLOCATION_SIZE - 2, ALLOCATION_SIZE - 1, ALLOCATION_SIZE - 1,
-      ALLOCATION_SIZE, ALLOCATION_SIZE * 2, ALLOCATION_SIZE * 2 - 2, ALLOCATION_SIZE
-  };
-  private static final int[] TEST_SAMPLE_OFFSETS = new int[] {
-      ALLOCATION_SIZE * 9, ALLOCATION_SIZE * 8 + 1, ALLOCATION_SIZE * 7, ALLOCATION_SIZE * 6 + 1,
-      ALLOCATION_SIZE * 5, ALLOCATION_SIZE * 3, ALLOCATION_SIZE + 1, 0
-  };
-  private static final long[] TEST_SAMPLE_TIMESTAMPS = new long[] {
-      0, 1000, 2000, 3000, 4000, 5000, 6000, 7000
-  };
-  private static final long LAST_SAMPLE_TIMESTAMP =
-      TEST_SAMPLE_TIMESTAMPS[TEST_SAMPLE_TIMESTAMPS.length - 1];
-  private static final int[] TEST_SAMPLE_FLAGS = new int[] {
-      C.BUFFER_FLAG_KEY_FRAME, 0, 0, 0, C.BUFFER_FLAG_KEY_FRAME, 0, 0, 0
-  };
-  private static final Format[] TEST_SAMPLE_FORMATS = new Format[] {
-      TEST_FORMAT_1, TEST_FORMAT_1, TEST_FORMAT_1, TEST_FORMAT_1, TEST_FORMAT_2, TEST_FORMAT_2,
-      TEST_FORMAT_2, TEST_FORMAT_2
-  };
-  private static final int TEST_DATA_SECOND_KEYFRAME_INDEX = 4;
+  private static final int[] SAMPLE_SIZES =
+      new int[] {
+        ALLOCATION_SIZE - 1,
+        ALLOCATION_SIZE - 2,
+        ALLOCATION_SIZE - 1,
+        ALLOCATION_SIZE - 1,
+        ALLOCATION_SIZE,
+        ALLOCATION_SIZE * 2,
+        ALLOCATION_SIZE * 2 - 2,
+        ALLOCATION_SIZE
+      };
+  private static final int[] SAMPLE_OFFSETS =
+      new int[] {
+        ALLOCATION_SIZE * 9,
+        ALLOCATION_SIZE * 8 + 1,
+        ALLOCATION_SIZE * 7,
+        ALLOCATION_SIZE * 6 + 1,
+        ALLOCATION_SIZE * 5,
+        ALLOCATION_SIZE * 3,
+        ALLOCATION_SIZE + 1,
+        0
+      };
+  private static final long[] SAMPLE_TIMESTAMPS =
+      new long[] {0, 1000, 2000, 3000, 4000, 5000, 6000, 7000};
+  private static final long LAST_SAMPLE_TIMESTAMP = SAMPLE_TIMESTAMPS[SAMPLE_TIMESTAMPS.length - 1];
+  private static final int[] SAMPLE_FLAGS =
+      new int[] {C.BUFFER_FLAG_KEY_FRAME, 0, 0, 0, C.BUFFER_FLAG_KEY_FRAME, 0, 0, 0};
+  private static final Format[] SAMPLE_FORMATS =
+      new Format[] {FORMAT_1, FORMAT_1, FORMAT_1, FORMAT_1, FORMAT_2, FORMAT_2, FORMAT_2, FORMAT_2};
+  private static final int DATA_SECOND_KEYFRAME_INDEX = 4;
 
   private Allocator allocator;
   private SampleQueue sampleQueue;
@@ -117,37 +128,37 @@ public void testReadWithoutWrite() {
 
   @Test
   public void testReadFormatDeduplicated() {
-    sampleQueue.format(TEST_FORMAT_1);
-    assertReadFormat(false, TEST_FORMAT_1);
+    sampleQueue.format(FORMAT_1);
+    assertReadFormat(false, FORMAT_1);
     // If the same format is input then it should be de-duplicated (i.e. not output again).
-    sampleQueue.format(TEST_FORMAT_1);
-    assertNoSamplesToRead(TEST_FORMAT_1);
+    sampleQueue.format(FORMAT_1);
+    assertNoSamplesToRead(FORMAT_1);
     // The same applies for a format that's equal (but a different object).
-    sampleQueue.format(TEST_FORMAT_1_COPY);
-    assertNoSamplesToRead(TEST_FORMAT_1);
+    sampleQueue.format(FORMAT_1_COPY);
+    assertNoSamplesToRead(FORMAT_1);
   }
 
   @Test
   public void testReadSingleSamples() {
-    sampleQueue.sampleData(new ParsableByteArray(TEST_DATA), ALLOCATION_SIZE);
+    sampleQueue.sampleData(new ParsableByteArray(DATA), ALLOCATION_SIZE);
 
     assertAllocationCount(1);
     // Nothing to read.
     assertNoSamplesToRead(null);
 
-    sampleQueue.format(TEST_FORMAT_1);
+    sampleQueue.format(FORMAT_1);
 
     // Read the format.
-    assertReadFormat(false, TEST_FORMAT_1);
+    assertReadFormat(false, FORMAT_1);
     // Nothing to read.
-    assertNoSamplesToRead(TEST_FORMAT_1);
+    assertNoSamplesToRead(FORMAT_1);
 
     sampleQueue.sampleMetadata(1000, C.BUFFER_FLAG_KEY_FRAME, ALLOCATION_SIZE, 0, null);
 
     // If formatRequired, should read the format rather than the sample.
-    assertReadFormat(true, TEST_FORMAT_1);
+    assertReadFormat(true, FORMAT_1);
     // Otherwise should read the sample.
-    assertSampleRead(1000, true, TEST_DATA, 0, ALLOCATION_SIZE);
+    assertReadSample(1000, true, DATA, 0, ALLOCATION_SIZE);
     // Allocation should still be held.
     assertAllocationCount(1);
     sampleQueue.discardToRead();
@@ -155,16 +166,16 @@ public void testReadSingleSamples() {
     assertAllocationCount(0);
 
     // Nothing to read.
-    assertNoSamplesToRead(TEST_FORMAT_1);
+    assertNoSamplesToRead(FORMAT_1);
 
     // Write a second sample followed by one byte that does not belong to it.
-    sampleQueue.sampleData(new ParsableByteArray(TEST_DATA), ALLOCATION_SIZE);
+    sampleQueue.sampleData(new ParsableByteArray(DATA), ALLOCATION_SIZE);
     sampleQueue.sampleMetadata(2000, 0, ALLOCATION_SIZE - 1, 1, null);
 
     // If formatRequired, should read the format rather than the sample.
-    assertReadFormat(true, TEST_FORMAT_1);
+    assertReadFormat(true, FORMAT_1);
     // Read the sample.
-    assertSampleRead(2000, false, TEST_DATA, 0, ALLOCATION_SIZE - 1);
+    assertReadSample(2000, false, DATA, 0, ALLOCATION_SIZE - 1);
     // Allocation should still be held.
     assertAllocationCount(1);
     sampleQueue.discardToRead();
@@ -176,9 +187,9 @@ public void testReadSingleSamples() {
     sampleQueue.sampleMetadata(3000, 0, 1, 0, null);
 
     // If formatRequired, should read the format rather than the sample.
-    assertReadFormat(true, TEST_FORMAT_1);
+    assertReadFormat(true, FORMAT_1);
     // Read the sample.
-    assertSampleRead(3000, false, TEST_DATA, ALLOCATION_SIZE - 1, 1);
+    assertReadSample(3000, false, DATA, ALLOCATION_SIZE - 1, 1);
     // Allocation should still be held.
     assertAllocationCount(1);
     sampleQueue.discardToRead();
@@ -202,8 +213,8 @@ public void testReadMultiSamplesTwice() {
     writeTestData();
     writeTestData();
     assertAllocationCount(20);
-    assertReadTestData(TEST_FORMAT_2);
-    assertReadTestData(TEST_FORMAT_2);
+    assertReadTestData(FORMAT_2);
+    assertReadTestData(FORMAT_2);
     assertAllocationCount(20);
     sampleQueue.discardToRead();
     assertAllocationCount(0);
@@ -251,15 +262,15 @@ public void testAdvanceToEnd() {
     assertAllocationCount(0);
     // Despite skipping all samples, we should still read the last format, since this is the
     // expected format for a subsequent sample.
-    assertReadFormat(false, TEST_FORMAT_2);
+    assertReadFormat(false, FORMAT_2);
     // Once the format has been read, there's nothing else to read.
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
   public void testAdvanceToEndRetainsUnassignedData() {
-    sampleQueue.format(TEST_FORMAT_1);
-    sampleQueue.sampleData(new ParsableByteArray(TEST_DATA), ALLOCATION_SIZE);
+    sampleQueue.format(FORMAT_1);
+    sampleQueue.sampleData(new ParsableByteArray(DATA), ALLOCATION_SIZE);
     sampleQueue.advanceToEnd();
     assertAllocationCount(1);
     sampleQueue.discardToRead();
@@ -267,14 +278,14 @@ public void testAdvanceToEndRetainsUnassignedData() {
     // written.
     assertAllocationCount(1);
     // We should be able to read the format.
-    assertReadFormat(false, TEST_FORMAT_1);
+    assertReadFormat(false, FORMAT_1);
     // Once the format has been read, there's nothing else to read.
-    assertNoSamplesToRead(TEST_FORMAT_1);
+    assertNoSamplesToRead(FORMAT_1);
 
     sampleQueue.sampleMetadata(0, C.BUFFER_FLAG_KEY_FRAME, ALLOCATION_SIZE, 0, null);
     // Once the metadata has been written, check the sample can be read as expected.
-    assertSampleRead(0, true, TEST_DATA, 0, ALLOCATION_SIZE);
-    assertNoSamplesToRead(TEST_FORMAT_1);
+    assertReadSample(0, true, DATA, 0, ALLOCATION_SIZE);
+    assertNoSamplesToRead(FORMAT_1);
     assertAllocationCount(1);
     sampleQueue.discardToRead();
     assertAllocationCount(0);
@@ -283,21 +294,21 @@ public void testAdvanceToEndRetainsUnassignedData() {
   @Test
   public void testAdvanceToBeforeBuffer() {
     writeTestData();
-    int skipCount = sampleQueue.advanceTo(TEST_SAMPLE_TIMESTAMPS[0] - 1, true, false);
+    int skipCount = sampleQueue.advanceTo(SAMPLE_TIMESTAMPS[0] - 1, true, false);
     // Should fail and have no effect.
     assertThat(skipCount).isEqualTo(ADVANCE_FAILED);
     assertReadTestData();
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
   public void testAdvanceToStartOfBuffer() {
     writeTestData();
-    int skipCount = sampleQueue.advanceTo(TEST_SAMPLE_TIMESTAMPS[0], true, false);
+    int skipCount = sampleQueue.advanceTo(SAMPLE_TIMESTAMPS[0], true, false);
     // Should succeed but have no effect (we're already at the first frame).
     assertThat(skipCount).isEqualTo(0);
     assertReadTestData();
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -306,8 +317,8 @@ public void testAdvanceToEndOfBuffer() {
     int skipCount = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP, true, false);
     // Should succeed and skip to 2nd keyframe (the 4th frame).
     assertThat(skipCount).isEqualTo(4);
-    assertReadTestData(null, TEST_DATA_SECOND_KEYFRAME_INDEX);
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertReadTestData(null, DATA_SECOND_KEYFRAME_INDEX);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -317,7 +328,7 @@ public void testAdvanceToAfterBuffer() {
     // Should fail and have no effect.
     assertThat(skipCount).isEqualTo(ADVANCE_FAILED);
     assertReadTestData();
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -326,8 +337,8 @@ public void testAdvanceToAfterBufferAllowed() {
     int skipCount = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP + 1, true, true);
     // Should succeed and skip to 2nd keyframe (the 4th frame).
     assertThat(skipCount).isEqualTo(4);
-    assertReadTestData(null, TEST_DATA_SECOND_KEYFRAME_INDEX);
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertReadTestData(null, DATA_SECOND_KEYFRAME_INDEX);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -339,10 +350,10 @@ public void testDiscardToEnd() {
     assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(0);
     // We should still be able to read the upstream format.
-    assertReadFormat(false, TEST_FORMAT_2);
+    assertReadFormat(false, FORMAT_2);
     // We should be able to write and read subsequent samples.
     writeTestData();
-    assertReadTestData(TEST_FORMAT_2);
+    assertReadTestData(FORMAT_2);
   }
 
   @Test
@@ -356,12 +367,12 @@ public void testDiscardToStopAtReadPosition() {
     // Read the first sample.
     assertReadTestData(null, 0, 1);
     // Shouldn't discard anything.
-    sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1] - 1, false, true);
+    sampleQueue.discardTo(SAMPLE_TIMESTAMPS[1] - 1, false, true);
     assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(10);
     // Should discard the read sample.
-    sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1], false, true);
+    sampleQueue.discardTo(SAMPLE_TIMESTAMPS[1], false, true);
     assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
@@ -371,7 +382,7 @@ public void testDiscardToStopAtReadPosition() {
     assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
     // Should be able to read the remaining samples.
-    assertReadTestData(TEST_FORMAT_1, 1, 7);
+    assertReadTestData(FORMAT_1, 1, 7);
     assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     // Should discard up to the second last sample
@@ -390,17 +401,17 @@ public void testDiscardToStopAtReadPosition() {
   public void testDiscardToDontStopAtReadPosition() {
     writeTestData();
     // Shouldn't discard anything.
-    sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1] - 1, false, false);
+    sampleQueue.discardTo(SAMPLE_TIMESTAMPS[1] - 1, false, false);
     assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertAllocationCount(10);
     // Should discard the first sample.
-    sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1], false, false);
+    sampleQueue.discardTo(SAMPLE_TIMESTAMPS[1], false, false);
     assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
     // Should be able to read the remaining samples.
-    assertReadTestData(TEST_FORMAT_1, 1, 7);
+    assertReadTestData(FORMAT_1, 1, 7);
   }
 
   @Test
@@ -424,8 +435,8 @@ public void testDiscardUpstream() {
     assertAllocationCount(1);
     sampleQueue.discardUpstreamSamples(0);
     assertAllocationCount(0);
-    assertReadFormat(false, TEST_FORMAT_2);
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertReadFormat(false, FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -435,8 +446,8 @@ public void testDiscardUpstreamMulti() {
     assertAllocationCount(4);
     sampleQueue.discardUpstreamSamples(0);
     assertAllocationCount(0);
-    assertReadFormat(false, TEST_FORMAT_2);
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertReadFormat(false, FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -445,8 +456,8 @@ public void testDiscardUpstreamBeforeRead() {
     sampleQueue.discardUpstreamSamples(4);
     assertAllocationCount(4);
     assertReadTestData(null, 0, 4);
-    assertReadFormat(false, TEST_FORMAT_2);
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertReadFormat(false, FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
@@ -467,18 +478,18 @@ public void testDiscardUpstreamAfterRead() {
     assertAllocationCount(1);
     sampleQueue.discardUpstreamSamples(3);
     assertAllocationCount(0);
-    assertReadFormat(false, TEST_FORMAT_2);
-    assertNoSamplesToRead(TEST_FORMAT_2);
+    assertReadFormat(false, FORMAT_2);
+    assertNoSamplesToRead(FORMAT_2);
   }
 
   @Test
   public void testLargestQueuedTimestampWithDiscardUpstream() {
     writeTestData();
     assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(LAST_SAMPLE_TIMESTAMP);
-    sampleQueue.discardUpstreamSamples(TEST_SAMPLE_TIMESTAMPS.length - 1);
+    sampleQueue.discardUpstreamSamples(SAMPLE_TIMESTAMPS.length - 1);
     // Discarding from upstream should reduce the largest timestamp.
     assertThat(sampleQueue.getLargestQueuedTimestampUs())
-        .isEqualTo(TEST_SAMPLE_TIMESTAMPS[TEST_SAMPLE_TIMESTAMPS.length - 2]);
+        .isEqualTo(SAMPLE_TIMESTAMPS[SAMPLE_TIMESTAMPS.length - 2]);
     sampleQueue.discardUpstreamSamples(0);
     // Discarding everything from upstream without reading should unset the largest timestamp.
     assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(MIN_VALUE);
@@ -487,14 +498,14 @@ public void testLargestQueuedTimestampWithDiscardUpstream() {
   @Test
   public void testLargestQueuedTimestampWithDiscardUpstreamDecodeOrder() {
     long[] decodeOrderTimestamps = new long[] {0, 3000, 2000, 1000, 4000, 7000, 6000, 5000};
-    writeTestData(TEST_DATA, TEST_SAMPLE_SIZES, TEST_SAMPLE_OFFSETS, decodeOrderTimestamps,
-        TEST_SAMPLE_FORMATS, TEST_SAMPLE_FLAGS);
+    writeTestData(
+        DATA, SAMPLE_SIZES, SAMPLE_OFFSETS, decodeOrderTimestamps, SAMPLE_FORMATS, SAMPLE_FLAGS);
     assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(7000);
-    sampleQueue.discardUpstreamSamples(TEST_SAMPLE_TIMESTAMPS.length - 2);
+    sampleQueue.discardUpstreamSamples(SAMPLE_TIMESTAMPS.length - 2);
     // Discarding the last two samples should not change the largest timestamp, due to the decode
     // ordering of the timestamps.
     assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(7000);
-    sampleQueue.discardUpstreamSamples(TEST_SAMPLE_TIMESTAMPS.length - 3);
+    sampleQueue.discardUpstreamSamples(SAMPLE_TIMESTAMPS.length - 3);
     // Once a third sample is discarded, the largest timestamp should have changed.
     assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(4000);
     sampleQueue.discardUpstreamSamples(0);
@@ -511,21 +522,77 @@ public void testLargestQueuedTimestampWithRead() {
     assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(LAST_SAMPLE_TIMESTAMP);
   }
 
+  @Test
+  public void testSetSampleOffset() {
+    long sampleOffsetUs = 1000;
+    sampleQueue.setSampleOffsetUs(sampleOffsetUs);
+    writeTestData();
+    assertReadTestData(null, 0, 8, sampleOffsetUs);
+    assertReadEndOfStream(false);
+  }
+
+  @Test
+  public void testSplice() {
+    writeTestData();
+    sampleQueue.splice();
+    // Splice should succeed, replacing the last 4 samples with the sample being written.
+    long spliceSampleTimeUs = SAMPLE_TIMESTAMPS[4];
+    writeSample(DATA, spliceSampleTimeUs, FORMAT_SPLICED, C.BUFFER_FLAG_KEY_FRAME);
+    assertReadTestData(null, 0, 4);
+    assertReadFormat(false, FORMAT_SPLICED);
+    assertReadSample(spliceSampleTimeUs, true, DATA, 0, DATA.length);
+    assertReadEndOfStream(false);
+  }
+
+  @Test
+  public void testSpliceAfterRead() {
+    writeTestData();
+    assertReadTestData(null, 0, 4);
+    sampleQueue.splice();
+    // Splice should fail, leaving the last 4 samples unchanged.
+    long spliceSampleTimeUs = SAMPLE_TIMESTAMPS[3];
+    writeSample(DATA, spliceSampleTimeUs, FORMAT_SPLICED, C.BUFFER_FLAG_KEY_FRAME);
+    assertReadTestData(SAMPLE_FORMATS[3], 4, 4);
+    assertReadEndOfStream(false);
+
+    sampleQueue.rewind();
+    assertReadTestData(null, 0, 4);
+    sampleQueue.splice();
+    // Splice should succeed, replacing the last 4 samples with the sample being written
+    spliceSampleTimeUs = SAMPLE_TIMESTAMPS[3] + 1;
+    writeSample(DATA, spliceSampleTimeUs, FORMAT_SPLICED, C.BUFFER_FLAG_KEY_FRAME);
+    assertReadFormat(false, FORMAT_SPLICED);
+    assertReadSample(spliceSampleTimeUs, true, DATA, 0, DATA.length);
+    assertReadEndOfStream(false);
+  }
+
+  @Test
+  public void testSpliceWithSampleOffset() {
+    long sampleOffsetUs = 30000;
+    sampleQueue.setSampleOffsetUs(sampleOffsetUs);
+    writeTestData();
+    sampleQueue.splice();
+    // Splice should succeed, replacing the last 4 samples with the sample being written.
+    long spliceSampleTimeUs = SAMPLE_TIMESTAMPS[4];
+    writeSample(DATA, spliceSampleTimeUs, FORMAT_SPLICED, C.BUFFER_FLAG_KEY_FRAME);
+    assertReadTestData(null, 0, 4, sampleOffsetUs);
+    assertReadFormat(false, FORMAT_SPLICED.copyWithSubsampleOffsetUs(sampleOffsetUs));
+    assertReadSample(spliceSampleTimeUs + sampleOffsetUs, true, DATA, 0, DATA.length);
+    assertReadEndOfStream(false);
+  }
+
   // Internal methods.
 
   /**
    * Writes standard test data to {@code sampleQueue}.
    */
-  @SuppressWarnings("ReferenceEquality")
   private void writeTestData() {
-    writeTestData(TEST_DATA, TEST_SAMPLE_SIZES, TEST_SAMPLE_OFFSETS, TEST_SAMPLE_TIMESTAMPS,
-        TEST_SAMPLE_FORMATS, TEST_SAMPLE_FLAGS);
+    writeTestData(
+        DATA, SAMPLE_SIZES, SAMPLE_OFFSETS, SAMPLE_TIMESTAMPS, SAMPLE_FORMATS, SAMPLE_FLAGS);
   }
 
   /**
    * Writes the specified test data to {@code sampleQueue}.
-   *
-   *
    */
   @SuppressWarnings("ReferenceEquality")
   private void writeTestData(byte[] data, int[] sampleSizes, int[] sampleOffsets,
@@ -542,6 +609,13 @@ private void writeTestData(byte[] data, int[] sampleSizes, int[] sampleOffsets,
     }
   }
 
+  /** Writes a single sample to {@code sampleQueue}. */
+  private void writeSample(byte[] data, long timestampUs, Format format, int sampleFlags) {
+    sampleQueue.format(format);
+    sampleQueue.sampleData(new ParsableByteArray(data), data.length);
+    sampleQueue.sampleMetadata(timestampUs, sampleFlags, data.length, 0, null);
+  }
+
   /**
    * Asserts correct reading of standard test data from {@code sampleQueue}.
    */
@@ -565,8 +639,7 @@ private void assertReadTestData(Format startFormat) {
    * @param firstSampleIndex The index of the first sample that's expected to be read.
    */
   private void assertReadTestData(Format startFormat, int firstSampleIndex) {
-    assertReadTestData(startFormat, firstSampleIndex,
-        TEST_SAMPLE_TIMESTAMPS.length - firstSampleIndex);
+    assertReadTestData(startFormat, firstSampleIndex, SAMPLE_TIMESTAMPS.length - firstSampleIndex);
   }
 
   /**
@@ -577,23 +650,38 @@ private void assertReadTestData(Format startFormat, int firstSampleIndex) {
    * @param sampleCount The number of samples to read.
    */
   private void assertReadTestData(Format startFormat, int firstSampleIndex, int sampleCount) {
-    Format format = startFormat;
+    assertReadTestData(startFormat, firstSampleIndex, sampleCount, 0);
+  }
+
+  /**
+   * Asserts correct reading of standard test data from {@code sampleQueue}.
+   *
+   * @param startFormat The format of the last sample previously read from {@code sampleQueue}.
+   * @param firstSampleIndex The index of the first sample that's expected to be read.
+   * @param sampleCount The number of samples to read.
+   * @param sampleOffsetUs The expected sample offset.
+   */
+  private void assertReadTestData(
+      Format startFormat, int firstSampleIndex, int sampleCount, long sampleOffsetUs) {
+    Format format = adjustFormat(startFormat, sampleOffsetUs);
     for (int i = firstSampleIndex; i < firstSampleIndex + sampleCount; i++) {
       // Use equals() on the read side despite using referential equality on the write side, since
       // sampleQueue de-duplicates written formats using equals().
-      if (!TEST_SAMPLE_FORMATS[i].equals(format)) {
+      Format testSampleFormat = adjustFormat(SAMPLE_FORMATS[i], sampleOffsetUs);
+      if (!testSampleFormat.equals(format)) {
         // If the format has changed, we should read it.
-        assertReadFormat(false, TEST_SAMPLE_FORMATS[i]);
-        format = TEST_SAMPLE_FORMATS[i];
+        assertReadFormat(false, testSampleFormat);
+        format = testSampleFormat;
       }
       // If we require the format, we should always read it.
-      assertReadFormat(true, TEST_SAMPLE_FORMATS[i]);
+      assertReadFormat(true, testSampleFormat);
       // Assert the sample is as expected.
-      assertSampleRead(TEST_SAMPLE_TIMESTAMPS[i],
-          (TEST_SAMPLE_FLAGS[i] & C.BUFFER_FLAG_KEY_FRAME) != 0,
-          TEST_DATA,
-          TEST_DATA.length - TEST_SAMPLE_OFFSETS[i] - TEST_SAMPLE_SIZES[i],
-          TEST_SAMPLE_SIZES[i]);
+      assertReadSample(
+          SAMPLE_TIMESTAMPS[i] + sampleOffsetUs,
+          (SAMPLE_FLAGS[i] & C.BUFFER_FLAG_KEY_FRAME) != 0,
+          DATA,
+          DATA.length - SAMPLE_OFFSETS[i] - SAMPLE_SIZES[i],
+          SAMPLE_SIZES[i]);
     }
   }
 
@@ -688,8 +776,8 @@ private void assertReadFormat(boolean formatRequired, Format format) {
    * @param offset The offset in {@code sampleData} of the expected sample data.
    * @param length The length of the expected sample data.
    */
-  private void assertSampleRead(long timeUs, boolean isKeyframe, byte[] sampleData, int offset,
-      int length) {
+  private void assertReadSample(
+      long timeUs, boolean isKeyframe, byte[] sampleData, int offset, int length) {
     clearFormatHolderAndInputBuffer();
     int result = sampleQueue.read(formatHolder, inputBuffer, false, false, 0);
     assertThat(result).isEqualTo(RESULT_BUFFER_READ);
@@ -738,4 +826,9 @@ private void clearFormatHolderAndInputBuffer() {
     inputBuffer.clear();
   }
 
+  private static Format adjustFormat(@Nullable Format format, long sampleOffsetUs) {
+    return format == null || sampleOffsetUs == 0
+        ? format
+        : format.copyWithSubsampleOffsetUs(sampleOffsetUs);
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
index e15c8f0aaa..430ceb87f1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
@@ -45,10 +45,32 @@ public void testDefaultShuffleOrder() {
         testCloneAndInsert(new DefaultShuffleOrder(initialLength, RANDOM_SEED), insertionPoint, 5);
       }
     }
-    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 0);
-    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 2);
-    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 4);
-    testCloneAndRemove(new DefaultShuffleOrder(1, RANDOM_SEED), 0);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 0, 1);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 2, 3);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 4, 5);
+    testCloneAndRemove(new DefaultShuffleOrder(1, RANDOM_SEED), 0, 1);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 0, 1000);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 0, 999);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 0, 500);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 100, 600);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 500, 1000);
+  }
+
+  @Test
+  public void testDefaultShuffleOrderSideloaded() {
+    int[] shuffledIndices = new int[] {2, 1, 0, 4, 3};
+    ShuffleOrder shuffleOrder = new DefaultShuffleOrder(shuffledIndices, RANDOM_SEED);
+    assertThat(shuffleOrder.getFirstIndex()).isEqualTo(2);
+    assertThat(shuffleOrder.getLastIndex()).isEqualTo(3);
+    for (int i = 0; i < 4; i++) {
+      assertThat(shuffleOrder.getNextIndex(shuffledIndices[i])).isEqualTo(shuffledIndices[i + 1]);
+    }
+    assertThat(shuffleOrder.getNextIndex(3)).isEqualTo(C.INDEX_UNSET);
+    for (int i = 4; i > 0; i--) {
+      assertThat(shuffleOrder.getPreviousIndex(shuffledIndices[i]))
+          .isEqualTo(shuffledIndices[i - 1]);
+    }
+    assertThat(shuffleOrder.getPreviousIndex(2)).isEqualTo(C.INDEX_UNSET);
   }
 
   @Test
@@ -63,10 +85,15 @@ public void testUnshuffledShuffleOrder() {
         testCloneAndInsert(new UnshuffledShuffleOrder(initialLength), insertionPoint, 5);
       }
     }
-    testCloneAndRemove(new UnshuffledShuffleOrder(5), 0);
-    testCloneAndRemove(new UnshuffledShuffleOrder(5), 2);
-    testCloneAndRemove(new UnshuffledShuffleOrder(5), 4);
-    testCloneAndRemove(new UnshuffledShuffleOrder(1), 0);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 0, 1);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 2, 3);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 4, 5);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1), 0, 1);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 0, 1000);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 0, 999);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 0, 500);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 100, 600);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 500, 1000);
   }
 
   @Test
@@ -120,22 +147,24 @@ private static void testCloneAndInsert(ShuffleOrder shuffleOrder, int position,
     }
   }
 
-  private static void testCloneAndRemove(ShuffleOrder shuffleOrder, int position) {
-    ShuffleOrder newOrder = shuffleOrder.cloneAndRemove(position);
-    assertShuffleOrderCorrectness(newOrder, shuffleOrder.getLength() - 1);
+  private static void testCloneAndRemove(
+      ShuffleOrder shuffleOrder, int indexFrom, int indexToExclusive) {
+    int numberOfElementsToRemove = indexToExclusive - indexFrom;
+    ShuffleOrder newOrder = shuffleOrder.cloneAndRemove(indexFrom, indexToExclusive);
+    assertShuffleOrderCorrectness(newOrder, shuffleOrder.getLength() - numberOfElementsToRemove);
     // Assert all elements still have the relative same order
     for (int i = 0; i < shuffleOrder.getLength(); i++) {
-      if (i == position) {
+      if (i >= indexFrom && i < indexToExclusive) {
         continue;
       }
       int expectedNextIndex = shuffleOrder.getNextIndex(i);
-      if (expectedNextIndex == position) {
+      while (expectedNextIndex >= indexFrom && expectedNextIndex < indexToExclusive) {
         expectedNextIndex = shuffleOrder.getNextIndex(expectedNextIndex);
       }
-      if (expectedNextIndex != C.INDEX_UNSET && expectedNextIndex >= position) {
-        expectedNextIndex--;
+      if (expectedNextIndex != C.INDEX_UNSET && expectedNextIndex >= indexFrom) {
+        expectedNextIndex -= numberOfElementsToRemove;
       }
-      int newNextIndex = newOrder.getNextIndex(i < position ? i : i - 1);
+      int newNextIndex = newOrder.getNextIndex(i < indexFrom ? i : i - numberOfElementsToRemove);
       assertThat(newNextIndex).isEqualTo(expectedNextIndex);
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
index 2587b78d99..1b57341d33 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
@@ -45,11 +45,11 @@ public void setUp() throws Exception {
   public void testGetPeriodPositionDynamicWindowUnknownDuration() {
     SinglePeriodTimeline timeline = new SinglePeriodTimeline(C.TIME_UNSET, false, true);
     // Should return null with any positive position projection.
-    Pair<Integer, Long> position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 1);
+    Pair<Object, Long> position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 1);
     assertThat(position).isNull();
     // Should return (0, 0) without a position projection.
     position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 0);
-    assertThat(position.first).isEqualTo(0);
+    assertThat(position.first).isEqualTo(timeline.getUidOfPeriod(0));
     assertThat(position.second).isEqualTo(0);
   }
 
@@ -66,16 +66,16 @@ public void testGetPeriodPositionDynamicWindowKnownDuration() {
             /* isDynamic= */ true,
             /* tag= */ null);
     // Should return null with a positive position projection beyond window duration.
-    Pair<Integer, Long> position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET,
-        windowDurationUs + 1);
+    Pair<Object, Long> position =
+        timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, windowDurationUs + 1);
     assertThat(position).isNull();
     // Should return (0, duration) with a projection equal to window duration.
     position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, windowDurationUs);
-    assertThat(position.first).isEqualTo(0);
+    assertThat(position.first).isEqualTo(timeline.getUidOfPeriod(0));
     assertThat(position.second).isEqualTo(windowDurationUs);
     // Should return (0, 0) without a position projection.
     position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 0);
-    assertThat(position.first).isEqualTo(0);
+    assertThat(position.first).isEqualTo(timeline.getUidOfPeriod(0));
     assertThat(position.second).isEqualTo(0);
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
index a8cc04473d..da03df9b8a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
@@ -89,6 +89,19 @@ public void testGetFirstAdIndexToPlaySkipsPlayedAd() {
     assertThat(state.adGroups[0].states[2]).isEqualTo(AdPlaybackState.AD_STATE_AVAILABLE);
   }
 
+  @Test
+  public void testGetFirstAdIndexToPlaySkipsSkippedAd() {
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 3);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, TEST_URI);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 2, TEST_URI);
+
+    state = state.withSkippedAd(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0);
+
+    assertThat(state.adGroups[0].getFirstAdIndexToPlay()).isEqualTo(1);
+    assertThat(state.adGroups[0].states[1]).isEqualTo(AdPlaybackState.AD_STATE_UNAVAILABLE);
+    assertThat(state.adGroups[0].states[2]).isEqualTo(AdPlaybackState.AD_STATE_AVAILABLE);
+  }
+
   @Test
   public void testGetFirstAdIndexToPlaySkipsErrorAds() {
     state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 3);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
index e9abaca075..1430c70e09 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.text.Cue;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,6 +37,7 @@
   private static final String TYPICAL_MISSING_SEQUENCE = "subrip/typical_missing_sequence";
   private static final String TYPICAL_NEGATIVE_TIMESTAMPS = "subrip/typical_negative_timestamps";
   private static final String TYPICAL_UNEXPECTED_END = "subrip/typical_unexpected_end";
+  private static final String TYPICAL_WITH_TAGS = "subrip/typical_with_tags";
   private static final String NO_END_TIMECODES_FILE = "subrip/no_end_timecodes";
 
   @Test
@@ -154,6 +156,33 @@ public void testDecodeNoEndTimecodes() throws IOException {
         .isEqualTo("Or to the end of the media.");
   }
 
+  @Test
+  public void testDecodeCueWithTag() throws IOException {
+    SubripDecoder decoder = new SubripDecoder();
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_WITH_TAGS);
+    SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
+
+    assertTypicalCue1(subtitle, 0);
+    assertTypicalCue2(subtitle, 2);
+    assertTypicalCue3(subtitle, 4);
+
+    assertThat(subtitle.getCues(subtitle.getEventTime(6)).get(0).text.toString())
+        .isEqualTo("This { \\an2} is not a valid tag due to the space after the opening bracket.");
+
+    assertThat(subtitle.getCues(subtitle.getEventTime(8)).get(0).text.toString())
+        .isEqualTo("This is the fifth subtitle with multiple valid tags.");
+
+    assertAlignmentCue(subtitle, 10, Cue.ANCHOR_TYPE_END, Cue.ANCHOR_TYPE_START); // {/an1}
+    assertAlignmentCue(subtitle, 12, Cue.ANCHOR_TYPE_END, Cue.ANCHOR_TYPE_MIDDLE); // {/an2}
+    assertAlignmentCue(subtitle, 14, Cue.ANCHOR_TYPE_END, Cue.ANCHOR_TYPE_END); // {/an3}
+    assertAlignmentCue(subtitle, 16, Cue.ANCHOR_TYPE_MIDDLE, Cue.ANCHOR_TYPE_START); // {/an4}
+    assertAlignmentCue(subtitle, 18, Cue.ANCHOR_TYPE_MIDDLE, Cue.ANCHOR_TYPE_MIDDLE); // {/an5}
+    assertAlignmentCue(subtitle, 20, Cue.ANCHOR_TYPE_MIDDLE, Cue.ANCHOR_TYPE_END); // {/an6}
+    assertAlignmentCue(subtitle, 22, Cue.ANCHOR_TYPE_START, Cue.ANCHOR_TYPE_START); // {/an7}
+    assertAlignmentCue(subtitle, 24, Cue.ANCHOR_TYPE_START, Cue.ANCHOR_TYPE_MIDDLE); // {/an8}
+    assertAlignmentCue(subtitle, 26, Cue.ANCHOR_TYPE_START, Cue.ANCHOR_TYPE_END); // {/an9}
+  }
+
   private static void assertTypicalCue1(SubripSubtitle subtitle, int eventIndex) {
     assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(0);
     assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
@@ -174,4 +203,19 @@ private static void assertTypicalCue3(SubripSubtitle subtitle, int eventIndex) {
         .isEqualTo("This is the third subtitle.");
     assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(8901000);
   }
+
+  private static void assertAlignmentCue(
+      SubripSubtitle subtitle,
+      int eventIndex,
+      @Cue.AnchorType int lineAnchor,
+      @Cue.AnchorType int positionAnchor) {
+    long eventTimeUs = subtitle.getEventTime(eventIndex);
+    Cue cue = subtitle.getCues(eventTimeUs).get(0);
+    assertThat(cue.lineType).isEqualTo(Cue.LINE_TYPE_FRACTION);
+    assertThat(cue.lineAnchor).isEqualTo(lineAnchor);
+    assertThat(cue.line).isEqualTo(SubripDecoder.getFractionalPositionForAnchorType(lineAnchor));
+    assertThat(cue.positionAnchor).isEqualTo(positionAnchor);
+    assertThat(cue.position)
+        .isEqualTo(SubripDecoder.getFractionalPositionForAnchorType(positionAnchor));
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
index fdf454e5df..72fff9606c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
@@ -63,6 +63,9 @@
   private static final String FONT_SIZE_INVALID_TTML_FILE = "ttml/font_size_invalid.xml";
   private static final String FONT_SIZE_EMPTY_TTML_FILE = "ttml/font_size_empty.xml";
   private static final String FRAME_RATE_TTML_FILE = "ttml/frame_rate.xml";
+  private static final String BITMAP_REGION_FILE = "ttml/bitmap_percentage_region.xml";
+  private static final String BITMAP_PIXEL_REGION_FILE = "ttml/bitmap_pixel_region.xml";
+  private static final String BITMAP_UNSUPPORTED_REGION_FILE = "ttml/bitmap_unsupported_region.xml";
 
   @Test
   public void testInlineAttributes() throws IOException, SubtitleDecoderException {
@@ -259,56 +262,56 @@ public void testMergeMultipleStylesWithParentStyle()
   @Test
   public void testMultipleRegions() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(MULTIPLE_REGIONS_TTML_FILE);
-    List<Cue> output = subtitle.getCues(1000000);
-    assertThat(output).hasSize(2);
-    Cue ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("lorem");
-    assertThat(ttmlCue.position).isEqualTo(10f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(10f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
-
-    ttmlCue = output.get(1);
-    assertThat(ttmlCue.text.toString()).isEqualTo("amet");
-    assertThat(ttmlCue.position).isEqualTo(60f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(10f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
-
-    output = subtitle.getCues(5000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("ipsum");
-    assertThat(ttmlCue.position).isEqualTo(40f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(40f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
-
-    output = subtitle.getCues(9000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("dolor");
-    assertThat(ttmlCue.position).isEqualTo(Cue.DIMEN_UNSET);
-    assertThat(ttmlCue.line).isEqualTo(Cue.DIMEN_UNSET);
-    assertThat(ttmlCue.size).isEqualTo(Cue.DIMEN_UNSET);
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(2);
+    Cue cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("lorem");
+    assertThat(cue.position).isEqualTo(10f / 100f);
+    assertThat(cue.line).isEqualTo(10f / 100f);
+    assertThat(cue.size).isEqualTo(20f / 100f);
+
+    cue = cues.get(1);
+    assertThat(cue.text.toString()).isEqualTo("amet");
+    assertThat(cue.position).isEqualTo(60f / 100f);
+    assertThat(cue.line).isEqualTo(10f / 100f);
+    assertThat(cue.size).isEqualTo(20f / 100f);
+
+    cues = subtitle.getCues(5000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("ipsum");
+    assertThat(cue.position).isEqualTo(40f / 100f);
+    assertThat(cue.line).isEqualTo(40f / 100f);
+    assertThat(cue.size).isEqualTo(20f / 100f);
+
+    cues = subtitle.getCues(9000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("dolor");
+    assertThat(cue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.size).isEqualTo(Cue.DIMEN_UNSET);
     // TODO: Should be as below, once https://github.com/google/ExoPlayer/issues/2953 is fixed.
-    // assertEquals(10f / 100f, ttmlCue.position);
-    // assertEquals(80f / 100f, ttmlCue.line);
-    // assertEquals(1f, ttmlCue.size);
-
-    output = subtitle.getCues(21000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this");
-    assertThat(ttmlCue.position).isEqualTo(45f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(45f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(35f / 100f);
-    output = subtitle.getCues(25000000);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this\nThen this");
-    output = subtitle.getCues(29000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this\nThen this\nFinally this");
-    assertThat(ttmlCue.position).isEqualTo(45f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(45f / 100f);
+    // assertEquals(10f / 100f, cue.position);
+    // assertEquals(80f / 100f, cue.line);
+    // assertEquals(1f, cue.size);
+
+    cues = subtitle.getCues(21000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("She first said this");
+    assertThat(cue.position).isEqualTo(45f / 100f);
+    assertThat(cue.line).isEqualTo(45f / 100f);
+    assertThat(cue.size).isEqualTo(35f / 100f);
+    cues = subtitle.getCues(25000000);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("She first said this\nThen this");
+    cues = subtitle.getCues(29000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("She first said this\nThen this\nFinally this");
+    assertThat(cue.position).isEqualTo(45f / 100f);
+    assertThat(cue.line).isEqualTo(45f / 100f);
   }
 
   @Test
@@ -499,6 +502,91 @@ public void testFrameRate() throws IOException, SubtitleDecoderException {
     assertThat((double) subtitle.getEventTime(3)).isWithin(2000).of(2_002_000_000);
   }
 
+  @Test
+  public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderException {
+    TtmlSubtitle subtitle = getSubtitle(BITMAP_REGION_FILE);
+
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(1);
+    Cue cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(24f / 100f);
+    assertThat(cue.line).isEqualTo(28f / 100f);
+    assertThat(cue.size).isEqualTo(51f / 100f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(4000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(21f / 100f);
+    assertThat(cue.line).isEqualTo(35f / 100f);
+    assertThat(cue.size).isEqualTo(57f / 100f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(7500000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(24f / 100f);
+    assertThat(cue.line).isEqualTo(28f / 100f);
+    assertThat(cue.size).isEqualTo(51f / 100f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+  }
+
+  @Test
+  public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException {
+    TtmlSubtitle subtitle = getSubtitle(BITMAP_PIXEL_REGION_FILE);
+
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(1);
+    Cue cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(307f / 1280f);
+    assertThat(cue.line).isEqualTo(562f / 720f);
+    assertThat(cue.size).isEqualTo(653f / 1280f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(4000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(269f / 1280f);
+    assertThat(cue.line).isEqualTo(612f / 720f);
+    assertThat(cue.size).isEqualTo(730f / 1280f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+  }
+
+  @Test
+  public void testBitmapUnsupportedRegion() throws IOException, SubtitleDecoderException {
+    TtmlSubtitle subtitle = getSubtitle(BITMAP_UNSUPPORTED_REGION_FILE);
+
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(1);
+    Cue cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.size).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(4000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.size).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+  }
+
   private void assertSpans(
       TtmlSubtitle subtitle,
       int second,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
index c0fa52f74b..155b8f5993 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
@@ -55,7 +55,7 @@
 
   @Test
   public void testDecodeNoSubtitle() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_SUBTITLE);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     assertThat(subtitle.getCues(0)).isEmpty();
@@ -63,7 +63,7 @@ public void testDecodeNoSubtitle() throws IOException, SubtitleDecoderException
 
   @Test
   public void testDecodeJustText() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_JUST_TEXT);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
@@ -74,7 +74,7 @@ public void testDecodeJustText() throws IOException, SubtitleDecoderException {
 
   @Test
   public void testDecodeWithStyl() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
@@ -90,7 +90,7 @@ public void testDecodeWithStyl() throws IOException, SubtitleDecoderException {
 
   @Test
   public void testDecodeWithStylAllDefaults() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes =
         TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL_ALL_DEFAULTS);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
@@ -102,7 +102,7 @@ public void testDecodeWithStylAllDefaults() throws IOException, SubtitleDecoderE
 
   @Test
   public void testDecodeUtf16BeNoStyl() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_UTF16_BE_NO_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
@@ -113,7 +113,7 @@ public void testDecodeUtf16BeNoStyl() throws IOException, SubtitleDecoderExcepti
 
   @Test
   public void testDecodeUtf16LeNoStyl() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_UTF16_LE_NO_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
@@ -124,7 +124,7 @@ public void testDecodeUtf16LeNoStyl() throws IOException, SubtitleDecoderExcepti
 
   @Test
   public void testDecodeWithMultipleStyl() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_MULTIPLE_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
@@ -142,7 +142,7 @@ public void testDecodeWithMultipleStyl() throws IOException, SubtitleDecoderExce
 
   @Test
   public void testDecodeWithOtherExtension() throws IOException, SubtitleDecoderException {
-    Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
+    Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes =
         TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_OTHER_EXTENSION);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
index b89eb47618..9e42f0c049 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
@@ -246,7 +246,7 @@ public void testParseCornerCases() throws Exception {
 
   private static Spanned parseCueText(String string) {
     WebvttCue.Builder builder = new WebvttCue.Builder();
-    WebvttCueParser.parseCueText(null, string, builder, Collections.<WebvttCssStyle>emptyList());
+    WebvttCueParser.parseCueText(null, string, builder, Collections.emptyList());
     return (Spanned) builder.build().text;
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
index eec985ef5b..c4724bc8b9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
@@ -49,6 +49,7 @@
   private static final String WITH_TAGS_FILE = "webvtt/with_tags";
   private static final String WITH_CSS_STYLES = "webvtt/with_css_styles";
   private static final String WITH_CSS_COMPLEX_SELECTORS = "webvtt/with_css_complex_selectors";
+  private static final String WITH_BOM = "webvtt/with_bom";
   private static final String EMPTY_FILE = "webvtt/empty";
 
   @Test
@@ -56,7 +57,7 @@ public void testDecodeEmpty() throws IOException {
     WebvttDecoder decoder = new WebvttDecoder();
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY_FILE);
     try {
-      decoder.decode(bytes, bytes.length, false);
+      decoder.decode(bytes, bytes.length, /* reset= */ false);
       fail();
     } catch (SubtitleDecoderException expected) {
       // Do nothing.
@@ -71,8 +72,40 @@ public void testDecodeTypical() throws IOException, SubtitleDecoderException {
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
+  }
+
+  @Test
+  public void testDecodeWithBom() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_BOM);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    // Test cues.
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
   }
 
   @Test
@@ -83,8 +116,18 @@ public void testDecodeTypicalWithBadTimestamps() throws IOException, SubtitleDec
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
   }
 
   @Test
@@ -95,8 +138,18 @@ public void testDecodeTypicalWithIds() throws IOException, SubtitleDecoderExcept
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
   }
 
   @Test
@@ -107,8 +160,18 @@ public void testDecodeTypicalWithComments() throws IOException, SubtitleDecoderE
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     // test cues
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
   }
 
   @Test
@@ -119,10 +182,30 @@ public void testDecodeWithTags() throws IOException, SubtitleDecoderException {
     assertThat(subtitle.getEventTimeCount()).isEqualTo(8);
 
     // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-    assertCue(subtitle, 4, 4000000, 5000000, "This is the third subtitle.");
-    assertCue(subtitle, 6, 6000000, 7000000, "This is the <fourth> &subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 4,
+        /* startTimeUs= */ 4000000,
+        /* endTimeUs= */ 5000000,
+        "This is the third subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 6,
+        /* startTimeUs= */ 6000000,
+        /* endTimeUs= */ 7000000,
+        "This is the <fourth> &subtitle.");
   }
 
   @Test
@@ -133,82 +216,82 @@ public void testDecodeWithPositioning() throws IOException, SubtitleDecoderExcep
     // Test cues.
     assertCue(
         subtitle,
-        0,
-        0,
-        1234000,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
         "This is the first subtitle.",
         Alignment.ALIGN_NORMAL,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.TYPE_UNSET,
-        0.1f,
-        Cue.ANCHOR_TYPE_START,
-        0.35f);
+        /* line= */ Cue.DIMEN_UNSET,
+        /* lineType= */ Cue.TYPE_UNSET,
+        /* lineAnchor= */ Cue.TYPE_UNSET,
+        /* position= */ 0.1f,
+        /* positionAnchor= */ Cue.ANCHOR_TYPE_START,
+        /* size= */ 0.35f);
     assertCue(
         subtitle,
-        2,
-        2345000,
-        3456000,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
         "This is the second subtitle.",
         Alignment.ALIGN_OPPOSITE,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        0.35f);
+        /* line= */ Cue.DIMEN_UNSET,
+        /* lineType= */ Cue.TYPE_UNSET,
+        /* lineAnchor= */ Cue.TYPE_UNSET,
+        /* position= */ Cue.DIMEN_UNSET,
+        /* positionAnchor= */ Cue.TYPE_UNSET,
+        /* size= */ 0.35f);
     assertCue(
         subtitle,
-        4,
-        4000000,
-        5000000,
+        /* eventTimeIndex= */ 4,
+        /* startTimeUs= */ 4000000,
+        /* endTimeUs= */ 5000000,
         "This is the third subtitle.",
         Alignment.ALIGN_CENTER,
-        0.45f,
-        Cue.LINE_TYPE_FRACTION,
-        Cue.ANCHOR_TYPE_END,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        0.35f);
+        /* line= */ 0.45f,
+        /* lineType= */ Cue.LINE_TYPE_FRACTION,
+        /* lineAnchor= */ Cue.ANCHOR_TYPE_END,
+        /* position= */ Cue.DIMEN_UNSET,
+        /* positionAnchor= */ Cue.TYPE_UNSET,
+        /* size= */ 0.35f);
     assertCue(
         subtitle,
-        6,
-        6000000,
-        7000000,
+        /* eventTimeIndex= */ 6,
+        /* startTimeUs= */ 6000000,
+        /* endTimeUs= */ 7000000,
         "This is the fourth subtitle.",
         Alignment.ALIGN_CENTER,
-        -11f,
-        Cue.LINE_TYPE_NUMBER,
-        Cue.TYPE_UNSET,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.DIMEN_UNSET);
+        /* line= */ -11f,
+        /* lineType= */ Cue.LINE_TYPE_NUMBER,
+        /* lineAnchor= */ Cue.TYPE_UNSET,
+        /* position= */ Cue.DIMEN_UNSET,
+        /* positionAnchor= */ Cue.TYPE_UNSET,
+        /* size= */ Cue.DIMEN_UNSET);
     assertCue(
         subtitle,
-        8,
-        7000000,
-        8000000,
+        /* eventTimeIndex= */ 8,
+        /* startTimeUs= */ 7000000,
+        /* endTimeUs= */ 8000000,
         "This is the fifth subtitle.",
         Alignment.ALIGN_OPPOSITE,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.TYPE_UNSET,
-        0.1f,
-        Cue.ANCHOR_TYPE_END,
-        0.1f);
+        /* line= */ Cue.DIMEN_UNSET,
+        /* lineType= */ Cue.TYPE_UNSET,
+        /* lineAnchor= */ Cue.TYPE_UNSET,
+        /* position= */ 0.1f,
+        /* positionAnchor= */ Cue.ANCHOR_TYPE_END,
+        /* size= */ 0.1f);
     assertCue(
         subtitle,
-        10,
-        10000000,
-        11000000,
+        /* eventTimeIndex= */ 10,
+        /* startTimeUs= */ 10000000,
+        /* endTimeUs= */ 11000000,
         "This is the sixth subtitle.",
         Alignment.ALIGN_CENTER,
-        0.45f,
-        Cue.LINE_TYPE_FRACTION,
-        Cue.ANCHOR_TYPE_END,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        0.35f);
+        /* line= */ 0.45f,
+        /* lineType= */ Cue.LINE_TYPE_FRACTION,
+        /* lineAnchor= */ Cue.ANCHOR_TYPE_END,
+        /* position= */ Cue.DIMEN_UNSET,
+        /* positionAnchor= */ Cue.TYPE_UNSET,
+        /* size= */ 0.35f);
   }
 
   @Test
@@ -219,8 +302,18 @@ public void testDecodeWithBadCueHeader() throws IOException, SubtitleDecoderExce
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 4000000, 5000000, "This is the third subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 4000000,
+        /* endTimeUs= */ 5000000,
+        "This is the third subtitle.");
   }
 
   @Test
@@ -231,57 +324,70 @@ public void testWebvttWithCssStyle() throws IOException, SubtitleDecoderExceptio
     assertThat(subtitle.getEventTimeCount()).isEqualTo(8);
 
     // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-
-    Spanned s1 = getUniqueSpanTextAt(subtitle, 0);
-    Spanned s2 = getUniqueSpanTextAt(subtitle, 2345000);
-    Spanned s3 = getUniqueSpanTextAt(subtitle, 20000000);
-    Spanned s4 = getUniqueSpanTextAt(subtitle, 25000000);
-    assertThat(s1.getSpans(0, s1.length(), ForegroundColorSpan.class)).hasLength(1);
-    assertThat(s1.getSpans(0, s1.length(), BackgroundColorSpan.class)).hasLength(1);
-    assertThat(s2.getSpans(0, s2.length(), ForegroundColorSpan.class)).hasLength(2);
-    assertThat(s3.getSpans(10, s3.length(), UnderlineSpan.class)).hasLength(1);
-    assertThat(s4.getSpans(0, 16, BackgroundColorSpan.class)).hasLength(2);
-    assertThat(s4.getSpans(17, s4.length(), StyleSpan.class)).hasLength(1);
-    assertThat(s4.getSpans(17, s4.length(), StyleSpan.class)[0].getStyle())
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 0,
+        /* startTimeUs= */ 0,
+        /* endTimeUs= */ 1234000,
+        "This is the first subtitle.");
+    assertCue(
+        subtitle,
+        /* eventTimeIndex= */ 2,
+        /* startTimeUs= */ 2345000,
+        /* endTimeUs= */ 3456000,
+        "This is the second subtitle.");
+
+    Spanned s1 = getUniqueSpanTextAt(subtitle, /* timeUs= */ 0);
+    Spanned s2 = getUniqueSpanTextAt(subtitle, /* timeUs= */ 2345000);
+    Spanned s3 = getUniqueSpanTextAt(subtitle, /* timeUs= */ 20000000);
+    Spanned s4 = getUniqueSpanTextAt(subtitle, /* timeUs= */ 25000000);
+    assertThat(s1.getSpans(/* start= */ 0, s1.length(), ForegroundColorSpan.class)).hasLength(1);
+    assertThat(s1.getSpans(/* start= */ 0, s1.length(), BackgroundColorSpan.class)).hasLength(1);
+    assertThat(s2.getSpans(/* start= */ 0, s2.length(), ForegroundColorSpan.class)).hasLength(2);
+    assertThat(s3.getSpans(/* start= */ 10, s3.length(), UnderlineSpan.class)).hasLength(1);
+    assertThat(s4.getSpans(/* start= */ 0, /* end= */ 16, BackgroundColorSpan.class)).hasLength(2);
+    assertThat(s4.getSpans(/* start= */ 17, s4.length(), StyleSpan.class)).hasLength(1);
+    assertThat(s4.getSpans(/* start= */ 17, s4.length(), StyleSpan.class)[0].getStyle())
         .isEqualTo(Typeface.BOLD);
   }
 
   @Test
   public void testWithComplexCssSelectors() throws IOException, SubtitleDecoderException {
     WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_CSS_COMPLEX_SELECTORS);
-    Spanned text = getUniqueSpanTextAt(subtitle, 0);
-    assertThat(text.getSpans(30, text.length(), ForegroundColorSpan.class)).hasLength(1);
-    assertThat(text.getSpans(30, text.length(), ForegroundColorSpan.class)[0].getForegroundColor())
+    Spanned text = getUniqueSpanTextAt(subtitle, /* timeUs= */ 0);
+    assertThat(text.getSpans(/* start= */ 30, text.length(), ForegroundColorSpan.class))
+        .hasLength(1);
+    assertThat(
+            text.getSpans(/* start= */ 30, text.length(), ForegroundColorSpan.class)[0]
+                .getForegroundColor())
         .isEqualTo(0xFFEE82EE);
-    assertThat(text.getSpans(30, text.length(), TypefaceSpan.class)).hasLength(1);
-    assertThat(text.getSpans(30, text.length(), TypefaceSpan.class)[0].getFamily())
+    assertThat(text.getSpans(/* start= */ 30, text.length(), TypefaceSpan.class)).hasLength(1);
+    assertThat(text.getSpans(/* start= */ 30, text.length(), TypefaceSpan.class)[0].getFamily())
         .isEqualTo("courier");
 
-    text = getUniqueSpanTextAt(subtitle, 2000000);
-    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)).hasLength(1);
-    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)[0].getFamily())
+    text = getUniqueSpanTextAt(subtitle, /* timeUs= */ 2000000);
+    assertThat(text.getSpans(/* start= */ 5, text.length(), TypefaceSpan.class)).hasLength(1);
+    assertThat(text.getSpans(/* start= */ 5, text.length(), TypefaceSpan.class)[0].getFamily())
         .isEqualTo("courier");
 
-    text = getUniqueSpanTextAt(subtitle, 2500000);
-    assertThat(text.getSpans(5, text.length(), StyleSpan.class)).hasLength(1);
-    assertThat(text.getSpans(5, text.length(), StyleSpan.class)[0].getStyle())
+    text = getUniqueSpanTextAt(subtitle, /* timeUs= */ 2500000);
+    assertThat(text.getSpans(/* start= */ 5, text.length(), StyleSpan.class)).hasLength(1);
+    assertThat(text.getSpans(/* start= */ 5, text.length(), StyleSpan.class)[0].getStyle())
         .isEqualTo(Typeface.BOLD);
-    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)).hasLength(1);
-    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)[0].getFamily())
+    assertThat(text.getSpans(/* start= */ 5, text.length(), TypefaceSpan.class)).hasLength(1);
+    assertThat(text.getSpans(/* start= */ 5, text.length(), TypefaceSpan.class)[0].getFamily())
         .isEqualTo("courier");
 
-    text = getUniqueSpanTextAt(subtitle, 4000000);
-    assertThat(text.getSpans(6, 22, StyleSpan.class)).hasLength(0);
-    assertThat(text.getSpans(30, text.length(), StyleSpan.class)).hasLength(1);
-    assertThat(text.getSpans(30, text.length(), StyleSpan.class)[0].getStyle())
+    text = getUniqueSpanTextAt(subtitle, /* timeUs= */ 4000000);
+    assertThat(text.getSpans(/* start= */ 6, /* end= */ 22, StyleSpan.class)).hasLength(0);
+    assertThat(text.getSpans(/* start= */ 30, text.length(), StyleSpan.class)).hasLength(1);
+    assertThat(text.getSpans(/* start= */ 30, text.length(), StyleSpan.class)[0].getStyle())
         .isEqualTo(Typeface.BOLD);
 
-    text = getUniqueSpanTextAt(subtitle, 5000000);
-    assertThat(text.getSpans(9, 17, StyleSpan.class)).hasLength(0);
-    assertThat(text.getSpans(19, text.length(), StyleSpan.class)).hasLength(1);
-    assertThat(text.getSpans(19, text.length(), StyleSpan.class)[0].getStyle())
+    text = getUniqueSpanTextAt(subtitle, /* timeUs= */ 5000000);
+    assertThat(text.getSpans(/* start= */ 9, /* end= */ 17, StyleSpan.class)).hasLength(0);
+    assertThat(text.getSpans(/* start= */ 19, text.length(), StyleSpan.class)).hasLength(1);
+    assertThat(text.getSpans(/* start= */ 19, text.length(), StyleSpan.class)[0].getStyle())
         .isEqualTo(Typeface.ITALIC);
   }
 
@@ -289,7 +395,7 @@ private WebvttSubtitle getSubtitleForTestAsset(String asset)
       throws IOException, SubtitleDecoderException {
     WebvttDecoder decoder = new WebvttDecoder();
     byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, asset);
-    return decoder.decode(bytes, bytes.length, false);
+    return decoder.decode(bytes, bytes.length, /* reset= */ false);
   }
 
   private Spanned getUniqueSpanTextAt(WebvttSubtitle sub, long timeUs) {
@@ -304,13 +410,13 @@ private static void assertCue(
         startTimeUs,
         endTimeUs,
         text,
-        null,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET,
-        Cue.DIMEN_UNSET);
+        /* textAlignment= */ null,
+        /* line= */ Cue.DIMEN_UNSET,
+        /* lineType= */ Cue.TYPE_UNSET,
+        /* lineAnchor= */ Cue.TYPE_UNSET,
+        /* position= */ Cue.DIMEN_UNSET,
+        /* positionAnchor= */ Cue.TYPE_UNSET,
+        /* size= */ Cue.DIMEN_UNSET);
   }
 
   private static void assertCue(
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
index 3074f28b64..af165ffe9b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
@@ -38,8 +38,7 @@
   private static final String FIRST_AND_SECOND_SUBTITLE_STRING =
       FIRST_SUBTITLE_STRING + "\n" + SECOND_SUBTITLE_STRING;
 
-  private static final WebvttSubtitle emptySubtitle = new WebvttSubtitle(
-      Collections.<WebvttCue>emptyList());
+  private static final WebvttSubtitle emptySubtitle = new WebvttSubtitle(Collections.emptyList());
 
   private static final WebvttSubtitle simpleSubtitle;
   static {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
index f9ebee78d6..3ddc809ca4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
@@ -16,6 +16,10 @@
 package com.google.android.exoplayer2.trackselection;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 import static org.mockito.MockitoAnnotations.initMocks;
 
@@ -24,6 +28,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.testutil.FakeClock;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -32,6 +37,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
@@ -43,6 +49,11 @@
 @RunWith(RobolectricTestRunner.class)
 public final class AdaptiveTrackSelectionTest {
 
+  private static final MediaChunkIterator[] THREE_EMPTY_MEDIA_CHUNK_ITERATORS =
+      new MediaChunkIterator[] {
+        MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY
+      };
+
   @Mock private BandwidthMeter mockBandwidthMeter;
   private FakeClock fakeClock;
 
@@ -54,6 +65,26 @@ public void setUp() {
     fakeClock = new FakeClock(0);
   }
 
+  @Test
+  public void testFactoryUsesInitiallyProvidedBandwidthMeter() {
+    BandwidthMeter initialBandwidthMeter = mock(BandwidthMeter.class);
+    BandwidthMeter injectedBandwidthMeter = mock(BandwidthMeter.class);
+    Format format = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    @SuppressWarnings("deprecation")
+    AdaptiveTrackSelection adaptiveTrackSelection =
+        new AdaptiveTrackSelection.Factory(initialBandwidthMeter)
+            .createTrackSelection(new TrackGroup(format), injectedBandwidthMeter, /* tracks= */ 0);
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ 0,
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ new MediaChunkIterator[] {MediaChunkIterator.EMPTY});
+
+    verify(initialBandwidthMeter, atLeastOnce()).getBitrateEstimate();
+    verifyZeroInteractions(injectedBandwidthMeter);
+  }
+
   @Test
   public void testSelectInitialIndexUseMaxInitialBitrateIfNoBandwidthEstimate() {
     Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
@@ -99,7 +130,9 @@ public void testUpdateSelectedTrackDoNotSwitchUpIfNotBufferedEnough() {
     adaptiveTrackSelection.updateSelectedTrack(
         /* playbackPositionUs= */ 0,
         /* bufferedDurationUs= */ 9_999_000,
-        /* availableDurationUs= */ C.TIME_UNSET);
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
 
     // When bandwidth estimation is updated to 2000L, we can switch up to use a higher bitrate
     // format. However, since we only buffered 9_999_000 us, which is smaller than
@@ -125,7 +158,9 @@ public void testUpdateSelectedTrackSwitchUpIfBufferedEnough() {
     adaptiveTrackSelection.updateSelectedTrack(
         /* playbackPositionUs= */ 0,
         /* bufferedDurationUs= */ 10_000_000,
-        /* availableDurationUs= */ C.TIME_UNSET);
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
 
     // When bandwidth estimation is updated to 2000L, we can switch up to use a higher bitrate
     // format. When we have buffered enough (10_000_000 us, which is equal to
@@ -151,7 +186,9 @@ public void testUpdateSelectedTrackDoNotSwitchDownIfBufferedEnough() {
     adaptiveTrackSelection.updateSelectedTrack(
         /* playbackPositionUs= */ 0,
         /* bufferedDurationUs= */ 25_000_000,
-        /* availableDurationUs= */ C.TIME_UNSET);
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
 
     // When bandwidth estimation is updated to 500L, we should switch down to use a lower bitrate
     // format. However, since we have enough buffer at higher quality (25_000_000 us, which is equal
@@ -177,7 +214,9 @@ public void testUpdateSelectedTrackSwitchDownIfNotBufferedEnough() {
     adaptiveTrackSelection.updateSelectedTrack(
         /* playbackPositionUs= */ 0,
         /* bufferedDurationUs= */ 24_999_000,
-        /* availableDurationUs= */ C.TIME_UNSET);
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
 
     // When bandwidth estimation is updated to 500L, we should switch down to use a lower bitrate
     // format. When we don't have enough buffer at higher quality (24_999_000 us is smaller than
@@ -400,10 +439,5 @@ public void load() throws IOException, InterruptedException {
     public boolean isLoadCompleted() {
       return true;
     }
-
-    @Override
-    public long bytesLoaded() {
-      return 0;
-    }
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index 2ba63d6773..94f6abd87b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -17,11 +17,16 @@
 
 import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES;
 import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_HANDLED;
+import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_UNSUPPORTED_SUBTYPE;
 import static com.google.android.exoplayer2.RendererConfiguration.DEFAULT;
 import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyVararg;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 import static org.mockito.MockitoAnnotations.initMocks;
 
 import android.os.Parcel;
@@ -38,6 +43,7 @@
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.ParametersBuilder;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
 import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.HashMap;
 import java.util.Map;
@@ -71,33 +77,10 @@
   private static final RendererCapabilities[] RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER =
       new RendererCapabilities[] {VIDEO_CAPABILITIES, NO_SAMPLE_CAPABILITIES};
 
-  private static final TrackGroup VIDEO_TRACK_GROUP =
-      new TrackGroup(
-          Format.createVideoSampleFormat(
-              "video",
-              MimeTypes.VIDEO_H264,
-              null,
-              Format.NO_VALUE,
-              Format.NO_VALUE,
-              1024,
-              768,
-              Format.NO_VALUE,
-              null,
-              null));
-  private static final TrackGroup AUDIO_TRACK_GROUP =
-      new TrackGroup(
-          Format.createAudioSampleFormat(
-              "audio",
-              MimeTypes.AUDIO_AAC,
-              null,
-              Format.NO_VALUE,
-              Format.NO_VALUE,
-              2,
-              44100,
-              null,
-              null,
-              0,
-              null));
+  private static final Format VIDEO_FORMAT = buildVideoFormat("video");
+  private static final Format AUDIO_FORMAT = buildAudioFormat("audio");
+  private static final TrackGroup VIDEO_TRACK_GROUP = new TrackGroup(VIDEO_FORMAT);
+  private static final TrackGroup AUDIO_TRACK_GROUP = new TrackGroup(AUDIO_FORMAT);
   private static final TrackGroupArray TRACK_GROUPS =
       new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);
 
@@ -110,13 +93,16 @@
 
   @Mock
   private InvalidationListener invalidationListener;
+  @Mock private BandwidthMeter bandwidthMeter;
 
   private DefaultTrackSelector trackSelector;
 
   @Before
   public void setUp() {
     initMocks(this);
+    when(bandwidthMeter.getBitrateEstimate()).thenReturn(1000000L);
     trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
   }
 
   /** Tests {@link Parameters} {@link android.os.Parcelable} implementation. */
@@ -139,15 +125,17 @@ public void testParametersParcelable() {
             /* selectUndeterminedTextLanguage= */ false,
             /* disabledTextTrackSelectionFlags= */ 0,
             /* forceLowestBitrate= */ true,
+            /* forceHighestSupportedBitrate= */ true,
             /* allowMixedMimeAdaptiveness= */ false,
             /* allowNonSeamlessAdaptiveness= */ true,
             /* maxVideoWidth= */ 1,
             /* maxVideoHeight= */ 2,
-            /* maxVideoBitrate= */ 3,
+            /* maxVideoFrameRate= */ 3,
+            /* maxVideoBitrate= */ 4,
             /* exceedVideoConstraintsIfNecessary= */ false,
             /* exceedRendererCapabilitiesIfNecessary= */ true,
-            /* viewportWidth= */ 4,
-            /* viewportHeight= */ 5,
+            /* viewportWidth= */ 5,
+            /* viewportHeight= */ 6,
             /* viewportOrientationMayChange= */ false,
             /* tunnelingAudioSessionId= */ C.AUDIO_SESSION_ID_UNSET);
 
@@ -183,6 +171,7 @@ public void testSelectionOverrideParcelable() {
   @Test
   public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
@@ -197,6 +186,7 @@ public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
   @Test
   public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
@@ -212,6 +202,7 @@ public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackExceptio
   @Test
   public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
@@ -229,6 +220,7 @@ public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlayb
   @Test
   public void testSelectTracksWithDisabledRenderer() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(trackSelector.buildUponParameters().setRendererDisabled(1, true));
     TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
     assertTrackSelections(result, new TrackSelection[] {TRACK_SELECTIONS[0], null});
@@ -240,6 +232,7 @@ public void testSelectTracksWithDisabledRenderer() throws ExoPlaybackException {
   @Test
   public void testSelectTracksWithClearedDisabledRenderer() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
@@ -255,6 +248,7 @@ public void testSelectTracksWithClearedDisabledRenderer() throws ExoPlaybackExce
   @Test
   public void testSelectTracksWithNoSampleRenderer() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     TrackSelectorResult result =
         trackSelector.selectTracks(RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
     assertTrackSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);
@@ -266,6 +260,7 @@ public void testSelectTracksWithNoSampleRenderer() throws ExoPlaybackException {
   @Test
   public void testSelectTracksWithDisabledNoSampleRenderer() throws ExoPlaybackException {
     DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(trackSelector.buildUponParameters().setRendererDisabled(1, true));
     TrackSelectorResult result =
         trackSelector.selectTracks(RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
@@ -282,7 +277,7 @@ public void testSelectTracksWithDisabledNoSampleRenderer() throws ExoPlaybackExc
   @Test
   public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListener()
       throws Exception {
-    trackSelector.init(invalidationListener);
+    trackSelector.init(invalidationListener, /* bandwidthMeter= */ null);
 
     verify(invalidationListener, never()).onTrackSelectionsInvalidated();
   }
@@ -295,7 +290,7 @@ public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListen
   public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
       throws Exception {
     Parameters parameters = new ParametersBuilder().setPreferredAudioLanguage("eng").build();
-    trackSelector.init(invalidationListener);
+    trackSelector.init(invalidationListener, /* bandwidthMeter= */ null);
     trackSelector.setParameters(parameters);
 
     verify(invalidationListener).onTrackSelectionsInvalidated();
@@ -310,7 +305,7 @@ public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
   public void testSetParameterWithSameParametersDoesNotNotifyInvalidationListenerAgain()
       throws Exception {
     ParametersBuilder builder = new ParametersBuilder().setPreferredAudioLanguage("eng");
-    trackSelector.init(invalidationListener);
+    trackSelector.init(invalidationListener, /* bandwidthMeter= */ null);
     trackSelector.setParameters(builder.build());
     trackSelector.setParameters(builder.build());
 
@@ -323,12 +318,9 @@ public void testSetParameterWithSameParametersDoesNotNotifyInvalidationListenerA
    */
   @Test
   public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
-    Format audioFormat =
-        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format audioFormat = buildAudioFormat("audio", /* language= */ null, /* selectionFlags= */ 0);
     Format formatWithSelectionFlag =
-        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, null);
+        buildAudioFormat("audio", /* language= */ null, C.SELECTION_FLAG_DEFAULT);
 
     TrackSelectorResult result = trackSelector.selectTracks(
         new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
@@ -352,9 +344,10 @@ public void testSelectTracksSelectPreferredAudioLanguage()
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(frAudioFormat, enAudioFormat));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            wrapFormats(frAudioFormat, enAudioFormat));
 
     assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(enAudioFormat);
   }
@@ -388,12 +381,8 @@ public void testSelectTracksSelectPreferredAudioLanguageOverSelectionFlag()
    */
   @Test
   public void testSelectTracksPreferTrackWithinCapabilities() throws Exception {
-    Format supportedFormat =
-        Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    Format exceededFormat =
-        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format supportedFormat = buildAudioFormat("supportedFormat");
+    Format exceededFormat = buildAudioFormat("exceededFormat");
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);
@@ -754,53 +743,18 @@ public void testSelectTracksExceedingCapabilitiesPreferLowerSampleRateBeforeBitr
   /** Tests text track selection flags. */
   @Test
   public void testsTextTrackSelectionFlags() throws ExoPlaybackException {
-    Format forcedOnly =
-        Format.createTextContainerFormat(
-            "forcedOnly",
-            null,
-            MimeTypes.TEXT_VTT,
-            null,
-            Format.NO_VALUE,
-            C.SELECTION_FLAG_FORCED,
-            "eng");
+    Format forcedOnly = buildTextFormat("forcedOnly", "eng", C.SELECTION_FLAG_FORCED);
     Format forcedDefault =
-        Format.createTextContainerFormat(
-            "forcedDefault",
-            null,
-            MimeTypes.TEXT_VTT,
-            null,
-            Format.NO_VALUE,
-            C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT,
-            "eng");
-    Format defaultOnly =
-        Format.createTextContainerFormat(
-            "defaultOnly",
-            null,
-            MimeTypes.TEXT_VTT,
-            null,
-            Format.NO_VALUE,
-            C.SELECTION_FLAG_DEFAULT,
-            "eng");
-    Format forcedOnlySpanish =
-        Format.createTextContainerFormat(
-            "forcedOnlySpanish",
-            null,
-            MimeTypes.TEXT_VTT,
-            null,
-            Format.NO_VALUE,
-            C.SELECTION_FLAG_FORCED,
-            "spa");
-    Format noFlag =
-        Format.createTextContainerFormat(
-            "noFlag", null, MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "eng");
+        buildTextFormat("forcedDefault", "eng", C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT);
+    Format defaultOnly = buildTextFormat("defaultOnly", "eng", C.SELECTION_FLAG_DEFAULT);
+    Format forcedOnlySpanish = buildTextFormat("forcedOnlySpanish", "spa", C.SELECTION_FLAG_FORCED);
+    Format noFlag = buildTextFormat("noFlag", "eng");
 
     RendererCapabilities[] textRendererCapabilities =
         new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};
 
-    TrackSelectorResult result;
-
     // There is no text language preference, the first track flagged as default should be selected.
-    result =
+    TrackSelectorResult result =
         trackSelector.selectTracks(
             textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
     assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedDefault);
@@ -886,22 +840,18 @@ public void testsTextTrackSelectionFlags() throws ExoPlaybackException {
    */
   @Test
   public void testSelectUndeterminedTextLanguageAsFallback() throws ExoPlaybackException{
-    Format spanish = Format.createTextContainerFormat("spanish", null,
-        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "spa");
-    Format german = Format.createTextContainerFormat("german", null,
-        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "de");
-    Format undeterminedUnd = Format.createTextContainerFormat("undeterminedUnd", null,
-        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "und");
-    Format undeterminedNull = Format.createTextContainerFormat("undeterminedNull", null,
-        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, null);
+    Format spanish = buildTextFormat("spanish", "spa");
+    Format german = buildTextFormat("german", "de");
+    Format undeterminedUnd = buildTextFormat("undeterminedUnd", "und");
+    Format undeterminedNull = buildTextFormat("undeterminedNull", null);
 
     RendererCapabilities[] textRendererCapabilites =
         new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};
 
-    TrackSelectorResult result;
-
-    result = trackSelector.selectTracks(textRendererCapabilites,
-        wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            textRendererCapabilites,
+            wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
     assertThat(result.selections.get(0)).isNull();
 
     trackSelector.setParameters(
@@ -933,6 +883,48 @@ public void testSelectUndeterminedTextLanguageAsFallback() throws ExoPlaybackExc
     assertThat(result.selections.get(0)).isNull();
   }
 
+  /** Tests audio track selection when there are multiple audio renderers. */
+  @Test
+  public void testSelectPreferredTextTrackMultipleRenderers() throws Exception {
+    Format english = buildTextFormat("en", "en");
+    Format german = buildTextFormat("de", "de");
+
+    // First renderer handles english.
+    Map<String, Integer> firstRendererMappedCapabilities = new HashMap<>();
+    firstRendererMappedCapabilities.put(english.id, FORMAT_HANDLED);
+    firstRendererMappedCapabilities.put(german.id, FORMAT_UNSUPPORTED_SUBTYPE);
+    RendererCapabilities firstRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_TEXT, firstRendererMappedCapabilities);
+
+    // Second renderer handles german.
+    Map<String, Integer> secondRendererMappedCapabilities = new HashMap<>();
+    secondRendererMappedCapabilities.put(english.id, FORMAT_UNSUPPORTED_SUBTYPE);
+    secondRendererMappedCapabilities.put(german.id, FORMAT_HANDLED);
+    RendererCapabilities secondRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_TEXT, secondRendererMappedCapabilities);
+
+    RendererCapabilities[] rendererCapabilities =
+        new RendererCapabilities[] {firstRendererCapabilities, secondRendererCapabilities};
+
+    // Without an explicit language preference, nothing should be selected.
+    TrackSelectorResult result =
+        trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
+    assertThat(result.selections.get(0)).isNull();
+    assertThat(result.selections.get(1)).isNull();
+
+    // Explicit language preference for english. First renderer should be used.
+    trackSelector.setParameters(trackSelector.buildUponParameters().setPreferredTextLanguage("en"));
+    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(english);
+    assertThat(result.selections.get(1)).isNull();
+
+    // Explicit language preference for German. Second renderer should be used.
+    trackSelector.setParameters(trackSelector.buildUponParameters().setPreferredTextLanguage("de"));
+    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
+    assertThat(result.selections.get(0)).isNull();
+    assertThat(result.selections.get(1).getFormat(0)).isSameAs(german);
+  }
+
   /**
    * Tests that track selector will select audio tracks with lower bitrate when {@link Parameters}
    * indicate lowest bitrate preference, even when tracks are within capabilities.
@@ -956,6 +948,152 @@ public void testSelectTracksWithinCapabilitiesAndForceLowestBitrateSelectLowerBi
     assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerBitrateFormat);
   }
 
+  @Test
+  public void testSelectTracksWithMultipleAudioTracksReturnsAdaptiveTrackSelection()
+      throws Exception {
+    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
+    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
+    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
+        .thenReturn(adaptiveTrackSelection);
+
+    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
+    trackSelector.init(invalidationListener, bandwidthMeter);
+
+    TrackGroupArray trackGroupArray = singleTrackGroup(AUDIO_FORMAT, AUDIO_FORMAT);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroupArray);
+
+    assertThat(result.length).isEqualTo(1);
+    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
+    verify(adaptiveTrackSelectionFactory)
+        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 0, 1);
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleAudioTracksOverrideReturnsAdaptiveTrackSelection()
+      throws Exception {
+    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
+    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
+    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
+        .thenReturn(adaptiveTrackSelection);
+
+    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
+    trackSelector.init(invalidationListener, bandwidthMeter);
+
+    TrackGroupArray trackGroupArray = singleTrackGroup(AUDIO_FORMAT, AUDIO_FORMAT, AUDIO_FORMAT);
+    trackSelector.setParameters(
+        trackSelector
+            .buildUponParameters()
+            .setSelectionOverride(
+                /* rendererIndex= */ 0,
+                trackGroupArray,
+                new SelectionOverride(/* groupIndex= */ 0, /* tracks= */ 1, 2)));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroupArray);
+
+    assertThat(result.length).isEqualTo(1);
+    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
+    verify(adaptiveTrackSelectionFactory)
+        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 1, 2);
+  }
+
+  /** Tests audio track selection when there are multiple audio renderers. */
+  @Test
+  public void testSelectPreferredAudioTrackMultipleRenderers() throws Exception {
+    Format english = buildAudioFormat("en", "en");
+    Format german = buildAudioFormat("de", "de");
+
+    // First renderer handles english.
+    Map<String, Integer> firstRendererMappedCapabilities = new HashMap<>();
+    firstRendererMappedCapabilities.put(english.id, FORMAT_HANDLED);
+    firstRendererMappedCapabilities.put(german.id, FORMAT_UNSUPPORTED_SUBTYPE);
+    RendererCapabilities firstRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, firstRendererMappedCapabilities);
+
+    // Second renderer handles german.
+    Map<String, Integer> secondRendererMappedCapabilities = new HashMap<>();
+    secondRendererMappedCapabilities.put(english.id, FORMAT_UNSUPPORTED_SUBTYPE);
+    secondRendererMappedCapabilities.put(german.id, FORMAT_HANDLED);
+    RendererCapabilities secondRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, secondRendererMappedCapabilities);
+
+    RendererCapabilities[] rendererCapabilities =
+        new RendererCapabilities[] {firstRendererCapabilities, secondRendererCapabilities};
+
+    // Without an explicit language preference, prefer the first renderer.
+    TrackSelectorResult result =
+        trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(english);
+    assertThat(result.selections.get(1)).isNull();
+
+    // Explicit language preference for english. First renderer should be used.
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setPreferredAudioLanguage("en"));
+    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(english);
+    assertThat(result.selections.get(1)).isNull();
+
+    // Explicit language preference for German. Second renderer should be used.
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setPreferredAudioLanguage("de"));
+    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
+    assertThat(result.selections.get(0)).isNull();
+    assertThat(result.selections.get(1).getFormat(0)).isSameAs(german);
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleVideoTracksReturnsAdaptiveTrackSelection()
+      throws Exception {
+    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
+    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
+    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
+        .thenReturn(adaptiveTrackSelection);
+
+    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
+    trackSelector.init(invalidationListener, bandwidthMeter);
+
+    TrackGroupArray trackGroupArray = singleTrackGroup(VIDEO_FORMAT, VIDEO_FORMAT);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroupArray);
+
+    assertThat(result.length).isEqualTo(1);
+    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
+    verify(adaptiveTrackSelectionFactory)
+        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 0, 1);
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleVideoTracksOverrideReturnsAdaptiveTrackSelection()
+      throws Exception {
+    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
+    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
+    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
+        .thenReturn(adaptiveTrackSelection);
+
+    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
+    trackSelector.init(invalidationListener, bandwidthMeter);
+
+    TrackGroupArray trackGroupArray = singleTrackGroup(VIDEO_FORMAT, VIDEO_FORMAT, VIDEO_FORMAT);
+    trackSelector.setParameters(
+        trackSelector
+            .buildUponParameters()
+            .setSelectionOverride(
+                /* rendererIndex= */ 0,
+                trackGroupArray,
+                new SelectionOverride(/* groupIndex= */ 0, /* tracks= */ 1, 2)));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroupArray);
+
+    assertThat(result.length).isEqualTo(1);
+    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
+    verify(adaptiveTrackSelectionFactory)
+        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 1, 2);
+  }
+
   private static void assertTrackSelections(TrackSelectorResult result, TrackSelection[] expected) {
     assertThat(result.length).isEqualTo(expected.length);
     for (int i = 0; i < expected.length; i++) {
@@ -975,6 +1113,59 @@ private static TrackGroupArray wrapFormats(Format... formats) {
     return new TrackGroupArray(trackGroups);
   }
 
+  private static Format buildVideoFormat(String id) {
+    return Format.createVideoSampleFormat(
+        id,
+        MimeTypes.VIDEO_H264,
+        null,
+        Format.NO_VALUE,
+        Format.NO_VALUE,
+        1024,
+        768,
+        Format.NO_VALUE,
+        null,
+        null);
+  }
+
+  private static Format buildAudioFormat(String id) {
+    return buildAudioFormat(id, /* language= */ null);
+  }
+
+  private static Format buildAudioFormat(String id, String language) {
+    return buildAudioFormat(id, language, /* selectionFlags= */ 0);
+  }
+
+  private static Format buildAudioFormat(String id, String language, int selectionFlags) {
+    return Format.createAudioSampleFormat(
+        id,
+        MimeTypes.AUDIO_AAC,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* maxInputSize= */ Format.NO_VALUE,
+        /* channelCount= */ 2,
+        /* sampleRate= */ 44100,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        selectionFlags,
+        language);
+  }
+
+  private static Format buildTextFormat(String id, String language) {
+    return buildTextFormat(id, language, /* selectionFlags= */ 0);
+  }
+
+  private static Format buildTextFormat(String id, String language, int selectionFlags) {
+    return Format.createTextContainerFormat(
+        id,
+        /* label= */ null,
+        /* containerMimeType= */ null,
+        /* sampleMimeType= */ MimeTypes.TEXT_VTT,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        selectionFlags,
+        language);
+  }
+
   /**
    * A {@link RendererCapabilities} that advertises support for all formats of a given type using
    * a provided support value. For any format that does not have the given track type,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java
new file mode 100644
index 0000000000..615f680bb5
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link TrackSelector}. */
+@RunWith(RobolectricTestRunner.class)
+public class TrackSelectorTest {
+
+  private TrackSelector trackSelector;
+
+  @Before
+  public void setUp() {
+    trackSelector = new TrackSelector() {
+      @Override
+      public TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+          TrackGroupArray trackGroups) throws ExoPlaybackException {
+        throw new UnsupportedOperationException();
+      }
+
+      @Override
+      public void onSelectionActivated(Object info) {}
+    };
+  }
+
+  @Test
+  public void getBandwidthMeter_beforeInitialization_throwsException() {
+    try {
+      trackSelector.getBandwidthMeter();
+      fail();
+    } catch (Exception e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void getBandwidthMeter_afterInitialization_returnsProvidedBandwidthMeter() {
+    InvalidationListener invalidationListener = Mockito.mock(InvalidationListener.class);
+    BandwidthMeter bandwidthMeter = Mockito.mock(BandwidthMeter.class);
+    trackSelector.init(invalidationListener, bandwidthMeter);
+
+    assertThat(trackSelector.getBandwidthMeter()).isEqualTo(bandwidthMeter);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java
new file mode 100644
index 0000000000..7155c37e29
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link BaseDataSource}. */
+@RunWith(RobolectricTestRunner.class)
+public class BaseDataSourceTest {
+
+  @Test
+  public void dataTransfer_withLocalSource_isReported() throws IOException {
+    TestSource testSource = new TestSource(/* isNetwork= */ false);
+    TestTransferListener transferListener = new TestTransferListener();
+    testSource.addTransferListener(transferListener);
+
+    DataSpec dataSpec = new DataSpec(Uri.EMPTY);
+    testSource.open(dataSpec);
+    testSource.read(/* buffer= */ null, /* offset= */ 0, /* readLength= */ 100);
+    testSource.close();
+
+    assertThat(transferListener.lastTransferInitializingSource).isSameAs(testSource);
+    assertThat(transferListener.lastTransferStartSource).isSameAs(testSource);
+    assertThat(transferListener.lastBytesTransferredSource).isSameAs(testSource);
+    assertThat(transferListener.lastTransferEndSource).isSameAs(testSource);
+
+    assertThat(transferListener.lastTransferInitializingDataSpec).isEqualTo(dataSpec);
+    assertThat(transferListener.lastTransferStartDataSpec).isEqualTo(dataSpec);
+    assertThat(transferListener.lastBytesTransferredDataSpec).isEqualTo(dataSpec);
+    assertThat(transferListener.lastTransferEndDataSpec).isEqualTo(dataSpec);
+
+    assertThat(transferListener.lastTransferInitializingIsNetwork).isEqualTo(false);
+    assertThat(transferListener.lastTransferStartIsNetwork).isEqualTo(false);
+    assertThat(transferListener.lastBytesTransferredIsNetwork).isEqualTo(false);
+    assertThat(transferListener.lastTransferEndIsNetwork).isEqualTo(false);
+
+    assertThat(transferListener.lastBytesTransferred).isEqualTo(100);
+  }
+
+  @Test
+  public void dataTransfer_withRemoteSource_isReported() throws IOException {
+    TestSource testSource = new TestSource(/* isNetwork= */ true);
+    TestTransferListener transferListener = new TestTransferListener();
+    testSource.addTransferListener(transferListener);
+
+    DataSpec dataSpec = new DataSpec(Uri.EMPTY);
+    testSource.open(dataSpec);
+    testSource.read(/* buffer= */ null, /* offset= */ 0, /* readLength= */ 100);
+    testSource.close();
+
+    assertThat(transferListener.lastTransferInitializingSource).isSameAs(testSource);
+    assertThat(transferListener.lastTransferStartSource).isSameAs(testSource);
+    assertThat(transferListener.lastBytesTransferredSource).isSameAs(testSource);
+    assertThat(transferListener.lastTransferEndSource).isSameAs(testSource);
+
+    assertThat(transferListener.lastTransferInitializingDataSpec).isEqualTo(dataSpec);
+    assertThat(transferListener.lastTransferStartDataSpec).isEqualTo(dataSpec);
+    assertThat(transferListener.lastBytesTransferredDataSpec).isEqualTo(dataSpec);
+    assertThat(transferListener.lastTransferEndDataSpec).isEqualTo(dataSpec);
+
+    assertThat(transferListener.lastTransferInitializingIsNetwork).isEqualTo(true);
+    assertThat(transferListener.lastTransferStartIsNetwork).isEqualTo(true);
+    assertThat(transferListener.lastBytesTransferredIsNetwork).isEqualTo(true);
+    assertThat(transferListener.lastTransferEndIsNetwork).isEqualTo(true);
+
+    assertThat(transferListener.lastBytesTransferred).isEqualTo(100);
+  }
+
+  private static final class TestSource extends BaseDataSource {
+
+    public TestSource(boolean isNetwork) {
+      super(isNetwork);
+    }
+
+    @Override
+    public long open(DataSpec dataSpec) throws IOException {
+      transferInitializing(dataSpec);
+      transferStarted(dataSpec);
+      return C.LENGTH_UNSET;
+    }
+
+    @Override
+    public int read(byte[] buffer, int offset, int readLength) throws IOException {
+      bytesTransferred(readLength);
+      return readLength;
+    }
+
+    @Override
+    public @Nullable Uri getUri() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void close() throws IOException {
+      transferEnded();
+    }
+  }
+
+  private static final class TestTransferListener implements TransferListener {
+
+    public Object lastTransferInitializingSource;
+    public DataSpec lastTransferInitializingDataSpec;
+    public boolean lastTransferInitializingIsNetwork;
+
+    public Object lastTransferStartSource;
+    public DataSpec lastTransferStartDataSpec;
+    public boolean lastTransferStartIsNetwork;
+
+    public Object lastBytesTransferredSource;
+    public DataSpec lastBytesTransferredDataSpec;
+    public boolean lastBytesTransferredIsNetwork;
+    public int lastBytesTransferred;
+
+    public Object lastTransferEndSource;
+    public DataSpec lastTransferEndDataSpec;
+    public boolean lastTransferEndIsNetwork;
+
+    @Override
+    public void onTransferInitializing(DataSource source, DataSpec dataSpec, boolean isNetwork) {
+      lastTransferInitializingSource = source;
+      lastTransferInitializingDataSpec = dataSpec;
+      lastTransferInitializingIsNetwork = isNetwork;
+    }
+
+    @Override
+    public void onTransferStart(DataSource source, DataSpec dataSpec, boolean isNetwork) {
+      lastTransferStartSource = source;
+      lastTransferStartDataSpec = dataSpec;
+      lastTransferStartIsNetwork = isNetwork;
+    }
+
+    @Override
+    public void onBytesTransferred(
+        DataSource source, DataSpec dataSpec, boolean isNetwork, int bytesTransferred) {
+      lastBytesTransferredSource = source;
+      lastBytesTransferredDataSpec = dataSpec;
+      lastBytesTransferredIsNetwork = isNetwork;
+      lastBytesTransferred = bytesTransferred;
+    }
+
+    @Override
+    public void onTransferEnd(DataSource source, DataSpec dataSpec, boolean isNetwork) {
+      lastTransferEndSource = source;
+      lastTransferEndDataSpec = dataSpec;
+      lastTransferEndIsNetwork = isNetwork;
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
index 49f865e2b5..dd1ae30bdb 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
@@ -20,9 +20,8 @@
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
-import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,16 +45,20 @@ public void testBase64Data() throws IOException {
     DataSpec dataSpec = buildDataSpec("data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiL"
         + "CJjb250ZW50X2lkIjoiTWpBeE5WOTBaV0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwM"
         + "DAwMDAwMDAwMDAiXX0=");
-    DataSourceAsserts.assertDataSourceContent(schemeDataDataSource, dataSpec,
-        ("{\"provider\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
-        + "[\"00000000000000000000000000000000\"]}").getBytes(Charset.forName(C.UTF8_NAME)));
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource,
+        dataSpec,
+        Util.getUtf8Bytes(
+            "{\"provider\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
+                + "[\"00000000000000000000000000000000\"]}"));
   }
 
   @Test
   public void testAsciiData() throws IOException {
-    DataSourceAsserts.assertDataSourceContent(schemeDataDataSource,
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource,
         buildDataSpec("data:,A%20brief%20note"),
-        "A brief note".getBytes(Charset.forName(C.UTF8_NAME)));
+        Util.getUtf8Bytes("A brief note"));
   }
 
   @Test
@@ -68,7 +71,7 @@ public void testPartialReads() throws IOException {
     assertThat(schemeDataDataSource.read(buffer, 9, 15)).isEqualTo(9);
     assertThat(schemeDataDataSource.read(buffer, 1, 0)).isEqualTo(0);
     assertThat(schemeDataDataSource.read(buffer, 1, 1)).isEqualTo(RESULT_END_OF_INPUT);
-    assertThat(new String(buffer, 0, 18, C.UTF8_NAME)).isEqualTo("012345678901234567");
+    assertThat(Util.fromUtf8Bytes(buffer, 0, 18)).isEqualTo("012345678901234567");
   }
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
new file mode 100644
index 0000000000..ebdb45909b
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
@@ -0,0 +1,531 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.telephony.TelephonyManager;
+import com.google.android.exoplayer2.C;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.shadows.ShadowNetworkInfo;
+
+/** Unit test for {@link DefaultBandwidthMeter}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultBandwidthMeterTest {
+
+  private static final String FAST_COUNTRY_ISO = "EE";
+  private static final String SLOW_COUNTRY_ISO = "PG";
+
+  private TelephonyManager telephonyManager;
+  private ConnectivityManager connectivityManager;
+  private NetworkInfo networkInfoOffline;
+  private NetworkInfo networkInfoWifi;
+  private NetworkInfo networkInfo2g;
+  private NetworkInfo networkInfo3g;
+  private NetworkInfo networkInfo4g;
+  private NetworkInfo networkInfoEthernet;
+
+  @Before
+  public void setUp() {
+    connectivityManager =
+        (ConnectivityManager)
+            RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE);
+    telephonyManager =
+        (TelephonyManager)
+            RuntimeEnvironment.application.getSystemService(Context.TELEPHONY_SERVICE);
+    Shadows.shadowOf(telephonyManager).setNetworkCountryIso(FAST_COUNTRY_ISO);
+    networkInfoOffline =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.DISCONNECTED,
+            ConnectivityManager.TYPE_WIFI,
+            /* subType= */ 0,
+            /* isAvailable= */ false,
+            /* isConnected= */ false);
+    networkInfoWifi =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_WIFI,
+            /* subType= */ 0,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfo2g =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_GPRS,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfo3g =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_HSDPA,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfo4g =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_LTE,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfoEthernet =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_ETHERNET,
+            /* subType= */ 0,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+  }
+  
+  @Test
+  public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeterWifi =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateWifi = bandwidthMeterWifi.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimateWifi).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor3G() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeterWifi =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateWifi = bandwidthMeterWifi.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    assertThat(initialEstimateWifi).isGreaterThan(initialEstimate3g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeterEthernet =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateEthernet = bandwidthMeterEthernet.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor3G() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeterEthernet =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateEthernet = bandwidthMeterEthernet.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate3g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfo4g);
+    DefaultBandwidthMeter bandwidthMeter4g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate4g = bandwidthMeter4g.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimate4g).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor3G() {
+    setActiveNetworkInfo(networkInfo4g);
+    DefaultBandwidthMeter bandwidthMeter4g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate4g = bandwidthMeter4g.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    assertThat(initialEstimate4g).isGreaterThan(initialEstimate3g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_for3G_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimate3g).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
+    setActiveNetworkInfo(networkInfoOffline);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isGreaterThan(100_000L);
+    assertThat(initialEstimate).isLessThan(50_000_000L);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_forWifi_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfoWifi);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_forEthernet_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_for2G_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfo2g);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_for3G_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfo3g);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_for4g_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfo4g);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_whileConnectedToNetwork_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_whileOffline_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoOffline);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forWifi_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forEthernet_whileConnectedToEthernet_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_ETHERNET, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forEthernet_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_for2G_whileConnectedTo2G_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_for2G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_for3G_whileConnectedTo3G_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_3G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_for3G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_3G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_for4G_whileConnectedTo4G_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfo4g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_4G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_for4G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_4G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_forOffline_whileOffline_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoOffline);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_OFFLINE, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forOffline_whileConnectedToNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_OFFLINE, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_forCountry_usesDefaultValuesForCountry() {
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFastWithSlowOverwrite =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(SLOW_COUNTRY_ISO)
+            .build();
+    long initialEstimateFastWithSlowOverwrite =
+        bandwidthMeterFastWithSlowOverwrite.getBitrateEstimate();
+
+    assertThat(initialEstimateFastWithSlowOverwrite).isEqualTo(initialEstimateSlow);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_withoutContext_isReasonable() {
+    DefaultBandwidthMeter bandwidthMeterWithBuilder =
+        new DefaultBandwidthMeter.Builder(/* context= */ null).build();
+    long initialEstimateWithBuilder = bandwidthMeterWithBuilder.getBitrateEstimate();
+
+    DefaultBandwidthMeter bandwidthMeterWithoutBuilder = new DefaultBandwidthMeter();
+    long initialEstimateWithoutBuilder = bandwidthMeterWithoutBuilder.getBitrateEstimate();
+
+    assertThat(initialEstimateWithBuilder).isGreaterThan(100_000L);
+    assertThat(initialEstimateWithBuilder).isLessThan(50_000_000L);
+    assertThat(initialEstimateWithoutBuilder).isGreaterThan(100_000L);
+    assertThat(initialEstimateWithoutBuilder).isLessThan(50_000_000L);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_withoutAccessNetworkStatePermission_isReasonable() {
+    Shadows.shadowOf(RuntimeEnvironment.application).denyPermissions(ACCESS_NETWORK_STATE);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isGreaterThan(100_000L);
+    assertThat(initialEstimate).isLessThan(50_000_000L);
+  }
+
+  private void setActiveNetworkInfo(NetworkInfo networkInfo) {
+    Shadows.shadowOf(connectivityManager).setActiveNetworkInfo(networkInfo);
+  }
+
+  private void setNetworkCountryIso(String countryIso) {
+    Shadows.shadowOf(telephonyManager).setNetworkCountryIso(countryIso);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
new file mode 100644
index 0000000000..5576588857
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit tests for {@link DefaultLoadErrorHandlingPolicy}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultLoadErrorHandlingPolicyTest {
+
+  @Test
+  public void getBlacklistDurationMsFor_blacklist404() {
+    InvalidResponseCodeException exception =
+        new InvalidResponseCodeException(
+            404, "Not Found", Collections.emptyMap(), new DataSpec(Uri.EMPTY));
+    assertThat(getDefaultPolicyBlacklistOutputFor(exception))
+        .isEqualTo(DefaultLoadErrorHandlingPolicy.DEFAULT_TRACK_BLACKLIST_MS);
+  }
+
+  @Test
+  public void getBlacklistDurationMsFor_blacklist410() {
+    InvalidResponseCodeException exception =
+        new InvalidResponseCodeException(
+            410, "Gone", Collections.emptyMap(), new DataSpec(Uri.EMPTY));
+    assertThat(getDefaultPolicyBlacklistOutputFor(exception))
+        .isEqualTo(DefaultLoadErrorHandlingPolicy.DEFAULT_TRACK_BLACKLIST_MS);
+  }
+
+  @Test
+  public void getBlacklistDurationMsFor_dontBlacklistUnexpectedHttpCodes() {
+    InvalidResponseCodeException exception =
+        new InvalidResponseCodeException(
+            500, "Internal Server Error", Collections.emptyMap(), new DataSpec(Uri.EMPTY));
+    assertThat(getDefaultPolicyBlacklistOutputFor(exception)).isEqualTo(C.TIME_UNSET);
+  }
+
+  @Test
+  public void getBlacklistDurationMsFor_dontBlacklistUnexpectedExceptions() {
+    FileNotFoundException exception = new FileNotFoundException();
+    assertThat(getDefaultPolicyBlacklistOutputFor(exception)).isEqualTo(C.TIME_UNSET);
+  }
+
+  @Test
+  public void getRetryDelayMsFor_dontRetryParserException() {
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new ParserException(), 1))
+        .isEqualTo(C.TIME_UNSET);
+  }
+
+  @Test
+  public void getRetryDelayMsFor_successiveRetryDelays() {
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new FileNotFoundException(), 3)).isEqualTo(2000);
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new FileNotFoundException(), 5)).isEqualTo(4000);
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new FileNotFoundException(), 9)).isEqualTo(5000);
+  }
+
+  private static long getDefaultPolicyBlacklistOutputFor(IOException exception) {
+    return new DefaultLoadErrorHandlingPolicy()
+        .getBlacklistDurationMsFor(
+            C.DATA_TYPE_MEDIA, /* loadDurationMs= */ 1000, exception, /* errorCount= */ 1);
+  }
+
+  private static long getDefaultPolicyRetryDelayOutputFor(IOException exception, int errorCount) {
+    return new DefaultLoadErrorHandlingPolicy()
+        .getRetryDelayMsFor(C.DATA_TYPE_MEDIA, /* loadDurationMs= */ 1000, exception, errorCount);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index 8dc702d3a3..2285a68062 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -46,16 +46,21 @@
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   private static final int MAX_CACHE_FILE_SIZE = 3;
+  private static final String CACHE_KEY_PREFIX = "myCacheKeyFactoryPrefix";
 
   private Uri testDataUri;
-  private String testDataKey;
+  private String fixedCacheKey;
+  private String expectedCacheKey;
   private File tempFolder;
   private SimpleCache cache;
+  private CacheKeyFactory cacheKeyFactory;
 
   @Before
   public void setUp() throws Exception {
     testDataUri = Uri.parse("test_data");
-    testDataKey = CacheUtil.generateKey(testDataUri);
+    fixedCacheKey = CacheUtil.generateKey(testDataUri);
+    expectedCacheKey = fixedCacheKey;
+    cacheKeyFactory = dataSpec -> CACHE_KEY_PREFIX + "." + CacheUtil.generateKey(dataSpec.uri);
     tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
@@ -77,41 +82,203 @@ public void testMaxCacheFileSize() throws Exception {
     }
   }
 
-  @Test
-  public void testCacheAndRead() throws Exception {
-    assertCacheAndRead(false, false);
-  }
-
   @Test
   public void testCacheAndReadUnboundedRequest() throws Exception {
-    assertCacheAndRead(true, false);
+    assertCacheAndRead(/* unboundedRequest= */ true, /* simulateUnknownLength= */ false);
   }
 
   @Test
   public void testCacheAndReadUnknownLength() throws Exception {
-    assertCacheAndRead(false, true);
+    assertCacheAndRead(/* unboundedRequest= */ false, /* simulateUnknownLength= */ true);
   }
 
   @Test
   public void testCacheAndReadUnboundedRequestUnknownLength() throws Exception {
-    assertCacheAndRead(true, true);
+    assertCacheAndRead(/* unboundedRequest= */ true, /* simulateUnknownLength= */ true);
+  }
+
+  @Test
+  public void testCacheAndRead() throws Exception {
+    assertCacheAndRead(/* unboundedRequest= */ false, /* simulateUnknownLength= */ false);
   }
 
   @Test
   public void testUnsatisfiableRange() throws Exception {
     // Bounded request but the content length is unknown. This forces all data to be cached but not
     // the length
-    assertCacheAndRead(false, true);
+    assertCacheAndRead(/* unboundedRequest= */ false, /* simulateUnknownLength= */ true);
 
     // Now do an unbounded request. This will read all of the data from cache and then try to read
     // more from upstream which will cause to a 416 so CDS will store the length.
-    CacheDataSource cacheDataSource = createCacheDataSource(true, true);
-    assertReadDataContentLength(cacheDataSource, true, true);
+    CacheDataSource cacheDataSource =
+        createCacheDataSource(/* setReadException= */ true, /* simulateUnknownLength= */ true);
+    assertReadDataContentLength(
+        cacheDataSource, /* unboundedRequest= */ true, /* unknownLength= */ true);
 
     // If the user try to access off range then it should throw an IOException
     try {
-      cacheDataSource = createCacheDataSource(false, false);
-      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, testDataKey));
+      cacheDataSource =
+          createCacheDataSource(/* setReadException= */ false, /* simulateUnknownLength= */ false);
+      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+      fail();
+    } catch (IOException e) {
+      // success
+    }
+  }
+
+  @Test
+  public void testCacheAndReadUnboundedRequestWithCacheKeyFactoryWithNullDataSpecCacheKey()
+      throws Exception {
+    fixedCacheKey = null;
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
+
+    assertCacheAndRead(
+        /* unboundedRequest= */ true, /* simulateUnknownLength= */ false, cacheKeyFactory);
+  }
+
+  @Test
+  public void testCacheAndReadUnknownLengthWithCacheKeyFactoryOverridingWithNullDataSpecCacheKey()
+      throws Exception {
+    fixedCacheKey = null;
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
+
+    assertCacheAndRead(
+        /* unboundedRequest= */ false, /* simulateUnknownLength= */ true, cacheKeyFactory);
+  }
+
+  @Test
+  public void
+      testCacheAndReadUnboundedRequestUnknownLengthWithCacheKeyFactoryWithNullDataSpecCacheKey()
+          throws Exception {
+    fixedCacheKey = null;
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
+
+    assertCacheAndRead(
+        /* unboundedRequest= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+  }
+
+  @Test
+  public void testCacheAndReadWithCacheKeyFactoryWithNullDataSpecCacheKey() throws Exception {
+    fixedCacheKey = null;
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
+
+    assertCacheAndRead(
+        /* unboundedRequest= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
+  }
+
+  @Test
+  public void testUnsatisfiableRangeWithCacheKeyFactoryNullDataSpecCacheKey() throws Exception {
+    fixedCacheKey = null;
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
+
+    // Bounded request but the content length is unknown. This forces all data to be cached but not
+    // the length
+    assertCacheAndRead(
+        /* unboundedRequest= */ false, /* simulateUnknownLength= */ true, cacheKeyFactory);
+
+    // Now do an unbounded request. This will read all of the data from cache and then try to read
+    // more from upstream which will cause to a 416 so CDS will store the length.
+    CacheDataSource cacheDataSource =
+        createCacheDataSource(
+            /* setReadException= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    assertReadDataContentLength(
+        cacheDataSource, /* unboundedRequest= */ true, /* unknownLength= */ true);
+
+    // If the user try to access off range then it should throw an IOException
+    try {
+      cacheDataSource =
+          createCacheDataSource(
+              /* setReadException= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
+      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+      fail();
+    } catch (IOException e) {
+      // success
+    }
+  }
+
+  @Test
+  public void testCacheAndReadUnboundedRequestWithCacheKeyFactoryOverridingDataSpecCacheKey()
+      throws Exception {
+    fixedCacheKey = CacheUtil.generateKey(testDataUri);
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+
+    assertCacheAndRead(true, false, cacheKeyFactory);
+  }
+
+  @Test
+  public void testCacheAndReadUnknownLengthWithCacheKeyFactoryOverridingDataSpecCacheKey()
+      throws Exception {
+    fixedCacheKey = CacheUtil.generateKey(testDataUri);
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+
+    assertCacheAndRead(false, true, cacheKeyFactory);
+  }
+
+  @Test
+  public void
+      testCacheAndReadUnboundedRequestUnknownLengthWithCacheKeyFactoryOverridingDataSpecCacheKey()
+          throws Exception {
+    fixedCacheKey = CacheUtil.generateKey(testDataUri);
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+
+    assertCacheAndRead(
+        /* unboundedRequest= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+  }
+
+  @Test
+  public void testCacheAndReadWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
+    fixedCacheKey = CacheUtil.generateKey(testDataUri);
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+
+    assertCacheAndRead(
+        /* unboundedRequest= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
+  }
+
+  @Test
+  public void testUnsatisfiableRangeWithCacheKeyFactoryOverridingDataSpecCacheKey()
+      throws Exception {
+    fixedCacheKey = CacheUtil.generateKey(testDataUri);
+    expectedCacheKey =
+        cacheKeyFactory.buildCacheKey(
+            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+
+    // Bounded request but the content length is unknown. This forces all data to be cached but not
+    // the length
+    assertCacheAndRead(
+        /* unboundedRequest= */ false, /* simulateUnknownLength= */ true, cacheKeyFactory);
+
+    // Now do an unbounded request. This will read all of the data from cache and then try to read
+    // more from upstream which will cause to a 416 so CDS will store the length.
+    CacheDataSource cacheDataSource =
+        createCacheDataSource(
+            /* setReadException= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    assertReadDataContentLength(
+        cacheDataSource, /* unboundedRequest= */ true, /* unknownLength= */ true);
+
+    // If the user try to access off range then it should throw an IOException
+    try {
+      cacheDataSource =
+          createCacheDataSource(
+              /* setReadException= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
+      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
       fail();
     } catch (IOException e) {
       // success
@@ -123,7 +290,7 @@ public void testContentLengthEdgeCases() throws Exception {
     // Read partial at EOS but don't cross it so length is unknown
     CacheDataSource cacheDataSource = createCacheDataSource(false, true);
     assertReadData(cacheDataSource, true, TEST_DATA.length - 2, 2);
-    assertThat(cache.getContentLength(testDataKey)).isEqualTo(C.LENGTH_UNSET);
+    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(C.LENGTH_UNSET);
 
     // Now do an unbounded request for whole data. This will cause a bounded request from upstream.
     // End of data from upstream shouldn't be mixed up with EOS and cause length set wrong.
@@ -133,7 +300,7 @@ public void testContentLengthEdgeCases() throws Exception {
     // Now the length set correctly do an unbounded request with offset
     assertThat(
             cacheDataSource.open(
-                new DataSpec(testDataUri, TEST_DATA.length - 2, C.LENGTH_UNSET, testDataKey)))
+                new DataSpec(testDataUri, TEST_DATA.length - 2, C.LENGTH_UNSET, expectedCacheKey)))
         .isEqualTo(2);
 
     // An unbounded request with offset for not cached content
@@ -155,12 +322,12 @@ public void testUnknownLengthContentReadInOneConnectionAndLengthIsResolved() thr
     CacheDataSource cacheDataSource = new CacheDataSource(cache, upstream, 0);
 
     int flags = DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH;
-    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey, flags));
+    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, expectedCacheKey, flags));
     TestUtil.readToEnd(cacheDataSource);
     cacheDataSource.close();
 
     assertThat(upstream.getAndClearOpenedDataSpecs()).hasLength(1);
-    assertThat(cache.getContentLength(testDataKey)).isEqualTo(TEST_DATA.length);
+    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(TEST_DATA.length);
   }
 
   @Test
@@ -171,7 +338,7 @@ public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
         new CacheDataSource(
             cache, upstream, CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
 
-    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey));
+    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, expectedCacheKey));
     TestUtil.readToEnd(cacheDataSource);
     cacheDataSource.close();
 
@@ -193,20 +360,14 @@ public void testSwitchToCacheSourceWithReadOnlyCacheDataSource() throws Exceptio
     // Insert an action just before the end of the data to fail the test if reading from upstream
     // reaches end of the data.
     fakeData
-        .appendReadAction(
-            new Runnable() {
-              @Override
-              public void run() {
-                fail("Read from upstream shouldn't reach to the end of the data.");
-              }
-            })
+        .appendReadAction(() -> fail("Read from upstream shouldn't reach to the end of the data."))
         .appendReadData(1);
     // Create cache read-only CacheDataSource.
     CacheDataSource cacheDataSource =
         new CacheDataSource(cache, upstream, new FileDataSource(), null, 0, null);
 
     // Open source and read some data from upstream as the data hasn't cached yet.
-    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
     cacheDataSource.open(dataSpec);
     byte[] buffer = new byte[1024];
     cacheDataSource.read(buffer, 0, buffer.length);
@@ -235,17 +396,11 @@ public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Excep
     // Insert an action just before the end of the data to fail the test if reading from upstream
     // reaches end of the data.
     fakeData
-        .appendReadAction(
-            new Runnable() {
-              @Override
-              public void run() {
-                fail("Read from upstream shouldn't reach to the end of the data.");
-              }
-            })
+        .appendReadAction(() -> fail("Read from upstream shouldn't reach to the end of the data."))
         .appendReadData(1);
 
     // Lock the content on the cache.
-    SimpleCacheSpan cacheSpan = cache.startReadWriteNonBlocking(testDataKey, 0);
+    SimpleCacheSpan cacheSpan = cache.startReadWriteNonBlocking(expectedCacheKey, 0);
     assertThat(cacheSpan).isNotNull();
     assertThat(cacheSpan.isHoleSpan()).isTrue();
 
@@ -253,7 +408,7 @@ public void run() {
     CacheDataSource cacheDataSource = new CacheDataSource(cache, upstream, 0);
 
     // Open source and read some data from upstream without writing to cache as the data is locked.
-    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
     cacheDataSource.open(dataSpec);
     byte[] buffer = new byte[1024];
     cacheDataSource.read(buffer, 0, buffer.length);
@@ -286,7 +441,7 @@ public void testDeleteCachedWhileReadingFromUpstreamWithReadOnlyCacheDataSourceD
     upstream.getDataSet().newDefaultData().appendReadData(1024).endData();
 
     // Cache the latter half of the data.
-    DataSpec dataSpec = new DataSpec(testDataUri, 512, C.LENGTH_UNSET, testDataKey);
+    DataSpec dataSpec = new DataSpec(testDataUri, 512, C.LENGTH_UNSET, fixedCacheKey);
     CacheUtil.cache(dataSpec, cache, upstream, /* counters= */ null, /* isCanceled= */ null);
 
     // Create cache read-only CacheDataSource.
@@ -294,12 +449,12 @@ public void testDeleteCachedWhileReadingFromUpstreamWithReadOnlyCacheDataSourceD
         new CacheDataSource(cache, upstream, new FileDataSource(), null, 0, null);
 
     // Open source and read some data from upstream as the data hasn't cached yet.
-    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
     cacheDataSource.open(dataSpec);
     TestUtil.readExactly(cacheDataSource, 100);
 
     // Delete cached data.
-    CacheUtil.remove(cache, testDataKey);
+    CacheUtil.remove(cache, expectedCacheKey);
     assertCacheEmpty(cache);
 
     // Read the rest of the data.
@@ -317,28 +472,24 @@ public void testDeleteCachedWhileReadingFromUpstreamWithBlockingCacheDataSourceD
 
     // Cache the latter half of the data.
     int halfDataLength = 512;
-    DataSpec dataSpec = new DataSpec(testDataUri, halfDataLength, C.LENGTH_UNSET, testDataKey);
+    DataSpec dataSpec = new DataSpec(testDataUri, halfDataLength, C.LENGTH_UNSET, fixedCacheKey);
     CacheUtil.cache(dataSpec, cache, upstream, /* counters= */ null, /* isCanceled= */ null);
 
     // Create blocking CacheDataSource.
     CacheDataSource cacheDataSource =
         new CacheDataSource(cache, upstream, CacheDataSource.FLAG_BLOCK_ON_CACHE);
 
-    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
     cacheDataSource.open(dataSpec);
 
     // Read the first half from upstream as it hasn't cached yet.
     TestUtil.readExactly(cacheDataSource, halfDataLength);
 
     // Delete the cached latter half.
-    NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(testDataKey);
+    NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(expectedCacheKey);
     for (CacheSpan cachedSpan : cachedSpans) {
       if (cachedSpan.position >= halfDataLength) {
-        try {
-          cache.removeSpan(cachedSpan);
-        } catch (Cache.CacheException e) {
-          // do nothing
-        }
+        cache.removeSpan(cachedSpan);
       }
     }
 
@@ -355,8 +506,30 @@ private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknow
 
     // Just read from cache
     cacheDataSource = createCacheDataSource(true, simulateUnknownLength);
-    assertReadDataContentLength(cacheDataSource, unboundedRequest,
-        false /*length is already cached*/);
+    assertReadDataContentLength(
+        cacheDataSource,
+        unboundedRequest,
+        // Length is already cached.
+        /* unknownLength= */ false);
+  }
+
+  private void assertCacheAndRead(
+      boolean unboundedRequest, boolean simulateUnknownLength, CacheKeyFactory cacheKeyFactory)
+      throws IOException {
+    // Read all data from upstream and write to cache
+    CacheDataSource cacheDataSource =
+        createCacheDataSource(
+            /* setReadException= */ false, simulateUnknownLength, cacheKeyFactory);
+    assertReadDataContentLength(cacheDataSource, unboundedRequest, simulateUnknownLength);
+
+    // Just read from cache
+    cacheDataSource =
+        createCacheDataSource(/* setReadException= */ true, simulateUnknownLength, cacheKeyFactory);
+    assertReadDataContentLength(
+        cacheDataSource,
+        unboundedRequest,
+        // Length is already cached.
+        /* unknownLength= */ false);
   }
 
   /**
@@ -368,7 +541,7 @@ private void assertReadDataContentLength(CacheDataSource cacheDataSource,
     int length = unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length;
     assertReadData(cacheDataSource, unknownLength, 0, length);
     // If !unboundedRequest, CacheDataSource doesn't reach EOS so shouldn't cache content length
-    assertThat(cache.getContentLength(testDataKey))
+    assertThat(cache.getContentLength(expectedCacheKey))
         .isEqualTo(!unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length);
   }
 
@@ -380,7 +553,11 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
     }
     DataSpec dataSpec =
         new DataSpec(
-            testDataUri, position, length, testDataKey, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+            testDataUri,
+            position,
+            length,
+            fixedCacheKey,
+            DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
     assertThat(cacheDataSource.open(dataSpec)).isEqualTo(unknownLength ? length : testDataLength);
     cacheDataSource.close();
 
@@ -395,6 +572,16 @@ private CacheDataSource createCacheDataSource(boolean setReadException,
         CacheDataSource.FLAG_BLOCK_ON_CACHE);
   }
 
+  private CacheDataSource createCacheDataSource(
+      boolean setReadException, boolean simulateUnknownLength, CacheKeyFactory cacheKeyFactory) {
+    return createCacheDataSource(
+        setReadException,
+        simulateUnknownLength,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE,
+        new CacheDataSink(cache, MAX_CACHE_FILE_SIZE),
+        cacheKeyFactory);
+  }
+
   private CacheDataSource createCacheDataSource(boolean setReadException,
       boolean simulateUnknownLength, @CacheDataSource.Flags int flags) {
     return createCacheDataSource(setReadException, simulateUnknownLength, flags,
@@ -404,14 +591,34 @@ private CacheDataSource createCacheDataSource(boolean setReadException,
   private CacheDataSource createCacheDataSource(boolean setReadException,
       boolean simulateUnknownLength, @CacheDataSource.Flags int flags,
       CacheDataSink cacheWriteDataSink) {
+    return createCacheDataSource(
+        setReadException,
+        simulateUnknownLength,
+        flags,
+        cacheWriteDataSink,
+        /* cacheKeyFactory= */ null);
+  }
+
+  private CacheDataSource createCacheDataSource(
+      boolean setReadException,
+      boolean simulateUnknownLength,
+      @CacheDataSource.Flags int flags,
+      CacheDataSink cacheWriteDataSink,
+      CacheKeyFactory cacheKeyFactory) {
     FakeDataSource upstream = new FakeDataSource();
     FakeData fakeData = upstream.getDataSet().newDefaultData()
         .setSimulateUnknownLength(simulateUnknownLength).appendReadData(TEST_DATA);
     if (setReadException) {
       fakeData.appendReadError(new IOException("Shouldn't read from upstream"));
     }
-    return new CacheDataSource(cache, upstream, new FileDataSource(), cacheWriteDataSink,
-        flags, null);
+    return new CacheDataSource(
+        cache,
+        upstream,
+        new FileDataSource(),
+        cacheWriteDataSink,
+        flags,
+        /* eventListener= */ null,
+        cacheKeyFactory);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
index 61c7f2b673..36fb78894f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
@@ -131,6 +131,22 @@ public void testGetKey() throws Exception {
         .isEqualTo(generateKey(testUri));
   }
 
+  @Test
+  public void testDefaultCacheKeyFactory_buildCacheKey() throws Exception {
+    Uri testUri = Uri.parse("test");
+    String key = "key";
+    // If DataSpec.key is present, returns it
+    assertThat(
+            CacheUtil.DEFAULT_CACHE_KEY_FACTORY.buildCacheKey(
+                new DataSpec(testUri, 0, LENGTH_UNSET, key)))
+        .isEqualTo(key);
+    // If not generates a new one using DataSpec.uri
+    assertThat(
+            CacheUtil.DEFAULT_CACHE_KEY_FACTORY.buildCacheKey(
+                new DataSpec(testUri, 0, LENGTH_UNSET, null)))
+        .isEqualTo(generateKey(testUri));
+  }
+
   @Test
   public void testGetCachedNoData() throws Exception {
     CachingCounters counters = new CachingCounters();
@@ -276,22 +292,15 @@ public void testCacheThrowEOFException() throws Exception {
   @Test
   public void testCachePolling() throws Exception {
     final CachingCounters counters = new CachingCounters();
-    FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
-        .appendReadData(TestUtil.buildTestData(100))
-        .appendReadAction(new Runnable() {
-          @Override
-          public void run() {
-            assertCounters(counters, 0, 100, 300);
-          }
-        })
-        .appendReadData(TestUtil.buildTestData(100))
-        .appendReadAction(new Runnable() {
-          @Override
-          public void run() {
-            assertCounters(counters, 0, 200, 300);
-          }
-        })
-        .appendReadData(TestUtil.buildTestData(100)).endData();
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .newData("test_data")
+            .appendReadData(TestUtil.buildTestData(100))
+            .appendReadAction(() -> assertCounters(counters, 0, 100, 300))
+            .appendReadData(TestUtil.buildTestData(100))
+            .appendReadAction(() -> assertCounters(counters, 0, 200, 300))
+            .appendReadData(TestUtil.buildTestData(100))
+            .endData();
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
 
     CacheUtil.cache(
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
index 50f9cd2ae8..f8da2b1085 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -61,8 +61,7 @@
   @Before
   public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
-    when(cache.addListener(anyString(), any(Cache.Listener.class)))
-        .thenReturn(new TreeSet<CacheSpan>());
+    when(cache.addListener(anyString(), any(Cache.Listener.class))).thenReturn(new TreeSet<>());
     tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
     cacheDir = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     index = new CachedContentIndex(cacheDir);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index 15e2b80f59..15bbb8c108 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -37,8 +37,6 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 
@@ -49,6 +47,7 @@
 public class SimpleCacheTest {
 
   private static final String KEY_1 = "key1";
+  private static final String KEY_2 = "key2";
 
   private File cacheDir;
 
@@ -154,6 +153,40 @@ public void testReloadCache() throws Exception {
     assertCachedDataReadCorrect(cacheSpan2);
   }
 
+  @Test
+  public void testReloadCacheWithoutRelease() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    // Write data for KEY_1.
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+    // Write and remove data for KEY_2.
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_2, 0);
+    addCache(simpleCache, KEY_2, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan2);
+    simpleCache.removeSpan(simpleCache.getCachedSpans(KEY_2).first());
+
+    // Don't release the cache. This means the index file wont have been written to disk after the
+    // data for KEY_2 was removed. Move the cache instead, so we can reload it without failing the
+    // folder locking check.
+    File cacheDir2 = Util.createTempFile(RuntimeEnvironment.application, "ExoPlayerTest");
+    cacheDir2.delete();
+    cacheDir.renameTo(cacheDir2);
+
+    // Reload the cache from its new location.
+    simpleCache = new SimpleCache(cacheDir2, new NoOpCacheEvictor());
+
+    // Read data back for KEY_1.
+    CacheSpan cacheSpan3 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan3);
+
+    // Check the entry for KEY_2 was removed when the cache was reloaded.
+    assertThat(simpleCache.getCachedSpans(KEY_2)).isEmpty();
+
+    Util.recursiveDelete(cacheDir2);
+  }
+
   @Test
   public void testEncryptedIndex() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
@@ -259,12 +292,12 @@ public void testExceptionDuringEvictionByLeastRecentlyUsedCacheEvictorNotHang()
     addCache(simpleCache, KEY_1, 0, 15);
 
     // Make index.store() throw exception from now on.
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        throw new Cache.CacheException("SimpleCacheTest");
-      }
-    }).when(index).store();
+    doAnswer(
+            invocation -> {
+              throw new CacheException("SimpleCacheTest");
+            })
+        .when(index)
+        .store();
 
     // Adding more content will make LeastRecentlyUsedCacheEvictor evict previous content.
     try {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
index 6c921f0288..4daa29afd0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
@@ -28,8 +28,8 @@
 @RunWith(RobolectricTestRunner.class)
 public final class ReusableBufferedOutputStreamTest {
 
-  private static final byte[] TEST_DATA_1 = "test data 1".getBytes();
-  private static final byte[] TEST_DATA_2 = "2 test data".getBytes();
+  private static final byte[] TEST_DATA_1 = Util.getUtf8Bytes("test data 1");
+  private static final byte[] TEST_DATA_2 = Util.getUtf8Bytes("2 test data");
 
   @Test
   public void testReset() throws Exception {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java
new file mode 100644
index 0000000000..ca34bc3216
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link TimedValueQueue}. */
+@RunWith(RobolectricTestRunner.class)
+public class TimedValueQueueTest {
+
+  private TimedValueQueue<String> queue;
+
+  @Before
+  public void setUp() throws Exception {
+    queue = new TimedValueQueue<>();
+  }
+
+  @Test
+  public void testAddAndPollValues() {
+    queue.add(0, "a");
+    queue.add(1, "b");
+    queue.add(2, "c");
+    assertThat(queue.poll(0)).isEqualTo("a");
+    assertThat(queue.poll(1)).isEqualTo("b");
+    assertThat(queue.poll(2)).isEqualTo("c");
+  }
+
+  @Test
+  public void testBufferCapacityIncreasesAutomatically() {
+    queue = new TimedValueQueue<>(1);
+    for (int i = 0; i < 20; i++) {
+      queue.add(i, "" + i);
+      if ((i & 1) == 1) {
+        assertThat(queue.poll(0)).isEqualTo("" + (i / 2));
+      }
+    }
+    assertThat(queue.size()).isEqualTo(10);
+  }
+
+  @Test
+  public void testTimeDiscontinuityClearsValues() {
+    queue.add(1, "b");
+    queue.add(2, "c");
+    queue.add(0, "a");
+    assertThat(queue.size()).isEqualTo(1);
+    assertThat(queue.poll(0)).isEqualTo("a");
+  }
+
+  @Test
+  public void testTimeDiscontinuityOnFullBufferClearsValues() {
+    queue = new TimedValueQueue<>(2);
+    queue.add(1, "b");
+    queue.add(3, "c");
+    queue.add(2, "a");
+    assertThat(queue.size()).isEqualTo(1);
+    assertThat(queue.poll(2)).isEqualTo("a");
+  }
+
+  @Test
+  public void testPollReturnsClosestValue() {
+    queue.add(0, "a");
+    queue.add(3, "b");
+    assertThat(queue.poll(2)).isEqualTo("b");
+    assertThat(queue.size()).isEqualTo(0);
+  }
+
+  @Test
+  public void testPollRemovesPreviousValues() {
+    queue.add(0, "a");
+    queue.add(1, "b");
+    queue.add(2, "c");
+    assertThat(queue.poll(1)).isEqualTo("b");
+    assertThat(queue.size()).isEqualTo(1);
+  }
+
+  @Test
+  public void testPollFloorReturnsClosestPreviousValue() {
+    queue.add(0, "a");
+    queue.add(3, "b");
+    assertThat(queue.pollFloor(2)).isEqualTo("a");
+    assertThat(queue.pollFloor(2)).isEqualTo(null);
+    assertThat(queue.pollFloor(3)).isEqualTo("b");
+    assertThat(queue.size()).isEqualTo(0);
+  }
+
+  @Test
+  public void testPollFloorRemovesPreviousValues() {
+    queue.add(0, "a");
+    queue.add(1, "b");
+    queue.add(2, "c");
+    assertThat(queue.pollFloor(1)).isEqualTo("b");
+    assertThat(queue.size()).isEqualTo(1);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
index cdd5d1a696..baf8aa7c40 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -27,8 +27,10 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Random;
+import java.util.zip.Deflater;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -247,6 +249,23 @@ public void testEscapeUnescapeFileName() {
     }
   }
 
+  @Test
+  public void testInflate() {
+    byte[] testData = TestUtil.buildTestData(/*arbitrary test data size*/ 256 * 1024);
+    byte[] compressedData = new byte[testData.length * 2];
+    Deflater compresser = new Deflater(9);
+    compresser.setInput(testData);
+    compresser.finish();
+    int compressedDataLength = compresser.deflate(compressedData);
+    compresser.end();
+
+    ParsableByteArray input = new ParsableByteArray(compressedData, compressedDataLength);
+    ParsableByteArray output = new ParsableByteArray();
+    assertThat(Util.inflate(input, output, /* inflater= */ null)).isTrue();
+    assertThat(output.limit()).isEqualTo(testData.length);
+    assertThat(Arrays.copyOf(output.data, output.limit())).isEqualTo(testData);
+  }
+
   private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
     assertThat(escapeFileName(fileName)).isEqualTo(escapedFileName);
     assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java
new file mode 100644
index 0000000000..071cd582d5
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.opengl.Matrix;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Tests {@link FrameRotationQueue}. */
+@RunWith(RobolectricTestRunner.class)
+public class FrameRotationQueueTest {
+
+  private FrameRotationQueue frameRotationQueue;
+  private float[] rotationMatrix;
+
+  @Before
+  public void setUp() throws Exception {
+    frameRotationQueue = new FrameRotationQueue();
+    rotationMatrix = new float[16];
+  }
+
+  @Test
+  public void testGetRotationMatrixReturnsNull_whenEmpty() throws Exception {
+    assertThat(frameRotationQueue.pollRotationMatrix(rotationMatrix, 0)).isFalse();
+  }
+
+  @Test
+  public void testGetRotationMatrixReturnsNotNull_whenNotEmpty() throws Exception {
+    frameRotationQueue.setRotation(0, new float[] {1, 2, 3});
+    assertThat(frameRotationQueue.pollRotationMatrix(rotationMatrix, 0)).isTrue();
+    assertThat(rotationMatrix).hasLength(16);
+  }
+
+  @Test
+  public void testConvertsAngleAxisToRotationMatrix() throws Exception {
+    doTestAngleAxisToRotationMatrix(/* angleRadian= */ 0, /* x= */ 1, /* y= */ 0, /* z= */ 0);
+    frameRotationQueue.reset();
+    doTestAngleAxisToRotationMatrix(/* angleRadian= */ 1, /* x= */ 1, /* y= */ 0, /* z= */ 0);
+    frameRotationQueue.reset();
+    doTestAngleAxisToRotationMatrix(/* angleRadian= */ 1, /* x= */ 0, /* y= */ 0, /* z= */ 1);
+    // Don't reset frameRotationQueue as we use recenter matrix from previous calls.
+    doTestAngleAxisToRotationMatrix(/* angleRadian= */ -1, /* x= */ 0, /* y= */ 1, /* z= */ 0);
+    doTestAngleAxisToRotationMatrix(/* angleRadian= */ 1, /* x= */ 1, /* y= */ 1, /* z= */ 1);
+  }
+
+  @Test
+  public void testRecentering_justYaw() throws Exception {
+    float[] actualMatrix =
+        getRotationMatrixFromAngleAxis(
+            /* angleRadian= */ (float) Math.PI, /* x= */ 0, /* y= */ 1, /* z= */ 0);
+    float[] expectedMatrix = new float[16];
+    Matrix.setIdentityM(expectedMatrix, 0);
+    assertEquals(actualMatrix, expectedMatrix);
+  }
+
+  @Test
+  public void testRecentering_yawAndPitch() throws Exception {
+    float[] matrix =
+        getRotationMatrixFromAngleAxis(
+            /* angleRadian= */ (float) Math.PI, /* x= */ 1, /* y= */ 1, /* z= */ 0);
+    assertMultiplication(
+        /* xr= */ 0, /* yr= */ 0, /* zr= */ 1, matrix, /* x= */ 0, /* y= */ 0, /* z= */ 1);
+  }
+
+  @Test
+  public void testRecentering_yawAndPitch2() throws Exception {
+    float[] matrix =
+        getRotationMatrixFromAngleAxis(
+            /* angleRadian= */ (float) Math.PI / 2, /* x= */ 1, /* y= */ 1, /* z= */ 0);
+    float sqrt2 = (float) Math.sqrt(2);
+    assertMultiplication(
+        /* xr= */ sqrt2, /* yr= */ 0, /* zr= */ 0, matrix, /* x= */ 1, /* y= */ -1, /* z= */ 0);
+  }
+
+  @Test
+  public void testRecentering_yawAndPitchAndRoll() throws Exception {
+    float[] matrix =
+        getRotationMatrixFromAngleAxis(
+            /* angleRadian= */ (float) Math.PI * 2 / 3, /* x= */ 1, /* y= */ 1, /* z= */ 1);
+    assertMultiplication(
+        /* xr= */ 0, /* yr= */ 0, /* zr= */ 1, matrix, /* x= */ 0, /* y= */ 0, /* z= */ 1);
+  }
+
+  private void doTestAngleAxisToRotationMatrix(float angleRadian, int x, int y, int z) {
+    float[] actualMatrix = getRotationMatrixFromAngleAxis(angleRadian, x, y, z);
+    float[] expectedMatrix = createRotationMatrix(angleRadian, x, y, z);
+    assertEquals(actualMatrix, expectedMatrix);
+  }
+
+  private float[] getRotationMatrixFromAngleAxis(float angleRadian, int x, int y, int z) {
+    float length = Matrix.length(x, y, z);
+    float factor = angleRadian / length;
+    // Negate y and z to revert OpenGL coordinate system conversion.
+    frameRotationQueue.setRotation(0, new float[] {x * factor, -y * factor, -z * factor});
+    frameRotationQueue.pollRotationMatrix(rotationMatrix, 0);
+    return rotationMatrix;
+  }
+
+  private static void assertMultiplication(
+      float xr, float yr, float zr, float[] actualMatrix, float x, float y, float z) {
+    float[] vector = new float[] {x, y, z, 0};
+    float[] resultVec = new float[4];
+    Matrix.multiplyMV(resultVec, 0, actualMatrix, 0, vector, 0);
+    assertEquals(resultVec, new float[] {xr, yr, zr, 0});
+  }
+
+  private static float[] createRotationMatrix(float angleRadian, int x, int y, int z) {
+    float[] expectedMatrix = new float[16];
+    Matrix.setRotateM(expectedMatrix, 0, (float) Math.toDegrees(angleRadian), x, y, z);
+    return expectedMatrix;
+  }
+
+  private static void assertEquals(float[] actual, float[] expected) {
+    assertThat(actual).usingTolerance(1.0e-5).containsExactly(expected).inOrder();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java
new file mode 100644
index 0000000000..af1a8421b4
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+import junit.framework.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Tests for {@link ProjectionDecoder}. */
+@RunWith(RobolectricTestRunner.class)
+public final class ProjectionDecoderTest {
+
+  private static final byte[] PROJ_DATA =
+      Util.getBytesFromHexString(
+          "0000008D70726F6A0000008579746D7000000000ABA158D672617720000000716D65736800000006BF800000"
+              + "3F8000003F0000003F2AAAAB000000003EAAAAAB000000100024200104022430010421034020400123"
+              + "1020401013020010102222001001003100200010320010000000010000000000240084009066080420"
+              + "9020108421002410860214C1200660");
+
+  private static final int MSHP_OFFSET = 16;
+  private static final int VERTEX_COUNT = 36;
+  private static final float[] FIRST_VERTEX = {-1.0f, -1.0f, 1.0f};
+  private static final float[] LAST_VERTEX = {1.0f, -1.0f, -1.0f};
+  private static final float[] FIRST_UV = {0.5f, 1.0f};
+  private static final float[] LAST_UV = {1.0f, 1.0f};
+
+  @Test
+  public void testDecodeProj() {
+    testDecoding(PROJ_DATA);
+  }
+
+  @Test
+  public void testDecodeMshp() {
+    testDecoding(Arrays.copyOfRange(PROJ_DATA, MSHP_OFFSET, PROJ_DATA.length));
+  }
+
+  private static void testDecoding(byte[] data) {
+    Projection projection = ProjectionDecoder.decode(data, C.STEREO_MODE_MONO);
+    assertThat(projection).isNotNull();
+    assertThat(projection.stereoMode).isEqualTo(C.STEREO_MODE_MONO);
+    assertThat(projection.leftMesh).isNotNull();
+    assertThat(projection.rightMesh).isNotNull();
+    assertThat(projection.singleMesh).isTrue();
+    testSubMesh(projection.leftMesh);
+  }
+
+  /** Tests the that SubMesh (mesh with the video) contains expected data. */
+  private static void testSubMesh(Projection.Mesh leftMesh) {
+    assertThat(leftMesh.getSubMeshCount()).isEqualTo(1);
+
+    Projection.SubMesh subMesh = leftMesh.getSubMesh(0);
+    assertThat(subMesh.mode).isEqualTo(Projection.DRAW_MODE_TRIANGLES);
+
+    float[] vertices = subMesh.vertices;
+    float[] uv = subMesh.textureCoords;
+    assertThat(vertices.length).isEqualTo(VERTEX_COUNT * 3);
+    assertThat(subMesh.textureCoords.length).isEqualTo(VERTEX_COUNT * 2);
+
+    // Test first vertex
+    testCoordinate(FIRST_VERTEX, vertices, 0, 3);
+    // Test last vertex
+    testCoordinate(LAST_VERTEX, vertices, VERTEX_COUNT * 3 - 3, 3);
+
+    // Test first uv
+    testCoordinate(FIRST_UV, uv, 0, 2);
+    // Test last uv
+    testCoordinate(LAST_UV, uv, VERTEX_COUNT * 2 - 2, 2);
+  }
+
+  /** Tests that the output coordinates match the expected. */
+  private static void testCoordinate(float[] expected, float[] output, int offset, int count) {
+    for (int i = 0; i < count; i++) {
+      Assert.assertEquals(expected[i], output[i + offset]);
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java
new file mode 100644
index 0000000000..0e2d0999fb
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video.spherical;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.C;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Tests for {@link Projection}. */
+@RunWith(RobolectricTestRunner.class)
+public class ProjectionTest {
+  private static final float EPSILON = .00001f;
+
+  // Default 360 sphere.
+  private static final float RADIUS = 1;
+  private static final int LATITUDES = 12;
+  private static final int LONGITUDES = 24;
+  private static final float VERTICAL_FOV_DEGREES = 180;
+  private static final float HORIZONTAL_FOV_DEGREES = 360;
+
+  @Test
+  public void testSphericalMesh() throws Exception {
+    // Only the first param is important in this test.
+    Projection projection =
+        Projection.createEquirectangular(
+            RADIUS,
+            LATITUDES,
+            LONGITUDES,
+            VERTICAL_FOV_DEGREES,
+            HORIZONTAL_FOV_DEGREES,
+            C.STEREO_MODE_MONO);
+
+    Projection.SubMesh subMesh = projection.leftMesh.getSubMesh(0);
+    assertThat(subMesh.getVertexCount()).isGreaterThan(LATITUDES * LONGITUDES);
+
+    float[] data = subMesh.vertices;
+    for (int i = 0; i < data.length; ) {
+      float x = data[i++];
+      float y = data[i++];
+      float z = data[i++];
+      assertEquals(RADIUS, Math.sqrt(x * x + y * y + z * z), EPSILON);
+    }
+  }
+
+  @Test
+  public void testArgumentValidation() {
+    checkIllegalArgumentException(0, 1, 1, 1, 1);
+    checkIllegalArgumentException(1, 0, 1, 1, 1);
+    checkIllegalArgumentException(1, 1, 0, 1, 1);
+    checkIllegalArgumentException(1, 1, 1, 0, 1);
+    checkIllegalArgumentException(1, 1, 1, 181, 1);
+    checkIllegalArgumentException(1, 1, 1, 1, 0);
+    checkIllegalArgumentException(1, 1, 1, 1, 361);
+  }
+
+  private void checkIllegalArgumentException(
+      float radius,
+      int latitudes,
+      int longitudes,
+      float verticalFovDegrees,
+      float horizontalFovDegrees) {
+    try {
+      Projection.createEquirectangular(
+          radius,
+          latitudes,
+          longitudes,
+          verticalFovDegrees,
+          horizontalFovDegrees,
+          C.STEREO_MODE_MONO);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Do nothing. Expected.
+    }
+  }
+}
diff --git a/library/dash/build.gradle b/library/dash/build.gradle
index 867b288498..40b014aaf9 100644
--- a/library/dash/build.gradle
+++ b/library/dash/build.gradle
@@ -18,9 +18,15 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
diff --git a/library/dash/proguard-rules.txt b/library/dash/proguard-rules.txt
new file mode 100644
index 0000000000..f8725fff4d
--- /dev/null
+++ b/library/dash/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the dash module.
+
+# Constructors accessed via reflection in SegmentDownloadAction
+-dontnote com.google.android.exoplayer2.source.dash.offline.DashDownloadAction
+-keepclassmembers class com.google.android.exoplayer2.source.dash.offline.DashDownloadAction {
+  static ** DESERIALIZER;
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
index 31c32e6100..c6cdc88f2f 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
 
 /**
  * An {@link ChunkSource} for DASH streams.
@@ -44,6 +45,8 @@
      *     message track.
      * @param enableCea608Track Whether the chunks generated by the source may output a CEA-608
      *     track.
+     * @param transferListener The transfer listener which should be informed of any data transfers.
+     *     May be null if no listener is available.
      * @return The created {@link DashChunkSource}.
      */
     DashChunkSource createDashChunkSource(
@@ -56,7 +59,8 @@ DashChunkSource createDashChunkSource(
         long elapsedRealtimeOffsetMs,
         boolean enableEventMessageTrack,
         boolean enableCea608Track,
-        @Nullable PlayerTrackEmsgHandler playerEmsgHandler);
+        @Nullable PlayerTrackEmsgHandler playerEmsgHandler,
+        @Nullable TransferListener transferListener);
   }
 
   /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index f80ff89fc1..5c9a933508 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -18,7 +18,6 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import android.util.Pair;
-import android.util.SparseArray;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -43,9 +42,12 @@
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -61,8 +63,8 @@
 
   /* package */ final int id;
   private final DashChunkSource.Factory chunkSourceFactory;
-  private final int minLoadableRetryCount;
-  private final EventDispatcher eventDispatcher;
+  private final @Nullable TransferListener transferListener;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final long elapsedRealtimeOffset;
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final Allocator allocator;
@@ -72,6 +74,7 @@
   private final PlayerEmsgHandler playerEmsgHandler;
   private final IdentityHashMap<ChunkSampleStream<DashChunkSource>, PlayerTrackEmsgHandler>
       trackEmsgHandlerBySampleStream;
+  private final EventDispatcher eventDispatcher;
 
   private @Nullable Callback callback;
   private ChunkSampleStream<DashChunkSource>[] sampleStreams;
@@ -87,7 +90,8 @@ public DashMediaPeriod(
       DashManifest manifest,
       int periodIndex,
       DashChunkSource.Factory chunkSourceFactory,
-      int minLoadableRetryCount,
+      @Nullable TransferListener transferListener,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       EventDispatcher eventDispatcher,
       long elapsedRealtimeOffset,
       LoaderErrorThrower manifestLoaderErrorThrower,
@@ -98,7 +102,8 @@ public DashMediaPeriod(
     this.manifest = manifest;
     this.periodIndex = periodIndex;
     this.chunkSourceFactory = chunkSourceFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.transferListener = transferListener;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
     this.elapsedRealtimeOffset = elapsedRealtimeOffset;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
@@ -139,7 +144,10 @@ public void updateManifest(DashManifest manifest, int periodIndex) {
     for (EventSampleStream eventSampleStream : eventSampleStreams) {
       for (EventStream eventStream : eventStreams) {
         if (eventStream.id().equals(eventSampleStream.eventStreamId())) {
-          eventSampleStream.updateEventStream(eventStream, manifest.dynamic);
+          int lastPeriodIndex = manifest.getPeriodCount() - 1;
+          eventSampleStream.updateEventStream(
+              eventStream,
+              /* eventStreamAppendable= */ manifest.dynamic && periodIndex == lastPeriodIndex);
           break;
         }
       }
@@ -186,126 +194,34 @@ public TrackGroupArray getTrackGroups() {
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    SparseArray<ChunkSampleStream<DashChunkSource>> primarySampleStreams = new SparseArray<>();
-    List<EventSampleStream> eventSampleStreamList = new ArrayList<>();
-
-    selectPrimarySampleStreams(selections, mayRetainStreamFlags, streams, streamResetFlags,
-        positionUs, primarySampleStreams);
-    selectEventSampleStreams(selections, mayRetainStreamFlags, streams,
-        streamResetFlags, eventSampleStreamList);
-    selectEmbeddedSampleStreams(selections, mayRetainStreamFlags, streams, streamResetFlags,
-        positionUs, primarySampleStreams);
-
-    sampleStreams = newSampleStreamArray(primarySampleStreams.size());
-    for (int i = 0; i < sampleStreams.length; i++) {
-      sampleStreams[i] = primarySampleStreams.valueAt(i);
+    int[] streamIndexToTrackGroupIndex = getStreamIndexToTrackGroupIndex(selections);
+    releaseDisabledStreams(selections, mayRetainStreamFlags, streams);
+    releaseOrphanEmbeddedStreams(selections, streams, streamIndexToTrackGroupIndex);
+    selectNewStreams(
+        selections, streams, streamResetFlags, positionUs, streamIndexToTrackGroupIndex);
+
+    ArrayList<ChunkSampleStream<DashChunkSource>> sampleStreamList = new ArrayList<>();
+    ArrayList<EventSampleStream> eventSampleStreamList = new ArrayList<>();
+    for (SampleStream sampleStream : streams) {
+      if (sampleStream instanceof ChunkSampleStream) {
+        @SuppressWarnings("unchecked")
+        ChunkSampleStream<DashChunkSource> stream =
+            (ChunkSampleStream<DashChunkSource>) sampleStream;
+        sampleStreamList.add(stream);
+      } else if (sampleStream instanceof EventSampleStream) {
+        eventSampleStreamList.add((EventSampleStream) sampleStream);
+      }
     }
+    sampleStreams = newSampleStreamArray(sampleStreamList.size());
+    sampleStreamList.toArray(sampleStreams);
     eventSampleStreams = new EventSampleStream[eventSampleStreamList.size()];
     eventSampleStreamList.toArray(eventSampleStreams);
+
     compositeSequenceableLoader =
         compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
     return positionUs;
   }
 
-  private void selectPrimarySampleStreams(
-      TrackSelection[] selections,
-      boolean[] mayRetainStreamFlags,
-      SampleStream[] streams,
-      boolean[] streamResetFlags,
-      long positionUs,
-      SparseArray<ChunkSampleStream<DashChunkSource>> primarySampleStreams) {
-    for (int i = 0; i < selections.length; i++) {
-      if (streams[i] instanceof ChunkSampleStream) {
-        @SuppressWarnings("unchecked")
-        ChunkSampleStream<DashChunkSource> stream = (ChunkSampleStream<DashChunkSource>) streams[i];
-        if (selections[i] == null || !mayRetainStreamFlags[i]) {
-          stream.release(this);
-          streams[i] = null;
-        } else {
-          int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
-          primarySampleStreams.put(trackGroupIndex, stream);
-        }
-      }
-
-      if (streams[i] == null && selections[i] != null) {
-        int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
-        TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
-        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_PRIMARY) {
-          ChunkSampleStream<DashChunkSource> stream = buildSampleStream(trackGroupInfo,
-              selections[i], positionUs);
-          primarySampleStreams.put(trackGroupIndex, stream);
-          streams[i] = stream;
-          streamResetFlags[i] = true;
-        }
-      }
-    }
-  }
-
-  private void selectEventSampleStreams(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags,
-      List<EventSampleStream> eventSampleStreamsList) {
-    for (int i = 0; i < selections.length; i++) {
-      if (streams[i] instanceof EventSampleStream) {
-        EventSampleStream stream = (EventSampleStream) streams[i];
-        if (selections[i] == null || !mayRetainStreamFlags[i]) {
-          streams[i] = null;
-        } else {
-          eventSampleStreamsList.add(stream);
-        }
-      }
-
-      if (streams[i] == null && selections[i] != null) {
-        int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
-        TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
-        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_MANIFEST_EVENTS) {
-          EventStream eventStream = eventStreams.get(trackGroupInfo.eventStreamGroupIndex);
-          Format format = selections[i].getTrackGroup().getFormat(0);
-          EventSampleStream stream = new EventSampleStream(eventStream, format, manifest.dynamic);
-          streams[i] = stream;
-          streamResetFlags[i] = true;
-          eventSampleStreamsList.add(stream);
-        }
-      }
-    }
-  }
-
-  private void selectEmbeddedSampleStreams(
-      TrackSelection[] selections,
-      boolean[] mayRetainStreamFlags,
-      SampleStream[] streams,
-      boolean[] streamResetFlags,
-      long positionUs,
-      SparseArray<ChunkSampleStream<DashChunkSource>> primarySampleStreams) {
-    for (int i = 0; i < selections.length; i++) {
-      if ((streams[i] instanceof EmbeddedSampleStream || streams[i] instanceof EmptySampleStream)
-          && (selections[i] == null || !mayRetainStreamFlags[i])) {
-        // The stream is for an embedded track and is either no longer selected or needs replacing.
-        releaseIfEmbeddedSampleStream(streams[i]);
-        streams[i] = null;
-      }
-      // We need to consider replacing the stream even if it's non-null because the primary stream
-      // may have been replaced, selected or deselected.
-      if (selections[i] != null) {
-        int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
-        TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
-        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_EMBEDDED) {
-          ChunkSampleStream<?> primaryStream = primarySampleStreams.get(
-              trackGroupInfo.primaryTrackGroupIndex);
-          SampleStream stream = streams[i];
-          boolean mayRetainStream = primaryStream == null ? stream instanceof EmptySampleStream
-              : (stream instanceof EmbeddedSampleStream
-                  && ((EmbeddedSampleStream) stream).parent == primaryStream);
-          if (!mayRetainStream) {
-            releaseIfEmbeddedSampleStream(stream);
-            streams[i] = primaryStream == null ? new EmptySampleStream()
-                : primaryStream.selectEmbeddedTrack(positionUs, trackGroupInfo.trackType);
-            streamResetFlags[i] = true;
-          }
-        }
-      }
-    }
-  }
-
   @Override
   public void discardBuffer(long positionUs, boolean toKeyframe) {
     for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
@@ -372,6 +288,124 @@ public void onContinueLoadingRequested(ChunkSampleStream<DashChunkSource> sample
 
   // Internal methods.
 
+  private int[] getStreamIndexToTrackGroupIndex(TrackSelection[] selections) {
+    int[] streamIndexToTrackGroupIndex = new int[selections.length];
+    for (int i = 0; i < selections.length; i++) {
+      if (selections[i] != null) {
+        streamIndexToTrackGroupIndex[i] = trackGroups.indexOf(selections[i].getTrackGroup());
+      } else {
+        streamIndexToTrackGroupIndex[i] = C.INDEX_UNSET;
+      }
+    }
+    return streamIndexToTrackGroupIndex;
+  }
+
+  private void releaseDisabledStreams(
+      TrackSelection[] selections, boolean[] mayRetainStreamFlags, SampleStream[] streams) {
+    for (int i = 0; i < selections.length; i++) {
+      if (selections[i] == null || !mayRetainStreamFlags[i]) {
+        if (streams[i] instanceof ChunkSampleStream) {
+          @SuppressWarnings("unchecked")
+          ChunkSampleStream<DashChunkSource> stream =
+              (ChunkSampleStream<DashChunkSource>) streams[i];
+          stream.release(this);
+        } else if (streams[i] instanceof EmbeddedSampleStream) {
+          ((EmbeddedSampleStream) streams[i]).release();
+        }
+        streams[i] = null;
+      }
+    }
+  }
+
+  private void releaseOrphanEmbeddedStreams(
+      TrackSelection[] selections, SampleStream[] streams, int[] streamIndexToTrackGroupIndex) {
+    for (int i = 0; i < selections.length; i++) {
+      if (streams[i] instanceof EmptySampleStream || streams[i] instanceof EmbeddedSampleStream) {
+        // We need to release an embedded stream if the corresponding primary stream is released.
+        int primaryStreamIndex = getPrimaryStreamIndex(i, streamIndexToTrackGroupIndex);
+        boolean mayRetainStream;
+        if (primaryStreamIndex == C.INDEX_UNSET) {
+          // If the corresponding primary stream is not selected, we may retain an existing
+          // EmptySampleStream.
+          mayRetainStream = streams[i] instanceof EmptySampleStream;
+        } else {
+          // If the corresponding primary stream is selected, we may retain the embedded stream if
+          // the stream's parent still matches.
+          mayRetainStream =
+              (streams[i] instanceof EmbeddedSampleStream)
+                  && ((EmbeddedSampleStream) streams[i]).parent == streams[primaryStreamIndex];
+        }
+        if (!mayRetainStream) {
+          if (streams[i] instanceof EmbeddedSampleStream) {
+            ((EmbeddedSampleStream) streams[i]).release();
+          }
+          streams[i] = null;
+        }
+      }
+    }
+  }
+
+  private void selectNewStreams(
+      TrackSelection[] selections,
+      SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs,
+      int[] streamIndexToTrackGroupIndex) {
+    // Create newly selected primary and event streams.
+    for (int i = 0; i < selections.length; i++) {
+      if (streams[i] == null && selections[i] != null) {
+        streamResetFlags[i] = true;
+        int trackGroupIndex = streamIndexToTrackGroupIndex[i];
+        TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
+        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_PRIMARY) {
+          streams[i] = buildSampleStream(trackGroupInfo, selections[i], positionUs);
+        } else if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_MANIFEST_EVENTS) {
+          EventStream eventStream = eventStreams.get(trackGroupInfo.eventStreamGroupIndex);
+          Format format = selections[i].getTrackGroup().getFormat(0);
+          streams[i] = new EventSampleStream(eventStream, format, manifest.dynamic);
+        }
+      }
+    }
+    // Create newly selected embedded streams from the corresponding primary stream. Note that this
+    // second pass is needed because the primary stream may not have been created yet in a first
+    // pass if the index of the primary stream is greater than the index of the embedded stream.
+    for (int i = 0; i < selections.length; i++) {
+      if (streams[i] == null && selections[i] != null) {
+        int trackGroupIndex = streamIndexToTrackGroupIndex[i];
+        TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
+        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_EMBEDDED) {
+          int primaryStreamIndex = getPrimaryStreamIndex(i, streamIndexToTrackGroupIndex);
+          if (primaryStreamIndex == C.INDEX_UNSET) {
+            // If an embedded track is selected without the corresponding primary track, create an
+            // empty sample stream instead.
+            streams[i] = new EmptySampleStream();
+          } else {
+            streams[i] =
+                ((ChunkSampleStream) streams[primaryStreamIndex])
+                    .selectEmbeddedTrack(positionUs, trackGroupInfo.trackType);
+          }
+        }
+      }
+    }
+  }
+
+  private int getPrimaryStreamIndex(int embeddedStreamIndex, int[] streamIndexToTrackGroupIndex) {
+    int embeddedTrackGroupIndex = streamIndexToTrackGroupIndex[embeddedStreamIndex];
+    if (embeddedTrackGroupIndex == C.INDEX_UNSET) {
+      return C.INDEX_UNSET;
+    }
+    int primaryTrackGroupIndex = trackGroupInfos[embeddedTrackGroupIndex].primaryTrackGroupIndex;
+    for (int i = 0; i < streamIndexToTrackGroupIndex.length; i++) {
+      int trackGroupIndex = streamIndexToTrackGroupIndex[i];
+      if (trackGroupIndex == primaryTrackGroupIndex
+          && trackGroupInfos[trackGroupIndex].trackGroupCategory
+              == TrackGroupInfo.CATEGORY_PRIMARY) {
+        return i;
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
   private static Pair<TrackGroupArray, TrackGroupInfo[]> buildTrackGroups(
       List<AdaptationSet> adaptationSets, List<EventStream> eventStreams) {
     int[][] groupedAdaptationSetIndices = getGroupedAdaptationSetIndices(adaptationSets);
@@ -562,7 +596,8 @@ private static void buildManifestEventTrackGroupInfos(List<EventStream> eventStr
             elapsedRealtimeOffset,
             enableEventMessageTrack,
             enableCea608Track,
-            trackPlayerEmsgHandler);
+            trackPlayerEmsgHandler,
+            transferListener);
     ChunkSampleStream<DashChunkSource> stream =
         new ChunkSampleStream<>(
             trackGroupInfo.trackType,
@@ -572,7 +607,7 @@ private static void buildManifestEventTrackGroupInfos(List<EventStream> eventStr
             this,
             allocator,
             positionUs,
-            minLoadableRetryCount,
+            loadErrorHandlingPolicy,
             eventDispatcher);
     synchronized (this) {
       // The map is also accessed on the loading thread so synchronize access.
@@ -624,14 +659,9 @@ private static boolean hasCea608Track(List<AdaptationSet> adaptationSets,
     return new ChunkSampleStream[length];
   }
 
-  private static void releaseIfEmbeddedSampleStream(SampleStream sampleStream) {
-    if (sampleStream instanceof EmbeddedSampleStream) {
-      ((EmbeddedSampleStream) sampleStream).release();
-    }
-  }
-
   private static final class TrackGroupInfo {
 
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({CATEGORY_PRIMARY, CATEGORY_EMBEDDED, CATEGORY_MANIFEST_EVENTS})
     public @interface TrackGroupCategory {}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 7b854e9d29..c8de8f02b1 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -20,7 +20,6 @@
 import android.os.SystemClock;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-import android.util.Log;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
@@ -37,15 +36,21 @@
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerEmsgCallback;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
 import com.google.android.exoplayer2.source.dash.manifest.UtcTimingElement;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -74,11 +79,22 @@
 
     private @Nullable ParsingLoadable.Parser<? extends DashManifest> manifestParser;
     private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
-    private int minLoadableRetryCount;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private long livePresentationDelayMs;
+    private boolean livePresentationDelayOverridesManifest;
     private boolean isCreateCalled;
     private @Nullable Object tag;
 
+    /**
+     * Creates a new factory for {@link DashMediaSource}s.
+     *
+     * @param dataSourceFactory A factory for {@link DataSource} instances that will be used to load
+     *     manifest and media data.
+     */
+    public Factory(DataSource.Factory dataSourceFactory) {
+      this(new DefaultDashChunkSource.Factory(dataSourceFactory), dataSourceFactory);
+    }
+
     /**
      * Creates a new factory for {@link DashMediaSource}s.
      *
@@ -93,8 +109,8 @@ public Factory(
         @Nullable DataSource.Factory manifestDataSourceFactory) {
       this.chunkSourceFactory = Assertions.checkNotNull(chunkSourceFactory);
       this.manifestDataSourceFactory = manifestDataSourceFactory;
-      minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
-      livePresentationDelayMs = DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
+      livePresentationDelayMs = DEFAULT_LIVE_PRESENTATION_DELAY_MS;
       compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
     }
 
@@ -114,34 +130,69 @@ public Factory setTag(Object tag) {
     }
 
     /**
-     * Sets the minimum number of times to retry if a loading error occurs. The default value is
-     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     * Sets the minimum number of times to retry if a loading error occurs. See {@link
+     * #setLoadErrorHandlingPolicy} for the default value.
+     *
+     * <p>Calling this method is equivalent to calling {@link #setLoadErrorHandlingPolicy} with
+     * {@link DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy(int)
+     * DefaultLoadErrorHandlingPolicy(minLoadableRetryCount)}
      *
      * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     * @deprecated Use {@link #setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy)} instead.
      */
+    @Deprecated
     public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      return setLoadErrorHandlingPolicy(new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount));
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy}. The default value is created by calling {@link
+     * DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy()}.
+     *
+     * <p>Calling this method overrides any calls to {@link #setMinLoadableRetryCount(int)}.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
       Assertions.checkState(!isCreateCalled);
-      this.minLoadableRetryCount = minLoadableRetryCount;
+      this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
       return this;
     }
 
+    /** @deprecated Use {@link #setLivePresentationDelayMs(long, boolean)}. */
+    @Deprecated
+    @SuppressWarnings("deprecation")
+    public Factory setLivePresentationDelayMs(long livePresentationDelayMs) {
+      if (livePresentationDelayMs == DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS) {
+        return setLivePresentationDelayMs(DEFAULT_LIVE_PRESENTATION_DELAY_MS, false);
+      } else {
+        return setLivePresentationDelayMs(livePresentationDelayMs, true);
+      }
+    }
+
     /**
      * Sets the duration in milliseconds by which the default start position should precede the end
-     * of the live window for live playbacks. The default value is {@link
-     * #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS}.
+     * of the live window for live playbacks. The {@code overridesManifest} parameter specifies
+     * whether the value is used in preference to one in the manifest, if present. The default value
+     * is {@link #DEFAULT_LIVE_PRESENTATION_DELAY_MS}, and by default {@code overridesManifest} is
+     * false.
      *
      * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
-     *     default start position should precede the end of the live window. Use {@link
-     *     #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by the
-     *     manifest, if present.
+     *     default start position should precede the end of the live window.
+     * @param overridesManifest Whether the value is used in preference to one in the manifest, if
+     *     present.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
      */
-    public Factory setLivePresentationDelayMs(long livePresentationDelayMs) {
+    public Factory setLivePresentationDelayMs(
+        long livePresentationDelayMs, boolean overridesManifest) {
       Assertions.checkState(!isCreateCalled);
       this.livePresentationDelayMs = livePresentationDelayMs;
+      this.livePresentationDelayOverridesManifest = overridesManifest;
       return this;
     }
 
@@ -196,8 +247,9 @@ public DashMediaSource createMediaSource(DashManifest manifest) {
           /* manifestParser= */ null,
           chunkSourceFactory,
           compositeSequenceableLoaderFactory,
-          minLoadableRetryCount,
+          loadErrorHandlingPolicy,
           livePresentationDelayMs,
+          livePresentationDelayOverridesManifest,
           tag);
     }
 
@@ -236,8 +288,9 @@ public DashMediaSource createMediaSource(Uri manifestUri) {
           manifestParser,
           chunkSourceFactory,
           compositeSequenceableLoaderFactory,
-          minLoadableRetryCount,
+          loadErrorHandlingPolicy,
           livePresentationDelayMs,
+          livePresentationDelayOverridesManifest,
           tag);
     }
 
@@ -264,21 +317,16 @@ public DashMediaSource createMediaSource(
   }
 
   /**
-   * The default minimum number of times to retry loading data prior to failing.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
-  /**
-   * A constant indicating that the presentation delay for live streams should be set to
-   * {@link DashManifest#suggestedPresentationDelayMs} if specified by the manifest, or
-   * {@link #DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS} otherwise. The presentation delay is the
-   * duration by which the default start position precedes the end of the live window.
-   */
-  public static final long DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS = -1;
-  /**
-   * A fixed default presentation delay for live streams. The presentation delay is the duration
-   * by which the default start position precedes the end of the live window.
+   * The default presentation delay for live streams. The presentation delay is the duration by
+   * which the default start position precedes the end of the live window.
    */
-  public static final long DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS = 30000;
+  public static final long DEFAULT_LIVE_PRESENTATION_DELAY_MS = 30000;
+  /** @deprecated Use {@link #DEFAULT_LIVE_PRESENTATION_DELAY_MS}. */
+  @Deprecated
+  public static final long DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS =
+      DEFAULT_LIVE_PRESENTATION_DELAY_MS;
+  /** @deprecated Use of this parameter is no longer necessary. */
+  @Deprecated public static final long DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS = -1;
 
   /**
    * The interval in milliseconds between invocations of {@link
@@ -297,8 +345,9 @@ public DashMediaSource createMediaSource(
   private final DataSource.Factory manifestDataSourceFactory;
   private final DashChunkSource.Factory chunkSourceFactory;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final long livePresentationDelayMs;
+  private final boolean livePresentationDelayOverridesManifest;
   private final EventDispatcher manifestEventDispatcher;
   private final ParsingLoadable.Parser<? extends DashManifest> manifestParser;
   private final ManifestCallback manifestCallback;
@@ -312,6 +361,7 @@ public DashMediaSource createMediaSource(
 
   private DataSource dataSource;
   private Loader loader;
+  private @Nullable TransferListener mediaTransferListener;
 
   private IOException manifestFatalError;
   private Handler handler;
@@ -326,7 +376,6 @@ public DashMediaSource createMediaSource(
 
   private int staleManifestReloadAttempt;
   private long expiredManifestPublishTimeUs;
-  private boolean dynamicMediaPresentationEnded;
 
   private int firstPeriodId;
 
@@ -340,12 +389,17 @@ public DashMediaSource createMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DashMediaSource(
       DashManifest manifest,
       DashChunkSource.Factory chunkSourceFactory,
       Handler eventHandler,
       MediaSourceEventListener eventListener) {
-    this(manifest, chunkSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
+    this(
+        manifest,
+        chunkSourceFactory,
+        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT,
+        eventHandler,
         eventListener);
   }
 
@@ -373,8 +427,9 @@ public DashMediaSource(
         /* manifestParser= */ null,
         chunkSourceFactory,
         new DefaultCompositeSequenceableLoaderFactory(),
-        minLoadableRetryCount,
-        DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
+        DEFAULT_LIVE_PRESENTATION_DELAY_MS,
+        /* livePresentationDelayOverridesManifest= */ false,
         /* tag= */ null);
     if (eventHandler != null && eventListener != null) {
       addEventListener(eventHandler, eventListener);
@@ -394,15 +449,21 @@ public DashMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DashMediaSource(
       Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
       DashChunkSource.Factory chunkSourceFactory,
       Handler eventHandler,
       MediaSourceEventListener eventListener) {
-    this(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
-        DEFAULT_MIN_LOADABLE_RETRY_COUNT, DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS,
-        eventHandler, eventListener);
+    this(
+        manifestUri,
+        manifestDataSourceFactory,
+        chunkSourceFactory,
+        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT,
+        DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS,
+        eventHandler,
+        eventListener);
   }
 
   /**
@@ -423,6 +484,7 @@ public DashMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DashMediaSource(
       Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
@@ -431,8 +493,15 @@ public DashMediaSource(
       long livePresentationDelayMs,
       Handler eventHandler,
       MediaSourceEventListener eventListener) {
-    this(manifestUri, manifestDataSourceFactory, new DashManifestParser(), chunkSourceFactory,
-        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+    this(
+        manifestUri,
+        manifestDataSourceFactory,
+        new DashManifestParser(),
+        chunkSourceFactory,
+        minLoadableRetryCount,
+        livePresentationDelayMs,
+        eventHandler,
+        eventListener);
   }
 
   /**
@@ -454,6 +523,7 @@ public DashMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public DashMediaSource(
       Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
@@ -470,8 +540,11 @@ public DashMediaSource(
         manifestParser,
         chunkSourceFactory,
         new DefaultCompositeSequenceableLoaderFactory(),
-        minLoadableRetryCount,
-        livePresentationDelayMs,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
+        livePresentationDelayMs == DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS
+            ? DEFAULT_LIVE_PRESENTATION_DELAY_MS
+            : livePresentationDelayMs,
+        livePresentationDelayMs != DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS,
         /* tag= */ null);
     if (eventHandler != null && eventListener != null) {
       addEventListener(eventHandler, eventListener);
@@ -485,8 +558,9 @@ private DashMediaSource(
       ParsingLoadable.Parser<? extends DashManifest> manifestParser,
       DashChunkSource.Factory chunkSourceFactory,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       long livePresentationDelayMs,
+      boolean livePresentationDelayOverridesManifest,
       @Nullable Object tag) {
     this.initialManifestUri = manifestUri;
     this.manifest = manifest;
@@ -494,8 +568,9 @@ private DashMediaSource(
     this.manifestDataSourceFactory = manifestDataSourceFactory;
     this.manifestParser = manifestParser;
     this.chunkSourceFactory = chunkSourceFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.livePresentationDelayMs = livePresentationDelayMs;
+    this.livePresentationDelayOverridesManifest = livePresentationDelayOverridesManifest;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     this.tag = tag;
     sideloadedManifest = manifest != null;
@@ -513,18 +588,8 @@ private DashMediaSource(
     } else {
       manifestCallback = new ManifestCallback();
       manifestLoadErrorThrower = new ManifestLoadErrorThrower();
-      refreshManifestRunnable = new Runnable() {
-        @Override
-        public void run() {
-          startLoadingManifest();
-        }
-      };
-      simulateManifestRefreshRunnable = new Runnable() {
-        @Override
-        public void run() {
-          processManifest(false);
-        }
-      };
+      refreshManifestRunnable = this::startLoadingManifest;
+      simulateManifestRefreshRunnable = () -> processManifest(false);
     }
   }
 
@@ -543,7 +608,17 @@ public void replaceManifestUri(Uri manifestUri) {
   // MediaSource implementation.
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    this.mediaTransferListener = mediaTransferListener;
     if (sideloadedManifest) {
       processManifest(false);
     } else {
@@ -561,7 +636,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId periodId, Allocator allocator) {
-    int periodIndex = periodId.periodIndex;
+    int periodIndex = (Integer) periodId.periodUid - firstPeriodId;
     EventDispatcher periodEventDispatcher =
         createEventDispatcher(periodId, manifest.getPeriod(periodIndex).startMs);
     DashMediaPeriod mediaPeriod =
@@ -570,7 +645,8 @@ public MediaPeriod createPeriod(MediaPeriodId periodId, Allocator allocator) {
             manifest,
             periodIndex,
             chunkSourceFactory,
-            minLoadableRetryCount,
+            mediaTransferListener,
+            loadErrorHandlingPolicy,
             periodEventDispatcher,
             elapsedRealtimeOffsetMs,
             manifestLoadErrorThrower,
@@ -608,7 +684,6 @@ public void releaseSourceInternal() {
     elapsedRealtimeOffsetMs = 0;
     staleManifestReloadAttempt = 0;
     expiredManifestPublishTimeUs = C.TIME_UNSET;
-    dynamicMediaPresentationEnded = false;
     firstPeriodId = 0;
     periodsById.clear();
   }
@@ -620,10 +695,6 @@ public void releaseSourceInternal() {
     startLoadingManifest();
   }
 
-  /* package */ void onDashLiveMediaPresentationEndSignalEncountered() {
-    this.dynamicMediaPresentationEnded = true;
-  }
-
   /* package */ void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs) {
     if (this.expiredManifestPublishTimeUs == C.TIME_UNSET
         || this.expiredManifestPublishTimeUs < expiredManifestPublishTimeUs) {
@@ -637,6 +708,8 @@ public void releaseSourceInternal() {
       long elapsedRealtimeMs, long loadDurationMs) {
     manifestEventDispatcher.loadCompleted(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -661,9 +734,8 @@ public void releaseSourceInternal() {
         // behind.
         Log.w(TAG, "Loaded out of sync manifest");
         isManifestStale = true;
-      } else if (dynamicMediaPresentationEnded
-          || (expiredManifestPublishTimeUs != C.TIME_UNSET
-              && newManifest.publishTimeMs * 1000 <= expiredManifestPublishTimeUs)) {
+      } else if (expiredManifestPublishTimeUs != C.TIME_UNSET
+          && newManifest.publishTimeMs * 1000 <= expiredManifestPublishTimeUs) {
         // If we receive a dynamic manifest that's older than expected (i.e. its publish time has
         // expired, or it's dynamic and we know the presentation has ended), then this manifest is
         // stale.
@@ -672,14 +744,13 @@ public void releaseSourceInternal() {
             "Loaded stale dynamic manifest: "
                 + newManifest.publishTimeMs
                 + ", "
-                + dynamicMediaPresentationEnded
-                + ", "
                 + expiredManifestPublishTimeUs);
         isManifestStale = true;
       }
 
       if (isManifestStale) {
-        if (staleManifestReloadAttempt++ < minLoadableRetryCount) {
+        if (staleManifestReloadAttempt++
+            < loadErrorHandlingPolicy.getMinimumLoadableRetryCount(loadable.type)) {
           scheduleManifestRefresh(getManifestLoadRetryDelayMillis());
         } else {
           manifestFatalError = new DashManifestStaleException();
@@ -689,7 +760,6 @@ public void releaseSourceInternal() {
       staleManifestReloadAttempt = 0;
     }
 
-
     manifest = newManifest;
     manifestLoadPending &= manifest.dynamic;
     manifestLoadStartTimestampMs = elapsedRealtimeMs - loadDurationMs;
@@ -698,7 +768,9 @@ public void releaseSourceInternal() {
       synchronized (manifestUriLock) {
         // This condition checks that replaceManifestUri wasn't called between the start and end of
         // this load. If it was, we ignore the manifest location and prefer the manual replacement.
-        if (loadable.dataSpec.uri == manifestUri) {
+        @SuppressWarnings("ReferenceEquality")
+        boolean isSameUriInstance = loadable.dataSpec.uri == manifestUri;
+        if (isSameUriInstance) {
           manifestUri = manifest.location;
         }
       }
@@ -716,8 +788,7 @@ public void releaseSourceInternal() {
     }
   }
 
-  /* package */ @Loader.RetryAction
-  int onManifestLoadError(
+  /* package */ LoadErrorAction onManifestLoadError(
       ParsingLoadable<DashManifest> loadable,
       long elapsedRealtimeMs,
       long loadDurationMs,
@@ -725,6 +796,8 @@ int onManifestLoadError(
     boolean isFatal = error instanceof ParserException;
     manifestEventDispatcher.loadError(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -738,6 +811,8 @@ int onManifestLoadError(
       long elapsedRealtimeMs, long loadDurationMs) {
     manifestEventDispatcher.loadCompleted(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -745,14 +820,15 @@ int onManifestLoadError(
     onUtcTimestampResolved(loadable.getResult() - elapsedRealtimeMs);
   }
 
-  /* package */ @Loader.RetryAction
-  int onUtcTimestampLoadError(
+  /* package */ LoadErrorAction onUtcTimestampLoadError(
       ParsingLoadable<Long> loadable,
       long elapsedRealtimeMs,
       long loadDurationMs,
       IOException error) {
     manifestEventDispatcher.loadError(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -767,6 +843,8 @@ int onUtcTimestampLoadError(
       long loadDurationMs) {
     manifestEventDispatcher.loadCanceled(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -869,9 +947,9 @@ private void processManifest(boolean scheduleRefresh) {
     long windowDefaultStartPositionUs = 0;
     if (manifest.dynamic) {
       long presentationDelayForManifestMs = livePresentationDelayMs;
-      if (presentationDelayForManifestMs == DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS) {
-        presentationDelayForManifestMs = manifest.suggestedPresentationDelayMs != C.TIME_UNSET
-            ? manifest.suggestedPresentationDelayMs : DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS;
+      if (!livePresentationDelayOverridesManifest
+          && manifest.suggestedPresentationDelayMs != C.TIME_UNSET) {
+        presentationDelayForManifestMs = manifest.suggestedPresentationDelayMs;
       }
       // Snap the default position to the start of the segment containing it.
       windowDefaultStartPositionUs = windowDurationUs - C.msToUs(presentationDelayForManifestMs);
@@ -944,7 +1022,7 @@ private void startLoadingManifest() {
     startLoading(
         new ParsingLoadable<>(dataSource, manifestUri, C.DATA_TYPE_MANIFEST, manifestParser),
         manifestCallback,
-        minLoadableRetryCount);
+        loadErrorHandlingPolicy.getMinimumLoadableRetryCount(C.DATA_TYPE_MANIFEST));
   }
 
   private long getManifestLoadRetryDelayMillis() {
@@ -974,8 +1052,25 @@ public static PeriodSeekInfo createPeriodSeekInfo(
       long availableEndTimeUs = Long.MAX_VALUE;
       boolean isIndexExplicit = false;
       boolean seenEmptyIndex = false;
+
+      boolean haveAudioVideoAdaptationSets = false;
       for (int i = 0; i < adaptationSetCount; i++) {
-        DashSegmentIndex index = period.adaptationSets.get(i).representations.get(0).getIndex();
+        int type = period.adaptationSets.get(i).type;
+        if (type == C.TRACK_TYPE_AUDIO || type == C.TRACK_TYPE_VIDEO) {
+          haveAudioVideoAdaptationSets = true;
+          break;
+        }
+      }
+
+      for (int i = 0; i < adaptationSetCount; i++) {
+        AdaptationSet adaptationSet = period.adaptationSets.get(i);
+        // Exclude text adaptation sets from duration calculations, if we have at least one audio
+        // or video adaptation set. See: https://github.com/google/ExoPlayer/issues/4029
+        if (haveAudioVideoAdaptationSets && adaptationSet.type == C.TRACK_TYPE_TEXT) {
+          continue;
+        }
+
+        DashSegmentIndex index = adaptationSet.representations.get(0).getIndex();
         if (index == null) {
           return new PeriodSeekInfo(true, 0, durationUs);
         }
@@ -1051,10 +1146,9 @@ public int getPeriodCount() {
 
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIdentifiers) {
-      Assertions.checkIndex(periodIndex, 0, manifest.getPeriodCount());
+      Assertions.checkIndex(periodIndex, 0, getPeriodCount());
       Object id = setIdentifiers ? manifest.getPeriod(periodIndex).id : null;
-      Object uid = setIdentifiers ? firstPeriodId
-          + Assertions.checkIndex(periodIndex, 0, manifest.getPeriodCount()) : null;
+      Object uid = setIdentifiers ? (firstPeriodId + periodIndex) : null;
       return period.set(id, uid, 0, manifest.getPeriodDurationUs(periodIndex),
           C.msToUs(manifest.getPeriod(periodIndex).startMs - manifest.getPeriod(0).startMs)
               - offsetInFirstPeriodUs);
@@ -1072,16 +1166,20 @@ public Window getWindow(
       long windowDefaultStartPositionUs = getAdjustedWindowDefaultStartPositionUs(
           defaultPositionProjectionUs);
       Object tag = setTag ? windowTag : null;
+      boolean isDynamic =
+          manifest.dynamic
+              && manifest.minUpdatePeriodMs != C.TIME_UNSET
+              && manifest.durationMs == C.TIME_UNSET;
       return window.set(
           tag,
           presentationStartTimeMs,
           windowStartTimeMs,
           /* isSeekable= */ true,
-          manifest.dynamic,
+          isDynamic,
           windowDefaultStartPositionUs,
           windowDurationUs,
           /* firstPeriodIndex= */ 0,
-          manifest.getPeriodCount() - 1,
+          /* lastPeriodIndex= */ getPeriodCount() - 1,
           offsetInFirstPeriodUs);
     }
 
@@ -1091,8 +1189,8 @@ public int getIndexOfPeriod(Object uid) {
         return C.INDEX_UNSET;
       }
       int periodId = (int) uid;
-      return periodId < firstPeriodId || periodId >= firstPeriodId + getPeriodCount()
-          ? C.INDEX_UNSET : (periodId - firstPeriodId);
+      int periodIndex = periodId - firstPeriodId;
+      return periodIndex < 0 || periodIndex >= getPeriodCount() ? C.INDEX_UNSET : periodIndex;
     }
 
     private long getAdjustedWindowDefaultStartPositionUs(long defaultPositionProjectionUs) {
@@ -1137,6 +1235,11 @@ private long getAdjustedWindowDefaultStartPositionUs(long defaultPositionProject
           - defaultStartPositionInPeriodUs;
     }
 
+    @Override
+    public Object getUidOfPeriod(int periodIndex) {
+      Assertions.checkIndex(periodIndex, 0, getPeriodCount());
+      return firstPeriodId + periodIndex;
+    }
   }
 
   private final class DefaultPlayerEmsgCallback implements PlayerEmsgCallback {
@@ -1150,11 +1253,6 @@ public void onDashManifestRefreshRequested() {
     public void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs) {
       DashMediaSource.this.onDashManifestPublishTimeExpired(expiredManifestPublishTimeUs);
     }
-
-    @Override
-    public void onDashLiveMediaPresentationEndSignalEncountered() {
-      DashMediaSource.this.onDashLiveMediaPresentationEndSignalEncountered();
-    }
   }
 
   private final class ManifestCallback implements Loader.Callback<ParsingLoadable<DashManifest>> {
@@ -1172,11 +1270,12 @@ public void onLoadCanceled(ParsingLoadable<DashManifest> loadable,
     }
 
     @Override
-    public @Loader.RetryAction int onLoadError(
+    public LoadErrorAction onLoadError(
         ParsingLoadable<DashManifest> loadable,
         long elapsedRealtimeMs,
         long loadDurationMs,
-        IOException error) {
+        IOException error,
+        int errorCount) {
       return onManifestLoadError(loadable, elapsedRealtimeMs, loadDurationMs, error);
     }
 
@@ -1197,11 +1296,12 @@ public void onLoadCanceled(ParsingLoadable<Long> loadable, long elapsedRealtimeM
     }
 
     @Override
-    public @Loader.RetryAction int onLoadError(
+    public LoadErrorAction onLoadError(
         ParsingLoadable<Long> loadable,
         long elapsedRealtimeMs,
         long loadDurationMs,
-        IOException error) {
+        IOException error,
+        int errorCount) {
       return onUtcTimestampLoadError(loadable, elapsedRealtimeMs, loadDurationMs, error);
     }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
index 6b481df46d..743462bd89 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
@@ -54,7 +54,7 @@
    */
   public static DashManifest loadManifest(DataSource dataSource, Uri uri)
       throws IOException {
-    return ParsingLoadable.load(dataSource, new DashManifestParser(), uri);
+    return ParsingLoadable.load(dataSource, new DashManifestParser(), uri, C.DATA_TYPE_MANIFEST);
   }
 
   /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index c00410f57e..5e20fb769c 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
+import android.support.annotation.CheckResult;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -29,13 +30,14 @@
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.rawcc.RawCcExtractor;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
+import com.google.android.exoplayer2.source.chunk.BaseMediaChunkIterator;
 import com.google.android.exoplayer2.source.chunk.Chunk;
 import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
 import com.google.android.exoplayer2.source.chunk.ChunkHolder;
-import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
 import com.google.android.exoplayer2.source.chunk.ContainerMediaChunk;
 import com.google.android.exoplayer2.source.chunk.InitializationChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.source.chunk.SingleSampleMediaChunk;
 import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerTrackEmsgHandler;
 import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
@@ -47,6 +49,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -84,8 +87,12 @@ public DashChunkSource createDashChunkSource(
         long elapsedRealtimeOffsetMs,
         boolean enableEventMessageTrack,
         boolean enableCea608Track,
-        @Nullable PlayerTrackEmsgHandler playerEmsgHandler) {
+        @Nullable PlayerTrackEmsgHandler playerEmsgHandler,
+        @Nullable TransferListener transferListener) {
       DataSource dataSource = dataSourceFactory.createDataSource();
+      if (transferListener != null) {
+        dataSource.addTransferListener(transferListener);
+      }
       return new DefaultDashChunkSource(
           manifestLoaderErrorThrower,
           manifest,
@@ -209,7 +216,8 @@ public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
       List<Representation> representations = getRepresentations();
       for (int i = 0; i < representationHolders.length; i++) {
         Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
-        representationHolders[i].updateRepresentation(periodDurationUs, representation);
+        representationHolders[i] =
+            representationHolders[i].copyWithNewRepresentation(periodDurationUs, representation);
       }
     } catch (BehindLiveWindowException e) {
       fatalError = e;
@@ -234,7 +242,10 @@ public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaCh
   }
 
   @Override
-  public void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+  public void getNextChunk(
+      long playbackPositionUs,
+      long loadPositionUs,
+      List<? extends MediaChunk> queue,
       ChunkHolder out) {
     if (fatalError != null) {
       return;
@@ -253,7 +264,37 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
       return;
     }
 
-    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
+    long nowUnixTimeUs = getNowUnixTimeUs();
+    MediaChunk previous = queue.isEmpty() ? null : queue.get(queue.size() - 1);
+    MediaChunkIterator[] chunkIterators = new MediaChunkIterator[trackSelection.length()];
+    for (int i = 0; i < chunkIterators.length; i++) {
+      RepresentationHolder representationHolder = representationHolders[i];
+      if (representationHolder.segmentIndex == null) {
+        chunkIterators[i] = MediaChunkIterator.EMPTY;
+      } else {
+        long firstAvailableSegmentNum =
+            representationHolder.getFirstAvailableSegmentNum(manifest, periodIndex, nowUnixTimeUs);
+        long lastAvailableSegmentNum =
+            representationHolder.getLastAvailableSegmentNum(manifest, periodIndex, nowUnixTimeUs);
+        long segmentNum =
+            getSegmentNum(
+                representationHolder,
+                previous,
+                loadPositionUs,
+                firstAvailableSegmentNum,
+                lastAvailableSegmentNum);
+        if (segmentNum < firstAvailableSegmentNum) {
+          chunkIterators[i] = MediaChunkIterator.EMPTY;
+        } else {
+          chunkIterators[i] =
+              new RepresentationSegmentIterator(
+                  representationHolder, segmentNum, lastAvailableSegmentNum);
+        }
+      }
+    }
+
+    trackSelection.updateSelectedTrack(
+        playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs, queue, chunkIterators);
 
     RepresentationHolder representationHolder =
         representationHolders[trackSelection.getSelectedIndex()];
@@ -277,58 +318,61 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
       }
     }
 
-    int availableSegmentCount = representationHolder.getSegmentCount();
-    if (availableSegmentCount == 0) {
+    long periodDurationUs = representationHolder.periodDurationUs;
+    boolean periodEnded = periodDurationUs != C.TIME_UNSET;
+
+    if (representationHolder.getSegmentCount() == 0) {
       // The index doesn't define any segments.
-      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
+      out.endOfStream = periodEnded;
       return;
     }
 
-    long firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
-    long lastAvailableSegmentNum;
-    if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
-      // The index is itself unbounded. We need to use the current time to calculate the range of
-      // available segments.
-      long liveEdgeTimeUs = getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTimeMs);
-      long periodStartUs = C.msToUs(manifest.getPeriod(periodIndex).startMs);
-      long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
-      if (manifest.timeShiftBufferDepthMs != C.TIME_UNSET) {
-        long bufferDepthUs = C.msToUs(manifest.timeShiftBufferDepthMs);
-        firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
-            representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
-      }
-      // getSegmentNum(liveEdgeTimeInPeriodUs) will not be completed yet, so subtract one to get the
-      // index of the last completed segment.
-      lastAvailableSegmentNum = representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
-    } else {
-      lastAvailableSegmentNum = firstAvailableSegmentNum + availableSegmentCount - 1;
-    }
+    long firstAvailableSegmentNum =
+        representationHolder.getFirstAvailableSegmentNum(manifest, periodIndex, nowUnixTimeUs);
+    long lastAvailableSegmentNum =
+        representationHolder.getLastAvailableSegmentNum(manifest, periodIndex, nowUnixTimeUs);
 
     updateLiveEdgeTimeUs(representationHolder, lastAvailableSegmentNum);
 
-    long segmentNum;
-    if (previous == null) {
-      segmentNum = Util.constrainValue(representationHolder.getSegmentNum(loadPositionUs),
-          firstAvailableSegmentNum, lastAvailableSegmentNum);
-    } else {
-      segmentNum = previous.getNextChunkIndex();
-      if (segmentNum < firstAvailableSegmentNum) {
-        // This is before the first chunk in the current manifest.
-        fatalError = new BehindLiveWindowException();
-        return;
-      }
+    long segmentNum =
+        getSegmentNum(
+            representationHolder,
+            previous,
+            loadPositionUs,
+            firstAvailableSegmentNum,
+            lastAvailableSegmentNum);
+    if (segmentNum < firstAvailableSegmentNum) {
+      // This is before the first chunk in the current manifest.
+      fatalError = new BehindLiveWindowException();
+      return;
     }
 
     if (segmentNum > lastAvailableSegmentNum
         || (missingLastSegment && segmentNum >= lastAvailableSegmentNum)) {
-      // This is beyond the last chunk in the current manifest.
-      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
+      // The segment is beyond the end of the period.
+      out.endOfStream = periodEnded;
+      return;
+    }
+
+    if (periodEnded && representationHolder.getSegmentStartTimeUs(segmentNum) >= periodDurationUs) {
+      // The period duration clips the period to a position before the segment.
+      out.endOfStream = true;
       return;
     }
 
     int maxSegmentCount =
         (int) Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
-    long seekTimeUs = previous == null ? loadPositionUs : C.TIME_UNSET;
+    if (periodDurationUs != C.TIME_UNSET) {
+      while (maxSegmentCount > 1
+          && representationHolder.getSegmentStartTimeUs(segmentNum + maxSegmentCount - 1)
+              >= periodDurationUs) {
+        // The period duration clips the period to a position before the last segment in the range
+        // [segmentNum, segmentNum + maxSegmentCount - 1]. Reduce maxSegmentCount.
+        maxSegmentCount--;
+      }
+    }
+
+    long seekTimeUs = queue.isEmpty() ? loadPositionUs : C.TIME_UNSET;
     out.chunk =
         newMediaChunk(
             representationHolder,
@@ -346,18 +390,19 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
   public void onChunkLoadCompleted(Chunk chunk) {
     if (chunk instanceof InitializationChunk) {
       InitializationChunk initializationChunk = (InitializationChunk) chunk;
-      RepresentationHolder representationHolder =
-          representationHolders[trackSelection.indexOf(initializationChunk.trackFormat)];
+      int trackIndex = trackSelection.indexOf(initializationChunk.trackFormat);
+      RepresentationHolder representationHolder = representationHolders[trackIndex];
       // The null check avoids overwriting an index obtained from the manifest with one obtained
       // from the stream. If the manifest defines an index then the stream shouldn't, but in cases
       // where it does we should ignore it.
       if (representationHolder.segmentIndex == null) {
         SeekMap seekMap = representationHolder.extractorWrapper.getSeekMap();
         if (seekMap != null) {
-          representationHolder.segmentIndex =
-              new DashWrappingSegmentIndex(
-                  (ChunkIndex) seekMap,
-                  representationHolder.representation.presentationTimeOffsetUs);
+          representationHolders[trackIndex] =
+              representationHolder.copyWithNewSegmentIndex(
+                  new DashWrappingSegmentIndex(
+                      (ChunkIndex) seekMap,
+                      representationHolder.representation.presentationTimeOffsetUs));
         }
       }
     }
@@ -367,7 +412,8 @@ public void onChunkLoadCompleted(Chunk chunk) {
   }
 
   @Override
-  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
+  public boolean onChunkLoadError(
+      Chunk chunk, boolean cancelable, Exception e, long blacklistDurationMs) {
     if (!cancelable) {
       return false;
     }
@@ -390,13 +436,26 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
         }
       }
     }
-    // Blacklist if appropriate.
-    return ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
-        trackSelection.indexOf(chunk.trackFormat), e);
+    return blacklistDurationMs != C.TIME_UNSET
+        && trackSelection.blacklist(trackSelection.indexOf(chunk.trackFormat), blacklistDurationMs);
   }
 
   // Internal methods.
 
+  private long getSegmentNum(
+      RepresentationHolder representationHolder,
+      @Nullable MediaChunk previousChunk,
+      long loadPositionUs,
+      long firstAvailableSegmentNum,
+      long lastAvailableSegmentNum) {
+    return previousChunk != null
+        ? previousChunk.getNextChunkIndex()
+        : Util.constrainValue(
+            representationHolder.getSegmentNum(loadPositionUs),
+            firstAvailableSegmentNum,
+            lastAvailableSegmentNum);
+  }
+
   private ArrayList<Representation> getRepresentations() {
     List<AdaptationSet> manifestAdapationSets = manifest.getPeriod(periodIndex).adaptationSets;
     ArrayList<Representation> representations = new ArrayList<>();
@@ -425,9 +484,14 @@ private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
     return resolveTimeToLiveEdgePossible ? liveEdgeTimeUs - playbackPositionUs : C.TIME_UNSET;
   }
 
-  protected static Chunk newInitializationChunk(RepresentationHolder representationHolder,
-      DataSource dataSource, Format trackFormat, int trackSelectionReason,
-      Object trackSelectionData, RangedUri initializationUri, RangedUri indexUri) {
+  protected Chunk newInitializationChunk(
+      RepresentationHolder representationHolder,
+      DataSource dataSource,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      RangedUri initializationUri,
+      RangedUri indexUri) {
     RangedUri requestUri;
     String baseUrl = representationHolder.representation.baseUrl;
     if (initializationUri != null) {
@@ -446,7 +510,7 @@ protected static Chunk newInitializationChunk(RepresentationHolder representatio
         trackSelectionReason, trackSelectionData, representationHolder.extractorWrapper);
   }
 
-  protected static Chunk newMediaChunk(
+  protected Chunk newMediaChunk(
       RepresentationHolder representationHolder,
       DataSource dataSource,
       int trackType,
@@ -479,6 +543,11 @@ protected static Chunk newMediaChunk(
         segmentCount++;
       }
       long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum + segmentCount - 1);
+      long periodDurationUs = representationHolder.periodDurationUs;
+      long clippedEndTimeUs =
+          periodDurationUs != C.TIME_UNSET && periodDurationUs <= endTimeUs
+              ? periodDurationUs
+              : C.TIME_UNSET;
       DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
           segmentUri.start, segmentUri.length, representation.getCacheKey());
       long sampleOffsetUs = -representation.presentationTimeOffsetUs;
@@ -491,6 +560,7 @@ protected static Chunk newMediaChunk(
           startTimeUs,
           endTimeUs,
           seekTimeUs,
+          clippedEndTimeUs,
           firstSegmentNum,
           segmentCount,
           sampleOffsetUs,
@@ -500,18 +570,57 @@ protected static Chunk newMediaChunk(
 
   // Protected classes.
 
-  /**
-   * Holds information about a single {@link Representation}.
-   */
+  /** {@link MediaChunkIterator} wrapping a {@link RepresentationHolder}. */
+  protected static final class RepresentationSegmentIterator extends BaseMediaChunkIterator {
+
+    private final RepresentationHolder representationHolder;
+
+    /**
+     * Creates iterator.
+     *
+     * @param representation The {@link RepresentationHolder} to wrap.
+     * @param segmentNum The number of the segment this iterator will be pointing to initially.
+     * @param lastAvailableSegmentNum The number of the last available segment.
+     */
+    public RepresentationSegmentIterator(
+        RepresentationHolder representation, long segmentNum, long lastAvailableSegmentNum) {
+      super(/* fromIndex= */ segmentNum, /* toIndex= */ lastAvailableSegmentNum);
+      this.representationHolder = representation;
+    }
+
+    @Override
+    public DataSpec getDataSpec() {
+      checkInBounds();
+      Representation representation = representationHolder.representation;
+      RangedUri segmentUri = representationHolder.getSegmentUrl(getCurrentIndex());
+      Uri resolvedUri = segmentUri.resolveUri(representation.baseUrl);
+      String cacheKey = representation.getCacheKey();
+      return new DataSpec(resolvedUri, segmentUri.start, segmentUri.length, cacheKey);
+    }
+
+    @Override
+    public long getChunkStartTimeUs() {
+      checkInBounds();
+      return representationHolder.getSegmentStartTimeUs(getCurrentIndex());
+    }
+
+    @Override
+    public long getChunkEndTimeUs() {
+      checkInBounds();
+      return representationHolder.getSegmentEndTimeUs(getCurrentIndex());
+    }
+  }
+
+  /** Holds information about a snapshot of a single {@link Representation}. */
   protected static final class RepresentationHolder {
 
-    /* package */ final ChunkExtractorWrapper extractorWrapper;
+    /* package */ final @Nullable ChunkExtractorWrapper extractorWrapper;
 
-    public Representation representation;
-    public DashSegmentIndex segmentIndex;
+    public final Representation representation;
+    public final @Nullable DashSegmentIndex segmentIndex;
 
-    private long periodDurationUs;
-    private long segmentNumShift;
+    private final long periodDurationUs;
+    private final long segmentNumShift;
 
     /* package */ RepresentationHolder(
         long periodDurationUs,
@@ -520,80 +629,86 @@ protected static Chunk newMediaChunk(
         boolean enableEventMessageTrack,
         boolean enableCea608Track,
         TrackOutput playerEmsgTrackOutput) {
+      this(
+          periodDurationUs,
+          representation,
+          createExtractorWrapper(
+              trackType,
+              representation,
+              enableEventMessageTrack,
+              enableCea608Track,
+              playerEmsgTrackOutput),
+          /* segmentNumShift= */ 0,
+          representation.getIndex());
+    }
+
+    private RepresentationHolder(
+        long periodDurationUs,
+        Representation representation,
+        @Nullable ChunkExtractorWrapper extractorWrapper,
+        long segmentNumShift,
+        @Nullable DashSegmentIndex segmentIndex) {
       this.periodDurationUs = periodDurationUs;
       this.representation = representation;
-      String containerMimeType = representation.format.containerMimeType;
-      if (mimeTypeIsRawText(containerMimeType)) {
-        extractorWrapper = null;
-      } else {
-        Extractor extractor;
-        if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
-          extractor = new RawCcExtractor(representation.format);
-        } else if (mimeTypeIsWebm(containerMimeType)) {
-          extractor = new MatroskaExtractor(MatroskaExtractor.FLAG_DISABLE_SEEK_FOR_CUES);
-        } else {
-          int flags = 0;
-          if (enableEventMessageTrack) {
-            flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
-          }
-          // TODO: Use caption format information from the manifest if available.
-          List<Format> closedCaptionFormats = enableCea608Track
-              ? Collections.singletonList(
-                  Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0, null))
-              : Collections.<Format>emptyList();
-
-          extractor =
-              new FragmentedMp4Extractor(
-                  flags, null, null, null, closedCaptionFormats, playerEmsgTrackOutput);
-        }
-        // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
-        // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
-        extractorWrapper = new ChunkExtractorWrapper(extractor, trackType, representation.format);
-      }
-      segmentIndex = representation.getIndex();
+      this.segmentNumShift = segmentNumShift;
+      this.extractorWrapper = extractorWrapper;
+      this.segmentIndex = segmentIndex;
     }
 
-    /* package */ void updateRepresentation(long newPeriodDurationUs,
-        Representation newRepresentation) throws BehindLiveWindowException {
+    @CheckResult
+    /* package */ RepresentationHolder copyWithNewRepresentation(
+        long newPeriodDurationUs, Representation newRepresentation)
+        throws BehindLiveWindowException {
       DashSegmentIndex oldIndex = representation.getIndex();
       DashSegmentIndex newIndex = newRepresentation.getIndex();
 
-      periodDurationUs = newPeriodDurationUs;
-      representation = newRepresentation;
       if (oldIndex == null) {
         // Segment numbers cannot shift if the index isn't defined by the manifest.
-        return;
+        return new RepresentationHolder(
+            newPeriodDurationUs, newRepresentation, extractorWrapper, segmentNumShift, oldIndex);
       }
 
-      segmentIndex = newIndex;
       if (!oldIndex.isExplicit()) {
         // Segment numbers cannot shift if the index isn't explicit.
-        return;
+        return new RepresentationHolder(
+            newPeriodDurationUs, newRepresentation, extractorWrapper, segmentNumShift, newIndex);
       }
 
-      int oldIndexSegmentCount = oldIndex.getSegmentCount(periodDurationUs);
+      int oldIndexSegmentCount = oldIndex.getSegmentCount(newPeriodDurationUs);
       if (oldIndexSegmentCount == 0) {
         // Segment numbers cannot shift if the old index was empty.
-        return;
+        return new RepresentationHolder(
+            newPeriodDurationUs, newRepresentation, extractorWrapper, segmentNumShift, newIndex);
       }
 
       long oldIndexLastSegmentNum = oldIndex.getFirstSegmentNum() + oldIndexSegmentCount - 1;
-      long oldIndexEndTimeUs = oldIndex.getTimeUs(oldIndexLastSegmentNum)
-          + oldIndex.getDurationUs(oldIndexLastSegmentNum, periodDurationUs);
+      long oldIndexEndTimeUs =
+          oldIndex.getTimeUs(oldIndexLastSegmentNum)
+              + oldIndex.getDurationUs(oldIndexLastSegmentNum, newPeriodDurationUs);
       long newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
       long newIndexStartTimeUs = newIndex.getTimeUs(newIndexFirstSegmentNum);
+      long newSegmentNumShift = segmentNumShift;
       if (oldIndexEndTimeUs == newIndexStartTimeUs) {
         // The new index continues where the old one ended, with no overlap.
-        segmentNumShift += oldIndexLastSegmentNum + 1 - newIndexFirstSegmentNum;
+        newSegmentNumShift += oldIndexLastSegmentNum + 1 - newIndexFirstSegmentNum;
       } else if (oldIndexEndTimeUs < newIndexStartTimeUs) {
         // There's a gap between the old index and the new one which means we've slipped behind the
         // live window and can't proceed.
         throw new BehindLiveWindowException();
       } else {
         // The new index overlaps with the old one.
-        segmentNumShift += oldIndex.getSegmentNum(newIndexStartTimeUs, periodDurationUs)
-            - newIndexFirstSegmentNum;
+        newSegmentNumShift +=
+            oldIndex.getSegmentNum(newIndexStartTimeUs, newPeriodDurationUs)
+                - newIndexFirstSegmentNum;
       }
+      return new RepresentationHolder(
+          newPeriodDurationUs, newRepresentation, extractorWrapper, newSegmentNumShift, newIndex);
+    }
+
+    @CheckResult
+    /* package */ RepresentationHolder copyWithNewSegmentIndex(DashSegmentIndex segmentIndex) {
+      return new RepresentationHolder(
+          periodDurationUs, representation, extractorWrapper, segmentNumShift, segmentIndex);
     }
 
     public long getFirstSegmentNum() {
@@ -621,6 +736,38 @@ public RangedUri getSegmentUrl(long segmentNum) {
       return segmentIndex.getSegmentUrl(segmentNum - segmentNumShift);
     }
 
+    public long getFirstAvailableSegmentNum(
+        DashManifest manifest, int periodIndex, long nowUnixTimeUs) {
+      if (getSegmentCount() == DashSegmentIndex.INDEX_UNBOUNDED
+          && manifest.timeShiftBufferDepthMs != C.TIME_UNSET) {
+        // The index is itself unbounded. We need to use the current time to calculate the range of
+        // available segments.
+        long liveEdgeTimeUs = nowUnixTimeUs - C.msToUs(manifest.availabilityStartTimeMs);
+        long periodStartUs = C.msToUs(manifest.getPeriod(periodIndex).startMs);
+        long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
+        long bufferDepthUs = C.msToUs(manifest.timeShiftBufferDepthMs);
+        return Math.max(
+            getFirstSegmentNum(), getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
+      }
+      return getFirstSegmentNum();
+    }
+
+    public long getLastAvailableSegmentNum(
+        DashManifest manifest, int periodIndex, long nowUnixTimeUs) {
+      int availableSegmentCount = getSegmentCount();
+      if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
+        // The index is itself unbounded. We need to use the current time to calculate the range of
+        // available segments.
+        long liveEdgeTimeUs = nowUnixTimeUs - C.msToUs(manifest.availabilityStartTimeMs);
+        long periodStartUs = C.msToUs(manifest.getPeriod(periodIndex).startMs);
+        long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
+        // getSegmentNum(liveEdgeTimeInPeriodUs) will not be completed yet, so subtract one to get
+        // the index of the last completed segment.
+        return getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
+      }
+      return getFirstSegmentNum() + availableSegmentCount - 1;
+    }
+
     private static boolean mimeTypeIsWebm(String mimeType) {
       return mimeType.startsWith(MimeTypes.VIDEO_WEBM) || mimeType.startsWith(MimeTypes.AUDIO_WEBM)
           || mimeType.startsWith(MimeTypes.APPLICATION_WEBM);
@@ -629,5 +776,40 @@ private static boolean mimeTypeIsWebm(String mimeType) {
     private static boolean mimeTypeIsRawText(String mimeType) {
       return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
     }
+
+    private static @Nullable ChunkExtractorWrapper createExtractorWrapper(
+        int trackType,
+        Representation representation,
+        boolean enableEventMessageTrack,
+        boolean enableCea608Track,
+        TrackOutput playerEmsgTrackOutput) {
+      String containerMimeType = representation.format.containerMimeType;
+      if (mimeTypeIsRawText(containerMimeType)) {
+        return null;
+      }
+      Extractor extractor;
+      if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
+        extractor = new RawCcExtractor(representation.format);
+      } else if (mimeTypeIsWebm(containerMimeType)) {
+        extractor = new MatroskaExtractor(MatroskaExtractor.FLAG_DISABLE_SEEK_FOR_CUES);
+      } else {
+        int flags = 0;
+        if (enableEventMessageTrack) {
+          flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
+        }
+        // TODO: Use caption format information from the manifest if available.
+        List<Format> closedCaptionFormats =
+            enableCea608Track
+                ? Collections.singletonList(
+                    Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0, null))
+                : Collections.emptyList();
+        extractor =
+            new FragmentedMp4Extractor(
+                flags, null, null, null, closedCaptionFormats, playerEmsgTrackOutput);
+      }
+      // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
+      // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
+      return new ChunkExtractorWrapper(extractor, trackType, representation.format);
+    }
   }
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
index 7fef59f6a1..9f812b8e84 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
@@ -36,37 +36,53 @@
   private final EventMessageEncoder eventMessageEncoder;
 
   private long[] eventTimesUs;
-  private boolean eventStreamUpdatable;
+  private boolean eventStreamAppendable;
   private EventStream eventStream;
 
   private boolean isFormatSentDownstream;
   private int currentIndex;
   private long pendingSeekPositionUs;
 
-  EventSampleStream(EventStream eventStream, Format upstreamFormat, boolean eventStreamUpdatable) {
+  public EventSampleStream(
+      EventStream eventStream, Format upstreamFormat, boolean eventStreamAppendable) {
     this.upstreamFormat = upstreamFormat;
     this.eventStream = eventStream;
     eventMessageEncoder = new EventMessageEncoder();
     pendingSeekPositionUs = C.TIME_UNSET;
     eventTimesUs = eventStream.presentationTimesUs;
-    updateEventStream(eventStream, eventStreamUpdatable);
+    updateEventStream(eventStream, eventStreamAppendable);
   }
 
-  void updateEventStream(EventStream eventStream, boolean eventStreamUpdatable) {
+  public String eventStreamId() {
+    return eventStream.id();
+  }
+
+  public void updateEventStream(EventStream eventStream, boolean eventStreamAppendable) {
     long lastReadPositionUs = currentIndex == 0 ? C.TIME_UNSET : eventTimesUs[currentIndex - 1];
 
-    this.eventStreamUpdatable = eventStreamUpdatable;
+    this.eventStreamAppendable = eventStreamAppendable;
     this.eventStream = eventStream;
     this.eventTimesUs = eventStream.presentationTimesUs;
     if (pendingSeekPositionUs != C.TIME_UNSET) {
       seekToUs(pendingSeekPositionUs);
     } else if (lastReadPositionUs != C.TIME_UNSET) {
-      currentIndex = Util.binarySearchCeil(eventTimesUs, lastReadPositionUs, false, false);
+      currentIndex =
+          Util.binarySearchCeil(
+              eventTimesUs, lastReadPositionUs, /* inclusive= */ false, /* stayInBounds= */ false);
     }
   }
 
-  String eventStreamId() {
-    return eventStream.id();
+  /**
+   * Seeks to the specified position in microseconds.
+   *
+   * @param positionUs The seek position in microseconds.
+   */
+  public void seekToUs(long positionUs) {
+    currentIndex =
+        Util.binarySearchCeil(
+            eventTimesUs, positionUs, /* inclusive= */ true, /* stayInBounds= */ false);
+    boolean isPendingSeek = eventStreamAppendable && currentIndex == eventTimesUs.length;
+    pendingSeekPositionUs = isPendingSeek ? positionUs : C.TIME_UNSET;
   }
 
   @Override
@@ -88,7 +104,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       return C.RESULT_FORMAT_READ;
     }
     if (currentIndex == eventTimesUs.length) {
-      if (!eventStreamUpdatable) {
+      if (!eventStreamAppendable) {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
       } else {
@@ -118,15 +134,4 @@ public int skipData(long positionUs) {
     return skipped;
   }
 
-  /**
-   * Seeks to the specified position in microseconds.
-   *
-   * @param positionUs The seek position in microseconds.
-   */
-  public void seekToUs(long positionUs) {
-    currentIndex = Util.binarySearchCeil(eventTimesUs, positionUs, true, false);
-    boolean isPendingSeek = eventStreamUpdatable && currentIndex == eventTimesUs.length;
-    pendingSeekPositionUs = isPendingSeek ? positionUs : C.TIME_UNSET;
-  }
-
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
index 1bb08c4398..be299308a9 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
@@ -35,6 +35,7 @@
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
@@ -59,8 +60,7 @@
  */
 public final class PlayerEmsgHandler implements Handler.Callback {
 
-  private static final int EMSG_MEDIA_PRESENTATION_ENDED = 1;
-  private static final int EMSG_MANIFEST_EXPIRED = 2;
+  private static final int EMSG_MANIFEST_EXPIRED = 1;
 
   /** Callbacks for player emsg events encountered during DASH live stream. */
   public interface PlayerEmsgCallback {
@@ -74,9 +74,6 @@
      * @param expiredManifestPublishTimeUs The manifest publish time that has been expired.
      */
     void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs);
-
-    /** Called when a media presentation end signal is encountered during live stream. * */
-    void onDashLiveMediaPresentationEndSignalEncountered();
   }
 
   private final Allocator allocator;
@@ -87,7 +84,6 @@
 
   private DashManifest manifest;
 
-  private boolean dynamicMediaPresentationEnded;
   private long expiredManifestPublishTimeUs;
   private long lastLoadedChunkEndTimeUs;
   private long lastLoadedChunkEndTimeBeforeRefreshUs;
@@ -100,7 +96,6 @@
    *     messages that generate DASH media source events.
    * @param allocator An {@link Allocator} from which allocations can be obtained.
    */
-  @SuppressWarnings("nullness")
   public PlayerEmsgHandler(
       DashManifest manifest, PlayerEmsgCallback playerEmsgCallback, Allocator allocator) {
     this.manifest = manifest;
@@ -108,7 +103,7 @@ public PlayerEmsgHandler(
     this.allocator = allocator;
 
     manifestPublishTimeToExpiryTimeUs = new TreeMap<>();
-    handler = new Handler(this);
+    handler = Util.createHandler(/* callback= */ this);
     decoder = new EventMessageDecoder();
     lastLoadedChunkEndTimeUs = C.TIME_UNSET;
     lastLoadedChunkEndTimeBeforeRefreshUs = C.TIME_UNSET;
@@ -134,21 +129,15 @@ public void updateManifest(DashManifest newManifest) {
       return true;
     }
     boolean manifestRefreshNeeded = false;
-    if (dynamicMediaPresentationEnded) {
-      // The manifest we have is dynamic, but we know a non-dynamic one representing the final state
-      // should be available.
-      manifestRefreshNeeded = true;
-    } else {
-      // Find the smallest publishTime (greater than or equal to the current manifest's publish
-      // time) that has a corresponding expiry time.
-      Map.Entry<Long, Long> expiredEntry = ceilingExpiryEntryForPublishTime(manifest.publishTimeMs);
-      if (expiredEntry != null) {
-        long expiredPointUs = expiredEntry.getValue();
-        if (expiredPointUs < presentationPositionUs) {
-          expiredManifestPublishTimeUs = expiredEntry.getKey();
-          notifyManifestPublishTimeExpired();
-          manifestRefreshNeeded = true;
-        }
+    // Find the smallest publishTime (greater than or equal to the current manifest's publish time)
+    // that has a corresponding expiry time.
+    Map.Entry<Long, Long> expiredEntry = ceilingExpiryEntryForPublishTime(manifest.publishTimeMs);
+    if (expiredEntry != null) {
+      long expiredPointUs = expiredEntry.getValue();
+      if (expiredPointUs < presentationPositionUs) {
+        expiredManifestPublishTimeUs = expiredEntry.getKey();
+        notifyManifestPublishTimeExpired();
+        manifestRefreshNeeded = true;
       }
     }
     if (manifestRefreshNeeded) {
@@ -221,9 +210,6 @@ public boolean handleMessage(Message message) {
       return true;
     }
     switch (message.what) {
-      case (EMSG_MEDIA_PRESENTATION_ENDED):
-        handleMediaPresentationEndedMessageEncountered();
-        return true;
       case (EMSG_MANIFEST_EXPIRED):
         ManifestExpiryEventInfo messageObj = (ManifestExpiryEventInfo) message.obj;
         handleManifestExpiredMessage(
@@ -248,11 +234,6 @@ private void handleManifestExpiredMessage(long eventTimeUs, long manifestPublish
     }
   }
 
-  private void handleMediaPresentationEndedMessageEncountered() {
-    dynamicMediaPresentationEnded = true;
-    notifySourceMediaPresentationEnded();
-  }
-
   private @Nullable Map.Entry<Long, Long> ceilingExpiryEntryForPublishTime(long publishTimeMs) {
     return manifestPublishTimeToExpiryTimeUs.ceilingEntry(publishTimeMs);
   }
@@ -273,10 +254,6 @@ private void notifyManifestPublishTimeExpired() {
     playerEmsgCallback.onDashManifestPublishTimeExpired(expiredManifestPublishTimeUs);
   }
 
-  private void notifySourceMediaPresentationEnded() {
-    playerEmsgCallback.onDashLiveMediaPresentationEndSignalEncountered();
-  }
-
   /** Requests DASH media manifest to be refreshed if necessary. */
   private void maybeNotifyDashManifestRefreshNeeded() {
     if (lastLoadedChunkEndTimeBeforeRefreshUs != C.TIME_UNSET
@@ -291,19 +268,13 @@ private void maybeNotifyDashManifestRefreshNeeded() {
 
   private static long getManifestPublishTimeMsInEmsg(EventMessage eventMessage) {
     try {
-      return parseXsDateTime(new String(eventMessage.messageData));
+      return parseXsDateTime(Util.fromUtf8Bytes(eventMessage.messageData));
     } catch (ParserException ignored) {
       // if we can't parse this event, ignore
       return C.TIME_UNSET;
     }
   }
 
-  private static boolean isMessageSignalingMediaPresentationEnded(EventMessage eventMessage) {
-    // According to section 4.5.2.1 DASH-IF IOP, if both presentation time delta and event duration
-    // are zero, the media presentation is ended.
-    return eventMessage.presentationTimeUs == 0 && eventMessage.durationMs == 0;
-  }
-
   /** Handles emsg messages for a specific track for the player. */
   public final class PlayerTrackEmsgHandler implements TrackOutput {
 
@@ -336,7 +307,7 @@ public void sampleData(ParsableByteArray data, int length) {
 
     @Override
     public void sampleMetadata(
-        long timeUs, int flags, int size, int offset, CryptoData encryptionData) {
+        long timeUs, int flags, int size, int offset, @Nullable CryptoData encryptionData) {
       sampleQueue.sampleMetadata(timeUs, flags, size, offset, encryptionData);
       parseAndDiscardSamples();
     }
@@ -413,16 +384,7 @@ private void parsePlayerEmsgEvent(long eventTimeUs, EventMessage eventMessage) {
       if (manifestPublishTimeMsInEmsg == C.TIME_UNSET) {
         return;
       }
-
-      if (isMessageSignalingMediaPresentationEnded(eventMessage)) {
-        onMediaPresentationEndedMessageEncountered();
-      } else {
-        onManifestExpiredMessageEncountered(eventTimeUs, manifestPublishTimeMsInEmsg);
-      }
-    }
-
-    private void onMediaPresentationEndedMessageEncountered() {
-      handler.sendMessage(handler.obtainMessage(EMSG_MEDIA_PRESENTATION_ENDED));
+      onManifestExpiredMessageEncountered(eventTimeUs, manifestPublishTimeMsInEmsg);
     }
 
     private void onManifestExpiredMessageEncountered(
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
index fd91a2f784..d962374745 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
@@ -69,12 +69,14 @@ public AdaptationSet(int id, int type, List<Representation> representations,
     this.id = id;
     this.type = type;
     this.representations = Collections.unmodifiableList(representations);
-    this.accessibilityDescriptors = accessibilityDescriptors == null
-        ? Collections.<Descriptor>emptyList()
-        : Collections.unmodifiableList(accessibilityDescriptors);
-    this.supplementalProperties = supplementalProperties == null
-        ? Collections.<Descriptor>emptyList()
-        : Collections.unmodifiableList(supplementalProperties);
+    this.accessibilityDescriptors =
+        accessibilityDescriptors == null
+            ? Collections.emptyList()
+            : Collections.unmodifiableList(accessibilityDescriptors);
+    this.supplementalProperties =
+        supplementalProperties == null
+            ? Collections.emptyList()
+            : Collections.unmodifiableList(supplementalProperties);
   }
 
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
index 639ad32d78..3637b80ecb 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
@@ -16,8 +16,10 @@
 package com.google.android.exoplayer2.source.dash.manifest;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.FilterableManifest;
+import com.google.android.exoplayer2.offline.StreamKey;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedList;
@@ -27,7 +29,7 @@
  * Represents a DASH media presentation description (mpd), as defined by ISO/IEC 23009-1:2014
  * Section 5.3.1.2.
  */
-public class DashManifest implements FilterableManifest<DashManifest, RepresentationKey> {
+public class DashManifest implements FilterableManifest<DashManifest> {
 
   /**
    * The {@code availabilityStartTime} value in milliseconds since epoch, or {@link C#TIME_UNSET} if
@@ -85,12 +87,56 @@
    */
   public final Uri location;
 
+  /** The {@link ProgramInformation}, or null if not present. */
+  @Nullable public final ProgramInformation programInformation;
+
   private final List<Period> periods;
 
-  public DashManifest(long availabilityStartTimeMs, long durationMs, long minBufferTimeMs,
-      boolean dynamic, long minUpdatePeriodMs, long timeShiftBufferDepthMs,
-      long suggestedPresentationDelayMs, long publishTimeMs, UtcTimingElement utcTiming,
-      Uri location, List<Period> periods) {
+  /**
+   * @deprecated Use {@link #DashManifest(long, long, long, boolean, long, long, long, long,
+   *     ProgramInformation, UtcTimingElement, Uri, List)}.
+   */
+  @Deprecated
+  public DashManifest(
+      long availabilityStartTimeMs,
+      long durationMs,
+      long minBufferTimeMs,
+      boolean dynamic,
+      long minUpdatePeriodMs,
+      long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs,
+      long publishTimeMs,
+      UtcTimingElement utcTiming,
+      Uri location,
+      List<Period> periods) {
+    this(
+        availabilityStartTimeMs,
+        durationMs,
+        minBufferTimeMs,
+        dynamic,
+        minUpdatePeriodMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        /* programInformation= */ null,
+        utcTiming,
+        location,
+        periods);
+  }
+
+  public DashManifest(
+      long availabilityStartTimeMs,
+      long durationMs,
+      long minBufferTimeMs,
+      boolean dynamic,
+      long minUpdatePeriodMs,
+      long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs,
+      long publishTimeMs,
+      @Nullable ProgramInformation programInformation,
+      UtcTimingElement utcTiming,
+      Uri location,
+      List<Period> periods) {
     this.availabilityStartTimeMs = availabilityStartTimeMs;
     this.durationMs = durationMs;
     this.minBufferTimeMs = minBufferTimeMs;
@@ -99,9 +145,10 @@ public DashManifest(long availabilityStartTimeMs, long durationMs, long minBuffe
     this.timeShiftBufferDepthMs = timeShiftBufferDepthMs;
     this.suggestedPresentationDelayMs = suggestedPresentationDelayMs;
     this.publishTimeMs = publishTimeMs;
+    this.programInformation = programInformation;
     this.utcTiming = utcTiming;
     this.location = location;
-    this.periods = periods == null ? Collections.<Period>emptyList() : periods;
+    this.periods = periods == null ? Collections.emptyList() : periods;
   }
 
   public final int getPeriodCount() {
@@ -123,10 +170,10 @@ public final long getPeriodDurationUs(int index) {
   }
 
   @Override
-  public final DashManifest copy(List<RepresentationKey> streamKeys) {
-    LinkedList<RepresentationKey> keys = new LinkedList<>(streamKeys);
+  public final DashManifest copy(List<StreamKey> streamKeys) {
+    LinkedList<StreamKey> keys = new LinkedList<>(streamKeys);
     Collections.sort(keys);
-    keys.add(new RepresentationKey(-1, -1, -1)); // Add a stopper key to the end
+    keys.add(new StreamKey(-1, -1, -1)); // Add a stopper key to the end
 
     ArrayList<Period> copyPeriods = new ArrayList<>();
     long shiftMs = 0;
@@ -147,27 +194,37 @@ public final DashManifest copy(List<RepresentationKey> streamKeys) {
       }
     }
     long newDuration = durationMs != C.TIME_UNSET ? durationMs - shiftMs : C.TIME_UNSET;
-    return new DashManifest(availabilityStartTimeMs, newDuration, minBufferTimeMs, dynamic,
-        minUpdatePeriodMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs, publishTimeMs,
-        utcTiming, location, copyPeriods);
+    return new DashManifest(
+        availabilityStartTimeMs,
+        newDuration,
+        minBufferTimeMs,
+        dynamic,
+        minUpdatePeriodMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        programInformation,
+        utcTiming,
+        location,
+        copyPeriods);
   }
 
   private static ArrayList<AdaptationSet> copyAdaptationSets(
-      List<AdaptationSet> adaptationSets, LinkedList<RepresentationKey> keys) {
-    RepresentationKey key = keys.poll();
+      List<AdaptationSet> adaptationSets, LinkedList<StreamKey> keys) {
+    StreamKey key = keys.poll();
     int periodIndex = key.periodIndex;
     ArrayList<AdaptationSet> copyAdaptationSets = new ArrayList<>();
     do {
-      int adaptationSetIndex = key.adaptationSetIndex;
+      int adaptationSetIndex = key.groupIndex;
       AdaptationSet adaptationSet = adaptationSets.get(adaptationSetIndex);
 
       List<Representation> representations = adaptationSet.representations;
       ArrayList<Representation> copyRepresentations = new ArrayList<>();
       do {
-        Representation representation = representations.get(key.representationIndex);
+        Representation representation = representations.get(key.trackIndex);
         copyRepresentations.add(representation);
         key = keys.poll();
-      } while(key.periodIndex == periodIndex && key.adaptationSetIndex == adaptationSetIndex);
+      } while (key.periodIndex == periodIndex && key.groupIndex == adaptationSetIndex);
 
       copyAdaptationSets.add(new AdaptationSet(adaptationSet.id, adaptationSet.type,
           copyRepresentations, adaptationSet.accessibilityDescriptors,
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 0a4274e674..f017ae64ad 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -18,7 +18,6 @@
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Base64;
-import android.util.Log;
 import android.util.Pair;
 import android.util.Xml;
 import com.google.android.exoplayer2.C;
@@ -34,6 +33,7 @@
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -120,6 +120,7 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
     long suggestedPresentationDelayMs = dynamic
         ? parseDuration(xpp, "suggestedPresentationDelay", C.TIME_UNSET) : C.TIME_UNSET;
     long publishTimeMs = parseDateTime(xpp, "publishTime", C.TIME_UNSET);
+    ProgramInformation programInformation = null;
     UtcTimingElement utcTiming = null;
     Uri location = null;
 
@@ -134,6 +135,8 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
           baseUrl = parseBaseUrl(xpp, baseUrl);
           seenFirstBaseUrl = true;
         }
+      } else if (XmlPullParserUtil.isStartTag(xpp, "ProgramInformation")) {
+        programInformation = parseProgramInformation(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "UTCTiming")) {
         utcTiming = parseUtcTiming(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "Location")) {
@@ -155,6 +158,8 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
               : (period.startMs + periodDurationMs);
           periods.add(period);
         }
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "MPD"));
 
@@ -171,18 +176,47 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
       throw new ParserException("No periods found.");
     }
 
-    return buildMediaPresentationDescription(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs,
-        publishTimeMs, utcTiming, location, periods);
+    return buildMediaPresentationDescription(
+        availabilityStartTime,
+        durationMs,
+        minBufferTimeMs,
+        dynamic,
+        minUpdateTimeMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        programInformation,
+        utcTiming,
+        location,
+        periods);
   }
 
-  protected DashManifest buildMediaPresentationDescription(long availabilityStartTime,
-      long durationMs, long minBufferTimeMs, boolean dynamic, long minUpdateTimeMs,
-      long timeShiftBufferDepthMs, long suggestedPresentationDelayMs, long publishTimeMs,
-      UtcTimingElement utcTiming, Uri location, List<Period> periods) {
-    return new DashManifest(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs,
-        publishTimeMs, utcTiming, location, periods);
+  protected DashManifest buildMediaPresentationDescription(
+      long availabilityStartTime,
+      long durationMs,
+      long minBufferTimeMs,
+      boolean dynamic,
+      long minUpdateTimeMs,
+      long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs,
+      long publishTimeMs,
+      ProgramInformation programInformation,
+      UtcTimingElement utcTiming,
+      Uri location,
+      List<Period> periods) {
+    return new DashManifest(
+        availabilityStartTime,
+        durationMs,
+        minBufferTimeMs,
+        dynamic,
+        minUpdateTimeMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        programInformation,
+        utcTiming,
+        location,
+        periods);
   }
 
   protected UtcTimingElement parseUtcTiming(XmlPullParser xpp) {
@@ -221,6 +255,8 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
         segmentBase = parseSegmentList(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, null);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Period"));
 
@@ -247,6 +283,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     int audioChannels = Format.NO_VALUE;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", Format.NO_VALUE);
     String language = xpp.getAttributeValue(null, "lang");
+    String label = xpp.getAttributeValue(null, "label");
     String drmSchemeType = null;
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
     ArrayList<Descriptor> inbandEventStreams = new ArrayList<>();
@@ -283,9 +320,22 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "SupplementalProperty")) {
         supplementalProperties.add(parseDescriptor(xpp, "SupplementalProperty"));
       } else if (XmlPullParserUtil.isStartTag(xpp, "Representation")) {
-        RepresentationInfo representationInfo = parseRepresentation(xpp, baseUrl, mimeType, codecs,
-            width, height, frameRate, audioChannels, audioSamplingRate, language,
-            selectionFlags, accessibilityDescriptors, segmentBase);
+        RepresentationInfo representationInfo =
+            parseRepresentation(
+                xpp,
+                baseUrl,
+                label,
+                mimeType,
+                codecs,
+                width,
+                height,
+                frameRate,
+                audioChannels,
+                audioSamplingRate,
+                language,
+                selectionFlags,
+                accessibilityDescriptors,
+                segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
         representationInfos.add(representationInfo);
@@ -355,6 +405,7 @@ protected int getContentType(Format format) {
   protected Pair<String, SchemeData> parseContentProtection(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     String schemeType = null;
+    String licenseServerUrl = null;
     byte[] data = null;
     UUID uuid = null;
     boolean requiresSecureDecoder = false;
@@ -364,7 +415,7 @@ protected int getContentType(Format format) {
       switch (Util.toLowerInvariant(schemeIdUri)) {
         case "urn:mpeg:dash:mp4protection:2011":
           schemeType = xpp.getAttributeValue(null, "value");
-          String defaultKid = xpp.getAttributeValue(null, "cenc:default_KID");
+          String defaultKid = XmlPullParserUtil.getAttributeValueIgnorePrefix(xpp, "default_KID");
           if (!TextUtils.isEmpty(defaultKid)
               && !"00000000-0000-0000-0000-000000000000".equals(defaultKid)) {
             String[] defaultKidStrings = defaultKid.split("\\s+");
@@ -389,28 +440,38 @@ protected int getContentType(Format format) {
 
     do {
       xpp.next();
-      if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
+      if (XmlPullParserUtil.isStartTag(xpp, "ms:laurl")) {
+        licenseServerUrl = xpp.getAttributeValue(null, "licenseUrl");
+      } else if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
         String robustnessLevel = xpp.getAttributeValue(null, "robustness_level");
         requiresSecureDecoder = robustnessLevel != null && robustnessLevel.startsWith("HW");
-      } else if (data == null) {
-        if (XmlPullParserUtil.isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
-          // The cenc:pssh element is defined in 23001-7:2015.
-          data = Base64.decode(xpp.getText(), Base64.DEFAULT);
-          uuid = PsshAtomUtil.parseUuid(data);
-          if (uuid == null) {
-            Log.w(TAG, "Skipping malformed cenc:pssh data");
-            data = null;
-          }
-        } else if (C.PLAYREADY_UUID.equals(uuid) && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
-            && xpp.next() == XmlPullParser.TEXT) {
-          // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
-          data = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID,
-              Base64.decode(xpp.getText(), Base64.DEFAULT));
+      } else if (data == null
+          && XmlPullParserUtil.isStartTagIgnorePrefix(xpp, "pssh")
+          && xpp.next() == XmlPullParser.TEXT) {
+        // The cenc:pssh element is defined in 23001-7:2015.
+        data = Base64.decode(xpp.getText(), Base64.DEFAULT);
+        uuid = PsshAtomUtil.parseUuid(data);
+        if (uuid == null) {
+          Log.w(TAG, "Skipping malformed cenc:pssh data");
+          data = null;
         }
+      } else if (data == null
+          && C.PLAYREADY_UUID.equals(uuid)
+          && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
+          && xpp.next() == XmlPullParser.TEXT) {
+        // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
+        data =
+            PsshAtomUtil.buildPsshAtom(
+                C.PLAYREADY_UUID, Base64.decode(xpp.getText(), Base64.DEFAULT));
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "ContentProtection"));
-    SchemeData schemeData = uuid != null
-        ? new SchemeData(uuid, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder) : null;
+    SchemeData schemeData =
+        uuid != null
+            ? new SchemeData(
+                uuid, licenseServerUrl, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder)
+            : null;
     return Pair.create(schemeType, schemeData);
   }
 
@@ -441,17 +502,26 @@ protected int parseRole(XmlPullParser xpp) throws XmlPullParserException, IOExce
    */
   protected void parseAdaptationSetChild(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
-    // pass
+    maybeSkipTag(xpp);
   }
 
   // Representation parsing.
 
-  protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseUrl,
-      String adaptationSetMimeType, String adaptationSetCodecs, int adaptationSetWidth,
-      int adaptationSetHeight, float adaptationSetFrameRate, int adaptationSetAudioChannels,
-      int adaptationSetAudioSamplingRate, String adaptationSetLanguage,
+  protected RepresentationInfo parseRepresentation(
+      XmlPullParser xpp,
+      String baseUrl,
+      String label,
+      String adaptationSetMimeType,
+      String adaptationSetCodecs,
+      int adaptationSetWidth,
+      int adaptationSetHeight,
+      float adaptationSetFrameRate,
+      int adaptationSetAudioChannels,
+      int adaptationSetAudioSamplingRate,
+      String adaptationSetLanguage,
       @C.SelectionFlags int adaptationSetSelectionFlags,
-      List<Descriptor> adaptationSetAccessibilityDescriptors, SegmentBase segmentBase)
+      List<Descriptor> adaptationSetAccessibilityDescriptors,
+      SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
     int bandwidth = parseInt(xpp, "bandwidth", Format.NO_VALUE);
@@ -496,33 +566,79 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
       } else if (XmlPullParserUtil.isStartTag(xpp, "SupplementalProperty")) {
         supplementalProperties.add(parseDescriptor(xpp, "SupplementalProperty"));
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Representation"));
 
-    Format format = buildFormat(id, mimeType, width, height, frameRate, audioChannels,
-        audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetSelectionFlags,
-        adaptationSetAccessibilityDescriptors, codecs, supplementalProperties);
+    Format format =
+        buildFormat(
+            id,
+            label,
+            mimeType,
+            width,
+            height,
+            frameRate,
+            audioChannels,
+            audioSamplingRate,
+            bandwidth,
+            adaptationSetLanguage,
+            adaptationSetSelectionFlags,
+            adaptationSetAccessibilityDescriptors,
+            codecs,
+            supplementalProperties);
     segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase();
 
     return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeType, drmSchemeDatas,
         inbandEventStreams, Representation.REVISION_ID_DEFAULT);
   }
 
-  protected Format buildFormat(String id, String containerMimeType, int width, int height,
-      float frameRate, int audioChannels, int audioSamplingRate, int bitrate, String language,
-      @C.SelectionFlags int selectionFlags, List<Descriptor> accessibilityDescriptors,
-      String codecs, List<Descriptor> supplementalProperties) {
+  protected Format buildFormat(
+      String id,
+      String label,
+      String containerMimeType,
+      int width,
+      int height,
+      float frameRate,
+      int audioChannels,
+      int audioSamplingRate,
+      int bitrate,
+      String language,
+      @C.SelectionFlags int selectionFlags,
+      List<Descriptor> accessibilityDescriptors,
+      String codecs,
+      List<Descriptor> supplementalProperties) {
     String sampleMimeType = getSampleMimeType(containerMimeType, codecs);
     if (sampleMimeType != null) {
       if (MimeTypes.AUDIO_E_AC3.equals(sampleMimeType)) {
         sampleMimeType = parseEac3SupplementalProperties(supplementalProperties);
       }
       if (MimeTypes.isVideo(sampleMimeType)) {
-        return Format.createVideoContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, width, height, frameRate, null, selectionFlags);
+        return Format.createVideoContainerFormat(
+            id,
+            label,
+            containerMimeType,
+            sampleMimeType,
+            codecs,
+            bitrate,
+            width,
+            height,
+            frameRate,
+            /* initializationData= */ null,
+            selectionFlags);
       } else if (MimeTypes.isAudio(sampleMimeType)) {
-        return Format.createAudioContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, audioChannels, audioSamplingRate, null, selectionFlags, language);
+        return Format.createAudioContainerFormat(
+            id,
+            label,
+            containerMimeType,
+            sampleMimeType,
+            codecs,
+            bitrate,
+            audioChannels,
+            audioSamplingRate,
+            /* initializationData= */ null,
+            selectionFlags,
+            language);
       } else if (mimeTypeIsRawText(sampleMimeType)) {
         int accessibilityChannel;
         if (MimeTypes.APPLICATION_CEA608.equals(sampleMimeType)) {
@@ -532,12 +648,20 @@ protected Format buildFormat(String id, String containerMimeType, int width, int
         } else {
           accessibilityChannel = Format.NO_VALUE;
         }
-        return Format.createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, selectionFlags, language, accessibilityChannel);
+        return Format.createTextContainerFormat(
+            id,
+            label,
+            containerMimeType,
+            sampleMimeType,
+            codecs,
+            bitrate,
+            selectionFlags,
+            language,
+            accessibilityChannel);
       }
     }
-    return Format.createContainerFormat(id, containerMimeType, sampleMimeType, codecs, bitrate,
-        selectionFlags, language);
+    return Format.createContainerFormat(
+        id, label, containerMimeType, sampleMimeType, codecs, bitrate, selectionFlags, language);
   }
 
   protected Representation buildRepresentation(RepresentationInfo representationInfo,
@@ -582,6 +706,8 @@ protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, SingleSegmentBas
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Initialization")) {
         initialization = parseInitialization(xpp);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentBase"));
 
@@ -619,6 +745,8 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, SegmentList parent)
           segments = new ArrayList<>();
         }
         segments.add(parseSegmentUrl(xpp));
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentList"));
 
@@ -665,6 +793,8 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
         initialization = parseInitialization(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTimeline")) {
         timeline = parseSegmentTimeline(xpp);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentTemplate"));
 
@@ -712,6 +842,8 @@ protected EventStream parseEventStream(XmlPullParser xpp)
         EventMessage event = parseEvent(xpp, schemeIdUri, value, timescale,
             scratchOutputStream);
         eventMessages.add(event);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "EventStream"));
 
@@ -756,8 +888,15 @@ protected EventMessage parseEvent(
     long durationMs = Util.scaleLargeTimestamp(duration, 1000, timescale);
     long presentationTimesUs = Util.scaleLargeTimestamp(presentationTime, C.MICROS_PER_SECOND,
         timescale);
+    String messageData = parseString(xpp, "messageData", null);
     byte[] eventObject = parseEventObject(xpp, scratchOutputStream);
-    return buildEvent(schemeIdUri, value, id, durationMs, eventObject, presentationTimesUs);
+    return buildEvent(
+        schemeIdUri,
+        value,
+        id,
+        durationMs,
+        messageData == null ? eventObject : Util.getUtf8Bytes(messageData),
+        presentationTimesUs);
   }
 
   /**
@@ -773,7 +912,7 @@ protected EventMessage parseEvent(
       throws XmlPullParserException, IOException {
     scratchOutputStream.reset();
     XmlSerializer xmlSerializer = Xml.newSerializer();
-    xmlSerializer.setOutput(scratchOutputStream, null);
+    xmlSerializer.setOutput(scratchOutputStream, C.UTF8_NAME);
     // Start reading everything between <Event> and </Event>, and serialize them into an Xml
     // byte array.
     xpp.nextToken();
@@ -843,6 +982,8 @@ protected EventMessage buildEvent(String schemeIdUri, String value, long id,
           segmentTimeline.add(buildSegmentTimelineElement(elapsedTime, duration));
           elapsedTime += duration;
         }
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentTimeline"));
     return segmentTimeline;
@@ -889,6 +1030,28 @@ protected RangedUri buildRangedUri(String urlText, long rangeStart, long rangeLe
     return new RangedUri(urlText, rangeStart, rangeLength);
   }
 
+  protected ProgramInformation parseProgramInformation(XmlPullParser xpp)
+      throws IOException, XmlPullParserException {
+    String title = null;
+    String source = null;
+    String copyright = null;
+    String moreInformationURL = parseString(xpp, "moreInformationURL", null);
+    String lang = parseString(xpp, "lang", null);
+    do {
+      xpp.next();
+      if (XmlPullParserUtil.isStartTag(xpp, "Title")) {
+        title = xpp.nextText();
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Source")) {
+        source = xpp.nextText();
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Copyright")) {
+        copyright = xpp.nextText();
+      } else {
+        maybeSkipTag(xpp);
+      }
+    } while (!XmlPullParserUtil.isEndTag(xpp, "ProgramInformation"));
+    return new ProgramInformation(title, source, copyright, moreInformationURL, lang);
+  }
+
   // AudioChannelConfiguration parsing.
 
   protected int parseAudioChannelConfiguration(XmlPullParser xpp)
@@ -906,6 +1069,29 @@ protected int parseAudioChannelConfiguration(XmlPullParser xpp)
 
   // Utility methods.
 
+  /**
+   * If the provided {@link XmlPullParser} is currently positioned at the start of a tag, skips
+   * forward to the end of that tag.
+   *
+   * @param xpp The {@link XmlPullParser}.
+   * @throws XmlPullParserException If an error occurs parsing the stream.
+   * @throws IOException If an error occurs reading the stream.
+   */
+  public static void maybeSkipTag(XmlPullParser xpp) throws IOException, XmlPullParserException {
+    if (!XmlPullParserUtil.isStartTag(xpp)) {
+      return;
+    }
+    int depth = 1;
+    while (depth != 0) {
+      xpp.next();
+      if (XmlPullParserUtil.isStartTag(xpp)) {
+        depth++;
+      } else if (XmlPullParserUtil.isEndTag(xpp)) {
+        depth--;
+      }
+    }
+  }
+
   /**
    * Removes unnecessary {@link SchemeData}s with null {@link SchemeData#data}.
    */
@@ -940,10 +1126,12 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
     } else if (mimeTypeIsRawText(containerMimeType)) {
       return containerMimeType;
     } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
-      if ("stpp".equals(codecs)) {
-        return MimeTypes.APPLICATION_TTML;
-      } else if ("wvtt".equals(codecs)) {
-        return MimeTypes.APPLICATION_MP4VTT;
+      if (codecs != null) {
+        if (codecs.startsWith("stpp")) {
+          return MimeTypes.APPLICATION_TTML;
+        } else if (codecs.startsWith("wvtt")) {
+          return MimeTypes.APPLICATION_MP4VTT;
+        }
       }
     } else if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
       if (codecs != null) {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
index bb1dbdac5d..b6f7ef0a3b 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
@@ -51,7 +51,7 @@
    * @param adaptationSets The adaptation sets belonging to the period.
    */
   public Period(@Nullable String id, long startMs, List<AdaptationSet> adaptationSets) {
-    this(id, startMs, adaptationSets, Collections.<EventStream>emptyList());
+    this(id, startMs, adaptationSets, Collections.emptyList());
   }
 
   /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
new file mode 100644
index 0000000000..e3072c86bd
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
+
+/** A parsed program information element. */
+public class ProgramInformation {
+  /** The title for the media presentation. */
+  public final String title;
+
+  /** Information about the original source of the media presentation. */
+  public final String source;
+
+  /** A copyright statement for the media presentation. */
+  public final String copyright;
+
+  /** A URL that provides more information about the media presentation. */
+  public final String moreInformationURL;
+
+  /** Declares the language code(s) for this ProgramInformation. */
+  public final String lang;
+
+  public ProgramInformation(
+      String title, String source, String copyright, String moreInformationURL, String lang) {
+    this.title = title;
+    this.source = source;
+    this.copyright = copyright;
+    this.moreInformationURL = moreInformationURL;
+    this.lang = lang;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ProgramInformation other = (ProgramInformation) obj;
+    return Util.areEqual(this.title, other.title)
+        && Util.areEqual(this.source, other.source)
+        && Util.areEqual(this.copyright, other.copyright)
+        && Util.areEqual(this.moreInformationURL, other.moreInformationURL)
+        && Util.areEqual(this.lang, other.lang);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (title != null ? title.hashCode() : 0);
+    result = 31 * result + (source != null ? source.hashCode() : 0);
+    result = 31 * result + (copyright != null ? copyright.hashCode() : 0);
+    result = 31 * result + (moreInformationURL != null ? moreInformationURL.hashCode() : 0);
+    result = 31 * result + (lang != null ? lang.hashCode() : 0);
+    return result;
+  }
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
index 71a3a0122c..44daa1d016 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
@@ -135,8 +135,10 @@ private Representation(String contentId, long revisionId, Format format, String
     this.revisionId = revisionId;
     this.format = format;
     this.baseUrl = baseUrl;
-    this.inbandEventStreams = inbandEventStreams == null ? Collections.<Descriptor>emptyList()
-        : Collections.unmodifiableList(inbandEventStreams);
+    this.inbandEventStreams =
+        inbandEventStreams == null
+            ? Collections.emptyList()
+            : Collections.unmodifiableList(inbandEventStreams);
     initializationUri = segmentBase.getInitialization(this);
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
deleted file mode 100644
index fd9488af55..0000000000
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.manifest;
-
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-/** Uniquely identifies a {@link Representation} in a {@link DashManifest}. */
-public final class RepresentationKey implements Comparable<RepresentationKey> {
-
-  public final int periodIndex;
-  public final int adaptationSetIndex;
-  public final int representationIndex;
-
-  public RepresentationKey(int periodIndex, int adaptationSetIndex, int representationIndex) {
-    this.periodIndex = periodIndex;
-    this.adaptationSetIndex = adaptationSetIndex;
-    this.representationIndex = representationIndex;
-  }
-
-  @Override
-  public String toString() {
-    return periodIndex + "." + adaptationSetIndex + "." + representationIndex;
-  }
-
-  @Override
-  public boolean equals(@Nullable Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (o == null || getClass() != o.getClass()) {
-      return false;
-    }
-
-    RepresentationKey that = (RepresentationKey) o;
-    return periodIndex == that.periodIndex
-        && adaptationSetIndex == that.adaptationSetIndex
-        && representationIndex == that.representationIndex;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = periodIndex;
-    result = 31 * result + adaptationSetIndex;
-    result = 31 * result + representationIndex;
-    return result;
-  }
-
-  // Comparable implementation.
-
-  @Override
-  public int compareTo(@NonNull RepresentationKey o) {
-    int result = periodIndex - o.periodIndex;
-    if (result == 0) {
-      result = adaptationSetIndex - o.adaptationSetIndex;
-      if (result == 0) {
-        result = representationIndex - o.representationIndex;
-      }
-    }
-    return result;
-  }
-
-}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java
index c2facd9626..f36a018e5b 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java
@@ -20,55 +20,65 @@
 import com.google.android.exoplayer2.offline.DownloadAction;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.SegmentDownloadAction;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
+import com.google.android.exoplayer2.offline.StreamKey;
+import java.util.Collections;
 import java.util.List;
 
 /** An action to download or remove downloaded DASH streams. */
-public final class DashDownloadAction extends SegmentDownloadAction<RepresentationKey> {
+public final class DashDownloadAction extends SegmentDownloadAction {
 
   private static final String TYPE = "dash";
   private static final int VERSION = 0;
 
   public static final Deserializer DESERIALIZER =
-      new SegmentDownloadActionDeserializer<RepresentationKey>(TYPE, VERSION) {
-
-        @Override
-        protected RepresentationKey readKey(DataInputStream input) throws IOException {
-          return new RepresentationKey(input.readInt(), input.readInt(), input.readInt());
-        }
-
+      new SegmentDownloadActionDeserializer(TYPE, VERSION) {
         @Override
         protected DownloadAction createDownloadAction(
-            Uri uri, boolean isRemoveAction, byte[] data, List<RepresentationKey> keys) {
+            Uri uri, boolean isRemoveAction, byte[] data, List<StreamKey> keys) {
           return new DashDownloadAction(uri, isRemoveAction, data, keys);
         }
       };
 
+  /**
+   * Creates a DASH download action.
+   *
+   * @param uri The URI of the media to be downloaded.
+   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
+   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded.
+   */
+  public static DashDownloadAction createDownloadAction(
+      Uri uri, @Nullable byte[] data, List<StreamKey> keys) {
+    return new DashDownloadAction(uri, /* isRemoveAction= */ false, data, keys);
+  }
+
+  /**
+   * Creates a DASH remove action.
+   *
+   * @param uri The URI of the media to be removed.
+   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
+   */
+  public static DashDownloadAction createRemoveAction(Uri uri, @Nullable byte[] data) {
+    return new DashDownloadAction(uri, /* isRemoveAction= */ true, data, Collections.emptyList());
+  }
+
   /**
    * @param uri The DASH manifest URI.
    * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
    * @param data Optional custom data for this action.
    * @param keys Keys of representations to be downloaded. If empty, all representations are
    *     downloaded. If {@code removeAction} is true, {@code keys} must be empty.
+   * @deprecated Use {@link #createDownloadAction(Uri, byte[], List)} or {@link
+   *     #createRemoveAction(Uri, byte[])}.
    */
+  @Deprecated
   public DashDownloadAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<RepresentationKey> keys) {
+      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<StreamKey> keys) {
     super(TYPE, VERSION, uri, isRemoveAction, data, keys);
   }
 
   @Override
-  protected DashDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
+  public DashDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
     return new DashDownloader(uri, keys, constructorHelper);
   }
 
-  @Override
-  protected void writeKey(DataOutputStream output, RepresentationKey key) throws IOException {
-    output.writeInt(key.periodIndex);
-    output.writeInt(key.adaptationSetIndex);
-    output.writeInt(key.representationIndex);
-  }
-
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java
index bd19ff6587..91e41b9ded 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java
@@ -17,8 +17,10 @@
 
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.offline.TrackKey;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -26,13 +28,11 @@
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
@@ -51,9 +51,9 @@ public DashDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory)
 
   @Override
   protected void prepareInternal() throws IOException {
+    DataSource dataSource = manifestDataSourceFactory.createDataSource();
     manifest =
-        ParsingLoadable.load(
-            manifestDataSourceFactory.createDataSource(), new DashManifestParser(), uri);
+        ParsingLoadable.load(dataSource, new DashManifestParser(), uri, C.DATA_TYPE_MANIFEST);
   }
 
   /** Returns the DASH manifest. Must not be called until after preparation completes. */
@@ -87,23 +87,20 @@ public TrackGroupArray getTrackGroups(int periodIndex) {
 
   @Override
   public DashDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    return new DashDownloadAction(
-        uri, /* isRemoveAction= */ false, data, toRepresentationKeys(trackKeys));
+    return DashDownloadAction.createDownloadAction(uri, data, toStreamKeys(trackKeys));
   }
 
   @Override
   public DashDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return new DashDownloadAction(
-        uri, /* isRemoveAction= */ true, data, Collections.<RepresentationKey>emptyList());
+    return DashDownloadAction.createRemoveAction(uri, data);
   }
 
-  private static List<RepresentationKey> toRepresentationKeys(List<TrackKey> trackKeys) {
-    List<RepresentationKey> representationKeys = new ArrayList<>(trackKeys.size());
+  private static List<StreamKey> toStreamKeys(List<TrackKey> trackKeys) {
+    List<StreamKey> streamKeys = new ArrayList<>(trackKeys.size());
     for (int i = 0; i < trackKeys.size(); i++) {
       TrackKey trackKey = trackKeys.get(i);
-      representationKeys.add(
-          new RepresentationKey(trackKey.periodIndex, trackKey.groupIndex, trackKey.trackIndex));
+      streamKeys.add(new StreamKey(trackKey.periodIndex, trackKey.groupIndex, trackKey.trackIndex));
     }
-    return representationKeys;
+    return streamKeys;
   }
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
index 8762244558..68120d6177 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.offline.DownloadException;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.SegmentDownloader;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.dash.DashSegmentIndex;
 import com.google.android.exoplayer2.source.dash.DashUtil;
 import com.google.android.exoplayer2.source.dash.DashWrappingSegmentIndex;
@@ -30,7 +31,6 @@
 import com.google.android.exoplayer2.source.dash.manifest.Period;
 import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.IOException;
@@ -51,9 +51,7 @@
  * // period.
  * DashDownloader dashDownloader =
  *     new DashDownloader(
- *         manifestUrl,
- *         Collections.singletonList(new RepresentationKey(0, 0, 0)),
- *         constructorHelper);
+ *         manifestUrl, Collections.singletonList(new StreamKey(0, 0, 0)), constructorHelper);
  * // Perform the download.
  * dashDownloader.download();
  * // Access downloaded data using CacheDataSource
@@ -61,19 +59,17 @@
  *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
  * }</pre>
  */
-public final class DashDownloader extends SegmentDownloader<DashManifest, RepresentationKey> {
+public final class DashDownloader extends SegmentDownloader<DashManifest> {
 
   /**
    * @param manifestUri The {@link Uri} of the manifest to be downloaded.
-   * @param representationKeys Keys defining which representations in the manifest should be
-   *     selected for download. If empty, all representations are downloaded.
+   * @param streamKeys Keys defining which representations in the manifest should be selected for
+   *     download. If empty, all representations are downloaded.
    * @param constructorHelper A {@link DownloaderConstructorHelper} instance.
    */
   public DashDownloader(
-      Uri manifestUri,
-      List<RepresentationKey> representationKeys,
-      DownloaderConstructorHelper constructorHelper) {
-    super(manifestUri, representationKeys, constructorHelper);
+      Uri manifestUri, List<StreamKey> streamKeys, DownloaderConstructorHelper constructorHelper) {
+    super(manifestUri, streamKeys, constructorHelper);
   }
 
   @Override
diff --git a/library/dash/src/test/assets/sample_mpd_1 b/library/dash/src/test/assets/sample_mpd_1
index 07bcdd4f50..ccd3ab4dd6 100644
--- a/library/dash/src/test/assets/sample_mpd_1
+++ b/library/dash/src/test/assets/sample_mpd_1
@@ -9,6 +9,12 @@
     xmlns="urn:mpeg:DASH:schema:MPD:2011"
     xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"
     yt:earliestMediaSequence="1266404" >
+    <ProgramInformation lang="enUs"
+        moreInformationURL="www.example.com">
+        <Title>MediaTitle</Title>
+        <Source>MediaSource</Source>
+        <Copyright>MediaCopyright</Copyright>
+    </ProgramInformation>
     <Period start="PT6462826.784S" >
         <SegmentList
             presentationTimeOffset="34740095"
diff --git a/library/dash/src/test/assets/sample_mpd_4_event_stream b/library/dash/src/test/assets/sample_mpd_4_event_stream
index cf96541ca0..e4c927260d 100644
--- a/library/dash/src/test/assets/sample_mpd_4_event_stream
+++ b/library/dash/src/test/assets/sample_mpd_4_event_stream
@@ -2,7 +2,7 @@
 <MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:mpeg:DASH:schema:MPD:2011" xmlns:yt="http://youtube.com/yt/2012/10/10" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd" minBufferTime="PT1.500S" profiles="urn:mpeg:dash:profile:isoff-main:2011" type="dynamic" availabilityStartTime="2016-10-14T17:00:17" timeShiftBufferDepth="PT7200.000S" minimumUpdatePeriod="PT2.000S" yt:earliestMediaSequence="0" yt:mpdRequestTime="2016-10-14T18:29:17.082" yt:mpdResponseTime="2016-10-14T18:29:17.194">
  <Period start="PT0.000S" yt:segmentIngestTime="2016-10-14T17:00:14.257">
    <EventStream schemeIdUri="urn:uuid:XYZY" timescale="1000" value="call">
-     <Event presentationTime="0" duration="10000" id="0">+ 1 800 10101010</Event>
+     <Event presentationTime="0" duration="10000" id="0" messageData="+ 1 800 10101010"/>
    </EventStream>
    <EventStream schemeIdUri="urn:dvb:iptv:cpm:2014">
      <Event presentationTime="300" duration="1500" id="1"><![CDATA[<BroadcastEvent>
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
index 15fa3b3355..c09c765d83 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
@@ -76,15 +76,16 @@ private static Representation newRepresentations(DrmInitData drmInitData) {
     Format format =
         Format.createVideoContainerFormat(
             "id",
+            "label",
             MimeTypes.VIDEO_MP4,
             MimeTypes.VIDEO_H264,
-            "",
+            /* codecs= */ "",
             Format.NO_VALUE,
-            1024,
-            768,
+            /* width= */ 1024,
+            /* height= */ 768,
             Format.NO_VALUE,
-            null,
-            0);
+            /* initializationData= */ null,
+            /* selectionFlags= */ 0);
     if (drmInitData != null) {
       format = format.copyWithDrmInitData(drmInitData);
     }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index 6f14c8790f..a1693f6985 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.util.Collections;
@@ -117,7 +118,8 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
                 "",
                 1500000,
                 1,
-                ("<![CDATA[<BroadcastEvent>\n"
+                Util.getUtf8Bytes(
+                    "<![CDATA[<BroadcastEvent>\n"
                         + "      <Program crid=\"crid://broadcaster.example.com/ABCDEF\"/>\n"
                         + "      <InstanceDescription>\n"
                         + "      <Title xml:lang=\"en\">The title</Title>\n"
@@ -128,8 +130,7 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
                         + "      <mpeg7:Region>GB</mpeg7:Region>\n"
                         + "      </ParentalGuidance>\n"
                         + "      </InstanceDescription>\n"
-                        + "      </BroadcastEvent>]]>")
-                    .getBytes(),
+                        + "      </BroadcastEvent>]]>"),
                 300000000));
 
     // assert xml-structured event stream
@@ -142,15 +143,28 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
                 "",
                 1000000,
                 2,
-                ("<scte35:Signal>\n"
+                Util.getUtf8Bytes(
+                    "<scte35:Signal>\n"
                         + "         <scte35:Binary>\n"
                         + "         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==\n"
                         + "         </scte35:Binary>\n"
-                        + "       </scte35:Signal>")
-                    .getBytes(),
+                        + "       </scte35:Signal>"),
                 1000000000));
   }
 
+  @Test
+  public void testParseMediaPresentationDescriptionCanParseProgramInformation() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    DashManifest mpd =
+        parser.parse(
+            Uri.parse("Https://example.com/test.mpd"),
+            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_1));
+    ProgramInformation expectedProgramInformation =
+        new ProgramInformation(
+            "MediaTitle", "MediaSource", "MediaCopyright", "www.example.com", "enUs");
+    assertThat(mpd.programInformation).isEqualTo(expectedProgramInformation);
+  }
+
   @Test
   public void testParseCea608AccessibilityChannel() {
     assertThat(
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
index 9cf3594116..0d08df42e9 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
@@ -19,6 +19,7 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
 import java.util.Arrays;
 import java.util.Collections;
@@ -58,17 +59,17 @@ public void testCopy() throws Exception {
                 newAdaptationSet(8, representations[2][0]),
                 newAdaptationSet(9, representations[2][1])));
 
-    List<RepresentationKey> keys =
+    List<StreamKey> keys =
         Arrays.asList(
-            new RepresentationKey(0, 0, 0),
-            new RepresentationKey(0, 0, 1),
-            new RepresentationKey(0, 1, 2),
-            new RepresentationKey(1, 0, 1),
-            new RepresentationKey(1, 1, 0),
-            new RepresentationKey(1, 1, 2),
-            new RepresentationKey(2, 0, 1),
-            new RepresentationKey(2, 0, 2),
-            new RepresentationKey(2, 1, 0));
+            new StreamKey(0, 0, 0),
+            new StreamKey(0, 0, 1),
+            new StreamKey(0, 1, 2),
+            new StreamKey(1, 0, 1),
+            new StreamKey(1, 1, 0),
+            new StreamKey(1, 1, 2),
+            new StreamKey(2, 0, 1),
+            new StreamKey(2, 0, 2),
+            new StreamKey(2, 1, 0));
     // Keys don't need to be in any particular order
     Collections.shuffle(keys, new Random(0));
 
@@ -105,8 +106,7 @@ public void testCopySameAdaptationIndexButDifferentPeriod() throws Exception {
             newPeriod("4", 4, newAdaptationSet(5, representations[1][0])));
 
     DashManifest copyManifest =
-        sourceManifest.copy(
-            Arrays.asList(new RepresentationKey(0, 0, 0), new RepresentationKey(1, 0, 0)));
+        sourceManifest.copy(Arrays.asList(new StreamKey(0, 0, 0), new StreamKey(1, 0, 0)));
 
     DashManifest expectedManifest =
         newDashManifest(
@@ -141,12 +141,12 @@ public void testCopySkipPeriod() throws Exception {
     DashManifest copyManifest =
         sourceManifest.copy(
             Arrays.asList(
-                new RepresentationKey(0, 0, 0),
-                new RepresentationKey(0, 0, 1),
-                new RepresentationKey(0, 1, 2),
-                new RepresentationKey(2, 0, 1),
-                new RepresentationKey(2, 0, 2),
-                new RepresentationKey(2, 1, 0)));
+                new StreamKey(0, 0, 0),
+                new StreamKey(0, 0, 1),
+                new StreamKey(0, 1, 2),
+                new StreamKey(2, 0, 1),
+                new StreamKey(2, 0, 2),
+                new StreamKey(2, 1, 0)));
 
     DashManifest expectedManifest =
         newDashManifest(
@@ -219,7 +219,18 @@ private static Representation newRepresentation() {
 
   private static DashManifest newDashManifest(int duration, Period... periods) {
     return new DashManifest(
-        0, duration, 1, false, 2, 3, 4, 12345, DUMMY_UTC_TIMING, Uri.EMPTY, Arrays.asList(periods));
+        /* availabilityStartTimeMs= */ 0,
+        duration,
+        /* minBufferTimeMs= */ 1,
+        /* dynamic= */ false,
+        /* minUpdatePeriodMs= */ 2,
+        /* timeShiftBufferDepthMs= */ 3,
+        /* suggestedPresentationDelayMs= */ 4,
+        /* publishTimeMs= */ 12345,
+        /* programInformation= */ null,
+        DUMMY_UTC_TIMING,
+        Uri.EMPTY,
+        Arrays.asList(periods));
   }
 
   private static Period newPeriod(String id, int startMs, AdaptationSet... adaptationSets) {
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
index 309e6c8eb0..12c0b9239e 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
@@ -32,37 +32,30 @@
   public void testGetCacheKey() {
     String uri = "http://www.google.com";
     SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
-    Format format =
-        Format.createVideoContainerFormat(
-            "0",
-            MimeTypes.APPLICATION_MP4,
-            null,
-            MimeTypes.VIDEO_H264,
-            2500000,
-            1920,
-            1080,
-            Format.NO_VALUE,
-            null,
-            0);
+    Format format = createVideoContainerFormat("0");
     Representation representation =
         Representation.newInstance("test_stream_1", 3, format, uri, base);
     assertThat(representation.getCacheKey()).isEqualTo("test_stream_1.0.3");
 
-    format =
-        Format.createVideoContainerFormat(
-            "150",
-            MimeTypes.APPLICATION_MP4,
-            null,
-            MimeTypes.VIDEO_H264,
-            2500000,
-            1920,
-            1080,
-            Format.NO_VALUE,
-            null,
-            0);
+    format = createVideoContainerFormat("150");
     representation =
         Representation.newInstance(
             "test_stream_1", Representation.REVISION_ID_DEFAULT, format, uri, base);
     assertThat(representation.getCacheKey()).isEqualTo("test_stream_1.150.-1");
   }
+
+  private static Format createVideoContainerFormat(String id) {
+    return Format.createVideoContainerFormat(
+        id,
+        "label",
+        /* containerMimeType= */ MimeTypes.APPLICATION_MP4,
+        /* sampleMimeType= */ MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        /* bitrate= */ 2500000,
+        /* width= */ 1920,
+        /* height= */ 1080,
+        /* frameRate= */ Format.NO_VALUE,
+        /* initializationData= */ null,
+        /* selectionFlags= */ 0);
+  }
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java
index 43d9bd9965..0ebf6bb628 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java
@@ -18,10 +18,9 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.offline.DownloadAction;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import java.io.ByteArrayInputStream;
@@ -38,9 +37,7 @@
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link DashDownloadAction}.
- */
+/** Unit tests for {@link DashDownloadAction}. */
 @RunWith(RobolectricTestRunner.class)
 public class DashDownloadActionTest {
 
@@ -55,134 +52,106 @@ public void setUp() {
 
   @Test
   public void testDownloadActionIsNotRemoveAction() {
-    DashDownloadAction action = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
+    DownloadAction action = createDownloadAction(uri1);
     assertThat(action.isRemoveAction).isFalse();
   }
 
   @Test
-  public void testRemoveActionisRemoveAction() {
-    DashDownloadAction action2 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
+  public void testRemoveActionIsRemoveAction() {
+    DownloadAction action2 = createRemoveAction(uri1);
     assertThat(action2.isRemoveAction).isTrue();
   }
 
   @Test
   public void testCreateDownloader() {
     MockitoAnnotations.initMocks(this);
-    DashDownloadAction action = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
-    DownloaderConstructorHelper constructorHelper = new DownloaderConstructorHelper(
-        Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    DownloadAction action = createDownloadAction(uri1);
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
     assertThat(action.createDownloader(constructorHelper)).isNotNull();
   }
 
   @Test
   public void testSameUriDifferentAction_IsSameMedia() {
-    DashDownloadAction action1 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
-    DashDownloadAction action2 = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
+    DownloadAction action1 = createRemoveAction(uri1);
+    DownloadAction action2 = createDownloadAction(uri1);
     assertThat(action1.isSameMedia(action2)).isTrue();
   }
 
   @Test
   public void testDifferentUriAndAction_IsNotSameMedia() {
-    DashDownloadAction action3 = newAction(uri2, /* isRemoveAction= */ true, /* data= */ null);
-    DashDownloadAction action4 = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
+    DownloadAction action3 = createRemoveAction(uri2);
+    DownloadAction action4 = createDownloadAction(uri1);
     assertThat(action3.isSameMedia(action4)).isFalse();
   }
 
   @SuppressWarnings("EqualsWithItself")
   @Test
   public void testEquals() {
-    DashDownloadAction action1 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
+    DownloadAction action1 = createRemoveAction(uri1);
     assertThat(action1.equals(action1)).isTrue();
 
-    DashDownloadAction action2 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
-    DashDownloadAction action3 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
+    DownloadAction action2 = createRemoveAction(uri1);
+    DownloadAction action3 = createRemoveAction(uri1);
     assertEqual(action2, action3);
 
-    DashDownloadAction action4 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
-    DashDownloadAction action5 = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
+    DownloadAction action4 = createRemoveAction(uri1);
+    DownloadAction action5 = createDownloadAction(uri1);
     assertNotEqual(action4, action5);
 
-    DashDownloadAction action6 = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
-    DashDownloadAction action7 =
-        newAction(
-            uri1, /* isRemoveAction= */ false, /* data= */ null, new RepresentationKey(0, 0, 0));
+    DownloadAction action6 = createDownloadAction(uri1);
+    DownloadAction action7 = createDownloadAction(uri1, new StreamKey(0, 0, 0));
     assertNotEqual(action6, action7);
 
-    DashDownloadAction action8 =
-        newAction(
-            uri1, /* isRemoveAction= */ false, /* data= */ null, new RepresentationKey(1, 1, 1));
-    DashDownloadAction action9 =
-        newAction(
-            uri1, /* isRemoveAction= */ false, /* data= */ null, new RepresentationKey(0, 0, 0));
+    DownloadAction action8 = createDownloadAction(uri1, new StreamKey(1, 1, 1));
+    DownloadAction action9 = createDownloadAction(uri1, new StreamKey(0, 0, 0));
     assertNotEqual(action8, action9);
 
-    DashDownloadAction action10 = newAction(uri1, /* isRemoveAction= */ true, /* data= */ null);
-    DashDownloadAction action11 = newAction(uri2, /* isRemoveAction= */ true, /* data= */ null);
+    DownloadAction action10 = createRemoveAction(uri1);
+    DownloadAction action11 = createRemoveAction(uri2);
     assertNotEqual(action10, action11);
 
-    DashDownloadAction action12 =
-        newAction(
-            uri1,
-            /* isRemoveAction= */ false,
-            /* data= */ null,
-            new RepresentationKey(0, 0, 0),
-            new RepresentationKey(1, 1, 1));
-    DashDownloadAction action13 =
-        newAction(
-            uri1,
-            /* isRemoveAction= */ false,
-            /* data= */ null,
-            new RepresentationKey(1, 1, 1),
-            new RepresentationKey(0, 0, 0));
+    DownloadAction action12 =
+        createDownloadAction(uri1, new StreamKey(0, 0, 0), new StreamKey(1, 1, 1));
+    DownloadAction action13 =
+        createDownloadAction(uri1, new StreamKey(1, 1, 1), new StreamKey(0, 0, 0));
     assertEqual(action12, action13);
 
-    DashDownloadAction action14 =
-        newAction(
-            uri1, /* isRemoveAction= */ false, /* data= */ null, new RepresentationKey(0, 0, 0));
-    DashDownloadAction action15 =
-        newAction(
-            uri1,
-            /* isRemoveAction= */ false,
-            /* data= */ null,
-            new RepresentationKey(1, 1, 1),
-            new RepresentationKey(0, 0, 0));
+    DownloadAction action14 = createDownloadAction(uri1, new StreamKey(0, 0, 0));
+    DownloadAction action15 =
+        createDownloadAction(uri1, new StreamKey(1, 1, 1), new StreamKey(0, 0, 0));
     assertNotEqual(action14, action15);
 
-    DashDownloadAction action16 = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
-    DashDownloadAction action17 = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
+    DownloadAction action16 = createDownloadAction(uri1);
+    DownloadAction action17 = createDownloadAction(uri1);
     assertEqual(action16, action17);
   }
 
   @Test
   public void testSerializerGetType() {
-    DashDownloadAction action = newAction(uri1, /* isRemoveAction= */ false, /* data= */ null);
+    DownloadAction action = createDownloadAction(uri1);
     assertThat(action.type).isNotNull();
   }
 
   @Test
   public void testSerializerWriteRead() throws Exception {
-    doTestSerializationRoundTrip(newAction(uri1, /* isRemoveAction= */ false, /* data= */ null));
-    doTestSerializationRoundTrip(newAction(uri1, /* isRemoveAction= */ true, /* data= */ null));
+    doTestSerializationRoundTrip(createDownloadAction(uri1));
+    doTestSerializationRoundTrip(createRemoveAction(uri1));
     doTestSerializationRoundTrip(
-        newAction(
-            uri2,
-            /* isRemoveAction= */ false,
-            /* data= */ null,
-            new RepresentationKey(0, 0, 0),
-            new RepresentationKey(1, 1, 1)));
+        createDownloadAction(uri2, new StreamKey(0, 0, 0), new StreamKey(1, 1, 1)));
   }
 
-  private static void assertNotEqual(DashDownloadAction action1, DashDownloadAction action2) {
+  private static void assertNotEqual(DownloadAction action1, DownloadAction action2) {
     assertThat(action1).isNotEqualTo(action2);
     assertThat(action2).isNotEqualTo(action1);
   }
 
-  private static void assertEqual(DashDownloadAction action1, DashDownloadAction action2) {
+  private static void assertEqual(DownloadAction action1, DownloadAction action2) {
     assertThat(action1).isEqualTo(action2);
     assertThat(action2).isEqualTo(action1);
   }
 
-  private static void doTestSerializationRoundTrip(DashDownloadAction action) throws IOException {
+  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream output = new DataOutputStream(out);
     DownloadAction.serializeToStream(action, output);
@@ -196,10 +165,13 @@ private static void doTestSerializationRoundTrip(DashDownloadAction action) thro
     assertThat(action).isEqualTo(action2);
   }
 
-  private static DashDownloadAction newAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, RepresentationKey... keys) {
-    ArrayList<RepresentationKey> keysList = new ArrayList<>();
+  private static DownloadAction createDownloadAction(Uri uri, StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
     Collections.addAll(keysList, keys);
-    return new DashDownloadAction(uri, isRemoveAction, data, keysList);
+    return DashDownloadAction.createDownloadAction(uri, null, keysList);
+  }
+
+  private static DownloadAction createRemoveAction(Uri uri) {
+    return DashDownloadAction.createRemoveAction(uri, null);
   }
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
index 4c96357528..a597d780e0 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
@@ -27,7 +27,7 @@
 
 import com.google.android.exoplayer2.offline.DownloadException;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
@@ -77,7 +77,7 @@ public void testDownloadRepresentation() throws Exception {
             .setRandomData("audio_segment_2", 5)
             .setRandomData("audio_segment_3", 6);
 
-    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new RepresentationKey(0, 0, 0));
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download();
     assertCachedData(cache, fakeDataSet);
   }
@@ -96,7 +96,7 @@ public void testDownloadRepresentationInSmallParts() throws Exception {
             .setRandomData("audio_segment_2", 5)
             .setRandomData("audio_segment_3", 6);
 
-    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new RepresentationKey(0, 0, 0));
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download();
     assertCachedData(cache, fakeDataSet);
   }
@@ -115,8 +115,7 @@ public void testDownloadRepresentations() throws Exception {
             .setRandomData("text_segment_3", 3);
 
     DashDownloader dashDownloader =
-        getDashDownloader(
-            fakeDataSet, new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0));
+        getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
     dashDownloader.download();
     assertCachedData(cache, fakeDataSet);
   }
@@ -159,7 +158,7 @@ public void testProgressiveDownload() throws Exception {
     when(factory.createDataSource()).thenReturn(fakeDataSource);
 
     DashDownloader dashDownloader =
-        getDashDownloader(factory, new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0));
+        getDashDownloader(factory, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
     dashDownloader.download();
 
     DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
@@ -191,7 +190,7 @@ public void testProgressiveDownloadSeparatePeriods() throws Exception {
     when(factory.createDataSource()).thenReturn(fakeDataSource);
 
     DashDownloader dashDownloader =
-        getDashDownloader(factory, new RepresentationKey(0, 0, 0), new RepresentationKey(1, 0, 0));
+        getDashDownloader(factory, new StreamKey(0, 0, 0), new StreamKey(1, 0, 0));
     dashDownloader.download();
 
     DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
@@ -220,7 +219,7 @@ public void testDownloadRepresentationFailure() throws Exception {
             .endData()
             .setRandomData("audio_segment_3", 6);
 
-    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new RepresentationKey(0, 0, 0));
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     try {
       dashDownloader.download();
       fail();
@@ -245,7 +244,7 @@ public void testCounters() throws Exception {
             .endData()
             .setRandomData("audio_segment_3", 6);
 
-    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new RepresentationKey(0, 0, 0));
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     assertThat(dashDownloader.getDownloadedBytes()).isEqualTo(0);
 
     try {
@@ -274,8 +273,7 @@ public void testRemove() throws Exception {
             .setRandomData("text_segment_3", 3);
 
     DashDownloader dashDownloader =
-        getDashDownloader(
-            fakeDataSet, new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0));
+        getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
     dashDownloader.download();
     dashDownloader.remove();
     assertCacheEmpty(cache);
@@ -288,7 +286,7 @@ public void testRepresentationWithoutIndex() throws Exception {
             .setData(TEST_MPD_URI, TEST_MPD_NO_INDEX)
             .setRandomData("test_segment_1", 4);
 
-    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new RepresentationKey(0, 0, 0));
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     try {
       dashDownloader.download();
       fail();
@@ -299,17 +297,17 @@ public void testRepresentationWithoutIndex() throws Exception {
     assertCacheEmpty(cache);
   }
 
-  private DashDownloader getDashDownloader(FakeDataSet fakeDataSet, RepresentationKey... keys) {
-    return getDashDownloader(new Factory(null).setFakeDataSet(fakeDataSet), keys);
+  private DashDownloader getDashDownloader(FakeDataSet fakeDataSet, StreamKey... keys) {
+    return getDashDownloader(new Factory().setFakeDataSet(fakeDataSet), keys);
   }
 
-  private DashDownloader getDashDownloader(Factory factory, RepresentationKey... keys) {
+  private DashDownloader getDashDownloader(Factory factory, StreamKey... keys) {
     return new DashDownloader(
         TEST_MPD_URI, keysList(keys), new DownloaderConstructorHelper(cache, factory));
   }
 
-  private static ArrayList<RepresentationKey> keysList(RepresentationKey... keys) {
-    ArrayList<RepresentationKey> keysList = new ArrayList<>();
+  private static ArrayList<StreamKey> keysList(StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
     Collections.addAll(keysList, keys);
     return keysList;
   }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
index 8ca2aa083b..88d4ed6a9d 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
@@ -25,9 +25,10 @@
 import android.net.Uri;
 import android.os.ConditionVariable;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.offline.DownloadAction;
 import com.google.android.exoplayer2.offline.DownloadManager;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
@@ -62,8 +63,8 @@
   private File tempFolder;
   private FakeDataSet fakeDataSet;
   private DownloadManager downloadManager;
-  private RepresentationKey fakeRepresentationKey1;
-  private RepresentationKey fakeRepresentationKey2;
+  private StreamKey fakeStreamKey1;
+  private StreamKey fakeStreamKey2;
   private TestDownloadManagerListener downloadManagerListener;
   private File actionFile;
   private DummyMainThread dummyMainThread;
@@ -88,8 +89,8 @@ public void setUp() throws Exception {
             .setRandomData("text_segment_2", 2)
             .setRandomData("text_segment_3", 3);
 
-    fakeRepresentationKey1 = new RepresentationKey(0, 0, 0);
-    fakeRepresentationKey2 = new RepresentationKey(0, 1, 0);
+    fakeStreamKey1 = new StreamKey(0, 0, 0);
+    fakeStreamKey2 = new StreamKey(0, 1, 0);
     actionFile = new File(tempFolder, "actionFile");
     createDownloadManager();
   }
@@ -109,18 +110,14 @@ public void testSaveAndLoadActionFile() throws Throwable {
     fakeDataSet
         .newData(TEST_MPD_URI)
         .appendReadAction(
-            new Runnable() {
-              @SuppressWarnings("InfiniteLoopStatement")
-              @Override
-              public void run() {
-                try {
-                  // Wait until interrupted.
-                  while (true) {
-                    Thread.sleep(100000);
-                  }
-                } catch (InterruptedException ignored) {
-                  Thread.currentThread().interrupt();
+            () -> {
+              try {
+                // Wait until interrupted.
+                while (true) {
+                  Thread.sleep(100000);
                 }
+              } catch (InterruptedException ignored) {
+                Thread.currentThread().interrupt();
               }
             })
         .appendReadData(TEST_MPD)
@@ -129,13 +126,10 @@ public void run() {
     // Run DM accessing code on UI/main thread as it should be. Also not to block handling of loaded
     // actions.
     dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            // Setup an Action and immediately release the DM.
-            handleDownloadAction(fakeRepresentationKey1, fakeRepresentationKey2);
-            downloadManager.release();
-          }
+        () -> {
+          // Setup an Action and immediately release the DM.
+          handleDownloadAction(fakeStreamKey1, fakeStreamKey2);
+          downloadManager.release();
         });
 
     assertThat(actionFile.exists()).isTrue();
@@ -145,13 +139,7 @@ public void run() {
     // Revert fakeDataSet to normal.
     fakeDataSet.setData(TEST_MPD_URI, TEST_MPD);
 
-    dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            createDownloadManager();
-          }
-        });
+    dummyMainThread.runOnMainThread(this::createDownloadManager);
 
     // Block on the test thread.
     blockUntilTasksCompleteAndThrowAnyDownloadError();
@@ -160,15 +148,15 @@ public void run() {
 
   @Test
   public void testHandleDownloadAction() throws Throwable {
-    handleDownloadAction(fakeRepresentationKey1, fakeRepresentationKey2);
+    handleDownloadAction(fakeStreamKey1, fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
     assertCachedData(cache, fakeDataSet);
   }
 
   @Test
   public void testHandleMultipleDownloadAction() throws Throwable {
-    handleDownloadAction(fakeRepresentationKey1);
-    handleDownloadAction(fakeRepresentationKey2);
+    handleDownloadAction(fakeStreamKey1);
+    handleDownloadAction(fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
     assertCachedData(cache, fakeDataSet);
   }
@@ -177,17 +165,11 @@ public void testHandleMultipleDownloadAction() throws Throwable {
   public void testHandleInterferingDownloadAction() throws Throwable {
     fakeDataSet
         .newData("audio_segment_2")
-        .appendReadAction(
-            new Runnable() {
-              @Override
-              public void run() {
-                handleDownloadAction(fakeRepresentationKey2);
-              }
-            })
+        .appendReadAction(() -> handleDownloadAction(fakeStreamKey2))
         .appendReadData(TestUtil.buildTestData(5))
         .endData();
 
-    handleDownloadAction(fakeRepresentationKey1);
+    handleDownloadAction(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
     assertCachedData(cache, fakeDataSet);
@@ -195,7 +177,7 @@ public void run() {
 
   @Test
   public void testHandleRemoveAction() throws Throwable {
-    handleDownloadAction(fakeRepresentationKey1);
+    handleDownloadAction(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
 
@@ -210,7 +192,7 @@ public void testHandleRemoveAction() throws Throwable {
   @Ignore
   @Test
   public void testHandleRemoveActionBeforeDownloadFinish() throws Throwable {
-    handleDownloadAction(fakeRepresentationKey1);
+    handleDownloadAction(fakeStreamKey1);
     handleRemoveAction();
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
@@ -223,17 +205,11 @@ public void testHandleInterferingRemoveAction() throws Throwable {
     final ConditionVariable downloadInProgressCondition = new ConditionVariable();
     fakeDataSet
         .newData("audio_segment_2")
-        .appendReadAction(
-            new Runnable() {
-              @Override
-              public void run() {
-                downloadInProgressCondition.open();
-              }
-            })
+        .appendReadAction(downloadInProgressCondition::open)
         .appendReadData(TestUtil.buildTestData(5))
         .endData();
 
-    handleDownloadAction(fakeRepresentationKey1);
+    handleDownloadAction(fakeStreamKey1);
 
     assertThat(downloadInProgressCondition.block(ASSERT_TRUE_TIMEOUT)).isTrue();
 
@@ -248,7 +224,7 @@ private void blockUntilTasksCompleteAndThrowAnyDownloadError() throws Throwable
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
-  private void handleDownloadAction(RepresentationKey... keys) {
+  private void handleDownloadAction(StreamKey... keys) {
     downloadManager.handleAction(newAction(TEST_MPD_URI, false, null, keys));
   }
 
@@ -258,31 +234,33 @@ private void handleRemoveAction() {
 
   private void createDownloadManager() {
     dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            Factory fakeDataSourceFactory =
-                new FakeDataSource.Factory(null).setFakeDataSet(fakeDataSet);
-            downloadManager =
-                new DownloadManager(
-                    new DownloaderConstructorHelper(cache, fakeDataSourceFactory),
-                    /* maxSimultaneousDownloads= */ 1,
-                    /* minRetryCount= */ 3,
-                    actionFile,
-                    DashDownloadAction.DESERIALIZER);
-
-            downloadManagerListener =
-                new TestDownloadManagerListener(downloadManager, dummyMainThread);
-            downloadManager.addListener(downloadManagerListener);
-            downloadManager.startDownloads();
-          }
+        () -> {
+          Factory fakeDataSourceFactory = new FakeDataSource.Factory().setFakeDataSet(fakeDataSet);
+          downloadManager =
+              new DownloadManager(
+                  new DownloaderConstructorHelper(cache, fakeDataSourceFactory),
+                  /* maxSimultaneousDownloads= */ 1,
+                  /* minRetryCount= */ 3,
+                  actionFile,
+                  DashDownloadAction.DESERIALIZER);
+
+          downloadManagerListener =
+              new TestDownloadManagerListener(downloadManager, dummyMainThread);
+          downloadManager.addListener(downloadManagerListener);
+          downloadManager.startDownloads();
         });
   }
 
-  private static DashDownloadAction newAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, RepresentationKey... keys) {
-    ArrayList<RepresentationKey> keysList = new ArrayList<>();
+  private static DownloadAction newAction(
+      Uri uri, boolean isRemoveAction, @Nullable byte[] data, StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
     Collections.addAll(keysList, keys);
-    return new DashDownloadAction(uri, isRemoveAction, data, keysList);
+    DownloadAction result;
+    if (isRemoveAction) {
+      result = DashDownloadAction.createRemoveAction(uri, data);
+    } else {
+      result = DashDownloadAction.createDownloadAction(uri, data, keysList);
+    }
+    return result;
   }
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java
index 745acd9bbf..70a64f5524 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java
@@ -20,18 +20,16 @@
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
 
-import android.app.Notification;
 import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.offline.DownloadAction;
 import com.google.android.exoplayer2.offline.DownloadManager;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
 import com.google.android.exoplayer2.offline.DownloadService;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.scheduler.Requirements;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.scheduler.Scheduler;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
@@ -52,7 +50,6 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -65,8 +62,8 @@
   private SimpleCache cache;
   private File tempFolder;
   private FakeDataSet fakeDataSet;
-  private RepresentationKey fakeRepresentationKey1;
-  private RepresentationKey fakeRepresentationKey2;
+  private StreamKey fakeStreamKey1;
+  private StreamKey fakeStreamKey2;
   private Context context;
   private DownloadService dashDownloadService;
   private ConditionVariable pauseDownloadCondition;
@@ -81,15 +78,12 @@ public void setUp() throws IOException {
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
 
     Runnable pauseAction =
-        new Runnable() {
-          @Override
-          public void run() {
-            if (pauseDownloadCondition != null) {
-              try {
-                pauseDownloadCondition.block();
-              } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-              }
+        () -> {
+          if (pauseDownloadCondition != null) {
+            try {
+              pauseDownloadCondition.block();
+            } catch (InterruptedException e) {
+              Thread.currentThread().interrupt();
             }
           }
         };
@@ -107,72 +101,51 @@ public void run() {
             .setRandomData("text_segment_2", 2)
             .setRandomData("text_segment_3", 3);
     final DataSource.Factory fakeDataSourceFactory =
-        new FakeDataSource.Factory(null).setFakeDataSet(fakeDataSet);
-    fakeRepresentationKey1 = new RepresentationKey(0, 0, 0);
-    fakeRepresentationKey2 = new RepresentationKey(0, 1, 0);
+        new FakeDataSource.Factory().setFakeDataSet(fakeDataSet);
+    fakeStreamKey1 = new StreamKey(0, 0, 0);
+    fakeStreamKey2 = new StreamKey(0, 1, 0);
 
     dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            File actionFile;
-            try {
-              actionFile = Util.createTempFile(context, "ExoPlayerTest");
-            } catch (IOException e) {
-              throw new RuntimeException(e);
-            }
-            actionFile.delete();
-            final DownloadManager dashDownloadManager =
-                new DownloadManager(
-                    new DownloaderConstructorHelper(cache, fakeDataSourceFactory),
-                    1,
-                    3,
-                    actionFile,
-                    DashDownloadAction.DESERIALIZER);
-            downloadManagerListener =
-                new TestDownloadManagerListener(dashDownloadManager, dummyMainThread);
-            dashDownloadManager.addListener(downloadManagerListener);
-            dashDownloadManager.startDownloads();
-
-            dashDownloadService =
-                new DownloadService(/*foregroundNotificationId=*/ 1) {
-
-                  @Override
-                  protected DownloadManager getDownloadManager() {
-                    return dashDownloadManager;
-                  }
-
-                  @Override
-                  protected Notification getForegroundNotification(TaskState[] taskStates) {
-                    return Mockito.mock(Notification.class);
-                  }
-
-                  @Nullable
-                  @Override
-                  protected Scheduler getScheduler() {
-                    return null;
-                  }
-
-                  @Nullable
-                  @Override
-                  protected Requirements getRequirements() {
-                    return null;
-                  }
-                };
-            dashDownloadService.onCreate();
+        () -> {
+          File actionFile;
+          try {
+            actionFile = Util.createTempFile(context, "ExoPlayerTest");
+          } catch (IOException e) {
+            throw new RuntimeException(e);
           }
+          actionFile.delete();
+          final DownloadManager dashDownloadManager =
+              new DownloadManager(
+                  new DownloaderConstructorHelper(cache, fakeDataSourceFactory),
+                  1,
+                  3,
+                  actionFile,
+                  DashDownloadAction.DESERIALIZER);
+          downloadManagerListener =
+              new TestDownloadManagerListener(dashDownloadManager, dummyMainThread);
+          dashDownloadManager.addListener(downloadManagerListener);
+          dashDownloadManager.startDownloads();
+
+          dashDownloadService =
+              new DownloadService(DownloadService.FOREGROUND_NOTIFICATION_ID_NONE) {
+                @Override
+                protected DownloadManager getDownloadManager() {
+                  return dashDownloadManager;
+                }
+
+                @Nullable
+                @Override
+                protected Scheduler getScheduler() {
+                  return null;
+                }
+              };
+          dashDownloadService.onCreate();
         });
   }
 
   @After
   public void tearDown() {
-    dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            dashDownloadService.onDestroy();
-          }
-        });
+    dummyMainThread.runOnMainThread(() -> dashDownloadService.onDestroy());
     Util.recursiveDelete(tempFolder);
     dummyMainThread.release();
   }
@@ -180,8 +153,8 @@ public void run() {
   @Ignore // b/78877092
   @Test
   public void testMultipleDownloadAction() throws Throwable {
-    downloadKeys(fakeRepresentationKey1);
-    downloadKeys(fakeRepresentationKey2);
+    downloadKeys(fakeStreamKey1);
+    downloadKeys(fakeStreamKey2);
 
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
 
@@ -191,7 +164,7 @@ public void testMultipleDownloadAction() throws Throwable {
   @Ignore // b/78877092
   @Test
   public void testRemoveAction() throws Throwable {
-    downloadKeys(fakeRepresentationKey1, fakeRepresentationKey2);
+    downloadKeys(fakeStreamKey1, fakeStreamKey2);
 
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
 
@@ -206,7 +179,7 @@ public void testRemoveAction() throws Throwable {
   @Test
   public void testRemoveBeforeDownloadComplete() throws Throwable {
     pauseDownloadCondition = new ConditionVariable();
-    downloadKeys(fakeRepresentationKey1, fakeRepresentationKey2);
+    downloadKeys(fakeStreamKey1, fakeStreamKey2);
 
     removeAll();
 
@@ -219,26 +192,29 @@ private void removeAll() throws Throwable {
     callDownloadServiceOnStart(newAction(TEST_MPD_URI, true, null));
   }
 
-  private void downloadKeys(RepresentationKey... keys) {
+  private void downloadKeys(StreamKey... keys) {
     callDownloadServiceOnStart(newAction(TEST_MPD_URI, false, null, keys));
   }
 
-  private void callDownloadServiceOnStart(final DashDownloadAction action) {
+  private void callDownloadServiceOnStart(final DownloadAction action) {
     dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            Intent startIntent =
-                DownloadService.buildAddActionIntent(context, DownloadService.class, action, false);
-            dashDownloadService.onStartCommand(startIntent, 0, 0);
-          }
+        () -> {
+          Intent startIntent =
+              DownloadService.buildAddActionIntent(context, DownloadService.class, action, false);
+          dashDownloadService.onStartCommand(startIntent, 0, 0);
         });
   }
 
-  private static DashDownloadAction newAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, RepresentationKey... keys) {
-    ArrayList<RepresentationKey> keysList = new ArrayList<>();
+  private static DownloadAction newAction(
+      Uri uri, boolean isRemoveAction, @Nullable byte[] data, StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
     Collections.addAll(keysList, keys);
-    return new DashDownloadAction(uri, isRemoveAction, data, keysList);
+    DownloadAction result;
+    if (isRemoveAction) {
+      result = DashDownloadAction.createRemoveAction(uri, data);
+    } else {
+      result = DashDownloadAction.createDownloadAction(uri, data, keysList);
+    }
+    return result;
   }
 }
diff --git a/library/hls/build.gradle b/library/hls/build.gradle
index 025a460b1f..f05b358287 100644
--- a/library/hls/build.gradle
+++ b/library/hls/build.gradle
@@ -17,9 +17,15 @@ apply plugin: 'com.android.library'
 android {
     compileSdkVersion project.ext.compileSdkVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
diff --git a/library/hls/proguard-rules.txt b/library/hls/proguard-rules.txt
new file mode 100644
index 0000000000..3b8d1bb4ac
--- /dev/null
+++ b/library/hls/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the hls module.
+
+# Constructors accessed via reflection in SegmentDownloadAction
+-dontnote com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction
+-keepclassmembers class com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction {
+  static ** DESERIALIZER;
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
index 3f57cba1b0..55a648a0b8 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
@@ -16,10 +16,12 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.security.InvalidAlgorithmParameterException;
@@ -27,6 +29,8 @@
 import java.security.Key;
 import java.security.NoSuchAlgorithmException;
 import java.security.spec.AlgorithmParameterSpec;
+import java.util.List;
+import java.util.Map;
 import javax.crypto.Cipher;
 import javax.crypto.CipherInputStream;
 import javax.crypto.NoSuchPaddingException;
@@ -36,18 +40,18 @@
 /**
  * A {@link DataSource} that decrypts data read from an upstream source, encrypted with AES-128 with
  * a 128-bit key and PKCS7 padding.
- * <p>
- * Note that this {@link DataSource} does not support being opened from arbitrary offsets. It is
+ *
+ * <p>Note that this {@link DataSource} does not support being opened from arbitrary offsets. It is
  * designed specifically for reading whole files as defined in an HLS media playlist. For this
  * reason the implementation is private to the HLS package.
  */
-/* package */ final class Aes128DataSource implements DataSource {
+/* package */ class Aes128DataSource implements DataSource {
 
   private final DataSource upstream;
   private final byte[] encryptionKey;
   private final byte[] encryptionIv;
 
-  private CipherInputStream cipherInputStream;
+  private @Nullable CipherInputStream cipherInputStream;
 
   /**
    * @param upstream The upstream {@link DataSource}.
@@ -61,10 +65,15 @@ public Aes128DataSource(DataSource upstream, byte[] encryptionKey, byte[] encryp
   }
 
   @Override
-  public long open(DataSpec dataSpec) throws IOException {
+  public final void addTransferListener(TransferListener transferListener) {
+    upstream.addTransferListener(transferListener);
+  }
+
+  @Override
+  public final long open(DataSpec dataSpec) throws IOException {
     Cipher cipher;
     try {
-      cipher = Cipher.getInstance("AES/CBC/PKCS7Padding");
+      cipher = getCipherInstance();
     } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
       throw new RuntimeException(e);
     }
@@ -86,16 +95,8 @@ public long open(DataSpec dataSpec) throws IOException {
   }
 
   @Override
-  public void close() throws IOException {
-    if (cipherInputStream != null) {
-      cipherInputStream = null;
-      upstream.close();
-    }
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws IOException {
-    Assertions.checkState(cipherInputStream != null);
+  public final int read(byte[] buffer, int offset, int readLength) throws IOException {
+    Assertions.checkNotNull(cipherInputStream);
     int bytesRead = cipherInputStream.read(buffer, offset, readLength);
     if (bytesRead < 0) {
       return C.RESULT_END_OF_INPUT;
@@ -104,8 +105,24 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
   }
 
   @Override
-  public Uri getUri() {
+  public final @Nullable Uri getUri() {
     return upstream.getUri();
   }
 
+  @Override
+  public final Map<String, List<String>> getResponseHeaders() {
+    return upstream.getResponseHeaders();
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (cipherInputStream != null) {
+      cipherInputStream = null;
+      upstream.close();
+    }
+  }
+
+  protected Cipher getCipherInstance() throws NoSuchPaddingException, NoSuchAlgorithmException {
+    return Cipher.getInstance("AES/CBC/PKCS7Padding");
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
index 702b1126cc..8a403c3759 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
@@ -29,8 +30,11 @@
 import com.google.android.exoplayer2.extractor.ts.TsExtractor;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.io.EOFException;
+import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Default {@link HlsExtractorFactory} implementation.
@@ -44,67 +48,226 @@
   public static final String MP4_FILE_EXTENSION = ".mp4";
   public static final String M4_FILE_EXTENSION_PREFIX = ".m4";
   public static final String MP4_FILE_EXTENSION_PREFIX = ".mp4";
+  public static final String CMF_FILE_EXTENSION_PREFIX = ".cmf";
   public static final String VTT_FILE_EXTENSION = ".vtt";
   public static final String WEBVTT_FILE_EXTENSION = ".webvtt";
 
+  @DefaultTsPayloadReaderFactory.Flags private final int payloadReaderFactoryFlags;
+
+  /** Creates a factory for HLS segment extractors. */
+  public DefaultHlsExtractorFactory() {
+    this(/* payloadReaderFactoryFlags= */ 0);
+  }
+
+  /**
+   * Creates a factory for HLS segment extractors.
+   *
+   * @param payloadReaderFactoryFlags Flags to add when constructing any {@link
+   *     DefaultTsPayloadReaderFactory} instances. Other flags may be added on top of {@code
+   *     payloadReaderFactoryFlags} when creating {@link DefaultTsPayloadReaderFactory}.
+   */
+  public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
+    this.payloadReaderFactoryFlags = payloadReaderFactoryFlags;
+  }
+
   @Override
-  public Pair<Extractor, Boolean> createExtractor(Extractor previousExtractor, Uri uri,
-      Format format, List<Format> muxedCaptionFormats, DrmInitData drmInitData,
+  public Pair<Extractor, Boolean> createExtractor(
+      Extractor previousExtractor,
+      Uri uri,
+      Format format,
+      List<Format> muxedCaptionFormats,
+      DrmInitData drmInitData,
+      TimestampAdjuster timestampAdjuster,
+      Map<String, List<String>> responseHeaders,
+      ExtractorInput extractorInput)
+      throws InterruptedException, IOException {
+
+    if (previousExtractor != null) {
+      // A extractor has already been successfully used. Return one of the same type.
+      if (previousExtractor instanceof TsExtractor
+          || previousExtractor instanceof FragmentedMp4Extractor) {
+        // TS and fMP4 extractors can be reused.
+        return buildResult(previousExtractor);
+      } else if (previousExtractor instanceof WebvttExtractor) {
+        return buildResult(new WebvttExtractor(format.language, timestampAdjuster));
+      } else if (previousExtractor instanceof AdtsExtractor) {
+        return buildResult(new AdtsExtractor());
+      } else if (previousExtractor instanceof Ac3Extractor) {
+        return buildResult(new Ac3Extractor());
+      } else if (previousExtractor instanceof Mp3Extractor) {
+        return buildResult(new Mp3Extractor());
+      } else {
+        throw new IllegalArgumentException(
+            "Unexpected previousExtractor type: " + previousExtractor.getClass().getSimpleName());
+      }
+    }
+
+    // Try selecting the extractor by the file extension.
+    Extractor extractorByFileExtension =
+        createExtractorByFileExtension(
+            uri, format, muxedCaptionFormats, drmInitData, timestampAdjuster);
+    extractorInput.resetPeekPosition();
+    if (sniffQuietly(extractorByFileExtension, extractorInput)) {
+      return buildResult(extractorByFileExtension);
+    }
+
+    // We need to manually sniff each known type, without retrying the one selected by file
+    // extension.
+
+    if (!(extractorByFileExtension instanceof WebvttExtractor)) {
+      WebvttExtractor webvttExtractor = new WebvttExtractor(format.language, timestampAdjuster);
+      if (sniffQuietly(webvttExtractor, extractorInput)) {
+        return buildResult(webvttExtractor);
+      }
+    }
+
+    if (!(extractorByFileExtension instanceof AdtsExtractor)) {
+      AdtsExtractor adtsExtractor = new AdtsExtractor();
+      if (sniffQuietly(adtsExtractor, extractorInput)) {
+        return buildResult(adtsExtractor);
+      }
+    }
+
+    if (!(extractorByFileExtension instanceof Ac3Extractor)) {
+      Ac3Extractor ac3Extractor = new Ac3Extractor();
+      if (sniffQuietly(ac3Extractor, extractorInput)) {
+        return buildResult(ac3Extractor);
+      }
+    }
+
+    if (!(extractorByFileExtension instanceof Mp3Extractor)) {
+      Mp3Extractor mp3Extractor =
+          new Mp3Extractor(/* flags= */ 0, /* forcedFirstSampleTimestampUs= */ 0);
+      if (sniffQuietly(mp3Extractor, extractorInput)) {
+        return buildResult(mp3Extractor);
+      }
+    }
+
+    if (!(extractorByFileExtension instanceof FragmentedMp4Extractor)) {
+      FragmentedMp4Extractor fragmentedMp4Extractor =
+          new FragmentedMp4Extractor(
+              /* flags= */ 0,
+              timestampAdjuster,
+              /* sideloadedTrack= */ null,
+              drmInitData,
+              muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
+      if (sniffQuietly(fragmentedMp4Extractor, extractorInput)) {
+        return buildResult(fragmentedMp4Extractor);
+      }
+    }
+
+    if (!(extractorByFileExtension instanceof TsExtractor)) {
+      TsExtractor tsExtractor =
+          createTsExtractor(
+              payloadReaderFactoryFlags, format, muxedCaptionFormats, timestampAdjuster);
+      if (sniffQuietly(tsExtractor, extractorInput)) {
+        return buildResult(tsExtractor);
+      }
+    }
+
+    // Fall back on the extractor created by file extension.
+    return buildResult(extractorByFileExtension);
+  }
+
+  private Extractor createExtractorByFileExtension(
+      Uri uri,
+      Format format,
+      List<Format> muxedCaptionFormats,
+      DrmInitData drmInitData,
       TimestampAdjuster timestampAdjuster) {
     String lastPathSegment = uri.getLastPathSegment();
     if (lastPathSegment == null) {
       lastPathSegment = "";
     }
-    boolean isPackedAudioExtractor = false;
-    Extractor extractor;
     if (MimeTypes.TEXT_VTT.equals(format.sampleMimeType)
         || lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
         || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
-      extractor = new WebvttExtractor(format.language, timestampAdjuster);
+      return new WebvttExtractor(format.language, timestampAdjuster);
     } else if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
-      isPackedAudioExtractor = true;
-      extractor = new AdtsExtractor();
+      return new AdtsExtractor();
     } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
-      isPackedAudioExtractor = true;
-      extractor = new Ac3Extractor();
+      return new Ac3Extractor();
     } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
-      isPackedAudioExtractor = true;
-      extractor = new Mp3Extractor(0, 0);
-    } else if (previousExtractor != null) {
-      // Only reuse TS and fMP4 extractors.
-      extractor = previousExtractor;
+      return new Mp3Extractor(/* flags= */ 0, /* forcedFirstSampleTimestampUs= */ 0);
     } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
         || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)
-        || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
-      extractor = new FragmentedMp4Extractor(0, timestampAdjuster, null, drmInitData,
-          muxedCaptionFormats != null ? muxedCaptionFormats : Collections.<Format>emptyList());
+        || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)
+        || lastPathSegment.startsWith(CMF_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
+      return new FragmentedMp4Extractor(
+          /* flags= */ 0,
+          timestampAdjuster,
+          /* sideloadedTrack= */ null,
+          drmInitData,
+          muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
     } else {
       // For any other file extension, we assume TS format.
-      @DefaultTsPayloadReaderFactory.Flags
-      int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
-      if (muxedCaptionFormats != null) {
-        // The playlist declares closed caption renditions, we should ignore descriptors.
-        esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
-      } else {
-        muxedCaptionFormats = Collections.emptyList();
+      return createTsExtractor(
+          payloadReaderFactoryFlags, format, muxedCaptionFormats, timestampAdjuster);
+    }
+  }
+
+  private static TsExtractor createTsExtractor(
+      @DefaultTsPayloadReaderFactory.Flags int userProvidedPayloadReaderFactoryFlags,
+      Format format,
+      List<Format> muxedCaptionFormats,
+      TimestampAdjuster timestampAdjuster) {
+    @DefaultTsPayloadReaderFactory.Flags
+    int payloadReaderFactoryFlags =
+        DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM
+            | userProvidedPayloadReaderFactoryFlags;
+    if (muxedCaptionFormats != null) {
+      // The playlist declares closed caption renditions, we should ignore descriptors.
+      payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
+    } else {
+      // The playlist does not provide any closed caption information. We preemptively declare a
+      // closed caption track on channel 0.
+      muxedCaptionFormats =
+          Collections.singletonList(
+              Format.createTextSampleFormat(
+                  /* id= */ null,
+                  MimeTypes.APPLICATION_CEA608,
+                  /* selectionFlags= */ 0,
+                  /* language= */ null));
+    }
+    String codecs = format.codecs;
+    if (!TextUtils.isEmpty(codecs)) {
+      // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
+      // exist. If we know from the codec attribute that they don't exist, then we can
+      // explicitly ignore them even if they're declared.
+      if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
+        payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
       }
-      String codecs = format.codecs;
-      if (!TextUtils.isEmpty(codecs)) {
-        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
-        // exist. If we know from the codec attribute that they don't exist, then we can
-        // explicitly ignore them even if they're declared.
-        if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
-          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
-        }
-        if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
-          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
-        }
+      if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
+        payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
       }
-      extractor = new TsExtractor(TsExtractor.MODE_HLS, timestampAdjuster,
-          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats));
     }
-    return Pair.create(extractor, isPackedAudioExtractor);
+
+    return new TsExtractor(
+        TsExtractor.MODE_HLS,
+        timestampAdjuster,
+        new DefaultTsPayloadReaderFactory(payloadReaderFactoryFlags, muxedCaptionFormats));
+  }
+
+  private static Pair<Extractor, Boolean> buildResult(Extractor extractor) {
+    return new Pair<>(
+        extractor,
+        extractor instanceof AdtsExtractor
+            || extractor instanceof Ac3Extractor
+            || extractor instanceof Mp3Extractor);
+  }
+
+  private static boolean sniffQuietly(Extractor extractor, ExtractorInput input)
+      throws InterruptedException, IOException {
+    boolean result = false;
+    try {
+      result = extractor.sniff(input);
+    } catch (EOFException e) {
+      // Do nothing.
+    } finally {
+      input.resetPeekPosition();
+    }
+    return result;
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 37804b81f4..c1396de3d6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -17,13 +17,16 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.BaseMediaChunkIterator;
 import com.google.android.exoplayer2.source.chunk.Chunk;
-import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
 import com.google.android.exoplayer2.source.chunk.DataChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
@@ -32,6 +35,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -114,15 +118,22 @@ public void clear() {
    * @param variants The available variants.
    * @param dataSourceFactory An {@link HlsDataSourceFactory} to create {@link DataSource}s for the
    *     chunks.
-   * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
-   *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
-   *     same provider.
+   * @param mediaTransferListener The transfer listener which should be informed of any media data
+   *     transfers. May be null if no listener is available.
+   * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If multiple
+   *     {@link HlsChunkSource}s are used for a single playback, they should all share the same
+   *     provider.
    * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
    *     information is available in the master playlist.
    */
-  public HlsChunkSource(HlsExtractorFactory extractorFactory, HlsPlaylistTracker playlistTracker,
-      HlsUrl[] variants, HlsDataSourceFactory dataSourceFactory,
-      TimestampAdjusterProvider timestampAdjusterProvider, List<Format> muxedCaptionFormats) {
+  public HlsChunkSource(
+      HlsExtractorFactory extractorFactory,
+      HlsPlaylistTracker playlistTracker,
+      HlsUrl[] variants,
+      HlsDataSourceFactory dataSourceFactory,
+      @Nullable TransferListener mediaTransferListener,
+      TimestampAdjusterProvider timestampAdjusterProvider,
+      List<Format> muxedCaptionFormats) {
     this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
     this.variants = variants;
@@ -136,6 +147,9 @@ public HlsChunkSource(HlsExtractorFactory extractorFactory, HlsPlaylistTracker p
       initialTrackSelection[i] = i;
     }
     mediaDataSource = dataSourceFactory.createDataSource(C.DATA_TYPE_MEDIA);
+    if (mediaTransferListener != null) {
+      mediaDataSource.addTransferListener(mediaTransferListener);
+    }
     encryptionDataSource = dataSourceFactory.createDataSource(C.DATA_TYPE_DRM);
     trackGroup = new TrackGroup(variantFormats);
     trackSelection = new InitializationTrackSelection(trackGroup, initialTrackSelection);
@@ -204,29 +218,28 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
    * but the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
    * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
    *
-   * @param previous The most recently loaded media chunk.
    * @param playbackPositionUs The current playback position relative to the period start in
    *     microseconds. If playback of the period to which this chunk source belongs has not yet
    *     started, the value will be the starting position in the period minus the duration of any
    *     media in previous periods still to be played.
    * @param loadPositionUs The current load position relative to the period start in microseconds.
-   *     If {@code previous} is null, this is the starting position from which chunks should be
-   *     provided. Else it's equal to {@code previous.endTimeUs}.
+   * @param queue The queue of buffered {@link HlsMediaChunk}s.
    * @param out A holder to populate.
    */
   public void getNextChunk(
-      HlsMediaChunk previous, long playbackPositionUs, long loadPositionUs, HlsChunkHolder out) {
+      long playbackPositionUs, long loadPositionUs, List<HlsMediaChunk> queue, HlsChunkHolder out) {
+    HlsMediaChunk previous = queue.isEmpty() ? null : queue.get(queue.size() - 1);
     int oldVariantIndex = previous == null ? C.INDEX_UNSET
         : trackGroup.indexOf(previous.trackFormat);
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
     long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
     if (previous != null && !independentSegments) {
-      // Unless segments are known to be independent, switching variant will require downloading
-      // overlapping segments. Hence we will subtract previous chunk's duration from buffered
+      // Unless segments are known to be independent, switching variant requires downloading
+      // overlapping segments. Hence we subtract the previous segment's duration from the buffered
       // duration.
-      // This may affect the live-streaming adaptive track selection logic, when we are comparing
-      // buffered duration to time to live edge to decide whether to switch. Therefore,
-      // we will subtract this same amount from timeToLiveEdgeUs as well.
+      // This may affect the live-streaming adaptive track selection logic, when we compare the
+      // buffered duration to time-to-live-edge to decide whether to switch. Therefore, we subtract
+      // the duration of the last loaded segment from timeToLiveEdgeUs as well.
       long subtractedDurationUs = previous.getDurationUs();
       bufferedDurationUs = Math.max(0, bufferedDurationUs - subtractedDurationUs);
       if (timeToLiveEdgeUs != C.TIME_UNSET) {
@@ -235,7 +248,9 @@ public void getNextChunk(
     }
 
     // Select the variant.
-    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
+    MediaChunkIterator[] mediaChunkIterators = createMediaChunkIterators(previous, loadPositionUs);
+    trackSelection.updateSelectedTrack(
+        playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs, queue, mediaChunkIterators);
     int selectedVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
 
     boolean switchingVariant = oldVariantIndex != selectedVariantIndex;
@@ -247,48 +262,32 @@ public void getNextChunk(
       // Retry when playlist is refreshed.
       return;
     }
-    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
-    independentSegments = mediaPlaylist.hasIndependentSegmentsTag;
+    HlsMediaPlaylist mediaPlaylist =
+        playlistTracker.getPlaylistSnapshot(selectedUrl, /* isForPlayback= */ true);
+    independentSegments = mediaPlaylist.hasIndependentSegments;
 
     updateLiveEdgeTimeUs(mediaPlaylist);
 
     // Select the chunk.
-    long chunkMediaSequence;
     long startOfPlaylistInPeriodUs =
         mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
-    if (previous == null || switchingVariant) {
-      long endOfPlaylistInPeriodUs = startOfPlaylistInPeriodUs + mediaPlaylist.durationUs;
-      long targetPositionInPeriodUs =
-          (previous == null || independentSegments) ? loadPositionUs : previous.startTimeUs;
-      if (!mediaPlaylist.hasEndTag && targetPositionInPeriodUs >= endOfPlaylistInPeriodUs) {
-        // If the playlist is too old to contain the chunk, we need to refresh it.
-        chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
+    long chunkMediaSequence =
+        getChunkMediaSequence(
+            previous, switchingVariant, mediaPlaylist, startOfPlaylistInPeriodUs, loadPositionUs);
+    if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+      if (previous != null && switchingVariant) {
+        // We try getting the next chunk without adapting in case that's the reason for falling
+        // behind the live window.
+        selectedVariantIndex = oldVariantIndex;
+        selectedUrl = variants[selectedVariantIndex];
+        mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl, /* isForPlayback= */ true);
+        startOfPlaylistInPeriodUs =
+            mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
+        chunkMediaSequence = previous.getNextChunkIndex();
       } else {
-        long targetPositionInPlaylistUs = targetPositionInPeriodUs - startOfPlaylistInPeriodUs;
-        chunkMediaSequence =
-            Util.binarySearchFloor(
-                    mediaPlaylist.segments,
-                    /* value= */ targetPositionInPlaylistUs,
-                    /* inclusive= */ true,
-                    /* stayInBounds= */ !playlistTracker.isLive() || previous == null)
-                + mediaPlaylist.mediaSequence;
-        if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
-          // We try getting the next chunk without adapting in case that's the reason for falling
-          // behind the live window.
-          selectedVariantIndex = oldVariantIndex;
-          selectedUrl = variants[selectedVariantIndex];
-          mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
-          startOfPlaylistInPeriodUs =
-              mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
-          chunkMediaSequence = previous.getNextChunkIndex();
-        }
+        fatalError = new BehindLiveWindowException();
+        return;
       }
-    } else {
-      chunkMediaSequence = previous.getNextChunkIndex();
-    }
-    if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-      fatalError = new BehindLiveWindowException();
-      return;
     }
 
     int chunkIndex = (int) (chunkMediaSequence - mediaPlaylist.mediaSequence);
@@ -362,7 +361,7 @@ public void getNextChunk(
             isTimestampMaster,
             timestampAdjuster,
             previous,
-            mediaPlaylist.drmInitData,
+            segment.drmInitData,
             encryptionKey,
             encryptionIv);
   }
@@ -383,27 +382,28 @@ public void onChunkLoadCompleted(Chunk chunk) {
   }
 
   /**
-   * Called when the {@link HlsSampleStreamWrapper} encounters an error loading a chunk obtained
-   * from this source.
+   * Attempts to blacklist the track associated with the given chunk. Blacklisting will fail if the
+   * track is the only non-blacklisted track in the selection.
    *
-   * @param chunk The chunk whose load encountered the error.
-   * @param cancelable Whether the load can be canceled.
-   * @param error The error.
-   * @return Whether the load should be canceled.
+   * @param chunk The chunk whose load caused the blacklisting attempt.
+   * @param blacklistDurationMs The number of milliseconds for which the track selection should be
+   *     blacklisted.
+   * @return Whether the blacklisting succeeded.
    */
-  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException error) {
-    return cancelable && ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
-        trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), error);
+  public boolean maybeBlacklistTrack(Chunk chunk, long blacklistDurationMs) {
+    return trackSelection.blacklist(
+        trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), blacklistDurationMs);
   }
 
   /**
    * Called when a playlist load encounters an error.
    *
    * @param url The url of the playlist whose load encountered an error.
-   * @param shouldBlacklist Whether the playlist should be blacklisted.
+   * @param blacklistDurationMs The duration for which the playlist should be blacklisted. Or {@link
+   *     C#TIME_UNSET} if the playlist should not be blacklisted.
    * @return True if blacklisting did not encounter errors. False otherwise.
    */
-  public boolean onPlaylistError(HlsUrl url, boolean shouldBlacklist) {
+  public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
     int trackGroupIndex = trackGroup.indexOf(url.format);
     if (trackGroupIndex == C.INDEX_UNSET) {
       return true;
@@ -413,13 +413,89 @@ public boolean onPlaylistError(HlsUrl url, boolean shouldBlacklist) {
       return true;
     }
     seenExpectedPlaylistError |= expectedPlaylistUrl == url;
-    return !shouldBlacklist
-        || trackSelection.blacklist(
-            trackSelectionIndex, ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);
+    return blacklistDurationMs == C.TIME_UNSET
+        || trackSelection.blacklist(trackSelectionIndex, blacklistDurationMs);
+  }
+
+  /**
+   * Returns an array of {@link MediaChunkIterator}s for upcoming media chunks.
+   *
+   * @param previous The previous media chunk. May be null.
+   * @param loadPositionUs The position at which the iterators will start.
+   * @return Array of {@link MediaChunkIterator}s for each track.
+   */
+  public MediaChunkIterator[] createMediaChunkIterators(
+      @Nullable HlsMediaChunk previous, long loadPositionUs) {
+    int oldVariantIndex =
+        previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
+    MediaChunkIterator[] chunkIterators = new MediaChunkIterator[trackSelection.length()];
+    for (int i = 0; i < chunkIterators.length; i++) {
+      int variantIndex = trackSelection.getIndexInTrackGroup(i);
+      HlsUrl variantUrl = variants[variantIndex];
+      if (!playlistTracker.isSnapshotValid(variantUrl)) {
+        chunkIterators[i] = MediaChunkIterator.EMPTY;
+        continue;
+      }
+      HlsMediaPlaylist playlist =
+          playlistTracker.getPlaylistSnapshot(variantUrl, /* isForPlayback= */ false);
+      long startOfPlaylistInPeriodUs =
+          playlist.startTimeUs - playlistTracker.getInitialStartTimeUs();
+      boolean switchingVariant = variantIndex != oldVariantIndex;
+      long chunkMediaSequence =
+          getChunkMediaSequence(
+              previous, switchingVariant, playlist, startOfPlaylistInPeriodUs, loadPositionUs);
+      if (chunkMediaSequence < playlist.mediaSequence) {
+        chunkIterators[i] = MediaChunkIterator.EMPTY;
+        continue;
+      }
+      int chunkIndex = (int) (chunkMediaSequence - playlist.mediaSequence);
+      chunkIterators[i] =
+          new HlsMediaPlaylistSegmentIterator(playlist, startOfPlaylistInPeriodUs, chunkIndex);
+    }
+    return chunkIterators;
   }
 
   // Private methods.
 
+  /**
+   * Returns the media sequence number of the segment to load next in {@code mediaPlaylist}.
+   *
+   * @param previous The last (at least partially) loaded segment.
+   * @param switchingVariant Whether the segment to load is not preceded by a segment in the same
+   *     variant.
+   * @param mediaPlaylist The media playlist to which the segment to load belongs.
+   * @param startOfPlaylistInPeriodUs The start of {@code mediaPlaylist} relative to the period
+   *     start in microseconds.
+   * @param loadPositionUs The current load position relative to the period start in microseconds.
+   * @return The media sequence of the segment to load.
+   */
+  private long getChunkMediaSequence(
+      @Nullable HlsMediaChunk previous,
+      boolean switchingVariant,
+      HlsMediaPlaylist mediaPlaylist,
+      long startOfPlaylistInPeriodUs,
+      long loadPositionUs) {
+    if (previous == null || switchingVariant) {
+      long endOfPlaylistInPeriodUs = startOfPlaylistInPeriodUs + mediaPlaylist.durationUs;
+      long targetPositionInPeriodUs =
+          (previous == null || independentSegments) ? loadPositionUs : previous.startTimeUs;
+      if (!mediaPlaylist.hasEndTag && targetPositionInPeriodUs >= endOfPlaylistInPeriodUs) {
+        // If the playlist is too old to contain the chunk, we need to refresh it.
+        return mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
+      }
+      long targetPositionInPlaylistUs = targetPositionInPeriodUs - startOfPlaylistInPeriodUs;
+      return Util.binarySearchFloor(
+              mediaPlaylist.segments,
+              /* value= */ targetPositionInPlaylistUs,
+              /* inclusive= */ true,
+              /* stayInBounds= */ !playlistTracker.isLive() || previous == null)
+          + mediaPlaylist.mediaSequence;
+    }
+    // We ignore the case of previous not having loaded completely, in which case we load the next
+    // segment.
+    return previous.getNextChunkIndex();
+  }
+
   private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
     final boolean resolveTimeToLiveEdgePossible = liveEdgeInPeriodTimeUs != C.TIME_UNSET;
     return resolveTimeToLiveEdgePossible
@@ -483,8 +559,12 @@ public InitializationTrackSelection(TrackGroup group, int[] tracks) {
     }
 
     @Override
-    public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
-        long availableDurationUs) {
+    public void updateSelectedTrack(
+        long playbackPositionUs,
+        long bufferedDurationUs,
+        long availableDurationUs,
+        List<? extends MediaChunk> queue,
+        MediaChunkIterator[] mediaChunkIterators) {
       long nowMs = SystemClock.elapsedRealtime();
       if (!isBlacklisted(selectedIndex, nowMs)) {
         return;
@@ -541,4 +621,49 @@ protected void consume(byte[] data, int limit) throws IOException {
 
   }
 
+  /** {@link MediaChunkIterator} wrapping a {@link HlsMediaPlaylist}. */
+  private static final class HlsMediaPlaylistSegmentIterator extends BaseMediaChunkIterator {
+
+    private final HlsMediaPlaylist playlist;
+    private final long startOfPlaylistInPeriodUs;
+
+    /**
+     * Creates iterator.
+     *
+     * @param playlist The {@link HlsMediaPlaylist} to wrap.
+     * @param startOfPlaylistInPeriodUs The start time of the playlist in the period, in
+     *     microseconds.
+     * @param chunkIndex The chunk index in the playlist at which the iterator will start.
+     */
+    public HlsMediaPlaylistSegmentIterator(
+        HlsMediaPlaylist playlist, long startOfPlaylistInPeriodUs, int chunkIndex) {
+      super(/* fromIndex= */ chunkIndex, /* toIndex= */ playlist.segments.size() - 1);
+      this.playlist = playlist;
+      this.startOfPlaylistInPeriodUs = startOfPlaylistInPeriodUs;
+    }
+
+    @Override
+    public DataSpec getDataSpec() {
+      checkInBounds();
+      Segment segment = playlist.segments.get((int) getCurrentIndex());
+      Uri chunkUri = UriUtil.resolveToUri(playlist.baseUri, segment.url);
+      return new DataSpec(
+          chunkUri, segment.byterangeOffset, segment.byterangeLength, /* key= */ null);
+    }
+
+    @Override
+    public long getChunkStartTimeUs() {
+      checkInBounds();
+      Segment segment = playlist.segments.get((int) getCurrentIndex());
+      return startOfPlaylistInPeriodUs + segment.relativeStartTimeUs;
+    }
+
+    @Override
+    public long getChunkEndTimeUs() {
+      checkInBounds();
+      Segment segment = playlist.segments.get((int) getCurrentIndex());
+      long segmentStartTimeInPeriodUs = startOfPlaylistInPeriodUs + segment.relativeStartTimeUs;
+      return segmentStartTimeInPeriodUs + segment.durationUs;
+    }
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
index 3ed6a549db..eea64d4dc6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
@@ -20,8 +20,12 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.io.IOException;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Factory for HLS media chunk extractors.
@@ -42,12 +46,25 @@
    *     information is available in the master playlist.
    * @param drmInitData {@link DrmInitData} associated with the chunk.
    * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
+   * @param responseHeaders The HTTP response headers associated with the media segment or
+   *     initialization section to extract.
+   * @param sniffingExtractorInput The first extractor input that will be passed to the returned
+   *     extractor's {@link Extractor#read(ExtractorInput, PositionHolder)}. Must only be used to
+   *     call {@link Extractor#sniff(ExtractorInput)}.
    * @return A pair containing the {@link Extractor} and a boolean that indicates whether it is a
    *     packed audio extractor. The first element may be {@code previousExtractor} if the factory
    *     has determined it can be re-used.
+   * @throws InterruptedException If the thread is interrupted while sniffing.
+   * @throws IOException If an I/O error is encountered while sniffing.
    */
-  Pair<Extractor, Boolean> createExtractor(Extractor previousExtractor, Uri uri, Format format,
-      List<Format> muxedCaptionFormats, DrmInitData drmInitData,
-      TimestampAdjuster timestampAdjuster);
-
+  Pair<Extractor, Boolean> createExtractor(
+      Extractor previousExtractor,
+      Uri uri,
+      Format format,
+      List<Format> muxedCaptionFormats,
+      DrmInitData drmInitData,
+      TimestampAdjuster timestampAdjuster,
+      Map<String, List<String>> responseHeaders,
+      ExtractorInput sniffingExtractorInput)
+      throws InterruptedException, IOException;
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 3cd8556580..2995f8b0aa 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -41,8 +42,7 @@
  */
 /* package */ final class HlsMediaChunk extends MediaChunk {
 
-
-  private static final String PRIV_TIMESTAMP_FRAME_OWNER =
+  public static final String PRIV_TIMESTAMP_FRAME_OWNER =
       "com.apple.streaming.transportStreamTimestamp";
 
   private static final AtomicInteger uidSource = new AtomicInteger();
@@ -69,19 +69,20 @@
   private final boolean hasGapTag;
   private final TimestampAdjuster timestampAdjuster;
   private final boolean shouldSpliceIn;
-  private final Extractor extractor;
-  private final boolean isPackedAudioExtractor;
-  private final boolean reusingExtractor;
+  private final HlsExtractorFactory extractorFactory;
+  private final List<Format> muxedCaptionFormats;
+  private final DrmInitData drmInitData;
+  private final Extractor previousExtractor;
   private final Id3Decoder id3Decoder;
   private final ParsableByteArray id3Data;
 
+  private Extractor extractor;
   private HlsSampleStreamWrapper output;
   private int initSegmentBytesLoaded;
-  private int bytesLoaded;
-  private boolean id3TimestampPeeked;
+  private int nextLoadPosition;
   private boolean initLoadCompleted;
   private volatile boolean loadCanceled;
-  private volatile boolean loadCompleted;
+  private boolean loadCompleted;
 
   /**
    * @param extractorFactory A {@link HlsExtractorFactory} from which the HLS media chunk extractor
@@ -142,35 +143,24 @@ public HlsMediaChunk(
     this.hlsUrl = hlsUrl;
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
-    // Note: this.dataSource and dataSource may be different.
-    this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+    this.isEncrypted = fullSegmentEncryptionKey != null;
     this.hasGapTag = hasGapTag;
+    this.extractorFactory = extractorFactory;
+    this.muxedCaptionFormats = muxedCaptionFormats;
+    this.drmInitData = drmInitData;
     Extractor previousExtractor = null;
     if (previousChunk != null) {
-      shouldSpliceIn = previousChunk.hlsUrl != hlsUrl;
+      id3Decoder = previousChunk.id3Decoder;
+      id3Data = previousChunk.id3Data;
+      shouldSpliceIn = previousChunk.hlsUrl != hlsUrl || !previousChunk.loadCompleted;
       previousExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
           || shouldSpliceIn ? null : previousChunk.extractor;
     } else {
+      id3Decoder = new Id3Decoder();
+      id3Data = new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
       shouldSpliceIn = false;
     }
-    Pair<Extractor, Boolean> extractorData = extractorFactory.createExtractor(previousExtractor,
-        dataSpec.uri, trackFormat, muxedCaptionFormats, drmInitData, timestampAdjuster);
-    extractor = extractorData.first;
-    isPackedAudioExtractor = extractorData.second;
-    reusingExtractor = extractor == previousExtractor;
-    initLoadCompleted = reusingExtractor && initDataSpec != null;
-    if (isPackedAudioExtractor) {
-      if (previousChunk != null && previousChunk.id3Data != null) {
-        id3Decoder = previousChunk.id3Decoder;
-        id3Data = previousChunk.id3Data;
-      } else {
-        id3Decoder = new Id3Decoder();
-        id3Data = new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
-      }
-    } else {
-      id3Decoder = null;
-      id3Data = null;
-    }
+    this.previousExtractor = previousExtractor;
     initDataSource = dataSource;
     uid = uidSource.getAndIncrement();
   }
@@ -183,10 +173,6 @@ public HlsMediaChunk(
    */
   public void init(HlsSampleStreamWrapper output) {
     this.output = output;
-    output.init(uid, shouldSpliceIn, reusingExtractor);
-    if (!reusingExtractor) {
-      extractor.init(output);
-    }
   }
 
   @Override
@@ -194,11 +180,6 @@ public boolean isLoadCompleted() {
     return loadCompleted;
   }
 
-  @Override
-  public long bytesLoaded() {
-    return bytesLoaded;
-  }
-
   // Loadable implementation
 
   @Override
@@ -217,7 +198,7 @@ public void load() throws IOException, InterruptedException {
     }
   }
 
-  // Internal loading methods.
+  // Internal methods.
 
   private void maybeLoadInitData() throws IOException, InterruptedException {
     if (initLoadCompleted || initDataSpec == null) {
@@ -226,8 +207,7 @@ private void maybeLoadInitData() throws IOException, InterruptedException {
     }
     DataSpec initSegmentDataSpec = initDataSpec.subrange(initSegmentBytesLoaded);
     try {
-      ExtractorInput input = new DefaultExtractorInput(initDataSource,
-          initSegmentDataSpec.absoluteStreamPosition, initDataSource.open(initSegmentDataSpec));
+      DefaultExtractorInput input = prepareExtraction(initDataSource, initSegmentDataSpec);
       try {
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
@@ -251,9 +231,9 @@ private void loadMedia() throws IOException, InterruptedException {
     boolean skipLoadedBytes;
     if (isEncrypted) {
       loadDataSpec = dataSpec;
-      skipLoadedBytes = bytesLoaded != 0;
+      skipLoadedBytes = nextLoadPosition != 0;
     } else {
-      loadDataSpec = dataSpec.subrange(bytesLoaded);
+      loadDataSpec = dataSpec.subrange(nextLoadPosition);
       skipLoadedBytes = false;
     }
     if (!isMasterTimestampSource) {
@@ -263,16 +243,9 @@ private void loadMedia() throws IOException, InterruptedException {
       timestampAdjuster.setFirstSampleTimestampUs(startTimeUs);
     }
     try {
-      ExtractorInput input = new DefaultExtractorInput(dataSource,
-          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
-      if (isPackedAudioExtractor && !id3TimestampPeeked) {
-        long id3Timestamp = peekId3PrivTimestamp(input);
-        id3TimestampPeeked = true;
-        output.setSampleOffsetUs(id3Timestamp != C.TIME_UNSET
-            ? timestampAdjuster.adjustTsTimestamp(id3Timestamp) : startTimeUs);
-      }
+      ExtractorInput input = prepareExtraction(dataSource, loadDataSpec);
       if (skipLoadedBytes) {
-        input.skipFully(bytesLoaded);
+        input.skipFully(nextLoadPosition);
       }
       try {
         int result = Extractor.RESULT_CONTINUE;
@@ -280,13 +253,54 @@ private void loadMedia() throws IOException, InterruptedException {
           result = extractor.read(input, null);
         }
       } finally {
-        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+        nextLoadPosition = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
       Util.closeQuietly(dataSource);
     }
   }
 
+  private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec dataSpec)
+      throws IOException, InterruptedException {
+    long bytesToRead = dataSource.open(dataSpec);
+
+    DefaultExtractorInput extractorInput =
+        new DefaultExtractorInput(dataSource, dataSpec.absoluteStreamPosition, bytesToRead);
+
+    if (extractor == null) {
+      long id3Timestamp = peekId3PrivTimestamp(extractorInput);
+      extractorInput.resetPeekPosition();
+
+      Pair<Extractor, Boolean> extractorData =
+          extractorFactory.createExtractor(
+              previousExtractor,
+              dataSpec.uri,
+              trackFormat,
+              muxedCaptionFormats,
+              drmInitData,
+              timestampAdjuster,
+              dataSource.getResponseHeaders(),
+              extractorInput);
+      extractor = extractorData.first;
+      boolean reusingExtractor = extractor == previousExtractor;
+      boolean isPackedAudioExtractor = extractorData.second;
+      if (isPackedAudioExtractor) {
+        output.setSampleOffsetUs(
+            id3Timestamp != C.TIME_UNSET
+                ? timestampAdjuster.adjustTsTimestamp(id3Timestamp)
+                : startTimeUs);
+      }
+      initLoadCompleted = reusingExtractor && initDataSpec != null;
+
+      output.init(uid, shouldSpliceIn, reusingExtractor);
+      if (!reusingExtractor) {
+        extractor.init(output);
+      }
+    }
+
+    return extractorInput;
+  }
+
   /**
    * Peek the presentation timestamp of the first sample in the chunk from an ID3 PRIV as defined
    * in the HLS spec, version 20, Section 3.4. Returns {@link C#TIME_UNSET} if the frame is not
@@ -299,7 +313,10 @@ private void loadMedia() throws IOException, InterruptedException {
    */
   private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
     input.resetPeekPosition();
-    if (!input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH, true)) {
+    try {
+      input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+    } catch (EOFException e) {
+      // The input isn't long enough for there to be any ID3 data.
       return C.TIME_UNSET;
     }
     id3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
@@ -315,9 +332,7 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
       id3Data.reset(requiredCapacity);
       System.arraycopy(data, 0, id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
     }
-    if (!input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size, true)) {
-      return C.TIME_UNSET;
-    }
+    input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size);
     Metadata metadata = id3Decoder.decode(id3Data.data, id3Size);
     if (metadata == null) {
       return C.TIME_UNSET;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index b142d38df9..da50d7cc93 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -31,6 +32,9 @@
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -50,7 +54,8 @@
   private final HlsExtractorFactory extractorFactory;
   private final HlsPlaylistTracker playlistTracker;
   private final HlsDataSourceFactory dataSourceFactory;
-  private final int minLoadableRetryCount;
+  private final @Nullable TransferListener mediaTransferListener;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final EventDispatcher eventDispatcher;
   private final Allocator allocator;
   private final IdentityHashMap<SampleStream, Integer> streamWrapperIndices;
@@ -66,11 +71,28 @@
   private SequenceableLoader compositeSequenceableLoader;
   private boolean notifiedReadingStarted;
 
+  /**
+   * Creates an HLS media period.
+   *
+   * @param extractorFactory An {@link HlsExtractorFactory} for {@link Extractor}s for the segments.
+   * @param playlistTracker A tracker for HLS playlists.
+   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for segments
+   *     and keys.
+   * @param mediaTransferListener The transfer listener to inform of any media data transfers. May
+   *     be null if no listener is available.
+   * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+   * @param eventDispatcher A dispatcher to notify of events.
+   * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
+   * @param compositeSequenceableLoaderFactory A factory to create composite {@link
+   *     SequenceableLoader}s for when this media source loads data from multiple streams.
+   * @param allowChunklessPreparation Whether chunkless preparation is allowed.
+   */
   public HlsMediaPeriod(
       HlsExtractorFactory extractorFactory,
       HlsPlaylistTracker playlistTracker,
       HlsDataSourceFactory dataSourceFactory,
-      int minLoadableRetryCount,
+      @Nullable TransferListener mediaTransferListener,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       EventDispatcher eventDispatcher,
       Allocator allocator,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
@@ -78,7 +100,8 @@ public HlsMediaPeriod(
     this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
     this.dataSourceFactory = dataSourceFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.mediaTransferListener = mediaTransferListener;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
@@ -307,10 +330,10 @@ public void onPlaylistChanged() {
   }
 
   @Override
-  public boolean onPlaylistError(HlsUrl url, boolean shouldBlacklist) {
+  public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
     boolean noBlacklistingFailure = true;
     for (HlsSampleStreamWrapper streamWrapper : sampleStreamWrappers) {
-      noBlacklistingFailure &= streamWrapper.onPlaylistError(url, shouldBlacklist);
+      noBlacklistingFailure &= streamWrapper.onPlaylistError(url, blacklistDurationMs);
     }
     callback.onContinueLoadingRequested(this);
     return noBlacklistingFailure;
@@ -340,7 +363,7 @@ private void buildAndPrepareSampleStreamWrappers(long positionUs) {
               C.TRACK_TYPE_AUDIO,
               new HlsUrl[] {audioRendition},
               null,
-              Collections.<Format>emptyList(),
+              Collections.emptyList(),
               positionUs);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
       Format renditionFormat = audioRendition.format;
@@ -357,11 +380,7 @@ private void buildAndPrepareSampleStreamWrappers(long positionUs) {
       HlsUrl url = subtitleRenditions.get(i);
       HlsSampleStreamWrapper sampleStreamWrapper =
           buildSampleStreamWrapper(
-              C.TRACK_TYPE_TEXT,
-              new HlsUrl[] {url},
-              null,
-              Collections.<Format>emptyList(),
-              positionUs);
+              C.TRACK_TYPE_TEXT, new HlsUrl[] {url}, null, Collections.emptyList(), positionUs);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
       sampleStreamWrapper.prepareWithMasterPlaylistInfo(
           new TrackGroupArray(new TrackGroup(url.format)), 0, TrackGroupArray.EMPTY);
@@ -442,8 +461,10 @@ private void buildAndPrepareMainSampleStreamWrapper(
             && (masterPlaylist.muxedAudioFormat != null || masterPlaylist.audios.isEmpty())) {
           muxedTrackGroups.add(
               new TrackGroup(
-                  deriveMuxedAudioFormat(
-                      variants[0].format, masterPlaylist.muxedAudioFormat, Format.NO_VALUE)));
+                  deriveAudioFormat(
+                      variants[0].format,
+                      masterPlaylist.muxedAudioFormat,
+                      /* isPrimaryTrackInVariant= */ false)));
         }
         List<Format> ccFormats = masterPlaylist.muxedCaptionFormats;
         if (ccFormats != null) {
@@ -457,8 +478,10 @@ private void buildAndPrepareMainSampleStreamWrapper(
         for (int i = 0; i < audioFormats.length; i++) {
           Format variantFormat = variants[i].format;
           audioFormats[i] =
-              deriveMuxedAudioFormat(
-                  variantFormat, masterPlaylist.muxedAudioFormat, variantFormat.bitrate);
+              deriveAudioFormat(
+                  variantFormat,
+                  masterPlaylist.muxedAudioFormat,
+                  /* isPrimaryTrackInVariant= */ true);
         }
         muxedTrackGroups.add(new TrackGroup(audioFormats));
       } else {
@@ -488,53 +511,77 @@ private void buildAndPrepareMainSampleStreamWrapper(
 
   private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
       Format muxedAudioFormat, List<Format> muxedCaptionFormats, long positionUs) {
-    HlsChunkSource defaultChunkSource = new HlsChunkSource(extractorFactory, playlistTracker,
-        variants, dataSourceFactory, timestampAdjusterProvider, muxedCaptionFormats);
-    return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator, positionUs,
-        muxedAudioFormat, minLoadableRetryCount, eventDispatcher);
+    HlsChunkSource defaultChunkSource =
+        new HlsChunkSource(
+            extractorFactory,
+            playlistTracker,
+            variants,
+            dataSourceFactory,
+            mediaTransferListener,
+            timestampAdjusterProvider,
+            muxedCaptionFormats);
+    return new HlsSampleStreamWrapper(
+        trackType,
+        /* callback= */ this,
+        defaultChunkSource,
+        allocator,
+        positionUs,
+        muxedAudioFormat,
+        loadErrorHandlingPolicy,
+        eventDispatcher);
   }
 
   private static Format deriveVideoFormat(Format variantFormat) {
     String codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_VIDEO);
-    String mimeType = MimeTypes.getMediaMimeType(codecs);
-    return Format.createVideoSampleFormat(
+    String sampleMimeType = MimeTypes.getMediaMimeType(codecs);
+    return Format.createVideoContainerFormat(
         variantFormat.id,
-        mimeType,
+        variantFormat.label,
+        variantFormat.containerMimeType,
+        sampleMimeType,
         codecs,
         variantFormat.bitrate,
-        Format.NO_VALUE,
         variantFormat.width,
         variantFormat.height,
         variantFormat.frameRate,
-        null,
-        null);
+        /* initializationData= */ null,
+        variantFormat.selectionFlags);
   }
 
-  private static Format deriveMuxedAudioFormat(
-      Format variantFormat, Format mediaTagFormat, int bitrate) {
+  private static Format deriveAudioFormat(
+      Format variantFormat, Format mediaTagFormat, boolean isPrimaryTrackInVariant) {
     String codecs;
     int channelCount = Format.NO_VALUE;
     int selectionFlags = 0;
     String language = null;
+    String label = null;
     if (mediaTagFormat != null) {
       codecs = mediaTagFormat.codecs;
       channelCount = mediaTagFormat.channelCount;
       selectionFlags = mediaTagFormat.selectionFlags;
       language = mediaTagFormat.language;
+      label = mediaTagFormat.label;
     } else {
       codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_AUDIO);
+      if (isPrimaryTrackInVariant) {
+        channelCount = variantFormat.channelCount;
+        selectionFlags = variantFormat.selectionFlags;
+        language = variantFormat.label;
+        label = variantFormat.label;
+      }
     }
-    String mimeType = MimeTypes.getMediaMimeType(codecs);
-    return Format.createAudioSampleFormat(
+    String sampleMimeType = MimeTypes.getMediaMimeType(codecs);
+    int bitrate = isPrimaryTrackInVariant ? variantFormat.bitrate : Format.NO_VALUE;
+    return Format.createAudioContainerFormat(
         variantFormat.id,
-        mimeType,
+        label,
+        variantFormat.containerMimeType,
+        sampleMimeType,
         codecs,
         bitrate,
-        Format.NO_VALUE,
         channelCount,
-        Format.NO_VALUE,
-        null,
-        null,
+        /* sampleRate= */ Format.NO_VALUE,
+        /* initializationData= */ null,
         selectionFlags,
         language);
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index e0c805e1af..a9b0c579ac 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -32,14 +32,19 @@
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistTracker;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.List;
@@ -58,10 +63,10 @@
     private final HlsDataSourceFactory hlsDataSourceFactory;
 
     private HlsExtractorFactory extractorFactory;
-    private @Nullable ParsingLoadable.Parser<HlsPlaylist> playlistParser;
-    private @Nullable HlsPlaylistTracker playlistTracker;
+    private HlsPlaylistParserFactory playlistParserFactory;
+    private HlsPlaylistTracker.Factory playlistTrackerFactory;
     private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
-    private int minLoadableRetryCount;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private boolean allowChunklessPreparation;
     private boolean isCreateCalled;
     private @Nullable Object tag;
@@ -85,8 +90,10 @@ public Factory(DataSource.Factory dataSourceFactory) {
      */
     public Factory(HlsDataSourceFactory hlsDataSourceFactory) {
       this.hlsDataSourceFactory = Assertions.checkNotNull(hlsDataSourceFactory);
+      playlistParserFactory = new DefaultHlsPlaylistParserFactory();
+      playlistTrackerFactory = DefaultHlsPlaylistTracker.FACTORY;
       extractorFactory = HlsExtractorFactory.DEFAULT;
-      minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
       compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
     }
 
@@ -120,52 +127,67 @@ public Factory setExtractorFactory(HlsExtractorFactory extractorFactory) {
       return this;
     }
 
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy}. The default value is created by calling {@link
+     * DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy()}.
+     *
+     * <p>Calling this method overrides any calls to {@link #setMinLoadableRetryCount(int)}.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
+      Assertions.checkState(!isCreateCalled);
+      this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
+      return this;
+    }
+
     /**
      * Sets the minimum number of times to retry if a loading error occurs. The default value is
-     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     * {@link DefaultLoadErrorHandlingPolicy#DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     *
+     * <p>Calling this method is equivalent to calling {@link #setLoadErrorHandlingPolicy} with
+     * {@link DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy(int)
+     * DefaultLoadErrorHandlingPolicy(minLoadableRetryCount)}
      *
      * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     * @deprecated Use {@link #setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy)} instead.
      */
+    @Deprecated
     public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
       Assertions.checkState(!isCreateCalled);
-      this.minLoadableRetryCount = minLoadableRetryCount;
+      this.loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount);
       return this;
     }
 
     /**
-     * Sets the parser to parse HLS playlists. The default is an instance of {@link
-     * HlsPlaylistParser}.
+     * Sets the factory from which playlist parsers will be obtained. The default value is created
+     * by calling {@link DefaultHlsPlaylistParserFactory#DefaultHlsPlaylistParserFactory()}.
      *
-     * <p>Must not be called after calling {@link #setPlaylistTracker} on the same builder.
-     *
-     * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
+     * @param playlistParserFactory An {@link HlsPlaylistParserFactory}.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
      */
-    public Factory setPlaylistParser(ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
+    public Factory setPlaylistParserFactory(HlsPlaylistParserFactory playlistParserFactory) {
       Assertions.checkState(!isCreateCalled);
-      Assertions.checkState(playlistTracker == null, "A playlist tracker has already been set.");
-      this.playlistParser = Assertions.checkNotNull(playlistParser);
+      this.playlistParserFactory = Assertions.checkNotNull(playlistParserFactory);
       return this;
     }
 
     /**
-     * Sets the HLS playlist tracker. The default is an instance of {@link
-     * DefaultHlsPlaylistTracker}. Playlist trackers must not be shared by {@link HlsMediaSource}
-     * instances.
-     *
-     * <p>Must not be called after calling {@link #setPlaylistParser} on the same builder.
+     * Sets the {@link HlsPlaylistTracker} factory. The default value is {@link
+     * DefaultHlsPlaylistTracker#FACTORY}.
      *
-     * @param playlistTracker A tracker for HLS playlists.
+     * @param playlistTrackerFactory A factory for {@link HlsPlaylistTracker} instances.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
      */
-    public Factory setPlaylistTracker(HlsPlaylistTracker playlistTracker) {
+    public Factory setPlaylistTrackerFactory(HlsPlaylistTracker.Factory playlistTrackerFactory) {
       Assertions.checkState(!isCreateCalled);
-      Assertions.checkState(playlistParser == null, "A playlist parser has already been set.");
-      this.playlistTracker = Assertions.checkNotNull(playlistTracker);
+      this.playlistTrackerFactory = Assertions.checkNotNull(playlistTrackerFactory);
       return this;
     }
 
@@ -210,20 +232,14 @@ public Factory setAllowChunklessPreparation(boolean allowChunklessPreparation) {
     @Override
     public HlsMediaSource createMediaSource(Uri playlistUri) {
       isCreateCalled = true;
-      if (playlistTracker == null) {
-        playlistTracker =
-            new DefaultHlsPlaylistTracker(
-                hlsDataSourceFactory,
-                minLoadableRetryCount,
-                playlistParser != null ? playlistParser : new HlsPlaylistParser());
-      }
       return new HlsMediaSource(
           playlistUri,
           hlsDataSourceFactory,
           extractorFactory,
           compositeSequenceableLoaderFactory,
-          minLoadableRetryCount,
-          playlistTracker,
+          loadErrorHandlingPolicy,
+          playlistTrackerFactory.createTracker(
+              hlsDataSourceFactory, loadErrorHandlingPolicy, playlistParserFactory),
           allowChunklessPreparation,
           tag);
     }
@@ -248,22 +264,20 @@ public HlsMediaSource createMediaSource(
     public int[] getSupportedTypes() {
       return new int[] {C.TYPE_HLS};
     }
-  }
 
-  /**
-   * The default minimum number of times to retry loading data prior to failing.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+  }
 
   private final HlsExtractorFactory extractorFactory;
   private final Uri manifestUri;
   private final HlsDataSourceFactory dataSourceFactory;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final boolean allowChunklessPreparation;
   private final HlsPlaylistTracker playlistTracker;
   private final @Nullable Object tag;
 
+  private @Nullable TransferListener mediaTransferListener;
+
   /**
    * @param manifestUri The {@link Uri} of the HLS manifest.
    * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
@@ -274,12 +288,17 @@ public HlsMediaSource createMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public HlsMediaSource(
       Uri manifestUri,
       DataSource.Factory dataSourceFactory,
       Handler eventHandler,
       MediaSourceEventListener eventListener) {
-    this(manifestUri, dataSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
+    this(
+        manifestUri,
+        dataSourceFactory,
+        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT,
+        eventHandler,
         eventListener);
   }
 
@@ -295,6 +314,7 @@ public HlsMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public HlsMediaSource(
       Uri manifestUri,
       DataSource.Factory dataSourceFactory,
@@ -325,6 +345,7 @@ public HlsMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public HlsMediaSource(
       Uri manifestUri,
       HlsDataSourceFactory dataSourceFactory,
@@ -338,9 +359,11 @@ public HlsMediaSource(
         dataSourceFactory,
         extractorFactory,
         new DefaultCompositeSequenceableLoaderFactory(),
-        minLoadableRetryCount,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
         new DefaultHlsPlaylistTracker(
-            dataSourceFactory, minLoadableRetryCount, new HlsPlaylistParser()),
+            dataSourceFactory,
+            new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
+            playlistParser),
         /* allowChunklessPreparation= */ false,
         /* tag= */ null);
     if (eventHandler != null && eventListener != null) {
@@ -353,7 +376,7 @@ private HlsMediaSource(
       HlsDataSourceFactory dataSourceFactory,
       HlsExtractorFactory extractorFactory,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       HlsPlaylistTracker playlistTracker,
       boolean allowChunklessPreparation,
       @Nullable Object tag) {
@@ -361,14 +384,24 @@ private HlsMediaSource(
     this.dataSourceFactory = dataSourceFactory;
     this.extractorFactory = extractorFactory;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.playlistTracker = playlistTracker;
     this.allowChunklessPreparation = allowChunklessPreparation;
     this.tag = tag;
   }
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    this.mediaTransferListener = mediaTransferListener;
     EventDispatcher eventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
     playlistTracker.start(manifestUri, eventDispatcher, /* listener= */ this);
   }
@@ -380,13 +413,13 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    Assertions.checkArgument(id.periodIndex == 0);
     EventDispatcher eventDispatcher = createEventDispatcher(id);
     return new HlsMediaPeriod(
         extractorFactory,
         playlistTracker,
         dataSourceFactory,
-        minLoadableRetryCount,
+        mediaTransferListener,
+        loadErrorHandlingPolicy,
         eventDispatcher,
         allocator,
         compositeSequenceableLoaderFactory,
@@ -400,9 +433,7 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSourceInternal() {
-    if (playlistTracker != null) {
-      playlistTracker.release();
-    }
+    playlistTracker.stop();
   }
 
   @Override
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 705320bdad..39598c4cd8 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -16,17 +16,17 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.os.Handler;
-import android.support.annotation.IntDef;
-import android.util.Log;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
-import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.SampleQueue.UpstreamFormatChangedListener;
@@ -35,19 +35,23 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.Chunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Loads {@link HlsMediaChunk}s obtained from a {@link HlsChunkSource}, and provides
@@ -80,25 +84,17 @@
   public static final int SAMPLE_QUEUE_INDEX_NO_MAPPING_FATAL = -2;
   public static final int SAMPLE_QUEUE_INDEX_NO_MAPPING_NON_FATAL = -3;
 
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({PRIMARY_TYPE_NONE, PRIMARY_TYPE_TEXT, PRIMARY_TYPE_AUDIO, PRIMARY_TYPE_VIDEO})
-  private @interface PrimaryTrackType {}
-
-  private static final int PRIMARY_TYPE_NONE = 0;
-  private static final int PRIMARY_TYPE_TEXT = 1;
-  private static final int PRIMARY_TYPE_AUDIO = 2;
-  private static final int PRIMARY_TYPE_VIDEO = 3;
-
   private final int trackType;
   private final Callback callback;
   private final HlsChunkSource chunkSource;
   private final Allocator allocator;
   private final Format muxedAudioFormat;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final Loader loader;
   private final EventDispatcher eventDispatcher;
   private final HlsChunkSource.HlsChunkHolder nextChunkHolder;
   private final ArrayList<HlsMediaChunk> mediaChunks;
+  private final List<HlsMediaChunk> readOnlyMediaChunks;
   private final Runnable maybeFinishPrepareRunnable;
   private final Runnable onTracksEndedRunnable;
   private final Handler handler;
@@ -110,9 +106,12 @@
   private int audioSampleQueueIndex;
   private boolean videoSampleQueueMappingDone;
   private int videoSampleQueueIndex;
+  private int primarySampleQueueType;
+  private int primarySampleQueueIndex;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
   private int enabledTrackGroupCount;
+  private Format upstreamTrackFormat;
   private Format downstreamTrackFormat;
   private boolean released;
 
@@ -136,6 +135,7 @@
   // Accessed only by the loading thread.
   private boolean tracksEnded;
   private long sampleOffsetUs;
+  private int chunkUid;
 
   /**
    * @param trackType The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
@@ -144,19 +144,24 @@
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    * @param positionUs The position from which to start loading media.
    * @param muxedAudioFormat Optional muxed audio {@link Format} as defined by the master playlist.
-   * @param minLoadableRetryCount The minimum number of times that the source should retry a load
-   *     before propagating an error.
+   * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
    * @param eventDispatcher A dispatcher to notify of events.
    */
-  public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource chunkSource,
-      Allocator allocator, long positionUs, Format muxedAudioFormat, int minLoadableRetryCount,
+  public HlsSampleStreamWrapper(
+      int trackType,
+      Callback callback,
+      HlsChunkSource chunkSource,
+      Allocator allocator,
+      long positionUs,
+      Format muxedAudioFormat,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       EventDispatcher eventDispatcher) {
     this.trackType = trackType;
     this.callback = callback;
     this.chunkSource = chunkSource;
     this.allocator = allocator;
     this.muxedAudioFormat = muxedAudioFormat;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
     loader = new Loader("Loader:HlsSampleStreamWrapper");
     nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
@@ -167,21 +172,10 @@ public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource c
     sampleQueueIsAudioVideoFlags = new boolean[0];
     sampleQueuesEnabledStates = new boolean[0];
     mediaChunks = new ArrayList<>();
+    readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);
     hlsSampleStreams = new ArrayList<>();
-    maybeFinishPrepareRunnable =
-        new Runnable() {
-          @Override
-          public void run() {
-            maybeFinishPrepare();
-          }
-        };
-    onTracksEndedRunnable =
-        new Runnable() {
-          @Override
-          public void run() {
-            onTracksEnded();
-          }
-        };
+    maybeFinishPrepareRunnable = this::maybeFinishPrepare;
+    onTracksEndedRunnable = this::onTracksEnded;
     handler = new Handler();
     lastSeekPositionUs = positionUs;
     pendingResetPositionUs = positionUs;
@@ -334,8 +328,16 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
         boolean primarySampleQueueDirty = false;
         if (!seenFirstTrackSelection) {
           long bufferedDurationUs = positionUs < 0 ? -positionUs : 0;
-          primaryTrackSelection.updateSelectedTrack(positionUs, bufferedDurationUs, C.TIME_UNSET);
-          int chunkIndex = chunkSource.getTrackGroup().indexOf(getLastMediaChunk().trackFormat);
+          HlsMediaChunk lastMediaChunk = getLastMediaChunk();
+          MediaChunkIterator[] mediaChunkIterators =
+              chunkSource.createMediaChunkIterators(lastMediaChunk, positionUs);
+          primaryTrackSelection.updateSelectedTrack(
+              positionUs,
+              bufferedDurationUs,
+              C.TIME_UNSET,
+              readOnlyMediaChunks,
+              mediaChunkIterators);
+          int chunkIndex = chunkSource.getTrackGroup().indexOf(lastMediaChunk.trackFormat);
           if (primaryTrackSelection.getSelectedIndexInTrackGroup() != chunkIndex) {
             // This is the first selection and the chunk loaded during preparation does not match
             // the initially selected format.
@@ -368,7 +370,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
   }
 
   public void discardBuffer(long positionUs, boolean toKeyframe) {
-    if (!sampleQueuesBuilt) {
+    if (!sampleQueuesBuilt || isPendingReset()) {
       return;
     }
     int sampleQueueCount = sampleQueues.length;
@@ -387,11 +389,18 @@ public void discardBuffer(long positionUs, boolean toKeyframe) {
    */
   public boolean seekToUs(long positionUs, boolean forceReset) {
     lastSeekPositionUs = positionUs;
-    // If we're not forced to reset nor have a pending reset, see if we can seek within the buffer.
-    if (sampleQueuesBuilt && !forceReset && !isPendingReset() && seekInsideBufferUs(positionUs)) {
+    if (isPendingReset()) {
+      // A reset is already pending. We only need to update its position.
+      pendingResetPositionUs = positionUs;
+      return true;
+    }
+
+    // If we're not forced to reset, try and seek within the buffer.
+    if (sampleQueuesBuilt && !forceReset && seekInsideBufferUs(positionUs)) {
       return false;
     }
-    // We were unable to seek within the buffer, so need to reset.
+
+    // We can't seek inside the buffer, and so need to reset.
     pendingResetPositionUs = positionUs;
     loadingFinished = false;
     mediaChunks.clear();
@@ -426,8 +435,8 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
     chunkSource.setIsTimestampMaster(isTimestampMaster);
   }
 
-  public boolean onPlaylistError(HlsUrl url, boolean shouldBlacklist) {
-    return chunkSource.onPlaylistError(url, shouldBlacklist);
+  public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
+    return chunkSource.onPlaylistError(url, blacklistDurationMs);
   }
 
   // SampleStream implementation.
@@ -454,9 +463,7 @@ public int readData(int sampleQueueIndex, FormatHolder formatHolder, DecoderInpu
           && finishedReadingChunk(mediaChunks.get(discardToMediaChunkIndex))) {
         discardToMediaChunkIndex++;
       }
-      if (discardToMediaChunkIndex > 0) {
-        Util.removeRange(mediaChunks, 0, discardToMediaChunkIndex);
-      }
+      Util.removeRange(mediaChunks, 0, discardToMediaChunkIndex);
       HlsMediaChunk currentChunk = mediaChunks.get(0);
       Format trackFormat = currentChunk.trackFormat;
       if (!trackFormat.equals(downstreamTrackFormat)) {
@@ -467,8 +474,23 @@ public int readData(int sampleQueueIndex, FormatHolder formatHolder, DecoderInpu
       downstreamTrackFormat = trackFormat;
     }
 
-    return sampleQueues[sampleQueueIndex].read(formatHolder, buffer, requireFormat, loadingFinished,
-        lastSeekPositionUs);
+    int result =
+        sampleQueues[sampleQueueIndex].read(
+            formatHolder, buffer, requireFormat, loadingFinished, lastSeekPositionUs);
+    if (result == C.RESULT_FORMAT_READ && sampleQueueIndex == primarySampleQueueIndex) {
+      // Fill in primary sample format with information from the track format.
+      int chunkUid = sampleQueues[sampleQueueIndex].peekSourceId();
+      int chunkIndex = 0;
+      while (chunkIndex < mediaChunks.size() && mediaChunks.get(chunkIndex).uid != chunkUid) {
+        chunkIndex++;
+      }
+      Format trackFormat =
+          chunkIndex < mediaChunks.size()
+              ? mediaChunks.get(chunkIndex).trackFormat
+              : upstreamTrackFormat;
+      formatHolder.format = formatHolder.format.copyWithManifestFormatInfo(trackFormat);
+    }
+    return result;
   }
 
   public int skipData(int sampleQueueIndex, long positionUs) {
@@ -526,16 +548,20 @@ public boolean continueLoading(long positionUs) {
       return false;
     }
 
-    HlsMediaChunk previousChunk;
+    List<HlsMediaChunk> chunkQueue;
     long loadPositionUs;
     if (isPendingReset()) {
-      previousChunk = null;
+      chunkQueue = Collections.emptyList();
       loadPositionUs = pendingResetPositionUs;
     } else {
-      previousChunk = getLastMediaChunk();
-      loadPositionUs = previousChunk.endTimeUs;
+      chunkQueue = readOnlyMediaChunks;
+      HlsMediaChunk lastMediaChunk = getLastMediaChunk();
+      loadPositionUs =
+          lastMediaChunk.isLoadCompleted()
+              ? lastMediaChunk.endTimeUs
+              : Math.max(lastSeekPositionUs, lastMediaChunk.startTimeUs);
     }
-    chunkSource.getNextChunk(previousChunk, positionUs, loadPositionUs, nextChunkHolder);
+    chunkSource.getNextChunk(positionUs, loadPositionUs, chunkQueue, nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
@@ -559,11 +585,21 @@ public boolean continueLoading(long positionUs) {
       HlsMediaChunk mediaChunk = (HlsMediaChunk) loadable;
       mediaChunk.init(this);
       mediaChunks.add(mediaChunk);
+      upstreamTrackFormat = mediaChunk.trackFormat;
     }
-    long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
-    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs);
+    long elapsedRealtimeMs =
+        loader.startLoading(
+            loadable, this, loadErrorHandlingPolicy.getMinimumLoadableRetryCount(loadable.type));
+    eventDispatcher.loadStarted(
+        loadable.dataSpec,
+        loadable.type,
+        trackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs);
     return true;
   }
 
@@ -577,9 +613,20 @@ public void reevaluateBuffer(long positionUs) {
   @Override
   public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
     chunkSource.onChunkLoadCompleted(loadable);
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+    eventDispatcher.loadCompleted(
+        loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
+        loadable.type,
+        trackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.bytesLoaded());
     if (!prepared) {
       continueLoading(lastSeekPositionUs);
     } else {
@@ -590,9 +637,20 @@ public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDur
   @Override
   public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
       boolean released) {
-    eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+    eventDispatcher.loadCanceled(
+        loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
+        loadable.type,
+        trackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.bytesLoaded());
     if (!released) {
       resetSampleQueues();
       if (enabledTrackGroupCount > 0) {
@@ -602,36 +660,68 @@ public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDura
   }
 
   @Override
-  public @Loader.RetryAction int onLoadError(
-      Chunk loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error) {
+  public LoadErrorAction onLoadError(
+      Chunk loadable,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      IOException error,
+      int errorCount) {
     long bytesLoaded = loadable.bytesLoaded();
     boolean isMediaChunk = isMediaChunk(loadable);
-    boolean cancelable = !isMediaChunk || bytesLoaded == 0;
-    boolean canceled = false;
-    if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
-      if (isMediaChunk) {
+    boolean blacklistSucceeded = false;
+    LoadErrorAction loadErrorAction;
+
+    long blacklistDurationMs =
+        loadErrorHandlingPolicy.getBlacklistDurationMsFor(
+            loadable.type, loadDurationMs, error, errorCount);
+    if (blacklistDurationMs != C.TIME_UNSET) {
+      blacklistSucceeded = chunkSource.maybeBlacklistTrack(loadable, blacklistDurationMs);
+    }
+
+    if (blacklistSucceeded) {
+      if (isMediaChunk && bytesLoaded == 0) {
         HlsMediaChunk removed = mediaChunks.remove(mediaChunks.size() - 1);
         Assertions.checkState(removed == loadable);
         if (mediaChunks.isEmpty()) {
           pendingResetPositionUs = lastSeekPositionUs;
         }
       }
-      canceled = true;
+      loadErrorAction = Loader.DONT_RETRY;
+    } else /* did not blacklist */ {
+      long retryDelayMs =
+          loadErrorHandlingPolicy.getRetryDelayMsFor(
+              loadable.type, loadDurationMs, error, errorCount);
+      loadErrorAction =
+          retryDelayMs != C.TIME_UNSET
+              ? Loader.createRetryAction(/* resetErrorCount= */ false, retryDelayMs)
+              : Loader.DONT_RETRY_FATAL;
     }
-    eventDispatcher.loadError(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded(), error,
-        canceled);
-    if (canceled) {
+
+    eventDispatcher.loadError(
+        loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
+        loadable.type,
+        trackType,
+        loadable.trackFormat,
+        loadable.trackSelectionReason,
+        loadable.trackSelectionData,
+        loadable.startTimeUs,
+        loadable.endTimeUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        bytesLoaded,
+        error,
+        /* wasCanceled= */ !loadErrorAction.isRetry());
+
+    if (blacklistSucceeded) {
       if (!prepared) {
         continueLoading(lastSeekPositionUs);
       } else {
         callback.onContinueLoadingRequested(this);
       }
-      return Loader.DONT_RETRY;
-    } else {
-      return error instanceof ParserException ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
     }
+    return loadErrorAction;
   }
 
   // Called by the consuming thread, but only when there is no loading thread.
@@ -650,6 +740,7 @@ public void init(int chunkUid, boolean shouldSpliceIn, boolean reusingExtractor)
       audioSampleQueueMappingDone = false;
       videoSampleQueueMappingDone = false;
     }
+    this.chunkUid = chunkUid;
     for (SampleQueue sampleQueue : sampleQueues) {
       sampleQueue.sourceId(chunkUid);
     }
@@ -703,8 +794,9 @@ public TrackOutput track(int id, int type) {
         return createDummyTrackOutput(id, type);
       }
     }
-    SampleQueue trackOutput = new SampleQueue(allocator);
+    SampleQueue trackOutput = new PrivTimestampStrippingSampleQueue(allocator);
     trackOutput.setSampleOffsetUs(sampleOffsetUs);
+    trackOutput.sourceId(chunkUid);
     trackOutput.setUpstreamFormatChangeListener(this);
     sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
     sampleQueueTrackIds[trackCount] = id;
@@ -721,6 +813,10 @@ public TrackOutput track(int id, int type) {
       videoSampleQueueMappingDone = true;
       videoSampleQueueIndex = trackCount;
     }
+    if (getTrackTypeScore(type) > getTrackTypeScore(primarySampleQueueType)) {
+      primarySampleQueueIndex = trackCount;
+      primarySampleQueueType = type;
+    }
     sampleQueuesEnabledStates = Arrays.copyOf(sampleQueuesEnabledStates, trackCount + 1);
     return trackOutput;
   }
@@ -858,22 +954,22 @@ private void mapSampleQueuesToMatchTrackGroups() {
   private void buildTracksFromSampleStreams() {
     // Iterate through the extractor tracks to discover the "primary" track type, and the index
     // of the single track of this type.
-    @PrimaryTrackType int primaryExtractorTrackType = PRIMARY_TYPE_NONE;
+    int primaryExtractorTrackType = C.TRACK_TYPE_NONE;
     int primaryExtractorTrackIndex = C.INDEX_UNSET;
     int extractorTrackCount = sampleQueues.length;
     for (int i = 0; i < extractorTrackCount; i++) {
       String sampleMimeType = sampleQueues[i].getUpstreamFormat().sampleMimeType;
-      @PrimaryTrackType int trackType;
+      int trackType;
       if (MimeTypes.isVideo(sampleMimeType)) {
-        trackType = PRIMARY_TYPE_VIDEO;
+        trackType = C.TRACK_TYPE_VIDEO;
       } else if (MimeTypes.isAudio(sampleMimeType)) {
-        trackType = PRIMARY_TYPE_AUDIO;
+        trackType = C.TRACK_TYPE_AUDIO;
       } else if (MimeTypes.isText(sampleMimeType)) {
-        trackType = PRIMARY_TYPE_TEXT;
+        trackType = C.TRACK_TYPE_TEXT;
       } else {
-        trackType = PRIMARY_TYPE_NONE;
+        trackType = C.TRACK_TYPE_NONE;
       }
-      if (trackType > primaryExtractorTrackType) {
+      if (getTrackTypeScore(trackType) > getTrackTypeScore(primaryExtractorTrackType)) {
         primaryExtractorTrackType = trackType;
         primaryExtractorTrackIndex = i;
       } else if (trackType == primaryExtractorTrackType
@@ -900,14 +996,21 @@ private void buildTracksFromSampleStreams() {
       Format sampleFormat = sampleQueues[i].getUpstreamFormat();
       if (i == primaryExtractorTrackIndex) {
         Format[] formats = new Format[chunkSourceTrackCount];
-        for (int j = 0; j < chunkSourceTrackCount; j++) {
-          formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat, true);
+        if (chunkSourceTrackCount == 1) {
+          formats[0] = sampleFormat.copyWithManifestFormatInfo(chunkSourceTrackGroup.getFormat(0));
+        } else {
+          for (int j = 0; j < chunkSourceTrackCount; j++) {
+            formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat, true);
+          }
         }
         trackGroups[i] = new TrackGroup(formats);
         primaryTrackGroupIndex = i;
       } else {
-        Format trackFormat = primaryExtractorTrackType == PRIMARY_TYPE_VIDEO
-            && MimeTypes.isAudio(sampleFormat.sampleMimeType) ? muxedAudioFormat : null;
+        Format trackFormat =
+            primaryExtractorTrackType == C.TRACK_TYPE_VIDEO
+                    && MimeTypes.isAudio(sampleFormat.sampleMimeType)
+                ? muxedAudioFormat
+                : null;
         trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat, false));
       }
     }
@@ -949,7 +1052,28 @@ private boolean seekInsideBufferUs(long positionUs) {
   }
 
   /**
-   * Derives a track format using master playlist and sample format information.
+   * Scores a track type. Where multiple tracks are muxed into a container, the track with the
+   * highest score is the primary track.
+   *
+   * @param trackType The track type.
+   * @return The score.
+   */
+  private static int getTrackTypeScore(int trackType) {
+    switch (trackType) {
+      case C.TRACK_TYPE_VIDEO:
+        return 3;
+      case C.TRACK_TYPE_AUDIO:
+        return 2;
+      case C.TRACK_TYPE_TEXT:
+        return 1;
+      default:
+        return 0;
+    }
+  }
+
+  /**
+   * Derives a track sample format from the corresponding format in the master playlist, and a
+   * sample format that may have been obtained from a chunk belonging to a different track.
    *
    * @param playlistFormat The format information obtained from the master playlist.
    * @param sampleFormat The format information obtained from the samples.
@@ -971,6 +1095,7 @@ private static Format deriveFormat(
     }
     return sampleFormat.copyWithContainerInfo(
         playlistFormat.id,
+        playlistFormat.label,
         mimeType,
         codecs,
         bitrate,
@@ -1004,4 +1129,53 @@ private static DummyTrackOutput createDummyTrackOutput(int id, int type) {
     Log.w(TAG, "Unmapped track with id " + id + " of type " + type);
     return new DummyTrackOutput();
   }
+
+  private static final class PrivTimestampStrippingSampleQueue extends SampleQueue {
+
+    public PrivTimestampStrippingSampleQueue(Allocator allocator) {
+      super(allocator);
+    }
+
+    @Override
+    public void format(Format format) {
+      super.format(format.copyWithMetadata(getAdjustedMetadata(format.metadata)));
+    }
+
+    /**
+     * Strips the private timestamp frame from metadata, if present. See:
+     * https://github.com/google/ExoPlayer/issues/5063
+     */
+    @Nullable
+    private Metadata getAdjustedMetadata(@Nullable Metadata metadata) {
+      if (metadata == null) {
+        return null;
+      }
+      int length = metadata.length();
+      int transportStreamTimestampMetadataIndex = C.INDEX_UNSET;
+      for (int i = 0; i < length; i++) {
+        Metadata.Entry metadataEntry = metadata.get(i);
+        if (metadataEntry instanceof PrivFrame) {
+          PrivFrame privFrame = (PrivFrame) metadataEntry;
+          if (HlsMediaChunk.PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
+            transportStreamTimestampMetadataIndex = i;
+            break;
+          }
+        }
+      }
+      if (transportStreamTimestampMetadataIndex == C.INDEX_UNSET) {
+        return metadata;
+      }
+      if (length == 1) {
+        return null;
+      }
+      Metadata.Entry[] newMetadataEntries = new Metadata.Entry[length - 1];
+      for (int i = 0; i < length; i++) {
+        if (i != transportStreamTimestampMetadataIndex) {
+          int newIndex = i < transportStreamTimestampMetadataIndex ? i : i - 1;
+          newMetadataEntries[newIndex] = metadata.get(i);
+        }
+      }
+      return new Metadata(newMetadataEntries);
+    }
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
index 0b8f7f36a6..665f2e0570 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
@@ -25,7 +25,6 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.text.webvtt.WebvttParserUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -37,16 +36,18 @@
 
 /**
  * A special purpose extractor for WebVTT content in HLS.
- * <p>
- * This extractor passes through non-empty WebVTT files untouched, however derives the correct
+ *
+ * <p>This extractor passes through non-empty WebVTT files untouched, however derives the correct
  * sample timestamp for each by sniffing the X-TIMESTAMP-MAP header along with the start timestamp
  * of the first cue header. Empty WebVTT files are not passed through, since it's not possible to
  * derive a sample timestamp in this case.
  */
-/* package */ final class WebvttExtractor implements Extractor {
+public final class WebvttExtractor implements Extractor {
 
   private static final Pattern LOCAL_TIMESTAMP = Pattern.compile("LOCAL:([^,]+)");
   private static final Pattern MEDIA_TIMESTAMP = Pattern.compile("MPEGTS:(\\d+)");
+  private static final int HEADER_MIN_LENGTH = 6 /* "WEBVTT" */;
+  private static final int HEADER_MAX_LENGTH = 3 /* optional Byte Order Mark */ + HEADER_MIN_LENGTH;
 
   private final String language;
   private final TimestampAdjuster timestampAdjuster;
@@ -68,8 +69,21 @@ public WebvttExtractor(String language, TimestampAdjuster timestampAdjuster) {
 
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-    // This extractor is only used for the HLS use case, which should not call this method.
-    throw new IllegalStateException();
+    // Check whether there is a header without BOM.
+    input.peekFully(
+        sampleData, /* offset= */ 0, /* length= */ HEADER_MIN_LENGTH, /* allowEndOfInput= */ false);
+    sampleDataWrapper.reset(sampleData, HEADER_MIN_LENGTH);
+    if (WebvttParserUtil.isWebvttHeaderLine(sampleDataWrapper)) {
+      return true;
+    }
+    // The header did not match, try including the BOM.
+    input.peekFully(
+        sampleData,
+        /* offset= */ HEADER_MIN_LENGTH,
+        HEADER_MAX_LENGTH - HEADER_MIN_LENGTH,
+        /* allowEndOfInput= */ false);
+    sampleDataWrapper.reset(sampleData, HEADER_MAX_LENGTH);
+    return WebvttParserUtil.isWebvttHeaderLine(sampleDataWrapper);
   }
 
   @Override
@@ -118,11 +132,7 @@ private void processSample() throws ParserException {
     ParsableByteArray webvttData = new ParsableByteArray(sampleData);
 
     // Validate the first line of the header.
-    try {
-      WebvttParserUtil.validateWebvttHeaderLine(webvttData);
-    } catch (SubtitleDecoderException e) {
-      throw new ParserException(e);
-    }
+    WebvttParserUtil.validateWebvttHeaderLine(webvttData);
 
     // Defaults to use if the header doesn't contain an X-TIMESTAMP-MAP header.
     long vttTimestampUs = 0;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java
index e56bf66efd..c54a9a7dd3 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java
@@ -20,56 +20,78 @@
 import com.google.android.exoplayer2.offline.DownloadAction;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.SegmentDownloadAction;
-import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;
+import com.google.android.exoplayer2.offline.StreamKey;
 import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 
 /** An action to download or remove downloaded HLS streams. */
-public final class HlsDownloadAction extends SegmentDownloadAction<RenditionKey> {
+public final class HlsDownloadAction extends SegmentDownloadAction {
 
   private static final String TYPE = "hls";
-  private static final int VERSION = 0;
+  private static final int VERSION = 1;
 
   public static final Deserializer DESERIALIZER =
-      new SegmentDownloadActionDeserializer<RenditionKey>(TYPE, VERSION) {
+      new SegmentDownloadActionDeserializer(TYPE, VERSION) {
 
         @Override
-        protected RenditionKey readKey(DataInputStream input) throws IOException {
+        protected StreamKey readKey(int version, DataInputStream input) throws IOException {
+          if (version > 0) {
+            return super.readKey(version, input);
+          }
           int renditionGroup = input.readInt();
           int trackIndex = input.readInt();
-          return new RenditionKey(renditionGroup, trackIndex);
+          return new StreamKey(renditionGroup, trackIndex);
         }
 
         @Override
         protected DownloadAction createDownloadAction(
-            Uri uri, boolean isRemoveAction, byte[] data, List<RenditionKey> keys) {
+            Uri uri, boolean isRemoveAction, byte[] data, List<StreamKey> keys) {
           return new HlsDownloadAction(uri, isRemoveAction, data, keys);
         }
       };
 
+  /**
+   * Creates a HLS download action.
+   *
+   * @param uri The URI of the media to be downloaded.
+   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
+   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded.
+   */
+  public static HlsDownloadAction createDownloadAction(
+      Uri uri, @Nullable byte[] data, List<StreamKey> keys) {
+    return new HlsDownloadAction(uri, /* isRemoveAction= */ false, data, keys);
+  }
+
+  /**
+   * Creates a HLS remove action.
+   *
+   * @param uri The URI of the media to be removed.
+   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
+   */
+  public static HlsDownloadAction createRemoveAction(Uri uri, @Nullable byte[] data) {
+    return new HlsDownloadAction(uri, /* isRemoveAction= */ true, data, Collections.emptyList());
+  }
+
   /**
    * @param uri The HLS playlist URI.
    * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
    * @param data Optional custom data for this action.
    * @param keys Keys of renditions to be downloaded. If empty, all renditions are downloaded. If
    *     {@code removeAction} is true, {@code keys} must empty.
+   * @deprecated Use {@link #createDownloadAction(Uri, byte[], List)} or {@link
+   *     #createRemoveAction(Uri, byte[])}.
    */
+  @Deprecated
   public HlsDownloadAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<RenditionKey> keys) {
+      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<StreamKey> keys) {
     super(TYPE, VERSION, uri, isRemoveAction, data, keys);
   }
 
   @Override
-  protected HlsDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
+  public HlsDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
     return new HlsDownloader(uri, keys, constructorHelper);
   }
 
-  @Override
-  protected void writeKey(DataOutputStream output, RenditionKey key) throws IOException {
-    output.writeInt(key.type);
-    output.writeInt(key.trackIndex);
-  }
-
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
index 7fe03f6cb3..fcbe06993e 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
@@ -17,8 +17,10 @@
 
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.offline.TrackKey;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -26,14 +28,12 @@
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
-import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
@@ -44,7 +44,7 @@
   private final DataSource.Factory manifestDataSourceFactory;
 
   private @MonotonicNonNull HlsPlaylist playlist;
-  private int[] renditionTypes;
+  private int[] renditionGroups;
 
   public HlsDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory) {
     this.uri = uri;
@@ -54,7 +54,7 @@ public HlsDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory)
   @Override
   protected void prepareInternal() throws IOException {
     DataSource dataSource = manifestDataSourceFactory.createDataSource();
-    playlist = ParsingLoadable.load(dataSource, new HlsPlaylistParser(), uri);
+    playlist = ParsingLoadable.load(dataSource, new HlsPlaylistParser(), uri, C.DATA_TYPE_MANIFEST);
   }
 
   /** Returns the HLS playlist. Must not be called until after preparation completes. */
@@ -73,24 +73,24 @@ public int getPeriodCount() {
   public TrackGroupArray getTrackGroups(int periodIndex) {
     Assertions.checkNotNull(playlist);
     if (playlist instanceof HlsMediaPlaylist) {
-      renditionTypes = new int[0];
+      renditionGroups = new int[0];
       return TrackGroupArray.EMPTY;
     }
     // TODO: Generate track groups as in playback. Reverse the mapping in getDownloadAction.
     HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
     TrackGroup[] trackGroups = new TrackGroup[3];
-    renditionTypes = new int[3];
+    renditionGroups = new int[3];
     int trackGroupIndex = 0;
     if (!masterPlaylist.variants.isEmpty()) {
-      renditionTypes[trackGroupIndex] = RenditionKey.TYPE_VARIANT;
+      renditionGroups[trackGroupIndex] = HlsMasterPlaylist.GROUP_INDEX_VARIANT;
       trackGroups[trackGroupIndex++] = new TrackGroup(toFormats(masterPlaylist.variants));
     }
     if (!masterPlaylist.audios.isEmpty()) {
-      renditionTypes[trackGroupIndex] = RenditionKey.TYPE_AUDIO;
+      renditionGroups[trackGroupIndex] = HlsMasterPlaylist.GROUP_INDEX_AUDIO;
       trackGroups[trackGroupIndex++] = new TrackGroup(toFormats(masterPlaylist.audios));
     }
     if (!masterPlaylist.subtitles.isEmpty()) {
-      renditionTypes[trackGroupIndex] = RenditionKey.TYPE_SUBTITLE;
+      renditionGroups[trackGroupIndex] = HlsMasterPlaylist.GROUP_INDEX_SUBTITLE;
       trackGroups[trackGroupIndex++] = new TrackGroup(toFormats(masterPlaylist.subtitles));
     }
     return new TrackGroupArray(Arrays.copyOf(trackGroups, trackGroupIndex));
@@ -98,15 +98,14 @@ public TrackGroupArray getTrackGroups(int periodIndex) {
 
   @Override
   public HlsDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    Assertions.checkNotNull(renditionTypes);
-    return new HlsDownloadAction(
-        uri, /* isRemoveAction= */ false, data, toRenditionKeys(trackKeys, renditionTypes));
+    Assertions.checkNotNull(renditionGroups);
+    return HlsDownloadAction.createDownloadAction(
+        uri, data, toStreamKeys(trackKeys, renditionGroups));
   }
 
   @Override
   public HlsDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return new HlsDownloadAction(
-        uri, /* isRemoveAction= */ true, data, Collections.<RenditionKey>emptyList());
+    return HlsDownloadAction.createRemoveAction(uri, data);
   }
 
   private static Format[] toFormats(List<HlsMasterPlaylist.HlsUrl> hlsUrls) {
@@ -117,11 +116,11 @@ public HlsDownloadAction getRemoveAction(@Nullable byte[] data) {
     return formats;
   }
 
-  private static List<RenditionKey> toRenditionKeys(List<TrackKey> trackKeys, int[] groups) {
-    List<RenditionKey> representationKeys = new ArrayList<>(trackKeys.size());
+  private static List<StreamKey> toStreamKeys(List<TrackKey> trackKeys, int[] groups) {
+    List<StreamKey> representationKeys = new ArrayList<>(trackKeys.size());
     for (int i = 0; i < trackKeys.size(); i++) {
       TrackKey trackKey = trackKeys.get(i);
-      representationKeys.add(new RenditionKey(groups[trackKey.groupIndex], trackKey.trackIndex));
+      representationKeys.add(new StreamKey(groups[trackKey.groupIndex], trackKey.trackIndex));
     }
     return representationKeys;
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
index bd59eed447..85f41df359 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
@@ -19,12 +19,12 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.SegmentDownloader;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
-import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
@@ -48,7 +48,7 @@
  * HlsDownloader hlsDownloader =
  *     new HlsDownloader(
  *         playlistUri,
- *         Collections.singletonList(new RenditionKey(RenditionKey.TYPE_VARIANT, 0)),
+ *         Collections.singletonList(new StreamKey(HlsMasterPlaylist.GROUP_INDEX_VARIANT, 0)),
  *         constructorHelper);
  * // Perform the download.
  * hlsDownloader.download();
@@ -57,19 +57,17 @@
  *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
  * }</pre>
  */
-public final class HlsDownloader extends SegmentDownloader<HlsPlaylist, RenditionKey> {
+public final class HlsDownloader extends SegmentDownloader<HlsPlaylist> {
 
   /**
    * @param playlistUri The {@link Uri} of the playlist to be downloaded.
-   * @param renditionKeys Keys defining which renditions in the playlist should be selected for
+   * @param streamKeys Keys defining which renditions in the playlist should be selected for
    *     download. If empty, all renditions are downloaded.
    * @param constructorHelper A {@link DownloaderConstructorHelper} instance.
    */
   public HlsDownloader(
-      Uri playlistUri,
-      List<RenditionKey> renditionKeys,
-      DownloaderConstructorHelper constructorHelper) {
-    super(playlistUri, renditionKeys, constructorHelper);
+      Uri playlistUri, List<StreamKey> streamKeys, DownloaderConstructorHelper constructorHelper) {
+    super(playlistUri, streamKeys, constructorHelper);
   }
 
   @Override
@@ -120,10 +118,7 @@ protected HlsPlaylist getManifest(DataSource dataSource, Uri uri) throws IOExcep
   }
 
   private static HlsPlaylist loadManifest(DataSource dataSource, Uri uri) throws IOException {
-    ParsingLoadable<HlsPlaylist> loadable =
-        new ParsingLoadable<>(dataSource, uri, C.DATA_TYPE_MANIFEST, new HlsPlaylistParser());
-    loadable.load();
-    return loadable.getResult();
+    return ParsingLoadable.load(dataSource, new HlsPlaylistParser(), uri, C.DATA_TYPE_MANIFEST);
   }
 
   private static void addSegment(
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java
new file mode 100644
index 0000000000..9058980c73
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import com.google.android.exoplayer2.offline.FilteringManifestParser;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import java.util.Collections;
+import java.util.List;
+
+/** Default implementation for {@link HlsPlaylistParserFactory}. */
+public final class DefaultHlsPlaylistParserFactory implements HlsPlaylistParserFactory {
+
+  private final List<StreamKey> streamKeys;
+
+  /** Creates an instance that does not filter any parsing results. */
+  public DefaultHlsPlaylistParserFactory() {
+    this(Collections.emptyList());
+  }
+
+  /**
+   * Creates an instance that filters the parsing results using the given {@code streamKeys}.
+   *
+   * @param streamKeys See {@link
+   *     FilteringManifestParser#FilteringManifestParser(ParsingLoadable.Parser, List)}.
+   */
+  public DefaultHlsPlaylistParserFactory(List<StreamKey> streamKeys) {
+    this.streamKeys = streamKeys;
+  }
+
+  @Override
+  public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser() {
+    return new FilteringManifestParser<>(new HlsPlaylistParser(), streamKeys);
+  }
+
+  @Override
+  public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser(
+      HlsMasterPlaylist masterPlaylist) {
+    return new FilteringManifestParser<>(new HlsPlaylistParser(masterPlaylist), streamKeys);
+  }
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
index 014a302de7..4269b66d30 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
@@ -18,15 +18,17 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
-import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
 import com.google.android.exoplayer2.source.hls.HlsDataSourceFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.UriUtil;
@@ -39,6 +41,9 @@
 public final class DefaultHlsPlaylistTracker
     implements HlsPlaylistTracker, Loader.Callback<ParsingLoadable<HlsPlaylist>> {
 
+  /** Factory for {@link DefaultHlsPlaylistTracker} instances. */
+  public static final Factory FACTORY = DefaultHlsPlaylistTracker::new;
+
   /**
    * Coefficient applied on the target duration of a playlist to determine the amount of time after
    * which an unchanging playlist is considered stuck.
@@ -46,35 +51,51 @@
   private static final double PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT = 3.5;
 
   private final HlsDataSourceFactory dataSourceFactory;
-  private final ParsingLoadable.Parser<HlsPlaylist> playlistParser;
-  private final int minRetryCount;
+  private final HlsPlaylistParserFactory playlistParserFactory;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
   private final List<PlaylistEventListener> listeners;
 
-  private EventDispatcher eventDispatcher;
-  private Loader initialPlaylistLoader;
-  private Handler playlistRefreshHandler;
-  private PrimaryPlaylistListener primaryPlaylistListener;
-  private HlsMasterPlaylist masterPlaylist;
-  private HlsUrl primaryHlsUrl;
-  private HlsMediaPlaylist primaryUrlSnapshot;
+  private @Nullable ParsingLoadable.Parser<HlsPlaylist> mediaPlaylistParser;
+  private @Nullable EventDispatcher eventDispatcher;
+  private @Nullable Loader initialPlaylistLoader;
+  private @Nullable Handler playlistRefreshHandler;
+  private @Nullable PrimaryPlaylistListener primaryPlaylistListener;
+  private @Nullable HlsMasterPlaylist masterPlaylist;
+  private @Nullable HlsUrl primaryHlsUrl;
+  private @Nullable HlsMediaPlaylist primaryUrlSnapshot;
   private boolean isLive;
   private long initialStartTimeUs;
 
   /**
    * @param dataSourceFactory A factory for {@link DataSource} instances.
-   * @param minRetryCount The minimum number of times loads must be retried before {@link
-   *     #maybeThrowPlaylistRefreshError(HlsUrl)} and {@link
-   *     #maybeThrowPrimaryPlaylistRefreshError()} propagate any loading errors.
+   * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
    * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
+   * @deprecated Use {@link #DefaultHlsPlaylistTracker(HlsDataSourceFactory,
+   *     LoadErrorHandlingPolicy, HlsPlaylistParserFactory)} instead. Using this constructor
+   *     prevents support for attributes that are carried over from the master playlist to the media
+   *     playlists.
    */
+  @Deprecated
   public DefaultHlsPlaylistTracker(
       HlsDataSourceFactory dataSourceFactory,
-      int minRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
+    this(dataSourceFactory, loadErrorHandlingPolicy, createFixedFactory(playlistParser));
+  }
+
+  /**
+   * @param dataSourceFactory A factory for {@link DataSource} instances.
+   * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
+   * @param playlistParserFactory An {@link HlsPlaylistParserFactory}.
+   */
+  public DefaultHlsPlaylistTracker(
+      HlsDataSourceFactory dataSourceFactory,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
+      HlsPlaylistParserFactory playlistParserFactory) {
     this.dataSourceFactory = dataSourceFactory;
-    this.minRetryCount = minRetryCount;
-    this.playlistParser = playlistParser;
+    this.playlistParserFactory = playlistParserFactory;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     listeners = new ArrayList<>();
     playlistBundles = new IdentityHashMap<>();
     initialStartTimeUs = C.TIME_UNSET;
@@ -95,17 +116,22 @@ public void start(
             dataSourceFactory.createDataSource(C.DATA_TYPE_MANIFEST),
             initialPlaylistUri,
             C.DATA_TYPE_MANIFEST,
-            playlistParser);
+            playlistParserFactory.createPlaylistParser());
     Assertions.checkState(initialPlaylistLoader == null);
     initialPlaylistLoader = new Loader("DefaultHlsPlaylistTracker:MasterPlaylist");
     long elapsedRealtime =
-        initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
+        initialPlaylistLoader.startLoading(
+            masterPlaylistLoadable,
+            this,
+            loadErrorHandlingPolicy.getMinimumLoadableRetryCount(masterPlaylistLoadable.type));
     eventDispatcher.loadStarted(
-        masterPlaylistLoadable.dataSpec, masterPlaylistLoadable.type, elapsedRealtime);
+        masterPlaylistLoadable.dataSpec,
+        masterPlaylistLoadable.type,
+        elapsedRealtime);
   }
 
   @Override
-  public void release() {
+  public void stop() {
     primaryHlsUrl = null;
     primaryUrlSnapshot = null;
     masterPlaylist = null;
@@ -131,14 +157,14 @@ public void removeListener(PlaylistEventListener listener) {
   }
 
   @Override
-  public HlsMasterPlaylist getMasterPlaylist() {
+  public @Nullable HlsMasterPlaylist getMasterPlaylist() {
     return masterPlaylist;
   }
 
   @Override
-  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
+  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url, boolean isForPlayback) {
     HlsMediaPlaylist snapshot = playlistBundles.get(url).getPlaylistSnapshot();
-    if (snapshot != null) {
+    if (snapshot != null && isForPlayback) {
       maybeSetPrimaryUrl(url);
     }
     return snapshot;
@@ -193,6 +219,7 @@ public void onLoadCompleted(
       masterPlaylist = (HlsMasterPlaylist) result;
     }
     this.masterPlaylist = masterPlaylist;
+    mediaPlaylistParser = playlistParserFactory.createPlaylistParser(masterPlaylist);
     primaryHlsUrl = masterPlaylist.variants.get(0);
     ArrayList<HlsUrl> urls = new ArrayList<>();
     urls.addAll(masterPlaylist.variants);
@@ -202,12 +229,14 @@ public void onLoadCompleted(
     MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
     if (isMediaPlaylist) {
       // We don't need to load the playlist again. We can use the same result.
-      primaryBundle.processLoadedPlaylist((HlsMediaPlaylist) result);
+      primaryBundle.processLoadedPlaylist((HlsMediaPlaylist) result, loadDurationMs);
     } else {
       primaryBundle.loadPlaylist();
     }
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         C.DATA_TYPE_MANIFEST,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -222,6 +251,8 @@ public void onLoadCanceled(
       boolean released) {
     eventDispatcher.loadCanceled(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         C.DATA_TYPE_MANIFEST,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -229,21 +260,29 @@ public void onLoadCanceled(
   }
 
   @Override
-  public @Loader.RetryAction int onLoadError(
+  public LoadErrorAction onLoadError(
       ParsingLoadable<HlsPlaylist> loadable,
       long elapsedRealtimeMs,
       long loadDurationMs,
-      IOException error) {
-    boolean isFatal = error instanceof ParserException;
+      IOException error,
+      int errorCount) {
+    long retryDelayMs =
+        loadErrorHandlingPolicy.getRetryDelayMsFor(
+            loadable.type, loadDurationMs, error, errorCount);
+    boolean isFatal = retryDelayMs == C.TIME_UNSET;
     eventDispatcher.loadError(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         C.DATA_TYPE_MANIFEST,
         elapsedRealtimeMs,
         loadDurationMs,
         loadable.bytesLoaded(),
         error,
         isFatal);
-    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
+    return isFatal
+        ? Loader.DONT_RETRY_FATAL
+        : Loader.createRetryAction(/* resetErrorCount= */ false, retryDelayMs);
   }
 
   // Internal methods.
@@ -306,11 +345,11 @@ private void onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
     }
   }
 
-  private boolean notifyPlaylistError(HlsUrl playlistUrl, boolean shouldBlacklist) {
+  private boolean notifyPlaylistError(HlsUrl playlistUrl, long blacklistDurationMs) {
     int listenersSize = listeners.size();
     boolean anyBlacklistingFailed = false;
     for (int i = 0; i < listenersSize; i++) {
-      anyBlacklistingFailed |= !listeners.get(i).onPlaylistError(playlistUrl, shouldBlacklist);
+      anyBlacklistingFailed |= !listeners.get(i).onPlaylistError(playlistUrl, blacklistDurationMs);
     }
     return anyBlacklistingFailed;
   }
@@ -406,7 +445,7 @@ public MediaPlaylistBundle(HlsUrl playlistUrl) {
               dataSourceFactory.createDataSource(C.DATA_TYPE_MANIFEST),
               UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url),
               C.DATA_TYPE_MANIFEST,
-              playlistParser);
+              mediaPlaylistParser);
     }
 
     public HlsMediaPlaylist getPlaylistSnapshot() {
@@ -458,9 +497,11 @@ public void onLoadCompleted(
         ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs, long loadDurationMs) {
       HlsPlaylist result = loadable.getResult();
       if (result instanceof HlsMediaPlaylist) {
-        processLoadedPlaylist((HlsMediaPlaylist) result);
+        processLoadedPlaylist((HlsMediaPlaylist) result, loadDurationMs);
         eventDispatcher.loadCompleted(
             loadable.dataSpec,
+            loadable.getUri(),
+            loadable.getResponseHeaders(),
             C.DATA_TYPE_MANIFEST,
             elapsedRealtimeMs,
             loadDurationMs,
@@ -478,6 +519,8 @@ public void onLoadCanceled(
         boolean released) {
       eventDispatcher.loadCanceled(
           loadable.dataSpec,
+          loadable.getUri(),
+          loadable.getResponseHeaders(),
           C.DATA_TYPE_MANIFEST,
           elapsedRealtimeMs,
           loadDurationMs,
@@ -485,30 +528,49 @@ public void onLoadCanceled(
     }
 
     @Override
-    public @Loader.RetryAction int onLoadError(
+    public LoadErrorAction onLoadError(
         ParsingLoadable<HlsPlaylist> loadable,
         long elapsedRealtimeMs,
         long loadDurationMs,
-        IOException error) {
-      boolean isFatal = error instanceof ParserException;
+        IOException error,
+        int errorCount) {
+      LoadErrorAction loadErrorAction;
+
+      long blacklistDurationMs =
+          loadErrorHandlingPolicy.getBlacklistDurationMsFor(
+              loadable.type, loadDurationMs, error, errorCount);
+      boolean shouldBlacklist = blacklistDurationMs != C.TIME_UNSET;
+
+      boolean blacklistingFailed =
+          notifyPlaylistError(playlistUrl, blacklistDurationMs) || !shouldBlacklist;
+      if (shouldBlacklist) {
+        blacklistingFailed |= blacklistPlaylist(blacklistDurationMs);
+      }
+
+      if (blacklistingFailed) {
+        long retryDelay =
+            loadErrorHandlingPolicy.getRetryDelayMsFor(
+                loadable.type, loadDurationMs, error, errorCount);
+        loadErrorAction =
+            retryDelay != C.TIME_UNSET
+                ? Loader.createRetryAction(false, retryDelay)
+                : Loader.DONT_RETRY_FATAL;
+      } else {
+        loadErrorAction = Loader.DONT_RETRY;
+      }
+
       eventDispatcher.loadError(
           loadable.dataSpec,
+          loadable.getUri(),
+          loadable.getResponseHeaders(),
           C.DATA_TYPE_MANIFEST,
           elapsedRealtimeMs,
           loadDurationMs,
           loadable.bytesLoaded(),
           error,
-          isFatal);
-      boolean shouldBlacklist = ChunkedTrackBlacklistUtil.shouldBlacklist(error);
-      boolean shouldRetryIfNotFatal =
-          notifyPlaylistError(playlistUrl, shouldBlacklist) || !shouldBlacklist;
-      if (isFatal) {
-        return Loader.DONT_RETRY_FATAL;
-      }
-      if (shouldBlacklist) {
-        shouldRetryIfNotFatal |= blacklistPlaylist();
-      }
-      return shouldRetryIfNotFatal ? Loader.RETRY : Loader.DONT_RETRY;
+          /* wasCanceled= */ !loadErrorAction.isRetry());
+
+      return loadErrorAction;
     }
 
     // Runnable implementation.
@@ -523,12 +585,17 @@ public void run() {
 
     private void loadPlaylistImmediately() {
       long elapsedRealtime =
-          mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
+          mediaPlaylistLoader.startLoading(
+              mediaPlaylistLoadable,
+              this,
+              loadErrorHandlingPolicy.getMinimumLoadableRetryCount(mediaPlaylistLoadable.type));
       eventDispatcher.loadStarted(
-          mediaPlaylistLoadable.dataSpec, mediaPlaylistLoadable.type, elapsedRealtime);
+          mediaPlaylistLoadable.dataSpec,
+          mediaPlaylistLoadable.type,
+          elapsedRealtime);
     }
 
-    private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
+    private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist, long loadDurationMs) {
       HlsMediaPlaylist oldPlaylist = playlistSnapshot;
       long currentTimeMs = SystemClock.elapsedRealtime();
       lastSnapshotLoadMs = currentTimeMs;
@@ -540,16 +607,23 @@ private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
       } else if (!playlistSnapshot.hasEndTag) {
         if (loadedPlaylist.mediaSequence + loadedPlaylist.segments.size()
             < playlistSnapshot.mediaSequence) {
-          // The media sequence jumped backwards. The server has probably reset.
+          // TODO: Allow customization of playlist resets handling.
+          // The media sequence jumped backwards. The server has probably reset. We do not try
+          // blacklisting in this case.
           playlistError = new PlaylistResetException(playlistUrl.url);
-          notifyPlaylistError(playlistUrl, false);
+          notifyPlaylistError(playlistUrl, C.TIME_UNSET);
         } else if (currentTimeMs - lastSnapshotChangeMs
             > C.usToMs(playlistSnapshot.targetDurationUs)
                 * PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT) {
-          // The playlist seems to be stuck. Blacklist it.
+          // TODO: Allow customization of stuck playlists handling.
           playlistError = new PlaylistStuckException(playlistUrl.url);
-          notifyPlaylistError(playlistUrl, true);
-          blacklistPlaylist();
+          long blacklistDurationMs =
+              loadErrorHandlingPolicy.getBlacklistDurationMsFor(
+                  C.DATA_TYPE_MANIFEST, loadDurationMs, playlistError, /* errorCount= */ 1);
+          notifyPlaylistError(playlistUrl, blacklistDurationMs);
+          if (blacklistDurationMs != C.TIME_UNSET) {
+            blacklistPlaylist(blacklistDurationMs);
+          }
         }
       }
       // Do not allow the playlist to load again within the target duration if we obtained a new
@@ -571,12 +645,35 @@ private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
     /**
      * Blacklists the playlist.
      *
+     * @param blacklistDurationMs The number of milliseconds for which the playlist should be
+     *     blacklisted.
      * @return Whether the playlist is the primary, despite being blacklisted.
      */
-    private boolean blacklistPlaylist() {
-      blacklistUntilMs =
-          SystemClock.elapsedRealtime() + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;
+    private boolean blacklistPlaylist(long blacklistDurationMs) {
+      blacklistUntilMs = SystemClock.elapsedRealtime() + blacklistDurationMs;
       return primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
     }
   }
+
+  /**
+   * Creates a factory which always returns the given playlist parser.
+   *
+   * @param playlistParser The parser to return.
+   * @return A factory which always returns the given playlist parser.
+   */
+  private static HlsPlaylistParserFactory createFixedFactory(
+      ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
+    return new HlsPlaylistParserFactory() {
+      @Override
+      public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser() {
+        return playlistParser;
+      }
+
+      @Override
+      public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser(
+          HlsMasterPlaylist masterPlaylist) {
+        return playlistParser;
+      }
+    };
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index 5c29dca38e..bb01ade28d 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -16,14 +16,33 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 /** Represents an HLS master playlist. */
 public final class HlsMasterPlaylist extends HlsPlaylist {
 
+  /** Represents an empty master playlist, from which no attributes can be inherited. */
+  public static final HlsMasterPlaylist EMPTY =
+      new HlsMasterPlaylist(
+          /* baseUri= */ "",
+          /* tags= */ Collections.emptyList(),
+          /* variants= */ Collections.emptyList(),
+          /* audios= */ Collections.emptyList(),
+          /* subtitles= */ Collections.emptyList(),
+          /* muxedAudioFormat= */ null,
+          /* muxedCaptionFormats= */ Collections.emptyList(),
+          /* hasIndependentSegments= */ false,
+          /* variableDefinitions= */ Collections.emptyMap());
+
+  public static final int GROUP_INDEX_VARIANT = 0;
+  public static final int GROUP_INDEX_AUDIO = 1;
+  public static final int GROUP_INDEX_SUBTITLE = 2;
+
   /**
    * Represents a url in an HLS master playlist.
    */
@@ -45,8 +64,16 @@
      * @return An HLS url.
      */
     public static HlsUrl createMediaPlaylistHlsUrl(String url) {
-      Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null,
-          Format.NO_VALUE, 0, null);
+      Format format =
+          Format.createContainerFormat(
+              "0",
+              /* label= */ null,
+              MimeTypes.APPLICATION_M3U8,
+              /* sampleMimeType= */ null,
+              /* codecs= */ null,
+              /* bitrate= */ Format.NO_VALUE,
+              /* selectionFlags= */ 0,
+              /* language= */ null);
       return new HlsUrl(url, format);
     }
 
@@ -85,6 +112,8 @@ public HlsUrl(String url, Format format) {
    * captions information.
    */
   public final List<Format> muxedCaptionFormats;
+  /** Contains variable definitions, as defined by the #EXT-X-DEFINE tag. */
+  public final Map<String, String> variableDefinitions;
 
   /**
    * @param baseUri See {@link #baseUri}.
@@ -94,29 +123,41 @@ public HlsUrl(String url, Format format) {
    * @param subtitles See {@link #subtitles}.
    * @param muxedAudioFormat See {@link #muxedAudioFormat}.
    * @param muxedCaptionFormats See {@link #muxedCaptionFormats}.
+   * @param hasIndependentSegments See {@link #hasIndependentSegments}.
+   * @param variableDefinitions See {@link #variableDefinitions}.
    */
-  public HlsMasterPlaylist(String baseUri, List<String> tags, List<HlsUrl> variants,
-      List<HlsUrl> audios, List<HlsUrl> subtitles, Format muxedAudioFormat,
-      List<Format> muxedCaptionFormats) {
-    super(baseUri, tags);
+  public HlsMasterPlaylist(
+      String baseUri,
+      List<String> tags,
+      List<HlsUrl> variants,
+      List<HlsUrl> audios,
+      List<HlsUrl> subtitles,
+      Format muxedAudioFormat,
+      List<Format> muxedCaptionFormats,
+      boolean hasIndependentSegments,
+      Map<String, String> variableDefinitions) {
+    super(baseUri, tags, hasIndependentSegments);
     this.variants = Collections.unmodifiableList(variants);
     this.audios = Collections.unmodifiableList(audios);
     this.subtitles = Collections.unmodifiableList(subtitles);
     this.muxedAudioFormat = muxedAudioFormat;
     this.muxedCaptionFormats = muxedCaptionFormats != null
         ? Collections.unmodifiableList(muxedCaptionFormats) : null;
+    this.variableDefinitions = Collections.unmodifiableMap(variableDefinitions);
   }
 
   @Override
-  public HlsMasterPlaylist copy(List<RenditionKey> renditionKeys) {
+  public HlsMasterPlaylist copy(List<StreamKey> streamKeys) {
     return new HlsMasterPlaylist(
         baseUri,
         tags,
-        copyRenditionsList(variants, RenditionKey.TYPE_VARIANT, renditionKeys),
-        copyRenditionsList(audios, RenditionKey.TYPE_AUDIO, renditionKeys),
-        copyRenditionsList(subtitles, RenditionKey.TYPE_SUBTITLE, renditionKeys),
+        copyRenditionsList(variants, GROUP_INDEX_VARIANT, streamKeys),
+        copyRenditionsList(audios, GROUP_INDEX_AUDIO, streamKeys),
+        copyRenditionsList(subtitles, GROUP_INDEX_SUBTITLE, streamKeys),
         muxedAudioFormat,
-        muxedCaptionFormats);
+        muxedCaptionFormats,
+        hasIndependentSegments,
+        variableDefinitions);
   }
 
   /**
@@ -128,18 +169,26 @@ public HlsMasterPlaylist copy(List<RenditionKey> renditionKeys) {
   public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUrl) {
     List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUrl));
     List<HlsUrl> emptyList = Collections.emptyList();
-    return new HlsMasterPlaylist(null, Collections.<String>emptyList(), variant, emptyList,
-        emptyList, null, null);
+    return new HlsMasterPlaylist(
+        null,
+        Collections.emptyList(),
+        variant,
+        emptyList,
+        emptyList,
+        /* muxedAudioFormat= */ null,
+        /* muxedCaptionFormats= */ null,
+        /* hasIndependentSegments= */ false,
+        /* variableDefinitions= */ Collections.emptyMap());
   }
 
   private static List<HlsUrl> copyRenditionsList(
-      List<HlsUrl> renditions, int renditionType, List<RenditionKey> renditionKeys) {
-    List<HlsUrl> copiedRenditions = new ArrayList<>(renditionKeys.size());
+      List<HlsUrl> renditions, int groupIndex, List<StreamKey> streamKeys) {
+    List<HlsUrl> copiedRenditions = new ArrayList<>(streamKeys.size());
     for (int i = 0; i < renditions.size(); i++) {
       HlsUrl rendition = renditions.get(i);
-      for (int j = 0; j < renditionKeys.size(); j++) {
-        RenditionKey renditionKey = renditionKeys.get(j);
-        if (renditionKey.type == renditionType && renditionKey.trackIndex == i) {
+      for (int j = 0; j < streamKeys.size(); j++) {
+        StreamKey streamKey = streamKeys.get(j);
+        if (streamKey.groupIndex == groupIndex && streamKey.trackIndex == i) {
           copiedRenditions.add(rendition);
           break;
         }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 5ac6f37550..81d4e7a818 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -20,6 +20,8 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.offline.StreamKey;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -41,9 +43,11 @@
      * the media playlist does not define a media section for this segment. The same instance is
      * used for all segments that share an EXT-X-MAP tag.
      */
-    @Nullable public final Segment initializationSegment;
+    public final @Nullable Segment initializationSegment;
     /** The duration of the segment in microseconds, as defined by #EXTINF. */
     public final long durationUs;
+    /** The human readable title of the segment. */
+    public final String title;
     /**
      * The number of #EXT-X-DISCONTINUITY tags in the playlist before the segment.
      */
@@ -52,16 +56,21 @@
      * The start time of the segment in microseconds, relative to the start of the playlist.
      */
     public final long relativeStartTimeUs;
+    /**
+     * DRM initialization data for sample decryption, or null if the segment does not use CDM-DRM
+     * protection.
+     */
+    public final @Nullable DrmInitData drmInitData;
     /**
      * The encryption identity key uri as defined by #EXT-X-KEY, or null if the segment does not use
      * full segment encryption with identity key.
      */
-    public final String fullSegmentEncryptionKeyUri;
+    public final @Nullable String fullSegmentEncryptionKeyUri;
     /**
      * The encryption initialization vector as defined by #EXT-X-KEY, or null if the segment is not
      * encrypted.
      */
-    public final String encryptionIV;
+    public final @Nullable String encryptionIV;
     /**
      * The segment's byte range offset, as defined by #EXT-X-BYTERANGE.
      */
@@ -81,15 +90,29 @@
      * @param byterangeLength See {@link #byterangeLength}.
      */
     public Segment(String uri, long byterangeOffset, long byterangeLength) {
-      this(uri, null, 0, -1, C.TIME_UNSET, null, null, byterangeOffset, byterangeLength, false);
+      this(
+          uri,
+          /* initializationSegment= */ null,
+          /* title= */ "",
+          /* durationUs= */ 0,
+          /* relativeDiscontinuitySequence= */ -1,
+          /* relativeStartTimeUs= */ C.TIME_UNSET,
+          /* drmInitData= */ null,
+          /* fullSegmentEncryptionKeyUri= */ null,
+          /* encryptionIV= */ null,
+          byterangeOffset,
+          byterangeLength,
+          /* hasGapTag= */ false);
     }
 
     /**
      * @param url See {@link #url}.
      * @param initializationSegment See {@link #initializationSegment}.
+     * @param title See {@link #title}.
      * @param durationUs See {@link #durationUs}.
      * @param relativeDiscontinuitySequence See {@link #relativeDiscontinuitySequence}.
      * @param relativeStartTimeUs See {@link #relativeStartTimeUs}.
+     * @param drmInitData See {@link #drmInitData}.
      * @param fullSegmentEncryptionKeyUri See {@link #fullSegmentEncryptionKeyUri}.
      * @param encryptionIV See {@link #encryptionIV}.
      * @param byterangeOffset See {@link #byterangeOffset}.
@@ -98,20 +121,24 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
      */
     public Segment(
         String url,
-        Segment initializationSegment,
+        @Nullable Segment initializationSegment,
+        String title,
         long durationUs,
         int relativeDiscontinuitySequence,
         long relativeStartTimeUs,
-        String fullSegmentEncryptionKeyUri,
-        String encryptionIV,
+        @Nullable DrmInitData drmInitData,
+        @Nullable String fullSegmentEncryptionKeyUri,
+        @Nullable String encryptionIV,
         long byterangeOffset,
         long byterangeLength,
         boolean hasGapTag) {
       this.url = url;
       this.initializationSegment = initializationSegment;
+      this.title = title;
       this.durationUs = durationUs;
       this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
       this.relativeStartTimeUs = relativeStartTimeUs;
+      this.drmInitData = drmInitData;
       this.fullSegmentEncryptionKeyUri = fullSegmentEncryptionKeyUri;
       this.encryptionIV = encryptionIV;
       this.byterangeOffset = byterangeOffset;
@@ -128,11 +155,14 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
   }
 
   /**
-   * Type of the playlist, as defined by #EXT-X-PLAYLIST-TYPE.
+   * Type of the playlist, as defined by #EXT-X-PLAYLIST-TYPE. One of {@link
+   * #PLAYLIST_TYPE_UNKNOWN}, {@link #PLAYLIST_TYPE_VOD} or {@link #PLAYLIST_TYPE_EVENT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
   public @interface PlaylistType {}
+
   public static final int PLAYLIST_TYPE_UNKNOWN = 0;
   public static final int PLAYLIST_TYPE_VOD = 1;
   public static final int PLAYLIST_TYPE_EVENT = 2;
@@ -173,10 +203,6 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * The target duration in microseconds, as defined by #EXT-X-TARGETDURATION.
    */
   public final long targetDurationUs;
-  /**
-   * Whether the playlist contains the #EXT-X-INDEPENDENT-SEGMENTS tag.
-   */
-  public final boolean hasIndependentSegmentsTag;
   /**
    * Whether the playlist contains the #EXT-X-ENDLIST tag.
    */
@@ -186,10 +212,10 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    */
   public final boolean hasProgramDateTime;
   /**
-   * DRM initialization data for sample decryption, or null if none of the segment uses sample
-   * encryption.
+   * Contains the CDM protection schemes used by segments in this playlist. Does not contain any key
+   * acquisition data. Null if none of the segments in the playlist is CDM-encrypted.
    */
-  public final DrmInitData drmInitData;
+  public final @Nullable DrmInitData protectionSchemes;
   /**
    * The list of segments in the playlist.
    */
@@ -210,10 +236,10 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * @param mediaSequence See {@link #mediaSequence}.
    * @param version See {@link #version}.
    * @param targetDurationUs See {@link #targetDurationUs}.
-   * @param hasIndependentSegmentsTag See {@link #hasIndependentSegmentsTag}.
+   * @param hasIndependentSegments See {@link #hasIndependentSegments}.
    * @param hasEndTag See {@link #hasEndTag}.
+   * @param protectionSchemes See {@link #protectionSchemes}.
    * @param hasProgramDateTime See {@link #hasProgramDateTime}.
-   * @param drmInitData See {@link #drmInitData}.
    * @param segments See {@link #segments}.
    */
   public HlsMediaPlaylist(
@@ -227,12 +253,12 @@ public HlsMediaPlaylist(
       long mediaSequence,
       int version,
       long targetDurationUs,
-      boolean hasIndependentSegmentsTag,
+      boolean hasIndependentSegments,
       boolean hasEndTag,
       boolean hasProgramDateTime,
-      DrmInitData drmInitData,
+      @Nullable DrmInitData protectionSchemes,
       List<Segment> segments) {
-    super(baseUri, tags);
+    super(baseUri, tags, hasIndependentSegments);
     this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
     this.hasDiscontinuitySequence = hasDiscontinuitySequence;
@@ -240,10 +266,9 @@ public HlsMediaPlaylist(
     this.mediaSequence = mediaSequence;
     this.version = version;
     this.targetDurationUs = targetDurationUs;
-    this.hasIndependentSegmentsTag = hasIndependentSegmentsTag;
     this.hasEndTag = hasEndTag;
     this.hasProgramDateTime = hasProgramDateTime;
-    this.drmInitData = drmInitData;
+    this.protectionSchemes = protectionSchemes;
     this.segments = Collections.unmodifiableList(segments);
     if (!segments.isEmpty()) {
       Segment last = segments.get(segments.size() - 1);
@@ -256,7 +281,7 @@ public HlsMediaPlaylist(
   }
 
   @Override
-  public HlsMediaPlaylist copy(List<RenditionKey> renditionKeys) {
+  public HlsMediaPlaylist copy(List<StreamKey> streamKeys) {
     return this;
   }
 
@@ -294,7 +319,7 @@ public long getEndTimeUs() {
    *
    * @param startTimeUs The start time for the returned playlist.
    * @param discontinuitySequence The discontinuity sequence for the returned playlist.
-   * @return The playlist.
+   * @return An identical playlist including the provided discontinuity and timing information.
    */
   public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
     return new HlsMediaPlaylist(
@@ -308,18 +333,16 @@ public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
         mediaSequence,
         version,
         targetDurationUs,
-        hasIndependentSegmentsTag,
+        hasIndependentSegments,
         hasEndTag,
         hasProgramDateTime,
-        drmInitData,
+        protectionSchemes,
         segments);
   }
 
   /**
    * Returns a playlist identical to this one except that an end tag is added. If an end tag is
    * already present then the playlist will return itself.
-   *
-   * @return The playlist.
    */
   public HlsMediaPlaylist copyWithEndTag() {
     if (this.hasEndTag) {
@@ -336,10 +359,10 @@ public HlsMediaPlaylist copyWithEndTag() {
         mediaSequence,
         version,
         targetDurationUs,
-        hasIndependentSegmentsTag,
+        hasIndependentSegments,
         /* hasEndTag= */ true,
         hasProgramDateTime,
-        drmInitData,
+        protectionSchemes,
         segments);
   }
 
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
index 34ecde229d..9cec1cd33b 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
@@ -20,7 +20,7 @@
 import java.util.List;
 
 /** Represents an HLS playlist. */
-public abstract class HlsPlaylist implements FilterableManifest<HlsPlaylist, RenditionKey> {
+public abstract class HlsPlaylist implements FilterableManifest<HlsPlaylist> {
 
   /**
    * The base uri. Used to resolve relative paths.
@@ -30,14 +30,21 @@
    * The list of tags in the playlist.
    */
   public final List<String> tags;
+  /**
+   * Whether the media is formed of independent segments, as defined by the
+   * #EXT-X-INDEPENDENT-SEGMENTS tag.
+   */
+  public final boolean hasIndependentSegments;
 
   /**
    * @param baseUri See {@link #baseUri}.
    * @param tags See {@link #tags}.
+   * @param hasIndependentSegments See {@link #hasIndependentSegments}.
    */
-  protected HlsPlaylist(String baseUri, List<String> tags) {
+  protected HlsPlaylist(String baseUri, List<String> tags, boolean hasIndependentSegments) {
     this.baseUri = baseUri;
     this.tags = Collections.unmodifiableList(tags);
+    this.hasIndependentSegments = hasIndependentSegments;
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 7187bdb0ca..65f4796187 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -16,12 +16,14 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.util.Base64;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
@@ -38,9 +40,12 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Queue;
+import java.util.TreeMap;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import org.checkerframework.checker.nullness.qual.PolyNull;
 
 /**
  * HLS playlists parsing logic.
@@ -53,6 +58,7 @@
 
   private static final String TAG_VERSION = "#EXT-X-VERSION";
   private static final String TAG_PLAYLIST_TYPE = "#EXT-X-PLAYLIST-TYPE";
+  private static final String TAG_DEFINE = "#EXT-X-DEFINE";
   private static final String TAG_STREAM_INF = "#EXT-X-STREAM-INF";
   private static final String TAG_MEDIA = "#EXT-X-MEDIA";
   private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
@@ -80,6 +86,7 @@
   // Replaced by METHOD_SAMPLE_AES_CTR. Keep for backward compatibility.
   private static final String METHOD_SAMPLE_AES_CENC = "SAMPLE-AES-CENC";
   private static final String METHOD_SAMPLE_AES_CTR = "SAMPLE-AES-CTR";
+  private static final String KEYFORMAT_PLAYREADY = "com.microsoft.playready";
   private static final String KEYFORMAT_IDENTITY = "identity";
   private static final String KEYFORMAT_WIDEVINE_PSSH_BINARY =
       "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
@@ -106,6 +113,8 @@
       + ":(\\d+)\\b");
   private static final Pattern REGEX_MEDIA_DURATION = Pattern.compile(TAG_MEDIA_DURATION
       + ":([\\d\\.]+)\\b");
+  private static final Pattern REGEX_MEDIA_TITLE =
+      Pattern.compile(TAG_MEDIA_DURATION + ":[\\d\\.]+\\b,(.+)");
   private static final Pattern REGEX_TIME_OFFSET = Pattern.compile("TIME-OFFSET=(-?[\\d\\.]+)\\b");
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
@@ -124,8 +133,10 @@
               + "|"
               + METHOD_SAMPLE_AES_CTR
               + ")"
-              + "\\s*(,|$)");
+              + "\\s*(?:,|$)");
   private static final Pattern REGEX_KEYFORMAT = Pattern.compile("KEYFORMAT=\"(.+?)\"");
+  private static final Pattern REGEX_KEYFORMATVERSIONS =
+      Pattern.compile("KEYFORMATVERSIONS=\"(.+?)\"");
   private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
   private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
   private static final Pattern REGEX_TYPE = Pattern.compile("TYPE=(" + TYPE_AUDIO + "|" + TYPE_VIDEO
@@ -138,6 +149,30 @@
   private static final Pattern REGEX_AUTOSELECT = compileBooleanAttrPattern("AUTOSELECT");
   private static final Pattern REGEX_DEFAULT = compileBooleanAttrPattern("DEFAULT");
   private static final Pattern REGEX_FORCED = compileBooleanAttrPattern("FORCED");
+  private static final Pattern REGEX_VALUE = Pattern.compile("VALUE=\"(.+?)\"");
+  private static final Pattern REGEX_IMPORT = Pattern.compile("IMPORT=\"(.+?)\"");
+  private static final Pattern REGEX_VARIABLE_REFERENCE =
+      Pattern.compile("\\{\\$([a-zA-Z0-9\\-_]+)\\}");
+
+  private final HlsMasterPlaylist masterPlaylist;
+
+  /**
+   * Creates an instance where media playlists are parsed without inheriting attributes from a
+   * master playlist.
+   */
+  public HlsPlaylistParser() {
+    this(HlsMasterPlaylist.EMPTY);
+  }
+
+  /**
+   * Creates an instance where parsed media playlists inherit attributes from the given master
+   * playlist.
+   *
+   * @param masterPlaylist The master playlist from which media playlists will inherit attributes.
+   */
+  public HlsPlaylistParser(HlsMasterPlaylist masterPlaylist) {
+    this.masterPlaylist = masterPlaylist;
+  }
 
   @Override
   public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
@@ -165,7 +200,8 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
             || line.equals(TAG_DISCONTINUITY_SEQUENCE)
             || line.equals(TAG_ENDLIST)) {
           extraLines.add(line);
-          return parseMediaPlaylist(new LineIterator(extraLines, reader), uri.toString());
+          return parseMediaPlaylist(
+              masterPlaylist, new LineIterator(extraLines, reader), uri.toString());
         } else {
           extraLines.add(line);
         }
@@ -209,6 +245,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
       throws IOException {
     HashSet<String> variantUrls = new HashSet<>();
     HashMap<String, String> audioGroupIdToCodecs = new HashMap<>();
+    HashMap<String, String> variableDefinitions = new HashMap<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
@@ -217,6 +254,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     Format muxedAudioFormat = null;
     List<Format> muxedCaptionFormats = null;
     boolean noClosedCaptions = false;
+    boolean hasIndependentSegmentsTag = false;
 
     String line;
     while (iterator.hasNext()) {
@@ -227,20 +265,28 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         tags.add(line);
       }
 
-      if (line.startsWith(TAG_MEDIA)) {
+      if (line.startsWith(TAG_DEFINE)) {
+        variableDefinitions.put(
+            /* key= */ parseStringAttr(line, REGEX_NAME, variableDefinitions),
+            /* value= */ parseStringAttr(line, REGEX_VALUE, variableDefinitions));
+      } else if (line.equals(TAG_INDEPENDENT_SEGMENTS)) {
+        hasIndependentSegmentsTag = true;
+      } else if (line.startsWith(TAG_MEDIA)) {
         // Media tags are parsed at the end to include codec information from #EXT-X-STREAM-INF
         // tags.
         mediaTags.add(line);
       } else if (line.startsWith(TAG_STREAM_INF)) {
         noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
-        String averageBandwidthString = parseOptionalStringAttr(line, REGEX_AVERAGE_BANDWIDTH);
+        String averageBandwidthString =
+            parseOptionalStringAttr(line, REGEX_AVERAGE_BANDWIDTH, variableDefinitions);
         if (averageBandwidthString != null) {
           // If available, the average bandwidth attribute is used as the variant's bitrate.
           bitrate = Integer.parseInt(averageBandwidthString);
         }
-        String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
-        String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
+        String codecs = parseOptionalStringAttr(line, REGEX_CODECS, variableDefinitions);
+        String resolutionString =
+            parseOptionalStringAttr(line, REGEX_RESOLUTION, variableDefinitions);
         int width;
         int height;
         if (resolutionString != null) {
@@ -257,18 +303,32 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           height = Format.NO_VALUE;
         }
         float frameRate = Format.NO_VALUE;
-        String frameRateString = parseOptionalStringAttr(line, REGEX_FRAME_RATE);
+        String frameRateString =
+            parseOptionalStringAttr(line, REGEX_FRAME_RATE, variableDefinitions);
         if (frameRateString != null) {
           frameRate = Float.parseFloat(frameRateString);
         }
-        String audioGroupId = parseOptionalStringAttr(line, REGEX_AUDIO);
+        String audioGroupId = parseOptionalStringAttr(line, REGEX_AUDIO, variableDefinitions);
         if (audioGroupId != null && codecs != null) {
           audioGroupIdToCodecs.put(audioGroupId, Util.getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO));
         }
-        line = iterator.next(); // #EXT-X-STREAM-INF's URI.
+        line =
+            replaceVariableReferences(
+                iterator.next(), variableDefinitions); // #EXT-X-STREAM-INF's URI.
         if (variantUrls.add(line)) {
-          Format format = Format.createVideoContainerFormat(Integer.toString(variants.size()),
-              MimeTypes.APPLICATION_M3U8, null, codecs, bitrate, width, height, frameRate, null, 0);
+          Format format =
+              Format.createVideoContainerFormat(
+                  /* id= */ Integer.toString(variants.size()),
+                  /* label= */ null,
+                  /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+                  /* sampleMimeType= */ null,
+                  codecs,
+                  bitrate,
+                  width,
+                  height,
+                  frameRate,
+                  /* initializationData= */ null,
+                  /* selectionFlags= */ 0);
           variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
         }
       }
@@ -277,18 +337,29 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     for (int i = 0; i < mediaTags.size(); i++) {
       line = mediaTags.get(i);
       @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
-      String uri = parseOptionalStringAttr(line, REGEX_URI);
-      String id = parseStringAttr(line, REGEX_NAME);
-      String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
-      String groupId = parseOptionalStringAttr(line, REGEX_GROUP_ID);
+      String uri = parseOptionalStringAttr(line, REGEX_URI, variableDefinitions);
+      String name = parseStringAttr(line, REGEX_NAME, variableDefinitions);
+      String language = parseOptionalStringAttr(line, REGEX_LANGUAGE, variableDefinitions);
+      String groupId = parseOptionalStringAttr(line, REGEX_GROUP_ID, variableDefinitions);
+      String id = groupId + ":" + name;
       Format format;
-      switch (parseStringAttr(line, REGEX_TYPE)) {
+      switch (parseStringAttr(line, REGEX_TYPE, variableDefinitions)) {
         case TYPE_AUDIO:
           String codecs = audioGroupIdToCodecs.get(groupId);
           String sampleMimeType = codecs != null ? MimeTypes.getMediaMimeType(codecs) : null;
-          format = Format.createAudioContainerFormat(id, MimeTypes.APPLICATION_M3U8, sampleMimeType,
-              codecs, Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags,
-              language);
+          format =
+              Format.createAudioContainerFormat(
+                  /* id= */ id,
+                  /* label= */ name,
+                  /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+                  sampleMimeType,
+                  codecs,
+                  /* bitrate= */ Format.NO_VALUE,
+                  /* channelCount= */ Format.NO_VALUE,
+                  /* sampleRate= */ Format.NO_VALUE,
+                  /* initializationData= */ null,
+                  selectionFlags,
+                  language);
           if (uri == null) {
             muxedAudioFormat = format;
           } else {
@@ -296,12 +367,20 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           }
           break;
         case TYPE_SUBTITLES:
-          format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_M3U8,
-              MimeTypes.TEXT_VTT, null, Format.NO_VALUE, selectionFlags, language);
+          format =
+              Format.createTextContainerFormat(
+                  /* id= */ id,
+                  /* label= */ name,
+                  /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+                  /* sampleMimeType= */ MimeTypes.TEXT_VTT,
+                  /* codecs= */ null,
+                  /* bitrate= */ Format.NO_VALUE,
+                  selectionFlags,
+                  language);
           subtitles.add(new HlsMasterPlaylist.HlsUrl(uri, format));
           break;
         case TYPE_CLOSED_CAPTIONS:
-          String instreamId = parseStringAttr(line, REGEX_INSTREAM_ID);
+          String instreamId = parseStringAttr(line, REGEX_INSTREAM_ID, variableDefinitions);
           String mimeType;
           int accessibilityChannel;
           if (instreamId.startsWith("CC")) {
@@ -314,8 +393,17 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           if (muxedCaptionFormats == null) {
             muxedCaptionFormats = new ArrayList<>();
           }
-          muxedCaptionFormats.add(Format.createTextContainerFormat(id, null, mimeType, null,
-              Format.NO_VALUE, selectionFlags, language, accessibilityChannel));
+          muxedCaptionFormats.add(
+              Format.createTextContainerFormat(
+                  /* id= */ id,
+                  /* label= */ name,
+                  /* containerMimeType= */ null,
+                  /* sampleMimeType= */ mimeType,
+                  /* codecs= */ null,
+                  /* bitrate= */ Format.NO_VALUE,
+                  selectionFlags,
+                  language,
+                  accessibilityChannel));
           break;
         default:
           // Do nothing.
@@ -326,31 +414,49 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     if (noClosedCaptions) {
       muxedCaptionFormats = Collections.emptyList();
     }
-    return new HlsMasterPlaylist(baseUri, tags, variants, audios, subtitles, muxedAudioFormat,
-        muxedCaptionFormats);
+    return new HlsMasterPlaylist(
+        baseUri,
+        tags,
+        variants,
+        audios,
+        subtitles,
+        muxedAudioFormat,
+        muxedCaptionFormats,
+        hasIndependentSegmentsTag,
+        variableDefinitions);
   }
 
   @C.SelectionFlags
   private static int parseSelectionFlags(String line) {
-    return (parseBooleanAttribute(line, REGEX_DEFAULT, false) ? C.SELECTION_FLAG_DEFAULT : 0)
-        | (parseBooleanAttribute(line, REGEX_FORCED, false) ? C.SELECTION_FLAG_FORCED : 0)
-        | (parseBooleanAttribute(line, REGEX_AUTOSELECT, false) ? C.SELECTION_FLAG_AUTOSELECT : 0);
+    int flags = 0;
+    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {
+      flags |= C.SELECTION_FLAG_DEFAULT;
+    }
+    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {
+      flags |= C.SELECTION_FLAG_FORCED;
+    }
+    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {
+      flags |= C.SELECTION_FLAG_AUTOSELECT;
+    }
+    return flags;
   }
 
-  private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
-      throws IOException {
+  private static HlsMediaPlaylist parseMediaPlaylist(
+      HlsMasterPlaylist masterPlaylist, LineIterator iterator, String baseUri) throws IOException {
     @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;
     long startOffsetUs = C.TIME_UNSET;
     long mediaSequence = 0;
     int version = 1; // Default version == 1.
     long targetDurationUs = C.TIME_UNSET;
-    boolean hasIndependentSegmentsTag = false;
+    boolean hasIndependentSegmentsTag = masterPlaylist.hasIndependentSegments;
     boolean hasEndTag = false;
     Segment initializationSegment = null;
+    HashMap<String, String> variableDefinitions = new HashMap<>();
     List<Segment> segments = new ArrayList<>();
     List<String> tags = new ArrayList<>();
 
     long segmentDurationUs = 0;
+    String segmentTitle = "";
     boolean hasDiscontinuitySequence = false;
     int playlistDiscontinuitySequence = 0;
     int relativeDiscontinuitySequence = 0;
@@ -361,9 +467,12 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     long segmentMediaSequence = 0;
     boolean hasGapTag = false;
 
+    DrmInitData playlistProtectionSchemes = null;
     String encryptionKeyUri = null;
     String encryptionIV = null;
-    DrmInitData drmInitData = null;
+    TreeMap<String, SchemeData> currentSchemeDatas = new TreeMap<>();
+    String encryptionScheme = null;
+    DrmInitData cachedDrmInitData = null;
 
     String line;
     while (iterator.hasNext()) {
@@ -375,7 +484,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
       }
 
       if (line.startsWith(TAG_PLAYLIST_TYPE)) {
-        String playlistTypeString = parseStringAttr(line, REGEX_PLAYLIST_TYPE);
+        String playlistTypeString = parseStringAttr(line, REGEX_PLAYLIST_TYPE, variableDefinitions);
         if ("VOD".equals(playlistTypeString)) {
           playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_VOD;
         } else if ("EVENT".equals(playlistTypeString)) {
@@ -384,8 +493,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
       } else if (line.startsWith(TAG_START)) {
         startOffsetUs = (long) (parseDoubleAttr(line, REGEX_TIME_OFFSET) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_INIT_SEGMENT)) {
-        String uri = parseStringAttr(line, REGEX_URI);
-        String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
+        String uri = parseStringAttr(line, REGEX_URI, variableDefinitions);
+        String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE, variableDefinitions);
         if (byteRange != null) {
           String[] splitByteRange = byteRange.split("@");
           segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
@@ -403,39 +512,64 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         segmentMediaSequence = mediaSequence;
       } else if (line.startsWith(TAG_VERSION)) {
         version = parseIntAttr(line, REGEX_VERSION);
+      } else if (line.startsWith(TAG_DEFINE)) {
+        String importName = parseOptionalStringAttr(line, REGEX_IMPORT, variableDefinitions);
+        if (importName != null) {
+          String value = masterPlaylist.variableDefinitions.get(importName);
+          if (value != null) {
+            variableDefinitions.put(importName, value);
+          } else {
+            // The master playlist does not declare the imported variable. Ignore.
+          }
+        } else {
+          variableDefinitions.put(
+              parseStringAttr(line, REGEX_NAME, variableDefinitions),
+              parseStringAttr(line, REGEX_VALUE, variableDefinitions));
+        }
       } else if (line.startsWith(TAG_MEDIA_DURATION)) {
         segmentDurationUs =
             (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
+        segmentTitle = parseOptionalStringAttr(line, REGEX_MEDIA_TITLE, "", variableDefinitions);
       } else if (line.startsWith(TAG_KEY)) {
-        String method = parseOptionalStringAttr(line, REGEX_METHOD);
-        String keyFormat = parseOptionalStringAttr(line, REGEX_KEYFORMAT);
+        String method = parseStringAttr(line, REGEX_METHOD, variableDefinitions);
+        String keyFormat =
+            parseOptionalStringAttr(line, REGEX_KEYFORMAT, KEYFORMAT_IDENTITY, variableDefinitions);
         encryptionKeyUri = null;
         encryptionIV = null;
-        if (!METHOD_NONE.equals(method)) {
-          encryptionIV = parseOptionalStringAttr(line, REGEX_IV);
-          if (KEYFORMAT_IDENTITY.equals(keyFormat) || keyFormat == null) {
+        if (METHOD_NONE.equals(method)) {
+          currentSchemeDatas.clear();
+          cachedDrmInitData = null;
+        } else /* !METHOD_NONE.equals(method) */ {
+          encryptionIV = parseOptionalStringAttr(line, REGEX_IV, variableDefinitions);
+          if (KEYFORMAT_IDENTITY.equals(keyFormat)) {
             if (METHOD_AES_128.equals(method)) {
               // The segment is fully encrypted using an identity key.
-              encryptionKeyUri = parseStringAttr(line, REGEX_URI);
+              encryptionKeyUri = parseStringAttr(line, REGEX_URI, variableDefinitions);
             } else {
               // Do nothing. Samples are encrypted using an identity key, but this is not supported.
               // Hopefully, a traditional DRM alternative is also provided.
             }
-          } else if (method != null) {
-            SchemeData schemeData = parseWidevineSchemeData(line, keyFormat);
+          } else {
+            if (encryptionScheme == null) {
+              encryptionScheme =
+                  METHOD_SAMPLE_AES_CENC.equals(method) || METHOD_SAMPLE_AES_CTR.equals(method)
+                      ? C.CENC_TYPE_cenc
+                      : C.CENC_TYPE_cbcs;
+            }
+            SchemeData schemeData;
+            if (KEYFORMAT_PLAYREADY.equals(keyFormat)) {
+              schemeData = parsePlayReadySchemeData(line, variableDefinitions);
+            } else {
+              schemeData = parseWidevineSchemeData(line, keyFormat, variableDefinitions);
+            }
             if (schemeData != null) {
-              drmInitData =
-                  new DrmInitData(
-                      (METHOD_SAMPLE_AES_CENC.equals(method)
-                              || METHOD_SAMPLE_AES_CTR.equals(method))
-                          ? C.CENC_TYPE_cenc
-                          : C.CENC_TYPE_cbcs,
-                      schemeData);
+              cachedDrmInitData = null;
+              currentSchemeDatas.put(keyFormat, schemeData);
             }
           }
         }
       } else if (line.startsWith(TAG_BYTERANGE)) {
-        String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
+        String byteRange = parseStringAttr(line, REGEX_BYTERANGE, variableDefinitions);
         String[] splitByteRange = byteRange.split("@");
         segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
         if (splitByteRange.length > 1) {
@@ -467,17 +601,33 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         } else {
           segmentEncryptionIV = Long.toHexString(segmentMediaSequence);
         }
+
         segmentMediaSequence++;
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
+
+        if (cachedDrmInitData == null && !currentSchemeDatas.isEmpty()) {
+          SchemeData[] schemeDatas = currentSchemeDatas.values().toArray(new SchemeData[0]);
+          cachedDrmInitData = new DrmInitData(encryptionScheme, schemeDatas);
+          if (playlistProtectionSchemes == null) {
+            SchemeData[] playlistSchemeDatas = new SchemeData[schemeDatas.length];
+            for (int i = 0; i < schemeDatas.length; i++) {
+              playlistSchemeDatas[i] = schemeDatas[i].copyWithData(null);
+            }
+            playlistProtectionSchemes = new DrmInitData(encryptionScheme, playlistSchemeDatas);
+          }
+        }
+
         segments.add(
             new Segment(
-                line,
+                replaceVariableReferences(line, variableDefinitions),
                 initializationSegment,
+                segmentTitle,
                 segmentDurationUs,
                 relativeDiscontinuitySequence,
                 segmentStartTimeUs,
+                cachedDrmInitData,
                 encryptionKeyUri,
                 segmentEncryptionIV,
                 segmentByteRangeOffset,
@@ -485,6 +635,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
                 hasGapTag));
         segmentStartTimeUs += segmentDurationUs;
         segmentDurationUs = 0;
+        segmentTitle = "";
         if (segmentByteRangeLength != C.LENGTH_UNSET) {
           segmentByteRangeOffset += segmentByteRangeLength;
         }
@@ -506,16 +657,33 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         hasIndependentSegmentsTag,
         hasEndTag,
         /* hasProgramDateTime= */ playlistStartTimeUs != 0,
-        drmInitData,
+        playlistProtectionSchemes,
         segments);
   }
 
-  private static SchemeData parseWidevineSchemeData(String line, String keyFormat)
+  private static @Nullable SchemeData parsePlayReadySchemeData(
+      String line, Map<String, String> variableDefinitions) throws ParserException {
+    String keyFormatVersions =
+        parseOptionalStringAttr(line, REGEX_KEYFORMATVERSIONS, "1", variableDefinitions);
+    if (!"1".equals(keyFormatVersions)) {
+      // Not supported.
+      return null;
+    }
+    String uriString = parseStringAttr(line, REGEX_URI, variableDefinitions);
+    byte[] data = Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT);
+    byte[] psshData = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID, data);
+    return new SchemeData(C.PLAYREADY_UUID, MimeTypes.VIDEO_MP4, psshData);
+  }
+
+  private static @Nullable SchemeData parseWidevineSchemeData(
+      String line, String keyFormat, Map<String, String> variableDefinitions)
       throws ParserException {
     if (KEYFORMAT_WIDEVINE_PSSH_BINARY.equals(keyFormat)) {
-     String uriString = parseStringAttr(line, REGEX_URI);
-     return new SchemeData(C.WIDEVINE_UUID, MimeTypes.VIDEO_MP4,
-         Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT));
+      String uriString = parseStringAttr(line, REGEX_URI, variableDefinitions);
+      return new SchemeData(
+          C.WIDEVINE_UUID,
+          MimeTypes.VIDEO_MP4,
+          Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT));
     }
     if (KEYFORMAT_WIDEVINE_PSSH_JSON.equals(keyFormat)) {
       try {
@@ -528,31 +696,65 @@ private static SchemeData parseWidevineSchemeData(String line, String keyFormat)
   }
 
   private static int parseIntAttr(String line, Pattern pattern) throws ParserException {
-    return Integer.parseInt(parseStringAttr(line, pattern));
+    return Integer.parseInt(parseStringAttr(line, pattern, Collections.emptyMap()));
   }
 
   private static long parseLongAttr(String line, Pattern pattern) throws ParserException {
-    return Long.parseLong(parseStringAttr(line, pattern));
+    return Long.parseLong(parseStringAttr(line, pattern, Collections.emptyMap()));
   }
 
   private static double parseDoubleAttr(String line, Pattern pattern) throws ParserException {
-    return Double.parseDouble(parseStringAttr(line, pattern));
+    return Double.parseDouble(parseStringAttr(line, pattern, Collections.emptyMap()));
   }
 
-  private static String parseOptionalStringAttr(String line, Pattern pattern) {
-    Matcher matcher = pattern.matcher(line);
-    return matcher.find() ? matcher.group(1) : null;
+  private static String parseStringAttr(
+      String line, Pattern pattern, Map<String, String> variableDefinitions)
+      throws ParserException {
+    String value = parseOptionalStringAttr(line, pattern, variableDefinitions);
+    if (value != null) {
+      return value;
+    } else {
+      throw new ParserException("Couldn't match " + pattern.pattern() + " in " + line);
+    }
   }
 
-  private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
+  private static @Nullable String parseOptionalStringAttr(
+      String line, Pattern pattern, Map<String, String> variableDefinitions) {
+    return parseOptionalStringAttr(line, pattern, null, variableDefinitions);
+  }
+
+  private static @PolyNull String parseOptionalStringAttr(
+      String line,
+      Pattern pattern,
+      @PolyNull String defaultValue,
+      Map<String, String> variableDefinitions) {
     Matcher matcher = pattern.matcher(line);
-    if (matcher.find() && matcher.groupCount() == 1) {
-      return matcher.group(1);
+    String value = matcher.find() ? matcher.group(1) : defaultValue;
+    return variableDefinitions.isEmpty() || value == null
+        ? value
+        : replaceVariableReferences(value, variableDefinitions);
+  }
+
+  private static String replaceVariableReferences(
+      String string, Map<String, String> variableDefinitions) {
+    Matcher matcher = REGEX_VARIABLE_REFERENCE.matcher(string);
+    // TODO: Replace StringBuffer with StringBuilder once Java 9 is available.
+    StringBuffer stringWithReplacements = new StringBuffer();
+    while (matcher.find()) {
+      String groupName = matcher.group(1);
+      if (variableDefinitions.containsKey(groupName)) {
+        matcher.appendReplacement(
+            stringWithReplacements, Matcher.quoteReplacement(variableDefinitions.get(groupName)));
+      } else {
+        // The variable is not defined. The value is ignored.
+      }
     }
-    throw new ParserException("Couldn't match " + pattern.pattern() + " in " + line);
+    matcher.appendTail(stringWithReplacements);
+    return stringWithReplacements.toString();
   }
 
-  private static boolean parseBooleanAttribute(String line, Pattern pattern, boolean defaultValue) {
+  private static boolean parseOptionalBooleanAttribute(
+      String line, Pattern pattern, boolean defaultValue) {
     Matcher matcher = pattern.matcher(line);
     if (matcher.find()) {
       return matcher.group(1).equals(BOOLEAN_TRUE);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParserFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParserFactory.java
new file mode 100644
index 0000000000..814060bf7d
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParserFactory.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+
+/** Factory for {@link HlsPlaylist} parsers. */
+public interface HlsPlaylistParserFactory {
+
+  /**
+   * Returns a stand-alone playlist parser. Playlists parsed by the returned parser do not inherit
+   * any attributes from other playlists.
+   */
+  ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser();
+
+  /**
+   * Returns a playlist parser for playlists that were referenced by the given {@link
+   * HlsMasterPlaylist}. Returned {@link HlsMediaPlaylist} instances may inherit attributes from
+   * {@code masterPlaylist}.
+   *
+   * @param masterPlaylist The master playlist that referenced any parsed media playlists.
+   * @return A parser for HLS playlists.
+   */
+  ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser(HlsMasterPlaylist masterPlaylist);
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index febd1c217d..c73c9fa835 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -19,7 +19,9 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.hls.HlsDataSourceFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import java.io.IOException;
 
 /**
@@ -36,6 +38,22 @@
  */
 public interface HlsPlaylistTracker {
 
+  /** Factory for {@link HlsPlaylistTracker} instances. */
+  interface Factory {
+
+    /**
+     * Creates a new tracker instance.
+     *
+     * @param dataSourceFactory The {@link HlsDataSourceFactory} to use for playlist loading.
+     * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy} for playlist load errors.
+     * @param playlistParserFactory The {@link HlsPlaylistParserFactory} for playlist parsing.
+     */
+    HlsPlaylistTracker createTracker(
+        HlsDataSourceFactory dataSourceFactory,
+        LoadErrorHandlingPolicy loadErrorHandlingPolicy,
+        HlsPlaylistParserFactory playlistParserFactory);
+  }
+
   /** Listener for primary playlist changes. */
   interface PrimaryPlaylistListener {
 
@@ -59,10 +77,11 @@
      * Called if an error is encountered while loading a playlist.
      *
      * @param url The loaded url that caused the error.
-     * @param shouldBlacklist Whether the playlist should be blacklisted.
+     * @param blacklistDurationMs The duration for which the playlist should be blacklisted. Or
+     *     {@link C#TIME_UNSET} if the playlist should not be blacklisted.
      * @return True if blacklisting did not encounter errors. False otherwise.
      */
-    boolean onPlaylistError(HlsUrl url, boolean shouldBlacklist);
+    boolean onPlaylistError(HlsUrl url, long blacklistDurationMs);
   }
 
   /** Thrown when a playlist is considered to be stuck due to a server side error. */
@@ -100,8 +119,8 @@ public PlaylistResetException(String url) {
   /**
    * Starts the playlist tracker.
    *
-   * <p>Must be called from the playback thread. A tracker may be restarted after a {@link
-   * #release()} call.
+   * <p>Must be called from the playback thread. A tracker may be restarted after a {@link #stop()}
+   * call.
    *
    * @param initialPlaylistUri Uri of the HLS stream. Can point to a media playlist or a master
    *     playlist.
@@ -111,8 +130,12 @@ public PlaylistResetException(String url) {
   void start(
       Uri initialPlaylistUri, EventDispatcher eventDispatcher, PrimaryPlaylistListener listener);
 
-  /** Releases all acquired resources. Must be called once per {@link #start} call. */
-  void release();
+  /**
+   * Stops the playlist tracker and releases any acquired resources.
+   *
+   * <p>Must be called once per {@link #start} call.
+   */
+  void stop();
 
   /**
    * Registers a listener to receive events from the playlist tracker.
@@ -144,11 +167,13 @@ void start(
    * HlsUrl}.
    *
    * @param url The {@link HlsUrl} corresponding to the requested media playlist.
+   * @param isForPlayback Whether the caller might use the snapshot to request media segments for
+   *     playback. If true, the primary playlist may be updated to the one requested.
    * @return The most recent snapshot of the playlist referenced by the provided {@link HlsUrl}. May
    *     be null if no snapshot has been loaded yet.
    */
   @Nullable
-  HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url);
+  HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url, boolean isForPlayback);
 
   /**
    * Returns the start time of the first loaded primary playlist, or {@link C#TIME_UNSET} if no
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/RenditionKey.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/RenditionKey.java
deleted file mode 100644
index dec5882efb..0000000000
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/RenditionKey.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.playlist;
-
-import android.support.annotation.IntDef;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-/** Uniquely identifies a rendition in an {@link HlsMasterPlaylist}. */
-public final class RenditionKey implements Comparable<RenditionKey> {
-
-  /** Types of rendition. */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TYPE_VARIANT, TYPE_AUDIO, TYPE_SUBTITLE})
-  public @interface Type {}
-
-  public static final int TYPE_VARIANT = 0;
-  public static final int TYPE_AUDIO = 1;
-  public static final int TYPE_SUBTITLE = 2;
-
-  public final @Type int type;
-  public final int trackIndex;
-
-  public RenditionKey(@Type int type, int trackIndex) {
-    this.type = type;
-    this.trackIndex = trackIndex;
-  }
-
-  @Override
-  public String toString() {
-    return type + "." + trackIndex;
-  }
-
-  @Override
-  public boolean equals(@Nullable Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (o == null || getClass() != o.getClass()) {
-      return false;
-    }
-
-    RenditionKey that = (RenditionKey) o;
-    return type == that.type && trackIndex == that.trackIndex;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = type;
-    result = 31 * result + trackIndex;
-    return result;
-  }
-
-  // Comparable implementation.
-
-  @Override
-  public int compareTo(@NonNull RenditionKey other) {
-    int result = type - other.type;
-    if (result == 0) {
-      result = trackIndex - other.trackIndex;
-    }
-    return result;
-  }
-}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java
index 86bffc7762..defc838c6a 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java
@@ -21,7 +21,11 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.Cipher;
+import javax.crypto.NoSuchPaddingException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -33,7 +37,7 @@
   @Test
   public void test_OpenCallsUpstreamOpen_CloseCallsUpstreamClose() throws IOException {
     UpstreamDataSource upstream = new UpstreamDataSource();
-    Aes128DataSource testInstance = new Aes128DataSource(upstream, new byte[16], new byte[16]);
+    Aes128DataSource testInstance = new TestAes123DataSource(upstream, new byte[16], new byte[16]);
     assertThat(upstream.opened).isFalse();
 
     Uri uri = Uri.parse("http.abc.com/def");
@@ -53,7 +57,7 @@ public long open(DataSpec dataSpec) throws IOException {
             throw new IOException();
           }
         };
-    Aes128DataSource testInstance = new Aes128DataSource(upstream, new byte[16], new byte[16]);
+    Aes128DataSource testInstance = new TestAes123DataSource(upstream, new byte[16], new byte[16]);
     assertThat(upstream.opened).isFalse();
 
     Uri uri = Uri.parse("http.abc.com/def");
@@ -71,11 +75,33 @@ public long open(DataSpec dataSpec) throws IOException {
     assertThat(upstream.closedCalled).isTrue();
   }
 
+  private static class TestAes123DataSource extends Aes128DataSource {
+
+    public TestAes123DataSource(DataSource upstream, byte[] encryptionKey, byte[] encryptionIv) {
+      super(upstream, encryptionKey, encryptionIv);
+    }
+
+    @Override
+    protected Cipher getCipherInstance() throws NoSuchPaddingException, NoSuchAlgorithmException {
+      try {
+        return super.getCipherInstance();
+      } catch (NoSuchAlgorithmException e) {
+        // Some host machines may not provide an algorithm for "AES/CBC/PKCS7Padding", however on
+        // such machines it's possible to get a functionally identical algorithm by requesting
+        // "AES/CBC/PKCS5Padding".
+        return Cipher.getInstance("AES/CBC/PKCS5Padding");
+      }
+    }
+  }
+
   private static class UpstreamDataSource implements DataSource {
 
     public boolean opened;
     public boolean closedCalled;
 
+    @Override
+    public void addTransferListener(TransferListener transferListener) {}
+
     @Override
     public long open(DataSpec dataSpec) throws IOException {
       opened = true;
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java
new file mode 100644
index 0000000000..e3e2feed8b
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.io.EOFException;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Tests for {@link WebvttExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public class WebvttExtractorTest {
+
+  @Test
+  public void sniff_sniffsWebvttHeaderWithTrailingSpace() throws IOException, InterruptedException {
+    byte[] data = new byte[] {'W', 'E', 'B', 'V', 'T', 'T', ' ', '\t'};
+    assertThat(sniffData(data)).isTrue();
+  }
+
+  @Test
+  public void sniff_discardsByteOrderMark() throws IOException, InterruptedException {
+    byte[] data =
+        new byte[] {(byte) 0xEF, (byte) 0xBB, (byte) 0xBF, 'W', 'E', 'B', 'V', 'T', 'T', '\n', ' '};
+    assertThat(sniffData(data)).isTrue();
+  }
+
+  @Test
+  public void sniff_failsForIncorrectBom() throws IOException, InterruptedException {
+    byte[] data =
+        new byte[] {(byte) 0xEF, (byte) 0xBB, (byte) 0xBB, 'W', 'E', 'B', 'V', 'T', 'T', '\n'};
+    assertThat(sniffData(data)).isFalse();
+  }
+
+  @Test
+  public void sniff_failsForIncompleteHeader() throws IOException, InterruptedException {
+    byte[] data = new byte[] {'W', 'E', 'B', 'V', 'T', '\n'};
+    assertThat(sniffData(data)).isFalse();
+  }
+
+  @Test
+  public void sniff_failsForIncorrectHeader() throws IOException, InterruptedException {
+    byte[] data =
+        new byte[] {(byte) 0xEF, (byte) 0xBB, (byte) 0xBF, 'W', 'e', 'B', 'V', 'T', 'T', '\n'};
+    assertThat(sniffData(data)).isFalse();
+  }
+
+  private static boolean sniffData(byte[] data) throws IOException, InterruptedException {
+    ExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
+    try {
+      return new WebvttExtractor(/* language= */ null, new TimestampAdjuster(0)).sniff(input);
+    } catch (EOFException e) {
+      return false;
+    }
+  }
+}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadActionTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadActionTest.java
new file mode 100644
index 0000000000..778ecadddd
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadActionTest.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.offline.DownloadAction;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit tests for {@link HlsDownloadAction}. */
+@RunWith(RobolectricTestRunner.class)
+public class HlsDownloadActionTest {
+
+  private Uri uri1;
+  private Uri uri2;
+
+  @Before
+  public void setUp() {
+    uri1 = Uri.parse("http://test1.uri");
+    uri2 = Uri.parse("http://test2.uri");
+  }
+
+  @Test
+  public void testDownloadActionIsNotRemoveAction() {
+    DownloadAction action = createDownloadAction(uri1);
+    assertThat(action.isRemoveAction).isFalse();
+  }
+
+  @Test
+  public void testRemoveActionIsRemoveAction() {
+    DownloadAction action2 = createRemoveAction(uri1);
+    assertThat(action2.isRemoveAction).isTrue();
+  }
+
+  @Test
+  public void testCreateDownloader() {
+    MockitoAnnotations.initMocks(this);
+    DownloadAction action = createDownloadAction(uri1);
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    assertThat(action.createDownloader(constructorHelper)).isNotNull();
+  }
+
+  @Test
+  public void testSameUriDifferentAction_IsSameMedia() {
+    DownloadAction action1 = createRemoveAction(uri1);
+    DownloadAction action2 = createDownloadAction(uri1);
+    assertThat(action1.isSameMedia(action2)).isTrue();
+  }
+
+  @Test
+  public void testDifferentUriAndAction_IsNotSameMedia() {
+    DownloadAction action3 = createRemoveAction(uri2);
+    DownloadAction action4 = createDownloadAction(uri1);
+    assertThat(action3.isSameMedia(action4)).isFalse();
+  }
+
+  @SuppressWarnings("EqualsWithItself")
+  @Test
+  public void testEquals() {
+    DownloadAction action1 = createRemoveAction(uri1);
+    assertThat(action1.equals(action1)).isTrue();
+
+    DownloadAction action2 = createRemoveAction(uri1);
+    DownloadAction action3 = createRemoveAction(uri1);
+    assertEqual(action2, action3);
+
+    DownloadAction action4 = createRemoveAction(uri1);
+    DownloadAction action5 = createDownloadAction(uri1);
+    assertNotEqual(action4, action5);
+
+    DownloadAction action6 = createDownloadAction(uri1);
+    DownloadAction action7 = createDownloadAction(uri1, new StreamKey(0, 0));
+    assertNotEqual(action6, action7);
+
+    DownloadAction action8 = createDownloadAction(uri1, new StreamKey(1, 1));
+    DownloadAction action9 = createDownloadAction(uri1, new StreamKey(0, 0));
+    assertNotEqual(action8, action9);
+
+    DownloadAction action10 = createRemoveAction(uri1);
+    DownloadAction action11 = createRemoveAction(uri2);
+    assertNotEqual(action10, action11);
+
+    DownloadAction action12 = createDownloadAction(uri1, new StreamKey(0, 0), new StreamKey(1, 1));
+    DownloadAction action13 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
+    assertEqual(action12, action13);
+
+    DownloadAction action14 = createDownloadAction(uri1, new StreamKey(0, 0));
+    DownloadAction action15 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
+    assertNotEqual(action14, action15);
+
+    DownloadAction action16 = createDownloadAction(uri1);
+    DownloadAction action17 = createDownloadAction(uri1);
+    assertEqual(action16, action17);
+  }
+
+  @Test
+  public void testSerializerGetType() {
+    DownloadAction action = createDownloadAction(uri1);
+    assertThat(action.type).isNotNull();
+  }
+
+  @Test
+  public void testSerializerWriteRead() throws Exception {
+    doTestSerializationRoundTrip(createDownloadAction(uri1));
+    doTestSerializationRoundTrip(createRemoveAction(uri1));
+    doTestSerializationRoundTrip(
+        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
+  }
+
+  @Test
+  public void testSerializerVersion0() throws Exception {
+    doTestSerializationV0RoundTrip(createDownloadAction(uri1));
+    doTestSerializationV0RoundTrip(createRemoveAction(uri1));
+    doTestSerializationV0RoundTrip(
+        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
+  }
+
+  private static void assertNotEqual(DownloadAction action1, DownloadAction action2) {
+    assertThat(action1).isNotEqualTo(action2);
+    assertThat(action2).isNotEqualTo(action1);
+  }
+
+  private static void assertEqual(DownloadAction action1, DownloadAction action2) {
+    assertThat(action1).isEqualTo(action2);
+    assertThat(action2).isEqualTo(action1);
+  }
+
+  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream output = new DataOutputStream(out);
+    DownloadAction.serializeToStream(action, output);
+
+    assertEqual(action, deserializeActionFromStream(out));
+  }
+
+  private static void doTestSerializationV0RoundTrip(HlsDownloadAction action) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream output = new DataOutputStream(out);
+    DataOutputStream dataOutputStream = new DataOutputStream(output);
+    dataOutputStream.writeUTF(action.type);
+    dataOutputStream.writeInt(/* version */ 0);
+    dataOutputStream.writeUTF(action.uri.toString());
+    dataOutputStream.writeBoolean(action.isRemoveAction);
+    dataOutputStream.writeInt(action.data.length);
+    dataOutputStream.write(action.data);
+    dataOutputStream.writeInt(action.keys.size());
+    for (int i = 0; i < action.keys.size(); i++) {
+      StreamKey key = action.keys.get(i);
+      dataOutputStream.writeInt(key.groupIndex);
+      dataOutputStream.writeInt(key.trackIndex);
+    }
+    dataOutputStream.flush();
+
+    assertEqual(action, deserializeActionFromStream(out));
+  }
+
+  private static DownloadAction deserializeActionFromStream(ByteArrayOutputStream out)
+      throws IOException {
+    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
+    DataInputStream input = new DataInputStream(in);
+    return DownloadAction.deserializeFromStream(
+        new DownloadAction.Deserializer[] {HlsDownloadAction.DESERIALIZER}, input);
+  }
+
+  private static HlsDownloadAction createDownloadAction(Uri uri, StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
+    Collections.addAll(keysList, keys);
+    return HlsDownloadAction.createDownloadAction(uri, null, keysList);
+  }
+
+  private static HlsDownloadAction createRemoveAction(Uri uri) {
+    return HlsDownloadAction.createRemoveAction(uri, null);
+  }
+}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
index 6e816dd8a7..825988994e 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
@@ -36,7 +36,8 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
 import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
@@ -181,17 +182,17 @@ public void testDownloadEncMediaPlaylist() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
-  private HlsDownloader getHlsDownloader(String mediaPlaylistUri, List<RenditionKey> keys) {
-    Factory factory = new Factory(null).setFakeDataSet(fakeDataSet);
+  private HlsDownloader getHlsDownloader(String mediaPlaylistUri, List<StreamKey> keys) {
+    Factory factory = new Factory().setFakeDataSet(fakeDataSet);
     return new HlsDownloader(
         Uri.parse(mediaPlaylistUri), keys, new DownloaderConstructorHelper(cache, factory));
   }
 
-  private static ArrayList<RenditionKey> getKeys(int... variantIndices) {
-    ArrayList<RenditionKey> renditionKeys = new ArrayList<>();
+  private static ArrayList<StreamKey> getKeys(int... variantIndices) {
+    ArrayList<StreamKey> streamKeys = new ArrayList<>();
     for (int variantIndex : variantIndices) {
-      renditionKeys.add(new RenditionKey(RenditionKey.TYPE_VARIANT, variantIndex));
+      streamKeys.add(new StreamKey(HlsMasterPlaylist.GROUP_INDEX_VARIANT, variantIndex));
     }
-    return renditionKeys;
+    return streamKeys;
   }
 }
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 86426e1f94..d03049efb3 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -75,7 +75,7 @@
 
   private static final String PLAYLIST_WITH_CC =
       " #EXTM3U \n"
-          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
+          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,GROUP-ID=\"cc1\","
           + "LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
           + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
           + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
@@ -90,6 +90,14 @@
           + "CLOSED-CAPTIONS=NONE\n"
           + "http://example.com/low.m3u8\n";
 
+  private static final String PLAYLIST_WITH_SUBTITLES =
+      " #EXTM3U \n"
+          + "#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"sub1\","
+          + "LANGUAGE=\"es\",NAME=\"Eng\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n";
+
   private static final String PLAYLIST_WITH_AUDIO_MEDIA_TAG =
       "#EXTM3U\n"
           + "#EXT-X-STREAM-INF:BANDWIDTH=2227464,CODECS=\"avc1.640020,mp4a.40.2\",AUDIO=\"aud1\"\n"
@@ -105,6 +113,27 @@
           + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aud2\",LANGUAGE=\"en\",NAME=\"English\","
           + "AUTOSELECT=YES,DEFAULT=YES,CHANNELS=\"6\",URI=\"a2/prog_index.m3u8\"\n";
 
+  private static final String PLAYLIST_WITH_INDEPENDENT_SEGMENTS =
+      " #EXTM3U\n"
+          + "\n"
+          + "#EXT-X-INDEPENDENT-SEGMENTS\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+          + "http://example.com/spaces_in_codecs.m3u8\n";
+
+  private static final String PLAYLIST_WITH_VARIABLE_SUBSTITUTION =
+      " #EXTM3U \n"
+          + "\n"
+          + "#EXT-X-DEFINE:NAME=\"codecs\",VALUE=\"mp4a.40.5\"\n"
+          + "#EXT-X-DEFINE:NAME=\"tricky\",VALUE=\"This/{$nested}/reference/shouldnt/work\"\n"
+          + "#EXT-X-DEFINE:NAME=\"nested\",VALUE=\"This should not be inserted\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"{$codecs}\"\n"
+          + "http://example.com/{$tricky}\n";
+
   @Test
   public void testParseMasterPlaylist() throws IOException {
     HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_SIMPLE);
@@ -195,6 +224,53 @@ public void testCodecPropagation() throws IOException {
     assertThat(secondAudioFormat.sampleMimeType).isEqualTo(MimeTypes.AUDIO_AC3);
   }
 
+  @Test
+  public void testAudioIdPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_AUDIO_MEDIA_TAG);
+
+    Format firstAudioFormat = playlist.audios.get(0).format;
+    assertThat(firstAudioFormat.id).isEqualTo("aud1:English");
+
+    Format secondAudioFormat = playlist.audios.get(1).format;
+    assertThat(secondAudioFormat.id).isEqualTo("aud2:English");
+  }
+
+  @Test
+  public void testCCIdPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_CC);
+
+    Format firstTextFormat = playlist.muxedCaptionFormats.get(0);
+    assertThat(firstTextFormat.id).isEqualTo("cc1:Eng");
+  }
+
+  @Test
+  public void testSubtitleIdPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_SUBTITLES);
+
+    Format firstTextFormat = playlist.subtitles.get(0).format;
+    assertThat(firstTextFormat.id).isEqualTo("sub1:Eng");
+  }
+
+  @Test
+  public void testIndependentSegments() throws IOException {
+    HlsMasterPlaylist playlistWithIndependentSegments =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_INDEPENDENT_SEGMENTS);
+    assertThat(playlistWithIndependentSegments.hasIndependentSegments).isTrue();
+
+    HlsMasterPlaylist playlistWithoutIndependentSegments =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_SIMPLE);
+    assertThat(playlistWithoutIndependentSegments.hasIndependentSegments).isFalse();
+  }
+
+  @Test
+  public void testVariableSubstitution() throws IOException {
+    HlsMasterPlaylist playlistWithSubstitutions =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_VARIABLE_SUBSTITUTION);
+    HlsMasterPlaylist.HlsUrl variant = playlistWithSubstitutions.variants.get(0);
+    assertThat(variant.format.codecs).isEqualTo("mp4a.40.5");
+    assertThat(variant.url).isEqualTo("http://example.com/This/{$nested}/reference/shouldnt/work");
+  }
+
   private static HlsMasterPlaylist parseMasterPlaylist(String uri, String playlistString)
       throws IOException {
     Uri playlistUri = Uri.parse(uri);
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
index 7a8a4d7925..e7bf3c6324 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -24,7 +24,8 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,26 +54,25 @@ public void testParseMediaPlaylist() throws Exception {
             + "\n"
             + "#EXT-X-KEY:METHOD=AES-128,"
             + "URI=\"https://priv.example.com/key.php?r=2680\",IV=0x1566B\n"
-            + "#EXTINF:7.975,\n"
+            + "#EXTINF:7.975,segment title\n"
             + "#EXT-X-BYTERANGE:51501@2147483648\n"
             + "https://priv.example.com/fileSequence2680.ts\n"
             + "\n"
             + "#EXT-X-KEY:METHOD=NONE\n"
-            + "#EXTINF:7.941,\n"
+            + "#EXTINF:7.941,segment title .,:/# with interesting chars\n"
             + "#EXT-X-BYTERANGE:51501\n" // @2147535149
             + "https://priv.example.com/fileSequence2681.ts\n"
             + "\n"
             + "#EXT-X-DISCONTINUITY\n"
             + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2682\"\n"
-            + "#EXTINF:7.975,\n"
+            + "#EXTINF:7.975\n" // Trailing comma is omitted.
             + "#EXT-X-BYTERANGE:51740\n" // @2147586650
             + "https://priv.example.com/fileSequence2682.ts\n"
             + "\n"
             + "#EXTINF:7.975,\n"
             + "https://priv.example.com/fileSequence2683.ts\n"
             + "#EXT-X-ENDLIST";
-    InputStream inputStream =
-        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
     HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUri, inputStream);
 
     HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
@@ -82,6 +82,7 @@ public void testParseMediaPlaylist() throws Exception {
     assertThat(mediaPlaylist.mediaSequence).isEqualTo(2679);
     assertThat(mediaPlaylist.version).isEqualTo(3);
     assertThat(mediaPlaylist.hasEndTag).isTrue();
+    assertThat(mediaPlaylist.protectionSchemes).isNull();
     List<Segment> segments = mediaPlaylist.segments;
     assertThat(segments).isNotNull();
     assertThat(segments).hasSize(5);
@@ -90,6 +91,7 @@ public void testParseMediaPlaylist() throws Exception {
     assertThat(mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence)
         .isEqualTo(4);
     assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.title).isEqualTo("");
     assertThat(segment.fullSegmentEncryptionKeyUri).isNull();
     assertThat(segment.encryptionIV).isNull();
     assertThat(segment.byterangeLength).isEqualTo(51370);
@@ -99,6 +101,7 @@ public void testParseMediaPlaylist() throws Exception {
     segment = segments.get(1);
     assertThat(segment.relativeDiscontinuitySequence).isEqualTo(0);
     assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.title).isEqualTo("segment title");
     assertThat(segment.fullSegmentEncryptionKeyUri)
         .isEqualTo("https://priv.example.com/key.php?r=2680");
     assertThat(segment.encryptionIV).isEqualTo("0x1566B");
@@ -109,6 +112,7 @@ public void testParseMediaPlaylist() throws Exception {
     segment = segments.get(2);
     assertThat(segment.relativeDiscontinuitySequence).isEqualTo(0);
     assertThat(segment.durationUs).isEqualTo(7941000);
+    assertThat(segment.title).isEqualTo("segment title .,:/# with interesting chars");
     assertThat(segment.fullSegmentEncryptionKeyUri).isNull();
     assertThat(segment.encryptionIV).isEqualTo(null);
     assertThat(segment.byterangeLength).isEqualTo(51501);
@@ -118,6 +122,7 @@ public void testParseMediaPlaylist() throws Exception {
     segment = segments.get(3);
     assertThat(segment.relativeDiscontinuitySequence).isEqualTo(1);
     assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.title).isEqualTo("");
     assertThat(segment.fullSegmentEncryptionKeyUri)
         .isEqualTo("https://priv.example.com/key.php?r=2682");
     // 0xA7A == 2682.
@@ -130,6 +135,7 @@ public void testParseMediaPlaylist() throws Exception {
     segment = segments.get(4);
     assertThat(segment.relativeDiscontinuitySequence).isEqualTo(1);
     assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.title).isEqualTo("");
     assertThat(segment.fullSegmentEncryptionKeyUri)
         .isEqualTo("https://priv.example.com/key.php?r=2682");
     // 0xA7B == 2683.
@@ -156,12 +162,17 @@ public void testParseSampleAesMethod() throws Exception {
             + "#EXTINF:8,\n"
             + "https://priv.example.com/2.ts\n"
             + "#EXT-X-ENDLIST\n";
-    InputStream inputStream =
-        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
     HlsMediaPlaylist playlist =
         (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
-    assertThat(playlist.drmInitData.schemeType).isEqualTo(C.CENC_TYPE_cbcs);
-    assertThat(playlist.drmInitData.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.schemeType).isEqualTo(C.CENC_TYPE_cbcs);
+    assertThat(playlist.protectionSchemes.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.get(0).hasData()).isFalse();
+
+    assertThat(playlist.segments.get(0).drmInitData).isNull();
+
+    assertThat(playlist.segments.get(1).drmInitData.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.segments.get(1).drmInitData.get(0).hasData()).isTrue();
   }
 
   @Test
@@ -180,12 +191,12 @@ public void testParseSampleAesCencMethod() throws Exception {
             + "#EXTINF:8,\n"
             + "https://priv.example.com/2.ts\n"
             + "#EXT-X-ENDLIST\n";
-    InputStream inputStream =
-        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
     HlsMediaPlaylist playlist =
         (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
-    assertThat(playlist.drmInitData.schemeType).isEqualTo(C.CENC_TYPE_cenc);
-    assertThat(playlist.drmInitData.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.schemeType).isEqualTo(C.CENC_TYPE_cenc);
+    assertThat(playlist.protectionSchemes.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.get(0).hasData()).isFalse();
   }
 
   @Test
@@ -204,12 +215,89 @@ public void testParseSampleAesCtrMethod() throws Exception {
             + "#EXTINF:8,\n"
             + "https://priv.example.com/2.ts\n"
             + "#EXT-X-ENDLIST\n";
-    InputStream inputStream =
-        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
+    HlsMediaPlaylist playlist =
+        (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+    assertThat(playlist.protectionSchemes.schemeType).isEqualTo(C.CENC_TYPE_cenc);
+    assertThat(playlist.protectionSchemes.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.get(0).hasData()).isFalse();
+  }
+
+  @Test
+  public void testMultipleExtXKeysForSingleSegment() throws Exception {
+    Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:6\n"
+            + "#EXT-X-TARGETDURATION:6\n"
+            + "#EXT-X-MAP:URI=\"map.mp4\"\n"
+            + "#EXTINF:5.005,\n"
+            + "s000000.mp4\n"
+            + "#EXT-X-KEY:METHOD=SAMPLE-AES,"
+            + "KEYFORMAT=\"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\","
+            + "KEYFORMATVERSIONS=\"1\","
+            + "URI=\"data:text/plain;base64,Tm90aGluZyB0byBzZWUgaGVyZQ==\"\n"
+            + "#EXT-X-KEY:METHOD=SAMPLE-AES,KEYFORMAT=\"com.microsoft.playready\","
+            + "KEYFORMATVERSIONS=\"1\","
+            + "URI=\"data:text/plain;charset=UTF-16;base64,VGhpcyBpcyBhbiBlYXN0ZXIgZWdn\"\n"
+            + "#EXT-X-KEY:METHOD=SAMPLE-AES,KEYFORMAT=\"com.apple.streamingkeydelivery\","
+            + "KEYFORMATVERSIONS=\"1\",URI=\"skd://QW5vdGhlciBlYXN0ZXIgZWdn\"\n"
+            + "#EXT-X-MAP:URI=\"map.mp4\"\n"
+            + "#EXTINF:5.005,\n"
+            + "s000000.mp4\n"
+            + "#EXTINF:5.005,\n"
+            + "s000001.mp4\n"
+            + "#EXT-X-KEY:METHOD=SAMPLE-AES,"
+            + "KEYFORMAT=\"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\","
+            + "KEYFORMATVERSIONS=\"1\","
+            + "URI=\"data:text/plain;base64,RG9uJ3QgeW91IGdldCB0aXJlZCBvZiBkb2luZyB0aGlzPw==\""
+            + "\n"
+            + "#EXT-X-KEY:METHOD=SAMPLE-AES,KEYFORMAT=\"com.microsoft.playready\","
+            + "KEYFORMATVERSIONS=\"1\","
+            + "URI=\"data:text/plain;charset=UTF-16;base64,T2ssIGl0J3Mgbm90IGZ1biBhbnltb3Jl\"\n"
+            + "#EXT-X-KEY:METHOD=SAMPLE-AES,KEYFORMAT=\"com.apple.streamingkeydelivery\","
+            + "KEYFORMATVERSIONS=\"1\","
+            + "URI=\"skd://V2FpdCB1bnRpbCB5b3Ugc2VlIHRoZSBuZXh0IG9uZSE=\"\n"
+            + "#EXTINF:5.005,\n"
+            + "s000024.mp4\n"
+            + "#EXTINF:5.005,\n"
+            + "s000025.mp4\n"
+            + "#EXT-X-KEY:METHOD=NONE\n"
+            + "#EXTINF:5.005,\n"
+            + "s000026.mp4\n"
+            + "#EXTINF:5.005,\n"
+            + "s000026.mp4\n";
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
     HlsMediaPlaylist playlist =
         (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
-    assertThat(playlist.drmInitData.schemeType).isEqualTo(C.CENC_TYPE_cenc);
-    assertThat(playlist.drmInitData.get(0).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.schemeType).isEqualTo(C.CENC_TYPE_cbcs);
+    // Unsupported protection schemes like com.apple.streamingkeydelivery are ignored.
+    assertThat(playlist.protectionSchemes.schemeDataCount).isEqualTo(2);
+    assertThat(playlist.protectionSchemes.get(0).matches(C.PLAYREADY_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.get(0).hasData()).isFalse();
+    assertThat(playlist.protectionSchemes.get(1).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.protectionSchemes.get(1).hasData()).isFalse();
+
+    assertThat(playlist.segments.get(0).drmInitData).isNull();
+
+    assertThat(playlist.segments.get(1).drmInitData.get(0).matches(C.PLAYREADY_UUID)).isTrue();
+    assertThat(playlist.segments.get(1).drmInitData.get(0).hasData()).isTrue();
+    assertThat(playlist.segments.get(1).drmInitData.get(1).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.segments.get(1).drmInitData.get(1).hasData()).isTrue();
+
+    assertThat(playlist.segments.get(1).drmInitData)
+        .isEqualTo(playlist.segments.get(2).drmInitData);
+    assertThat(playlist.segments.get(2).drmInitData)
+        .isNotEqualTo(playlist.segments.get(3).drmInitData);
+    assertThat(playlist.segments.get(3).drmInitData.get(0).matches(C.PLAYREADY_UUID)).isTrue();
+    assertThat(playlist.segments.get(3).drmInitData.get(0).hasData()).isTrue();
+    assertThat(playlist.segments.get(3).drmInitData.get(1).matches(C.WIDEVINE_UUID)).isTrue();
+    assertThat(playlist.segments.get(3).drmInitData.get(1).hasData()).isTrue();
+
+    assertThat(playlist.segments.get(3).drmInitData)
+        .isEqualTo(playlist.segments.get(4).drmInitData);
+    assertThat(playlist.segments.get(5).drmInitData).isNull();
+    assertThat(playlist.segments.get(6).drmInitData).isNull();
   }
 
   @Test
@@ -237,8 +325,7 @@ public void testGapTag() throws IOException {
             + "02/00/42.ts\n"
             + "#EXTINF:5.005,\n"
             + "02/00/47.ts\n";
-    InputStream inputStream =
-        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
     HlsMediaPlaylist playlist =
         (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
 
@@ -266,8 +353,7 @@ public void testMapTag() throws IOException {
             + "#EXT-X-MAP:URI=\"init2.ts\""
             + "#EXTINF:5.005,\n"
             + "02/00/47.ts\n";
-    InputStream inputStream =
-        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
     HlsMediaPlaylist playlist =
         (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
 
@@ -278,4 +364,105 @@ public void testMapTag() throws IOException {
     assertThat(segments.get(1).initializationSegment.url).isEqualTo("init1.ts");
     assertThat(segments.get(3).initializationSegment.url).isEqualTo("init2.ts");
   }
+
+  @Test
+  public void testMasterPlaylistAttributeInheritance() throws IOException {
+    Uri playlistUri = Uri.parse("https://example.com/test3.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:3\n"
+            + "#EXT-X-TARGETDURATION:5\n"
+            + "#EXT-X-MEDIA-SEQUENCE:10\n"
+            + "#EXTINF:5.005,\n"
+            + "02/00/27.ts\n"
+            + "#EXT-X-MAP:URI=\"init1.ts\""
+            + "#EXTINF:5.005,\n"
+            + "02/00/32.ts\n"
+            + "#EXTINF:5.005,\n"
+            + "02/00/42.ts\n"
+            + "#EXT-X-MAP:URI=\"init2.ts\""
+            + "#EXTINF:5.005,\n"
+            + "02/00/47.ts\n";
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
+    HlsMediaPlaylist standalonePlaylist =
+        (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+    assertThat(standalonePlaylist.hasIndependentSegments).isFalse();
+
+    inputStream.reset();
+    HlsMasterPlaylist masterPlaylist =
+        new HlsMasterPlaylist(
+            /* baseUri= */ "https://example.com/",
+            /* tags= */ Collections.emptyList(),
+            /* variants= */ Collections.emptyList(),
+            /* audios= */ Collections.emptyList(),
+            /* subtitles= */ Collections.emptyList(),
+            /* muxedAudioFormat= */ null,
+            /* muxedCaptionFormats= */ null,
+            /* hasIndependentSegments= */ true,
+            /* variableDefinitions */ Collections.emptyMap());
+    HlsMediaPlaylist playlistWithInheritance =
+        (HlsMediaPlaylist) new HlsPlaylistParser(masterPlaylist).parse(playlistUri, inputStream);
+    assertThat(playlistWithInheritance.hasIndependentSegments).isTrue();
+  }
+
+  @Test
+  public void testVariableSubstitution() throws IOException {
+    Uri playlistUri = Uri.parse("https://example.com/substitution.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:8\n"
+            + "#EXT-X-DEFINE:NAME=\"underscore_1\",VALUE=\"{\"\n"
+            + "#EXT-X-DEFINE:NAME=\"dash-1\",VALUE=\"replaced_value.ts\"\n"
+            + "#EXT-X-TARGETDURATION:5\n"
+            + "#EXT-X-MEDIA-SEQUENCE:10\n"
+            + "#EXTINF:5.005,\n"
+            + "segment1.ts\n"
+            + "#EXT-X-MAP:URI=\"{$dash-1}\""
+            + "#EXTINF:5.005,\n"
+            + "segment{$underscore_1}$name_1}\n";
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
+    HlsMediaPlaylist playlist =
+        (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+    Segment segment = playlist.segments.get(1);
+    assertThat(segment.initializationSegment.url).isEqualTo("replaced_value.ts");
+    assertThat(segment.url).isEqualTo("segment{$name_1}");
+  }
+
+  @Test
+  public void testInheritedVariableSubstitution() throws IOException {
+    Uri playlistUri = Uri.parse("https://example.com/test3.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:8\n"
+            + "#EXT-X-TARGETDURATION:5\n"
+            + "#EXT-X-MEDIA-SEQUENCE:10\n"
+            + "#EXT-X-DEFINE:IMPORT=\"imported_base\"\n"
+            + "#EXTINF:5.005,\n"
+            + "{$imported_base}1.ts\n"
+            + "#EXTINF:5.005,\n"
+            + "{$imported_base}2.ts\n"
+            + "#EXTINF:5.005,\n"
+            + "{$imported_base}3.ts\n"
+            + "#EXTINF:5.005,\n"
+            + "{$imported_base}4.ts\n";
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
+    HashMap<String, String> variableDefinitions = new HashMap<>();
+    variableDefinitions.put("imported_base", "long_path");
+    HlsMasterPlaylist masterPlaylist =
+        new HlsMasterPlaylist(
+            /* baseUri= */ "",
+            /* tags= */ Collections.emptyList(),
+            /* variants= */ Collections.emptyList(),
+            /* audios= */ Collections.emptyList(),
+            /* subtitles= */ Collections.emptyList(),
+            /* muxedAudioFormat= */ null,
+            /* muxedCaptionFormats= */ Collections.emptyList(),
+            /* hasIndependentSegments= */ false,
+            variableDefinitions);
+    HlsMediaPlaylist playlist =
+        (HlsMediaPlaylist) new HlsPlaylistParser(masterPlaylist).parse(playlistUri, inputStream);
+    for (int i = 1; i <= 4; i++) {
+      assertThat(playlist.segments.get(i - 1).url).isEqualTo("long_path" + i + ".ts");
+    }
+  }
 }
diff --git a/library/smoothstreaming/build.gradle b/library/smoothstreaming/build.gradle
index 6f85d1572d..2fce6b697c 100644
--- a/library/smoothstreaming/build.gradle
+++ b/library/smoothstreaming/build.gradle
@@ -18,9 +18,15 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
diff --git a/library/smoothstreaming/proguard-rules.txt b/library/smoothstreaming/proguard-rules.txt
new file mode 100644
index 0000000000..d14244d783
--- /dev/null
+++ b/library/smoothstreaming/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the smoothstreaming module.
+
+# Constructors accessed via reflection in SegmentDownloadAction
+-dontnote com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction
+-keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction {
+  static ** DESERIALIZER;
+}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index de236c3514..9ac376efad 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.smoothstreaming;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
@@ -23,18 +24,20 @@
 import com.google.android.exoplayer2.extractor.mp4.Track;
 import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
+import com.google.android.exoplayer2.source.chunk.BaseMediaChunkIterator;
 import com.google.android.exoplayer2.source.chunk.Chunk;
 import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
 import com.google.android.exoplayer2.source.chunk.ChunkHolder;
-import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
 import com.google.android.exoplayer2.source.chunk.ContainerMediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.List;
@@ -53,10 +56,17 @@ public Factory(DataSource.Factory dataSourceFactory) {
     }
 
     @Override
-    public SsChunkSource createChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
-        SsManifest manifest, int elementIndex, TrackSelection trackSelection,
-        TrackEncryptionBox[] trackEncryptionBoxes) {
+    public SsChunkSource createChunkSource(
+        LoaderErrorThrower manifestLoaderErrorThrower,
+        SsManifest manifest,
+        int elementIndex,
+        TrackSelection trackSelection,
+        TrackEncryptionBox[] trackEncryptionBoxes,
+        @Nullable TransferListener transferListener) {
       DataSource dataSource = dataSourceFactory.createDataSource();
+      if (transferListener != null) {
+        dataSource.addTransferListener(transferListener);
+      }
       return new DefaultSsChunkSource(manifestLoaderErrorThrower, manifest, elementIndex,
           trackSelection, dataSource, trackEncryptionBoxes);
     }
@@ -166,7 +176,10 @@ public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaCh
   }
 
   @Override
-  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+  public final void getNextChunk(
+      long playbackPositionUs,
+      long loadPositionUs,
+      List<? extends MediaChunk> queue,
       ChunkHolder out) {
     if (fatalError != null) {
       return;
@@ -180,10 +193,11 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, lon
     }
 
     int chunkIndex;
-    if (previous == null) {
+    if (queue.isEmpty()) {
       chunkIndex = streamElement.getChunkIndex(loadPositionUs);
     } else {
-      chunkIndex = (int) (previous.getNextChunkIndex() - currentManifestChunkOffset);
+      chunkIndex =
+          (int) (queue.get(queue.size() - 1).getNextChunkIndex() - currentManifestChunkOffset);
       if (chunkIndex < 0) {
         // This is before the first chunk in the current manifest.
         fatalError = new BehindLiveWindowException();
@@ -199,11 +213,18 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, lon
 
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
     long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
-    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
+
+    MediaChunkIterator[] chunkIterators = new MediaChunkIterator[trackSelection.length()];
+    for (int i = 0; i < chunkIterators.length; i++) {
+      int trackIndex = trackSelection.getIndexInTrackGroup(i);
+      chunkIterators[i] = new StreamElementIterator(streamElement, trackIndex, chunkIndex);
+    }
+    trackSelection.updateSelectedTrack(
+        playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs, queue, chunkIterators);
 
     long chunkStartTimeUs = streamElement.getStartTimeUs(chunkIndex);
     long chunkEndTimeUs = chunkStartTimeUs + streamElement.getChunkDurationUs(chunkIndex);
-    long chunkSeekTimeUs = previous == null ? loadPositionUs : C.TIME_UNSET;
+    long chunkSeekTimeUs = queue.isEmpty() ? loadPositionUs : C.TIME_UNSET;
     int currentAbsoluteChunkIndex = chunkIndex + currentManifestChunkOffset;
 
     int trackSelectionIndex = trackSelection.getSelectedIndex();
@@ -233,9 +254,11 @@ public void onChunkLoadCompleted(Chunk chunk) {
   }
 
   @Override
-  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
-    return cancelable && ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
-        trackSelection.indexOf(chunk.trackFormat), e);
+  public boolean onChunkLoadError(
+      Chunk chunk, boolean cancelable, Exception e, long blacklistDurationMs) {
+    return cancelable
+        && blacklistDurationMs != C.TIME_UNSET
+        && trackSelection.blacklist(trackSelection.indexOf(chunk.trackFormat), blacklistDurationMs);
   }
 
   // Private methods.
@@ -265,6 +288,7 @@ private static MediaChunk newMediaChunk(
         chunkStartTimeUs,
         chunkEndTimeUs,
         chunkSeekTimeUs,
+        /* clippedEndTimeUs= */ C.TIME_UNSET,
         chunkIndex,
         /* chunkCount= */ 1,
         sampleOffsetUs,
@@ -283,4 +307,42 @@ private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
     return lastChunkEndTimeUs - playbackPositionUs;
   }
 
+  /** {@link MediaChunkIterator} wrapping a track of a {@link StreamElement}. */
+  private static final class StreamElementIterator extends BaseMediaChunkIterator {
+
+    private final StreamElement streamElement;
+    private final int trackIndex;
+
+    /**
+     * Creates iterator.
+     *
+     * @param streamElement The {@link StreamElement} to wrap.
+     * @param trackIndex The track index in the stream element.
+     * @param chunkIndex The chunk index at which the iterator will start.
+     */
+    public StreamElementIterator(StreamElement streamElement, int trackIndex, int chunkIndex) {
+      super(/* fromIndex= */ chunkIndex, /* toIndex= */ streamElement.chunkCount - 1);
+      this.streamElement = streamElement;
+      this.trackIndex = trackIndex;
+    }
+
+    @Override
+    public DataSpec getDataSpec() {
+      checkInBounds();
+      Uri uri = streamElement.buildRequestUri(trackIndex, (int) getCurrentIndex());
+      return new DataSpec(uri);
+    }
+
+    @Override
+    public long getChunkStartTimeUs() {
+      checkInBounds();
+      return streamElement.getStartTimeUs((int) getCurrentIndex());
+    }
+
+    @Override
+    public long getChunkEndTimeUs() {
+      long chunkStartTimeUs = getChunkStartTimeUs();
+      return chunkStartTimeUs + streamElement.getChunkDurationUs((int) getCurrentIndex());
+    }
+  }
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
index 48491cd0bd..f333a6f92c 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
@@ -15,11 +15,13 @@
  */
 package com.google.android.exoplayer2.source.smoothstreaming;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
 
 /**
  * A {@link ChunkSource} for SmoothStreaming.
@@ -37,6 +39,8 @@
      * @param streamElementIndex The index of the corresponding stream element in the manifest.
      * @param trackSelection The track selection.
      * @param trackEncryptionBoxes Track encryption boxes for the stream.
+     * @param transferListener The transfer listener which should be informed of any data transfers.
+     *     May be null if no listener is available.
      * @return The created {@link SsChunkSource}.
      */
     SsChunkSource createChunkSource(
@@ -44,7 +48,8 @@ SsChunkSource createChunkSource(
         SsManifest manifest,
         int streamElementIndex,
         TrackSelection trackSelection,
-        TrackEncryptionBox[] trackEncryptionBoxes);
+        TrackEncryptionBox[] trackEncryptionBoxes,
+        @Nullable TransferListener transferListener);
   }
 
   /**
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 8e7c3e38c9..14b54bc471 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -32,7 +32,9 @@
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
 import java.util.ArrayList;
 
@@ -45,8 +47,9 @@
   private static final int INITIALIZATION_VECTOR_SIZE = 8;
 
   private final SsChunkSource.Factory chunkSourceFactory;
+  private final @Nullable TransferListener transferListener;
   private final LoaderErrorThrower manifestLoaderErrorThrower;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final EventDispatcher eventDispatcher;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
@@ -59,13 +62,19 @@
   private SequenceableLoader compositeSequenceableLoader;
   private boolean notifiedReadingStarted;
 
-  public SsMediaPeriod(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
+  public SsMediaPeriod(
+      SsManifest manifest,
+      SsChunkSource.Factory chunkSourceFactory,
+      @Nullable TransferListener transferListener,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher,
-      LoaderErrorThrower manifestLoaderErrorThrower, Allocator allocator) {
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
+      EventDispatcher eventDispatcher,
+      LoaderErrorThrower manifestLoaderErrorThrower,
+      Allocator allocator) {
     this.chunkSourceFactory = chunkSourceFactory;
+    this.transferListener = transferListener;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
@@ -214,8 +223,14 @@ public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleSt
   private ChunkSampleStream<SsChunkSource> buildSampleStream(TrackSelection selection,
       long positionUs) {
     int streamElementIndex = trackGroups.indexOf(selection.getTrackGroup());
-    SsChunkSource chunkSource = chunkSourceFactory.createChunkSource(manifestLoaderErrorThrower,
-        manifest, streamElementIndex, selection, trackEncryptionBoxes);
+    SsChunkSource chunkSource =
+        chunkSourceFactory.createChunkSource(
+            manifestLoaderErrorThrower,
+            manifest,
+            streamElementIndex,
+            selection,
+            trackEncryptionBoxes,
+            transferListener);
     return new ChunkSampleStream<>(
         manifest.streamElements[streamElementIndex].type,
         null,
@@ -224,7 +239,7 @@ public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleSt
         this,
         allocator,
         positionUs,
-        minLoadableRetryCount,
+        loadErrorHandlingPolicy,
         eventDispatcher);
   }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index 72d1ba1efd..103a52a55a 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -40,9 +40,13 @@
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsUtil;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -63,11 +67,21 @@
 
     private @Nullable ParsingLoadable.Parser<? extends SsManifest> manifestParser;
     private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
-    private int minLoadableRetryCount;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private long livePresentationDelayMs;
     private boolean isCreateCalled;
     private @Nullable Object tag;
 
+    /**
+     * Creates a new factory for {@link SsMediaSource}s.
+     *
+     * @param dataSourceFactory A factory for {@link DataSource} instances that will be used to load
+     *     manifest and media data.
+     */
+    public Factory(DataSource.Factory dataSourceFactory) {
+      this(new DefaultSsChunkSource.Factory(dataSourceFactory), dataSourceFactory);
+    }
+
     /**
      * Creates a new factory for {@link SsMediaSource}s.
      *
@@ -82,7 +96,7 @@ public Factory(
         @Nullable DataSource.Factory manifestDataSourceFactory) {
       this.chunkSourceFactory = Assertions.checkNotNull(chunkSourceFactory);
       this.manifestDataSourceFactory = manifestDataSourceFactory;
-      minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
       livePresentationDelayMs = DEFAULT_LIVE_PRESENTATION_DELAY_MS;
       compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
     }
@@ -102,16 +116,36 @@ public Factory setTag(Object tag) {
     }
 
     /**
-     * Sets the minimum number of times to retry if a loading error occurs. The default value is
-     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     * Sets the minimum number of times to retry if a loading error occurs. See {@link
+     * #setLoadErrorHandlingPolicy} for the default value.
+     *
+     * <p>Calling this method is equivalent to calling {@link #setLoadErrorHandlingPolicy} with
+     * {@link DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy(int)
+     * DefaultLoadErrorHandlingPolicy(minLoadableRetryCount)}
      *
      * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
      * @return This factory, for convenience.
      * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     * @deprecated Use {@link #setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy)} instead.
      */
+    @Deprecated
     public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      return setLoadErrorHandlingPolicy(new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount));
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy}. The default value is created by calling {@link
+     * DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy()}.
+     *
+     * <p>Calling this method overrides any calls to {@link #setMinLoadableRetryCount(int)}.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
       Assertions.checkState(!isCreateCalled);
-      this.minLoadableRetryCount = minLoadableRetryCount;
+      this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
       return this;
     }
 
@@ -181,7 +215,7 @@ public SsMediaSource createMediaSource(SsManifest manifest) {
           /* manifestParser= */ null,
           chunkSourceFactory,
           compositeSequenceableLoaderFactory,
-          minLoadableRetryCount,
+          loadErrorHandlingPolicy,
           livePresentationDelayMs,
           tag);
     }
@@ -221,7 +255,7 @@ public SsMediaSource createMediaSource(Uri manifestUri) {
           manifestParser,
           chunkSourceFactory,
           compositeSequenceableLoaderFactory,
-          minLoadableRetryCount,
+          loadErrorHandlingPolicy,
           livePresentationDelayMs,
           tag);
     }
@@ -249,10 +283,6 @@ public SsMediaSource createMediaSource(
 
   }
 
-  /**
-   * The default minimum number of times to retry loading data prior to failing.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
   /**
    * The default presentation delay for live streams. The presentation delay is the duration by
    * which the default start position precedes the end of the live window.
@@ -273,7 +303,7 @@ public SsMediaSource createMediaSource(
   private final DataSource.Factory manifestDataSourceFactory;
   private final SsChunkSource.Factory chunkSourceFactory;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
-  private final int minLoadableRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final long livePresentationDelayMs;
   private final EventDispatcher manifestEventDispatcher;
   private final ParsingLoadable.Parser<? extends SsManifest> manifestParser;
@@ -283,6 +313,7 @@ public SsMediaSource createMediaSource(
   private DataSource manifestDataSource;
   private Loader manifestLoader;
   private LoaderErrorThrower manifestLoaderErrorThrower;
+  private @Nullable TransferListener mediaTransferListener;
 
   private long manifestLoadStartTimestamp;
   private SsManifest manifest;
@@ -299,13 +330,18 @@ public SsMediaSource createMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public SsMediaSource(
       SsManifest manifest,
       SsChunkSource.Factory chunkSourceFactory,
       Handler eventHandler,
       MediaSourceEventListener eventListener) {
-    this(manifest, chunkSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT,
-        eventHandler, eventListener);
+    this(
+        manifest,
+        chunkSourceFactory,
+        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT,
+        eventHandler,
+        eventListener);
   }
 
   /**
@@ -332,7 +368,7 @@ public SsMediaSource(
         /* manifestParser= */ null,
         chunkSourceFactory,
         new DefaultCompositeSequenceableLoaderFactory(),
-        minLoadableRetryCount,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
         DEFAULT_LIVE_PRESENTATION_DELAY_MS,
         /* tag= */ null);
     if (eventHandler != null && eventListener != null) {
@@ -353,14 +389,20 @@ public SsMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public SsMediaSource(
       Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
       SsChunkSource.Factory chunkSourceFactory,
       Handler eventHandler,
       MediaSourceEventListener eventListener) {
-    this(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
-        DEFAULT_MIN_LOADABLE_RETRY_COUNT, DEFAULT_LIVE_PRESENTATION_DELAY_MS, eventHandler,
+    this(
+        manifestUri,
+        manifestDataSourceFactory,
+        chunkSourceFactory,
+        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT,
+        DEFAULT_LIVE_PRESENTATION_DELAY_MS,
+        eventHandler,
         eventListener);
   }
 
@@ -380,6 +422,7 @@ public SsMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public SsMediaSource(
       Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
@@ -425,7 +468,7 @@ public SsMediaSource(
         manifestParser,
         chunkSourceFactory,
         new DefaultCompositeSequenceableLoaderFactory(),
-        minLoadableRetryCount,
+        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
         livePresentationDelayMs,
         /* tag= */ null);
     if (eventHandler != null && eventListener != null) {
@@ -440,7 +483,7 @@ private SsMediaSource(
       ParsingLoadable.Parser<? extends SsManifest> manifestParser,
       SsChunkSource.Factory chunkSourceFactory,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
-      int minLoadableRetryCount,
+      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       long livePresentationDelayMs,
       @Nullable Object tag) {
     Assertions.checkState(manifest == null || !manifest.isLive);
@@ -450,7 +493,7 @@ private SsMediaSource(
     this.manifestParser = manifestParser;
     this.chunkSourceFactory = chunkSourceFactory;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
+    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.livePresentationDelayMs = livePresentationDelayMs;
     this.manifestEventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
     this.tag = tag;
@@ -461,7 +504,17 @@ private SsMediaSource(
   // MediaSource implementation.
 
   @Override
-  public void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
+  @Override
+  public void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
+    this.mediaTransferListener = mediaTransferListener;
     if (sideloadedManifest) {
       manifestLoaderErrorThrower = new LoaderErrorThrower.Dummy();
       processManifest();
@@ -481,11 +534,17 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    Assertions.checkArgument(id.periodIndex == 0);
     EventDispatcher eventDispatcher = createEventDispatcher(id);
-    SsMediaPeriod period = new SsMediaPeriod(manifest, chunkSourceFactory,
-        compositeSequenceableLoaderFactory, minLoadableRetryCount, eventDispatcher,
-        manifestLoaderErrorThrower, allocator);
+    SsMediaPeriod period =
+        new SsMediaPeriod(
+            manifest,
+            chunkSourceFactory,
+            mediaTransferListener,
+            compositeSequenceableLoaderFactory,
+            loadErrorHandlingPolicy,
+            eventDispatcher,
+            manifestLoaderErrorThrower,
+            allocator);
     mediaPeriods.add(period);
     return period;
   }
@@ -518,6 +577,8 @@ public void onLoadCompleted(ParsingLoadable<SsManifest> loadable, long elapsedRe
       long loadDurationMs) {
     manifestEventDispatcher.loadCompleted(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -533,6 +594,8 @@ public void onLoadCanceled(ParsingLoadable<SsManifest> loadable, long elapsedRea
       long loadDurationMs, boolean released) {
     manifestEventDispatcher.loadCanceled(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -540,14 +603,17 @@ public void onLoadCanceled(ParsingLoadable<SsManifest> loadable, long elapsedRea
   }
 
   @Override
-  public @Loader.RetryAction int onLoadError(
+  public LoadErrorAction onLoadError(
       ParsingLoadable<SsManifest> loadable,
       long elapsedRealtimeMs,
       long loadDurationMs,
-      IOException error) {
+      IOException error,
+      int errorCount) {
     boolean isFatal = error instanceof ParserException;
     manifestEventDispatcher.loadError(
         loadable.dataSpec,
+        loadable.getUri(),
+        loadable.getResponseHeaders(),
         loadable.type,
         elapsedRealtimeMs,
         loadDurationMs,
@@ -629,18 +695,15 @@ private void scheduleManifestRefresh() {
     }
     long nextLoadTimestamp = manifestLoadStartTimestamp + MINIMUM_MANIFEST_REFRESH_PERIOD_MS;
     long delayUntilNextLoad = Math.max(0, nextLoadTimestamp - SystemClock.elapsedRealtime());
-    manifestRefreshHandler.postDelayed(new Runnable() {
-      @Override
-      public void run() {
-        startLoadingManifest();
-      }
-    }, delayUntilNextLoad);
+    manifestRefreshHandler.postDelayed(this::startLoadingManifest, delayUntilNextLoad);
   }
 
   private void startLoadingManifest() {
     ParsingLoadable<SsManifest> loadable = new ParsingLoadable<>(manifestDataSource,
         manifestUri, C.DATA_TYPE_MANIFEST, manifestParser);
-    long elapsedRealtimeMs = manifestLoader.startLoading(loadable, this, minLoadableRetryCount);
+    long elapsedRealtimeMs =
+        manifestLoader.startLoading(
+            loadable, this, loadErrorHandlingPolicy.getMinimumLoadableRetryCount(loadable.type));
     manifestEventDispatcher.loadStarted(loadable.dataSpec, loadable.type, elapsedRealtimeMs);
   }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
index 396d29fb75..2c508f0fde 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.offline.FilterableManifest;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -33,125 +34,9 @@
  * @see <a href="http://msdn.microsoft.com/en-us/library/ee673436(v=vs.90).aspx">IIS Smooth
  *     Streaming Client Manifest Format</a>
  */
-public class SsManifest implements FilterableManifest<SsManifest, StreamKey> {
+public class SsManifest implements FilterableManifest<SsManifest> {
 
-  public static final int UNSET_LOOKAHEAD = -1;
-
-  /**
-   * The client manifest major version.
-   */
-  public final int majorVersion;
-
-  /**
-   * The client manifest minor version.
-   */
-  public final int minorVersion;
-
-  /**
-   * The number of fragments in a lookahead, or {@link #UNSET_LOOKAHEAD} if the lookahead is
-   * unspecified.
-   */
-  public final int lookAheadCount;
-
-  /**
-   * Whether the manifest describes a live presentation still in progress.
-   */
-  public final boolean isLive;
-
-  /**
-   * Content protection information, or null if the content is not protected.
-   */
-  public final ProtectionElement protectionElement;
-
-  /**
-   * The contained stream elements.
-   */
-  public final StreamElement[] streamElements;
-
-  /**
-   * The overall presentation duration of the media in microseconds, or {@link C#TIME_UNSET}
-   * if the duration is unknown.
-   */
-  public final long durationUs;
-
-  /**
-   * The length of the trailing window for a live broadcast in microseconds, or
-   * {@link C#TIME_UNSET} if the stream is not live or if the window length is unspecified.
-   */
-  public final long dvrWindowLengthUs;
-
-  /**
-   * @param majorVersion The client manifest major version.
-   * @param minorVersion The client manifest minor version.
-   * @param timescale The timescale of the media as the number of units that pass in one second.
-   * @param duration The overall presentation duration in units of the timescale attribute, or 0
-   *     if the duration is unknown.
-   * @param dvrWindowLength The length of the trailing window in units of the timescale attribute,
-   *     or 0 if this attribute is unspecified or not applicable.
-   * @param lookAheadCount The number of fragments in a lookahead, or {@link #UNSET_LOOKAHEAD} if
-   *     this attribute is unspecified or not applicable.
-   * @param isLive True if the manifest describes a live presentation still in progress. False
-   *     otherwise.
-   * @param protectionElement Content protection information, or null if the content is not
-   *     protected.
-   * @param streamElements The contained stream elements.
-   */
-  public SsManifest(int majorVersion, int minorVersion, long timescale, long duration,
-      long dvrWindowLength, int lookAheadCount, boolean isLive, ProtectionElement protectionElement,
-      StreamElement[] streamElements) {
-    this(majorVersion, minorVersion,
-        duration == 0 ? C.TIME_UNSET
-            : Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, timescale),
-        dvrWindowLength == 0 ? C.TIME_UNSET
-            : Util.scaleLargeTimestamp(dvrWindowLength, C.MICROS_PER_SECOND, timescale),
-        lookAheadCount, isLive, protectionElement, streamElements);
-  }
-
-  private SsManifest(int majorVersion, int minorVersion, long durationUs, long dvrWindowLengthUs,
-      int lookAheadCount, boolean isLive, ProtectionElement protectionElement,
-      StreamElement[] streamElements) {
-    this.majorVersion = majorVersion;
-    this.minorVersion = minorVersion;
-    this.durationUs = durationUs;
-    this.dvrWindowLengthUs = dvrWindowLengthUs;
-    this.lookAheadCount = lookAheadCount;
-    this.isLive = isLive;
-    this.protectionElement = protectionElement;
-    this.streamElements = streamElements;
-  }
-
-  @Override
-  public final SsManifest copy(List<StreamKey> streamKeys) {
-    ArrayList<StreamKey> sortedKeys = new ArrayList<>(streamKeys);
-    Collections.sort(sortedKeys);
-
-    StreamElement currentStreamElement = null;
-    List<StreamElement> copiedStreamElements = new ArrayList<>();
-    List<Format> copiedFormats = new ArrayList<>();
-    for (int i = 0; i < sortedKeys.size(); i++) {
-      StreamKey key = sortedKeys.get(i);
-      StreamElement streamElement = streamElements[key.streamElementIndex];
-      if (streamElement != currentStreamElement && currentStreamElement != null) {
-        // We're advancing to a new stream element. Add the current one.
-        copiedStreamElements.add(currentStreamElement.copy(copiedFormats.toArray(new Format[0])));
-        copiedFormats.clear();
-      }
-      currentStreamElement = streamElement;
-      copiedFormats.add(streamElement.formats[key.trackIndex]);
-    }
-    if (currentStreamElement != null) {
-      // Add the last stream element.
-      copiedStreamElements.add(currentStreamElement.copy(copiedFormats.toArray(new Format[0])));
-    }
-
-    StreamElement[] copiedStreamElementsArray = copiedStreamElements.toArray(new StreamElement[0]);
-    return new SsManifest(majorVersion, minorVersion, durationUs, dvrWindowLengthUs, lookAheadCount,
-        isLive, protectionElement, copiedStreamElementsArray);
-  }
-
-  /**
-   * Represents a protection element containing a single header.
-   */
+  /** Represents a protection element containing a single header. */
   public static class ProtectionElement {
 
     public final UUID uuid;
@@ -161,7 +46,6 @@ public ProtectionElement(UUID uuid, byte[] data) {
       this.uuid = uuid;
       this.data = data;
     }
-
   }
 
   /**
@@ -301,7 +185,136 @@ public Uri buildRequestUri(int track, int chunkIndex) {
           .replace(URL_PLACEHOLDER_START_TIME_2, startTimeString);
       return UriUtil.resolveToUri(baseUri, chunkUrl);
     }
+  }
+
+  public static final int UNSET_LOOKAHEAD = -1;
+
+  /** The client manifest major version. */
+  public final int majorVersion;
+
+  /** The client manifest minor version. */
+  public final int minorVersion;
+
+  /**
+   * The number of fragments in a lookahead, or {@link #UNSET_LOOKAHEAD} if the lookahead is
+   * unspecified.
+   */
+  public final int lookAheadCount;
+
+  /** Whether the manifest describes a live presentation still in progress. */
+  public final boolean isLive;
 
+  /** Content protection information, or null if the content is not protected. */
+  public final ProtectionElement protectionElement;
+
+  /** The contained stream elements. */
+  public final StreamElement[] streamElements;
+
+  /**
+   * The overall presentation duration of the media in microseconds, or {@link C#TIME_UNSET} if the
+   * duration is unknown.
+   */
+  public final long durationUs;
+
+  /**
+   * The length of the trailing window for a live broadcast in microseconds, or {@link C#TIME_UNSET}
+   * if the stream is not live or if the window length is unspecified.
+   */
+  public final long dvrWindowLengthUs;
+
+  /**
+   * @param majorVersion The client manifest major version.
+   * @param minorVersion The client manifest minor version.
+   * @param timescale The timescale of the media as the number of units that pass in one second.
+   * @param duration The overall presentation duration in units of the timescale attribute, or 0 if
+   *     the duration is unknown.
+   * @param dvrWindowLength The length of the trailing window in units of the timescale attribute,
+   *     or 0 if this attribute is unspecified or not applicable.
+   * @param lookAheadCount The number of fragments in a lookahead, or {@link #UNSET_LOOKAHEAD} if
+   *     this attribute is unspecified or not applicable.
+   * @param isLive True if the manifest describes a live presentation still in progress. False
+   *     otherwise.
+   * @param protectionElement Content protection information, or null if the content is not
+   *     protected.
+   * @param streamElements The contained stream elements.
+   */
+  public SsManifest(
+      int majorVersion,
+      int minorVersion,
+      long timescale,
+      long duration,
+      long dvrWindowLength,
+      int lookAheadCount,
+      boolean isLive,
+      ProtectionElement protectionElement,
+      StreamElement[] streamElements) {
+    this(
+        majorVersion,
+        minorVersion,
+        duration == 0
+            ? C.TIME_UNSET
+            : Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, timescale),
+        dvrWindowLength == 0
+            ? C.TIME_UNSET
+            : Util.scaleLargeTimestamp(dvrWindowLength, C.MICROS_PER_SECOND, timescale),
+        lookAheadCount,
+        isLive,
+        protectionElement,
+        streamElements);
+  }
+
+  private SsManifest(
+      int majorVersion,
+      int minorVersion,
+      long durationUs,
+      long dvrWindowLengthUs,
+      int lookAheadCount,
+      boolean isLive,
+      ProtectionElement protectionElement,
+      StreamElement[] streamElements) {
+    this.majorVersion = majorVersion;
+    this.minorVersion = minorVersion;
+    this.durationUs = durationUs;
+    this.dvrWindowLengthUs = dvrWindowLengthUs;
+    this.lookAheadCount = lookAheadCount;
+    this.isLive = isLive;
+    this.protectionElement = protectionElement;
+    this.streamElements = streamElements;
   }
 
+  @Override
+  public final SsManifest copy(List<StreamKey> streamKeys) {
+    ArrayList<StreamKey> sortedKeys = new ArrayList<>(streamKeys);
+    Collections.sort(sortedKeys);
+
+    StreamElement currentStreamElement = null;
+    List<StreamElement> copiedStreamElements = new ArrayList<>();
+    List<Format> copiedFormats = new ArrayList<>();
+    for (int i = 0; i < sortedKeys.size(); i++) {
+      StreamKey key = sortedKeys.get(i);
+      StreamElement streamElement = streamElements[key.groupIndex];
+      if (streamElement != currentStreamElement && currentStreamElement != null) {
+        // We're advancing to a new stream element. Add the current one.
+        copiedStreamElements.add(currentStreamElement.copy(copiedFormats.toArray(new Format[0])));
+        copiedFormats.clear();
+      }
+      currentStreamElement = streamElement;
+      copiedFormats.add(streamElement.formats[key.trackIndex]);
+    }
+    if (currentStreamElement != null) {
+      // Add the last stream element.
+      copiedStreamElements.add(currentStreamElement.copy(copiedFormats.toArray(new Format[0])));
+    }
+
+    StreamElement[] copiedStreamElementsArray = copiedStreamElements.toArray(new StreamElement[0]);
+    return new SsManifest(
+        majorVersion,
+        minorVersion,
+        durationUs,
+        dvrWindowLengthUs,
+        lookAheadCount,
+        isLive,
+        protectionElement,
+        copiedStreamElementsArray);
+  }
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 3ca5f8d997..3d5ade403a 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -213,7 +213,7 @@ protected boolean handleChildInline(String tagName) {
 
     /**
      * @param xmlParser The underlying {@link XmlPullParser}
-     * @throws ParserException
+     * @throws ParserException If a parsing error occurs.
      */
     protected void parseStartTag(XmlPullParser xmlParser) throws ParserException {
       // Do nothing.
@@ -378,8 +378,12 @@ public Object build() {
         DrmInitData drmInitData = new DrmInitData(new SchemeData(protectionElement.uuid,
             MimeTypes.VIDEO_MP4, protectionElement.data));
         for (StreamElement streamElement : streamElementArray) {
-          for (int i = 0; i < streamElement.formats.length; i++) {
-            streamElement.formats[i] = streamElement.formats[i].copyWithDrmInitData(drmInitData);
+          int type = streamElement.type;
+          if (type == C.TRACK_TYPE_VIDEO || type == C.TRACK_TYPE_AUDIO) {
+            Format[] formats = streamElement.formats;
+            for (int i = 0; i < formats.length; i++) {
+              formats[i] = formats[i].copyWithDrmInitData(drmInitData);
+            }
           }
         }
       }
@@ -603,6 +607,7 @@ public Object build() {
     private static final String KEY_FOUR_CC = "FourCC";
     private static final String KEY_TYPE = "Type";
     private static final String KEY_LANGUAGE = "Language";
+    private static final String KEY_NAME = "Name";
     private static final String KEY_MAX_WIDTH = "MaxWidth";
     private static final String KEY_MAX_HEIGHT = "MaxHeight";
 
@@ -616,6 +621,7 @@ public QualityLevelParser(ElementParser parent, String baseUri) {
     public void parseStartTag(XmlPullParser parser) throws ParserException {
       int type = (Integer) getNormalizedAttribute(KEY_TYPE);
       String id = parser.getAttributeValue(null, KEY_INDEX);
+      String name = (String) getNormalizedAttribute(KEY_NAME);
       int bitrate = parseRequiredInt(parser, KEY_BITRATE);
       String sampleMimeType = fourCCToMimeType(parseRequiredString(parser, KEY_FOUR_CC));
 
@@ -624,8 +630,19 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         int height = parseRequiredInt(parser, KEY_MAX_HEIGHT);
         List<byte[]> codecSpecificData = buildCodecSpecificData(
             parser.getAttributeValue(null, KEY_CODEC_PRIVATE_DATA));
-        format = Format.createVideoContainerFormat(id, MimeTypes.VIDEO_MP4, sampleMimeType, null,
-            bitrate, width, height, Format.NO_VALUE, codecSpecificData, 0);
+        format =
+            Format.createVideoContainerFormat(
+                id,
+                name,
+                MimeTypes.VIDEO_MP4,
+                sampleMimeType,
+                /* codecs= */ null,
+                bitrate,
+                width,
+                height,
+                /* frameRate= */ Format.NO_VALUE,
+                codecSpecificData,
+                /* selectionFlags= */ 0);
       } else if (type == C.TRACK_TYPE_AUDIO) {
         sampleMimeType = sampleMimeType == null ? MimeTypes.AUDIO_AAC : sampleMimeType;
         int channels = parseRequiredInt(parser, KEY_CHANNELS);
@@ -637,15 +654,42 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
               CodecSpecificDataUtil.buildAacLcAudioSpecificConfig(samplingRate, channels));
         }
         String language = (String) getNormalizedAttribute(KEY_LANGUAGE);
-        format = Format.createAudioContainerFormat(id, MimeTypes.AUDIO_MP4, sampleMimeType, null,
-            bitrate, channels, samplingRate, codecSpecificData, 0, language);
+        format =
+            Format.createAudioContainerFormat(
+                id,
+                name,
+                MimeTypes.AUDIO_MP4,
+                sampleMimeType,
+                /* codecs= */ null,
+                bitrate,
+                channels,
+                samplingRate,
+                codecSpecificData,
+                /* selectionFlags= */ 0,
+                language);
       } else if (type == C.TRACK_TYPE_TEXT) {
         String language = (String) getNormalizedAttribute(KEY_LANGUAGE);
-        format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType,
-            null, bitrate, 0, language);
+        format =
+            Format.createTextContainerFormat(
+                id,
+                name,
+                MimeTypes.APPLICATION_MP4,
+                sampleMimeType,
+                /* codecs= */ null,
+                bitrate,
+                /* selectionFlags= */ 0,
+                language);
       } else {
-        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType, null,
-            bitrate, 0, null);
+        format =
+            Format.createContainerFormat(
+                id,
+                name,
+                MimeTypes.APPLICATION_MP4,
+                sampleMimeType,
+                /* codecs= */ null,
+                bitrate,
+                /* selectionFlags= */ 0,
+                /* language= */ null);
       }
     }
 
@@ -675,7 +719,7 @@ private static String fourCCToMimeType(String fourCC) {
       } else if (fourCC.equalsIgnoreCase("AAC") || fourCC.equalsIgnoreCase("AACL")
           || fourCC.equalsIgnoreCase("AACH") || fourCC.equalsIgnoreCase("AACP")) {
         return MimeTypes.AUDIO_AAC;
-      } else if (fourCC.equalsIgnoreCase("TTML")) {
+      } else if (fourCC.equalsIgnoreCase("TTML") || fourCC.equalsIgnoreCase("DFXP")) {
         return MimeTypes.APPLICATION_TTML;
       } else if (fourCC.equalsIgnoreCase("ac-3") || fourCC.equalsIgnoreCase("dac3")) {
         return MimeTypes.AUDIO_AC3;
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java
index d4b3ef6622..ad2196fd74 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java
@@ -20,24 +20,29 @@
 import com.google.android.exoplayer2.offline.DownloadAction;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.SegmentDownloadAction;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.StreamKey;
+import com.google.android.exoplayer2.offline.StreamKey;
 import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 
 /** An action to download or remove downloaded SmoothStreaming streams. */
-public final class SsDownloadAction extends SegmentDownloadAction<StreamKey> {
+public final class SsDownloadAction extends SegmentDownloadAction {
 
   private static final String TYPE = "ss";
-  private static final int VERSION = 0;
+  private static final int VERSION = 1;
 
   public static final Deserializer DESERIALIZER =
-      new SegmentDownloadActionDeserializer<StreamKey>(TYPE, VERSION) {
+      new SegmentDownloadActionDeserializer(TYPE, VERSION) {
 
         @Override
-        protected StreamKey readKey(DataInputStream input) throws IOException {
-          return new StreamKey(input.readInt(), input.readInt());
+        protected StreamKey readKey(int version, DataInputStream input) throws IOException {
+          if (version > 0) {
+            return super.readKey(version, input);
+          }
+          int groupIndex = input.readInt();
+          int trackIndex = input.readInt();
+          return new StreamKey(groupIndex, trackIndex);
         }
 
         @Override
@@ -47,27 +52,46 @@ protected DownloadAction createDownloadAction(
         }
       };
 
+  /**
+   * Creates a SmoothStreaming download action.
+   *
+   * @param uri The URI of the media to be downloaded.
+   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
+   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded.
+   */
+  public static SsDownloadAction createDownloadAction(
+      Uri uri, @Nullable byte[] data, List<StreamKey> keys) {
+    return new SsDownloadAction(uri, /* isRemoveAction= */ false, data, keys);
+  }
+
+  /**
+   * Creates a SmoothStreaming remove action.
+   *
+   * @param uri The URI of the media to be removed.
+   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
+   */
+  public static SsDownloadAction createRemoveAction(Uri uri, @Nullable byte[] data) {
+    return new SsDownloadAction(uri, /* isRemoveAction= */ true, data, Collections.emptyList());
+  }
+
   /**
    * @param uri The SmoothStreaming manifest URI.
    * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
    * @param data Optional custom data for this action.
    * @param keys Keys of streams to be downloaded. If empty, all streams are downloaded. If {@code
    *     removeAction} is true, {@code keys} must be empty.
+   * @deprecated Use {@link #createDownloadAction(Uri, byte[], List)} or {@link
+   *     #createRemoveAction(Uri, byte[])}.
    */
+  @Deprecated
   public SsDownloadAction(
       Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<StreamKey> keys) {
     super(TYPE, VERSION, uri, isRemoveAction, data, keys);
   }
 
   @Override
-  protected SsDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
+  public SsDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
     return new SsDownloader(uri, keys, constructorHelper);
   }
 
-  @Override
-  protected void writeKey(DataOutputStream output, StreamKey key) throws IOException {
-    output.writeInt(key.streamElementIndex);
-    output.writeInt(key.trackIndex);
-  }
-
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
index e60be93c93..5125beff1c 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
@@ -17,19 +17,19 @@
 
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.offline.TrackKey;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.StreamKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
@@ -49,7 +49,7 @@ public SsDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory) {
   @Override
   protected void prepareInternal() throws IOException {
     DataSource dataSource = manifestDataSourceFactory.createDataSource();
-    manifest = ParsingLoadable.load(dataSource, new SsManifestParser(), uri);
+    manifest = ParsingLoadable.load(dataSource, new SsManifestParser(), uri, C.DATA_TYPE_MANIFEST);
   }
 
   /** Returns the SmoothStreaming manifest. Must not be called until after preparation completes. */
@@ -77,13 +77,12 @@ public TrackGroupArray getTrackGroups(int periodIndex) {
 
   @Override
   public SsDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    return new SsDownloadAction(uri, /* isRemoveAction= */ false, data, toStreamKeys(trackKeys));
+    return SsDownloadAction.createDownloadAction(uri, data, toStreamKeys(trackKeys));
   }
 
   @Override
   public SsDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return new SsDownloadAction(
-        uri, /* isRemoveAction= */ true, data, Collections.<StreamKey>emptyList());
+    return SsDownloadAction.createRemoveAction(uri, data);
   }
 
   private static List<StreamKey> toStreamKeys(List<TrackKey> trackKeys) {
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
index 4fef3eb469..84ef251e5f 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
@@ -19,11 +19,11 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.SegmentDownloader;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsUtil;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.StreamKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
@@ -54,7 +54,7 @@
  *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
  * }</pre>
  */
-public final class SsDownloader extends SegmentDownloader<SsManifest, StreamKey> {
+public final class SsDownloader extends SegmentDownloader<SsManifest> {
 
   /**
    * @param manifestUri The {@link Uri} of the manifest to be downloaded.
@@ -69,10 +69,7 @@ public SsDownloader(
 
   @Override
   protected SsManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
-    ParsingLoadable<SsManifest> loadable =
-        new ParsingLoadable<>(dataSource, uri, C.DATA_TYPE_MANIFEST, new SsManifestParser());
-    loadable.load();
-    return loadable.getResult();
+    return ParsingLoadable.load(dataSource, new SsManifestParser(), uri, C.DATA_TYPE_MANIFEST);
   }
 
   @Override
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
index c7c6c6f3fb..dc8d6754f5 100644
--- a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
@@ -19,6 +19,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -63,9 +64,7 @@ public void testCopyRemoveStreamElement() throws Exception {
     SsManifest sourceManifest =
         newSsManifest(newStreamElement("1", formats[0]), newStreamElement("2", formats[1]));
 
-    List<StreamKey> keys = Arrays.asList(new StreamKey(1, 0));
-    // Keys don't need to be in any particular order
-    Collections.shuffle(keys, new Random(0));
+    List<StreamKey> keys = Collections.singletonList(new StreamKey(1, 0));
 
     SsManifest copyManifest = sourceManifest.copy(keys);
 
@@ -128,12 +127,19 @@ private static StreamElement newStreamElement(String name, Format... formats) {
         768,
         null,
         formats,
-        Collections.<Long>emptyList(),
+        Collections.emptyList(),
         0);
   }
 
   private static Format newFormat(String id) {
     return Format.createContainerFormat(
-        id, MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null, Format.NO_VALUE, 0, null);
+        id,
+        /* label= */ null,
+        MimeTypes.VIDEO_MP4,
+        MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* selectionFlags= */ 0,
+        /* language= */ null);
   }
 }
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadActionTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadActionTest.java
new file mode 100644
index 0000000000..fea03902ec
--- /dev/null
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadActionTest.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.offline.DownloadAction;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit tests for {@link SsDownloadAction}. */
+@RunWith(RobolectricTestRunner.class)
+public class SsDownloadActionTest {
+
+  private Uri uri1;
+  private Uri uri2;
+
+  @Before
+  public void setUp() {
+    uri1 = Uri.parse("http://test/1.uri");
+    uri2 = Uri.parse("http://test/2.uri");
+  }
+
+  @Test
+  public void testDownloadActionIsNotRemoveAction() {
+    DownloadAction action = createDownloadAction(uri1);
+    assertThat(action.isRemoveAction).isFalse();
+  }
+
+  @Test
+  public void testRemoveActionIsRemoveAction() {
+    DownloadAction action2 = createRemoveAction(uri1);
+    assertThat(action2.isRemoveAction).isTrue();
+  }
+
+  @Test
+  public void testCreateDownloader() {
+    MockitoAnnotations.initMocks(this);
+    DownloadAction action = createDownloadAction(uri1);
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    assertThat(action.createDownloader(constructorHelper)).isNotNull();
+  }
+
+  @Test
+  public void testSameUriDifferentAction_IsSameMedia() {
+    DownloadAction action1 = createRemoveAction(uri1);
+    DownloadAction action2 = createDownloadAction(uri1);
+    assertThat(action1.isSameMedia(action2)).isTrue();
+  }
+
+  @Test
+  public void testDifferentUriAndAction_IsNotSameMedia() {
+    DownloadAction action3 = createRemoveAction(uri2);
+    DownloadAction action4 = createDownloadAction(uri1);
+    assertThat(action3.isSameMedia(action4)).isFalse();
+  }
+
+  @SuppressWarnings("EqualsWithItself")
+  @Test
+  public void testEquals() {
+    DownloadAction action1 = createRemoveAction(uri1);
+    assertThat(action1.equals(action1)).isTrue();
+
+    DownloadAction action2 = createRemoveAction(uri1);
+    DownloadAction action3 = createRemoveAction(uri1);
+    assertEqual(action2, action3);
+
+    DownloadAction action4 = createRemoveAction(uri1);
+    DownloadAction action5 = createDownloadAction(uri1);
+    assertNotEqual(action4, action5);
+
+    DownloadAction action6 = createDownloadAction(uri1);
+    DownloadAction action7 = createDownloadAction(uri1, new StreamKey(0, 0));
+    assertNotEqual(action6, action7);
+
+    DownloadAction action8 = createDownloadAction(uri1, new StreamKey(1, 1));
+    DownloadAction action9 = createDownloadAction(uri1, new StreamKey(0, 0));
+    assertNotEqual(action8, action9);
+
+    DownloadAction action10 = createRemoveAction(uri1);
+    DownloadAction action11 = createRemoveAction(uri2);
+    assertNotEqual(action10, action11);
+
+    DownloadAction action12 = createDownloadAction(uri1, new StreamKey(0, 0), new StreamKey(1, 1));
+    DownloadAction action13 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
+    assertEqual(action12, action13);
+
+    DownloadAction action14 = createDownloadAction(uri1, new StreamKey(0, 0));
+    DownloadAction action15 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
+    assertNotEqual(action14, action15);
+
+    DownloadAction action16 = createDownloadAction(uri1);
+    DownloadAction action17 = createDownloadAction(uri1);
+    assertEqual(action16, action17);
+  }
+
+  @Test
+  public void testSerializerGetType() {
+    DownloadAction action = createDownloadAction(uri1);
+    assertThat(action.type).isNotNull();
+  }
+
+  @Test
+  public void testSerializerWriteRead() throws Exception {
+    doTestSerializationRoundTrip(createDownloadAction(uri1));
+    doTestSerializationRoundTrip(createRemoveAction(uri1));
+    doTestSerializationRoundTrip(
+        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
+  }
+
+  @Test
+  public void testSerializerVersion0() throws Exception {
+    doTestSerializationV0RoundTrip(createDownloadAction(uri1));
+    doTestSerializationV0RoundTrip(createRemoveAction(uri1));
+    doTestSerializationV0RoundTrip(
+        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
+  }
+
+  private static void assertNotEqual(DownloadAction action1, DownloadAction action2) {
+    assertThat(action1).isNotEqualTo(action2);
+    assertThat(action2).isNotEqualTo(action1);
+  }
+
+  private static void assertEqual(DownloadAction action1, DownloadAction action2) {
+    assertThat(action1).isEqualTo(action2);
+    assertThat(action2).isEqualTo(action1);
+  }
+
+  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream output = new DataOutputStream(out);
+    DownloadAction.serializeToStream(action, output);
+
+    assertEqual(action, deserializeActionFromStream(out));
+  }
+
+  private static void doTestSerializationV0RoundTrip(SsDownloadAction action) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream output = new DataOutputStream(out);
+    DataOutputStream dataOutputStream = new DataOutputStream(output);
+    dataOutputStream.writeUTF(action.type);
+    dataOutputStream.writeInt(/* version */ 0);
+    dataOutputStream.writeUTF(action.uri.toString());
+    dataOutputStream.writeBoolean(action.isRemoveAction);
+    dataOutputStream.writeInt(action.data.length);
+    dataOutputStream.write(action.data);
+    dataOutputStream.writeInt(action.keys.size());
+    for (int i = 0; i < action.keys.size(); i++) {
+      StreamKey key = action.keys.get(i);
+      dataOutputStream.writeInt(key.groupIndex);
+      dataOutputStream.writeInt(key.trackIndex);
+    }
+    dataOutputStream.flush();
+
+    assertEqual(action, deserializeActionFromStream(out));
+  }
+
+  private static DownloadAction deserializeActionFromStream(ByteArrayOutputStream out)
+      throws IOException {
+    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
+    DataInputStream input = new DataInputStream(in);
+    return DownloadAction.deserializeFromStream(
+        new DownloadAction.Deserializer[] {SsDownloadAction.DESERIALIZER}, input);
+  }
+
+  private static SsDownloadAction createDownloadAction(Uri uri, StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
+    Collections.addAll(keysList, keys);
+    return SsDownloadAction.createDownloadAction(uri, null, keysList);
+  }
+
+  private static SsDownloadAction createRemoveAction(Uri uri) {
+    return SsDownloadAction.createRemoveAction(uri, null);
+  }
+}
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index e481912f82..9f18d169da 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -17,6 +17,11 @@ apply plugin: 'com.android.library'
 android {
     compileSdkVersion project.ext.compileSdkVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
@@ -37,6 +42,7 @@ dependencies {
     implementation 'com.android.support:support-media-compat:' + supportLibraryVersion
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index 227eb52e79..0d4c6a4038 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -20,6 +20,7 @@
 import android.support.annotation.IntDef;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -45,7 +46,12 @@ void onAspectRatioUpdated(
   }
 
   // LINT.IfChange
-  /** Resize modes for {@link AspectRatioFrameLayout}. */
+  /**
+   * Resize modes for {@link AspectRatioFrameLayout}. One of {@link #RESIZE_MODE_FIT}, {@link
+   * #RESIZE_MODE_FIXED_WIDTH}, {@link #RESIZE_MODE_FIXED_HEIGHT}, {@link #RESIZE_MODE_FILL} or
+   * {@link #RESIZE_MODE_ZOOM}.
+   */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     RESIZE_MODE_FIT,
@@ -136,17 +142,15 @@ public void setAspectRatioListener(AspectRatioListener listener) {
     this.aspectRatioListener = listener;
   }
 
-  /**
-   * Returns the resize mode.
-   */
+  /** Returns the {@link ResizeMode}. */
   public @ResizeMode int getResizeMode() {
     return resizeMode;
   }
 
   /**
-   * Sets the resize mode.
+   * Sets the {@link ResizeMode}
    *
-   * @param resizeMode The resize mode.
+   * @param resizeMode The {@link ResizeMode}.
    */
   public void setResizeMode(@ResizeMode int resizeMode) {
     if (this.resizeMode != resizeMode) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
index 6066445e9d..8c7c507f92 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
@@ -16,18 +16,20 @@
 package com.google.android.exoplayer2.ui;
 
 import android.annotation.SuppressLint;
+import android.os.Looper;
 import android.widget.TextView;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.util.Assertions;
 import java.util.Locale;
 
 /**
  * A helper class for periodically updating a {@link TextView} with debug information obtained from
  * a {@link SimpleExoPlayer}.
  */
-public class DebugTextViewHelper extends Player.DefaultEventListener implements Runnable {
+public class DebugTextViewHelper implements Player.EventListener, Runnable {
 
   private static final int REFRESH_INTERVAL_MS = 1000;
 
@@ -37,10 +39,13 @@
   private boolean started;
 
   /**
-   * @param player The {@link SimpleExoPlayer} from which debug information should be obtained.
+   * @param player The {@link SimpleExoPlayer} from which debug information should be obtained. Only
+   *     players which are accessed on the main thread are supported ({@code
+   *     player.getApplicationLooper() == Looper.getMainLooper()}).
    * @param textView The {@link TextView} that should be updated to display the information.
    */
   public DebugTextViewHelper(SimpleExoPlayer player, TextView textView) {
+    Assertions.checkArgument(player.getApplicationLooper() == Looper.getMainLooper());
     this.player = player;
     this.textView = textView;
   }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index 05c645d9c7..75c4f71b64 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -174,6 +174,12 @@
   private static final long STOP_SCRUBBING_TIMEOUT_MS = 1000;
   private static final int DEFAULT_INCREMENT_COUNT = 20;
 
+  /**
+   * The name of the Android SDK view that most closely resembles this custom view. Used as the
+   * class name for accessibility.
+   */
+  private static final String ACCESSIBILITY_CLASS_NAME = "android.widget.SeekBar";
+
   private final Rect seekBounds;
   private final Rect progressBar;
   private final Rect bufferedBar;
@@ -184,7 +190,7 @@
   private final Paint adMarkerPaint;
   private final Paint playedAdMarkerPaint;
   private final Paint scrubberPaint;
-  private final Drawable scrubberDrawable;
+  private final @Nullable Drawable scrubberDrawable;
   private final int barHeight;
   private final int touchTargetHeight;
   private final int adMarkerWidth;
@@ -197,12 +203,12 @@
   private final Formatter formatter;
   private final Runnable stopScrubbingRunnable;
   private final CopyOnWriteArraySet<OnScrubListener> listeners;
+  private final int[] locationOnScreen;
+  private final Point touchPosition;
 
   private int keyCountIncrement;
   private long keyTimeIncrement;
   private int lastCoarseScrubXPosition;
-  private int[] locationOnScreen;
-  private Point touchPosition;
 
   private boolean scrubbing;
   private long scrubPosition;
@@ -210,12 +216,12 @@
   private long position;
   private long bufferedPosition;
   private int adGroupCount;
-  private long[] adGroupTimesMs;
-  private boolean[] playedAdGroups;
+  private @Nullable long[] adGroupTimesMs;
+  private @Nullable boolean[] playedAdGroups;
 
-  /**
-   * Creates a new time bar.
-   */
+  /** Creates a new time bar. */
+  // Suppress warnings due to usage of View methods in the constructor.
+  @SuppressWarnings("nullness:method.invocation.invalid")
   public DefaultTimeBar(Context context, AttributeSet attrs) {
     super(context, attrs);
     seekBounds = new Rect();
@@ -230,6 +236,8 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     scrubberPaint = new Paint();
     scrubberPaint.setAntiAlias(true);
     listeners = new CopyOnWriteArraySet<>();
+    locationOnScreen = new int[2];
+    touchPosition = new Point();
 
     // Calculate the dimensions and paints for drawn elements.
     Resources res = context.getResources();
@@ -299,12 +307,7 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     }
     formatBuilder = new StringBuilder();
     formatter = new Formatter(formatBuilder, Locale.getDefault());
-    stopScrubbingRunnable = new Runnable() {
-      @Override
-      public void run() {
-        stopScrubbing(false);
-      }
-    };
+    stopScrubbingRunnable = () -> stopScrubbing(/* canceled= */ false);
     if (scrubberDrawable != null) {
       scrubberPadding = (scrubberDrawable.getMinimumWidth() + 1) / 2;
     } else {
@@ -593,14 +596,14 @@ public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
     if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SELECTED) {
       event.getText().add(getProgressText());
     }
-    event.setClassName(DefaultTimeBar.class.getName());
+    event.setClassName(ACCESSIBILITY_CLASS_NAME);
   }
 
   @TargetApi(21)
   @Override
   public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
     super.onInitializeAccessibilityNodeInfo(info);
-    info.setClassName(DefaultTimeBar.class.getCanonicalName());
+    info.setClassName(ACCESSIBILITY_CLASS_NAME);
     info.setContentDescription(getProgressText());
     if (duration <= 0) {
       return;
@@ -616,7 +619,7 @@ public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
 
   @TargetApi(16)
   @Override
-  public boolean performAccessibilityAction(int action, Bundle args) {
+  public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
     if (super.performAccessibilityAction(action, args)) {
       return true;
     }
@@ -693,10 +696,6 @@ private void positionScrubber(float xPosition) {
   }
 
   private Point resolveRelativeTouchPosition(MotionEvent motionEvent) {
-    if (locationOnScreen == null) {
-      locationOnScreen = new int[2];
-      touchPosition = new Point();
-    }
     getLocationOnScreen(locationOnScreen);
     touchPosition.set(
         ((int) motionEvent.getRawX()) - locationOnScreen[0],
@@ -736,6 +735,11 @@ private void drawTimeBar(Canvas canvas) {
     if (scrubberBar.width() > 0) {
       canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, playedPaint);
     }
+    if (adGroupCount == 0) {
+      return;
+    }
+    long[] adGroupTimesMs = Assertions.checkNotNull(this.adGroupTimesMs);
+    boolean[] playedAdGroups = Assertions.checkNotNull(this.playedAdGroups);
     int adMarkerOffset = adMarkerWidth / 2;
     for (int i = 0; i < adGroupCount; i++) {
       long adGroupTimeMs = Util.constrainValue(adGroupTimesMs[i], 0, duration);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java
index b36941e999..5d68387869 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java
@@ -43,11 +43,11 @@ public String getTrackName(Format format) {
     } else if (trackType == C.TRACK_TYPE_AUDIO) {
       trackName =
           joinWithSeparator(
-              buildLanguageString(format),
+              buildLabelString(format),
               buildAudioChannelString(format),
               buildBitrateString(format));
     } else {
-      trackName = buildLanguageString(format);
+      trackName = buildLabelString(format);
     }
     return trackName.length() == 0 ? resources.getString(R.string.exo_track_unknown) : trackName;
   }
@@ -87,7 +87,11 @@ private String buildAudioChannelString(Format format) {
     }
   }
 
-  private String buildLanguageString(Format format) {
+  private String buildLabelString(Format format) {
+    if (!TextUtils.isEmpty(format.label)) {
+      return format.label;
+    }
+    // Fall back to using the language.
     String language = format.language;
     return TextUtils.isEmpty(language) || C.LANGUAGE_UNDETERMINED.equals(language)
         ? ""
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java
index 0a841fa38f..97832abfc7 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java
@@ -55,10 +55,18 @@ public static Notification buildProgressNotification(
     int downloadTaskCount = 0;
     boolean allDownloadPercentagesUnknown = true;
     boolean haveDownloadedBytes = false;
+    boolean haveDownloadTasks = false;
+    boolean haveRemoveTasks = false;
     for (TaskState taskState : taskStates) {
-      if (taskState.action.isRemoveAction || taskState.state != TaskState.STATE_STARTED) {
+      if (taskState.state != TaskState.STATE_STARTED
+          && taskState.state != TaskState.STATE_COMPLETED) {
         continue;
       }
+      if (taskState.action.isRemoveAction) {
+        haveRemoveTasks = true;
+        continue;
+      }
+      haveDownloadTasks = true;
       if (taskState.downloadPercentage != C.PERCENTAGE_UNSET) {
         allDownloadPercentagesUnknown = false;
         totalPercentage += taskState.downloadPercentage;
@@ -67,18 +75,20 @@ public static Notification buildProgressNotification(
       downloadTaskCount++;
     }
 
-    boolean haveDownloadTasks = downloadTaskCount > 0;
     int titleStringId =
         haveDownloadTasks
             ? R.string.exo_download_downloading
-            : (taskStates.length > 0 ? R.string.exo_download_removing : NULL_STRING_ID);
+            : (haveRemoveTasks ? R.string.exo_download_removing : NULL_STRING_ID);
     NotificationCompat.Builder notificationBuilder =
         newNotificationBuilder(
             context, smallIcon, channelId, contentIntent, message, titleStringId);
 
-    int progress = haveDownloadTasks ? (int) (totalPercentage / downloadTaskCount) : 0;
-    boolean indeterminate =
-        !haveDownloadTasks || (allDownloadPercentagesUnknown && haveDownloadedBytes);
+    int progress = 0;
+    boolean indeterminate = true;
+    if (haveDownloadTasks) {
+      progress = (int) (totalPercentage / downloadTaskCount);
+      indeterminate = allDownloadPercentagesUnknown && haveDownloadedBytes;
+    }
     notificationBuilder.setProgress(/* max= */ 100, progress, indeterminate);
     notificationBuilder.setOngoing(true);
     notificationBuilder.setShowWhen(false);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index da03d28cba..5467538c0f 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -34,10 +34,13 @@
   public interface VisibilityListener
       extends com.google.android.exoplayer2.ui.PlayerControlView.VisibilityListener {}
 
+  @Deprecated
+  @SuppressWarnings("deprecation")
   private static final class DefaultControlDispatcher
       extends com.google.android.exoplayer2.DefaultControlDispatcher implements ControlDispatcher {}
   /** @deprecated Use {@link com.google.android.exoplayer2.DefaultControlDispatcher}. */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public static final ControlDispatcher DEFAULT_CONTROL_DISPATCHER = new DefaultControlDispatcher();
 
   /** The default fast forward increment, in milliseconds. */
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index 63c791d166..8ab4210465 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -20,11 +20,13 @@
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.graphics.drawable.Drawable;
+import android.os.Looper;
 import android.os.SystemClock;
 import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
+import android.view.MotionEvent;
 import android.view.View;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
@@ -87,7 +89,7 @@
  *       below for more details.
  *       <ul>
  *         <li>Corresponding method: None
- *         <li>Default: {@code R.id.exo_player_control_view}
+ *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
  * </ul>
  *
@@ -207,6 +209,8 @@
   private final Formatter formatter;
   private final Timeline.Period period;
   private final Timeline.Window window;
+  private final Runnable updateProgressAction;
+  private final Runnable hideAction;
 
   private final Drawable repeatOffButtonDrawable;
   private final Drawable repeatOneButtonDrawable;
@@ -235,22 +239,6 @@
   private long[] extraAdGroupTimesMs;
   private boolean[] extraPlayedAdGroups;
 
-  private final Runnable updateProgressAction =
-      new Runnable() {
-        @Override
-        public void run() {
-          updateProgress();
-        }
-      };
-
-  private final Runnable hideAction =
-      new Runnable() {
-        @Override
-        public void run() {
-          hide();
-        }
-      };
-
   public PlayerControlView(Context context) {
     this(context, null);
   }
@@ -302,6 +290,8 @@ public PlayerControlView(
     extraPlayedAdGroups = new boolean[0];
     componentListener = new ComponentListener();
     controlDispatcher = new com.google.android.exoplayer2.DefaultControlDispatcher();
+    updateProgressAction = this::updateProgress;
+    hideAction = this::hide;
 
     LayoutInflater.from(context).inflate(controllerLayoutId, this);
     setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
@@ -373,9 +363,14 @@ public Player getPlayer() {
   /**
    * Sets the {@link Player} to control.
    *
-   * @param player The {@link Player} to control.
+   * @param player The {@link Player} to control, or {@code null} to detach the current player. Only
+   *     players which are accessed on the main thread are supported ({@code
+   *     player.getApplicationLooper() == Looper.getMainLooper()}).
    */
-  public void setPlayer(Player player) {
+  public void setPlayer(@Nullable Player player) {
+    Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());
+    Assertions.checkArgument(
+        player == null || player.getApplicationLooper() == Looper.getMainLooper());
     if (this.player == player) {
       return;
     }
@@ -534,6 +529,7 @@ public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatTog
         controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ALL);
       }
     }
+    updateRepeatModeButton();
   }
 
   /** Returns whether the shuffle button is shown. */
@@ -638,9 +634,8 @@ private void updateNavigation() {
       int windowIndex = player.getCurrentWindowIndex();
       timeline.getWindow(windowIndex, window);
       isSeekable = window.isSeekable;
-      enablePrevious =
-          isSeekable || !window.isDynamic || player.getPreviousWindowIndex() != C.INDEX_UNSET;
-      enableNext = window.isDynamic || player.getNextWindowIndex() != C.INDEX_UNSET;
+      enablePrevious = isSeekable || !window.isDynamic || player.hasPrevious();
+      enableNext = window.isDynamic || player.hasNext();
     }
     setButtonEnabled(enablePrevious, previousButton);
     setButtonEnabled(enableNext, nextButton);
@@ -715,7 +710,7 @@ private void updateProgress() {
     long bufferedPosition = 0;
     long duration = 0;
     if (player != null) {
-      long currentWindowTimeBarOffsetUs = 0;
+      long currentWindowTimeBarOffsetMs = 0;
       long durationUs = 0;
       int adGroupCount = 0;
       Timeline timeline = player.getCurrentTimeline();
@@ -726,7 +721,7 @@ private void updateProgress() {
             multiWindowTimeBar ? timeline.getWindowCount() - 1 : currentWindowIndex;
         for (int i = firstWindowIndex; i <= lastWindowIndex; i++) {
           if (i == currentWindowIndex) {
-            currentWindowTimeBarOffsetUs = durationUs;
+            currentWindowTimeBarOffsetMs = C.usToMs(durationUs);
           }
           timeline.getWindow(i, window);
           if (window.durationUs == C.TIME_UNSET) {
@@ -762,15 +757,8 @@ private void updateProgress() {
         }
       }
       duration = C.usToMs(durationUs);
-      position = C.usToMs(currentWindowTimeBarOffsetUs);
-      bufferedPosition = position;
-      if (player.isPlayingAd()) {
-        position += player.getContentPosition();
-        bufferedPosition = position;
-      } else {
-        position += player.getCurrentPosition();
-        bufferedPosition += player.getBufferedPosition();
-      }
+      position = currentWindowTimeBarOffsetMs + player.getContentPosition();
+      bufferedPosition = currentWindowTimeBarOffsetMs + player.getContentBufferedPosition();
       if (timeBar != null) {
         int extraAdGroupCount = extraAdGroupTimesMs.length;
         int totalAdGroupCount = adGroupCount + extraAdGroupCount;
@@ -842,7 +830,7 @@ private void setButtonEnabled(boolean enabled, View view) {
 
   private void previous() {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = player.getCurrentWindowIndex();
@@ -859,14 +847,14 @@ private void previous() {
 
   private void next() {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = player.getCurrentWindowIndex();
     int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
       seekTo(nextWindowIndex, C.TIME_UNSET);
-    } else if (timeline.getWindow(windowIndex, window, false).isDynamic) {
+    } else if (timeline.getWindow(windowIndex, window).isDynamic) {
       seekTo(windowIndex, C.TIME_UNSET);
     }
   }
@@ -952,6 +940,16 @@ public void onDetachedFromWindow() {
     removeCallbacks(hideAction);
   }
 
+  @Override
+  public final boolean dispatchTouchEvent(MotionEvent ev) {
+    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
+      removeCallbacks(hideAction);
+    } else if (ev.getAction() == MotionEvent.ACTION_UP) {
+      hideAfterTimeout();
+    }
+    return super.dispatchTouchEvent(ev);
+  }
+
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
     return dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
@@ -1037,12 +1035,11 @@ private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Win
     return true;
   }
 
-  private final class ComponentListener extends Player.DefaultEventListener
-      implements TimeBar.OnScrubListener, OnClickListener {
+  private final class ComponentListener
+      implements Player.EventListener, TimeBar.OnScrubListener, OnClickListener {
 
     @Override
     public void onScrubStart(TimeBar timeBar, long position) {
-      removeCallbacks(hideAction);
       scrubbing = true;
     }
 
@@ -1059,7 +1056,6 @@ public void onScrubStop(TimeBar timeBar, long position, boolean canceled) {
       if (!canceled && player != null) {
         seekToTimeBarPosition(position);
       }
-      hideAfterTimeout();
     }
 
     @Override
@@ -1088,7 +1084,7 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
 
     @Override
     public void onTimelineChanged(
-        Timeline timeline, Object manifest, @Player.TimelineChangeReason int reason) {
+        Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
       updateNavigation();
       updateTimeBarMode();
       updateProgress();
@@ -1123,7 +1119,6 @@ public void onClick(View view) {
           controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
         }
       }
-      hideAfterTimeout();
     }
   }
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index 19051ba932..47025d9bba 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer2.ui;
 
-import static java.lang.annotation.RetentionPolicy.SOURCE;
-
 import android.app.Notification;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
@@ -44,7 +42,9 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.NotificationUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -146,8 +146,23 @@
   /** Defines and handles custom actions. */
   public interface CustomActionReceiver {
 
-    /** Gets the actions handled by this receiver. */
-    Map<String, NotificationCompat.Action> createCustomActions(Context context);
+    /**
+     * Gets the actions handled by this receiver.
+     *
+     * <p>If multiple {@link PlayerNotificationManager} instances are in use at the same time, the
+     * {@code instanceId} must be set as an intent extra with key {@link
+     * PlayerNotificationManager#EXTRA_INSTANCE_ID} to avoid sending the action to every custom
+     * action receiver. It's also necessary to ensure something is different about the actions. This
+     * may be any of the {@link Intent} attributes considered by {@link Intent#filterEquals}, or
+     * different request code integers when creating the {@link PendingIntent}s with {@link
+     * PendingIntent#getBroadcast}. The easiest approach is to use the {@code instanceId} as the
+     * request code.
+     *
+     * @param context The {@link Context}.
+     * @param instanceId The instance id of the {@link PlayerNotificationManager}.
+     * @return A map of custom actions.
+     */
+    Map<String, NotificationCompat.Action> createCustomActions(Context context, int instanceId);
 
     /**
      * Gets the actions to be included in the notification given the current player state.
@@ -203,14 +218,11 @@ private BitmapCallback(int notificationTag) {
     public void onBitmap(final Bitmap bitmap) {
       if (bitmap != null) {
         mainHandler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                if (player != null
-                    && notificationTag == currentNotificationTag
-                    && isNotificationStarted) {
-                  updateNotification(bitmap);
-                }
+            () -> {
+              if (player != null
+                  && notificationTag == currentNotificationTag
+                  && isNotificationStarted) {
+                updateNotification(bitmap);
               }
             });
       }
@@ -231,9 +243,16 @@ public void run() {
   public static final String ACTION_REWIND = "com.google.android.exoplayer.rewind";
   /** The action which cancels the notification and stops playback. */
   public static final String ACTION_STOP = "com.google.android.exoplayer.stop";
+  /** The extra key of the instance id of the player notification manager. */
+  public static final String EXTRA_INSTANCE_ID = "INSTANCE_ID";
 
-  /** Visibility of notification on the lock screen. */
-  @Retention(SOURCE)
+  /**
+   * Visibility of notification on the lock screen. One of {@link
+   * NotificationCompat#VISIBILITY_PRIVATE}, {@link NotificationCompat#VISIBILITY_PUBLIC} or {@link
+   * NotificationCompat#VISIBILITY_SECRET}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NotificationCompat.VISIBILITY_PRIVATE,
     NotificationCompat.VISIBILITY_PUBLIC,
@@ -241,8 +260,14 @@ public void run() {
   })
   public @interface Visibility {}
 
-  /** Priority of the notification (required for API 25 and lower). */
-  @Retention(SOURCE)
+  /**
+   * Priority of the notification (required for API 25 and lower). One of {@link
+   * NotificationCompat#PRIORITY_DEFAULT}, {@link NotificationCompat#PRIORITY_MAX}, {@link
+   * NotificationCompat#PRIORITY_HIGH}, {@link NotificationCompat#PRIORITY_LOW }or {@link
+   * NotificationCompat#PRIORITY_MIN}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NotificationCompat.PRIORITY_DEFAULT,
     NotificationCompat.PRIORITY_MAX,
@@ -259,6 +284,8 @@ public void run() {
 
   private static final long MAX_POSITION_FOR_SEEK_TO_PREVIOUS = 3000;
 
+  private static int instanceIdCounter;
+
   private final Context context;
   private final String channelId;
   private final int notificationId;
@@ -271,6 +298,7 @@ public void run() {
   private final NotificationBroadcastReceiver notificationBroadcastReceiver;
   private final Map<String, NotificationCompat.Action> playbackActions;
   private final Map<String, NotificationCompat.Action> customActions;
+  private final int instanceId;
 
   private @Nullable Player player;
   private ControlDispatcher controlDispatcher;
@@ -363,6 +391,7 @@ public PlayerNotificationManager(
     this.mediaDescriptionAdapter = mediaDescriptionAdapter;
     this.customActionReceiver = customActionReceiver;
     this.controlDispatcher = new DefaultControlDispatcher();
+    instanceId = instanceIdCounter++;
     mainHandler = new Handler(Looper.getMainLooper());
     notificationManager = NotificationManagerCompat.from(context);
     playerListener = new PlayerListener();
@@ -384,14 +413,14 @@ public PlayerNotificationManager(
     visibility = NotificationCompat.VISIBILITY_PUBLIC;
 
     // initialize actions
-    playbackActions = createPlaybackActions(context);
+    playbackActions = createPlaybackActions(context, instanceId);
     for (String action : playbackActions.keySet()) {
       intentFilter.addAction(action);
     }
     customActions =
         customActionReceiver != null
-            ? customActionReceiver.createCustomActions(context)
-            : Collections.<String, NotificationCompat.Action>emptyMap();
+            ? customActionReceiver.createCustomActions(context, instanceId)
+            : Collections.emptyMap();
     for (String action : customActions.keySet()) {
       intentFilter.addAction(action);
     }
@@ -407,8 +436,15 @@ public PlayerNotificationManager(
    *
    * <p>If the player is released it must be removed from the manager by calling {@code
    * setPlayer(null)}. This will cancel the notification.
+   *
+   * @param player The {@link Player} to use, or {@code null} to remove the current player. Only
+   *     players which are accessed on the main thread are supported ({@code
+   *     player.getApplicationLooper() == Looper.getMainLooper()}).
    */
   public final void setPlayer(@Nullable Player player) {
+    Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());
+    Assertions.checkArgument(
+        player == null || player.getApplicationLooper() == Looper.getMainLooper());
     if (this.player == player) {
       return;
     }
@@ -460,7 +496,7 @@ public final void setFastForwardIncrementMs(long fastForwardMs) {
       return;
     }
     this.fastForwardMs = fastForwardMs;
-    maybeUpdateNotification();
+    invalidate();
   }
 
   /**
@@ -474,7 +510,7 @@ public final void setRewindIncrementMs(long rewindMs) {
       return;
     }
     this.rewindMs = rewindMs;
-    maybeUpdateNotification();
+    invalidate();
   }
 
   /**
@@ -485,7 +521,7 @@ public final void setRewindIncrementMs(long rewindMs) {
   public final void setUseNavigationActions(boolean useNavigationActions) {
     if (this.useNavigationActions != useNavigationActions) {
       this.useNavigationActions = useNavigationActions;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -497,7 +533,7 @@ public final void setUseNavigationActions(boolean useNavigationActions) {
   public final void setUsePlayPauseActions(boolean usePlayPauseActions) {
     if (this.usePlayPauseActions != usePlayPauseActions) {
       this.usePlayPauseActions = usePlayPauseActions;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -520,7 +556,7 @@ public final void setStopAction(@Nullable String stopAction) {
     } else {
       stopPendingIntent = null;
     }
-    maybeUpdateNotification();
+    invalidate();
   }
 
   /**
@@ -531,7 +567,7 @@ public final void setStopAction(@Nullable String stopAction) {
   public final void setMediaSessionToken(MediaSessionCompat.Token token) {
     if (!Util.areEqual(this.mediaSessionToken, token)) {
       mediaSessionToken = token;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -555,7 +591,7 @@ public final void setBadgeIconType(@NotificationCompat.BadgeIconType int badgeIc
       default:
         throw new IllegalArgumentException();
     }
-    maybeUpdateNotification();
+    invalidate();
   }
 
   /**
@@ -569,7 +605,7 @@ public final void setBadgeIconType(@NotificationCompat.BadgeIconType int badgeIc
   public final void setColorized(boolean colorized) {
     if (this.colorized != colorized) {
       this.colorized = colorized;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -583,7 +619,7 @@ public final void setColorized(boolean colorized) {
   public final void setDefaults(int defaults) {
     if (this.defaults != defaults) {
       this.defaults = defaults;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -597,7 +633,7 @@ public final void setDefaults(int defaults) {
   public final void setColor(int color) {
     if (this.color != color) {
       this.color = color;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -613,7 +649,7 @@ public final void setColor(int color) {
   public final void setOngoing(boolean ongoing) {
     if (this.ongoing != ongoing) {
       this.ongoing = ongoing;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -642,7 +678,7 @@ public final void setPriority(@Priority int priority) {
       default:
         throw new IllegalArgumentException();
     }
-    maybeUpdateNotification();
+    invalidate();
   }
 
   /**
@@ -655,7 +691,7 @@ public final void setPriority(@Priority int priority) {
   public final void setSmallIcon(@DrawableRes int smallIconResourceId) {
     if (this.smallIconResourceId != smallIconResourceId) {
       this.smallIconResourceId = smallIconResourceId;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -669,7 +705,7 @@ public final void setSmallIcon(@DrawableRes int smallIconResourceId) {
   public final void setUseChronometer(boolean useChronometer) {
     if (this.useChronometer != useChronometer) {
       this.useChronometer = useChronometer;
-      maybeUpdateNotification();
+      invalidate();
     }
   }
 
@@ -696,7 +732,14 @@ public final void setVisibility(@Visibility int visibility) {
       default:
         throw new IllegalStateException();
     }
-    maybeUpdateNotification();
+    invalidate();
+  }
+
+  /** Forces an update of the notification if already started. */
+  public void invalidate() {
+    if (isNotificationStarted && player != null) {
+      updateNotification(null);
+    }
   }
 
   @RequiresNonNull("player")
@@ -719,12 +762,6 @@ private void startOrUpdateNotification() {
     }
   }
 
-  private void maybeUpdateNotification() {
-    if (isNotificationStarted && player != null) {
-      updateNotification(null);
-    }
-  }
-
   private void stopNotification() {
     if (isNotificationStarted) {
       notificationManager.cancel(notificationId);
@@ -744,7 +781,6 @@ private void stopNotification() {
    * @return The {@link Notification} which has been built.
    */
   protected Notification createNotification(Player player, @Nullable Bitmap largeIcon) {
-    boolean isPlayingAd = player.isPlayingAd();
     NotificationCompat.Builder builder = new NotificationCompat.Builder(context, channelId);
     List<String> actionNames = getActions(player);
     for (int i = 0; i < actionNames.size(); i++) {
@@ -759,18 +795,18 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
     }
     // Create a media style notification.
     MediaStyle mediaStyle = new MediaStyle();
-    builder.setStyle(mediaStyle);
     if (mediaSessionToken != null) {
       mediaStyle.setMediaSession(mediaSessionToken);
     }
-    mediaStyle.setShowActionsInCompactView(getActionIndicesForCompactView(player));
+    mediaStyle.setShowActionsInCompactView(getActionIndicesForCompactView(actionNames, player));
     // Configure stop action (eg. when user dismisses the notification when !isOngoing).
-    boolean useStopAction = stopAction != null && !isPlayingAd;
+    boolean useStopAction = stopAction != null;
     mediaStyle.setShowCancelButton(useStopAction);
     if (useStopAction && stopPendingIntent != null) {
       builder.setDeleteIntent(stopPendingIntent);
       mediaStyle.setCancelButtonIntent(stopPendingIntent);
     }
+    builder.setStyle(mediaStyle);
     // Set notification properties from getters.
     builder
         .setBadgeIconType(badgeIconType)
@@ -782,6 +818,7 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
         .setPriority(priority)
         .setDefaults(defaults);
     if (useChronometer
+        && !player.isPlayingAd()
         && !player.isCurrentWindowDynamic()
         && player.getPlayWhenReady()
         && player.getPlaybackState() == Player.STATE_READY) {
@@ -826,37 +863,40 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
    * <p>This method can be safely overridden. However, the names must be of the playback actions
    * {@link #ACTION_PAUSE}, {@link #ACTION_PLAY}, {@link #ACTION_FAST_FORWARD}, {@link
    * #ACTION_REWIND}, {@link #ACTION_NEXT} or {@link #ACTION_PREVIOUS}, or a key contained in the
-   * map returned by {@link CustomActionReceiver#createCustomActions(Context)}. Otherwise the action
-   * name is ignored.
+   * map returned by {@link CustomActionReceiver#createCustomActions(Context, int)}. Otherwise the
+   * action name is ignored.
    */
   protected List<String> getActions(Player player) {
+    boolean isPlayingAd = player.isPlayingAd();
     List<String> stringActions = new ArrayList<>();
-    if (!player.isPlayingAd()) {
+    if (!isPlayingAd) {
       if (useNavigationActions) {
         stringActions.add(ACTION_PREVIOUS);
       }
       if (rewindMs > 0) {
         stringActions.add(ACTION_REWIND);
       }
-      if (usePlayPauseActions) {
-        if (player.getPlayWhenReady()) {
-          stringActions.add(ACTION_PAUSE);
-        } else {
-          stringActions.add(ACTION_PLAY);
-        }
+    }
+    if (usePlayPauseActions) {
+      if (player.getPlayWhenReady()) {
+        stringActions.add(ACTION_PAUSE);
+      } else {
+        stringActions.add(ACTION_PLAY);
       }
+    }
+    if (!isPlayingAd) {
       if (fastForwardMs > 0) {
         stringActions.add(ACTION_FAST_FORWARD);
       }
       if (useNavigationActions && player.getNextWindowIndex() != C.INDEX_UNSET) {
         stringActions.add(ACTION_NEXT);
       }
-      if (customActionReceiver != null) {
-        stringActions.addAll(customActionReceiver.getCustomActions(player));
-      }
-      if (ACTION_STOP.equals(stopAction)) {
-        stringActions.add(stopAction);
-      }
+    }
+    if (customActionReceiver != null) {
+      stringActions.addAll(customActionReceiver.getCustomActions(player));
+    }
+    if (ACTION_STOP.equals(stopAction)) {
+      stringActions.add(stopAction);
     }
     return stringActions;
   }
@@ -864,79 +904,77 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
   /**
    * Gets an array with the indices of the buttons to be shown in compact mode.
    *
-   * <p>This method can be overridden. The indices must refer to the list of actions returned by
-   * {@link #getActions(Player)}.
+   * <p>This method can be overridden. The indices must refer to the list of actions passed as the
+   * first parameter.
    *
+   * @param actionNames The names of the actions included in the notification.
    * @param player The player for which state to build a notification.
    */
-  protected int[] getActionIndicesForCompactView(Player player) {
-    if (!usePlayPauseActions) {
-      return new int[0];
-    }
-    int actionIndex = useNavigationActions ? 1 : 0;
-    actionIndex += fastForwardMs > 0 ? 1 : 0;
-    return new int[] {actionIndex};
+  protected int[] getActionIndicesForCompactView(List<String> actionNames, Player player) {
+    int pauseActionIndex = actionNames.indexOf(ACTION_PAUSE);
+    int playActionIndex = actionNames.indexOf(ACTION_PLAY);
+    return pauseActionIndex != -1
+        ? new int[] {pauseActionIndex}
+        : (playActionIndex != -1 ? new int[] {playActionIndex} : new int[0]);
   }
 
-  private static Map<String, NotificationCompat.Action> createPlaybackActions(Context context) {
+  private static Map<String, NotificationCompat.Action> createPlaybackActions(
+      Context context, int instanceId) {
     Map<String, NotificationCompat.Action> actions = new HashMap<>();
-    Intent playIntent = new Intent(ACTION_PLAY).setPackage(context.getPackageName());
     actions.put(
         ACTION_PLAY,
         new NotificationCompat.Action(
             R.drawable.exo_notification_play,
             context.getString(R.string.exo_controls_play_description),
-            PendingIntent.getBroadcast(context, 0, playIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
-    Intent pauseIntent = new Intent(ACTION_PAUSE).setPackage(context.getPackageName());
+            createBroadcastIntent(ACTION_PLAY, context, instanceId)));
     actions.put(
         ACTION_PAUSE,
         new NotificationCompat.Action(
             R.drawable.exo_notification_pause,
             context.getString(R.string.exo_controls_pause_description),
-            PendingIntent.getBroadcast(
-                context, 0, pauseIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
-    Intent stopIntent = new Intent(ACTION_STOP).setPackage(context.getPackageName());
+            createBroadcastIntent(ACTION_PAUSE, context, instanceId)));
     actions.put(
         ACTION_STOP,
         new NotificationCompat.Action(
             R.drawable.exo_notification_stop,
             context.getString(R.string.exo_controls_stop_description),
-            PendingIntent.getBroadcast(context, 0, stopIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
-    Intent rewindIntent = new Intent(ACTION_REWIND).setPackage(context.getPackageName());
+            createBroadcastIntent(ACTION_STOP, context, instanceId)));
     actions.put(
         ACTION_REWIND,
         new NotificationCompat.Action(
             R.drawable.exo_notification_rewind,
             context.getString(R.string.exo_controls_rewind_description),
-            PendingIntent.getBroadcast(
-                context, 0, rewindIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
-    Intent fastForwardIntent = new Intent(ACTION_FAST_FORWARD).setPackage(context.getPackageName());
+            createBroadcastIntent(ACTION_REWIND, context, instanceId)));
     actions.put(
         ACTION_FAST_FORWARD,
         new NotificationCompat.Action(
             R.drawable.exo_notification_fastforward,
             context.getString(R.string.exo_controls_fastforward_description),
-            PendingIntent.getBroadcast(
-                context, 0, fastForwardIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
-    Intent previousIntent = new Intent(ACTION_PREVIOUS).setPackage(context.getPackageName());
+            createBroadcastIntent(ACTION_FAST_FORWARD, context, instanceId)));
     actions.put(
         ACTION_PREVIOUS,
         new NotificationCompat.Action(
             R.drawable.exo_notification_previous,
             context.getString(R.string.exo_controls_previous_description),
-            PendingIntent.getBroadcast(
-                context, 0, previousIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
-    Intent nextIntent = new Intent(ACTION_NEXT).setPackage(context.getPackageName());
+            createBroadcastIntent(ACTION_PREVIOUS, context, instanceId)));
     actions.put(
         ACTION_NEXT,
         new NotificationCompat.Action(
             R.drawable.exo_notification_next,
             context.getString(R.string.exo_controls_next_description),
-            PendingIntent.getBroadcast(context, 0, nextIntent, PendingIntent.FLAG_CANCEL_CURRENT)));
+            createBroadcastIntent(ACTION_NEXT, context, instanceId)));
     return actions;
   }
 
-  private class PlayerListener extends Player.DefaultEventListener {
+  private static PendingIntent createBroadcastIntent(
+      String action, Context context, int instanceId) {
+    Intent intent = new Intent(action).setPackage(context.getPackageName());
+    intent.putExtra(EXTRA_INSTANCE_ID, instanceId);
+    return PendingIntent.getBroadcast(
+        context, instanceId, intent, PendingIntent.FLAG_CANCEL_CURRENT);
+  }
+
+  private class PlayerListener implements Player.EventListener {
 
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
@@ -949,7 +987,7 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
     }
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest, int reason) {
+    public void onTimelineChanged(Timeline timeline, @Nullable Object manifest, int reason) {
       if (player == null || player.getPlaybackState() == Player.STATE_IDLE) {
         return;
       }
@@ -990,7 +1028,9 @@ public NotificationBroadcastReceiver() {
     @Override
     public void onReceive(Context context, Intent intent) {
       Player player = PlayerNotificationManager.this.player;
-      if (player == null || !isNotificationStarted) {
+      if (player == null
+          || !isNotificationStarted
+          || intent.getIntExtra(EXTRA_INSTANCE_ID, instanceId) != instanceId) {
         return;
       }
       String action = intent.getAction();
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index a7aa48c0db..88eabfed07 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -17,6 +17,7 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.app.Activity;
 import android.content.Context;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
@@ -24,12 +25,17 @@
 import android.graphics.BitmapFactory;
 import android.graphics.Matrix;
 import android.graphics.RectF;
-import android.support.annotation.NonNull;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Looper;
+import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
+import android.support.v4.content.ContextCompat;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
+import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.TextureView;
 import android.view.View;
@@ -44,6 +50,7 @@
 import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.Player.VideoComponent;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -52,11 +59,16 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode;
+import com.google.android.exoplayer2.ui.spherical.SingleTapListener;
+import com.google.android.exoplayer2.ui.spherical.SphericalSurfaceView;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoListener;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.List;
 
 /**
@@ -79,7 +91,7 @@
  *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
  *       streams.
  *       <ul>
- *         <li>Corresponding method: {@link #setDefaultArtwork(Bitmap)}
+ *         <li>Corresponding method: {@link #setDefaultArtwork(Drawable)}
  *         <li>Default: {@code null}
  *       </ul>
  *   <li><b>{@code use_controller}</b> - Whether the playback controls can be shown.
@@ -106,10 +118,10 @@
  *         <li>Default: {@code true}
  *       </ul>
  *   <li><b>{@code show_buffering}</b> - Whether the buffering spinner is displayed when the player
- *       is buffering.
+ *       is buffering. Valid values are {@code never}, {@code when_playing} and {@code always}.
  *       <ul>
- *         <li>Corresponding method: {@link #setShowBuffering(boolean)}
- *         <li>Default: {@code false}
+ *         <li>Corresponding method: {@link #setShowBuffering(int)}
+ *         <li>Default: {@code never}
  *       </ul>
  *   <li><b>{@code resize_mode}</b> - Controls how video and album art is resized within the view.
  *       Valid values are {@code fit}, {@code fixed_width}, {@code fixed_height} and {@code fill}.
@@ -118,11 +130,11 @@
  *         <li>Default: {@code fit}
  *       </ul>
  *   <li><b>{@code surface_type}</b> - The type of surface view used for video playbacks. Valid
- *       values are {@code surface_view}, {@code texture_view} and {@code none}. Using {@code none}
- *       is recommended for audio only applications, since creating the surface can be expensive.
- *       Using {@code surface_view} is recommended for video applications. Note, TextureView can
- *       only be used in a hardware accelerated window. When rendered in software, TextureView will
- *       draw nothing.
+ *       values are {@code surface_view}, {@code texture_view}, {@code spherical_view} and {@code
+ *       none}. Using {@code none} is recommended for audio only applications, since creating the
+ *       surface can be expensive. Using {@code surface_view} is recommended for video applications.
+ *       Note, TextureView can only be used in a hardware accelerated window. When rendered in
+ *       software, TextureView will draw nothing.
  *       <ul>
  *         <li>Corresponding method: None
  *         <li>Default: {@code surface_view}
@@ -143,13 +155,13 @@
  *       for more details.
  *       <ul>
  *         <li>Corresponding method: None
- *         <li>Default: {@code R.id.exo_player_view}
+ *         <li>Default: {@code R.layout.exo_player_view}
  *       </ul>
  *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout resource to be
  *       inflated by the child {@link PlayerControlView}. See below for more details.
  *       <ul>
  *         <li>Corresponding method: None
- *         <li>Default: {@code R.id.exo_player_control_view}
+ *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
  *   <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
  *       PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
@@ -174,8 +186,9 @@
  *         <li>Type: {@link AspectRatioFrameLayout}
  *       </ul>
  *   <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
- *       view is typically an opaque view that covers the video surface view, thereby obscuring it
- *       when visible.
+ *       view is typically an opaque view that covers the video surface, thereby obscuring it when
+ *       visible. Obscuring the surface in this way also helps to prevent flicker at the start of
+ *       playback when {@code surface_type="surface_view"}.
  *       <ul>
  *         <li>Type: {@link View}
  *       </ul>
@@ -228,17 +241,43 @@
  */
 public class PlayerView extends FrameLayout {
 
+  // LINT.IfChange
+  /**
+   * Determines when the buffering view is shown. One of {@link #SHOW_BUFFERING_NEVER}, {@link
+   * #SHOW_BUFFERING_WHEN_PLAYING} or {@link #SHOW_BUFFERING_ALWAYS}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({SHOW_BUFFERING_NEVER, SHOW_BUFFERING_WHEN_PLAYING, SHOW_BUFFERING_ALWAYS})
+  public @interface ShowBuffering {}
+  /** The buffering view is never shown. */
+  public static final int SHOW_BUFFERING_NEVER = 0;
+  /**
+   * The buffering view is shown when the player is in the {@link Player#STATE_BUFFERING buffering}
+   * state and {@link Player#getPlayWhenReady() playWhenReady} is {@code true}.
+   */
+  public static final int SHOW_BUFFERING_WHEN_PLAYING = 1;
+  /**
+   * The buffering view is always shown when the player is in the {@link Player#STATE_BUFFERING
+   * buffering} state.
+   */
+  public static final int SHOW_BUFFERING_ALWAYS = 2;
+  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
+
+  // LINT.IfChange
   private static final int SURFACE_TYPE_NONE = 0;
   private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
   private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
+  private static final int SURFACE_TYPE_MONO360_VIEW = 3;
+  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
 
-  private final AspectRatioFrameLayout contentFrame;
+  @Nullable private final AspectRatioFrameLayout contentFrame;
   private final View shutterView;
-  private final View surfaceView;
+  @Nullable private final View surfaceView;
   private final ImageView artworkView;
   private final SubtitleView subtitleView;
-  private final @Nullable View bufferingView;
-  private final @Nullable TextView errorMessageView;
+  @Nullable private final View bufferingView;
+  @Nullable private final TextView errorMessageView;
   private final PlayerControlView controller;
   private final ComponentListener componentListener;
   private final FrameLayout overlayFrameLayout;
@@ -246,11 +285,11 @@
   private Player player;
   private boolean useController;
   private boolean useArtwork;
-  private Bitmap defaultArtwork;
-  private boolean showBuffering;
+  @Nullable private Drawable defaultArtwork;
+  private @ShowBuffering int showBuffering;
   private boolean keepContentOnPlayerReset;
-  private @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
-  private @Nullable CharSequence customErrorMessage;
+  @Nullable private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
+  @Nullable private CharSequence customErrorMessage;
   private int controllerShowTimeoutMs;
   private boolean controllerAutoShow;
   private boolean controllerHideDuringAds;
@@ -301,7 +340,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
     boolean controllerHideOnTouch = true;
     boolean controllerAutoShow = true;
     boolean controllerHideDuringAds = true;
-    boolean showBuffering = false;
+    int showBuffering = SHOW_BUFFERING_NEVER;
     if (attrs != null) {
       TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.PlayerView, 0, 0);
       try {
@@ -319,7 +358,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
         controllerHideOnTouch =
             a.getBoolean(R.styleable.PlayerView_hide_on_touch, controllerHideOnTouch);
         controllerAutoShow = a.getBoolean(R.styleable.PlayerView_auto_show, controllerAutoShow);
-        showBuffering = a.getBoolean(R.styleable.PlayerView_show_buffering, showBuffering);
+        showBuffering = a.getInteger(R.styleable.PlayerView_show_buffering, showBuffering);
         keepContentOnPlayerReset =
             a.getBoolean(
                 R.styleable.PlayerView_keep_content_on_player_reset, keepContentOnPlayerReset);
@@ -351,10 +390,21 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       ViewGroup.LayoutParams params =
           new ViewGroup.LayoutParams(
               ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
-      surfaceView =
-          surfaceType == SURFACE_TYPE_TEXTURE_VIEW
-              ? new TextureView(context)
-              : new SurfaceView(context);
+      switch (surfaceType) {
+        case SURFACE_TYPE_TEXTURE_VIEW:
+          surfaceView = new TextureView(context);
+          break;
+        case SURFACE_TYPE_MONO360_VIEW:
+          Assertions.checkState(Util.SDK_INT >= 15);
+          SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
+          sphericalSurfaceView.setSurfaceListener(componentListener);
+          sphericalSurfaceView.setSingleTapListener(componentListener);
+          surfaceView = sphericalSurfaceView;
+          break;
+        default:
+          surfaceView = new SurfaceView(context);
+          break;
+      }
       surfaceView.setLayoutParams(params);
       contentFrame.addView(surfaceView, 0);
     } else {
@@ -368,7 +418,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
     artworkView = findViewById(R.id.exo_artwork);
     this.useArtwork = useArtwork && artworkView != null;
     if (defaultArtworkId != 0) {
-      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
+      defaultArtwork = ContextCompat.getDrawable(getContext(), defaultArtworkId);
     }
 
     // Subtitle view.
@@ -424,9 +474,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
    * @param newPlayerView The new view to attach to the player.
    */
   public static void switchTargetView(
-      @NonNull Player player,
-      @Nullable PlayerView oldPlayerView,
-      @Nullable PlayerView newPlayerView) {
+      Player player, @Nullable PlayerView oldPlayerView, @Nullable PlayerView newPlayerView) {
     if (oldPlayerView == newPlayerView) {
       return;
     }
@@ -456,9 +504,14 @@ public Player getPlayer() {
    * calling {@code setPlayer(null)} to detach it from the old one. This ordering is significantly
    * more efficient and may allow for more seamless transitions.
    *
-   * @param player The {@link Player} to use.
+   * @param player The {@link Player} to use, or {@code null} to detach the current player. Only
+   *     players which are accessed on the main thread are supported ({@code
+   *     player.getApplicationLooper() == Looper.getMainLooper()}).
    */
-  public void setPlayer(Player player) {
+  public void setPlayer(@Nullable Player player) {
+    Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());
+    Assertions.checkArgument(
+        player == null || player.getApplicationLooper() == Looper.getMainLooper());
     if (this.player == player) {
       return;
     }
@@ -469,6 +522,8 @@ public void setPlayer(Player player) {
         oldVideoComponent.removeVideoListener(componentListener);
         if (surfaceView instanceof TextureView) {
           oldVideoComponent.clearVideoTextureView((TextureView) surfaceView);
+        } else if (surfaceView instanceof SphericalSurfaceView) {
+          ((SphericalSurfaceView) surfaceView).setVideoComponent(null);
         } else if (surfaceView instanceof SurfaceView) {
           oldVideoComponent.clearVideoSurfaceView((SurfaceView) surfaceView);
         }
@@ -493,6 +548,8 @@ public void setPlayer(Player player) {
       if (newVideoComponent != null) {
         if (surfaceView instanceof TextureView) {
           newVideoComponent.setVideoTextureView((TextureView) surfaceView);
+        } else if (surfaceView instanceof SphericalSurfaceView) {
+          ((SphericalSurfaceView) surfaceView).setVideoComponent(newVideoComponent);
         } else if (surfaceView instanceof SurfaceView) {
           newVideoComponent.setVideoSurfaceView((SurfaceView) surfaceView);
         }
@@ -519,16 +576,16 @@ public void setVisibility(int visibility) {
   }
 
   /**
-   * Sets the resize mode.
+   * Sets the {@link ResizeMode}.
    *
-   * @param resizeMode The resize mode.
+   * @param resizeMode The {@link ResizeMode}.
    */
   public void setResizeMode(@ResizeMode int resizeMode) {
     Assertions.checkState(contentFrame != null);
     contentFrame.setResizeMode(resizeMode);
   }
 
-  /** Returns the resize mode. */
+  /** Returns the {@link ResizeMode}. */
   public @ResizeMode int getResizeMode() {
     Assertions.checkState(contentFrame != null);
     return contentFrame.getResizeMode();
@@ -553,7 +610,7 @@ public void setUseArtwork(boolean useArtwork) {
   }
 
   /** Returns the default artwork to display. */
-  public Bitmap getDefaultArtwork() {
+  public @Nullable Drawable getDefaultArtwork() {
     return defaultArtwork;
   }
 
@@ -562,8 +619,21 @@ public Bitmap getDefaultArtwork() {
    * present in the media.
    *
    * @param defaultArtwork the default artwork to display.
+   * @deprecated use (@link {@link #setDefaultArtwork(Drawable)} instead.
+   */
+  @Deprecated
+  public void setDefaultArtwork(@Nullable Bitmap defaultArtwork) {
+    setDefaultArtwork(
+        defaultArtwork == null ? null : new BitmapDrawable(getResources(), defaultArtwork));
+  }
+
+  /**
+   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+   * present in the media.
+   *
+   * @param defaultArtwork the default artwork to display
    */
-  public void setDefaultArtwork(Bitmap defaultArtwork) {
+  public void setDefaultArtwork(@Nullable Drawable defaultArtwork) {
     if (this.defaultArtwork != defaultArtwork) {
       this.defaultArtwork = defaultArtwork;
       updateForCurrentTrackSelections(/* isNewPlayer= */ false);
@@ -636,9 +706,23 @@ public void setKeepContentOnPlayerReset(boolean keepContentOnPlayerReset) {
    * Sets whether a buffering spinner is displayed when the player is in the buffering state. The
    * buffering spinner is not displayed by default.
    *
-   * @param showBuffering Whether the buffering icon is displayer
+   * @deprecated Use {@link #setShowBuffering(int)}
+   * @param showBuffering Whether the buffering icon is displayed
    */
+  @Deprecated
   public void setShowBuffering(boolean showBuffering) {
+    setShowBuffering(showBuffering ? SHOW_BUFFERING_WHEN_PLAYING : SHOW_BUFFERING_NEVER);
+  }
+
+  /**
+   * Sets whether a buffering spinner is displayed when the player is in the buffering state. The
+   * buffering spinner is not displayed by default.
+   *
+   * @param showBuffering The mode that defines when the buffering spinner is displayed. One of
+   *     {@link #SHOW_BUFFERING_NEVER}, {@link #SHOW_BUFFERING_WHEN_PLAYING} and
+   *     {@link #SHOW_BUFFERING_ALWAYS}.
+   */
+  public void setShowBuffering(@ShowBuffering int showBuffering) {
     if (this.showBuffering != showBuffering) {
       this.showBuffering = showBuffering;
       updateBuffering();
@@ -681,8 +765,12 @@ public boolean dispatchKeyEvent(KeyEvent event) {
     }
     boolean isDpadWhenControlHidden =
         isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
-    maybeShowController(true);
-    return isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+    boolean handled =
+        isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+    if (handled) {
+      maybeShowController(true);
+    }
+    return handled;
   }
 
   /**
@@ -696,6 +784,11 @@ public boolean dispatchMediaKeyEvent(KeyEvent event) {
     return useController && controller.dispatchMediaKeyEvent(event);
   }
 
+  /** Returns whether the controller is currently visible. */
+  public boolean isControllerVisible() {
+    return controller != null && controller.isVisible();
+  }
+
   /**
    * Shows the playback controls. Does nothing if playback controls are disabled.
    *
@@ -904,10 +997,12 @@ public void setAspectRatioListener(AspectRatioFrameLayout.AspectRatioListener li
    *   <li>{@link SurfaceView} by default, or if the {@code surface_type} attribute is set to {@code
    *       surface_view}.
    *   <li>{@link TextureView} if {@code surface_type} is {@code texture_view}.
+   *   <li>{@link SphericalSurfaceView} if {@code surface_type} is {@code spherical_view}.
    *   <li>{@code null} if {@code surface_type} is {@code none}.
    * </ul>
    *
-   * @return The {@link SurfaceView}, {@link TextureView} or {@code null}.
+   * @return The {@link SurfaceView}, {@link TextureView}, {@link SphericalSurfaceView} or {@code
+   *     null}.
    */
   public View getVideoSurfaceView() {
     return surfaceView;
@@ -936,15 +1031,10 @@ public SubtitleView getSubtitleView() {
 
   @Override
   public boolean onTouchEvent(MotionEvent ev) {
-    if (!useController || player == null || ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+    if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
       return false;
     }
-    if (!controller.isVisible()) {
-      maybeShowController(true);
-    } else if (controllerHideOnTouch) {
-      controller.hide();
-    }
-    return true;
+    return toggleControllerVisibility();
   }
 
   @Override
@@ -956,6 +1046,64 @@ public boolean onTrackballEvent(MotionEvent ev) {
     return true;
   }
 
+  /**
+   * Should be called when the player is visible to the user and if {@code surface_type} is {@code
+   * spherical_view}. It is the counterpart to {@link #onPause()}.
+   *
+   * <p>This method should typically be called in {@link Activity#onStart()}, or {@link
+   * Activity#onResume()} for API versions &lt;= 23.
+   */
+  public void onResume() {
+    if (surfaceView instanceof SphericalSurfaceView) {
+      ((SphericalSurfaceView) surfaceView).onResume();
+    }
+  }
+
+  /**
+   * Should be called when the player is no longer visible to the user and if {@code surface_type}
+   * is {@code spherical_view}. It is the counterpart to {@link #onResume()}.
+   *
+   * <p>This method should typically be called in {@link Activity#onStop()}, or {@link
+   * Activity#onPause()} for API versions &lt;= 23.
+   */
+  public void onPause() {
+    if (surfaceView instanceof SphericalSurfaceView) {
+      ((SphericalSurfaceView) surfaceView).onPause();
+    }
+  }
+
+  /**
+   * Called when there's a change in the aspect ratio of the content being displayed. The default
+   * implementation sets the aspect ratio of the content frame to that of the content, unless the
+   * content view is a {@link SphericalSurfaceView} in which case the frame's aspect ratio is
+   * cleared.
+   *
+   * @param contentAspectRatio The aspect ratio of the content.
+   * @param contentFrame The content frame, or {@code null}.
+   * @param contentView The view that holds the content being displayed, or {@code null}.
+   */
+  protected void onContentAspectRatioChanged(
+      float contentAspectRatio,
+      @Nullable AspectRatioFrameLayout contentFrame,
+      @Nullable View contentView) {
+    if (contentFrame != null) {
+      contentFrame.setAspectRatio(
+          contentView instanceof SphericalSurfaceView ? 0 : contentAspectRatio);
+    }
+  }
+
+  private boolean toggleControllerVisibility() {
+    if (!useController || player == null) {
+      return false;
+    }
+    if (!controller.isVisible()) {
+      maybeShowController(true);
+    } else if (controllerHideOnTouch) {
+      controller.hide();
+    }
+    return true;
+  }
+
   /** Shows the playback controls, but only if forced or shown indefinitely. */
   private void maybeShowController(boolean isForced) {
     if (isPlayingAd() && controllerHideDuringAds) {
@@ -1032,7 +1180,7 @@ private void updateForCurrentTrackSelections(boolean isNewPlayer) {
           }
         }
       }
-      if (setArtworkFromBitmap(defaultArtwork)) {
+      if (setDrawableArtwork(defaultArtwork)) {
         return;
       }
     }
@@ -1046,21 +1194,20 @@ private boolean setArtworkFromMetadata(Metadata metadata) {
       if (metadataEntry instanceof ApicFrame) {
         byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
         Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        return setArtworkFromBitmap(bitmap);
+        return setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
       }
     }
     return false;
   }
 
-  private boolean setArtworkFromBitmap(Bitmap bitmap) {
-    if (bitmap != null) {
-      int bitmapWidth = bitmap.getWidth();
-      int bitmapHeight = bitmap.getHeight();
-      if (bitmapWidth > 0 && bitmapHeight > 0) {
-        if (contentFrame != null) {
-          contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
-        }
-        artworkView.setImageBitmap(bitmap);
+  private boolean setDrawableArtwork(@Nullable Drawable drawable) {
+    if (drawable != null) {
+      int drawableWidth = drawable.getIntrinsicWidth();
+      int drawableHeight = drawable.getIntrinsicHeight();
+      if (drawableWidth > 0 && drawableHeight > 0) {
+        float artworkAspectRatio = (float) drawableWidth / drawableHeight;
+        onContentAspectRatioChanged(artworkAspectRatio, contentFrame, artworkView);
+        artworkView.setImageDrawable(drawable);
         artworkView.setVisibility(VISIBLE);
         return true;
       }
@@ -1084,10 +1231,10 @@ private void closeShutter() {
   private void updateBuffering() {
     if (bufferingView != null) {
       boolean showBufferingSpinner =
-          showBuffering
-              && player != null
+          player != null
               && player.getPlaybackState() == Player.STATE_BUFFERING
-              && player.getPlayWhenReady();
+              && (showBuffering == SHOW_BUFFERING_ALWAYS
+                  || (showBuffering == SHOW_BUFFERING_WHEN_PLAYING && player.getPlayWhenReady()));
       bufferingView.setVisibility(showBufferingSpinner ? View.VISIBLE : View.GONE);
     }
   }
@@ -1170,8 +1317,13 @@ private boolean isDpadKey(int keyCode) {
         || keyCode == KeyEvent.KEYCODE_DPAD_CENTER;
   }
 
-  private final class ComponentListener extends Player.DefaultEventListener
-      implements TextOutput, VideoListener, OnLayoutChangeListener {
+  private final class ComponentListener
+      implements Player.EventListener,
+          TextOutput,
+          VideoListener,
+          OnLayoutChangeListener,
+          SphericalSurfaceView.SurfaceListener,
+          SingleTapListener {
 
     // TextOutput implementation
 
@@ -1187,9 +1339,6 @@ public void onCues(List<Cue> cues) {
     @Override
     public void onVideoSizeChanged(
         int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
-      if (contentFrame == null) {
-        return;
-      }
       float videoAspectRatio =
           (height == 0 || width == 0) ? 1 : (width * pixelWidthHeightRatio) / height;
 
@@ -1212,7 +1361,7 @@ public void onVideoSizeChanged(
         applyTextureViewRotation((TextureView) surfaceView, textureViewRotation);
       }
 
-      contentFrame.setAspectRatio(videoAspectRatio);
+      onContentAspectRatioChanged(videoAspectRatio, contentFrame, surfaceView);
     }
 
     @Override
@@ -1262,5 +1411,24 @@ public void onLayoutChange(
         int oldBottom) {
       applyTextureViewRotation((TextureView) view, textureViewRotation);
     }
+
+    // SphericalSurfaceView.SurfaceTextureListener implementation
+
+    @Override
+    public void surfaceChanged(@Nullable Surface surface) {
+      if (player != null) {
+        VideoComponent videoComponent = player.getVideoComponent();
+        if (videoComponent != null) {
+          videoComponent.setVideoSurface(surface);
+        }
+      }
+    }
+
+    // SingleTapListener implementation
+
+    @Override
+    public boolean onSingleTapUp(MotionEvent e) {
+      return toggleControllerVisibility();
+    }
   }
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index b8098b6fa7..55745a7cb5 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -20,6 +20,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.AttributeSet;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 
 /** @deprecated Use {@link PlayerView}. */
@@ -45,7 +46,10 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
    * @param player The player whose target view is being switched.
    * @param oldPlayerView The old view to detach from the player.
    * @param newPlayerView The new view to attach to the player.
+   * @deprecated Use {@link PlayerView#switchTargetView(Player, PlayerView, PlayerView)} instead.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static void switchTargetView(
       @NonNull SimpleExoPlayer player,
       @Nullable SimpleExoPlayerView oldPlayerView,
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index c5d264b310..4f22362de6 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -25,18 +25,19 @@
 import android.graphics.Paint.Join;
 import android.graphics.Paint.Style;
 import android.graphics.Rect;
-import android.graphics.RectF;
 import android.text.Layout.Alignment;
 import android.text.SpannableStringBuilder;
+import android.text.Spanned;
 import android.text.StaticLayout;
 import android.text.TextPaint;
 import android.text.TextUtils;
 import android.text.style.AbsoluteSizeSpan;
+import android.text.style.BackgroundColorSpan;
 import android.text.style.RelativeSizeSpan;
 import android.util.DisplayMetrics;
-import android.util.Log;
 import com.google.android.exoplayer2.text.CaptionStyleCompat;
 import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -51,13 +52,7 @@
    */
   private static final float INNER_PADDING_RATIO = 0.125f;
 
-  /**
-   * Temporary rectangle used for computing line bounds.
-   */
-  private final RectF lineBounds = new RectF();
-
   // Styled dimensions.
-  private final float cornerRadius;
   private final float outlineWidth;
   private final float shadowRadius;
   private final float shadowOffset;
@@ -89,7 +84,8 @@
   private int edgeColor;
   @CaptionStyleCompat.EdgeType
   private int edgeType;
-  private float textSizePx;
+  private float defaultTextSizePx;
+  private float cueTextSizePx;
   private float bottomPaddingFraction;
   private int parentLeft;
   private int parentTop;
@@ -114,7 +110,6 @@ public SubtitlePainter(Context context) {
     Resources resources = context.getResources();
     DisplayMetrics displayMetrics = resources.getDisplayMetrics();
     int twoDpInPx = Math.round((2f * displayMetrics.densityDpi) / DisplayMetrics.DENSITY_DEFAULT);
-    cornerRadius = twoDpInPx;
     outlineWidth = twoDpInPx;
     shadowRadius = twoDpInPx;
     shadowOffset = twoDpInPx;
@@ -130,8 +125,8 @@ public SubtitlePainter(Context context) {
 
   /**
    * Draws the provided {@link Cue} into a canvas with the specified styling.
-   * <p>
-   * A call to this method is able to use cached results of calculations made during the previous
+   *
+   * <p>A call to this method is able to use cached results of calculations made during the previous
    * call, and so an instance of this class is able to optimize repeated calls to this method in
    * which the same parameters are passed.
    *
@@ -140,7 +135,8 @@ public SubtitlePainter(Context context) {
    * @param applyEmbeddedFontSizes If {@code applyEmbeddedStyles} is true, defines whether font
    *     sizes embedded within the cue should be applied. Otherwise, it is ignored.
    * @param style The style to use when drawing the cue text.
-   * @param textSizePx The text size to use when drawing the cue text, in pixels.
+   * @param defaultTextSizePx The default text size to use when drawing the text, in pixels.
+   * @param cueTextSizePx The embedded text size of this cue, in pixels.
    * @param bottomPaddingFraction The bottom padding fraction to apply when {@link Cue#line} is
    *     {@link Cue#DIMEN_UNSET}, as a fraction of the viewport height
    * @param canvas The canvas into which to draw.
@@ -149,9 +145,19 @@ public SubtitlePainter(Context context) {
    * @param cueBoxRight The right position of the enclosing cue box.
    * @param cueBoxBottom The bottom position of the enclosing cue box.
    */
-  public void draw(Cue cue, boolean applyEmbeddedStyles, boolean applyEmbeddedFontSizes,
-      CaptionStyleCompat style, float textSizePx, float bottomPaddingFraction, Canvas canvas,
-      int cueBoxLeft, int cueBoxTop, int cueBoxRight, int cueBoxBottom) {
+  public void draw(
+      Cue cue,
+      boolean applyEmbeddedStyles,
+      boolean applyEmbeddedFontSizes,
+      CaptionStyleCompat style,
+      float defaultTextSizePx,
+      float cueTextSizePx,
+      float bottomPaddingFraction,
+      Canvas canvas,
+      int cueBoxLeft,
+      int cueBoxTop,
+      int cueBoxRight,
+      int cueBoxBottom) {
     boolean isTextCue = cue.bitmap == null;
     int windowColor = Color.BLACK;
     if (isTextCue) {
@@ -180,7 +186,8 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, boolean applyEmbeddedFont
         && this.edgeType == style.edgeType
         && this.edgeColor == style.edgeColor
         && Util.areEqual(this.textPaint.getTypeface(), style.typeface)
-        && this.textSizePx == textSizePx
+        && this.defaultTextSizePx == defaultTextSizePx
+        && this.cueTextSizePx == cueTextSizePx
         && this.bottomPaddingFraction == bottomPaddingFraction
         && this.parentLeft == cueBoxLeft
         && this.parentTop == cueBoxTop
@@ -209,7 +216,8 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, boolean applyEmbeddedFont
     this.edgeType = style.edgeType;
     this.edgeColor = style.edgeColor;
     this.textPaint.setTypeface(style.typeface);
-    this.textSizePx = textSizePx;
+    this.defaultTextSizePx = defaultTextSizePx;
+    this.cueTextSizePx = cueTextSizePx;
     this.bottomPaddingFraction = bottomPaddingFraction;
     this.parentLeft = cueBoxLeft;
     this.parentTop = cueBoxTop;
@@ -228,8 +236,8 @@ private void setupTextLayout() {
     int parentWidth = parentRight - parentLeft;
     int parentHeight = parentBottom - parentTop;
 
-    textPaint.setTextSize(textSizePx);
-    int textPaddingX = (int) (textSizePx * INNER_PADDING_RATIO + 0.5f);
+    textPaint.setTextSize(defaultTextSizePx);
+    int textPaddingX = (int) (defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);
 
     int availableWidth = parentWidth - textPaddingX * 2;
     if (cueSize != Cue.DIMEN_UNSET) {
@@ -240,14 +248,12 @@ private void setupTextLayout() {
       return;
     }
 
+    CharSequence cueText = this.cueText;
     // Remove embedded styling or font size if requested.
-    CharSequence cueText;
-    if (applyEmbeddedFontSizes && applyEmbeddedStyles) {
-      cueText = this.cueText;
-    } else if (!applyEmbeddedStyles) {
-      cueText = this.cueText.toString(); // Equivalent to erasing all spans.
-    } else {
-      SpannableStringBuilder newCueText = new SpannableStringBuilder(this.cueText);
+    if (!applyEmbeddedStyles) {
+      cueText = cueText.toString(); // Equivalent to erasing all spans.
+    } else if (!applyEmbeddedFontSizes) {
+      SpannableStringBuilder newCueText = new SpannableStringBuilder(cueText);
       int cueLength = newCueText.length();
       AbsoluteSizeSpan[] absSpans = newCueText.getSpans(0, cueLength, AbsoluteSizeSpan.class);
       RelativeSizeSpan[] relSpans = newCueText.getSpans(0, cueLength, RelativeSizeSpan.class);
@@ -258,6 +264,26 @@ private void setupTextLayout() {
         newCueText.removeSpan(relSpan);
       }
       cueText = newCueText;
+    } else {
+      // Apply embedded styles & font size.
+      if (cueTextSizePx > 0) {
+        // Use a SpannableStringBuilder encompassing the whole cue text to apply the default
+        // cueTextSizePx.
+        SpannableStringBuilder newCueText = new SpannableStringBuilder(cueText);
+        newCueText.setSpan(
+            new AbsoluteSizeSpan((int) cueTextSizePx),
+            /* start= */ 0,
+            /* end= */ newCueText.length(),
+            Spanned.SPAN_PRIORITY);
+        cueText = newCueText;
+      }
+    }
+
+    if (Color.alpha(backgroundColor) > 0) {
+      SpannableStringBuilder newCueText = new SpannableStringBuilder(cueText);
+      newCueText.setSpan(
+          new BackgroundColorSpan(backgroundColor), 0, newCueText.length(), Spanned.SPAN_PRIORITY);
+      cueText = newCueText;
     }
 
     Alignment textAlignment = cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;
@@ -284,7 +310,7 @@ private void setupTextLayout() {
       textLeft = Math.max(textLeft, parentLeft);
       textRight = Math.min(textLeft + textWidth, parentRight);
     } else {
-      textLeft = (parentWidth - textWidth) / 2;
+      textLeft = (parentWidth - textWidth) / 2 + parentLeft;
       textRight = textLeft + textWidth;
     }
 
@@ -367,30 +393,6 @@ private void drawTextLayout(Canvas canvas) {
           paint);
     }
 
-    if (Color.alpha(backgroundColor) > 0) {
-      paint.setColor(backgroundColor);
-      float previousBottom = layout.getLineTop(0);
-      int lineCount = layout.getLineCount();
-      for (int i = 0; i < lineCount; i++) {
-        float lineTextBoundLeft = layout.getLineLeft(i);
-        float lineTextBoundRight = layout.getLineRight(i);
-        lineBounds.left = lineTextBoundLeft - textPaddingX;
-        lineBounds.right = lineTextBoundRight + textPaddingX;
-        lineBounds.top = previousBottom;
-        lineBounds.bottom = layout.getLineBottom(i);
-        previousBottom = lineBounds.bottom;
-        float lineTextWidth = lineTextBoundRight - lineTextBoundLeft;
-        if (lineTextWidth > 0) {
-          // Do not draw a line's background color if it has no text.
-          // For some reason, calculating the width manually is more reliable than
-          // layout.getLineWidth().
-          // Sometimes, lineTextBoundRight == lineTextBoundLeft, and layout.getLineWidth() still
-          // returns non-zero value.
-          canvas.drawRoundRect(lineBounds, cornerRadius, cornerRadius, paint);
-        }
-      }
-    }
-
     if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {
       textPaint.setStrokeJoin(Join.ROUND);
       textPaint.setStrokeWidth(outlineWidth);
@@ -429,6 +431,7 @@ private void drawBitmapLayout(Canvas canvas) {
    * latter only checks the text of each sequence, and does not check for equality of styling that
    * may be embedded within the {@link CharSequence}s.
    */
+  @SuppressWarnings("UndefinedEquals")
   private static boolean areCharSequencesEqual(CharSequence first, CharSequence second) {
     // Some CharSequence implementations don't perform a cheap referential equality check in their
     // equals methods, so we perform one explicitly here.
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index bb9c38d886..50a923bced 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -206,8 +206,10 @@ public void setApplyEmbeddedFontSizes(boolean applyEmbeddedFontSizes) {
    * {@link CaptioningManager#getUserStyle()}, or to a default style before API level 19.
    */
   public void setUserDefaultStyle() {
-    setStyle(Util.SDK_INT >= 19 && !isInEditMode()
-        ? getUserCaptionStyleV19() : CaptionStyleCompat.DEFAULT);
+    setStyle(
+        Util.SDK_INT >= 19 && isCaptionManagerEnabled() && !isInEditMode()
+            ? getUserCaptionStyleV19()
+            : CaptionStyleCompat.DEFAULT);
   }
 
   /**
@@ -245,19 +247,17 @@ public void setBottomPaddingFraction(float bottomPaddingFraction) {
   @Override
   public void dispatchDraw(Canvas canvas) {
     int cueCount = (cues == null) ? 0 : cues.size();
-    int rawTop = getTop();
-    int rawBottom = getBottom();
+    int rawViewHeight = getHeight();
 
-    // Calculate the bounds after padding is taken into account.
-    int left = getLeft() + getPaddingLeft();
-    int top = rawTop + getPaddingTop();
-    int right = getRight() - getPaddingRight();
-    int bottom = rawBottom - getPaddingBottom();
+    // Calculate the cue box bounds relative to the canvas after padding is taken into account.
+    int left = getPaddingLeft();
+    int top = getPaddingTop();
+    int right = getWidth() - getPaddingRight();
+    int bottom = rawViewHeight - getPaddingBottom();
     if (bottom <= top || right <= left) {
       // No space to draw subtitles.
       return;
     }
-    int rawViewHeight = rawBottom - rawTop;
     int viewHeightMinusPadding = bottom - top;
 
     float defaultViewTextSizePx =
@@ -269,15 +269,15 @@ public void dispatchDraw(Canvas canvas) {
 
     for (int i = 0; i < cueCount; i++) {
       Cue cue = cues.get(i);
-      float textSizePx =
-          resolveTextSizeForCue(cue, rawViewHeight, viewHeightMinusPadding, defaultViewTextSizePx);
+      float cueTextSizePx = resolveCueTextSize(cue, rawViewHeight, viewHeightMinusPadding);
       SubtitlePainter painter = painters.get(i);
       painter.draw(
           cue,
           applyEmbeddedStyles,
           applyEmbeddedFontSizes,
           style,
-          textSizePx,
+          defaultViewTextSizePx,
+          cueTextSizePx,
           bottomPaddingFraction,
           canvas,
           left,
@@ -287,14 +287,13 @@ public void dispatchDraw(Canvas canvas) {
     }
   }
 
-  private float resolveTextSizeForCue(
-      Cue cue, int rawViewHeight, int viewHeightMinusPadding, float defaultViewTextSizePx) {
+  private float resolveCueTextSize(Cue cue, int rawViewHeight, int viewHeightMinusPadding) {
     if (cue.textSizeType == Cue.TYPE_UNSET || cue.textSize == Cue.DIMEN_UNSET) {
-      return defaultViewTextSizePx;
+      return 0;
     }
     float defaultCueTextSizePx =
         resolveTextSize(cue.textSizeType, cue.textSize, rawViewHeight, viewHeightMinusPadding);
-    return defaultCueTextSizePx > 0 ? defaultCueTextSizePx : defaultViewTextSizePx;
+    return Math.max(defaultCueTextSizePx, 0);
   }
 
   private float resolveTextSize(
@@ -315,6 +314,13 @@ private float resolveTextSize(
     }
   }
 
+  @TargetApi(19)
+  private boolean isCaptionManagerEnabled() {
+    CaptioningManager captioningManager =
+        (CaptioningManager) getContext().getSystemService(Context.CAPTIONING_SERVICE);
+    return captioningManager.isEnabled();
+  }
+
   @TargetApi(19)
   private float getUserCaptionFontScaleV19() {
     CaptioningManager captioningManager =
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java
index fe5d5cbbc5..3f09ac2427 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java
@@ -19,7 +19,6 @@
 import android.app.AlertDialog;
 import android.app.Dialog;
 import android.content.Context;
-import android.content.DialogInterface;
 import android.content.res.TypedArray;
 import android.support.annotation.AttrRes;
 import android.support.annotation.Nullable;
@@ -80,13 +79,7 @@
 
     final TrackSelectionView selectionView = dialogView.findViewById(R.id.exo_track_selection_view);
     selectionView.init(trackSelector, rendererIndex);
-    Dialog.OnClickListener okClickListener =
-        new Dialog.OnClickListener() {
-          @Override
-          public void onClick(DialogInterface dialog, int which) {
-            selectionView.applySelection();
-          }
-        };
+    Dialog.OnClickListener okClickListener = (dialog, which) -> selectionView.applySelection();
 
     AlertDialog dialog =
         builder
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlUtil.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlUtil.java
new file mode 100644
index 0000000000..8fd5d64e1c
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlUtil.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import static android.opengl.GLU.gluErrorString;
+
+import android.annotation.TargetApi;
+import android.opengl.GLES11Ext;
+import android.opengl.GLES20;
+import android.text.TextUtils;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.util.Log;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+/** GL utility methods. */
+/*package*/ final class GlUtil {
+  private static final String TAG = "Spherical.Utils";
+
+  /** Class only contains static methods. */
+  private GlUtil() {}
+
+  /**
+   * If there is an OpenGl error, logs the error and if {@link
+   * ExoPlayerLibraryInfo#GL_ASSERTIONS_ENABLED} is true throws a {@link RuntimeException}.
+   */
+  public static void checkGlError() {
+    int error = GLES20.glGetError();
+    int lastError;
+    if (error != GLES20.GL_NO_ERROR) {
+      do {
+        lastError = error;
+        Log.e(TAG, "glError " + gluErrorString(lastError));
+        error = GLES20.glGetError();
+      } while (error != GLES20.GL_NO_ERROR);
+
+      if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED) {
+        throw new RuntimeException("glError " + gluErrorString(lastError));
+      }
+    }
+  }
+
+  /**
+   * Builds a GL shader program from vertex & fragment shader code. The vertex and fragment shaders
+   * are passed as arrays of strings in order to make debugging compilation issues easier.
+   *
+   * @param vertexCode GLES20 vertex shader program.
+   * @param fragmentCode GLES20 fragment shader program.
+   * @return GLES20 program id.
+   */
+  public static int compileProgram(String[] vertexCode, String[] fragmentCode) {
+    checkGlError();
+    // prepare shaders and OpenGL program
+    int vertexShader = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);
+    GLES20.glShaderSource(vertexShader, TextUtils.join("\n", vertexCode));
+    GLES20.glCompileShader(vertexShader);
+    checkGlError();
+
+    int fragmentShader = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER);
+    GLES20.glShaderSource(fragmentShader, TextUtils.join("\n", fragmentCode));
+    GLES20.glCompileShader(fragmentShader);
+    checkGlError();
+
+    int program = GLES20.glCreateProgram();
+    GLES20.glAttachShader(program, vertexShader);
+    GLES20.glAttachShader(program, fragmentShader);
+
+    // Link and check for errors.
+    GLES20.glLinkProgram(program);
+    int[] linkStatus = new int[1];
+    GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
+    if (linkStatus[0] != GLES20.GL_TRUE) {
+      String errorMsg = "Unable to link shader program: \n" + GLES20.glGetProgramInfoLog(program);
+      Log.e(TAG, errorMsg);
+      if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED) {
+        throw new RuntimeException(errorMsg);
+      }
+    }
+    checkGlError();
+
+    return program;
+  }
+
+  /** Allocates a FloatBuffer with the given data. */
+  public static FloatBuffer createBuffer(float[] data) {
+    ByteBuffer bb = ByteBuffer.allocateDirect(data.length * C.BYTES_PER_FLOAT);
+    bb.order(ByteOrder.nativeOrder());
+    FloatBuffer buffer = bb.asFloatBuffer();
+    buffer.put(data);
+    buffer.position(0);
+
+    return buffer;
+  }
+
+  /**
+   * Creates a GL_TEXTURE_EXTERNAL_OES with default configuration of GL_LINEAR filtering and
+   * GL_CLAMP_TO_EDGE wrapping.
+   */
+  @TargetApi(15)
+  public static int createExternalTexture() {
+    int[] texId = new int[1];
+    GLES20.glGenTextures(1, IntBuffer.wrap(texId));
+    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texId[0]);
+    GLES20.glTexParameteri(
+        GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+    GLES20.glTexParameteri(
+        GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+    GLES20.glTexParameteri(
+        GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+    GLES20.glTexParameteri(
+        GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+    checkGlError();
+    return texId[0];
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java
new file mode 100644
index 0000000000..a52a25d085
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import static com.google.android.exoplayer2.ui.spherical.GlUtil.checkGlError;
+
+import android.annotation.TargetApi;
+import android.opengl.GLES11Ext;
+import android.opengl.GLES20;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.video.spherical.Projection;
+import java.nio.FloatBuffer;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+/**
+ * Utility class to render spherical meshes for video or images. Call {@link #init()} on the GL
+ * thread when ready.
+ */
+@TargetApi(15)
+/*package*/ final class ProjectionRenderer {
+
+  /** Defines the constants identifying the current eye type. */
+  /*package*/ interface EyeType {
+    /** Single eye in monocular rendering. */
+    int MONOCULAR = 0;
+
+    /** The left eye in stereo rendering. */
+    int LEFT = 1;
+
+    /** The right eye in stereo rendering. */
+    int RIGHT = 2;
+  }
+
+  /**
+   * Returns whether {@code projection} is supported. At least it should have left mesh and there
+   * should be only one sub mesh per mesh.
+   */
+  public static boolean isSupported(Projection projection) {
+    Projection.Mesh leftMesh = projection.leftMesh;
+    Projection.Mesh rightMesh = projection.rightMesh;
+    return leftMesh.getSubMeshCount() == 1
+        && leftMesh.getSubMesh(0).textureId == Projection.SubMesh.VIDEO_TEXTURE_ID
+        && rightMesh.getSubMeshCount() == 1
+        && rightMesh.getSubMesh(0).textureId == Projection.SubMesh.VIDEO_TEXTURE_ID;
+  }
+
+  // Basic vertex & fragment shaders to render a mesh with 3D position & 2D texture data.
+  private static final String[] VERTEX_SHADER_CODE =
+      new String[] {
+        "uniform mat4 uMvpMatrix;",
+        "uniform mat3 uTexMatrix;",
+        "attribute vec4 aPosition;",
+        "attribute vec2 aTexCoords;",
+        "varying vec2 vTexCoords;",
+
+        // Standard transformation.
+        "void main() {",
+        "  gl_Position = uMvpMatrix * aPosition;",
+        "  vTexCoords = (uTexMatrix * vec3(aTexCoords, 1)).xy;",
+        "}"
+      };
+  private static final String[] FRAGMENT_SHADER_CODE =
+      new String[] {
+        // This is required since the texture data is GL_TEXTURE_EXTERNAL_OES.
+        "#extension GL_OES_EGL_image_external : require",
+        "precision mediump float;",
+
+        // Standard texture rendering shader.
+        "uniform samplerExternalOES uTexture;",
+        "varying vec2 vTexCoords;",
+        "void main() {",
+        "  gl_FragColor = texture2D(uTexture, vTexCoords);",
+        "}"
+      };
+
+  // Texture transform matrices.
+  private static final float[] TEX_MATRIX_WHOLE = {
+    1.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f
+  };
+  private static final float[] TEX_MATRIX_TOP = {
+    1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.0f, 0.0f, 0.5f, 1.0f
+  };
+  private static final float[] TEX_MATRIX_BOTTOM = {
+    1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.0f, 0.0f, 1.0f, 1.0f
+  };
+  private static final float[] TEX_MATRIX_LEFT = {
+    0.5f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f
+  };
+  private static final float[] TEX_MATRIX_RIGHT = {
+    0.5f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.5f, 1.0f, 1.0f
+  };
+
+  private int stereoMode;
+  private @Nullable MeshData leftMeshData;
+  private @Nullable MeshData rightMeshData;
+
+  // Program related GL items. These are only valid if program != 0.
+  private int program;
+  private int mvpMatrixHandle;
+  private int uTexMatrixHandle;
+  private int positionHandle;
+  private int texCoordsHandle;
+  private int textureHandle;
+
+  /**
+   * Sets a {@link Projection} to be used.
+   *
+   * @param projection Contains the projection data to be rendered.
+   * @see #isSupported(Projection)
+   */
+  public void setProjection(Projection projection) {
+    if (!isSupported(projection)) {
+      return;
+    }
+    stereoMode = projection.stereoMode;
+    leftMeshData = new MeshData(projection.leftMesh.getSubMesh(0));
+    rightMeshData =
+        projection.singleMesh ? leftMeshData : new MeshData(projection.rightMesh.getSubMesh(0));
+  }
+
+  /** Initializes of the GL components. */
+  /* package */ void init() {
+    program = GlUtil.compileProgram(VERTEX_SHADER_CODE, FRAGMENT_SHADER_CODE);
+    mvpMatrixHandle = GLES20.glGetUniformLocation(program, "uMvpMatrix");
+    uTexMatrixHandle = GLES20.glGetUniformLocation(program, "uTexMatrix");
+    positionHandle = GLES20.glGetAttribLocation(program, "aPosition");
+    texCoordsHandle = GLES20.glGetAttribLocation(program, "aTexCoords");
+    textureHandle = GLES20.glGetUniformLocation(program, "uTexture");
+  }
+
+  /**
+   * Renders the mesh. If the projection hasn't been set, does nothing. This must be called on the
+   * GL thread.
+   *
+   * @param textureId GL_TEXTURE_EXTERNAL_OES used for this mesh.
+   * @param mvpMatrix The Model View Projection matrix.
+   * @param eyeType An {@link EyeType} value.
+   */
+  /* package */ void draw(int textureId, float[] mvpMatrix, int eyeType) {
+    MeshData meshData = eyeType == EyeType.RIGHT ? rightMeshData : leftMeshData;
+    if (meshData == null) {
+      return;
+    }
+
+    // Configure shader.
+    GLES20.glUseProgram(program);
+    checkGlError();
+
+    GLES20.glEnableVertexAttribArray(positionHandle);
+    GLES20.glEnableVertexAttribArray(texCoordsHandle);
+    checkGlError();
+
+    float[] texMatrix;
+    if (stereoMode == C.STEREO_MODE_TOP_BOTTOM) {
+      texMatrix = eyeType == EyeType.RIGHT ? TEX_MATRIX_BOTTOM : TEX_MATRIX_TOP;
+    } else if (stereoMode == C.STEREO_MODE_LEFT_RIGHT) {
+      texMatrix = eyeType == EyeType.RIGHT ? TEX_MATRIX_RIGHT : TEX_MATRIX_LEFT;
+    } else {
+      texMatrix = TEX_MATRIX_WHOLE;
+    }
+    GLES20.glUniformMatrix3fv(uTexMatrixHandle, 1, false, texMatrix, 0);
+
+    GLES20.glUniformMatrix4fv(mvpMatrixHandle, 1, false, mvpMatrix, 0);
+    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId);
+    GLES20.glUniform1i(textureHandle, 0);
+    checkGlError();
+
+    // Load position data.
+    GLES20.glVertexAttribPointer(
+        positionHandle,
+        Projection.POSITION_COORDS_PER_VERTEX,
+        GLES20.GL_FLOAT,
+        false,
+        Projection.POSITION_COORDS_PER_VERTEX * C.BYTES_PER_FLOAT,
+        meshData.vertexBuffer);
+    checkGlError();
+
+    // Load texture data.
+    GLES20.glVertexAttribPointer(
+        texCoordsHandle,
+        Projection.TEXTURE_COORDS_PER_VERTEX,
+        GLES20.GL_FLOAT,
+        false,
+        Projection.TEXTURE_COORDS_PER_VERTEX * C.BYTES_PER_FLOAT,
+        meshData.textureBuffer);
+    checkGlError();
+
+    // Render.
+    GLES20.glDrawArrays(meshData.drawMode, 0, meshData.vertexCount);
+    checkGlError();
+
+    GLES20.glDisableVertexAttribArray(positionHandle);
+    GLES20.glDisableVertexAttribArray(texCoordsHandle);
+  }
+
+  /** Cleans up the GL resources. */
+  /* package */ void shutdown() {
+    if (program != 0) {
+      GLES20.glDeleteProgram(program);
+    }
+  }
+
+  private static class MeshData {
+    private final int vertexCount;
+    private final FloatBuffer vertexBuffer;
+    private final FloatBuffer textureBuffer;
+    @Projection.DrawMode private final int drawMode;
+
+    public MeshData(Projection.SubMesh subMesh) {
+      vertexCount = subMesh.getVertexCount();
+      vertexBuffer = GlUtil.createBuffer(subMesh.vertices);
+      textureBuffer = GlUtil.createBuffer(subMesh.textureCoords);
+      switch (subMesh.mode) {
+        case Projection.DRAW_MODE_TRIANGLES_STRIP:
+          drawMode = GLES20.GL_TRIANGLE_STRIP;
+          break;
+        case Projection.DRAW_MODE_TRIANGLES_FAN:
+          drawMode = GLES20.GL_TRIANGLE_FAN;
+          break;
+        case Projection.DRAW_MODE_TRIANGLES:
+        default:
+          drawMode = GLES20.GL_TRIANGLES;
+          break;
+      }
+    }
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
new file mode 100644
index 0000000000..a8d4abcf07
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import static com.google.android.exoplayer2.ui.spherical.GlUtil.checkGlError;
+
+import android.graphics.SurfaceTexture;
+import android.opengl.GLES20;
+import android.opengl.Matrix;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ui.spherical.ProjectionRenderer.EyeType;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.TimedValueQueue;
+import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
+import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
+import com.google.android.exoplayer2.video.spherical.FrameRotationQueue;
+import com.google.android.exoplayer2.video.spherical.Projection;
+import com.google.android.exoplayer2.video.spherical.ProjectionDecoder;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+/** Renders a GL Scene. */
+/*package*/ class SceneRenderer implements VideoFrameMetadataListener, CameraMotionListener {
+
+  private final AtomicBoolean frameAvailable;
+  private final AtomicBoolean resetRotationAtNextFrame;
+  private final ProjectionRenderer projectionRenderer;
+  private final FrameRotationQueue frameRotationQueue;
+  private final TimedValueQueue<Long> sampleTimestampQueue;
+  private final TimedValueQueue<Projection> projectionQueue;
+  private final float[] rotationMatrix;
+  private final float[] tempMatrix;
+
+  // Used by GL thread only
+  private int textureId;
+  private @MonotonicNonNull SurfaceTexture surfaceTexture;
+
+  // Used by other threads only
+  private volatile @C.StreamType int defaultStereoMode;
+  private @C.StreamType int lastStereoMode;
+  private @Nullable byte[] lastProjectionData;
+
+  // Methods called on any thread.
+
+  public SceneRenderer() {
+    frameAvailable = new AtomicBoolean();
+    resetRotationAtNextFrame = new AtomicBoolean(true);
+    projectionRenderer = new ProjectionRenderer();
+    frameRotationQueue = new FrameRotationQueue();
+    sampleTimestampQueue = new TimedValueQueue<>();
+    projectionQueue = new TimedValueQueue<>();
+    rotationMatrix = new float[16];
+    tempMatrix = new float[16];
+    defaultStereoMode = C.STEREO_MODE_MONO;
+    lastStereoMode = Format.NO_VALUE;
+  }
+
+  /**
+   * Sets the default stereo mode. If the played video doesn't contain a stereo mode the default one
+   * is used.
+   *
+   * @param stereoMode A {@link C.StereoMode} value.
+   */
+  public void setDefaultStereoMode(@C.StereoMode int stereoMode) {
+    defaultStereoMode = stereoMode;
+  }
+
+  // Methods called on GL thread.
+
+  /** Initializes the renderer. */
+  public SurfaceTexture init() {
+    // Set the background frame color. This is only visible if the display mesh isn't a full sphere.
+    GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
+    checkGlError();
+
+    projectionRenderer.init();
+    checkGlError();
+
+    textureId = GlUtil.createExternalTexture();
+    surfaceTexture = new SurfaceTexture(textureId);
+    surfaceTexture.setOnFrameAvailableListener(surfaceTexture -> frameAvailable.set(true));
+    return surfaceTexture;
+  }
+
+  /**
+   * Draws the scene with a given eye pose and type.
+   *
+   * @param viewProjectionMatrix 16 element GL matrix.
+   * @param eyeType An {@link EyeType} value
+   */
+  public void drawFrame(float[] viewProjectionMatrix, int eyeType) {
+    // glClear isn't strictly necessary when rendering fully spherical panoramas, but it can improve
+    // performance on tiled renderers by causing the GPU to discard previous data.
+    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
+    checkGlError();
+
+    if (frameAvailable.compareAndSet(true, false)) {
+      Assertions.checkNotNull(surfaceTexture).updateTexImage();
+      checkGlError();
+      if (resetRotationAtNextFrame.compareAndSet(true, false)) {
+        Matrix.setIdentityM(rotationMatrix, 0);
+      }
+      long lastFrameTimestampNs = surfaceTexture.getTimestamp();
+      Long sampleTimestampUs = sampleTimestampQueue.poll(lastFrameTimestampNs);
+      if (sampleTimestampUs != null) {
+        frameRotationQueue.pollRotationMatrix(rotationMatrix, sampleTimestampUs);
+      }
+      Projection projection = projectionQueue.pollFloor(lastFrameTimestampNs);
+      if (projection != null) {
+        projectionRenderer.setProjection(projection);
+      }
+    }
+    Matrix.multiplyMM(tempMatrix, 0, viewProjectionMatrix, 0, rotationMatrix, 0);
+    projectionRenderer.draw(textureId, tempMatrix, eyeType);
+  }
+
+  // Methods called on playback thread.
+
+  // VideoFrameMetadataListener implementation.
+
+  @Override
+  public void onVideoFrameAboutToBeRendered(
+      long presentationTimeUs, long releaseTimeNs, Format format) {
+    sampleTimestampQueue.add(releaseTimeNs, presentationTimeUs);
+    setProjection(format.projectionData, format.stereoMode, releaseTimeNs);
+  }
+
+  // CameraMotionListener implementation.
+
+  @Override
+  public void onCameraMotion(long timeUs, float[] rotation) {
+    frameRotationQueue.setRotation(timeUs, rotation);
+  }
+
+  @Override
+  public void onCameraMotionReset() {
+    sampleTimestampQueue.clear();
+    frameRotationQueue.reset();
+    resetRotationAtNextFrame.set(true);
+  }
+
+  /**
+   * Sets projection data and stereo mode of the media to be played.
+   *
+   * @param projectionData Contains the projection data to be rendered.
+   * @param stereoMode A {@link C.StereoMode} value.
+   * @param timeNs When then new projection should be used.
+   */
+  private void setProjection(
+      @Nullable byte[] projectionData, @C.StereoMode int stereoMode, long timeNs) {
+    byte[] oldProjectionData = lastProjectionData;
+    int oldStereoMode = lastStereoMode;
+    lastProjectionData = projectionData;
+    lastStereoMode = stereoMode == Format.NO_VALUE ? defaultStereoMode : stereoMode;
+    if (oldStereoMode == lastStereoMode && Arrays.equals(oldProjectionData, lastProjectionData)) {
+      return;
+    }
+
+    Projection projectionFromData = null;
+    if (lastProjectionData != null) {
+      projectionFromData = ProjectionDecoder.decode(lastProjectionData, lastStereoMode);
+    }
+    Projection projection =
+        projectionFromData != null && ProjectionRenderer.isSupported(projectionFromData)
+            ? projectionFromData
+            : Projection.createEquirectangular(lastStereoMode);
+    projectionQueue.add(timeNs, projection);
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SingleTapListener.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SingleTapListener.java
new file mode 100644
index 0000000000..7328bdfcab
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SingleTapListener.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import android.view.MotionEvent;
+
+/** Listens tap events on a {@link android.view.View}. */
+public interface SingleTapListener {
+  /**
+   * Notified when a tap occurs with the up {@link MotionEvent} that triggered it.
+   *
+   * @param e The up motion event that completed the first tap.
+   * @return Whether the event is consumed.
+   */
+  boolean onSingleTapUp(MotionEvent e);
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
new file mode 100644
index 0000000000..7b58f54ac2
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
@@ -0,0 +1,416 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.PointF;
+import android.graphics.SurfaceTexture;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+import android.opengl.Matrix;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.AnyThread;
+import android.support.annotation.BinderThread;
+import android.support.annotation.Nullable;
+import android.support.annotation.UiThread;
+import android.util.AttributeSet;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.ui.spherical.ProjectionRenderer.EyeType;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * Renders a GL scene in a non-VR Activity that is affected by phone orientation and touch input.
+ *
+ * <p>The two input components are the TYPE_GAME_ROTATION_VECTOR Sensor and a TouchListener. The GL
+ * renderer combines these two inputs to render a scene with the appropriate camera orientation.
+ *
+ * <p>The primary complexity in this class is related to the various rotations. It is important to
+ * apply the touch and sensor rotations in the correct order or the user's touch manipulations won't
+ * match what they expect.
+ */
+@TargetApi(15)
+public final class SphericalSurfaceView extends GLSurfaceView {
+
+  /**
+   * This listener can be used to be notified when the {@link Surface} associated with this view is
+   * changed.
+   */
+  public interface SurfaceListener {
+    /**
+     * Invoked when the surface is changed or there isn't one anymore. Any previous surface
+     * shouldn't be used after this call.
+     *
+     * @param surface The new surface or null if there isn't one anymore.
+     */
+    void surfaceChanged(@Nullable Surface surface);
+  }
+
+  // Arbitrary vertical field of view.
+  private static final int FIELD_OF_VIEW_DEGREES = 90;
+  private static final float Z_NEAR = .1f;
+  private static final float Z_FAR = 100;
+
+  // TODO Calculate this depending on surface size and field of view.
+  private static final float PX_PER_DEGREES = 25;
+
+  /*package*/ static final float UPRIGHT_ROLL = (float) Math.PI;
+
+  private final SensorManager sensorManager;
+  private final @Nullable Sensor orientationSensor;
+  private final PhoneOrientationListener phoneOrientationListener;
+  private final Renderer renderer;
+  private final Handler mainHandler;
+  private final TouchTracker touchTracker;
+  private final SceneRenderer scene;
+  private @Nullable SurfaceListener surfaceListener;
+  private @Nullable SurfaceTexture surfaceTexture;
+  private @Nullable Surface surface;
+  private @Nullable Player.VideoComponent videoComponent;
+
+  public SphericalSurfaceView(Context context) {
+    this(context, null);
+  }
+
+  public SphericalSurfaceView(Context context, @Nullable AttributeSet attributeSet) {
+    super(context, attributeSet);
+    mainHandler = new Handler(Looper.getMainLooper());
+
+    // Configure sensors and touch.
+    sensorManager =
+        (SensorManager) Assertions.checkNotNull(context.getSystemService(Context.SENSOR_SERVICE));
+    Sensor orientationSensor = null;
+    if (Util.SDK_INT >= 18) {
+      // TYPE_GAME_ROTATION_VECTOR is the easiest sensor since it handles all the complex math for
+      // fusion. It's used instead of TYPE_ROTATION_VECTOR since the latter uses the magnetometer on
+      // devices. When used indoors, the magnetometer can take some time to settle depending on the
+      // device and amount of metal in the environment.
+      orientationSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR);
+    }
+    if (orientationSensor == null) {
+      orientationSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);
+    }
+    this.orientationSensor = orientationSensor;
+
+    scene = new SceneRenderer();
+    renderer = new Renderer(scene);
+
+    touchTracker = new TouchTracker(context, renderer, PX_PER_DEGREES);
+    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Display display = Assertions.checkNotNull(windowManager).getDefaultDisplay();
+    phoneOrientationListener = new PhoneOrientationListener(display, touchTracker, renderer);
+
+    setEGLContextClientVersion(2);
+    setRenderer(renderer);
+    setOnTouchListener(touchTracker);
+  }
+
+  /**
+   * Sets the default stereo mode. If the played video doesn't contain a stereo mode the default one
+   * is used.
+   *
+   * @param stereoMode A {@link C.StereoMode} value.
+   */
+  public void setDefaultStereoMode(@C.StereoMode int stereoMode) {
+    scene.setDefaultStereoMode(stereoMode);
+  }
+
+  /** Sets the {@link Player.VideoComponent} to use. */
+  public void setVideoComponent(@Nullable Player.VideoComponent newVideoComponent) {
+    if (newVideoComponent == videoComponent) {
+      return;
+    }
+    if (videoComponent != null) {
+      if (surface != null) {
+        videoComponent.clearVideoSurface(surface);
+      }
+      videoComponent.clearVideoFrameMetadataListener(scene);
+      videoComponent.clearCameraMotionListener(scene);
+    }
+    videoComponent = newVideoComponent;
+    if (videoComponent != null) {
+      videoComponent.setVideoFrameMetadataListener(scene);
+      videoComponent.setCameraMotionListener(scene);
+      videoComponent.setVideoSurface(surface);
+    }
+  }
+
+  /**
+   * Sets the {@link SurfaceListener} used to listen to surface events.
+   *
+   * @param listener The listener for surface events.
+   */
+  public void setSurfaceListener(@Nullable SurfaceListener listener) {
+    surfaceListener = listener;
+  }
+
+  /** Sets the {@link SingleTapListener} used to listen to single tap events on this view. */
+  public void setSingleTapListener(@Nullable SingleTapListener listener) {
+    touchTracker.setSingleTapListener(listener);
+  }
+
+  @Override
+  public void onResume() {
+    super.onResume();
+    if (orientationSensor != null) {
+      sensorManager.registerListener(
+          phoneOrientationListener, orientationSensor, SensorManager.SENSOR_DELAY_FASTEST);
+    }
+  }
+
+  @Override
+  public void onPause() {
+    if (orientationSensor != null) {
+      sensorManager.unregisterListener(phoneOrientationListener);
+    }
+    super.onPause();
+  }
+
+  @Override
+  protected void onDetachedFromWindow() {
+    // This call stops GL thread.
+    super.onDetachedFromWindow();
+
+    // Post to make sure we occur in order with any onSurfaceTextureAvailable calls.
+    mainHandler.post(
+        () -> {
+          if (surface != null) {
+            if (surfaceListener != null) {
+              surfaceListener.surfaceChanged(null);
+            }
+            releaseSurface(surfaceTexture, surface);
+            surfaceTexture = null;
+            surface = null;
+          }
+        });
+  }
+
+  // Called on GL thread.
+  private void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture) {
+    mainHandler.post(
+        () -> {
+          SurfaceTexture oldSurfaceTexture = this.surfaceTexture;
+          Surface oldSurface = this.surface;
+          this.surfaceTexture = surfaceTexture;
+          this.surface = new Surface(surfaceTexture);
+          if (surfaceListener != null) {
+            surfaceListener.surfaceChanged(surface);
+          }
+          releaseSurface(oldSurfaceTexture, oldSurface);
+        });
+  }
+
+  private static void releaseSurface(
+      @Nullable SurfaceTexture oldSurfaceTexture, @Nullable Surface oldSurface) {
+    if (oldSurfaceTexture != null) {
+      oldSurfaceTexture.release();
+    }
+    if (oldSurface != null) {
+      oldSurface.release();
+    }
+  }
+
+  /** Detects sensor events and saves them as a matrix. */
+  private static class PhoneOrientationListener implements SensorEventListener {
+    private final float[] phoneInWorldSpaceMatrix = new float[16];
+    private final float[] remappedPhoneMatrix = new float[16];
+    private final float[] angles = new float[3];
+    private final Display display;
+    private final TouchTracker touchTracker;
+    private final Renderer renderer;
+
+    public PhoneOrientationListener(Display display, TouchTracker touchTracker, Renderer renderer) {
+      this.display = display;
+      this.touchTracker = touchTracker;
+      this.renderer = renderer;
+    }
+
+    @Override
+    @BinderThread
+    public void onSensorChanged(SensorEvent event) {
+      SensorManager.getRotationMatrixFromVector(remappedPhoneMatrix, event.values);
+
+      // If we're not in upright portrait mode, remap the axes of the coordinate system according to
+      // the display rotation.
+      int xAxis;
+      int yAxis;
+      switch (display.getRotation()) {
+        case Surface.ROTATION_270:
+          xAxis = SensorManager.AXIS_MINUS_Y;
+          yAxis = SensorManager.AXIS_X;
+          break;
+        case Surface.ROTATION_180:
+          xAxis = SensorManager.AXIS_MINUS_X;
+          yAxis = SensorManager.AXIS_MINUS_Y;
+          break;
+        case Surface.ROTATION_90:
+          xAxis = SensorManager.AXIS_Y;
+          yAxis = SensorManager.AXIS_MINUS_X;
+          break;
+        case Surface.ROTATION_0:
+        default:
+          xAxis = SensorManager.AXIS_X;
+          yAxis = SensorManager.AXIS_Y;
+          break;
+      }
+      SensorManager.remapCoordinateSystem(
+          remappedPhoneMatrix, xAxis, yAxis, phoneInWorldSpaceMatrix);
+
+      // Extract the phone's roll and pass it on to touchTracker & renderer. Remapping is required
+      // since we need the calculated roll of the phone to be independent of the phone's pitch &
+      // yaw. Any operation that decomposes rotation to Euler angles needs to be performed
+      // carefully.
+      SensorManager.remapCoordinateSystem(
+          phoneInWorldSpaceMatrix,
+          SensorManager.AXIS_X,
+          SensorManager.AXIS_MINUS_Z,
+          remappedPhoneMatrix);
+      SensorManager.getOrientation(remappedPhoneMatrix, angles);
+      float roll = angles[2];
+      touchTracker.setRoll(roll);
+
+      // Rotate from Android coordinates to OpenGL coordinates. Android's coordinate system
+      // assumes Y points North and Z points to the sky. OpenGL has Y pointing up and Z pointing
+      // toward the user.
+      Matrix.rotateM(phoneInWorldSpaceMatrix, 0, 90, 1, 0, 0);
+      renderer.setDeviceOrientation(phoneInWorldSpaceMatrix, roll);
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {}
+  }
+
+  /**
+   * Standard GL Renderer implementation. The notable code is the matrix multiplication in
+   * onDrawFrame and updatePitchMatrix.
+   */
+  // @VisibleForTesting
+  /*package*/ class Renderer implements GLSurfaceView.Renderer, TouchTracker.Listener {
+    private final SceneRenderer scene;
+    private final float[] projectionMatrix = new float[16];
+
+    // There is no model matrix for this scene so viewProjectionMatrix is used for the mvpMatrix.
+    private final float[] viewProjectionMatrix = new float[16];
+
+    // Device orientation is derived from sensor data. This is accessed in the sensor's thread and
+    // the GL thread.
+    private final float[] deviceOrientationMatrix = new float[16];
+
+    // Optional pitch and yaw rotations are applied to the sensor orientation. These are accessed on
+    // the UI, sensor and GL Threads.
+    private final float[] touchPitchMatrix = new float[16];
+    private final float[] touchYawMatrix = new float[16];
+    private float touchPitch;
+    private float deviceRoll;
+
+    // viewMatrix = touchPitch * deviceOrientation * touchYaw.
+    private final float[] viewMatrix = new float[16];
+    private final float[] tempMatrix = new float[16];
+
+    public Renderer(SceneRenderer scene) {
+      this.scene = scene;
+      Matrix.setIdentityM(deviceOrientationMatrix, 0);
+      Matrix.setIdentityM(touchPitchMatrix, 0);
+      Matrix.setIdentityM(touchYawMatrix, 0);
+      deviceRoll = UPRIGHT_ROLL;
+    }
+
+    @Override
+    public synchronized void onSurfaceCreated(GL10 gl, EGLConfig config) {
+      onSurfaceTextureAvailable(scene.init());
+    }
+
+    @Override
+    public void onSurfaceChanged(GL10 gl, int width, int height) {
+      GLES20.glViewport(0, 0, width, height);
+      float aspect = (float) width / height;
+      float fovY = calculateFieldOfViewInYDirection(aspect);
+      Matrix.perspectiveM(projectionMatrix, 0, fovY, aspect, Z_NEAR, Z_FAR);
+    }
+
+    @Override
+    public void onDrawFrame(GL10 gl) {
+      // Combine touch & sensor data.
+      // Orientation = pitch * sensor * yaw since that is closest to what most users expect the
+      // behavior to be.
+      synchronized (this) {
+        Matrix.multiplyMM(tempMatrix, 0, deviceOrientationMatrix, 0, touchYawMatrix, 0);
+        Matrix.multiplyMM(viewMatrix, 0, touchPitchMatrix, 0, tempMatrix, 0);
+      }
+
+      Matrix.multiplyMM(viewProjectionMatrix, 0, projectionMatrix, 0, viewMatrix, 0);
+      scene.drawFrame(viewProjectionMatrix, EyeType.MONOCULAR);
+    }
+
+    /** Adjusts the GL camera's rotation based on device rotation. Runs on the sensor thread. */
+    @BinderThread
+    public synchronized void setDeviceOrientation(float[] matrix, float deviceRoll) {
+      System.arraycopy(matrix, 0, deviceOrientationMatrix, 0, deviceOrientationMatrix.length);
+      this.deviceRoll = -deviceRoll;
+      updatePitchMatrix();
+    }
+
+    /**
+     * Updates the pitch matrix after a physical rotation or touch input. The pitch matrix rotation
+     * is applied on an axis that is dependent on device rotation so this must be called after
+     * either touch or sensor update.
+     */
+    @AnyThread
+    private void updatePitchMatrix() {
+      // The camera's pitch needs to be rotated along an axis that is parallel to the real world's
+      // horizon. This is the <1, 0, 0> axis after compensating for the device's roll.
+      Matrix.setRotateM(
+          touchPitchMatrix,
+          0,
+          -touchPitch,
+          (float) Math.cos(deviceRoll),
+          (float) Math.sin(deviceRoll),
+          0);
+    }
+
+    @Override
+    @UiThread
+    public synchronized void onScrollChange(PointF scrollOffsetDegrees) {
+      touchPitch = scrollOffsetDegrees.y;
+      updatePitchMatrix();
+      Matrix.setRotateM(touchYawMatrix, 0, -scrollOffsetDegrees.x, 0, 1, 0);
+    }
+
+    private float calculateFieldOfViewInYDirection(float aspect) {
+      boolean landscapeMode = aspect > 1;
+      if (landscapeMode) {
+        double halfFovX = FIELD_OF_VIEW_DEGREES / 2;
+        double tanY = Math.tan(Math.toRadians(halfFovX)) / aspect;
+        double halfFovY = Math.toDegrees(Math.atan(tanY));
+        return (float) (halfFovY * 2);
+      } else {
+        return FIELD_OF_VIEW_DEGREES;
+      }
+    }
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
new file mode 100644
index 0000000000..c0373c9ca1
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import android.content.Context;
+import android.graphics.PointF;
+import android.support.annotation.BinderThread;
+import android.support.annotation.Nullable;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.view.View;
+
+/**
+ * Basic touch input system.
+ *
+ * <p>Mixing touch input and gyro input results in a complicated UI so this should be used
+ * carefully. This touch system implements a basic (X, Y) -> (yaw, pitch) transform. This works for
+ * basic UI but fails in edge cases where the user tries to drag scene up or down. There is no good
+ * UX solution for this. The least bad solution is to disable pitch manipulation and only let the
+ * user adjust yaw. This example tries to limit the awkwardness by restricting pitch manipulation to
+ * +/- 45 degrees.
+ *
+ * <p>It is also important to get the order of operations correct. To match what users expect, touch
+ * interaction manipulates the scene by rotating the world by the yaw offset and tilting the camera
+ * by the pitch offset. If the order of operations is incorrect, the sensors & touch rotations will
+ * have strange interactions. The roll of the phone is also tracked so that the x & y are correctly
+ * mapped to yaw & pitch no matter how the user holds their phone.
+ *
+ * <p>This class doesn't handle any scrolling inertia but Android's
+ * com.google.vr.sdk.widgets.common.TouchTracker.FlingGestureListener can be used with this code for
+ * a nicer UI. An even more advanced UI would reproject the user's touch point into 3D and drag the
+ * Mesh as the user moves their finger. However, that requires quaternion interpolation.
+ */
+/* package */ class TouchTracker extends GestureDetector.SimpleOnGestureListener
+    implements View.OnTouchListener {
+
+  /* package */ interface Listener {
+    void onScrollChange(PointF scrollOffsetDegrees);
+  }
+
+  // Touch input won't change the pitch beyond +/- 45 degrees. This reduces awkward situations
+  // where the touch-based pitch and gyro-based pitch interact badly near the poles.
+  /*package*/ static final float MAX_PITCH_DEGREES = 45;
+
+  // With every touch event, update the accumulated degrees offset by the new pixel amount.
+  private final PointF previousTouchPointPx = new PointF();
+  private final PointF accumulatedTouchOffsetDegrees = new PointF();
+
+  private final Listener listener;
+  private final float pxPerDegrees;
+  private final GestureDetector gestureDetector;
+  // The conversion from touch to yaw & pitch requires compensating for device roll. This is set
+  // on the sensor thread and read on the UI thread.
+  private volatile float roll;
+  private @Nullable SingleTapListener singleTapListener;
+
+  @SuppressWarnings({
+    "nullness:assignment.type.incompatible",
+    "nullness:argument.type.incompatible"
+  })
+  public TouchTracker(Context context, Listener listener, float pxPerDegrees) {
+    this.listener = listener;
+    this.pxPerDegrees = pxPerDegrees;
+    gestureDetector = new GestureDetector(context, this);
+    roll = SphericalSurfaceView.UPRIGHT_ROLL;
+  }
+
+  public void setSingleTapListener(@Nullable SingleTapListener listener) {
+    singleTapListener = listener;
+  }
+
+  /**
+   * Converts ACTION_MOVE events to pitch & yaw events while compensating for device roll.
+   *
+   * @return true if we handled the event
+   */
+  @Override
+  public boolean onTouch(View v, MotionEvent event) {
+    return gestureDetector.onTouchEvent(event);
+  }
+
+  @Override
+  public boolean onDown(MotionEvent e) {
+    // Initialize drag gesture.
+    previousTouchPointPx.set(e.getX(), e.getY());
+    return true;
+  }
+
+  @Override
+  public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+    // Calculate the touch delta in screen space.
+    float touchX = (e2.getX() - previousTouchPointPx.x) / pxPerDegrees;
+    float touchY = (e2.getY() - previousTouchPointPx.y) / pxPerDegrees;
+    previousTouchPointPx.set(e2.getX(), e2.getY());
+
+    float r = roll; // Copy volatile state.
+    float cr = (float) Math.cos(r);
+    float sr = (float) Math.sin(r);
+    // To convert from screen space to the 3D space, we need to adjust the drag vector based
+    // on the roll of the phone. This is standard rotationMatrix(roll) * vector math but has
+    // an inverted y-axis due to the screen-space coordinates vs GL coordinates.
+    // Handle yaw.
+    accumulatedTouchOffsetDegrees.x -= cr * touchX - sr * touchY;
+    // Handle pitch and limit it to 45 degrees.
+    accumulatedTouchOffsetDegrees.y += sr * touchX + cr * touchY;
+    accumulatedTouchOffsetDegrees.y =
+        Math.max(-MAX_PITCH_DEGREES, Math.min(MAX_PITCH_DEGREES, accumulatedTouchOffsetDegrees.y));
+
+    listener.onScrollChange(accumulatedTouchOffsetDegrees);
+    return true;
+  }
+
+  @Override
+  public boolean onSingleTapUp(MotionEvent e) {
+    if (singleTapListener != null) {
+      return singleTapListener.onSingleTapUp(e);
+    }
+    return false;
+  }
+
+  @BinderThread
+  public void setRoll(float roll) {
+    // We compensate for roll by rotating in the opposite direction.
+    this.roll = -roll;
+  }
+}
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png
index 9b8131124d..1af1f68a02 100644
Binary files a/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png and b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png differ
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png
index 159bea7fd8..db03f46435 100644
Binary files a/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png and b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png differ
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index 159844c234..534655f2f4 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -14,12 +14,14 @@
      limitations under the License.
 -->
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
   android:layout_width="match_parent"
   android:layout_height="wrap_content"
   android:layout_gravity="bottom"
   android:layoutDirection="ltr"
   android:background="#CC000000"
-  android:orientation="vertical">
+  android:orientation="vertical"
+  tools:targetApi="28">
 
   <LinearLayout
     android:layout_width="match_parent"
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index e127f181e9..c13622f182 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -29,6 +29,7 @@
     <enum name="none" value="0"/>
     <enum name="surface_view" value="1"/>
     <enum name="texture_view" value="2"/>
+    <enum name="spherical_view" value="3"/>
   </attr>
   <attr name="show_timeout" format="integer"/>
   <attr name="rewind_increment" format="integer"/>
@@ -50,7 +51,11 @@
     <attr name="hide_on_touch" format="boolean"/>
     <attr name="hide_during_ads" format="boolean"/>
     <attr name="auto_show" format="boolean"/>
-    <attr name="show_buffering" format="boolean"/>
+    <attr name="show_buffering" format="enum">
+      <enum name="never" value="0"/>
+      <enum name="when_playing" value="1"/>
+      <enum name="always" value="2"/>
+    </attr>
     <attr name="keep_content_on_player_reset" format="boolean"/>
     <attr name="resize_mode"/>
     <attr name="surface_type"/>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index d5d524b5a5..fe16d3b2c7 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -18,13 +18,22 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
+        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
     }
 }
 
 dependencies {
+    androidTestImplementation 'androidx.test:rules:' + testRunnerVersion
+    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
+    androidTestImplementation 'com.android.support:support-annotations:' + supportLibraryVersion
     androidTestImplementation project(modulePrefix + 'library-core')
     androidTestImplementation project(modulePrefix + 'library-dash')
     androidTestImplementation project(modulePrefix + 'library-hls')
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
index d4fd0b61f1..4165a42568 100644
--- a/playbacktests/src/androidTest/AndroidManifest.xml
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -18,6 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.playbacktests">
 
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
@@ -34,6 +35,6 @@
 
   <instrumentation
       android:targetPackage="com.google.android.exoplayer2.playbacktests"
-      android:name="android.test.InstrumentationTestRunner"/>
+      android:name="androidx.test.runner.AndroidJUnitRunner"/>
 
 </manifest>
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
index a4cd35911b..1832e16a98 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
@@ -15,26 +15,27 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import android.test.ActivityInstrumentationTestCase2;
+import static androidx.test.InstrumentationRegistry.getInstrumentation;
+
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.testutil.ActionSchedule;
 import com.google.android.exoplayer2.testutil.HostActivity;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Test playback of encrypted DASH streams using different CENC scheme types.
- */
-public final class CommonEncryptionDrmTest extends ActivityInstrumentationTestCase2<HostActivity> {
+/** Test playback of encrypted DASH streams using different CENC scheme types. */
+@RunWith(AndroidJUnit4.class)
+public final class CommonEncryptionDrmTest {
 
   private static final String TAG = "CencDrmTest";
 
-  private static final String URL_cenc =
-      "https://storage.googleapis.com/exoplayer-test-media-1/gts/tears-cenc.mpd";
-  private static final String URL_cbc1 =
-      "https://storage.googleapis.com/exoplayer-test-media-1/gts/tears-aes-cbc1.mpd";
-  private static final String URL_cbcs =
-      "https://storage.googleapis.com/exoplayer-test-media-1/gts/tears-aes-cbcs.mpd";
   private static final String ID_AUDIO = "0";
   private static final String[] IDS_VIDEO = new String[] {"1", "2"};
 
@@ -44,37 +45,38 @@
       .seekAndWait(270000).delay(10000).seekAndWait(200000).delay(10000).seekAndWait(732000)
       .build();
 
-  private DashTestRunner testRunner;
+  @Rule public ActivityTestRule<HostActivity> testRule = new ActivityTestRule<>(HostActivity.class);
 
-  public CommonEncryptionDrmTest() {
-    super(HostActivity.class);
-  }
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  private DashTestRunner testRunner;
 
-    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation())
-        .setWidevineInfo(MimeTypes.VIDEO_H264, false)
-        .setActionSchedule(ACTION_SCHEDULE_WITH_SEEKS)
-        .setAudioVideoFormats(ID_AUDIO, IDS_VIDEO)
-        .setCanIncludeAdditionalVideoFormats(true);
+  @Before
+  public void setUp() {
+    testRunner =
+        new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation())
+            .setWidevineInfo(MimeTypes.VIDEO_H264, false)
+            .setActionSchedule(ACTION_SCHEDULE_WITH_SEEKS)
+            .setAudioVideoFormats(ID_AUDIO, IDS_VIDEO)
+            .setCanIncludeAdditionalVideoFormats(true);
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() {
     testRunner = null;
-    super.tearDown();
   }
 
+  @Test
   public void testCencSchemeTypeV18() {
     if (Util.SDK_INT < 18) {
       // Pass.
       return;
     }
-    testRunner.setStreamName("test_widevine_h264_scheme_cenc").setManifestUrl(URL_cenc).run();
+    testRunner
+        .setStreamName("test_widevine_h264_scheme_cenc")
+        .setManifestUrl(DashTestData.WIDEVINE_SCHEME_CENC)
+        .run();
   }
 
+  @Test
   public void testCbc1SchemeTypeV25() {
     if (Util.SDK_INT < 25) {
       // cbc1 support was added in API 24, but it is stable from API 25 onwards.
@@ -82,9 +84,13 @@ public void testCbc1SchemeTypeV25() {
       // Pass.
       return;
     }
-    testRunner.setStreamName("test_widevine_h264_scheme_cbc1").setManifestUrl(URL_cbc1).run();
+    testRunner
+        .setStreamName("test_widevine_h264_scheme_cbc1")
+        .setManifestUrl(DashTestData.WIDEVINE_SCHEME_CBC1)
+        .run();
   }
 
+  @Test
   public void testCbcsSchemeTypeV25() {
     if (Util.SDK_INT < 25) {
       // cbcs support was added in API 24, but it is stable from API 25 onwards.
@@ -92,11 +98,14 @@ public void testCbcsSchemeTypeV25() {
       // Pass.
       return;
     }
-    testRunner.setStreamName("test_widevine_h264_scheme_cbcs").setManifestUrl(URL_cbcs).run();
+    testRunner
+        .setStreamName("test_widevine_h264_scheme_cbcs")
+        .setManifestUrl(DashTestData.WIDEVINE_SCHEME_CBCS)
+        .run();
   }
 
+  @Test
   public void testCensSchemeTypeV25() {
     // TODO: Implement once content is available. Track [internal: b/31219813].
   }
-
 }
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
index 5267d54bef..0dd05e7fd3 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
@@ -15,16 +15,18 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
+import static androidx.test.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import android.net.Uri;
-import android.test.ActivityInstrumentationTestCase2;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.dash.DashUtil;
 import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.source.dash.offline.DashDownloader;
 import com.google.android.exoplayer2.testutil.HostActivity;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
@@ -37,36 +39,38 @@
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Tests downloaded DASH playbacks.
- */
-public final class DashDownloadTest extends ActivityInstrumentationTestCase2<HostActivity> {
+/** Tests downloaded DASH playbacks. */
+@RunWith(AndroidJUnit4.class)
+public final class DashDownloadTest {
 
   private static final String TAG = "DashDownloadTest";
 
   private static final Uri MANIFEST_URI = Uri.parse(DashTestData.H264_MANIFEST);
 
+  @Rule public ActivityTestRule<HostActivity> testRule = new ActivityTestRule<>(HostActivity.class);
+
   private DashTestRunner testRunner;
   private File tempFolder;
   private SimpleCache cache;
   private DefaultHttpDataSourceFactory httpDataSourceFactory;
   private CacheDataSourceFactory offlineDataSourceFactory;
 
-  public DashDownloadTest() {
-    super(HostActivity.class);
-  }
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation())
-        .setManifestUrl(DashTestData.H264_MANIFEST)
-        .setFullPlaybackNoSeeking(true)
-        .setCanIncludeAdditionalVideoFormats(false)
-        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
-            DashTestData.H264_CDD_FIXED);
-    tempFolder = Util.createTempDirectory(getActivity(), "ExoPlayerTest");
+  @Before
+  public void setUp() throws Exception {
+    testRunner =
+        new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation())
+            .setManifestUrl(DashTestData.H264_MANIFEST)
+            .setFullPlaybackNoSeeking(true)
+            .setCanIncludeAdditionalVideoFormats(false)
+            .setAudioVideoFormats(
+                DashTestData.AAC_AUDIO_REPRESENTATION_ID, DashTestData.H264_CDD_FIXED);
+    tempFolder = Util.createTempDirectory(testRule.getActivity(), "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
     httpDataSourceFactory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
     offlineDataSourceFactory =
@@ -74,16 +78,16 @@ protected void setUp() throws Exception {
             cache, DummyDataSource.FACTORY, CacheDataSource.FLAG_BLOCK_ON_CACHE);
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() {
     testRunner = null;
     Util.recursiveDelete(tempFolder);
     cache = null;
-    super.tearDown();
   }
 
   // Download tests
 
+  @Test
   public void testDownload() throws Exception {
     if (Util.SDK_INT < 16) {
       return; // Pass.
@@ -106,7 +110,7 @@ public void testDownload() throws Exception {
   private DashDownloader downloadContent() throws Exception {
     DashManifest dashManifest =
         DashUtil.loadManifest(httpDataSourceFactory.createDataSource(), MANIFEST_URI);
-    ArrayList<RepresentationKey> keys = new ArrayList<>();
+    ArrayList<StreamKey> keys = new ArrayList<>();
     for (int pIndex = 0; pIndex < dashManifest.getPeriodCount(); pIndex++) {
       List<AdaptationSet> adaptationSets = dashManifest.getPeriod(pIndex).adaptationSets;
       for (int aIndex = 0; aIndex < adaptationSets.size(); aIndex++) {
@@ -116,7 +120,7 @@ private DashDownloader downloadContent() throws Exception {
           String id = representations.get(rIndex).format.id;
           if (DashTestData.AAC_AUDIO_REPRESENTATION_ID.equals(id)
               || DashTestData.H264_CDD_FIXED.equals(id)) {
-            keys.add(new RepresentationKey(pIndex, aIndex, rIndex));
+            keys.add(new StreamKey(pIndex, aIndex, rIndex));
           }
         }
       }
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
index 48b572fe87..9a54ffd07c 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
+import static androidx.test.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertThat;
 
-import android.test.ActivityInstrumentationTestCase2;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
@@ -27,11 +29,15 @@
 import com.google.android.exoplayer2.testutil.HostActivity;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Tests DASH playbacks using {@link ExoPlayer}.
- */
-public final class DashStreamingTest extends ActivityInstrumentationTestCase2<HostActivity> {
+/** Tests DASH playbacks using {@link ExoPlayer}. */
+@RunWith(AndroidJUnit4.class)
+public final class DashStreamingTest {
 
   private static final String TAG = "DashStreamingTest";
 
@@ -78,27 +84,24 @@
       // Wait 10 seconds, then seek to near end.
       .delay(10000).seek(120000)
       .build();
-  
-  private DashTestRunner testRunner;
 
-  public DashStreamingTest() {
-    super(HostActivity.class);
-  }
+  @Rule public ActivityTestRule<HostActivity> testRule = new ActivityTestRule<>(HostActivity.class);
+
+  private DashTestRunner testRunner;
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation());
+  @Before
+  public void setUp() {
+    testRunner = new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation());
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() {
     testRunner = null;
-    super.tearDown();
   }
 
   // H264 CDD.
 
+  @Test
   public void testH264Fixed() {
     if (Util.SDK_INT < 16) {
       // Pass.
@@ -113,6 +116,7 @@ public void testH264Fixed() {
         .run();
   }
 
+  @Test
   public void testH264Adaptive() throws DecoderQueryException {
     if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
@@ -128,6 +132,7 @@ public void testH264Adaptive() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
     if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
@@ -145,6 +150,7 @@ public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testH264AdaptiveWithRendererDisabling() throws DecoderQueryException {
     if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
@@ -164,6 +170,7 @@ public void testH264AdaptiveWithRendererDisabling() throws DecoderQueryException
 
   // H265 CDD.
 
+  @Test
   public void testH265FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -178,6 +185,7 @@ public void testH265FixedV23() {
         .run();
   }
 
+  @Test
   public void testH265AdaptiveV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -193,6 +201,7 @@ public void testH265AdaptiveV24() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testH265AdaptiveWithSeekingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -209,6 +218,7 @@ public void testH265AdaptiveWithSeekingV24() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testH265AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -227,6 +237,7 @@ public void testH265AdaptiveWithRendererDisablingV24() throws DecoderQueryExcept
 
   // VP9 (CDD).
 
+  @Test
   public void testVp9Fixed360pV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -242,6 +253,7 @@ public void testVp9Fixed360pV23() {
         .run();
   }
 
+  @Test
   public void testVp9AdaptiveV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -257,6 +269,7 @@ public void testVp9AdaptiveV24() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testVp9AdaptiveWithSeekingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -273,6 +286,7 @@ public void testVp9AdaptiveWithSeekingV24() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testVp9AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -292,6 +306,7 @@ public void testVp9AdaptiveWithRendererDisablingV24() throws DecoderQueryExcepti
   // H264: Other frame-rates for output buffer count assertions.
 
   // 23.976 fps.
+  @Test
   public void test23FpsH264FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -308,6 +323,7 @@ public void test23FpsH264FixedV23() {
   }
 
   // 24 fps.
+  @Test
   public void test24FpsH264FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -324,6 +340,7 @@ public void test24FpsH264FixedV23() {
   }
 
   // 29.97 fps.
+  @Test
   public void test29FpsH264FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -342,6 +359,7 @@ public void test29FpsH264FixedV23() {
   // Widevine encrypted media tests.
   // H264 CDD.
 
+  @Test
   public void testWidevineH264FixedV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18) {
       // Pass.
@@ -358,6 +376,7 @@ public void testWidevineH264FixedV18() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testWidevineH264AdaptiveV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
@@ -374,6 +393,7 @@ public void testWidevineH264AdaptiveV18() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testWidevineH264AdaptiveWithSeekingV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
@@ -391,6 +411,7 @@ public void testWidevineH264AdaptiveWithSeekingV18() throws DecoderQueryExceptio
         .run();
   }
 
+  @Test
   public void testWidevineH264AdaptiveWithRendererDisablingV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
@@ -410,6 +431,7 @@ public void testWidevineH264AdaptiveWithRendererDisablingV18() throws DecoderQue
 
   // H265 CDD.
 
+  @Test
   public void testWidevineH265FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -426,6 +448,7 @@ public void testWidevineH265FixedV23() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testWidevineH265AdaptiveV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -442,6 +465,7 @@ public void testWidevineH265AdaptiveV24() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testWidevineH265AdaptiveWithSeekingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -459,6 +483,7 @@ public void testWidevineH265AdaptiveWithSeekingV24() throws DecoderQueryExceptio
         .run();
   }
 
+  @Test
   public void testWidevineH265AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -478,6 +503,7 @@ public void testWidevineH265AdaptiveWithRendererDisablingV24() throws DecoderQue
 
   // VP9 (CDD).
 
+  @Test
   public void testWidevineVp9Fixed360pV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -494,6 +520,7 @@ public void testWidevineVp9Fixed360pV23() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testWidevineVp9AdaptiveV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -510,6 +537,7 @@ public void testWidevineVp9AdaptiveV24() throws DecoderQueryException {
         .run();
   }
 
+  @Test
   public void testWidevineVp9AdaptiveWithSeekingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -527,6 +555,7 @@ public void testWidevineVp9AdaptiveWithSeekingV24() throws DecoderQueryException
         .run();
   }
 
+  @Test
   public void testWidevineVp9AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -547,6 +576,7 @@ public void testWidevineVp9AdaptiveWithRendererDisablingV24() throws DecoderQuer
   // H264: Other frame-rates for output buffer count assertions.
 
   // 23.976 fps.
+  @Test
   public void testWidevine23FpsH264FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -564,6 +594,7 @@ public void testWidevine23FpsH264FixedV23() throws DecoderQueryException {
   }
 
   // 24 fps.
+  @Test
   public void testWidevine24FpsH264FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -581,6 +612,7 @@ public void testWidevine24FpsH264FixedV23() throws DecoderQueryException {
   }
 
   // 29.97 fps.
+  @Test
   public void testWidevine29FpsH264FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
@@ -599,6 +631,7 @@ public void testWidevine29FpsH264FixedV23() throws DecoderQueryException {
 
   // Decoder info.
 
+  @Test
   public void testDecoderInfoH264() throws DecoderQueryException {
     if (Util.SDK_INT < 16) {
       // Pass.
@@ -609,6 +642,7 @@ public void testDecoderInfoH264() throws DecoderQueryException {
     assertThat(Util.SDK_INT < 21 || decoderInfo.adaptive).isTrue();
   }
 
+  @Test
   public void testDecoderInfoH265V24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
@@ -617,6 +651,7 @@ public void testDecoderInfoH265V24() throws DecoderQueryException {
     assertThat(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H265, false).adaptive).isTrue();
   }
 
+  @Test
   public void testDecoderInfoVP9V24() throws DecoderQueryException {
     if (Util.SDK_INT < 24) {
       // Pass.
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java
index 33e24aaa13..45cdf34b6c 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java
@@ -22,22 +22,35 @@
  */
 public final class DashTestData {
 
-  private static final String BASE_URL = "https://storage.googleapis.com/exoplayer-test-media-1/"
-      + "gen-4/screens/dash-vod-single-segment/";
+  private static final String BASE_URL =
+      "https://storage.googleapis.com/exoplayer-test-media-1/gen-4/";
+
+  private static final String BASE_URL_SCREENS = BASE_URL + "screens/dash-vod-single-segment/";
+  private static final String BASE_URL_COMMON_ENCRYPTION = BASE_URL + "common-encryption/";
   // Clear content manifests.
-  public static final String H264_MANIFEST = BASE_URL + "manifest-h264.mpd";
-  public static final String H265_MANIFEST = BASE_URL + "manifest-h265.mpd";
-  public static final String VP9_MANIFEST = BASE_URL + "manifest-vp9.mpd";
-  public static final String H264_23_MANIFEST = BASE_URL + "manifest-h264-23.mpd";
-  public static final String H264_24_MANIFEST = BASE_URL + "manifest-h264-24.mpd";
-  public static final String H264_29_MANIFEST = BASE_URL + "manifest-h264-29.mpd";
+  public static final String H264_MANIFEST = BASE_URL_SCREENS + "manifest-h264.mpd";
+  public static final String H265_MANIFEST = BASE_URL_SCREENS + "manifest-h265.mpd";
+  public static final String VP9_MANIFEST = BASE_URL_SCREENS + "manifest-vp9.mpd";
+  public static final String H264_23_MANIFEST = BASE_URL_SCREENS + "manifest-h264-23.mpd";
+  public static final String H264_24_MANIFEST = BASE_URL_SCREENS + "manifest-h264-24.mpd";
+  public static final String H264_29_MANIFEST = BASE_URL_SCREENS + "manifest-h264-29.mpd";
   // Widevine encrypted content manifests.
-  public static final String WIDEVINE_H264_MANIFEST = BASE_URL + "manifest-h264-enc.mpd";
-  public static final String WIDEVINE_H265_MANIFEST = BASE_URL + "manifest-h265-enc.mpd";
-  public static final String WIDEVINE_VP9_MANIFEST = BASE_URL + "manifest-vp9-enc.mpd";
-  public static final String WIDEVINE_H264_23_MANIFEST = BASE_URL + "manifest-h264-23-enc.mpd";
-  public static final String WIDEVINE_H264_24_MANIFEST = BASE_URL + "manifest-h264-24-enc.mpd";
-  public static final String WIDEVINE_H264_29_MANIFEST = BASE_URL + "manifest-h264-29-enc.mpd";
+  public static final String WIDEVINE_H264_MANIFEST = BASE_URL_SCREENS + "manifest-h264-enc.mpd";
+  public static final String WIDEVINE_H265_MANIFEST = BASE_URL_SCREENS + "manifest-h265-enc.mpd";
+  public static final String WIDEVINE_VP9_MANIFEST = BASE_URL_SCREENS + "manifest-vp9-enc.mpd";
+  public static final String WIDEVINE_H264_23_MANIFEST =
+      BASE_URL_SCREENS + "manifest-h264-23-enc.mpd";
+  public static final String WIDEVINE_H264_24_MANIFEST =
+      BASE_URL_SCREENS + "manifest-h264-24-enc.mpd";
+  public static final String WIDEVINE_H264_29_MANIFEST =
+      BASE_URL_SCREENS + "manifest-h264-29-enc.mpd";
+
+  // Widevine encrypted content manifests using different common encryption schemes.
+  public static final String WIDEVINE_SCHEME_CENC = BASE_URL_COMMON_ENCRYPTION + "tears-cenc.mpd";
+  public static final String WIDEVINE_SCHEME_CBC1 =
+      BASE_URL_COMMON_ENCRYPTION + "tears-aes-cbc1.mpd";
+  public static final String WIDEVINE_SCHEME_CBCS =
+      BASE_URL_COMMON_ENCRYPTION + "tears-aes-cbcs.mpd";
 
   public static final String AAC_AUDIO_REPRESENTATION_ID = "141";
   public static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
index e9d8acb031..1a43a70f25 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -22,9 +22,9 @@
 import android.media.MediaDrm;
 import android.media.UnsupportedSchemeException;
 import android.net.Uri;
-import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
@@ -42,7 +42,6 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
 import com.google.android.exoplayer2.testutil.ActionSchedule;
 import com.google.android.exoplayer2.testutil.DebugRenderersFactory;
 import com.google.android.exoplayer2.testutil.DecoderCountersUtil;
@@ -55,12 +54,12 @@
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.RandomTrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
-import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -265,8 +264,7 @@ private DashHostedTest(String tag, String streamName, String manifestUrl,
     }
 
     @Override
-    protected DefaultTrackSelector buildTrackSelector(
-        HostActivity host, BandwidthMeter bandwidthMeter) {
+    protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
       return trackSelector;
     }
 
@@ -296,30 +294,31 @@ protected DefaultTrackSelector buildTrackSelector(
     }
 
     @Override
-    protected SimpleExoPlayer buildExoPlayer(HostActivity host, Surface surface,
+    protected SimpleExoPlayer buildExoPlayer(
+        HostActivity host,
+        Surface surface,
         MappingTrackSelector trackSelector,
         DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
       SimpleExoPlayer player =
           ExoPlayerFactory.newSimpleInstance(
-              new DebugRenderersFactory(host), trackSelector, drmSessionManager);
+              host,
+              new DebugRenderersFactory(host),
+              trackSelector,
+              new DefaultLoadControl(),
+              drmSessionManager);
       player.setVideoSurface(surface);
       return player;
     }
 
     @Override
-    protected MediaSource buildSource(HostActivity host, String userAgent,
-        TransferListener<? super DataSource> mediaTransferListener) {
-      DataSource.Factory manifestDataSourceFactory = dataSourceFactory != null
-          ? dataSourceFactory : new DefaultDataSourceFactory(host, userAgent);
-      DataSource.Factory mediaDataSourceFactory = dataSourceFactory != null
-          ? dataSourceFactory
-          : new DefaultDataSourceFactory(host, userAgent, mediaTransferListener);
+    protected MediaSource buildSource(HostActivity host, String userAgent) {
+      DataSource.Factory dataSourceFactory =
+          this.dataSourceFactory != null
+              ? this.dataSourceFactory
+              : new DefaultDataSourceFactory(host, userAgent);
       Uri manifestUri = Uri.parse(manifestUrl);
-      DefaultDashChunkSource.Factory chunkSourceFactory = new DefaultDashChunkSource.Factory(
-          mediaDataSourceFactory);
-      return new DashMediaSource.Factory(chunkSourceFactory, manifestDataSourceFactory)
-          .setMinLoadableRetryCount(MIN_LOADABLE_RETRY_COUNT)
-          .setLivePresentationDelayMs(0)
+      return new DashMediaSource.Factory(dataSourceFactory)
+          .setLoadErrorHandlingPolicy(new DefaultLoadErrorHandlingPolicy(MIN_LOADABLE_RETRY_COUNT))
           .createMediaSource(manifestUri);
     }
 
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
index 95c9cfbf97..7beaafd143 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
@@ -15,13 +15,16 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
+import static androidx.test.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
+import static org.junit.Assert.fail;
 
 import android.media.MediaDrm.MediaDrmStateException;
 import android.net.Uri;
-import android.test.ActivityInstrumentationTestCase2;
 import android.util.Pair;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
@@ -36,11 +39,15 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-/**
- * Tests Widevine encrypted DASH playbacks using offline keys.
- */
-public final class DashWidevineOfflineTest extends ActivityInstrumentationTestCase2<HostActivity> {
+/** Tests Widevine encrypted DASH playbacks using offline keys. */
+@RunWith(AndroidJUnit4.class)
+public final class DashWidevineOfflineTest {
 
   private static final String TAG = "DashWidevineOfflineTest";
   private static final String USER_AGENT = "ExoPlayerPlaybackTests";
@@ -50,21 +57,20 @@
   private OfflineLicenseHelper<FrameworkMediaCrypto> offlineLicenseHelper;
   private byte[] offlineLicenseKeySetId;
 
-  public DashWidevineOfflineTest() {
-    super(HostActivity.class);
-  }
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation())
-        .setStreamName("test_widevine_h264_fixed_offline")
-        .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
-        .setWidevineInfo(MimeTypes.VIDEO_H264, true)
-        .setFullPlaybackNoSeeking(true)
-        .setCanIncludeAdditionalVideoFormats(false)
-        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
-            DashTestData.WIDEVINE_H264_CDD_FIXED);
+  @Rule public ActivityTestRule<HostActivity> testRule = new ActivityTestRule<>(HostActivity.class);
+
+  @Before
+  public void setUp() throws Exception {
+    testRunner =
+        new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation())
+            .setStreamName("test_widevine_h264_fixed_offline")
+            .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
+            .setWidevineInfo(MimeTypes.VIDEO_H264, true)
+            .setFullPlaybackNoSeeking(true)
+            .setCanIncludeAdditionalVideoFormats(false)
+            .setAudioVideoFormats(
+                DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+                DashTestData.WIDEVINE_H264_CDD_FIXED);
 
     boolean useL1Widevine = DashTestRunner.isL1WidevineAvailable(MimeTypes.VIDEO_H264);
     String widevineLicenseUrl = DashTestData.getWidevineLicenseUrl(true, useL1Widevine);
@@ -75,8 +81,8 @@ protected void setUp() throws Exception {
     }
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() throws Exception {
     testRunner = null;
     if (offlineLicenseKeySetId != null) {
       releaseLicense();
@@ -86,11 +92,11 @@ protected void tearDown() throws Exception {
     }
     offlineLicenseHelper = null;
     httpDataSourceFactory = null;
-    super.tearDown();
   }
 
   // Offline license tests
 
+  @Test
   public void testWidevineOfflineLicenseV22() throws Exception {
     if (Util.SDK_INT < 22) {
       return; // Pass.
@@ -103,6 +109,7 @@ public void testWidevineOfflineLicenseV22() throws Exception {
     assertThat(offlineLicenseKeySetId).isNotNull();
   }
 
+  @Test
   public void testWidevineOfflineReleasedLicenseV22() throws Throwable {
     if (Util.SDK_INT < 22) {
       return; // Pass.
@@ -129,6 +136,7 @@ public void testWidevineOfflineReleasedLicenseV22() throws Throwable {
     }
   }
 
+  @Test
   public void testWidevineOfflineExpiredLicenseV22() throws Exception {
     if (Util.SDK_INT < 22) {
       return; // Pass.
@@ -158,6 +166,7 @@ public void testWidevineOfflineExpiredLicenseV22() throws Exception {
     testRunner.run();
   }
 
+  @Test
   public void testWidevineOfflineLicenseExpiresOnPauseV22() throws Exception {
     if (Util.SDK_INT < 22) {
       return; // Pass.
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java
new file mode 100644
index 0000000000..b9c513fe72
--- /dev/null
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.playbacktests.gts;
+
+import static androidx.test.InstrumentationRegistry.getInstrumentation;
+
+import android.media.MediaCodecInfo.AudioCapabilities;
+import android.media.MediaCodecInfo.CodecCapabilities;
+import android.media.MediaCodecInfo.CodecProfileLevel;
+import android.media.MediaCodecInfo.VideoCapabilities;
+import androidx.test.runner.AndroidJUnit4;
+import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
+import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
+import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer2.testutil.MetricsLogger;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests enumeration of decoders using {@link MediaCodecUtil}. */
+@RunWith(AndroidJUnit4.class)
+public class EnumerateDecodersTest {
+
+  private static final String TAG = "EnumerateDecodersTest";
+
+  private static final String REPORT_NAME = "GtsExoPlayerTestCases";
+  private static final String REPORT_OBJECT_NAME = "enumeratedecoderstest";
+
+  private MetricsLogger metricsLogger;
+
+  @Before
+  public void setUp() {
+    metricsLogger =
+        MetricsLogger.Factory.createDefault(
+            getInstrumentation(), TAG, REPORT_NAME, REPORT_OBJECT_NAME);
+  }
+
+  @Test
+  public void testEnumerateDecoders() throws Exception {
+    enumerateDecoders(MimeTypes.VIDEO_H263);
+    enumerateDecoders(MimeTypes.VIDEO_H264);
+    enumerateDecoders(MimeTypes.VIDEO_H265);
+    enumerateDecoders(MimeTypes.VIDEO_VP8);
+    enumerateDecoders(MimeTypes.VIDEO_VP9);
+    enumerateDecoders(MimeTypes.VIDEO_MP4V);
+    enumerateDecoders(MimeTypes.VIDEO_MPEG);
+    enumerateDecoders(MimeTypes.VIDEO_MPEG2);
+    enumerateDecoders(MimeTypes.VIDEO_VC1);
+    enumerateDecoders(MimeTypes.AUDIO_AAC);
+    enumerateDecoders(MimeTypes.AUDIO_MPEG_L1);
+    enumerateDecoders(MimeTypes.AUDIO_MPEG_L2);
+    enumerateDecoders(MimeTypes.AUDIO_MPEG);
+    enumerateDecoders(MimeTypes.AUDIO_RAW);
+    enumerateDecoders(MimeTypes.AUDIO_ALAW);
+    enumerateDecoders(MimeTypes.AUDIO_MLAW);
+    enumerateDecoders(MimeTypes.AUDIO_AC3);
+    enumerateDecoders(MimeTypes.AUDIO_E_AC3);
+    enumerateDecoders(MimeTypes.AUDIO_E_AC3_JOC);
+    enumerateDecoders(MimeTypes.AUDIO_TRUEHD);
+    enumerateDecoders(MimeTypes.AUDIO_DTS);
+    enumerateDecoders(MimeTypes.AUDIO_DTS_HD);
+    enumerateDecoders(MimeTypes.AUDIO_DTS_EXPRESS);
+    enumerateDecoders(MimeTypes.AUDIO_VORBIS);
+    enumerateDecoders(MimeTypes.AUDIO_OPUS);
+    enumerateDecoders(MimeTypes.AUDIO_AMR_NB);
+    enumerateDecoders(MimeTypes.AUDIO_AMR_WB);
+    enumerateDecoders(MimeTypes.AUDIO_FLAC);
+    enumerateDecoders(MimeTypes.AUDIO_ALAC);
+    enumerateDecoders(MimeTypes.AUDIO_MSGSM);
+  }
+
+  private void enumerateDecoders(String mimeType) throws DecoderQueryException {
+    logDecoderInfos(mimeType, /* secure= */ false);
+    logDecoderInfos(mimeType, /* secure= */ true);
+  }
+
+  private void logDecoderInfos(String mimeType, boolean secure) throws DecoderQueryException {
+    List<MediaCodecInfo> mediaCodecInfos = MediaCodecUtil.getDecoderInfos(mimeType, secure);
+    for (MediaCodecInfo mediaCodecInfo : mediaCodecInfos) {
+      CodecCapabilities capabilities = Assertions.checkNotNull(mediaCodecInfo.capabilities);
+      metricsLogger.logMetric(
+          "capabilities_" + mediaCodecInfo.name, codecCapabilitiesToString(mimeType, capabilities));
+    }
+  }
+
+  private static String codecCapabilitiesToString(
+      String requestedMimeType, CodecCapabilities codecCapabilities) {
+    boolean isVideo = MimeTypes.isVideo(requestedMimeType);
+    boolean isAudio = MimeTypes.isAudio(requestedMimeType);
+    StringBuilder result = new StringBuilder();
+    result.append("[requestedMimeType=").append(requestedMimeType);
+    if (Util.SDK_INT >= 21) {
+      result.append(", mimeType=").append(codecCapabilities.getMimeType());
+    }
+    result.append(", profileLevels=");
+    appendProfileLevels(codecCapabilities.profileLevels, result);
+    if (Util.SDK_INT >= 23) {
+      result
+          .append(", maxSupportedInstances=")
+          .append(codecCapabilities.getMaxSupportedInstances());
+    }
+    if (Util.SDK_INT >= 21) {
+      if (isVideo) {
+        result.append(", videoCapabilities=");
+        appendVideoCapabilities(codecCapabilities.getVideoCapabilities(), result);
+        result.append(", colorFormats=").append(Arrays.toString(codecCapabilities.colorFormats));
+      } else if (isAudio) {
+        result.append(", audioCapabilities=");
+        appendAudioCapabilities(codecCapabilities.getAudioCapabilities(), result);
+      }
+    }
+    if (Util.SDK_INT >= 19
+        && isVideo
+        && codecCapabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback)) {
+      result.append(", FEATURE_AdaptivePlayback");
+    }
+    if (Util.SDK_INT >= 21
+        && isVideo
+        && codecCapabilities.isFeatureSupported(CodecCapabilities.FEATURE_SecurePlayback)) {
+      result.append(", FEATURE_SecurePlayback");
+    }
+    if (Util.SDK_INT >= 26
+        && isVideo
+        && codecCapabilities.isFeatureSupported(CodecCapabilities.FEATURE_PartialFrame)) {
+      result.append(", FEATURE_PartialFrame");
+    }
+    if (Util.SDK_INT >= 21
+        && (isVideo || isAudio)
+        && codecCapabilities.isFeatureSupported(CodecCapabilities.FEATURE_TunneledPlayback)) {
+      result.append(", FEATURE_TunneledPlayback");
+    }
+    result.append(']');
+    return result.toString();
+  }
+
+  private static void appendAudioCapabilities(
+      AudioCapabilities audioCapabilities, StringBuilder result) {
+    result
+        .append("[bitrateRange=")
+        .append(audioCapabilities.getBitrateRange())
+        .append(", maxInputChannelCount=")
+        .append(audioCapabilities.getMaxInputChannelCount())
+        .append(", supportedSampleRateRanges=")
+        .append(Arrays.toString(audioCapabilities.getSupportedSampleRateRanges()))
+        .append(']');
+  }
+
+  private static void appendVideoCapabilities(
+      VideoCapabilities videoCapabilities, StringBuilder result) {
+    result
+        .append("[bitrateRange=")
+        .append(videoCapabilities.getBitrateRange())
+        .append(", heightAlignment=")
+        .append(videoCapabilities.getHeightAlignment())
+        .append(", widthAlignment=")
+        .append(videoCapabilities.getWidthAlignment())
+        .append(", supportedWidths=")
+        .append(videoCapabilities.getSupportedWidths())
+        .append(", supportedHeights=")
+        .append(videoCapabilities.getSupportedHeights())
+        .append(", supportedFrameRates=")
+        .append(videoCapabilities.getSupportedFrameRates())
+        .append(']');
+  }
+
+  private static void appendProfileLevels(CodecProfileLevel[] profileLevels, StringBuilder result) {
+    result.append('[');
+    int count = profileLevels.length;
+    for (int i = 0; i < count; i++) {
+      CodecProfileLevel profileLevel = profileLevels[i];
+      if (i != 0) {
+        result.append(", ");
+      }
+      result
+          .append("[profile=")
+          .append(profileLevel.profile)
+          .append(", level=")
+          .append(profileLevel.level)
+          .append(']');
+    }
+    result.append(']');
+  }
+}
diff --git a/testutils/build.gradle b/testutils/build.gradle
index a7f05a2c5e..2ef377ba5d 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
@@ -36,5 +41,7 @@ dependencies {
     api 'com.google.truth:truth:' + truthVersion
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     implementation project(modulePrefix + 'library-core')
+    implementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
+    annotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index a6c3438a52..c988c0c172 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -17,7 +17,6 @@
 
 import android.os.Handler;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -34,7 +33,9 @@
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerTarget;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.Parameters;
+import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.HandlerWrapper;
+import com.google.android.exoplayer2.util.Log;
 
 /**
  * Base class for actions to perform during playback tests.
@@ -469,12 +470,8 @@ protected void doActionImpl(
         SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
       player
           .createMessage(
-              new Target() {
-                @Override
-                public void handleMessage(int messageType, Object payload)
-                    throws ExoPlaybackException {
-                  throw exception;
-                }
+              (messageType, payload) -> {
+                throw exception;
               })
           .send();
     }
@@ -507,14 +504,22 @@ protected void doActionAndScheduleNextImpl(
         final Surface surface,
         final HandlerWrapper handler,
         final ActionNode nextAction) {
-      // Schedule one message on the playback thread to pause the player immediately.
+      Handler testThreadHandler = new Handler();
+      // Schedule a message on the playback thread to ensure the player is paused immediately.
       player
           .createMessage(
-              new Target() {
-                @Override
-                public void handleMessage(int messageType, Object payload)
-                    throws ExoPlaybackException {
-                  player.setPlayWhenReady(/* playWhenReady= */ false);
+              (messageType, payload) -> {
+                // Block playback thread until pause command has been sent from test thread.
+                ConditionVariable blockPlaybackThreadCondition = new ConditionVariable();
+                testThreadHandler.post(
+                    () -> {
+                      player.setPlayWhenReady(/* playWhenReady= */ false);
+                      blockPlaybackThreadCondition.open();
+                    });
+                try {
+                  blockPlaybackThreadCondition.block();
+                } catch (InterruptedException e) {
+                  // Ignore.
                 }
               })
           .setPosition(windowIndex, positionMs)
@@ -522,15 +527,10 @@ public void handleMessage(int messageType, Object payload)
       // Schedule another message on this test thread to continue action schedule.
       player
           .createMessage(
-              new Target() {
-                @Override
-                public void handleMessage(int messageType, Object payload)
-                    throws ExoPlaybackException {
-                  nextAction.schedule(player, trackSelector, surface, handler);
-                }
-              })
+              (messageType, payload) ->
+                  nextAction.schedule(player, trackSelector, surface, handler))
           .setPosition(windowIndex, positionMs)
-          .setHandler(new Handler())
+          .setHandler(testThreadHandler)
           .send();
       player.setPlayWhenReady(true);
     }
@@ -572,10 +572,12 @@ protected void doActionAndScheduleNextImpl(
         return;
       }
       Player.EventListener listener =
-          new Player.DefaultEventListener() {
+          new Player.EventListener() {
             @Override
             public void onTimelineChanged(
-                Timeline timeline, Object manifest, @Player.TimelineChangeReason int reason) {
+                Timeline timeline,
+                @Nullable Object manifest,
+                @Player.TimelineChangeReason int reason) {
               if (expectedTimeline == null || timeline.equals(expectedTimeline)) {
                 player.removeListener(this);
                 nextAction.schedule(player, trackSelector, surface, handler);
@@ -618,13 +620,14 @@ protected void doActionAndScheduleNextImpl(
       if (nextAction == null) {
         return;
       }
-      player.addListener(new Player.DefaultEventListener() {
-        @Override
-        public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
-          player.removeListener(this);
-          nextAction.schedule(player, trackSelector, surface, handler);
-        }
-      });
+      player.addListener(
+          new Player.EventListener() {
+            @Override
+            public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+              player.removeListener(this);
+              nextAction.schedule(player, trackSelector, surface, handler);
+            }
+          });
     }
 
     @Override
@@ -663,15 +666,66 @@ protected void doActionAndScheduleNextImpl(
       if (targetPlaybackState == player.getPlaybackState()) {
         nextAction.schedule(player, trackSelector, surface, handler);
       } else {
-        player.addListener(new Player.DefaultEventListener() {
-          @Override
-          public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-            if (targetPlaybackState == playbackState) {
-              player.removeListener(this);
-              nextAction.schedule(player, trackSelector, surface, handler);
-            }
-          }
-        });
+        player.addListener(
+            new Player.EventListener() {
+              @Override
+              public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+                if (targetPlaybackState == playbackState) {
+                  player.removeListener(this);
+                  nextAction.schedule(player, trackSelector, surface, handler);
+                }
+              }
+            });
+      }
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
+      // Not triggered.
+    }
+  }
+
+  /**
+   * Waits for a specified loading state, returning either immediately or after a call to {@link
+   * Player.EventListener#onLoadingChanged(boolean)}.
+   */
+  public static final class WaitForIsLoading extends Action {
+
+    private final boolean targetIsLoading;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param targetIsLoading The loading state to wait for.
+     */
+    public WaitForIsLoading(String tag, boolean targetIsLoading) {
+      super(tag, "WaitForIsLoading");
+      this.targetIsLoading = targetIsLoading;
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final DefaultTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
+        final ActionNode nextAction) {
+      if (nextAction == null) {
+        return;
+      }
+      if (targetIsLoading == player.isLoading()) {
+        nextAction.schedule(player, trackSelector, surface, handler);
+      } else {
+        player.addListener(
+            new Player.EventListener() {
+              @Override
+              public void onLoadingChanged(boolean isLoading) {
+                if (targetIsLoading == isLoading) {
+                  player.removeListener(this);
+                  nextAction.schedule(player, trackSelector, surface, handler);
+                }
+              }
+            });
       }
     }
 
@@ -704,13 +758,14 @@ protected void doActionAndScheduleNextImpl(
       if (nextAction == null) {
         return;
       }
-      player.addListener(new Player.DefaultEventListener() {
-        @Override
-        public void onSeekProcessed() {
-          player.removeListener(this);
-          nextAction.schedule(player, trackSelector, surface, handler);
-        }
-      });
+      player.addListener(
+          new Player.EventListener() {
+            @Override
+            public void onSeekProcessed() {
+              player.removeListener(this);
+              nextAction.schedule(player, trackSelector, surface, handler);
+            }
+          });
     }
 
     @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index 74fa13ece1..71f5fdeae1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -41,6 +41,7 @@
 import com.google.android.exoplayer2.testutil.Action.SetVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.Stop;
 import com.google.android.exoplayer2.testutil.Action.ThrowPlaybackException;
+import com.google.android.exoplayer2.testutil.Action.WaitForIsLoading;
 import com.google.android.exoplayer2.testutil.Action.WaitForPlaybackState;
 import com.google.android.exoplayer2.testutil.Action.WaitForPositionDiscontinuity;
 import com.google.android.exoplayer2.testutil.Action.WaitForSeekProcessed;
@@ -375,6 +376,15 @@ public Builder sendMessage(
       return apply(new SendMessages(tag, target, windowIndex, positionMs, deleteAfterDelivery));
     }
 
+    /**
+     * Schedules a delay until any timeline change.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder waitForTimelineChanged() {
+      return apply(new WaitForTimelineChanged(tag, /* expectedTimeline= */ null));
+    }
+
     /**
      * Schedules a delay until the timeline changed to a specified expected timeline.
      *
@@ -382,7 +392,7 @@ public Builder sendMessage(
      *     change.
      * @return The builder, for convenience.
      */
-    public Builder waitForTimelineChanged(@Nullable Timeline expectedTimeline) {
+    public Builder waitForTimelineChanged(Timeline expectedTimeline) {
       return apply(new WaitForTimelineChanged(tag, expectedTimeline));
     }
 
@@ -405,6 +415,16 @@ public Builder waitForPlaybackState(int targetPlaybackState) {
       return apply(new WaitForPlaybackState(tag, targetPlaybackState));
     }
 
+    /**
+     * Schedules a delay until {@code player.isLoading()} changes to the specified value.
+     *
+     * @param targetIsLoading The target value of {@code player.isLoading()}.
+     * @return The builder, for convenience.
+     */
+    public Builder waitForIsLoading(boolean targetIsLoading) {
+      return apply(new WaitForIsLoading(tag, targetIsLoading));
+    }
+
     /**
      * Schedules a {@link Runnable} to be executed.
      *
@@ -447,7 +467,8 @@ private Builder appendActionNode(ActionNode actionNode) {
     private SimpleExoPlayer player;
 
     /** Handles the message send to the component and additionally provides access to the player. */
-    public abstract void handleMessage(SimpleExoPlayer player, int messageType, Object message);
+    public abstract void handleMessage(
+        SimpleExoPlayer player, int messageType, @Nullable Object message);
 
     /** Sets the player to be passed to {@link #handleMessage(SimpleExoPlayer, int, Object)}. */
     /* package */ void setPlayer(SimpleExoPlayer player) {
@@ -455,7 +476,8 @@ private Builder appendActionNode(ActionNode actionNode) {
     }
 
     @Override
-    public final void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    public final void handleMessage(int messageType, @Nullable Object message)
+        throws ExoPlaybackException {
       handleMessage(player, messageType, message);
     }
   }
@@ -610,13 +632,7 @@ protected void doActionAndScheduleNextImpl(
         ActionNode nextAction) {
       Assertions.checkArgument(nextAction == null);
       if (callback != null) {
-        handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                callback.onActionScheduleFinished();
-              }
-            });
+        handler.post(() -> callback.onActionScheduleFinished());
       }
     }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
index 4bbfef6bb8..627b5b72f3 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
@@ -81,15 +81,20 @@ public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCod
     }
 
     @Override
-    protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
-        MediaCrypto crypto) throws DecoderQueryException {
+    protected void configureCodec(
+        MediaCodecInfo codecInfo,
+        MediaCodec codec,
+        Format format,
+        MediaCrypto crypto,
+        float operatingRate)
+        throws DecoderQueryException {
       // If the codec is being initialized whilst the renderer is started, default behavior is to
       // render the first frame (i.e. the keyframe before the current position), then drop frames up
       // to the current playback position. For test runs that place a maximum limit on the number of
       // dropped frames allowed, this is not desired behavior. Hence we skip (rather than drop)
       // frames up to the current playback position [Internal: b/66494991].
       skipToPositionBeforeRenderingFirstFrame = getState() == Renderer.STATE_STARTED;
-      super.configureCodec(codecInfo, codec, format, crypto);
+      super.configureCodec(codecInfo, codec, format, crypto, operatingRate);
     }
 
     @Override
@@ -121,17 +126,33 @@ protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
     }
 
     @Override
-    protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
-        ByteBuffer buffer, int bufferIndex, int bufferFlags, long bufferPresentationTimeUs,
-        boolean shouldSkip) throws ExoPlaybackException {
+    protected boolean processOutputBuffer(
+        long positionUs,
+        long elapsedRealtimeUs,
+        MediaCodec codec,
+        ByteBuffer buffer,
+        int bufferIndex,
+        int bufferFlags,
+        long bufferPresentationTimeUs,
+        boolean shouldSkip,
+        Format format)
+        throws ExoPlaybackException {
       if (skipToPositionBeforeRenderingFirstFrame && bufferPresentationTimeUs < positionUs) {
         // After the codec has been initialized, don't render the first frame until we've caught up
         // to the playback position. Else test runs on devices that do not support dummy surface
         // will drop frames between rendering the first one and catching up [Internal: b/66494991].
         shouldSkip = true;
       }
-      return super.processOutputBuffer(positionUs, elapsedRealtimeUs, codec, buffer, bufferIndex,
-          bufferFlags, bufferPresentationTimeUs, shouldSkip);
+      return super.processOutputBuffer(
+          positionUs,
+          elapsedRealtimeUs,
+          codec,
+          buffer,
+          bufferIndex,
+          bufferFlags,
+          bufferPresentationTimeUs,
+          shouldSkip,
+          format);
     }
 
     @Override
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
similarity index 93%
rename from testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
rename to testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
index 8f65dc876a..858d287196 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
@@ -60,12 +60,9 @@ public void runOnMainThread(int timeoutMs, final Runnable runnable) {
     } else {
       final ConditionVariable finishedCondition = new ConditionVariable();
       handler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              runnable.run();
-              finishedCondition.open();
-            }
+          () -> {
+            runnable.run();
+            finishedCondition.open();
           });
       assertThat(finishedCondition.block(timeoutMs)).isTrue();
     }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
index 5c8e87d38f..ad59ca7152 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
@@ -20,17 +20,17 @@
 import android.os.ConditionVariable;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.util.Log;
 import android.view.Surface;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.audio.DefaultAudioSink;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -40,20 +40,14 @@
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.upstream.BandwidthMeter;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.EventLogger;
 import com.google.android.exoplayer2.util.HandlerWrapper;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
-import com.google.android.exoplayer2.video.VideoRendererEventListener;
 
-/**
- * A {@link HostedTest} for {@link ExoPlayer} playback tests.
- */
-public abstract class ExoHostedTest extends Player.DefaultEventListener implements HostedTest,
-    AudioRendererEventListener, VideoRendererEventListener {
+/** A {@link HostedTest} for {@link ExoPlayer} playback tests. */
+public abstract class ExoHostedTest implements AnalyticsListener, HostedTest {
 
   static {
     // DefaultAudioSink is able to work around spurious timestamps reported by the platform (by
@@ -80,9 +74,7 @@
   private SimpleExoPlayer player;
   private Surface surface;
   private ExoPlaybackException playerError;
-  private Player.EventListener playerEventListener;
-  private VideoRendererEventListener videoDebugListener;
-  private AudioRendererEventListener audioDebugListener;
+  private AnalyticsListener analyticsListener;
   private boolean playerWasPrepared;
 
   private boolean playing;
@@ -135,33 +127,11 @@ public final void setSchedule(ActionSchedule schedule) {
     }
   }
 
-  /**
-   * Sets an {@link Player.EventListener} to listen for ExoPlayer events during the test.
-   */
-  public final void setEventListener(Player.EventListener eventListener) {
-    this.playerEventListener = eventListener;
-    if (player != null) {
-      player.addListener(eventListener);
-    }
-  }
-
-  /**
-   * Sets an {@link VideoRendererEventListener} to listen for video debug events during the test.
-   */
-  public final void setVideoDebugListener(VideoRendererEventListener videoDebugListener) {
-    this.videoDebugListener = videoDebugListener;
-    if (player != null) {
-      player.addVideoDebugListener(videoDebugListener);
-    }
-  }
-
-  /**
-   * Sets an {@link AudioRendererEventListener} to listen for audio debug events during the test.
-   */
-  public final void setAudioDebugListener(AudioRendererEventListener audioDebugListener) {
-    this.audioDebugListener = audioDebugListener;
+  /** Sets an {@link AnalyticsListener} to listen for events during the test. */
+  public final void setAnalyticsListener(AnalyticsListener analyticsListener) {
+    this.analyticsListener = analyticsListener;
     if (player != null) {
-      player.addAudioDebugListener(audioDebugListener);
+      player.addAnalyticsListener(analyticsListener);
     }
   }
 
@@ -171,24 +141,16 @@ public final void setAudioDebugListener(AudioRendererEventListener audioDebugLis
   public final void onStart(HostActivity host, Surface surface) {
     this.surface = surface;
     // Build the player.
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
-    trackSelector = buildTrackSelector(host, bandwidthMeter);
+    trackSelector = buildTrackSelector(host);
     String userAgent = "ExoPlayerPlaybackTests";
     DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = buildDrmSessionManager(userAgent);
     player = buildExoPlayer(host, surface, trackSelector, drmSessionManager);
-    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent), bandwidthMeter));
-    if (playerEventListener != null) {
-      player.addListener(playerEventListener);
-    }
-    if (videoDebugListener != null) {
-      player.addVideoDebugListener(videoDebugListener);
+    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent)));
+    player.addAnalyticsListener(this);
+    player.addAnalyticsListener(new EventLogger(trackSelector, tag));
+    if (analyticsListener != null) {
+      player.addAnalyticsListener(analyticsListener);
     }
-    if (audioDebugListener != null) {
-      player.addAudioDebugListener(audioDebugListener);
-    }
-    player.addListener(this);
-    player.addAudioDebugListener(this);
-    player.addVideoDebugListener(this);
     player.setPlayWhenReady(true);
     actionHandler = Clock.DEFAULT.createHandler(Looper.myLooper(), /* callback= */ null);
     // Schedule any pending actions.
@@ -231,10 +193,11 @@ public final void onFinished() {
     assertPassed(audioDecoderCounters, videoDecoderCounters);
   }
 
-  // Player.EventListener
+  // AnalyticsListener
 
   @Override
-  public final void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+  public final void onPlayerStateChanged(
+      EventTime eventTime, boolean playWhenReady, int playbackState) {
     Log.d(tag, "state [" + playWhenReady + ", " + playbackState + "]");
     playerWasPrepared |= playbackState != Player.STATE_IDLE;
     if (playbackState == Player.STATE_ENDED
@@ -251,85 +214,20 @@ public final void onPlayerStateChanged(boolean playWhenReady, int playbackState)
   }
 
   @Override
-  public final void onPlayerError(ExoPlaybackException error) {
+  public final void onPlayerError(EventTime eventTime, ExoPlaybackException error) {
     playerWasPrepared = true;
     playerError = error;
     onPlayerErrorInternal(error);
   }
 
-  // AudioRendererEventListener
-
-  @Override
-  public void onAudioEnabled(DecoderCounters counters) {
-    Log.d(tag, "audioEnabled");
-  }
-
-  @Override
-  public void onAudioSessionId(int audioSessionId) {
-    Log.d(tag, "audioSessionId [" + audioSessionId + "]");
-  }
-
-  @Override
-  public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs,
-      long initializationDurationMs) {
-    Log.d(tag, "audioDecoderInitialized [" + decoderName + "]");
-  }
-
-  @Override
-  public void onAudioInputFormatChanged(Format format) {
-    Log.d(tag, "audioFormatChanged [" + Format.toLogString(format) + "]");
-  }
-
-  @Override
-  public void onAudioDisabled(DecoderCounters counters) {
-    Log.d(tag, "audioDisabled");
-    audioDecoderCounters.merge(counters);
-  }
-
-  @Override
-  public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
-    Log.e(tag, "audioTrackUnderrun [" + bufferSize + ", " + bufferSizeMs + ", "
-        + elapsedSinceLastFeedMs + "]", null);
-  }
-
-  // VideoRendererEventListener
-
-  @Override
-  public void onVideoEnabled(DecoderCounters counters) {
-    Log.d(tag, "videoEnabled");
-  }
-
-  @Override
-  public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs,
-      long initializationDurationMs) {
-    Log.d(tag, "videoDecoderInitialized [" + decoderName + "]");
-  }
-
-  @Override
-  public void onVideoInputFormatChanged(Format format) {
-    Log.d(tag, "videoFormatChanged [" + Format.toLogString(format) + "]");
-  }
-
-  @Override
-  public void onVideoDisabled(DecoderCounters counters) {
-    Log.d(tag, "videoDisabled");
-    videoDecoderCounters.merge(counters);
-  }
-
   @Override
-  public void onDroppedFrames(int count, long elapsed) {
-    Log.d(tag, "droppedFrames [" + count + "]");
-  }
-
-  @Override
-  public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-      float pixelWidthHeightRatio) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onRenderedFirstFrame(Surface surface) {
-    // Do nothing.
+  public void onDecoderDisabled(
+      EventTime eventTime, int trackType, DecoderCounters decoderCounters) {
+    if (trackType == C.TRACK_TYPE_AUDIO) {
+      audioDecoderCounters.merge(decoderCounters);
+    } else if (trackType == C.TRACK_TYPE_VIDEO) {
+      videoDecoderCounters.merge(decoderCounters);
+    }
   }
 
   // Internal logic
@@ -344,12 +242,7 @@ private boolean stopTest() {
     player = null;
     // We post opening of the finished condition so that any events posted to the main thread as a
     // result of player.release() are guaranteed to be handled before the test returns.
-    actionHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        testFinished.open();
-      }
-    });
+    actionHandler.post(testFinished::open);
     return true;
   }
 
@@ -359,25 +252,30 @@ public void run() {
   }
 
   @SuppressWarnings("unused")
-  protected DefaultTrackSelector buildTrackSelector(
-      HostActivity host, BandwidthMeter bandwidthMeter) {
-    return new DefaultTrackSelector(new AdaptiveTrackSelection.Factory(bandwidthMeter));
+  protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
+    return new DefaultTrackSelector(new AdaptiveTrackSelection.Factory());
   }
 
   @SuppressWarnings("unused")
-  protected SimpleExoPlayer buildExoPlayer(HostActivity host, Surface surface,
+  protected SimpleExoPlayer buildExoPlayer(
+      HostActivity host,
+      Surface surface,
       MappingTrackSelector trackSelector,
       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(host, drmSessionManager,
-        DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF, 0);
-    SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector);
+    RenderersFactory renderersFactory =
+        new DefaultRenderersFactory(
+            host,
+            DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF,
+            /* allowedVideoJoiningTimeMs= */ 0);
+    SimpleExoPlayer player =
+        ExoPlayerFactory.newSimpleInstance(
+            host, renderersFactory, trackSelector, new DefaultLoadControl(), drmSessionManager);
     player.setVideoSurface(surface);
     return player;
   }
 
   @SuppressWarnings("unused")
-  protected abstract MediaSource buildSource(HostActivity host, String userAgent,
-      TransferListener<? super DataSource> mediaTransferListener);
+  protected abstract MediaSource buildSource(HostActivity host, String userAgent);
 
   @SuppressWarnings("unused")
   protected void onPlayerErrorInternal(ExoPlaybackException error) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
index cf7470b80a..b613f7f364 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
@@ -17,7 +17,9 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.content.Context;
 import android.os.HandlerThread;
+import android.os.Looper;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -30,31 +32,24 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
-import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
-import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.HandlerWrapper;
 import com.google.android.exoplayer2.util.MimeTypes;
-import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-/**
- * Helper class to run an ExoPlayer test.
- */
-public final class ExoPlayerTestRunner extends Player.DefaultEventListener
-    implements ActionSchedule.Callback {
+/** Helper class to run an ExoPlayer test. */
+public final class ExoPlayerTestRunner implements Player.EventListener, ActionSchedule.Callback {
 
   /**
    * Builder to set-up a {@link ExoPlayerTestRunner}. Default fake implementations will be used for
@@ -81,13 +76,12 @@
     private MediaSource mediaSource;
     private DefaultTrackSelector trackSelector;
     private LoadControl loadControl;
+    private BandwidthMeter bandwidthMeter;
     private Format[] supportedFormats;
     private Renderer[] renderers;
     private RenderersFactory renderersFactory;
     private ActionSchedule actionSchedule;
     private Player.EventListener eventListener;
-    private VideoRendererEventListener videoRendererEventListener;
-    private AudioRendererEventListener audioRendererEventListener;
     private AnalyticsListener analyticsListener;
     private Integer expectedPlayerEndedCount;
 
@@ -162,6 +156,18 @@ public Builder setLoadControl(LoadControl loadControl) {
       return this;
     }
 
+    /**
+     * Sets the {@link BandwidthMeter} to be used by the test runner. The default value is a {@link
+     * DefaultBandwidthMeter} in its default configuration.
+     *
+     * @param bandwidthMeter The {@link BandwidthMeter} to be used by the test runner.
+     * @return This builder.
+     */
+    public Builder setBandwidthMeter(BandwidthMeter bandwidthMeter) {
+      this.bandwidthMeter = bandwidthMeter;
+      return this;
+    }
+
     /**
      * Sets a list of {@link Format}s to be used by a {@link FakeMediaSource} to create media
      * periods and for setting up a {@link FakeRenderer}. The default value is a single
@@ -242,28 +248,6 @@ public Builder setEventListener(Player.EventListener eventListener) {
       return this;
     }
 
-    /**
-     * Sets a {@link VideoRendererEventListener} to be registered.
-     *
-     * @param eventListener A {@link VideoRendererEventListener} to be registered.
-     * @return This builder.
-     */
-    public Builder setVideoRendererEventListener(VideoRendererEventListener eventListener) {
-      this.videoRendererEventListener = eventListener;
-      return this;
-    }
-
-    /**
-     * Sets an {@link AudioRendererEventListener} to be registered.
-     *
-     * @param eventListener An {@link AudioRendererEventListener} to be registered.
-     * @return This builder.
-     */
-    public Builder setAudioRendererEventListener(AudioRendererEventListener eventListener) {
-      this.audioRendererEventListener = eventListener;
-      return this;
-    }
-
     /**
      * Sets an {@link AnalyticsListener} to be registered.
      *
@@ -292,32 +276,30 @@ public Builder setExpectedPlayerEndedCount(int expectedPlayerEndedCount) {
     /**
      * Builds an {@link ExoPlayerTestRunner} using the provided values or their defaults.
      *
+     * @param context The context.
      * @return The built {@link ExoPlayerTestRunner}.
      */
-    public ExoPlayerTestRunner build() {
+    public ExoPlayerTestRunner build(Context context) {
       if (supportedFormats == null) {
         supportedFormats = new Format[] {VIDEO_FORMAT};
       }
       if (trackSelector == null) {
         trackSelector = new DefaultTrackSelector();
       }
+      if (bandwidthMeter == null) {
+        bandwidthMeter = new DefaultBandwidthMeter.Builder().build();
+      }
       if (renderersFactory == null) {
         if (renderers == null) {
           renderers = new Renderer[] {new FakeRenderer(supportedFormats)};
         }
         renderersFactory =
-            new RenderersFactory() {
-              @Override
-              public Renderer[] createRenderers(
-                  android.os.Handler eventHandler,
-                  VideoRendererEventListener videoRendererEventListener,
-                  AudioRendererEventListener audioRendererEventListener,
-                  TextOutput textRendererOutput,
-                  MetadataOutput metadataRendererOutput,
-                  DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-                return renderers;
-              }
-            };
+            (eventHandler,
+                videoRendererEventListener,
+                audioRendererEventListener,
+                textRendererOutput,
+                metadataRendererOutput,
+                drmSessionManager) -> renderers;
       }
       if (loadControl == null) {
         loadControl = new DefaultLoadControl();
@@ -335,29 +317,29 @@ public ExoPlayerTestRunner build() {
         expectedPlayerEndedCount = 1;
       }
       return new ExoPlayerTestRunner(
+          context,
           clock,
           mediaSource,
           renderersFactory,
           trackSelector,
           loadControl,
+          bandwidthMeter,
           actionSchedule,
           eventListener,
-          videoRendererEventListener,
-          audioRendererEventListener,
           analyticsListener,
           expectedPlayerEndedCount);
     }
   }
 
+  private final Context context;
   private final Clock clock;
   private final MediaSource mediaSource;
   private final RenderersFactory renderersFactory;
   private final DefaultTrackSelector trackSelector;
   private final LoadControl loadControl;
+  private final BandwidthMeter bandwidthMeter;
   private final @Nullable ActionSchedule actionSchedule;
   private final @Nullable Player.EventListener eventListener;
-  private final @Nullable VideoRendererEventListener videoRendererEventListener;
-  private final @Nullable AudioRendererEventListener audioRendererEventListener;
   private final @Nullable AnalyticsListener analyticsListener;
 
   private final HandlerThread playerThread;
@@ -376,26 +358,26 @@ public ExoPlayerTestRunner build() {
   private boolean playerWasPrepared;
 
   private ExoPlayerTestRunner(
+      Context context,
       Clock clock,
       MediaSource mediaSource,
       RenderersFactory renderersFactory,
       DefaultTrackSelector trackSelector,
       LoadControl loadControl,
+      BandwidthMeter bandwidthMeter,
       @Nullable ActionSchedule actionSchedule,
       @Nullable Player.EventListener eventListener,
-      @Nullable VideoRendererEventListener videoRendererEventListener,
-      @Nullable AudioRendererEventListener audioRendererEventListener,
       @Nullable AnalyticsListener analyticsListener,
       int expectedPlayerEndedCount) {
+    this.context = context;
     this.clock = clock;
     this.mediaSource = mediaSource;
     this.renderersFactory = renderersFactory;
     this.trackSelector = trackSelector;
     this.loadControl = loadControl;
+    this.bandwidthMeter = bandwidthMeter;
     this.actionSchedule = actionSchedule;
     this.eventListener = eventListener;
-    this.videoRendererEventListener = videoRendererEventListener;
-    this.audioRendererEventListener = audioRendererEventListener;
     this.analyticsListener = analyticsListener;
     this.timelines = new ArrayList<>();
     this.manifests = new ArrayList<>();
@@ -420,33 +402,25 @@ private ExoPlayerTestRunner(
    */
   public ExoPlayerTestRunner start() {
     handler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            try {
-              player = new TestSimpleExoPlayer(renderersFactory, trackSelector, loadControl, clock);
-              player.addListener(ExoPlayerTestRunner.this);
-              if (eventListener != null) {
-                player.addListener(eventListener);
-              }
-              if (videoRendererEventListener != null) {
-                player.addVideoDebugListener(videoRendererEventListener);
-              }
-              if (audioRendererEventListener != null) {
-                player.addAudioDebugListener(audioRendererEventListener);
-              }
-              if (analyticsListener != null) {
-                player.addAnalyticsListener(analyticsListener);
-              }
-              player.setPlayWhenReady(true);
-              if (actionSchedule != null) {
-                actionSchedule.start(
-                    player, trackSelector, null, handler, ExoPlayerTestRunner.this);
-              }
-              player.prepare(mediaSource);
-            } catch (Exception e) {
-              handleException(e);
+        () -> {
+          try {
+            player =
+                new TestSimpleExoPlayer(
+                    context, renderersFactory, trackSelector, loadControl, bandwidthMeter, clock);
+            player.addListener(ExoPlayerTestRunner.this);
+            if (eventListener != null) {
+              player.addListener(eventListener);
+            }
+            if (analyticsListener != null) {
+              player.addAnalyticsListener(analyticsListener);
             }
+            player.setPlayWhenReady(true);
+            if (actionSchedule != null) {
+              actionSchedule.start(player, trackSelector, null, handler, ExoPlayerTestRunner.this);
+            }
+            player.prepare(mediaSource);
+          } catch (Exception e) {
+            handleException(e);
           }
         });
     return this;
@@ -572,20 +546,18 @@ public void assertPlayedPeriodIndices(Integer... periodIndices) {
   // Private implementation details.
 
   private void release() throws InterruptedException {
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          if (player != null) {
-            player.release();
+    handler.post(
+        () -> {
+          try {
+            if (player != null) {
+              player.release();
+            }
+          } catch (Exception e) {
+            handleException(e);
+          } finally {
+            playerThread.quit();
           }
-        } catch (Exception e) {
-          handleException(e);
-        } finally {
-          playerThread.quit();
-        }
-      }
-    });
+        });
     playerThread.join();
   }
 
@@ -601,8 +573,8 @@ private void handleException(Exception exception) {
   // Player.EventListener
 
   @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest,
-      @Player.TimelineChangeReason int reason) {
+  public void onTimelineChanged(
+      Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
     timelines.add(timeline);
     manifests.add(manifest);
     timelineChangeReasons.add(reason);
@@ -653,17 +625,22 @@ public void onActionScheduleFinished() {
   private static final class TestSimpleExoPlayer extends SimpleExoPlayer {
 
     public TestSimpleExoPlayer(
+        Context context,
         RenderersFactory renderersFactory,
         TrackSelector trackSelector,
         LoadControl loadControl,
+        BandwidthMeter bandwidthMeter,
         Clock clock) {
       super(
+          context,
           renderersFactory,
           trackSelector,
           loadControl,
           /* drmSessionManager= */ null,
+          bandwidthMeter,
           new AnalyticsCollector.Factory(),
-          clock);
+          clock,
+          Looper.myLooper());
     }
   }
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java
index 82c14a5b32..0fef8db78e 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java
@@ -15,9 +15,14 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.BaseMediaChunkIterator;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData.Segment;
+import com.google.android.exoplayer2.upstream.DataSpec;
 import java.util.Random;
 
 /**
@@ -63,6 +68,49 @@ public FakeAdaptiveDataSet createDataSet(TrackGroup trackGroup, long mediaDurati
 
   }
 
+  /** {@link MediaChunkIterator} for the chunks defined by a fake adaptive data set. */
+  public static final class Iterator extends BaseMediaChunkIterator {
+
+    private final FakeAdaptiveDataSet dataSet;
+    private final int trackGroupIndex;
+
+    /**
+     * Create iterator.
+     *
+     * @param dataSet The data set to iterate over.
+     * @param trackGroupIndex The index of the track group to iterate over.
+     * @param chunkIndex The chunk index to which the iterator points initially.
+     */
+    public Iterator(FakeAdaptiveDataSet dataSet, int trackGroupIndex, int chunkIndex) {
+      super(/* fromIndex= */ chunkIndex, /* toIndex= */ dataSet.getChunkCount() - 1);
+      this.dataSet = dataSet;
+      this.trackGroupIndex = trackGroupIndex;
+    }
+
+    @Override
+    public DataSpec getDataSpec() {
+      checkInBounds();
+      String uri = dataSet.getUri(trackGroupIndex);
+      int chunkIndex = (int) getCurrentIndex();
+      Segment fakeDataChunk = dataSet.getData(uri).getSegments().get(chunkIndex);
+      return new DataSpec(
+          Uri.parse(uri), fakeDataChunk.byteOffset, fakeDataChunk.length, /* key= */ null);
+    }
+
+    @Override
+    public long getChunkStartTimeUs() {
+      checkInBounds();
+      return dataSet.getStartTime((int) getCurrentIndex());
+    }
+
+    @Override
+    public long getChunkEndTimeUs() {
+      checkInBounds();
+      int chunkIndex = (int) getCurrentIndex();
+      return dataSet.getStartTime(chunkIndex) + dataSet.getChunkDuration(chunkIndex);
+    }
+  }
+
   private final int chunkCount;
   private final long chunkDurationUs;
   private final long lastChunkDurationUs;
@@ -124,5 +172,4 @@ public long getStartTime(int chunkIndex) {
   public int getChunkIndexByPosition(long positionUs) {
     return (int) (positionUs / chunkDurationUs);
   }
-
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
index 1008c0d561..f8bf950ef2 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -24,6 +25,8 @@
 import com.google.android.exoplayer2.source.chunk.ChunkSampleStream;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.ArrayList;
 import java.util.List;
@@ -37,6 +40,7 @@
 
   private final Allocator allocator;
   private final FakeChunkSource.Factory chunkSourceFactory;
+  private final @Nullable TransferListener transferListener;
   private final long durationUs;
 
   private Callback callback;
@@ -48,10 +52,12 @@ public FakeAdaptiveMediaPeriod(
       EventDispatcher eventDispatcher,
       Allocator allocator,
       FakeChunkSource.Factory chunkSourceFactory,
-      long durationUs) {
+      long durationUs,
+      @Nullable TransferListener transferListener) {
     super(trackGroupArray, eventDispatcher);
     this.allocator = allocator;
     this.chunkSourceFactory = chunkSourceFactory;
+    this.transferListener = transferListener;
     this.durationUs = durationUs;
     this.sampleStreams = newSampleStreamArray(0);
   }
@@ -71,8 +77,13 @@ public synchronized void prepare(Callback callback, long positionUs) {
   }
 
   @Override
-  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+  @SuppressWarnings("unchecked")
+  public long selectTracks(
+      TrackSelection[] selections,
+      boolean[] mayRetainStreamFlags,
+      SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs) {
     long returnPositionUs = super.selectTracks(selections, mayRetainStreamFlags, streams,
         streamResetFlags, positionUs);
     List<ChunkSampleStream<FakeChunkSource>> validStreams = new ArrayList<>();
@@ -128,16 +139,17 @@ public boolean continueLoading(long positionUs) {
 
   @Override
   protected SampleStream createSampleStream(TrackSelection trackSelection) {
-    FakeChunkSource chunkSource = chunkSourceFactory.createChunkSource(trackSelection, durationUs);
+    FakeChunkSource chunkSource =
+        chunkSourceFactory.createChunkSource(trackSelection, durationUs, transferListener);
     return new ChunkSampleStream<>(
         MimeTypes.getTrackType(trackSelection.getSelectedFormat().sampleMimeType),
-        null,
-        null,
+        /* embeddedTrackTypes= */ null,
+        /* embeddedTrackFormats= */ null,
         chunkSource,
-        this,
+        /* callback= */ this,
         allocator,
-        0,
-        3,
+        /* positionUs= */ 0,
+        new DefaultLoadErrorHandlingPolicy(/* minimumLoadableRetryCount= */ 3),
         eventDispatcher);
   }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
index 41488b2a3b..089528bfde 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
@@ -15,14 +15,14 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSourceEventListener;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
 
 /**
  * Fake {@link MediaSource} that provides a given timeline. Creating the period returns a
@@ -36,12 +36,9 @@ public FakeAdaptiveMediaSource(
       Timeline timeline,
       Object manifest,
       TrackGroupArray trackGroupArray,
-      Handler eventHandler,
-      MediaSourceEventListener eventListener,
       FakeChunkSource.Factory chunkSourceFactory) {
     super(timeline, manifest, trackGroupArray);
     this.chunkSourceFactory = chunkSourceFactory;
-    addEventListener(eventHandler, eventListener);
   }
 
   @Override
@@ -49,10 +46,16 @@ protected FakeMediaPeriod createFakeMediaPeriod(
       MediaPeriodId id,
       TrackGroupArray trackGroupArray,
       Allocator allocator,
-      EventDispatcher eventDispatcher) {
-    Period period = timeline.getPeriod(id.periodIndex, new Period());
+      EventDispatcher eventDispatcher,
+      @Nullable TransferListener transferListener) {
+    Period period = timeline.getPeriodByUid(id.periodUid, new Period());
     return new FakeAdaptiveMediaPeriod(
-        trackGroupArray, eventDispatcher, allocator, chunkSourceFactory, period.durationUs);
+        trackGroupArray,
+        eventDispatcher,
+        allocator,
+        chunkSourceFactory,
+        period.durationUs,
+        transferListener);
   }
 
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
index 9234287e92..b5db0dc489 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
@@ -23,11 +24,13 @@
 import com.google.android.exoplayer2.source.chunk.ChunkHolder;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.source.chunk.SingleSampleMediaChunk;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData.Segment;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -52,11 +55,17 @@ public Factory(FakeAdaptiveDataSet.Factory dataSetFactory,
       this.dataSourceFactory = dataSourceFactory;
     }
 
-    public FakeChunkSource createChunkSource(TrackSelection trackSelection, long durationUs) {
+    public FakeChunkSource createChunkSource(
+        TrackSelection trackSelection,
+        long durationUs,
+        @Nullable TransferListener transferListener) {
       FakeAdaptiveDataSet dataSet =
           dataSetFactory.createDataSet(trackSelection.getTrackGroup(), durationUs);
       dataSourceFactory.setFakeDataSet(dataSet);
       DataSource dataSource = dataSourceFactory.createDataSource();
+      if (transferListener != null) {
+        dataSource.addTransferListener(transferListener);
+      }
       return new FakeChunkSource(trackSelection, dataSource, dataSet);
     }
 
@@ -95,14 +104,23 @@ public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaCh
   }
 
   @Override
-  public void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+  public void getNextChunk(
+      long playbackPositionUs,
+      long loadPositionUs,
+      List<? extends MediaChunk> queue,
       ChunkHolder out) {
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
-    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, C.TIME_UNSET);
     int chunkIndex =
-        previous == null
+        queue.isEmpty()
             ? dataSet.getChunkIndexByPosition(playbackPositionUs)
-            : (int) previous.getNextChunkIndex();
+            : (int) queue.get(queue.size() - 1).getNextChunkIndex();
+    MediaChunkIterator[] chunkIterators = new MediaChunkIterator[trackSelection.length()];
+    for (int i = 0; i < chunkIterators.length; i++) {
+      int trackGroupIndex = trackSelection.getIndexInTrackGroup(i);
+      chunkIterators[i] = new FakeAdaptiveDataSet.Iterator(dataSet, trackGroupIndex, chunkIndex);
+    }
+    trackSelection.updateSelectedTrack(
+        playbackPositionUs, bufferedDurationUs, C.TIME_UNSET, queue, chunkIterators);
     if (chunkIndex >= dataSet.getChunkCount()) {
       out.endOfStream = true;
     } else {
@@ -127,7 +145,8 @@ public void onChunkLoadCompleted(Chunk chunk) {
   }
 
   @Override
-  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
+  public boolean onChunkLoadError(
+      Chunk chunk, boolean cancelable, Exception e, long blacklistDurationMs) {
     return false;
   }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
index de623b59c9..9f6fdc9d49 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
@@ -16,14 +16,13 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData.Segment;
+import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -32,38 +31,38 @@
  * A fake {@link DataSource} capable of simulating various scenarios. It uses a {@link FakeDataSet}
  * instance which determines the response to data access calls.
  */
-public class FakeDataSource implements DataSource {
+public class FakeDataSource extends BaseDataSource {
 
   /**
    * Factory to create a {@link FakeDataSource}.
    */
   public static class Factory implements DataSource.Factory {
 
-    protected final TransferListener<? super FakeDataSource> transferListener;
     protected FakeDataSet fakeDataSet;
-
-    public Factory(@Nullable TransferListener<? super FakeDataSource> transferListener) {
-      this.transferListener = transferListener;
-    }
+    protected boolean isNetwork;
 
     public final Factory setFakeDataSet(FakeDataSet fakeDataSet) {
       this.fakeDataSet = fakeDataSet;
       return this;
     }
 
+    public final Factory setIsNetwork(boolean isNetwork) {
+      this.isNetwork = isNetwork;
+      return this;
+    }
+
     @Override
     public DataSource createDataSource() {
-      return new FakeDataSource(fakeDataSet, transferListener);
+      return new FakeDataSource(fakeDataSet, isNetwork);
     }
-
   }
 
   private final FakeDataSet fakeDataSet;
-  private final TransferListener<? super FakeDataSource> transferListener;
   private final ArrayList<DataSpec> openedDataSpecs;
 
   private Uri uri;
-  private boolean opened;
+  private boolean openCalled;
+  private boolean sourceOpened;
   private FakeData fakeData;
   private int currentSegmentIndex;
   private long bytesRemaining;
@@ -73,14 +72,13 @@ public FakeDataSource() {
   }
 
   public FakeDataSource(FakeDataSet fakeDataSet) {
-    this(fakeDataSet, null);
+    this(fakeDataSet, /* isNetwork= */ false);
   }
 
-  public FakeDataSource(FakeDataSet fakeDataSet,
-      @Nullable TransferListener<? super FakeDataSource> transferListener) {
+  public FakeDataSource(FakeDataSet fakeDataSet, boolean isNetwork) {
+    super(isNetwork);
     Assertions.checkNotNull(fakeDataSet);
     this.fakeDataSet = fakeDataSet;
-    this.transferListener = transferListener;
     this.openedDataSpecs = new ArrayList<>();
   }
 
@@ -90,12 +88,14 @@ public final FakeDataSet getDataSet() {
 
   @Override
   public final long open(DataSpec dataSpec) throws IOException {
-    Assertions.checkState(!opened);
+    Assertions.checkState(!openCalled);
+    openCalled = true;
+
     // DataSpec requires a matching close call even if open fails.
-    opened = true;
     uri = dataSpec.uri;
     openedDataSpecs.add(dataSpec);
 
+    transferInitializing(dataSpec);
     fakeData = fakeDataSet.getData(uri.toString());
     if (fakeData == null) {
       throw new IOException("Data not found: " + dataSpec.uri);
@@ -129,9 +129,8 @@ public final long open(DataSpec dataSpec) throws IOException {
         currentSegmentIndex++;
       }
     }
-    if (transferListener != null) {
-      transferListener.onTransferStart(this, dataSpec);
-    }
+    sourceOpened = true;
+    transferStarted(dataSpec);
     // Configure bytesRemaining, and return.
     if (dataSpec.length == C.LENGTH_UNSET) {
       bytesRemaining = totalLength - dataSpec.position;
@@ -144,7 +143,7 @@ public final long open(DataSpec dataSpec) throws IOException {
 
   @Override
   public final int read(byte[] buffer, int offset, int readLength) throws IOException {
-    Assertions.checkState(opened);
+    Assertions.checkState(sourceOpened);
     while (true) {
       if (currentSegmentIndex == fakeData.getSegments().size() || bytesRemaining == 0) {
         return C.RESULT_END_OF_INPUT;
@@ -171,9 +170,7 @@ public final int read(byte[] buffer, int offset, int readLength) throws IOExcept
           System.arraycopy(current.data, current.bytesRead, buffer, offset, readLength);
         }
         onDataRead(readLength);
-        if (transferListener != null) {
-          transferListener.onBytesTransferred(this, readLength);
-        }
+        bytesTransferred(readLength);
         bytesRemaining -= readLength;
         current.bytesRead += readLength;
         if (current.bytesRead == current.length) {
@@ -191,8 +188,8 @@ public final Uri getUri() {
 
   @Override
   public final void close() throws IOException {
-    Assertions.checkState(opened);
-    opened = false;
+    Assertions.checkState(openCalled);
+    openCalled = false;
     uri = null;
     if (fakeData != null && currentSegmentIndex < fakeData.getSegments().size()) {
       Segment current = fakeData.getSegments().get(currentSegmentIndex);
@@ -200,8 +197,9 @@ public final void close() throws IOException {
         current.exceptionCleared = true;
       }
     }
-    if (transferListener != null) {
-      transferListener.onTransferEnd(this);
+    if (sourceOpened) {
+      sourceOpened = false;
+      transferEnded();
     }
     fakeData = null;
   }
@@ -219,7 +217,7 @@ public final void close() throws IOException {
 
   /** Returns whether the data source is currently opened. */
   public final boolean isOpened() {
-    return opened;
+    return sourceOpened;
   }
 
   protected void onDataRead(int bytesRead) throws IOException {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
index 552827c8da..c467bd36af 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
@@ -20,6 +20,7 @@
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 
@@ -255,7 +256,7 @@ private boolean skipFullyInternal(int length, boolean allowEndOfInput) throws EO
     private boolean simulateIOErrors;
 
     public Builder() {
-      data = new byte[0];
+      data = Util.EMPTY_BYTE_ARRAY;
     }
 
     public Builder setData(byte[] data) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
index a251bd5ef0..f2739f2b4d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
@@ -31,6 +31,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.IOException;
+import java.util.Collections;
 
 /**
  * Fake {@link MediaPeriod} that provides tracks from the given {@link TrackGroupArray}. Selecting
@@ -93,13 +94,7 @@ public void setDiscontinuityPositionUs(long discontinuityPositionUs) {
   public synchronized void setPreparationComplete() {
     deferOnPrepared = false;
     if (playerHandler != null && prepareCallback != null) {
-      playerHandler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              finishPreparation();
-            }
-          });
+      playerHandler.post(this::finishPreparation);
     }
   }
 
@@ -232,6 +227,8 @@ private void finishPreparation() {
     prepareCallback.onPrepared(this);
     eventDispatcher.loadCompleted(
         FAKE_DATA_SPEC,
+        FAKE_DATA_SPEC.uri,
+        /* responseHeaders= */ Collections.emptyMap(),
         C.DATA_TYPE_MEDIA,
         C.TRACK_TYPE_UNKNOWN,
         /* trackFormat= */ null,
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
index ffc877bf42..1f0c0c1a40 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
@@ -36,9 +36,11 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -59,6 +61,7 @@
   private boolean preparedSource;
   private boolean releasedSource;
   private Handler sourceInfoRefreshHandler;
+  private @Nullable TransferListener transferListener;
 
   /**
    * Creates a {@link FakeMediaSource}. This media source creates {@link FakeMediaPeriod}s with a
@@ -86,8 +89,19 @@ public FakeMediaSource(@Nullable Timeline timeline, Object manifest,
   }
 
   @Override
-  public synchronized void prepareSourceInternal(ExoPlayer player, boolean isTopLevelSource) {
+  @Nullable
+  public Object getTag() {
+    boolean hasTimeline = timeline != null && !timeline.isEmpty();
+    return hasTimeline ? timeline.getWindow(0, new Timeline.Window()).tag : null;
+  }
+
+  @Override
+  public synchronized void prepareSourceInternal(
+      ExoPlayer player,
+      boolean isTopLevelSource,
+      @Nullable TransferListener mediaTransferListener) {
     assertThat(preparedSource).isFalse();
+    transferListener = mediaTransferListener;
     preparedSource = true;
     releasedSource = false;
     sourceInfoRefreshHandler = new Handler();
@@ -105,12 +119,13 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     assertThat(preparedSource).isTrue();
     assertThat(releasedSource).isFalse();
-    Assertions.checkIndex(id.periodIndex, 0, timeline.getPeriodCount());
-    Period period = timeline.getPeriod(id.periodIndex, new Period());
+    int periodIndex = timeline.getIndexOfPeriod(id.periodUid);
+    Assertions.checkArgument(periodIndex != C.INDEX_UNSET);
+    Period period = timeline.getPeriod(periodIndex, new Period());
     EventDispatcher eventDispatcher =
         createEventDispatcher(period.windowIndex, id, period.getPositionInWindowMs());
     FakeMediaPeriod mediaPeriod =
-        createFakeMediaPeriod(id, trackGroupArray, allocator, eventDispatcher);
+        createFakeMediaPeriod(id, trackGroupArray, allocator, eventDispatcher, transferListener);
     activeMediaPeriods.add(mediaPeriod);
     createdMediaPeriods.add(id);
     return mediaPeriod;
@@ -143,15 +158,12 @@ public void releaseSourceInternal() {
   public synchronized void setNewSourceInfo(final Timeline newTimeline, final Object newManifest) {
     if (sourceInfoRefreshHandler != null) {
       sourceInfoRefreshHandler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              assertThat(releasedSource).isFalse();
-              assertThat(preparedSource).isTrue();
-              timeline = newTimeline;
-              manifest = newManifest;
-              finishSourcePreparation();
-            }
+          () -> {
+            assertThat(releasedSource).isFalse();
+            assertThat(preparedSource).isTrue();
+            timeline = newTimeline;
+            manifest = newManifest;
+            finishSourcePreparation();
           });
     } else {
       timeline = newTimeline;
@@ -159,9 +171,9 @@ public void run() {
     }
   }
 
-  /** Asserts that the source has been prepared. */
-  public void assertPrepared() {
-    assertThat(preparedSource).isTrue();
+  /** Returns whether the source is currently prepared. */
+  public boolean isPrepared() {
+    return preparedSource;
   }
 
   /**
@@ -190,13 +202,16 @@ public void assertMediaPeriodCreated(MediaPeriodId mediaPeriodId) {
    * @param trackGroupArray The {@link TrackGroupArray} supported by the media period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    * @param eventDispatcher An {@link EventDispatcher} to dispatch media source events.
+   * @param transferListener The transfer listener which should be informed of any data transfers.
+   *     May be null if no listener is available.
    * @return A new {@link FakeMediaPeriod}.
    */
   protected FakeMediaPeriod createFakeMediaPeriod(
       MediaPeriodId id,
       TrackGroupArray trackGroupArray,
       Allocator allocator,
-      EventDispatcher eventDispatcher) {
+      EventDispatcher eventDispatcher,
+      @Nullable TransferListener transferListener) {
     return new FakeMediaPeriod(trackGroupArray, eventDispatcher);
   }
 
@@ -216,11 +231,18 @@ private void finishSourcePreparation() {
       EventDispatcher eventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
       eventDispatcher.loadStarted(
           new LoadEventInfo(
-              FAKE_DATA_SPEC, elapsedRealTimeMs, /* loadDurationMs= */ 0, /* bytesLoaded= */ 0),
+              FAKE_DATA_SPEC,
+              FAKE_DATA_SPEC.uri,
+              /* responseHeaders= */ Collections.emptyMap(),
+              elapsedRealTimeMs,
+              /* loadDurationMs= */ 0,
+              /* bytesLoaded= */ 0),
           mediaLoadData);
       eventDispatcher.loadCompleted(
           new LoadEventInfo(
               FAKE_DATA_SPEC,
+              FAKE_DATA_SPEC.uri,
+              /* responseHeaders= */ Collections.emptyMap(),
               elapsedRealTimeMs,
               /* loadDurationMs= */ 0,
               /* bytesLoaded= */ MANIFEST_LOAD_BYTES),
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
index 0575b261a9..8b653f6642 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
@@ -33,6 +33,7 @@
   private final Format format;
   private final @Nullable EventDispatcher eventDispatcher;
 
+  private boolean notifiedDownstreamFormat;
   private boolean readFormat;
   private boolean readSample;
 
@@ -59,6 +60,15 @@ public boolean isReady() {
   @Override
   public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       boolean formatRequired) {
+    if (eventDispatcher != null && !notifiedDownstreamFormat) {
+      eventDispatcher.downstreamFormatChanged(
+          C.TRACK_TYPE_UNKNOWN,
+          format,
+          C.SELECTION_REASON_UNKNOWN,
+          /* trackSelectionData= */ null,
+          /* mediaTimeUs= */ 0);
+      notifiedDownstreamFormat = true;
+    }
     if (formatRequired || !readFormat) {
       formatHolder.format = format;
       readFormat = true;
@@ -69,14 +79,6 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       buffer.data.put((byte) 0);
       buffer.flip();
       readSample = true;
-      if (eventDispatcher != null) {
-        eventDispatcher.downstreamFormatChanged(
-            C.TRACK_TYPE_UNKNOWN,
-            format,
-            C.SELECTION_REASON_UNKNOWN,
-            /* trackSelectionData= */ null,
-            /* mediaTimeUs= */ 0);
-      }
       return C.RESULT_BUFFER_READ;
     } else {
       buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
index 4e118366d7..56438a51ef 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ads.AdPlaybackState;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
@@ -206,15 +207,25 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
 
   @Override
   public int getIndexOfPeriod(Object uid) {
-    Period period = new Period();
     for (int i = 0; i < getPeriodCount(); i++) {
-      if (getPeriod(i, period, true).uid.equals(uid)) {
+      if (getUidOfPeriod(i).equals(uid)) {
         return i;
       }
     }
     return C.INDEX_UNSET;
   }
 
+  @Override
+  public Object getUidOfPeriod(int periodIndex) {
+    Assertions.checkIndex(periodIndex, 0, getPeriodCount());
+    int windowIndex =
+        Util.binarySearchFloor(
+            periodOffsets, periodIndex, /* inclusive= */ true, /* stayInBounds= */ false);
+    int windowPeriodIndex = periodIndex - periodOffsets[windowIndex];
+    TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
+    return Pair.create(windowDefinition.id, windowPeriodIndex);
+  }
+
   private static TimelineWindowDefinition[] createDefaultWindowDefinitions(int windowCount) {
     TimelineWindowDefinition[] windowDefinitions = new TimelineWindowDefinition[windowCount];
     for (int i = 0; i < windowCount; i++) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
index 6432842df4..4dd00557ae 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -44,7 +45,7 @@
   public Format format;
 
   public FakeTrackOutput() {
-    sampleData = new byte[0];
+    sampleData = Util.EMPTY_BYTE_ARRAY;
     sampleTimesUs = new ArrayList<>();
     sampleFlags = new ArrayList<>();
     sampleStartOffsets = new ArrayList<>();
@@ -53,7 +54,7 @@ public FakeTrackOutput() {
   }
 
   public void clear() {
-    sampleData = new byte[0];
+    sampleData = Util.EMPTY_BYTE_ARRAY;
     sampleTimesUs.clear();
     sampleFlags.clear();
     sampleStartOffsets.clear();
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 6cbba48f1f..257b66a3d0 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -25,12 +25,12 @@
 import android.os.ConditionVariable;
 import android.os.PowerManager;
 import android.os.PowerManager.WakeLock;
-import android.util.Log;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 import android.view.Window;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -80,6 +80,7 @@
   }
 
   private static final String TAG = "HostActivity";
+  private static final long START_TIMEOUT_MS = 5000;
 
   private WakeLock wakeLock;
   private WifiLock wifiLock;
@@ -117,14 +118,18 @@ public void runTest(final HostedTest hostedTest, long timeoutMs, boolean failOnT
     forcedStopped = false;
     hostedTestStarted = false;
 
-    runOnUiThread(new Runnable() {
-      @Override
-      public void run() {
-        HostActivity.this.hostedTest = hostedTest;
-        maybeStartHostedTest();
-      }
-    });
-    hostedTestStartedCondition.block();
+    runOnUiThread(
+        () -> {
+          HostActivity.this.hostedTest = hostedTest;
+          maybeStartHostedTest();
+        });
+
+    if (!hostedTestStartedCondition.block(START_TIMEOUT_MS)) {
+      String message =
+          "Test failed to start. Display may be turned off or keyguard may be present.";
+      Log.e(TAG, message);
+      fail(message);
+    }
 
     if (hostedTest.blockUntilStopped(timeoutMs)) {
       if (!forcedStopped) {
@@ -138,12 +143,7 @@ public void run() {
         fail(message);
       }
     } else {
-      runOnUiThread(new Runnable() {
-        @Override
-        public void run() {
-          hostedTest.forceStop();
-        }
-      });
+      runOnUiThread(hostedTest::forceStop);
       String message = "Test timed out after " + timeoutMs + " ms.";
       Log.e(TAG, message);
       if (failOnTimeout) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/LogcatMetricsLogger.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/LogcatMetricsLogger.java
index fdff47dd2c..f3432749d0 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/LogcatMetricsLogger.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/LogcatMetricsLogger.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.util.Log;
+import com.google.android.exoplayer2.util.Log;
 
 /**
  * Implementation of {@link MetricsLogger} that prints the metrics to logcat.
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index ee17068242..3351e2db8d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -19,8 +19,16 @@
 import static org.junit.Assert.fail;
 
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
+import android.net.Uri;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -140,7 +148,11 @@ public static InputStream getInputStream(Context context, String fileName) throw
   }
 
   public static String getString(Context context, String fileName) throws IOException {
-    return new String(getByteArray(context, fileName));
+    return Util.fromUtf8Bytes(getByteArray(context, fileName));
+  }
+
+  public static Bitmap readBitmapFromFile(Context context, String fileName) throws IOException {
+    return BitmapFactory.decodeStream(getInputStream(context, fileName));
   }
 
   /**
@@ -166,4 +178,203 @@ public static void assertDataSourceContent(
     }
   }
 
+  /**
+   * Asserts whether actual bitmap is very similar to the expected bitmap at some quality level.
+   *
+   * <p>This is defined as their PSNR value is greater than or equal to the threshold. The higher
+   * the threshold, the more similar they are.
+   *
+   * @param expectedBitmap The expected bitmap.
+   * @param actualBitmap The actual bitmap.
+   * @param psnrThresholdDb The PSNR threshold (in dB), at or above which bitmaps are considered
+   *     very similar.
+   */
+  public static void assertBitmapsAreSimilar(
+      Bitmap expectedBitmap, Bitmap actualBitmap, double psnrThresholdDb) {
+    assertThat(getPsnr(expectedBitmap, actualBitmap)).isAtLeast(psnrThresholdDb);
+  }
+
+  /**
+   * Calculates the Peak-Signal-to-Noise-Ratio value for 2 bitmaps.
+   *
+   * <p>This is the logarithmic decibel(dB) value of the average mean-squared-error of normalized
+   * (0.0-1.0) R/G/B values from the two bitmaps. The higher the value, the more similar they are.
+   *
+   * @param firstBitmap The first bitmap.
+   * @param secondBitmap The second bitmap.
+   * @return The PSNR value calculated from these 2 bitmaps.
+   */
+  private static double getPsnr(Bitmap firstBitmap, Bitmap secondBitmap) {
+    assertThat(firstBitmap.getWidth()).isEqualTo(secondBitmap.getWidth());
+    assertThat(firstBitmap.getHeight()).isEqualTo(secondBitmap.getHeight());
+    long mse = 0;
+    for (int i = 0; i < firstBitmap.getWidth(); i++) {
+      for (int j = 0; j < firstBitmap.getHeight(); j++) {
+        int firstColorInt = firstBitmap.getPixel(i, j);
+        int firstRed = Color.red(firstColorInt);
+        int firstGreen = Color.green(firstColorInt);
+        int firstBlue = Color.blue(firstColorInt);
+        int secondColorInt = secondBitmap.getPixel(i, j);
+        int secondRed = Color.red(secondColorInt);
+        int secondGreen = Color.green(secondColorInt);
+        int secondBlue = Color.blue(secondColorInt);
+        mse +=
+            ((firstRed - secondRed) * (firstRed - secondRed)
+                + (firstGreen - secondGreen) * (firstGreen - secondGreen)
+                + (firstBlue - secondBlue) * (firstBlue - secondBlue));
+      }
+    }
+    double normalizedMse =
+        mse / (255.0 * 255.0 * 3.0 * firstBitmap.getWidth() * firstBitmap.getHeight());
+    return 10 * Math.log10(1.0 / normalizedMse);
+  }
+
+  /** Returns the {@link Uri} for the given asset path. */
+  public static Uri buildAssetUri(String assetPath) {
+    return Uri.parse("asset:///" + assetPath);
+  }
+
+  /**
+   * Reads from the given input using the given {@link Extractor}, until it can produce the {@link
+   * SeekMap} and all of the tracks have been identified, or until the extractor encounters EOF.
+   *
+   * @param extractor The {@link Extractor} to extractor from input.
+   * @param output The {@link FakeTrackOutput} to store the extracted {@link SeekMap} and track.
+   * @param dataSource The {@link DataSource} that will be used to read from the input.
+   * @param uri The Uri of the input.
+   * @return The extracted {@link SeekMap}.
+   * @throws IOException If an error occurred reading from the input, or if the extractor finishes
+   *     reading from input without extracting any {@link SeekMap}.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public static SeekMap extractSeekMap(
+      Extractor extractor, FakeExtractorOutput output, DataSource dataSource, Uri uri)
+      throws IOException, InterruptedException {
+    ExtractorInput input = getExtractorInputFromPosition(dataSource, /* position= */ 0, uri);
+    extractor.init(output);
+    PositionHolder positionHolder = new PositionHolder();
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (true) {
+      try {
+        // Keep reading until we can get the seek map
+        while (readResult == Extractor.RESULT_CONTINUE
+            && (output.seekMap == null || !output.tracksEnded)) {
+          readResult = extractor.read(input, positionHolder);
+        }
+      } finally {
+        Util.closeQuietly(dataSource);
+      }
+
+      if (readResult == Extractor.RESULT_SEEK) {
+        input = getExtractorInputFromPosition(dataSource, positionHolder.position, uri);
+        readResult = Extractor.RESULT_CONTINUE;
+      } else if (readResult == Extractor.RESULT_END_OF_INPUT) {
+        throw new IOException("EOF encountered without seekmap");
+      }
+      if (output.seekMap != null) {
+        return output.seekMap;
+      }
+    }
+  }
+
+  /**
+   * Extracts all samples from the given file into a {@link FakeTrackOutput}.
+   *
+   * @param extractor The {@link Extractor} to extractor from input.
+   * @param context A {@link Context}.
+   * @param fileName The name of the input file.
+   * @return The {@link FakeTrackOutput} containing the extracted samples.
+   * @throws IOException If an error occurred reading from the input, or if the extractor finishes
+   *     reading from input without extracting any {@link SeekMap}.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public static FakeExtractorOutput extractAllSamplesFromFile(
+      Extractor extractor, Context context, String fileName)
+      throws IOException, InterruptedException {
+    byte[] data = TestUtil.getByteArray(context, fileName);
+    FakeExtractorOutput expectedOutput = new FakeExtractorOutput();
+    extractor.init(expectedOutput);
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
+
+    PositionHolder positionHolder = new PositionHolder();
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      while (readResult == Extractor.RESULT_CONTINUE) {
+        readResult = extractor.read(input, positionHolder);
+      }
+      if (readResult == Extractor.RESULT_SEEK) {
+        input.setPosition((int) positionHolder.position);
+        readResult = Extractor.RESULT_CONTINUE;
+      }
+    }
+    return expectedOutput;
+  }
+
+  /**
+   * Seeks to the given seek time of the stream from the given input, and keeps reading from the
+   * input until we can extract at least one sample following the seek position, or until
+   * end-of-input is reached.
+   *
+   * @param extractor The {@link Extractor} to extractor from input.
+   * @param seekMap The {@link SeekMap} of the stream from the given input.
+   * @param seekTimeUs The seek time, in micro-seconds.
+   * @param trackOutput The {@link FakeTrackOutput} to store the extracted samples.
+   * @param dataSource The {@link DataSource} that will be used to read from the input.
+   * @param uri The Uri of the input.
+   * @return The index of the first extracted sample written to the given {@code trackOutput} after
+   *     the seek is completed, or -1 if the seek is completed without any extracted sample.
+   */
+  public static int seekToTimeUs(
+      Extractor extractor,
+      SeekMap seekMap,
+      long seekTimeUs,
+      DataSource dataSource,
+      FakeTrackOutput trackOutput,
+      Uri uri)
+      throws IOException, InterruptedException {
+    int numSampleBeforeSeek = trackOutput.getSampleCount();
+    SeekMap.SeekPoints seekPoints = seekMap.getSeekPoints(seekTimeUs);
+
+    long initialSeekLoadPosition = seekPoints.first.position;
+    extractor.seek(initialSeekLoadPosition, seekTimeUs);
+
+    PositionHolder positionHolder = new PositionHolder();
+    positionHolder.position = C.POSITION_UNSET;
+    ExtractorInput extractorInput =
+        TestUtil.getExtractorInputFromPosition(dataSource, initialSeekLoadPosition, uri);
+    int extractorReadResult = Extractor.RESULT_CONTINUE;
+    while (true) {
+      try {
+        // Keep reading until we can read at least one sample after seek
+        while (extractorReadResult == Extractor.RESULT_CONTINUE
+            && trackOutput.getSampleCount() == numSampleBeforeSeek) {
+          extractorReadResult = extractor.read(extractorInput, positionHolder);
+        }
+      } finally {
+        Util.closeQuietly(dataSource);
+      }
+
+      if (extractorReadResult == Extractor.RESULT_SEEK) {
+        extractorInput =
+            TestUtil.getExtractorInputFromPosition(dataSource, positionHolder.position, uri);
+        extractorReadResult = Extractor.RESULT_CONTINUE;
+      } else if (extractorReadResult == Extractor.RESULT_END_OF_INPUT) {
+        return -1;
+      } else if (trackOutput.getSampleCount() > numSampleBeforeSeek) {
+        // First index after seek = num sample before seek.
+        return numSampleBeforeSeek;
+      }
+    }
+  }
+
+  /** Returns an {@link ExtractorInput} to read from the given input at given position. */
+  public static ExtractorInput getExtractorInputFromPosition(
+      DataSource dataSource, long position, Uri uri) throws IOException {
+    DataSpec dataSpec = new DataSpec(uri, position, C.LENGTH_UNSET, /* key= */ null);
+    long length = dataSource.open(dataSpec);
+    if (length != C.LENGTH_UNSET) {
+      length += position;
+    }
+    return new DefaultExtractorInput(dataSource, position, length);
+  }
 }
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
index 725753ce46..90e70e4538 100644
--- a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
@@ -131,13 +131,7 @@ private static void assertSleepingStates(boolean[] states, SleeperThread[] sleep
 
   private static void waitForHandler(HandlerWrapper handler) {
     final ConditionVariable handlerFinished = new ConditionVariable();
-    handler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            handlerFinished.open();
-          }
-        });
+    handler.post(handlerFinished::open);
     handlerFinished.block();
   }
 
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
index 75c6f886c2..99469295bb 100644
--- a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
@@ -65,11 +65,8 @@ public void testMultipleDataSets() {
   public void testSegmentTypes() {
     byte[] testData = TestUtil.buildTestData(3);
     Runnable runnable =
-        new Runnable() {
-          @Override
-          public void run() {
-            // Do nothing.
-          }
+        () -> {
+          // Do nothing.
         };
     IOException exception = new IOException();
     FakeDataSet fakeDataSet =
diff --git a/testutils_robolectric/build.gradle b/testutils_robolectric/build.gradle
index 1fd745c676..2d3317934b 100644
--- a/testutils_robolectric/build.gradle
+++ b/testutils_robolectric/build.gradle
@@ -18,6 +18,11 @@ android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
index cb70c75bdb..4b3a0d5051 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
@@ -61,8 +61,8 @@ public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
   }
 
   @Override
-  public ShuffleOrder cloneAndRemove(int removalIndex) {
-    return new FakeShuffleOrder(length - 1);
+  public ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive) {
+    return new FakeShuffleOrder(length - indexToExclusive + indexFrom);
   }
 
   @Override
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java
index 8ceb5338a6..b479ebed29 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.util.List;
 
@@ -119,7 +120,11 @@ public void onPlaybackSpeed(float speed) {
 
   @Override
   public void updateSelectedTrack(
-      long playbackPositionUs, long bufferedDurationUs, long availableDurationUs) {
+      long playbackPositionUs,
+      long bufferedDurationUs,
+      long availableDurationUs,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] mediaChunkIterators) {
     assertThat(isEnabled).isTrue();
   }
 
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
index 4d4a53bcdd..d3eca63461 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
@@ -51,8 +51,9 @@ public FakeTrackSelector(boolean mayReuseTrackSelection) {
       int[] rendererMixedMimeTypeAdaptationSupports,
       Parameters params)
       throws ExoPlaybackException {
-    TrackSelection[] selections = new TrackSelection[mappedTrackInfo.length];
-    for (int i = 0; i < mappedTrackInfo.length; i++) {
+    int rendererCount = mappedTrackInfo.getRendererCount();
+    TrackSelection[] selections = new TrackSelection[rendererCount];
+    for (int i = 0; i < rendererCount; i++) {
       TrackGroupArray trackGroupArray = mappedTrackInfo.getTrackGroups(i);
       boolean hasTracks = trackGroupArray.length > 0;
       selections[i] = hasTracks ? reuseOrCreateTrackSelection(trackGroupArray.get(0)) : null;
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
index ee3a3a2d32..70e7669dfb 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
@@ -97,16 +97,13 @@ public void runOnPlaybackThread(final Runnable runnable) {
     final Throwable[] throwable = new Throwable[1];
     final ConditionVariable finishedCondition = new ConditionVariable();
     playbackHandler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            try {
-              runnable.run();
-            } catch (Throwable e) {
-              throwable[0] = e;
-            } finally {
-              finishedCondition.open();
-            }
+        () -> {
+          try {
+            runnable.run();
+          } catch (Throwable e) {
+            throwable[0] = e;
+          } finally {
+            finishedCondition.open();
           }
         });
     assertThat(finishedCondition.block(TIMEOUT_MS)).isTrue();
@@ -123,18 +120,19 @@ public void run() {
   public Timeline prepareSource() throws IOException {
     final IOException[] prepareError = new IOException[1];
     runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            mediaSource.prepareSource(player, true, mediaSourceListener);
-            try {
-              // TODO: This only catches errors that are set synchronously in prepareSource. To
-              // capture async errors we'll need to poll maybeThrowSourceInfoRefreshError until the
-              // first call to onSourceInfoRefreshed.
-              mediaSource.maybeThrowSourceInfoRefreshError();
-            } catch (IOException e) {
-              prepareError[0] = e;
-            }
+        () -> {
+          mediaSource.prepareSource(
+              player,
+              /* isTopLevelSource= */ true,
+              mediaSourceListener,
+              /* mediaTransferListener= */ null);
+          try {
+            // TODO: This only catches errors that are set synchronously in prepareSource. To
+            // capture async errors we'll need to poll maybeThrowSourceInfoRefreshError until the
+            // first call to onSourceInfoRefreshed.
+            mediaSource.maybeThrowSourceInfoRefreshError();
+          } catch (IOException e) {
+            prepareError[0] = e;
           }
         });
     if (prepareError[0] != null) {
@@ -152,13 +150,7 @@ public void run() {
    */
   public MediaPeriod createPeriod(final MediaPeriodId periodId) {
     final MediaPeriod[] holder = new MediaPeriod[1];
-    runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            holder[0] = mediaSource.createPeriod(periodId, allocator);
-          }
-        });
+    runOnPlaybackThread(() -> holder[0] = mediaSource.createPeriod(periodId, allocator));
     assertThat(holder[0]).isNotNull();
     return holder[0];
   }
@@ -175,24 +167,21 @@ public CountDownLatch preparePeriod(final MediaPeriod mediaPeriod, final long po
     final ConditionVariable prepareCalled = new ConditionVariable();
     final CountDownLatch preparedCountDown = new CountDownLatch(1);
     runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            mediaPeriod.prepare(
-                new MediaPeriod.Callback() {
-                  @Override
-                  public void onPrepared(MediaPeriod mediaPeriod) {
-                    preparedCountDown.countDown();
-                  }
-
-                  @Override
-                  public void onContinueLoadingRequested(MediaPeriod source) {
-                    // Do nothing.
-                  }
-                },
-                positionUs);
-            prepareCalled.open();
-          }
+        () -> {
+          mediaPeriod.prepare(
+              new MediaPeriod.Callback() {
+                @Override
+                public void onPrepared(MediaPeriod mediaPeriod1) {
+                  preparedCountDown.countDown();
+                }
+
+                @Override
+                public void onContinueLoadingRequested(MediaPeriod source) {
+                  // Do nothing.
+                }
+              },
+              positionUs);
+          prepareCalled.open();
         });
     prepareCalled.block();
     return preparedCountDown;
@@ -204,13 +193,7 @@ public void onContinueLoadingRequested(MediaPeriod source) {
    * @param mediaPeriod The {@link MediaPeriod} to release.
    */
   public void releasePeriod(final MediaPeriod mediaPeriod) {
-    runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            mediaSource.releasePeriod(mediaPeriod);
-          }
-        });
+    runOnPlaybackThread(() -> mediaSource.releasePeriod(mediaPeriod));
   }
 
   /**
@@ -218,13 +201,7 @@ public void run() {
    * thread.
    */
   public void releaseSource() {
-    runOnPlaybackThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            mediaSource.releaseSource(mediaSourceListener);
-          }
-        });
+    runOnPlaybackThread(() -> mediaSource.releaseSource(mediaSourceListener));
   }
 
   /**
@@ -274,12 +251,12 @@ public Timeline assertTimelineChangeBlocking() {
   public void assertPrepareAndReleaseAllPeriods() throws InterruptedException {
     Timeline.Period period = new Timeline.Period();
     for (int i = 0; i < timeline.getPeriodCount(); i++) {
-      timeline.getPeriod(i, period);
-      assertPrepareAndReleasePeriod(new MediaPeriodId(i, period.windowIndex));
+      timeline.getPeriod(i, period, /* setIds= */ true);
+      assertPrepareAndReleasePeriod(new MediaPeriodId(period.uid, period.windowIndex));
       for (int adGroupIndex = 0; adGroupIndex < period.getAdGroupCount(); adGroupIndex++) {
         for (int adIndex = 0; adIndex < period.getAdCountInAdGroup(adGroupIndex); adIndex++) {
           assertPrepareAndReleasePeriod(
-              new MediaPeriodId(i, adGroupIndex, adIndex, period.windowIndex));
+              new MediaPeriodId(period.uid, adGroupIndex, adIndex, period.windowIndex));
         }
       }
     }
@@ -291,17 +268,25 @@ private void assertPrepareAndReleasePeriod(MediaPeriodId mediaPeriodId)
     assertThat(lastCreatedMediaPeriod.getAndSet(/* newValue= */ null)).isEqualTo(mediaPeriodId);
     CountDownLatch preparedCondition = preparePeriod(mediaPeriod, 0);
     assertThat(preparedCondition.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)).isTrue();
-    // MediaSource is supposed to support multiple calls to createPeriod with the same id without an
-    // intervening call to releasePeriod.
-    MediaPeriod secondMediaPeriod = createPeriod(mediaPeriodId);
-    assertThat(lastCreatedMediaPeriod.getAndSet(/* newValue= */ null)).isEqualTo(mediaPeriodId);
+    // MediaSource is supposed to support multiple calls to createPeriod without an intervening call
+    // to releasePeriod.
+    MediaPeriodId secondMediaPeriodId =
+        new MediaPeriodId(
+            mediaPeriodId.periodUid,
+            mediaPeriodId.adGroupIndex,
+            mediaPeriodId.adIndexInAdGroup,
+            mediaPeriodId.windowSequenceNumber + 1000);
+    MediaPeriod secondMediaPeriod = createPeriod(secondMediaPeriodId);
+    assertThat(lastCreatedMediaPeriod.getAndSet(/* newValue= */ null))
+        .isEqualTo(secondMediaPeriodId);
     CountDownLatch secondPreparedCondition = preparePeriod(secondMediaPeriod, 0);
     assertThat(secondPreparedCondition.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)).isTrue();
     // Release the periods.
     releasePeriod(mediaPeriod);
     assertThat(lastReleasedMediaPeriod.getAndSet(/* newValue= */ null)).isEqualTo(mediaPeriodId);
     releasePeriod(secondMediaPeriod);
-    assertThat(lastReleasedMediaPeriod.getAndSet(/* newValue= */ null)).isEqualTo(mediaPeriodId);
+    assertThat(lastReleasedMediaPeriod.getAndSet(/* newValue= */ null))
+        .isEqualTo(secondMediaPeriodId);
   }
 
   /**
@@ -337,8 +322,8 @@ public void assertCompletedMediaPeriodLoads(MediaPeriodId... mediaPeriodIds) {
       int windowIndex = windowIndexAndMediaPeriodId.first;
       MediaPeriodId mediaPeriodId = windowIndexAndMediaPeriodId.second;
       if (expectedLoads.remove(mediaPeriodId)) {
-        assertThat(windowIndex)
-            .isEqualTo(timeline.getPeriod(mediaPeriodId.periodIndex, period).windowIndex);
+        int periodIndex = timeline.getIndexOfPeriod(mediaPeriodId.periodUid);
+        assertThat(windowIndex).isEqualTo(timeline.getPeriod(periodIndex, period).windowIndex);
       }
     }
     assertWithMessage("Not all expected media source loads have been completed.")
@@ -442,6 +427,11 @@ public EventHandlingExoPlayer(Looper looper) {
       this.handler = new Handler(looper, this);
     }
 
+    @Override
+    public Looper getApplicationLooper() {
+      return handler.getLooper();
+    }
+
     @Override
     public PlayerMessage createMessage(PlayerMessage.Target target) {
       return new PlayerMessage(
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
index 0d5d4e4437..dc7781fd90 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
@@ -61,9 +61,9 @@ public CustomLooper() {
 
     @Implementation
     public static void loop() {
-      ShadowLooper looper = shadowOf(Looper.myLooper());
-      if (looper instanceof CustomLooper) {
-        ((CustomLooper) looper).doLoop();
+      Looper looper = Looper.myLooper();
+      if (shadowOf(looper) instanceof CustomLooper) {
+        ((CustomLooper) shadowOf(looper)).doLoop();
       }
     }
 
@@ -93,8 +93,9 @@ private void removeMessages(Handler handler, int what, Object object) {
     }
 
     private void doLoop() {
-      try {
-        while (true) {
+      boolean wasInterrupted = false;
+      while (true) {
+        try {
           PendingMessage pendingMessage = pendingMessages.take();
           if (pendingMessage.message == null) {
             // Null message is signal to end message loop.
@@ -118,6 +119,11 @@ private void doLoop() {
             }
             if (!isRemoved) {
               try {
+                if (wasInterrupted) {
+                  wasInterrupted = false;
+                  // Restore the interrupt status flag, so long-running messages will exit early.
+                  Thread.currentThread().interrupt();
+                }
                 target.dispatchMessage(pendingMessage.message);
               } catch (Throwable t) {
                 // Interrupt the main thread to terminate the test. Robolectric's HandlerThread will
@@ -132,9 +138,9 @@ private void doLoop() {
           } else {
             callInstanceMethod(pendingMessage.message, "recycle");
           }
+        } catch (InterruptedException e) {
+          wasInterrupted = true;
         }
-      } catch (InterruptedException e) {
-        // Ignore.
       }
     }
   }
@@ -155,9 +161,10 @@ public CustomMessageQueue() {
     @Implementation
     @Override
     public boolean enqueueMessage(Message msg, long when) {
-      ShadowLooper looper = shadowOf(ShadowLooper.getLooperForThread(looperThread));
-      if (looper instanceof CustomLooper && looper != ShadowLooper.getShadowMainLooper()) {
-        ((CustomLooper) looper).addPendingMessage(msg, when);
+      Looper looper = ShadowLooper.getLooperForThread(looperThread);
+      if (shadowOf(looper) instanceof CustomLooper
+          && shadowOf(looper) != ShadowLooper.getShadowMainLooper()) {
+        ((CustomLooper) shadowOf(looper)).addPendingMessage(msg, when);
       } else {
         super.enqueueMessage(msg, when);
       }
@@ -166,9 +173,10 @@ public boolean enqueueMessage(Message msg, long when) {
 
     @Implementation
     public void removeMessages(Handler handler, int what, Object object) {
-      ShadowLooper looper = shadowOf(ShadowLooper.getLooperForThread(looperThread));
-      if (looper instanceof CustomLooper && looper != ShadowLooper.getShadowMainLooper()) {
-        ((CustomLooper) looper).removeMessages(handler, what, object);
+      Looper looper = ShadowLooper.getLooperForThread(looperThread);
+      if (shadowOf(looper) instanceof CustomLooper
+          && shadowOf(looper) != ShadowLooper.getShadowMainLooper()) {
+        ((CustomLooper) shadowOf(looper)).removeMessages(handler, what, object);
       }
     }
   }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
index d81cef9d8a..724ed366bc 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.BasePlayer;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -32,7 +32,12 @@
  * An abstract {@link ExoPlayer} implementation that throws {@link UnsupportedOperationException}
  * from every method.
  */
-public abstract class StubExoPlayer implements ExoPlayer {
+public abstract class StubExoPlayer extends BasePlayer implements ExoPlayer {
+
+  @Override
+  public AudioComponent getAudioComponent() {
+    throw new UnsupportedOperationException();
+  }
 
   @Override
   public VideoComponent getVideoComponent() {
@@ -44,11 +49,21 @@ public TextComponent getTextComponent() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
+  public MetadataComponent getMetadataComponent() {
+    throw new UnsupportedOperationException();
+  }
+
   @Override
   public Looper getPlaybackLooper() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
+  public Looper getApplicationLooper() {
+    throw new UnsupportedOperationException();
+  }
+
   @Override
   public void addListener(Player.EventListener listener) {
     throw new UnsupportedOperationException();
@@ -69,6 +84,11 @@ public ExoPlaybackException getPlaybackError() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
+  public void retry() {
+    throw new UnsupportedOperationException();
+  }
+
   @Override
   public void prepare(MediaSource mediaSource) {
     throw new UnsupportedOperationException();
@@ -114,21 +134,6 @@ public boolean isLoading() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     throw new UnsupportedOperationException();
@@ -150,12 +155,7 @@ public void setSeekParameters(SeekParameters seekParameters) {
   }
 
   @Override
-  public @Nullable Object getCurrentTag() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void stop() {
+  public SeekParameters getSeekParameters() {
     throw new UnsupportedOperationException();
   }
 
@@ -175,11 +175,15 @@ public PlayerMessage createMessage(PlayerMessage.Target target) {
   }
 
   @Override
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public void sendMessages(ExoPlayerMessage... messages) {
     throw new UnsupportedOperationException();
   }
 
   @Override
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public void blockingSendMessages(ExoPlayerMessage... messages) {
     throw new UnsupportedOperationException();
   }
@@ -224,16 +228,6 @@ public int getCurrentWindowIndex() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public long getDuration() {
     throw new UnsupportedOperationException();
@@ -250,17 +244,7 @@ public long getBufferedPosition() {
   }
 
   @Override
-  public int getBufferedPercentage() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
+  public long getTotalBufferedDuration() {
     throw new UnsupportedOperationException();
   }
 
@@ -283,4 +267,9 @@ public int getCurrentAdIndexInAdGroup() {
   public long getContentPosition() {
     throw new UnsupportedOperationException();
   }
+
+  @Override
+  public long getContentBufferedPosition() {
+    throw new UnsupportedOperationException();
+  }
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java
index b624c49350..7e0ffc1772 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java
@@ -81,12 +81,9 @@ public void blockUntilTasksCompleteAndThrowAnyDownloadError() throws Throwable {
       downloadFinishedCondition = new CountDownLatch(1);
     }
     dummyMainThread.runOnMainThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            if (downloadManager.isIdle()) {
-              downloadFinishedCondition.countDown();
-            }
+        () -> {
+          if (downloadManager.isIdle()) {
+            downloadFinishedCondition.countDown();
           }
         });
     assertThat(downloadFinishedCondition.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
@@ -98,7 +95,7 @@ public void run() {
   private ArrayBlockingQueue<Integer> getStateQueue(DownloadAction action) {
     synchronized (actionStates) {
       if (!actionStates.containsKey(action)) {
-        actionStates.put(action, new ArrayBlockingQueue<Integer>(10));
+        actionStates.put(action, new ArrayBlockingQueue<>(10));
       }
       return actionStates.get(action);
     }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
index a0ca6af8a9..1e3c9c61d9 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
@@ -141,6 +141,7 @@ public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCo
       }
       assertThat(period.windowIndex).isEqualTo(expectedWindowIndex);
       assertThat(timeline.getIndexOfPeriod(period.uid)).isEqualTo(i);
+      assertThat(timeline.getUidOfPeriod(i)).isEqualTo(period.uid);
       for (int repeatMode : REPEAT_MODES) {
         if (i < accumulatedPeriodCounts[expectedWindowIndex + 1] - 1) {
           assertThat(timeline.getNextPeriodIndex(i, period, window, repeatMode, false))
