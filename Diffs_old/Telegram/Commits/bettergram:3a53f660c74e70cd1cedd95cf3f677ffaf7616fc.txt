diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index 8d2910bf2..1598a373e 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -4,6 +4,7 @@ repositories {
     google()
     mavenCentral()
     jcenter()
+    maven { url 'https://jitpack.io' }
 }
 
 configurations {
@@ -30,10 +31,23 @@ dependencies {
     implementation 'net.hockeyapp.android:HockeySDK:5.1.0'
     implementation 'com.googlecode.mp4parser:isoparser:1.0.6'
     implementation 'com.stripe:stripe-android:2.0.2'
+    annotationProcessor "com.github.instagram.ig-json-parser:processor:$rootProject.igjsonVersion"
+    implementation "com.github.instagram.ig-json-parser:runtime:$rootProject.igjsonVersion"
+    implementation("com.squareup.picasso:picasso:$rootProject.picassoVersion") {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    }
+    implementation("com.rometools:rome:$rootProject.romVersion") {
+        exclude group: 'org.apache.commons', module: 'commons-lang3'
+    }
+    implementation project(path: ':inline-youtube-view')
+    implementation(project(path: ":shinebuttonlib")) {
+        exclude group: 'com.android.support', module: 'appcompat-v7'
+    }
+    implementation 'org.jsoup:jsoup:1.11.3'
 }
 
 android {
-    compileSdkVersion 28
+    compileSdkVersion rootProject.compileSdkVersion
     buildToolsVersion '28.0.3'
 
     defaultConfig.applicationId = "io.bettergram"
@@ -99,6 +113,7 @@ android {
             debuggable false
             jniDebuggable false
             signingConfig signingConfigs.release
+            matchingFallbacks = ['debug', 'release']
         }
     }
 
@@ -237,8 +252,8 @@ android {
     }
 
     defaultConfig {
-        minSdkVersion 21
-        targetSdkVersion 28
+        minSdkVersion rootProject.minSdkVersion
+        targetSdkVersion rootProject.targetSdkVersion
         versionName "4.9.1"
 
         vectorDrawables.generatedDensities = ['mdpi', 'hdpi', 'xhdpi', 'xxhdpi']
diff --git a/TMessagesProj/proguard-rules.pro b/TMessagesProj/proguard-rules.pro
index 09d2a0672..8e7ae4a9e 100644
--- a/TMessagesProj/proguard-rules.pro
+++ b/TMessagesProj/proguard-rules.pro
@@ -16,4 +16,11 @@
 -dontwarn com.googlecode.mp4parser.**
 # Use -keep to explicitly keep any other classes shrinking would remove
 -dontoptimize
--dontobfuscate
\ No newline at end of file
+-dontobfuscate
+-dontwarn sun.misc.Unsafe
+-dontwarn javax.annotation.**
+-dontwarn org.jaxen.**
+-dontwarn org.conscrypt.**
+-dontwarn javax.xml.stream.**
+-dontwarn org.slf4j.**
+-keep class com.rometools.** { *; }
\ No newline at end of file
diff --git a/TMessagesProj/src/main/AndroidManifest.xml b/TMessagesProj/src/main/AndroidManifest.xml
index d93057d41..6308c4623 100644
--- a/TMessagesProj/src/main/AndroidManifest.xml
+++ b/TMessagesProj/src/main/AndroidManifest.xml
@@ -308,6 +308,11 @@
             </intent-filter>
         </service>
 
+        <service android:name="io.bettergram.service.NewsDataService"/>
+        <service android:name="io.bettergram.service.YoutubeDataService"/>
+        <service android:name="io.bettergram.service.CryptoDataService"/>
+        <service android:name="io.bettergram.service.ResourcesDataService"/>
+
         <receiver android:name="org.telegram.messenger.MusicPlayerReceiver">
             <intent-filter>
                 <action android:name="org.telegram.android.musicplayer.close"/>
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrency.java b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrency.java
new file mode 100644
index 000000000..150ac6201
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrency.java
@@ -0,0 +1,16 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class CryptoCurrency {
+    @JsonField(fieldName = "code")
+    public String code;
+    @JsonField(fieldName = "name")
+    public String name;
+    @JsonField(fieldName = "url")
+    public String url;
+    @JsonField(fieldName = "icon")
+    public String icon;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyData.java b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyData.java
new file mode 100644
index 000000000..6e117055e
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyData.java
@@ -0,0 +1,14 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+import java.util.List;
+
+@JsonType
+public class CryptoCurrencyData {
+    @JsonField(fieldName = "success")
+    public boolean success;
+    @JsonField(fieldName = "data")
+    public List<CryptoCurrency> data;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfo.java b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfo.java
new file mode 100644
index 000000000..c1629b4c4
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfo.java
@@ -0,0 +1,24 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class CryptoCurrencyInfo {
+    @JsonField(fieldName = "name")
+    public String name;
+    @JsonField(fieldName = "code")
+    public String code;
+    @JsonField(fieldName = "volume")
+    public double volume;
+    @JsonField(fieldName = "cap")
+    public double cap;
+    @JsonField(fieldName = "rank")
+    public int rank;
+    @JsonField(fieldName = "price")
+    public double price;
+    @JsonField(fieldName = "delta")
+    public CryptoCurrencyInfoDelta delta;
+    @JsonField(fieldName = "icon")
+    public String icon;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoData.java b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoData.java
new file mode 100644
index 000000000..c90e2b943
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoData.java
@@ -0,0 +1,14 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+import java.util.List;
+
+@JsonType
+public class CryptoCurrencyInfoData {
+    @JsonField(fieldName = "list")
+    public List<CryptoCurrencyInfo> list;
+    @JsonField(fieldName = "favorites")
+    public List<CryptoCurrencyInfo> favorites;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoDelta.java b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoDelta.java
new file mode 100644
index 000000000..4060e376b
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoDelta.java
@@ -0,0 +1,20 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class CryptoCurrencyInfoDelta {
+    @JsonField(fieldName = "second")
+    public double second;
+    @JsonField(fieldName = "minute")
+    public double minute;
+    @JsonField(fieldName = "hour")
+    public double hour;
+    @JsonField(fieldName = "day")
+    public double day;
+    @JsonField(fieldName = "week")
+    public double week;
+    @JsonField(fieldName = "month")
+    public double month;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoResponse.java b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoResponse.java
new file mode 100644
index 000000000..f97159dfe
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/CryptoCurrencyInfoResponse.java
@@ -0,0 +1,30 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class CryptoCurrencyInfoResponse {
+    @JsonField(fieldName = "success")
+    public boolean success;
+    @JsonField(fieldName = "cap")
+    public double cap;
+    @JsonField(fieldName = "volume")
+    public double volume;
+    @JsonField(fieldName = "btcDominance")
+    public double btcDominance;
+    @JsonField(fieldName = "sort")
+    public String sort;
+    @JsonField(fieldName = "order")
+    public String order;
+    @JsonField(fieldName = "offset")
+    public int offset;
+    @JsonField(fieldName = "limit")
+    public int limit;
+    @JsonField(fieldName = "currency")
+    public String currency;
+    @JsonField(fieldName = "total")
+    public int total;
+    @JsonField(fieldName = "data")
+    public CryptoCurrencyInfoData data;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/News.java b/TMessagesProj/src/main/java/io/bettergram/data/News.java
new file mode 100644
index 000000000..956b5d359
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/News.java
@@ -0,0 +1,24 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class News {
+
+  @JsonField(fieldName = "source")
+  public Source source;
+
+  @JsonField(fieldName = "title")
+  public String title;
+
+  @JsonField(fieldName = "url")
+  public String url;
+
+  @JsonField(fieldName = "urlToImage")
+  public String urlToImage;
+
+  @JsonField(fieldName = "publishedAt")
+  public String publishedAt;
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/NewsData.java b/TMessagesProj/src/main/java/io/bettergram/data/NewsData.java
new file mode 100644
index 000000000..15516d7db
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/NewsData.java
@@ -0,0 +1,15 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import java.util.List;
+
+@JsonType
+public class NewsData {
+
+  @JsonField(fieldName = "success")
+  public boolean success;
+
+  @JsonField(fieldName = "news")
+  public List<String> news;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/NewsList.java b/TMessagesProj/src/main/java/io/bettergram/data/NewsList.java
new file mode 100644
index 000000000..2a86080c0
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/NewsList.java
@@ -0,0 +1,13 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import java.util.List;
+
+@JsonType
+public class NewsList {
+
+  @JsonField(fieldName = "articles")
+  public List<News> articles;
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/ResourceGroup.java b/TMessagesProj/src/main/java/io/bettergram/data/ResourceGroup.java
new file mode 100644
index 000000000..0db21024e
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/ResourceGroup.java
@@ -0,0 +1,14 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+import java.util.List;
+
+@JsonType
+public class ResourceGroup {
+    @JsonField(fieldName = "title")
+    public String title;
+    @JsonField(fieldName = "items")
+    public List<ResourceItem> items;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/ResourceItem.java b/TMessagesProj/src/main/java/io/bettergram/data/ResourceItem.java
new file mode 100644
index 000000000..fbf7d7a49
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/ResourceItem.java
@@ -0,0 +1,20 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class ResourceItem {
+    @JsonField(fieldName = "title")
+    public String title;
+    @JsonField(fieldName = "description")
+    public String description;
+    @JsonField(fieldName = "url")
+    public String url;
+    @JsonField(fieldName = "iconUrl")
+    public String iconUrl;
+
+    public String thumbnail() {
+        return iconUrl.replace("s=460&v=4", "s=84&v=4");
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/Resources.java b/TMessagesProj/src/main/java/io/bettergram/data/Resources.java
new file mode 100644
index 000000000..9c7930a1d
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/Resources.java
@@ -0,0 +1,12 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+import java.util.List;
+
+@JsonType
+public class Resources {
+    @JsonField(fieldName = "groups")
+    public List<ResourceGroup> groups;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/ResourcesData.java b/TMessagesProj/src/main/java/io/bettergram/data/ResourcesData.java
new file mode 100644
index 000000000..950eacbdf
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/ResourcesData.java
@@ -0,0 +1,12 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class ResourcesData {
+    @JsonField(fieldName = "success")
+    public boolean success;
+    @JsonField(fieldName = "resources")
+    public Resources resources;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/Source.java b/TMessagesProj/src/main/java/io/bettergram/data/Source.java
new file mode 100644
index 000000000..b59ccd995
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/Source.java
@@ -0,0 +1,15 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class Source {
+
+  @JsonField(fieldName = "id")
+  public String id;
+
+  @JsonField(fieldName = "name")
+  public String name;
+
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/Video.java b/TMessagesProj/src/main/java/io/bettergram/data/Video.java
new file mode 100644
index 000000000..e185e53e4
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/Video.java
@@ -0,0 +1,26 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class Video {
+
+  @JsonField(fieldName = "id")
+  public String id;
+
+  @JsonField(fieldName = "channelTitle")
+  public String channelTitle;
+
+  @JsonField(fieldName = "title")
+  public String title;
+
+  @JsonField(fieldName = "viewCount")
+  public String viewCount;
+
+  @JsonField(fieldName = "duration")
+  public String duration;
+
+  @JsonField(fieldName = "publishedAt")
+  public String publishedAt;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/VideoData.java b/TMessagesProj/src/main/java/io/bettergram/data/VideoData.java
new file mode 100644
index 000000000..a04e61677
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/VideoData.java
@@ -0,0 +1,12 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import java.util.List;
+
+@JsonType
+public class VideoData {
+
+  @JsonField(fieldName = "videos")
+  public List<String> videos;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/data/VideoList.java b/TMessagesProj/src/main/java/io/bettergram/data/VideoList.java
new file mode 100644
index 000000000..ac5c10e91
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/data/VideoList.java
@@ -0,0 +1,13 @@
+package io.bettergram.data;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import java.util.List;
+
+@JsonType
+public class VideoList {
+
+  @JsonField(fieldName = "videos")
+  public List<Video> videos;
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/BaseDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/BaseDataService.java
new file mode 100644
index 000000000..1fd0f78da
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/BaseDataService.java
@@ -0,0 +1,26 @@
+package io.bettergram.service;
+
+import android.annotation.SuppressLint;
+import android.app.IntentService;
+import android.content.Intent;
+import android.support.annotation.Nullable;
+
+@SuppressLint("Registered")
+public class BaseDataService extends IntentService {
+
+    public BaseDataService(String name) {
+        super(name);
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable Intent intent) {
+
+    }
+
+    protected void publishResults(String jsonResult, String action, String extraKey) {
+        Intent intent = new Intent(action);
+        intent.putExtra(extraKey, jsonResult);
+        sendBroadcast(intent);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
new file mode 100644
index 000000000..20401d2ff
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
@@ -0,0 +1,171 @@
+package io.bettergram.service;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.support.annotation.Nullable;
+import io.bettergram.data.*;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+import java.io.IOException;
+import java.util.*;
+
+import static android.text.TextUtils.isEmpty;
+
+public class CryptoDataService extends BaseDataService {
+
+    public static final String CRYPTO_PREF = "CRYPTO_PREF";
+    public static final String KEY_CRYPTO_CURRENCIES = "KEY_CRYPTO_CURRENCIES";
+
+    public static final String EXTRA_FETCH_CRYPTO_CURRENCIES = "EXTRA_FETCH_CRYPTO_CURRENCIES";
+    public static final String EXTRA_SORT_BY = "EXTRA_SORT_BY";
+    public static final String EXTRA_ORDER_BY = "EXTRA_ORDER_BY";
+    public static final String EXTRA_OFFSET = "EXTRA_OFFSET";
+    public static final String EXTRA_LIMIT = "EXTRA_LIMIT";
+    public static final String EXTRA_FAVORITE = "EXTRA_FAVORITE";
+    public static final String EXTRA__CURRENCY = "EXTRA__CURRENCY";
+
+    public static final String RESULT = "result";
+    public static final String NOTIFICATION = "io.bettergram.service.CryptoDataService";
+
+    public static final String CRYPTO_CURRENCIES_URL = "https://http-api.livecoinwatch.com/currencies";
+    public static final String CRYPTO_COINS_URL = "https://http-api.livecoinwatch.com/bettergram/coins";
+
+    public static final int notify = 60000;
+    private Timer mTimer = null;
+
+    private SharedPreferences pref;
+
+    public CryptoDataService() {
+        super("CryptoDataService");
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable Intent intent) {
+        if (mTimer != null) // Cancel if already existed
+            mTimer.cancel();
+        else
+            mTimer = new Timer();   //recreate new
+        mTimer.scheduleAtFixedRate(new TimeDisplay(intent), 0, notify);   //Schedule task
+    }
+
+    private List<CryptoCurrencyInfo> addIcons(List<CryptoCurrencyInfo> list, List<CryptoCurrency> currencies) {
+        for (int i = 0, size = list.size(); i < size; i++) {
+            final int index = i;
+
+            CryptoCurrency foundCurrency = CollectionUtil.find(currencies, (CryptoCurrency item) -> list.get(index).code.equals(item.code));
+
+            if (foundCurrency != null) {
+                list.get(index).icon = foundCurrency.icon;
+                list.get(index).name = foundCurrency.name;
+            }
+        }
+        return list;
+    }
+
+    interface Predicate<T> {
+        boolean contains(T item);
+    }
+
+    static class CollectionUtil {
+
+        public static <T> T find(final Collection<T> collection, final Predicate<T> predicate) {
+            for (T item : collection) {
+                if (predicate.contains(item)) {
+                    return item;
+                }
+            }
+            return null;
+        }
+    }
+
+    //class TimeDisplay for handling task
+    class TimeDisplay extends TimerTask {
+
+        Intent intent;
+
+        TimeDisplay(Intent intent) {
+            this.intent = intent;
+        }
+
+        @Override
+        public void run() {
+            pref = getSharedPreferences(CRYPTO_PREF, Context.MODE_PRIVATE);
+
+            boolean fetchCryptoCurrencies = intent.getBooleanExtra(KEY_CRYPTO_CURRENCIES, false);
+
+            String savedCryptoJson = pref.getString(KEY_CRYPTO_CURRENCIES, null);
+
+            List<CryptoCurrency> currencies = new ArrayList<>();
+
+            OkHttpClient client = new OkHttpClient();
+
+            if (fetchCryptoCurrencies || isEmpty(savedCryptoJson)) {
+
+                Request request = new Request.Builder().url(CRYPTO_CURRENCIES_URL).build();
+
+                try {
+                    Response response = client.newCall(request).execute();
+
+                    if (response.isSuccessful() && response.body() != null) {
+                        String fetchedCryptoJson = response.body().string();
+                        pref.edit().putString(KEY_CRYPTO_CURRENCIES, fetchedCryptoJson).apply();
+                        savedCryptoJson = fetchedCryptoJson;
+                    }
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            try {
+                CryptoCurrencyData currencyData = CryptoCurrencyData__JsonHelper.parseFromJson(savedCryptoJson);
+                currencies.addAll(currencyData.data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+
+            String sortBy = intent.getStringExtra(EXTRA_SORT_BY);
+            String orderBy = intent.getStringExtra(EXTRA_ORDER_BY);
+            int offset = intent.getIntExtra(EXTRA_OFFSET, 0);
+            int limit = intent.getIntExtra(EXTRA_LIMIT, 10);
+            String favorites = intent.getStringExtra(EXTRA_FAVORITE);
+            String currency = intent.getStringExtra(EXTRA__CURRENCY);
+
+            HttpUrl.Builder urlBuilder = Objects.requireNonNull(HttpUrl.parse(CRYPTO_COINS_URL)).newBuilder();
+            urlBuilder.addQueryParameter("sort", !isEmpty(sortBy) ? sortBy : "rank");
+            urlBuilder.addQueryParameter("order", !isEmpty(orderBy) ? orderBy : "ascending");
+            urlBuilder.addQueryParameter("offset", String.valueOf(offset));
+            urlBuilder.addQueryParameter("limit", String.valueOf(limit));
+            urlBuilder.addQueryParameter("favorites", !isEmpty(favorites) ? favorites : String.valueOf(false));
+            urlBuilder.addQueryParameter("currency", currency);
+
+            String url = urlBuilder.build().toString();
+
+            Request request = new Request.Builder().url(url).build();
+
+            try {
+                Response response = client.newCall(request).execute();
+
+                if (response.isSuccessful() && response.body() != null) {
+                    String fetchedCurrencyJson = response.body().string();
+                    CryptoCurrencyInfoResponse cryptoResponse = CryptoCurrencyInfoResponse__JsonHelper.parseFromJson(fetchedCurrencyJson);
+                    cryptoResponse.data.favorites = addIcons(cryptoResponse.data.favorites, currencies);
+                    cryptoResponse.data.list = addIcons(cryptoResponse.data.list, currencies);
+                    String json = CryptoCurrencyInfoResponse__JsonHelper.serializeToJson(cryptoResponse);
+
+                    publishResults(json, NOTIFICATION, RESULT);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java
new file mode 100644
index 000000000..388246216
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java
@@ -0,0 +1,167 @@
+package io.bettergram.service;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import com.rometools.rome.feed.synd.SyndEntry;
+import com.rometools.rome.feed.synd.SyndFeed;
+import com.rometools.rome.io.FeedException;
+import com.rometools.rome.io.SyndFeedInput;
+import com.rometools.rome.io.XmlReader;
+import io.bettergram.data.*;
+import io.bettergram.service.api.NewsApi;
+import io.bettergram.utils.io.IOUtils;
+import org.json.JSONException;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import org.jsoup.select.Elements;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static android.text.TextUtils.isEmpty;
+import static io.bettergram.utils.AeSimpleSHA1.SHA1;
+
+public class NewsDataService extends BaseDataService {
+
+    private static final String TAG = NewsDataService.class.getName();
+
+    public static final String NEWS_PREF = "NEWS_PREF";
+
+    public static final String KEY_FEED_XML = "KEY_FEED_XML";
+
+    public static final String KEY_SAVED_LIST = "KEY_SAVED_LIST";
+
+    public static final String RESULT = "result";
+
+    public static final String NOTIFICATION = "io.bettergram.service.NewsDataService";
+
+    private SharedPreferences pref;
+
+    public NewsDataService() {
+        super("NewsDataService");
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+
+        pref = getSharedPreferences(NEWS_PREF, Context.MODE_PRIVATE);
+
+        String jsonRaw = pref.getString(KEY_SAVED_LIST, null);
+        if (!isEmpty(jsonRaw)) {
+            publishResults(jsonRaw, NOTIFICATION, RESULT);
+        }
+
+        List<News> articles = new ArrayList<>();
+
+        try {
+            String json = NewsApi.getNewsQuietly();
+
+            NewsData data = NewsData__JsonHelper.parseFromJson(json);
+
+            for (int i = 0, size_i = data.news.size(); i < size_i; i++) {
+
+                String url = data.news.get(i);
+                HttpURLConnection urlConnection = (HttpURLConnection) new URL(url).openConnection();
+                urlConnection.setRequestProperty("User-Agent", "ROME");
+                urlConnection.connect();
+                InputStream in = urlConnection.getInputStream();
+
+                String urlHash = url;
+                try {
+                    urlHash = SHA1(urlHash);
+                } catch (NoSuchAlgorithmException e) {
+                    e.printStackTrace();
+                }
+                String xmlFetched = IOUtils.toString(in, "UTF-8");
+                String xmlSaved = pref.getString(KEY_FEED_XML + urlHash, null);
+
+                String xmlFinal = null;
+                try {
+                    if (isEmpty(xmlSaved) || !SHA1(xmlFetched).equals(SHA1(xmlSaved))) {
+                        pref.edit().putString(KEY_FEED_XML + urlHash, xmlFetched).apply();
+                        xmlFinal = xmlFetched;
+                    } else {
+                        xmlFinal = xmlSaved;
+                    }
+                } catch (NoSuchAlgorithmException e) {
+                    e.printStackTrace();
+                }
+
+                if (isEmpty(xmlFinal)) break;
+
+                InputStream stream = new ByteArrayInputStream(xmlFinal.getBytes(StandardCharsets.UTF_8));
+
+                SyndFeed feed = new SyndFeedInput().build(new XmlReader(stream, "text/xml"));
+
+                List<News> temp = new ArrayList<>();
+
+                for (int j = 0, size_j = feed.getEntries().size(); j < size_j; j++) {
+                    SyndEntry entry = feed.getEntries().get(j);
+                    News newsItem = new News();
+                    newsItem.title = entry.getTitle();
+
+                    SyndFeed source = entry.getSource();
+
+                    Source newsSource = new Source();
+                    newsSource.name = source != null ? source.getAuthor() : entry.getAuthor();
+                    newsItem.source = newsSource;
+
+                    newsItem.url = entry.getLink();
+                    newsItem.urlToImage = source != null ? source.getImage().getUrl() : null;
+
+                    newsItem.publishedAt = entry.getPublishedDate().toString();
+
+                    temp.add(newsItem);
+                }
+
+                articles.addAll(temp);
+            }
+
+            NewsList newsList = new NewsList();
+            newsList.articles = articles;
+            publishResults(NewsList__JsonHelper.serializeToJson(newsList), NOTIFICATION, RESULT);
+        } catch (IOException | JSONException | FeedException e) {
+            e.printStackTrace();
+        }
+
+        if (!articles.isEmpty()) {
+            for (int i = 0, size = articles.size(); i < size; i++) {
+                try {
+                    if (isEmpty(articles.get(i).urlToImage)) {
+                        Document document = Jsoup.parse(new URL(articles.get(i).url), 10000);
+                        Elements metas = document.head().getElementsByTag("meta");
+                        for (Element meta : metas) {
+                            Elements attribute = meta.getElementsByAttributeValue("property", "og:image");
+                            String content = attribute.attr("content");
+                            if (!isEmpty(content)) {
+                                articles.get(i).urlToImage = content;
+                                break;
+                            }
+                        }
+                    }
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+            NewsList newsList = new NewsList();
+            newsList.articles = articles;
+
+            try {
+                String json = NewsList__JsonHelper.serializeToJson(newsList);
+                pref.edit().putString(KEY_SAVED_LIST, json).apply();
+                publishResults(json, NOTIFICATION, RESULT);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/ResourcesDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/ResourcesDataService.java
new file mode 100644
index 000000000..4a61200e8
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/ResourcesDataService.java
@@ -0,0 +1,28 @@
+package io.bettergram.service;
+
+import android.content.Intent;
+import android.support.annotation.Nullable;
+import io.bettergram.service.api.ResourcesApi;
+import org.json.JSONException;
+
+import java.io.IOException;
+
+public class ResourcesDataService extends BaseDataService {
+
+    public static final String RESULT = "result";
+    public static final String NOTIFICATION = "io.bettergram.service.ResourcesDataService";
+
+    public ResourcesDataService() {
+        super("ResourcesDataService");
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable Intent intent) {
+        try {
+            String json = ResourcesApi.getResourcesQuietly();
+            publishResults(json, NOTIFICATION, RESULT);
+        } catch (IOException | JSONException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/YoutubeDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/YoutubeDataService.java
new file mode 100644
index 000000000..4fd282767
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/YoutubeDataService.java
@@ -0,0 +1,69 @@
+package io.bettergram.service;
+
+import android.content.Intent;
+import android.util.Log;
+import com.rometools.rome.feed.synd.SyndEntry;
+import com.rometools.rome.feed.synd.SyndFeed;
+import com.rometools.rome.io.FeedException;
+import com.rometools.rome.io.SyndFeedInput;
+import com.rometools.rome.io.XmlReader;
+import io.bettergram.data.VideoData;
+import io.bettergram.data.VideoData__JsonHelper;
+import io.bettergram.messenger.R;
+import io.bettergram.service.api.VideosApi;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.net.URL;
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class YoutubeDataService extends BaseDataService {
+
+    private static final String TAG = YoutubeDataService.class.getName();
+
+    public static final String RESULT = "result";
+
+    public static final String NOTIFICATION = "io.bettergram.service.YoutubeDataService";
+
+    private static List<String> videoIds = new ArrayList<>();
+
+    public YoutubeDataService() {
+        super("YoutubeDataService");
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        String apiKey = getString(R.string.youtube_api_key);
+        try {
+            VideoData videoData = VideoData__JsonHelper.parseFromJson(VideosApi.getYoutubeRSSFeed());
+
+            for (String video : videoData.videos) {
+                SyndFeed feed = new SyndFeedInput().build(new XmlReader(new URL(video)));
+                for (SyndEntry entry : feed.getEntries()) {
+                    videoIds.add(entry.getUri().replace("yt:video:", ""));
+                }
+            }
+
+            JSONArray jsonArray = new JSONArray();
+
+            for (String videoId : videoIds) {
+                JSONObject jsonObject = new JSONObject(VideosApi.getDataQuietly(videoId, apiKey));
+                jsonArray.put(jsonObject);
+            }
+
+            JSONObject jsonObject = new JSONObject();
+
+            jsonObject.put("videos", jsonArray);
+            String jsonResult = jsonObject.toString();
+            Log.i(TAG, "json: " + jsonResult);
+
+            publishResults(jsonResult, NOTIFICATION, RESULT);
+        } catch (IOException | JSONException | FeedException | ParseException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/api/NewsApi.java b/TMessagesProj/src/main/java/io/bettergram/service/api/NewsApi.java
new file mode 100644
index 000000000..69a96ff26
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/api/NewsApi.java
@@ -0,0 +1,48 @@
+package io.bettergram.service.api;
+
+import android.annotation.SuppressLint;
+import io.bettergram.utils.io.IOUtils;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+public class NewsApi {
+
+    //@formatter:off
+    @SuppressLint("SimpleDateFormat")
+    private static final SimpleDateFormat FROM_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:SS'Z'");
+    //@formatter:on
+    @SuppressLint("SimpleDateFormat")
+    private static final SimpleDateFormat TO_FORMAT = new SimpleDateFormat("MMM dd, yyyy");
+
+    private static final String LIVE_COIN_WATCH_NEWS_URL = "https://api.bettergram.io/v1/news";
+
+    /**
+     * Gets news related to cryptocurrency
+     */
+    public static String getNewsQuietly() throws IOException, JSONException {
+        URL newsURL = new URL(LIVE_COIN_WATCH_NEWS_URL);
+        JSONObject jsonData = new JSONObject(
+                IOUtils.toString(
+                        newsURL,
+                        Charset.forName("UTF-8")
+                )
+        );
+
+        return jsonData.toString();
+    }
+
+    /**
+     * Gets formatted date
+     */
+    public static String getFormattedDate(String unformattedDate) throws ParseException {
+        Date date = FROM_FORMAT.parse(unformattedDate);
+        return TO_FORMAT.format(date);
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/api/ResourcesApi.java b/TMessagesProj/src/main/java/io/bettergram/service/api/ResourcesApi.java
new file mode 100644
index 000000000..4c3d30770
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/api/ResourcesApi.java
@@ -0,0 +1,26 @@
+package io.bettergram.service.api;
+
+import io.bettergram.utils.io.IOUtils;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.net.URL;
+import java.nio.charset.Charset;
+
+public class ResourcesApi {
+
+    public static final String RESOURCES_BASE_URL = "https://api.bettergram.io/v1/resources";
+
+    public static String getResourcesQuietly() throws IOException, JSONException {
+        URL newsURL = new URL(RESOURCES_BASE_URL);
+        JSONObject jsonData = new JSONObject(
+                IOUtils.toString(
+                        newsURL,
+                        Charset.forName("UTF-8")
+                )
+        );
+
+        return jsonData.toString();
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/api/VideosApi.java b/TMessagesProj/src/main/java/io/bettergram/service/api/VideosApi.java
new file mode 100644
index 000000000..512417bc3
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/service/api/VideosApi.java
@@ -0,0 +1,122 @@
+package io.bettergram.service.api;
+
+import android.annotation.SuppressLint;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import io.bettergram.utils.Counter;
+import io.bettergram.utils.io.IOUtils;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+public class VideosApi {
+
+    @SuppressLint("SimpleDateFormat")
+    private static final SimpleDateFormat DURATION_FORMAT = new SimpleDateFormat("mm:ss");
+    //@formatter:off
+    @SuppressLint("SimpleDateFormat")
+    private static final SimpleDateFormat FROM_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
+    //@formatter:on
+    @SuppressLint("SimpleDateFormat")
+    private static final SimpleDateFormat TO_FORMAT = new SimpleDateFormat("MMM dd, yyyy");
+
+    private static final String YOUTUBE_STATISTICS_URL = "https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics&id=%s&key=%s";
+
+    private static final String LIVE_COIN_WATCH_VIDEO_URL = "https://api.bettergram.io/v1/videos";
+
+    /**
+     * Queries data for specific youtube video
+     */
+    @Nullable
+    public static Map<String, String> getDataQuietly(@NonNull String videoId, String apiKey)
+            throws IOException, JSONException, ParseException {
+        URL statsURL = new URL(String.format(YOUTUBE_STATISTICS_URL, videoId, apiKey));
+        JSONObject jsonData = new JSONObject(
+                IOUtils.toString(
+                        statsURL,
+                        Charset.forName("UTF-8")
+                )
+        );
+
+        Log.i(VideosApi.class.getName(), "json: " + jsonData.toString());
+
+        Map<String, String> data = new HashMap<>();
+
+        JSONArray itemsArray = jsonData.getJSONArray("items");
+        JSONObject item = itemsArray.getJSONObject(0);
+        if (item != null) {
+
+            data.put("id", item.getString("id"));
+
+            JSONObject snippet = item.getJSONObject("snippet");
+            if (snippet != null) {
+
+                String publishedAt = snippet.getString("publishedAt");
+                Date date = FROM_FORMAT.parse(publishedAt);
+                publishedAt = TO_FORMAT.format(date);
+
+                data.put("publishedAt", publishedAt);
+                data.put("title", snippet.getString("title"));
+                data.put("channelTitle", snippet.getString("channelTitle"));
+            }
+
+            JSONObject contentDetails = item.getJSONObject("contentDetails");
+            if (contentDetails != null) {
+                String duration = contentDetails.getString("duration");
+                data.put("duration", formatDuration(duration));
+            }
+
+            JSONObject statistics = item.getJSONObject("statistics");
+            if (statistics != null) {
+                long viewCount = Long.valueOf(statistics.getString("viewCount"));
+                data.put("viewCount", Counter.format(viewCount));
+            }
+        }
+        return data;
+    }
+
+    /**
+     * Gets Youtube RSS
+     */
+    public static String getYoutubeRSSFeed() throws IOException, JSONException {
+        URL statsURL = new URL(LIVE_COIN_WATCH_VIDEO_URL);
+        JSONObject jsonData = new JSONObject(
+                IOUtils.toString(
+                        statsURL,
+                        Charset.forName("UTF-8")
+                )
+        );
+        return jsonData.toString();
+    }
+
+    /**
+     * Formats youtube video duration
+     */
+    @SuppressLint("DefaultLocale")
+    private static String formatDuration(String time) {
+        time = time.substring(2);
+        long duration = 0L;
+        Object[][] indexes = new Object[][]{{"H", 3600}, {"M", 60}, {"S", 1}};
+        for (int i = 0; i < indexes.length; i++) {
+            int index = time.indexOf((String) indexes[i][0]);
+            if (index != -1) {
+                String value = time.substring(0, index);
+                duration += Integer.parseInt(value) * (int) indexes[i][1] * 1000;
+                time = time.substring(value.length() + 1);
+            }
+        }
+        Date date = new Date(duration);
+        return DURATION_FORMAT.format(date);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java
new file mode 100644
index 000000000..ae91b38f8
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java
@@ -0,0 +1,240 @@
+package io.bettergram.ui.adapters;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.content.ContextCompat;
+import android.text.SpannableStringBuilder;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.RelativeSizeSpan;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.sackcentury.shinebuttonlib.ShineButton;
+import com.squareup.picasso.Picasso;
+import io.bettergram.data.CryptoCurrencyInfo;
+import io.bettergram.data.CryptoCurrencyInfoResponse;
+import io.bettergram.data.CryptoCurrencyInfoResponse__JsonHelper;
+import io.bettergram.messenger.R;
+import io.bettergram.service.CryptoDataService;
+import io.bettergram.utils.Number;
+import io.bettergram.utils.SpanBuilder;
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.support.widget.RecyclerView;
+import org.telegram.ui.ActionBar.Theme;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static io.bettergram.service.CryptoDataService.EXTRA_LIMIT;
+
+public class CryptoAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
+
+    /**
+     * Receives data from {@link CryptoDataService}
+     */
+    public BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Bundle bundle = intent.getExtras();
+            if (bundle != null) {
+                new Thread(new JsonRunnable(bundle.getString(CryptoDataService.RESULT))).start();
+            }
+        }
+    };
+
+    /**
+     * Runnable the processes json response
+     */
+    class JsonRunnable implements Runnable {
+
+        String json;
+
+        JsonRunnable(String json) {
+            this.json = json;
+        }
+
+        @Override
+        public void run() {
+            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+            try {
+                CryptoCurrencyInfoResponse cryptoData = CryptoCurrencyInfoResponse__JsonHelper.parseFromJson(json);
+                AndroidUtilities.runOnUIThread(() -> setCryptoData(cryptoData));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    class MainViewHolder extends RecyclerView.ViewHolder {
+
+        ImageView imageCrypto;
+
+        TextView textCryptoName, textCryptoPrice, textDayDelta;
+
+        MainViewHolder(@NonNull View itemView) {
+            super(itemView);
+            imageCrypto = itemView.findViewById(R.id.imageCrypto);
+            textCryptoName = itemView.findViewById(R.id.textCryptoName);
+            textCryptoPrice = itemView.findViewById(R.id.textCryptoPrice);
+            textDayDelta = itemView.findViewById(R.id.textDayDelta);
+
+            Activity activity = (Activity) itemView.getContext();
+            ShineButton star = itemView.findViewById(R.id.star);
+            star.init(activity);
+        }
+    }
+
+    class HeaderViewHolder extends RecyclerView.ViewHolder {
+
+        TextView textCap, textDom, textVol;
+
+        public HeaderViewHolder(View itemView) {
+            super(itemView);
+            textCap = itemView.findViewById(R.id.textCap);
+            textDom = itemView.findViewById(R.id.textDom);
+            textVol = itemView.findViewById(R.id.textVol);
+        }
+    }
+
+    class LabelViewHolder extends RecyclerView.ViewHolder {
+        public LabelViewHolder(View itemView) {
+            super(itemView);
+        }
+    }
+
+    private CryptoCurrencyInfoResponse cryptoData;
+
+    private List<CryptoCurrencyInfo> data = new ArrayList<>();
+
+    public CryptoAdapter() {
+    }
+
+    public void setCryptoData(CryptoCurrencyInfoResponse cryptoData) {
+        if (cryptoData != null) {
+            this.cryptoData = cryptoData;
+            if (cryptoData.data != null && !cryptoData.data.list.isEmpty()) {
+                data.clear();
+                data.addAll(cryptoData.data.favorites);
+                data.addAll(cryptoData.data.list);
+            }
+        }
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        return position == 0 ? 0 : position == 1 ? 1 : 2;
+    }
+
+    @NonNull
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        final Context context = parent.getContext();
+        LayoutInflater inflater = LayoutInflater.from(context);
+        switch (viewType) {
+            case 0:
+                return new HeaderViewHolder(inflater.inflate(R.layout.header_crypto, parent, false));
+            case 1:
+                return new LabelViewHolder(inflater.inflate(R.layout.item_crypto_top, parent, false));
+            case 2:
+                return new MainViewHolder(inflater.inflate(R.layout.item_crypto, parent, false));
+            default:
+                throw new IllegalStateException("Unrecognizable viewType");
+        }
+    }
+
+    @SuppressLint("DefaultLocale")
+    @Override
+    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
+        final Context context = holder.itemView.getContext();
+
+        if (holder instanceof HeaderViewHolder) {
+            HeaderViewHolder header = (HeaderViewHolder) holder;
+            double cap = cryptoData.cap;
+            header.textCap.setText(formatHeaderValue(context, "MARKET CAP($)", Number.truncateNumber(cap)));
+            double dom = cryptoData.btcDominance;
+            header.textDom.setText(formatHeaderValue(context, "BTC DOM.", String.format("%.2f%%", (dom * 100))));
+            double vol = cryptoData.volume;
+            header.textVol.setText(formatHeaderValue(context, "24H VOL($)", Number.truncateNumber(vol)));
+        } else if (holder instanceof LabelViewHolder) {
+
+        } else if (holder instanceof MainViewHolder) {
+            int realPosition = position - 2;
+            CryptoCurrencyInfo info = data.get(realPosition);
+
+            MainViewHolder main = (MainViewHolder) holder;
+            main.textCryptoName.setText(info.name);
+            double price = info.price;
+            boolean isGreaterZero = Math.floor(price) > 0;
+            double deltaMinute = -1 * ((1 - info.delta.minute) * 100);
+            main.textCryptoPrice.setTextColor(deltaMinute > 0 ? Color.parseColor("#ff69bc35") : Color.RED);
+            main.textCryptoPrice.setText(String.format(isGreaterZero ? "$%,.2f" : "$%.4f", price));
+            Picasso.get().load(info.icon).into(main.imageCrypto);
+            double deltaDay = -1 * ((1 - info.delta.day) * 100);
+            main.textDayDelta.setTextColor(deltaDay > 0 ? Color.parseColor("#ff69bc35") : Color.RED);
+            main.textDayDelta.setText(String.format(deltaDay > 0 ? "+%s%%" : "%s%%", Number.truncateNumber(deltaDay)));
+
+            main.textDayDelta.setCompoundDrawablesWithIntrinsicBounds(
+                    null,
+                    null,
+                    deltaDay > 0 ? Theme.crypto_priceUpDrawable : Theme.crypto_priceDownDrawable,
+                    null
+            );
+            main.textDayDelta.setCompoundDrawablePadding(2);
+        }
+    }
+
+    @Override
+    public int getItemCount() {
+        return data.size() + 2;
+    }
+
+    /**
+     * Creates formatted header for price
+     */
+    public SpannableStringBuilder formatHeaderValue(Context context, String s1, String s2) {
+        int grey73 = ContextCompat.getColor(context, R.color.grey73);
+        int grey2c = ContextCompat.getColor(context, R.color.grey2c);
+
+        SpanBuilder spanBuilder = new SpanBuilder();
+        spanBuilder
+                .appendWithLineBreak(s1,
+                        new RelativeSizeSpan(0.7f),
+                        new ForegroundColorSpan(grey73)
+                )
+                .append(s2,
+                        new RelativeSizeSpan(1.2f),
+                        new ForegroundColorSpan(grey2c)
+                );
+        return spanBuilder.build();
+    }
+
+    public void startService(Activity activity) {
+        Intent intent = new Intent(activity, CryptoDataService.class);
+        intent.putExtra(EXTRA_LIMIT, 100);
+        activity.startService(intent);
+    }
+
+    /**
+     * Register {@link BroadcastReceiver} of {@link CryptoDataService}
+     */
+    public void registerReceiver(Activity activity) {
+        activity.registerReceiver(receiver, new IntentFilter(CryptoDataService.NOTIFICATION));
+    }
+
+    /**
+     * Unregister {@link BroadcastReceiver} of {@link CryptoDataService}
+     */
+    public void unregisterReceiver(Activity activity) {
+        activity.unregisterReceiver(receiver);
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/NewsAdapter.java b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/NewsAdapter.java
new file mode 100644
index 000000000..ee5d81f55
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/NewsAdapter.java
@@ -0,0 +1,179 @@
+package io.bettergram.ui.adapters;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.squareup.picasso.Callback;
+import com.squareup.picasso.Picasso;
+import io.bettergram.data.News;
+import io.bettergram.data.NewsList;
+import io.bettergram.data.NewsList__JsonHelper;
+import io.bettergram.messenger.R;
+import io.bettergram.service.NewsDataService;
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.support.widget.RecyclerView;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class NewsAdapter extends RecyclerView.Adapter<NewsAdapter.NewsViewHolder> {
+
+    /**
+     * Receives data from {@link NewsDataService}
+     */
+    public BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Bundle bundle = intent.getExtras();
+            if (bundle != null) {
+                new Thread(new JsonRunnable(bundle.getString(NewsDataService.RESULT))).start();
+            }
+        }
+    };
+
+    /**
+     * Runnable the processes json response
+     */
+    class JsonRunnable implements Runnable {
+
+        String json;
+
+        JsonRunnable(String json) {
+            this.json = json;
+        }
+
+        @Override
+        public void run() {
+            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+            try {
+                NewsList newsList = NewsList__JsonHelper.parseFromJson(json);
+                AndroidUtilities.runOnUIThread(() -> setNewsList(newsList.articles));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private List<News> newsList = new ArrayList<>();
+
+    class NewsViewHolder extends RecyclerView.ViewHolder {
+
+        ImageView imageThumb;
+
+        TextView textTitle, textAccount, textDatePosted;
+
+        NewsViewHolder(View itemView) {
+            super(itemView);
+            imageThumb = itemView.findViewById(R.id.imageThumb);
+            textTitle = itemView.findViewById(R.id.textTitle);
+            textAccount = itemView.findViewById(R.id.textAccount);
+            textDatePosted = itemView.findViewById(R.id.textDatePosted);
+        }
+    }
+
+    public void setNewsList(List<News> newsList) {
+        this.newsList.clear();
+        this.newsList.addAll(newsList);
+        AndroidUtilities.runOnUIThread(this::notifyDataSetChanged);
+    }
+
+    @NonNull
+    @Override
+    public NewsViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int type) {
+        final Context context = parent.getContext();
+        final LayoutInflater inflater = LayoutInflater.from(context);
+
+        final View content = inflater
+                .inflate(type == 1 ? R.layout.item_news_big : R.layout.item_news_small,
+                        parent,
+                        false
+                );
+
+        return new NewsViewHolder(content);
+    }
+
+    @Override
+    public void onBindViewHolder(NewsViewHolder holder, int position) {
+        final News news = newsList.get(position);
+
+        holder.imageThumb.post(() -> {
+            int width = (int) (holder.imageThumb.getMeasuredWidth() * 0.5f);
+            int height = (int) (holder.imageThumb.getMeasuredHeight() * 0.5f);
+
+            if (width > 0 && height > 0) {
+                Picasso.get().load(news.urlToImage).resize(width, height).centerCrop().into(holder.imageThumb, new Callback.EmptyCallback() {
+                    @Override
+                    public void onSuccess() {
+                        holder.imageThumb.requestLayout();
+                    }
+                });
+            } else {
+                Picasso.get().load(news.urlToImage).into(holder.imageThumb, new Callback.EmptyCallback() {
+                    @Override
+                    public void onSuccess() {
+                        holder.imageThumb.requestLayout();
+                    }
+                });
+            }
+        });
+
+        holder.textTitle.setText(news.title);
+        holder.textTitle.setOnClickListener(v -> {
+            Intent browserIntent = new Intent(Intent.ACTION_VIEW);
+            browserIntent.setData(Uri.parse(news.url));
+            v.getContext().startActivity(browserIntent);
+        });
+
+        holder.textAccount.setText(news.source.name);
+
+        //TODO: proper format
+        holder.textDatePosted.setText(news.publishedAt.substring(0, 10));
+//    try {
+//      holder.textDatePosted.setText(NewsApi.getFormattedDate(news.publishedAt));
+//    } catch (ParseException e) {
+//      e.printStackTrace();
+//    }
+
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        return position == 0 ? 1 : 2;
+    }
+
+    @Override
+    public int getItemCount() {
+        return newsList.size();
+    }
+
+    public void startService(Activity activity) {
+        Intent intent = new Intent(activity, NewsDataService.class);
+        activity.startService(intent);
+    }
+
+    /**
+     * Register {@link BroadcastReceiver} of {@link NewsDataService}
+     */
+    public void registerReceiver(Activity activity) {
+        activity.registerReceiver(receiver, new IntentFilter(NewsDataService.NOTIFICATION));
+    }
+
+    /**
+     * Unregister {@link BroadcastReceiver} of {@link NewsDataService}
+     */
+    public void unregisterReceiver(Activity activity) {
+        activity.unregisterReceiver(receiver);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/ResourcesAdapter.java b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/ResourcesAdapter.java
new file mode 100644
index 000000000..3aef39fbf
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/ResourcesAdapter.java
@@ -0,0 +1,196 @@
+package io.bettergram.ui.adapters;
+
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.squareup.picasso.Picasso;
+import io.bettergram.data.ResourceGroup;
+import io.bettergram.data.ResourceItem;
+import io.bettergram.data.ResourcesData;
+import io.bettergram.data.ResourcesData__JsonHelper;
+import io.bettergram.messenger.R;
+import io.bettergram.service.ResourcesDataService;
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.support.widget.RecyclerView;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static android.text.TextUtils.isEmpty;
+
+public class ResourcesAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
+
+    /**
+     * Receives data from {@link ResourcesDataService}
+     */
+    public BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Bundle bundle = intent.getExtras();
+            if (bundle != null) {
+                new Thread(new JsonRunnable(bundle.getString(ResourcesDataService.RESULT))).start();
+            }
+        }
+    };
+
+    /**
+     * Runnable the processes json response
+     */
+    class JsonRunnable implements Runnable {
+
+        String json;
+
+        JsonRunnable(String json) {
+            this.json = json;
+        }
+
+        @Override
+        public void run() {
+            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+            try {
+                ResourcesData data = ResourcesData__JsonHelper.parseFromJson(json);
+                List<Object> objects = new ArrayList<>();
+                for (int i = 0, size_i = data.resources.groups.size(); i < size_i; i++) {
+                    ResourceGroup group = data.resources.groups.get(i);
+                    objects.add(group.title);
+                    for (int j = 0, size_j = group.items.size(); j < size_j; j++) {
+                        objects.add(group.items.get(j));
+                    }
+                }
+                AndroidUtilities.runOnUIThread(() -> setResources(objects));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    class TitleViewHolder extends RecyclerView.ViewHolder {
+        TextView textTitle;
+
+        TitleViewHolder(View itemView) {
+            super(itemView);
+            textTitle = itemView.findViewById(R.id.textTitle);
+        }
+
+    }
+
+    class ContentViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {
+        ImageView imageResource;
+        TextView textName, textDesc;
+        ResourceItem item;
+
+        public void setItem(ResourceItem item) {
+            this.item = item;
+        }
+
+        public ContentViewHolder(View itemView) {
+            super(itemView);
+            itemView.setOnClickListener(this);
+            imageResource = itemView.findViewById(R.id.imageResource);
+            textName = itemView.findViewById(R.id.textName);
+            textDesc = itemView.findViewById(R.id.textDesc);
+        }
+
+        @Override
+        public void onClick(View v) {
+            Log.e("resources", "Point XXX");
+            final Context context = v.getContext();
+            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(item.url));
+            context.startActivity(intent);
+        }
+    }
+
+    private List<Object> objects = new ArrayList<>();
+
+
+    public void setResources(List<Object> objects) {
+        this.objects = objects;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        for (int i = 0, size_i = objects.size(); i < size_i; i++) {
+            if (i == position) {
+                if (objects.get(i) instanceof String) return 0;
+                if (objects.get(i) instanceof ResourceItem) return 1;
+            }
+        }
+        return -1;
+    }
+
+    @Override
+    public int getItemCount() {
+        return objects.size();
+    }
+
+
+    @NonNull
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        LayoutInflater inflater = LayoutInflater.from(parent.getContext());
+        switch (viewType) {
+            case 0:
+                return new TitleViewHolder(inflater.inflate(R.layout.item_resource_header, parent, false));
+            case 1:
+                return new ContentViewHolder(inflater.inflate(R.layout.item_resource_content, parent, false));
+            default:
+                throw new IllegalStateException("Unrecognizable view type");
+        }
+    }
+
+    @Override
+    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
+        int type = getItemViewType(position);
+        switch (type) {
+            case 0:
+                TitleViewHolder tvh = (TitleViewHolder) holder;
+                String title = (String) objects.get(position);
+                tvh.textTitle.setText(title);
+                break;
+            case 1:
+                ContentViewHolder cvh = (ContentViewHolder) holder;
+                ResourceItem item = (ResourceItem) objects.get(position);
+                cvh.setItem(item);
+                if (!isEmpty(item.title) && !isEmpty(item.url) && !isEmpty(item.description)) {
+                    cvh.textName.setText(item.title);
+                    cvh.textDesc.setText(item.description);
+                    Picasso.get().load(item.thumbnail()).into(cvh.imageResource);
+                }
+                break;
+            default:
+                throw new IllegalStateException("Unrecognizable view type");
+        }
+    }
+
+    public void startService(Activity activity) {
+        Intent intent = new Intent(activity, ResourcesDataService.class);
+        activity.startService(intent);
+    }
+
+    /**
+     * Register {@link BroadcastReceiver} of {@link ResourcesDataService}
+     */
+    public void registerReceiver(Activity activity) {
+        activity.registerReceiver(receiver, new IntentFilter(ResourcesDataService.NOTIFICATION));
+    }
+
+    /**
+     * Unregister {@link BroadcastReceiver} of {@link ResourcesDataService}
+     */
+    public void unregisterReceiver(Activity activity) {
+        activity.unregisterReceiver(receiver);
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java
new file mode 100644
index 000000000..8ef00c001
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java
@@ -0,0 +1,181 @@
+package io.bettergram.ui.adapters;
+
+import android.app.Activity;
+import android.app.FragmentManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+import com.flipkart.youtubeview.YouTubePlayerView;
+import com.flipkart.youtubeview.models.ImageLoader;
+import com.squareup.picasso.Picasso;
+import io.bettergram.data.Video;
+import io.bettergram.data.VideoList;
+import io.bettergram.data.VideoList__JsonHelper;
+import io.bettergram.messenger.R;
+import io.bettergram.service.YoutubeDataService;
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.support.widget.RecyclerView;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.flipkart.youtubeview.models.YouTubePlayerType.STRICT_NATIVE;
+
+public class YouTubePlayerAdapter extends RecyclerView.Adapter<YouTubePlayerAdapter.YouTubePlayerViewHolder> {
+
+    /**
+     * Receives data from {@link YoutubeDataService}
+     */
+    public BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Bundle bundle = intent.getExtras();
+            if (bundle != null) {
+                new Thread(new JsonRunnable(bundle.getString(YoutubeDataService.RESULT))).start();
+            }
+        }
+    };
+
+    /**
+     * Runnable the processes json response
+     */
+    class JsonRunnable implements Runnable {
+
+        String json;
+
+        JsonRunnable(String json) {
+            this.json = json;
+        }
+
+        @Override
+        public void run() {
+            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+            try {
+                VideoList videoList = VideoList__JsonHelper.parseFromJson(json);
+                AndroidUtilities.runOnUIThread(() -> setVideos(videoList.videos));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private List<Video> videos = new ArrayList<>();
+    private Context context;
+    private FragmentManager fragmentManager;
+    private int playerType;
+    private String apiKey;
+    private String webviewUrl;
+
+    class YouTubePlayerViewHolder extends RecyclerView.ViewHolder {
+
+        YouTubePlayerView playerView;
+
+        TextView textTitle, textAccount, textDatePosted, textViewCount;
+
+        YouTubePlayerViewHolder(View view) {
+            super(view);
+            playerView = view.findViewById(R.id.youtube_player_view);
+            textTitle = view.findViewById(R.id.textTitle);
+            textAccount = view.findViewById(R.id.textAccount);
+            textDatePosted = view.findViewById(R.id.textDatePosted);
+            textViewCount = view.findViewById(R.id.textViewCount);
+        }
+    }
+
+    private ImageLoader imageLoader = (imageView, url, height, width) -> {
+        Picasso.get().invalidate(url);// temporarily invalidated so the app wont load from memory as it shows blank image
+
+        Picasso.get()
+                .load(url)
+                .resize(width, height)
+                .centerCrop()
+                .placeholder(R.color.grey70)
+                .into(imageView);
+    };
+
+    public void setVideos(List<Video> videos) {
+        if (videos == null || videos.isEmpty()) return;
+        this.videos.clear();
+        this.videos.addAll(videos);
+        notifyDataSetChanged();
+    }
+
+    public YouTubePlayerAdapter(Activity activity) {
+        this.context = activity;
+        this.fragmentManager = activity.getFragmentManager();
+        this.playerType = STRICT_NATIVE;
+        this.apiKey = context.getString(R.string.youtube_api_key);
+        this.webviewUrl = context.getString(R.string.youtube_webview_url);
+        Picasso.get().setLoggingEnabled(true);
+    }
+
+    @Override
+    public int getItemCount() {
+        return videos.size();
+    }
+
+    @NonNull
+    @Override
+    public YouTubePlayerViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        final Context context = parent.getContext();
+        View view = LayoutInflater.from(context).inflate(R.layout.youtube_player, parent, false);
+        return new YouTubePlayerViewHolder(view);
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        return position;
+    }
+
+    @Override
+    public void onBindViewHolder(final YouTubePlayerViewHolder holder, int position) {
+        YouTubePlayerView playerView = holder.playerView;
+        Video video = videos.get(position);
+
+        String videoId = video.id;
+        String title = video.title;
+        String channelTitle = video.channelTitle;
+        String publishedAt = video.publishedAt;
+        String viewCount = video.viewCount;
+        String duration = video.duration;
+
+        holder.textTitle.setText(title);
+        holder.textAccount.setText(channelTitle);
+        holder.textDatePosted.setText(publishedAt);
+        holder.textViewCount.setText(String.format("%s views", viewCount));
+
+        if (!playerView.initted) {
+            playerView.initPlayer(apiKey, videoId, webviewUrl, playerType, null, fragmentManager, imageLoader);
+        } else {
+            playerView.load();
+        }
+    }
+
+    public void startService(Activity activity) {
+        Intent intent = new Intent(activity, YoutubeDataService.class);
+        activity.startService(intent);
+    }
+
+    /**
+     * Register {@link BroadcastReceiver} of {@link YoutubeDataService}
+     */
+    public void registerReceiver(Activity activity) {
+        activity.registerReceiver(receiver, new IntentFilter(YoutubeDataService.NOTIFICATION));
+    }
+
+    /**
+     * Unregister {@link BroadcastReceiver} of {@link YoutubeDataService}
+     */
+    public void unregisterReceiver(Activity activity) {
+        activity.unregisterReceiver(receiver);
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/AeSimpleSHA1.java b/TMessagesProj/src/main/java/io/bettergram/utils/AeSimpleSHA1.java
new file mode 100644
index 000000000..63c9ea385
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/AeSimpleSHA1.java
@@ -0,0 +1,28 @@
+package io.bettergram.utils;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public class AeSimpleSHA1 {
+    private static String convertToHex(byte[] data) {
+        StringBuilder buf = new StringBuilder();
+        for (byte b : data) {
+            int halfbyte = (b >>> 4) & 0x0F;
+            int two_halfs = 0;
+            do {
+                buf.append((0 <= halfbyte) && (halfbyte <= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
+                halfbyte = b & 0x0F;
+            } while (two_halfs++ < 1);
+        }
+        return buf.toString();
+    }
+
+    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        MessageDigest md = MessageDigest.getInstance("SHA-1");
+        byte[] textBytes = text.getBytes("iso-8859-1");
+        md.update(textBytes, 0, textBytes.length);
+        byte[] sha1hash = md.digest();
+        return convertToHex(sha1hash);
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/Counter.java b/TMessagesProj/src/main/java/io/bettergram/utils/Counter.java
new file mode 100644
index 000000000..5f89f703c
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/Counter.java
@@ -0,0 +1,40 @@
+package io.bettergram.utils;
+
+import java.util.Map.Entry;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+public class Counter {
+
+  private static final NavigableMap<Long, String> SUFFIXES = new TreeMap<>();
+
+  static {
+    SUFFIXES.put(1_000L, "k");
+    SUFFIXES.put(1_000_000L, "M");
+    SUFFIXES.put(1_000_000_000L, "G");
+    SUFFIXES.put(1_000_000_000_000L, "T");
+    SUFFIXES.put(1_000_000_000_000_000L, "P");
+    SUFFIXES.put(1_000_000_000_000_000_000L, "E");
+  }
+
+  public static String format(long value) {
+    //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
+    if (value == Long.MIN_VALUE) {
+      return format(Long.MIN_VALUE + 1);
+    }
+    if (value < 0) {
+      return "-" + format(-value);
+    }
+    if (value < 1000) {
+      return Long.toString(value); //deal with easy case
+    }
+
+    Entry<Long, String> e = SUFFIXES.floorEntry(value);
+    Long divideBy = e.getKey();
+    String suffix = e.getValue();
+
+    long truncated = value / (divideBy / 10); //the number part of the output times 10
+    boolean hasDecimal = truncated < 100 && (truncated / 10d) != (truncated / 10);
+    return hasDecimal ? (truncated / 10d) + suffix : (truncated / 10) + suffix;
+  }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/Number.java b/TMessagesProj/src/main/java/io/bettergram/utils/Number.java
new file mode 100644
index 000000000..5f621ee16
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/Number.java
@@ -0,0 +1,17 @@
+package io.bettergram.utils;
+
+import android.annotation.SuppressLint;
+
+public class Number {
+    private static final long MILLION = 1000000L;
+    private static final long BILLION = 1000000000L;
+    private static final long TRILLION = 1000000000000L;
+
+    @SuppressLint("DefaultLocale")
+    public static String truncateNumber(double x) {
+        return x < MILLION ? String.format("%.2f", x) :
+                x < BILLION ? String.format("%.2f ", (x / MILLION)) + "M" :
+                        x < TRILLION ? String.format("%.2f ", (x / BILLION)) + "B" :
+                                String.format("%.2f ", (x / TRILLION)) + "T";
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/SpanBuilder.java b/TMessagesProj/src/main/java/io/bettergram/utils/SpanBuilder.java
new file mode 100644
index 000000000..2ffaa1723
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/SpanBuilder.java
@@ -0,0 +1,70 @@
+package io.bettergram.utils;
+
+import android.text.Spannable;
+import android.text.SpannableStringBuilder;
+import android.text.style.CharacterStyle;
+import java.util.ArrayList;
+import java.util.List;
+
+public class SpanBuilder {
+
+  private class SpanSection {
+
+    private final String text;
+    private final int startIndex;
+    private final CharacterStyle[] styles;
+
+    private SpanSection(String text, int startIndex, CharacterStyle... styles) {
+      this.styles = styles;
+      this.text = text;
+      this.startIndex = startIndex;
+    }
+
+    private void apply(SpannableStringBuilder spanStringBuilder) {
+      if (spanStringBuilder == null) {
+        return;
+      }
+      for (CharacterStyle style : styles) {
+        spanStringBuilder.setSpan(style, startIndex, startIndex + text.length(),
+            Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
+      }
+    }
+  }
+
+  private List<SpanSection> spanSections;
+  private StringBuilder stringBuilder;
+
+  public SpanBuilder() {
+    stringBuilder = new StringBuilder();
+    spanSections = new ArrayList<>();
+  }
+
+  public SpanBuilder append(String text, CharacterStyle... styles) {
+    if (styles != null && styles.length > 0) {
+      spanSections.add(new SpanSection(text, stringBuilder.length(), styles));
+    }
+    stringBuilder.append(text);
+    return this;
+  }
+
+  public SpanBuilder appendWithSpace(String text, CharacterStyle... styles) {
+    return append(text.concat(" "), styles);
+  }
+
+  public SpanBuilder appendWithLineBreak(String text, CharacterStyle... styles) {
+    return append(text.concat("\n"), styles);
+  }
+
+  public SpannableStringBuilder build() {
+    SpannableStringBuilder ssb = new SpannableStringBuilder(stringBuilder.toString());
+    for (SpanSection section : spanSections) {
+      section.apply(ssb);
+    }
+    return ssb;
+  }
+
+  @Override
+  public String toString() {
+    return stringBuilder.toString();
+  }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/io/Charsets.java b/TMessagesProj/src/main/java/io/bettergram/utils/io/Charsets.java
new file mode 100644
index 000000000..257b64814
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/io/Charsets.java
@@ -0,0 +1,189 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.bettergram.utils.io;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+/**
+ * Charsets required of every implementation of the Java platform.
+ * <p>
+ * From the Java documentation <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">
+ * Standard charsets</a>:
+ * <p>
+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult
+ * the release documentation for your implementation to see if any other encodings are supported. Consult the release
+ * documentation for your implementation to see if any other encodings are supported. </cite>
+ * </p>
+ *
+ * <ul>
+ * <li><code>US-ASCII</code><br>
+ * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>
+ * <li><code>ISO-8859-1</code><br>
+ * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>
+ * <li><code>UTF-8</code><br>
+ * Eight-bit Unicode Transformation Format.</li>
+ * <li><code>UTF-16BE</code><br>
+ * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>
+ * <li><code>UTF-16LE</code><br>
+ * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>
+ * <li><code>UTF-16</code><br>
+ * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order
+ * accepted on input, big-endian used on output.)</li>
+ * </ul>
+ *
+ * @version $Id$
+ * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+ * @since 2.3
+ */
+public class Charsets {
+    //
+    // This class should only contain Charset instances for required encodings. This guarantees that it will load
+    // correctly and without delay on all Java platforms.
+    //
+
+    /**
+     * Constructs a sorted map from canonical charset names to charset objects required of every implementation of the
+     * Java platform.
+     * <p>
+     * From the Java documentation <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">
+     * Standard charsets</a>:
+     * </p>
+     *
+     * @return An immutable, case-insensitive map from canonical charset names to charset objects.
+     * @see Charset#availableCharsets()
+     * @since 2.5
+     */
+    public static SortedMap<String, Charset> requiredCharsets() {
+        // maybe cache?
+        final TreeMap<String, Charset> m = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+        m.put(StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1);
+        m.put(StandardCharsets.US_ASCII.name(), StandardCharsets.US_ASCII);
+        m.put(StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16);
+        m.put(StandardCharsets.UTF_16BE.name(), StandardCharsets.UTF_16BE);
+        m.put(StandardCharsets.UTF_16LE.name(), StandardCharsets.UTF_16LE);
+        m.put(StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8);
+        return Collections.unmodifiableSortedMap(m);
+    }
+
+    /**
+     * Returns the given Charset or the default Charset if the given Charset is null.
+     *
+     * @param charset A charset or null.
+     * @return the given Charset or the default Charset if the given Charset is null
+     */
+    public static Charset toCharset(final Charset charset) {
+        return charset == null ? Charset.defaultCharset() : charset;
+    }
+
+    /**
+     * Returns a Charset for the named charset. If the name is null, return the default Charset.
+     *
+     * @param charset The name of the requested charset, may be null.
+     * @return a Charset for the named charset
+     * @throws java.nio.charset.UnsupportedCharsetException If the named charset is unavailable
+     */
+    public static Charset toCharset(final String charset) {
+        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);
+    }
+
+    /**
+     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.
+     * <p>
+     * Every implementation of the Java platform is required to support this character encoding.
+     * </p>
+     *
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
+     */
+    @Deprecated
+    public static final Charset ISO_8859_1 = StandardCharsets.ISO_8859_1;
+
+    /**
+     * <p>
+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.
+     * </p>
+     * <p>
+     * Every implementation of the Java platform is required to support this character encoding.
+     * </p>
+     *
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
+     */
+    @Deprecated
+    public static final Charset US_ASCII = StandardCharsets.US_ASCII;
+
+    /**
+     * <p>
+     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark
+     * (either order accepted on input, big-endian used on output)
+     * </p>
+     * <p>
+     * Every implementation of the Java platform is required to support this character encoding.
+     * </p>
+     *
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
+     */
+    @Deprecated
+    public static final Charset UTF_16 = StandardCharsets.UTF_16;
+
+    /**
+     * <p>
+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.
+     * </p>
+     * <p>
+     * Every implementation of the Java platform is required to support this character encoding.
+     * </p>
+     *
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
+     */
+    @Deprecated
+    public static final Charset UTF_16BE = StandardCharsets.UTF_16BE;
+
+    /**
+     * <p>
+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.
+     * </p>
+     * <p>
+     * Every implementation of the Java platform is required to support this character encoding.
+     * </p>
+     *
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
+     */
+    @Deprecated
+    public static final Charset UTF_16LE = StandardCharsets.UTF_16LE;
+
+    /**
+     * <p>
+     * Eight-bit Unicode Transformation Format.
+     * </p>
+     * <p>
+     * Every implementation of the Java platform is required to support this character encoding.
+     * </p>
+     *
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
+     */
+    @Deprecated
+    public static final Charset UTF_8 = StandardCharsets.UTF_8;
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/io/IOUtils.java b/TMessagesProj/src/main/java/io/bettergram/utils/io/IOUtils.java
new file mode 100644
index 000000000..4742f461c
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/io/IOUtils.java
@@ -0,0 +1,3209 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.bettergram.utils.io;
+
+import io.bettergram.utils.io.output.ByteArrayOutputStream;
+import io.bettergram.utils.io.output.StringBuilderWriter;
+
+import java.io.*;
+import java.net.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.Selector;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * General IO stream manipulation utilities.
+ * <p>
+ * This class provides static utility methods for input/output operations.
+ * <ul>
+ * <li><b>[Deprecated]</b> closeQuietly - these methods close a stream ignoring nulls and exceptions
+ * <li>toXxx/read - these methods read data from a stream
+ * <li>write - these methods write data to a stream
+ * <li>copy - these methods copy all the data from one stream to another
+ * <li>contentEquals - these methods compare the content of two streams
+ * </ul>
+ * <p>
+ * The byte-to-char methods and char-to-byte methods involve a conversion step.
+ * Two methods are provided in each case, one that uses the platform default
+ * encoding and the other which allows you to specify an encoding. You are
+ * encouraged to always specify an encoding because relying on the platform
+ * default can lead to unexpected results, for example when moving from
+ * development to production.
+ * <p>
+ * All the methods in this class that read a stream are buffered internally.
+ * This means that there is no cause to use a <code>BufferedInputStream</code>
+ * or <code>BufferedReader</code>. The default buffer size of 4K has been shown
+ * to be efficient in tests.
+ * <p>
+ * The various copy methods all delegate the actual copying to one of the following methods:
+ * <ul>
+ * <li>{@link #copyLarge(InputStream, OutputStream, byte[])}</li>
+ * <li>{@link #copyLarge(InputStream, OutputStream, long, long, byte[])}</li>
+ * <li>{@link #copyLarge(Reader, Writer, char[])}</li>
+ * <li>{@link #copyLarge(Reader, Writer, long, long, char[])}</li>
+ * </ul>
+ * For example, {@link #copy(InputStream, OutputStream)} calls {@link #copyLarge(InputStream, OutputStream)}
+ * which calls {@link #copy(InputStream, OutputStream, int)} which creates the buffer and calls
+ * {@link #copyLarge(InputStream, OutputStream, byte[])}.
+ * <p>
+ * Applications can re-use buffers by using the underlying methods directly.
+ * This may improve performance for applications that need to do a lot of copying.
+ * <p>
+ * Wherever possible, the methods in this class do <em>not</em> flush or close
+ * the stream. This is to avoid making non-portable assumptions about the
+ * streams' origin and further use. Thus the caller is still responsible for
+ * closing streams after use.
+ * <p>
+ * Origin of code: Excalibur.
+ */
+public class IOUtils {
+    // NOTE: This class is focused on InputStream, OutputStream, Reader and
+    // Writer. Each method should take at least one of these as a parameter,
+    // or return one of them.
+
+    /**
+     * Represents the end-of-file (or stream).
+     *
+     * @since 2.5 (made public)
+     */
+    public static final int EOF = -1;
+
+    /**
+     * The Unix directory separator character.
+     */
+    public static final char DIR_SEPARATOR_UNIX = '/';
+    /**
+     * The Windows directory separator character.
+     */
+    public static final char DIR_SEPARATOR_WINDOWS = '\\';
+    /**
+     * The system directory separator character.
+     */
+    public static final char DIR_SEPARATOR = File.separatorChar;
+    /**
+     * The Unix line separator string.
+     */
+    public static final String LINE_SEPARATOR_UNIX = "\n";
+    /**
+     * The Windows line separator string.
+     */
+    public static final String LINE_SEPARATOR_WINDOWS = "\r\n";
+    /**
+     * The system line separator string.
+     */
+    public static final String LINE_SEPARATOR;
+
+    static {
+        // avoid security issues
+        try (final StringBuilderWriter buf = new StringBuilderWriter(4);
+             final PrintWriter out = new PrintWriter(buf)) {
+            out.println();
+            LINE_SEPARATOR = buf.toString();
+        }
+    }
+
+    /**
+     * The default buffer size ({@value}) to use for
+     * {@link #copyLarge(InputStream, OutputStream)}
+     * and
+     * {@link #copyLarge(Reader, Writer)}
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
+
+    /**
+     * The default buffer size to use for the skip() methods.
+     */
+    private static final int SKIP_BUFFER_SIZE = 2048;
+
+    // Allocated in the relevant skip method if necessary.
+    /*
+     * These buffers are static and are shared between threads.
+     * This is possible because the buffers are write-only - the contents are never read.
+     *
+     * N.B. there is no need to synchronize when creating these because:
+     * - we don't care if the buffer is created multiple times (the data is ignored)
+     * - we always use the same size buffer, so if it it is recreated it will still be OK
+     * (if the buffer size were variable, we would need to synch. to ensure some other thread
+     * did not create a smaller one)
+     */
+    private static char[] SKIP_CHAR_BUFFER;
+    private static byte[] SKIP_BYTE_BUFFER;
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public IOUtils() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Closes a URLConnection.
+     *
+     * @param conn the connection to close.
+     * @since 2.4
+     */
+    public static void close(final URLConnection conn) {
+        if (conn instanceof HttpURLConnection) {
+            ((HttpURLConnection) conn).disconnect();
+        }
+    }
+
+    /**
+     * Closes an <code>Reader</code> unconditionally.
+     * <p>
+     * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     *   char[] data = new char[1024];
+     *   Reader in = null;
+     *   try {
+     *       in = new FileReader("foo.txt");
+     *       in.read(data);
+     *       in.close(); //close errors are handled
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(in);
+     *   }
+     * </pre>
+     *
+     * @param input the Reader to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final Reader input) {
+        closeQuietly((Closeable) input);
+    }
+
+    /**
+     * Closes an <code>Writer</code> unconditionally.
+     * <p>
+     * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     *   Writer out = null;
+     *   try {
+     *       out = new StringWriter();
+     *       out.write("Hello World");
+     *       out.close(); //close errors are handled
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(out);
+     *   }
+     * </pre>
+     *
+     * @param output the Writer to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final Writer output) {
+        closeQuietly((Closeable) output);
+    }
+
+    /**
+     * Closes an <code>InputStream</code> unconditionally.
+     * <p>
+     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     *   byte[] data = new byte[1024];
+     *   InputStream in = null;
+     *   try {
+     *       in = new FileInputStream("foo.txt");
+     *       in.read(data);
+     *       in.close(); //close errors are handled
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(in);
+     *   }
+     * </pre>
+     *
+     * @param input the InputStream to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final InputStream input) {
+        closeQuietly((Closeable) input);
+    }
+
+    /**
+     * Closes an <code>OutputStream</code> unconditionally.
+     * <p>
+     * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     * byte[] data = "Hello, World".getBytes();
+     *
+     * OutputStream out = null;
+     * try {
+     *     out = new FileOutputStream("foo.txt");
+     *     out.write(data);
+     *     out.close(); //close errors are handled
+     * } catch (IOException e) {
+     *     // error handling
+     * } finally {
+     *     IOUtils.closeQuietly(out);
+     * }
+     * </pre>
+     *
+     * @param output the OutputStream to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final OutputStream output) {
+        closeQuietly((Closeable) output);
+    }
+
+    /**
+     * Closes a <code>Closeable</code> unconditionally.
+     * <p>
+     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in
+     * finally blocks.
+     * <p>
+     * Example code:
+     * </p>
+     * <pre>
+     * Closeable closeable = null;
+     * try {
+     *     closeable = new FileReader(&quot;foo.txt&quot;);
+     *     // process closeable
+     *     closeable.close();
+     * } catch (Exception e) {
+     *     // error handling
+     * } finally {
+     *     IOUtils.closeQuietly(closeable);
+     * }
+     * </pre>
+     * <p>
+     * Closing all streams:
+     * </p>
+     * <pre>
+     * try {
+     *     return IOUtils.copy(inputStream, outputStream);
+     * } finally {
+     *     IOUtils.closeQuietly(inputStream);
+     *     IOUtils.closeQuietly(outputStream);
+     * }
+     * </pre>
+     *
+     * @param closeable the objects to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @since 2.0
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (final IOException ioe) {
+            // ignore
+        }
+    }
+
+    /**
+     * Closes a <code>Closeable</code> unconditionally.
+     * <p>
+     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.
+     * <p>
+     * This is typically used in finally blocks to ensure that the closeable is closed
+     * even if an Exception was thrown before the normal close statement was reached.
+     * <br>
+     * <b>It should not be used to replace the close statement(s)
+     * which should be present for the non-exceptional case.</b>
+     * <br>
+     * It is only intended to simplify tidying up where normal processing has already failed
+     * and reporting close failure as well is not necessary or useful.
+     * <p>
+     * Example code:
+     * </p>
+     * <pre>
+     * Closeable closeable = null;
+     * try {
+     *     closeable = new FileReader(&quot;foo.txt&quot;);
+     *     // processing using the closeable; may throw an Exception
+     *     closeable.close(); // Normal close - exceptions not ignored
+     * } catch (Exception e) {
+     *     // error handling
+     * } finally {
+     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>
+     * }
+     * </pre>
+     * <p>
+     * Closing all streams:
+     * <br>
+     * <pre>
+     * try {
+     *     return IOUtils.copy(inputStream, outputStream);
+     * } finally {
+     *     IOUtils.closeQuietly(inputStream, outputStream);
+     * }
+     * </pre>
+     *
+     * @param closeables the objects to close, may be null or already closed
+     * @see #closeQuietly(Closeable)
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @since 2.5
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final Closeable... closeables) {
+        if (closeables == null) {
+            return;
+        }
+        for (final Closeable closeable : closeables) {
+            closeQuietly(closeable);
+        }
+    }
+
+    /**
+     * Closes a <code>Socket</code> unconditionally.
+     * <p>
+     * Equivalent to {@link Socket#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     *   Socket socket = null;
+     *   try {
+     *       socket = new Socket("http://www.foo.com/", 80);
+     *       // process socket
+     *       socket.close();
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(socket);
+     *   }
+     * </pre>
+     *
+     * @param sock the Socket to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @since 2.0
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final Socket sock) {
+        if (sock != null) {
+            try {
+                sock.close();
+            } catch (final IOException ioe) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Closes a <code>Selector</code> unconditionally.
+     * <p>
+     * Equivalent to {@link Selector#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     *   Selector selector = null;
+     *   try {
+     *       selector = Selector.open();
+     *       // process socket
+     *
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(selector);
+     *   }
+     * </pre>
+     *
+     * @param selector the Selector to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @since 2.2
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final Selector selector) {
+        if (selector != null) {
+            try {
+                selector.close();
+            } catch (final IOException ioe) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Closes a <code>ServerSocket</code> unconditionally.
+     * <p>
+     * Equivalent to {@link ServerSocket#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p>
+     * Example code:
+     * <pre>
+     *   ServerSocket socket = null;
+     *   try {
+     *       socket = new ServerSocket();
+     *       // process socket
+     *       socket.close();
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(socket);
+     *   }
+     * </pre>
+     *
+     * @param sock the ServerSocket to close, may be null or already closed
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @since 2.2
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final ServerSocket sock) {
+        if (sock != null) {
+            try {
+                sock.close();
+            } catch (final IOException ioe) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Fetches entire contents of an <code>InputStream</code> and represent
+     * same data as result InputStream.
+     * <p>
+     * This method is useful where,
+     * <ul>
+     * <li>Source InputStream is slow.</li>
+     * <li>It has network resources associated, so we cannot keep it open for
+     * long time.</li>
+     * <li>It has network timeout associated.</li>
+     * </ul>
+     * It can be used in favor of {@link #toByteArray(InputStream)}, since it
+     * avoids unnecessary allocation and copy of byte[].<br>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input Stream to be fully buffered.
+     * @return A fully buffered stream.
+     * @throws IOException if an I/O error occurs
+     * @since 2.0
+     */
+    public static InputStream toBufferedInputStream(final InputStream input) throws IOException {
+        return ByteArrayOutputStream.toBufferedInputStream(input);
+    }
+
+    /**
+     * Fetches entire contents of an <code>InputStream</code> and represent
+     * same data as result InputStream.
+     * <p>
+     * This method is useful where,
+     * <ul>
+     * <li>Source InputStream is slow.</li>
+     * <li>It has network resources associated, so we cannot keep it open for
+     * long time.</li>
+     * <li>It has network timeout associated.</li>
+     * </ul>
+     * It can be used in favor of {@link #toByteArray(InputStream)}, since it
+     * avoids unnecessary allocation and copy of byte[].<br>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input Stream to be fully buffered.
+     * @param size  the initial buffer size
+     * @return A fully buffered stream.
+     * @throws IOException if an I/O error occurs
+     * @since 2.5
+     */
+    public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {
+        return ByteArrayOutputStream.toBufferedInputStream(input, size);
+    }
+
+    /**
+     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given
+     * reader.
+     *
+     * @param reader the reader to wrap or return (not null)
+     * @return the given reader or a new {@link BufferedReader} for the given reader
+     * @throws NullPointerException if the input parameter is null
+     * @see #buffer(Reader)
+     * @since 2.2
+     */
+    public static BufferedReader toBufferedReader(final Reader reader) {
+        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
+    }
+
+    /**
+     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given
+     * reader.
+     *
+     * @param reader the reader to wrap or return (not null)
+     * @param size   the buffer size, if a new BufferedReader is created.
+     * @return the given reader or a new {@link BufferedReader} for the given reader
+     * @throws NullPointerException if the input parameter is null
+     * @see #buffer(Reader)
+     * @since 2.5
+     */
+    public static BufferedReader toBufferedReader(final Reader reader, final int size) {
+        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);
+    }
+
+    /**
+     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from
+     * the given reader.
+     *
+     * @param reader the reader to wrap or return (not null)
+     * @return the given reader or a new {@link BufferedReader} for the given reader
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedReader buffer(final Reader reader) {
+        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
+    }
+
+    /**
+     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the
+     * given reader.
+     *
+     * @param reader the reader to wrap or return (not null)
+     * @param size   the buffer size, if a new BufferedReader is created.
+     * @return the given reader or a new {@link BufferedReader} for the given reader
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedReader buffer(final Reader reader, final int size) {
+        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);
+    }
+
+    /**
+     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the
+     * given Writer.
+     *
+     * @param writer the Writer to wrap or return (not null)
+     * @return the given Writer or a new {@link BufferedWriter} for the given Writer
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedWriter buffer(final Writer writer) {
+        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);
+    }
+
+    /**
+     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the
+     * given Writer.
+     *
+     * @param writer the Writer to wrap or return (not null)
+     * @param size   the buffer size, if a new BufferedWriter is created.
+     * @return the given Writer or a new {@link BufferedWriter} for the given Writer
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedWriter buffer(final Writer writer, final int size) {
+        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);
+    }
+
+    /**
+     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a
+     * BufferedOutputStream from the given OutputStream.
+     *
+     * @param outputStream the OutputStream to wrap or return (not null)
+     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedOutputStream buffer(final OutputStream outputStream) {
+        // reject null early on rather than waiting for IO operation to fail
+        if (outputStream == null) { // not checked by BufferedOutputStream
+            throw new NullPointerException();
+        }
+        return outputStream instanceof BufferedOutputStream ?
+                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);
+    }
+
+    /**
+     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a
+     * BufferedOutputStream from the given OutputStream.
+     *
+     * @param outputStream the OutputStream to wrap or return (not null)
+     * @param size         the buffer size, if a new BufferedOutputStream is created.
+     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedOutputStream buffer(final OutputStream outputStream, final int size) {
+        // reject null early on rather than waiting for IO operation to fail
+        if (outputStream == null) { // not checked by BufferedOutputStream
+            throw new NullPointerException();
+        }
+        return outputStream instanceof BufferedOutputStream ?
+                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);
+    }
+
+    /**
+     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a
+     * BufferedInputStream from the given InputStream.
+     *
+     * @param inputStream the InputStream to wrap or return (not null)
+     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedInputStream buffer(final InputStream inputStream) {
+        // reject null early on rather than waiting for IO operation to fail
+        if (inputStream == null) { // not checked by BufferedInputStream
+            throw new NullPointerException();
+        }
+        return inputStream instanceof BufferedInputStream ?
+                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);
+    }
+
+    /**
+     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a
+     * BufferedInputStream from the given InputStream.
+     *
+     * @param inputStream the InputStream to wrap or return (not null)
+     * @param size        the buffer size, if a new BufferedInputStream is created.
+     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream
+     * @throws NullPointerException if the input parameter is null
+     * @since 2.5
+     */
+    public static BufferedInputStream buffer(final InputStream inputStream, final int size) {
+        // reject null early on rather than waiting for IO operation to fail
+        if (inputStream == null) { // not checked by BufferedInputStream
+            throw new NullPointerException();
+        }
+        return inputStream instanceof BufferedInputStream ?
+                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);
+    }
+
+    // read toByteArray
+    //-----------------------------------------------------------------------
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     */
+    public static byte[] toByteArray(final InputStream input) throws IOException {
+        try (final ByteArrayOutputStream output = new ByteArrayOutputStream()) {
+            copy(input, output);
+            return output.toByteArray();
+        }
+    }
+
+    /**
+     * Gets contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * Use this method instead of <code>toByteArray(InputStream)</code>
+     * when <code>InputStream</code> size is known.
+     * <b>NOTE:</b> the method checks that the length can safely be cast to an int without truncation
+     * before using {@link IOUtils#toByteArray(java.io.InputStream, int)} to read into the byte array.
+     * (Arrays can have no more than Integer.MAX_VALUE entries anyway)
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param size  the size of <code>InputStream</code>
+     * @return the requested byte array
+     * @throws IOException              if an I/O error occurs or <code>InputStream</code> size differ from parameter
+     *                                  size
+     * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE
+     * @see IOUtils#toByteArray(java.io.InputStream, int)
+     * @since 2.1
+     */
+    public static byte[] toByteArray(final InputStream input, final long size) throws IOException {
+
+        if (size > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("Size cannot be greater than Integer max value: " + size);
+        }
+
+        return toByteArray(input, (int) size);
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * Use this method instead of <code>toByteArray(InputStream)</code>
+     * when <code>InputStream</code> size is known
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param size  the size of <code>InputStream</code>
+     * @return the requested byte array
+     * @throws IOException              if an I/O error occurs or <code>InputStream</code> size differ from parameter
+     *                                  size
+     * @throws IllegalArgumentException if size is less than zero
+     * @since 2.1
+     */
+    public static byte[] toByteArray(final InputStream input, final int size) throws IOException {
+
+        if (size < 0) {
+            throw new IllegalArgumentException("Size must be equal or greater than zero: " + size);
+        }
+
+        if (size == 0) {
+            return new byte[0];
+        }
+
+        final byte[] data = new byte[size];
+        int offset = 0;
+        int read;
+
+        while (offset < size && (read = input.read(data, offset, size - offset)) != EOF) {
+            offset += read;
+        }
+
+        if (offset != size) {
+            throw new IOException("Unexpected read size. current: " + offset + ", expected: " + size);
+        }
+
+        return data;
+    }
+
+    /**
+     * Gets the contents of a <code>Reader</code> as a <code>byte[]</code>
+     * using the default character encoding of the platform.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @deprecated 2.5 use {@link #toByteArray(Reader, Charset)} instead
+     */
+    @Deprecated
+    public static byte[] toByteArray(final Reader input) throws IOException {
+        return toByteArray(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents of a <code>Reader</code> as a <code>byte[]</code>
+     * using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input    the <code>Reader</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static byte[] toByteArray(final Reader input, final Charset encoding) throws IOException {
+        try (final ByteArrayOutputStream output = new ByteArrayOutputStream()) {
+            copy(input, output, encoding);
+            return output.toByteArray();
+        }
+    }
+
+    /**
+     * Gets the contents of a <code>Reader</code> as a <code>byte[]</code>
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input    the <code>Reader</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested byte array
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static byte[] toByteArray(final Reader input, final String encoding) throws IOException {
+        return toByteArray(input, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents of a <code>String</code> as a <code>byte[]</code>
+     * using the default character encoding of the platform.
+     * <p>
+     * This is the same as {@link String#getBytes()}.
+     *
+     * @param input the <code>String</code> to convert
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs (never occurs)
+     * @deprecated 2.5 Use {@link String#getBytes()} instead
+     */
+    @Deprecated
+    public static byte[] toByteArray(final String input) throws IOException {
+        // make explicit the use of the default charset
+        return input.getBytes(Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents of a <code>URI</code> as a <code>byte[]</code>.
+     *
+     * @param uri the <code>URI</code> to read
+     * @return the requested byte array
+     * @throws NullPointerException if the uri is null
+     * @throws IOException          if an I/O exception occurs
+     * @since 2.4
+     */
+    public static byte[] toByteArray(final URI uri) throws IOException {
+        return IOUtils.toByteArray(uri.toURL());
+    }
+
+    /**
+     * Gets the contents of a <code>URL</code> as a <code>byte[]</code>.
+     *
+     * @param url the <code>URL</code> to read
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O exception occurs
+     * @since 2.4
+     */
+    public static byte[] toByteArray(final URL url) throws IOException {
+        final URLConnection conn = url.openConnection();
+        try {
+            return IOUtils.toByteArray(conn);
+        } finally {
+            close(conn);
+        }
+    }
+
+    /**
+     * Gets the contents of a <code>URLConnection</code> as a <code>byte[]</code>.
+     *
+     * @param urlConn the <code>URLConnection</code> to read
+     * @return the requested byte array
+     * @throws NullPointerException if the urlConn is null
+     * @throws IOException          if an I/O exception occurs
+     * @since 2.4
+     */
+    public static byte[] toByteArray(final URLConnection urlConn) throws IOException {
+        try (InputStream inputStream = urlConn.getInputStream()) {
+            return IOUtils.toByteArray(inputStream);
+        }
+    }
+
+    // read char[]
+    //-----------------------------------------------------------------------
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a character array
+     * using the default character encoding of the platform.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param is the <code>InputStream</code> to read from
+     * @return the requested character array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #toCharArray(InputStream, Charset)} instead
+     */
+    @Deprecated
+    public static char[] toCharArray(final InputStream is) throws IOException {
+        return toCharArray(is, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a character array
+     * using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param is       the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested character array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static char[] toCharArray(final InputStream is, final Charset encoding)
+            throws IOException {
+        final CharArrayWriter output = new CharArrayWriter();
+        copy(is, output, encoding);
+        return output.toCharArray();
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a character array
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param is       the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested character array
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static char[] toCharArray(final InputStream is, final String encoding) throws IOException {
+        return toCharArray(is, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents of a <code>Reader</code> as a character array.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @return the requested character array
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static char[] toCharArray(final Reader input) throws IOException {
+        final CharArrayWriter sw = new CharArrayWriter();
+        copy(input, sw);
+        return sw.toCharArray();
+    }
+
+    // read toString
+    //-----------------------------------------------------------------------
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a String
+     * using the default character encoding of the platform.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @deprecated 2.5 use {@link #toString(InputStream, Charset)} instead
+     */
+    @Deprecated
+    public static String toString(final InputStream input) throws IOException {
+        return toString(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a String
+     * using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * </p>
+     *
+     * @param input    the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static String toString(final InputStream input, final Charset encoding) throws IOException {
+        try (final StringBuilderWriter sw = new StringBuilderWriter()) {
+            copy(input, sw, encoding);
+            return sw.toString();
+        }
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a String
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input    the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     */
+    public static String toString(final InputStream input, final String encoding)
+            throws IOException {
+        return toString(input, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents of a <code>Reader</code> as a String.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     */
+    public static String toString(final Reader input) throws IOException {
+        try (final StringBuilderWriter sw = new StringBuilderWriter()) {
+            copy(input, sw);
+            return sw.toString();
+        }
+    }
+
+    /**
+     * Gets the contents at the given URI.
+     *
+     * @param uri The URI source.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.1
+     * @deprecated 2.5 use {@link #toString(URI, Charset)} instead
+     */
+    @Deprecated
+    public static String toString(final URI uri) throws IOException {
+        return toString(uri, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents at the given URI.
+     *
+     * @param uri      The URI source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.3.
+     */
+    public static String toString(final URI uri, final Charset encoding) throws IOException {
+        return toString(uri.toURL(), Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents at the given URI.
+     *
+     * @param uri      The URI source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException                                  if an I/O exception occurs.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 2.1
+     */
+    public static String toString(final URI uri, final String encoding) throws IOException {
+        return toString(uri, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents at the given URL.
+     *
+     * @param url The URL source.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.1
+     * @deprecated 2.5 use {@link #toString(URL, Charset)} instead
+     */
+    @Deprecated
+    public static String toString(final URL url) throws IOException {
+        return toString(url, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents at the given URL.
+     *
+     * @param url      The URL source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.3
+     */
+    public static String toString(final URL url, final Charset encoding) throws IOException {
+        try (InputStream inputStream = url.openStream()) {
+            return toString(inputStream, encoding);
+        }
+    }
+
+    /**
+     * Gets the contents at the given URL.
+     *
+     * @param url      The URL source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException                                  if an I/O exception occurs.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 2.1
+     */
+    public static String toString(final URL url, final String encoding) throws IOException {
+        return toString(url, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents of a <code>byte[]</code> as a String
+     * using the default character encoding of the platform.
+     *
+     * @param input the byte array to read from
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs (never occurs)
+     * @deprecated 2.5 Use {@link String#String(byte[])} instead
+     */
+    @Deprecated
+    public static String toString(final byte[] input) throws IOException {
+        // make explicit the use of the default charset
+        return new String(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents of a <code>byte[]</code> as a String
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param input    the byte array to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs (never occurs)
+     */
+    public static String toString(final byte[] input, final String encoding) throws IOException {
+        return new String(input, Charsets.toCharset(encoding));
+    }
+
+    // resources
+    //-----------------------------------------------------------------------
+
+    /**
+     * Gets the contents of a classpath resource as a String using the
+     * specified character encoding.
+     *
+     * <p>
+     * It is expected the given <code>name</code> to be absolute. The
+     * behavior is not well-defined otherwise.
+     * </p>
+     *
+     * @param name     name of the desired resource
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws IOException if an I/O error occurs
+     * @since 2.6
+     */
+    public static String resourceToString(final String name, final Charset encoding) throws IOException {
+        return resourceToString(name, encoding, null);
+    }
+
+    /**
+     * Gets the contents of a classpath resource as a String using the
+     * specified character encoding.
+     *
+     * <p>
+     * It is expected the given <code>name</code> to be absolute. The
+     * behavior is not well-defined otherwise.
+     * </p>
+     *
+     * @param name        name of the desired resource
+     * @param encoding    the encoding to use, null means platform default
+     * @param classLoader the class loader that the resolution of the resource is delegated to
+     * @return the requested String
+     * @throws IOException if an I/O error occurs
+     * @since 2.6
+     */
+    public static String resourceToString(final String name, final Charset encoding, final ClassLoader classLoader) throws IOException {
+        return toString(resourceToURL(name, classLoader), encoding);
+    }
+
+    /**
+     * Gets the contents of a classpath resource as a byte array.
+     *
+     * <p>
+     * It is expected the given <code>name</code> to be absolute. The
+     * behavior is not well-defined otherwise.
+     * </p>
+     *
+     * @param name name of the desired resource
+     * @return the requested byte array
+     * @throws IOException if an I/O error occurs
+     * @since 2.6
+     */
+    public static byte[] resourceToByteArray(final String name) throws IOException {
+        return resourceToByteArray(name, null);
+    }
+
+    /**
+     * Gets the contents of a classpath resource as a byte array.
+     *
+     * <p>
+     * It is expected the given <code>name</code> to be absolute. The
+     * behavior is not well-defined otherwise.
+     * </p>
+     *
+     * @param name        name of the desired resource
+     * @param classLoader the class loader that the resolution of the resource is delegated to
+     * @return the requested byte array
+     * @throws IOException if an I/O error occurs
+     * @since 2.6
+     */
+    public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {
+        return toByteArray(resourceToURL(name, classLoader));
+    }
+
+    /**
+     * Gets a URL pointing to the given classpath resource.
+     *
+     * <p>
+     * It is expected the given <code>name</code> to be absolute. The
+     * behavior is not well-defined otherwise.
+     * </p>
+     *
+     * @param name name of the desired resource
+     * @return the requested URL
+     * @throws IOException if an I/O error occurs
+     * @since 2.6
+     */
+    public static URL resourceToURL(final String name) throws IOException {
+        return resourceToURL(name, null);
+    }
+
+    /**
+     * Gets a URL pointing to the given classpath resource.
+     *
+     * <p>
+     * It is expected the given <code>name</code> to be absolute. The
+     * behavior is not well-defined otherwise.
+     * </p>
+     *
+     * @param name        name of the desired resource
+     * @param classLoader the class loader that the resolution of the resource is delegated to
+     * @return the requested URL
+     * @throws IOException if an I/O error occurs
+     * @since 2.6
+     */
+    public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {
+        // What about the thread context class loader?
+        // What about the system class loader?
+        final URL resource = classLoader == null ? IOUtils.class.getResource(name) : classLoader.getResource(name);
+
+        if (resource == null) {
+            throw new IOException("Resource not found: " + name);
+        }
+
+        return resource;
+    }
+
+    // readLines
+    //-----------------------------------------------------------------------
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a list of Strings,
+     * one entry per line, using the default character encoding of the platform.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input the <code>InputStream</code> to read from, not null
+     * @return the list of Strings, never null
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #readLines(InputStream, Charset)} instead
+     */
+    @Deprecated
+    public static List<String> readLines(final InputStream input) throws IOException {
+        return readLines(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a list of Strings,
+     * one entry per line, using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input    the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
+     * @return the list of Strings, never null
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static List<String> readLines(final InputStream input, final Charset encoding) throws IOException {
+        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(encoding));
+        return readLines(reader);
+    }
+
+    /**
+     * Gets the contents of an <code>InputStream</code> as a list of Strings,
+     * one entry per line, using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input    the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
+     * @return the list of Strings, never null
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static List<String> readLines(final InputStream input, final String encoding) throws IOException {
+        return readLines(input, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents of a <code>Reader</code> as a list of Strings,
+     * one entry per line.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from, not null
+     * @return the list of Strings, never null
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static List<String> readLines(final Reader input) throws IOException {
+        final BufferedReader reader = toBufferedReader(input);
+        final List<String> list = new ArrayList<>();
+        String line = reader.readLine();
+        while (line != null) {
+            list.add(line);
+            line = reader.readLine();
+        }
+        return list;
+    }
+
+    // lineIterator
+    //-----------------------------------------------------------------------
+
+    /**
+     * Returns an Iterator for the lines in a <code>Reader</code>.
+     * <p>
+     * <code>LineIterator</code> holds a reference to the open
+     * <code>Reader</code> specified here. When you have finished with the
+     * iterator you should close the reader to free internal resources.
+     * This can be done by closing the reader directly, or by calling
+     * {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}.
+     * <p>
+     * The recommended usage pattern is:
+     * <pre>
+     * try {
+     *   LineIterator it = IOUtils.lineIterator(reader);
+     *   while (it.hasNext()) {
+     *     String line = it.nextLine();
+     *     /// do something with line
+     *   }
+     * } finally {
+     *   IOUtils.closeQuietly(reader);
+     * }
+     * </pre>
+     *
+     * @param reader the <code>Reader</code> to read from, not null
+     * @return an Iterator of the lines in the reader, never null
+     * @throws IllegalArgumentException if the reader is null
+     * @since 1.2
+     */
+    public static LineIterator lineIterator(final Reader reader) {
+        return new LineIterator(reader);
+    }
+
+    /**
+     * Returns an Iterator for the lines in an <code>InputStream</code>, using
+     * the character encoding specified (or default encoding if null).
+     * <p>
+     * <code>LineIterator</code> holds a reference to the open
+     * <code>InputStream</code> specified here. When you have finished with
+     * the iterator you should close the stream to free internal resources.
+     * This can be done by closing the stream directly, or by calling
+     * {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}.
+     * <p>
+     * The recommended usage pattern is:
+     * <pre>
+     * try {
+     *   LineIterator it = IOUtils.lineIterator(stream, charset);
+     *   while (it.hasNext()) {
+     *     String line = it.nextLine();
+     *     /// do something with line
+     *   }
+     * } finally {
+     *   IOUtils.closeQuietly(stream);
+     * }
+     * </pre>
+     *
+     * @param input    the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
+     * @return an Iterator of the lines in the reader, never null
+     * @throws IllegalArgumentException if the input is null
+     * @throws IOException              if an I/O error occurs, such as if the encoding is invalid
+     * @since 2.3
+     */
+    public static LineIterator lineIterator(final InputStream input, final Charset encoding) throws IOException {
+        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(encoding)));
+    }
+
+    /**
+     * Returns an Iterator for the lines in an <code>InputStream</code>, using
+     * the character encoding specified (or default encoding if null).
+     * <p>
+     * <code>LineIterator</code> holds a reference to the open
+     * <code>InputStream</code> specified here. When you have finished with
+     * the iterator you should close the stream to free internal resources.
+     * This can be done by closing the stream directly, or by calling
+     * {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}.
+     * <p>
+     * The recommended usage pattern is:
+     * <pre>
+     * try {
+     *   LineIterator it = IOUtils.lineIterator(stream, "UTF-8");
+     *   while (it.hasNext()) {
+     *     String line = it.nextLine();
+     *     /// do something with line
+     *   }
+     * } finally {
+     *   IOUtils.closeQuietly(stream);
+     * }
+     * </pre>
+     *
+     * @param input    the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
+     * @return an Iterator of the lines in the reader, never null
+     * @throws IllegalArgumentException                     if the input is null
+     * @throws IOException                                  if an I/O error occurs, such as if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.2
+     */
+    public static LineIterator lineIterator(final InputStream input, final String encoding) throws IOException {
+        return lineIterator(input, Charsets.toCharset(encoding));
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Converts the specified CharSequence to an input stream, encoded as bytes
+     * using the default character encoding of the platform.
+     *
+     * @param input the CharSequence to convert
+     * @return an input stream
+     * @since 2.0
+     * @deprecated 2.5 use {@link #toInputStream(CharSequence, Charset)} instead
+     */
+    @Deprecated
+    public static InputStream toInputStream(final CharSequence input) {
+        return toInputStream(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Converts the specified CharSequence to an input stream, encoded as bytes
+     * using the specified character encoding.
+     *
+     * @param input    the CharSequence to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @since 2.3
+     */
+    public static InputStream toInputStream(final CharSequence input, final Charset encoding) {
+        return toInputStream(input.toString(), encoding);
+    }
+
+    /**
+     * Converts the specified CharSequence to an input stream, encoded as bytes
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param input    the CharSequence to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @throws IOException                                  if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 2.0
+     */
+    public static InputStream toInputStream(final CharSequence input, final String encoding) throws IOException {
+        return toInputStream(input, Charsets.toCharset(encoding));
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Converts the specified string to an input stream, encoded as bytes
+     * using the default character encoding of the platform.
+     *
+     * @param input the string to convert
+     * @return an input stream
+     * @since 1.1
+     * @deprecated 2.5 use {@link #toInputStream(String, Charset)} instead
+     */
+    @Deprecated
+    public static InputStream toInputStream(final String input) {
+        return toInputStream(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Converts the specified string to an input stream, encoded as bytes
+     * using the specified character encoding.
+     *
+     * @param input    the string to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @since 2.3
+     */
+    public static InputStream toInputStream(final String input, final Charset encoding) {
+        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(encoding)));
+    }
+
+    /**
+     * Converts the specified string to an input stream, encoded as bytes
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param input    the string to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @throws IOException                                  if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static InputStream toInputStream(final String input, final String encoding) throws IOException {
+        final byte[] bytes = input.getBytes(Charsets.toCharset(encoding));
+        return new ByteArrayInputStream(bytes);
+    }
+
+    // write byte[]
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to an <code>OutputStream</code>.
+     *
+     * @param data   the byte array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(final byte[] data, final OutputStream output)
+            throws IOException {
+        if (data != null) {
+            output.write(data);
+        }
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to an <code>OutputStream</code> using chunked writes.
+     * This is intended for writing very large byte arrays which might otherwise cause excessive
+     * memory usage if the native code has to allocate a copy.
+     *
+     * @param data   the byte array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.5
+     */
+    public static void writeChunked(final byte[] data, final OutputStream output)
+            throws IOException {
+        if (data != null) {
+            int bytes = data.length;
+            int offset = 0;
+            while (bytes > 0) {
+                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);
+                output.write(data, offset, chunk);
+                bytes -= chunk;
+                offset += chunk;
+            }
+        }
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
+     * using the default character encoding of the platform.
+     * <p>
+     * This method uses {@link String#String(byte[])}.
+     *
+     * @param data   the byte array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #write(byte[], Writer, Charset)} instead
+     */
+    @Deprecated
+    public static void write(final byte[] data, final Writer output) throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
+     * using the specified character encoding.
+     * <p>
+     * This method uses {@link String#String(byte[], String)}.
+     *
+     * @param data     the byte array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(final byte[] data, final Writer output, final Charset encoding) throws IOException {
+        if (data != null) {
+            output.write(new String(data, Charsets.toCharset(encoding)));
+        }
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
+     * using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method uses {@link String#String(byte[], String)}.
+     *
+     * @param data     the byte array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static void write(final byte[] data, final Writer output, final String encoding) throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write char[]
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>char[]</code> to a <code>Writer</code>
+     *
+     * @param data   the char array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(final char[] data, final Writer output) throws IOException {
+        if (data != null) {
+            output.write(data);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to a <code>Writer</code> using chunked writes.
+     * This is intended for writing very large byte arrays which might otherwise cause excessive
+     * memory usage if the native code has to allocate a copy.
+     *
+     * @param data   the char array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.5
+     */
+    public static void writeChunked(final char[] data, final Writer output) throws IOException {
+        if (data != null) {
+            int bytes = data.length;
+            int offset = 0;
+            while (bytes > 0) {
+                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);
+                output.write(data, offset, chunk);
+                bytes -= chunk;
+                offset += chunk;
+            }
+        }
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to bytes on an
+     * <code>OutputStream</code>.
+     * <p>
+     * This method uses {@link String#String(char[])} and
+     * {@link String#getBytes()}.
+     *
+     * @param data   the char array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #write(char[], OutputStream, Charset)} instead
+     */
+    @Deprecated
+    public static void write(final char[] data, final OutputStream output)
+            throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * This method uses {@link String#String(char[])} and
+     * {@link String#getBytes(String)}.
+     *
+     * @param data     the char array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(final char[] data, final OutputStream output, final Charset encoding) throws IOException {
+        if (data != null) {
+            output.write(new String(data).getBytes(Charsets.toCharset(encoding)));
+        }
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method uses {@link String#String(char[])} and
+     * {@link String#getBytes(String)}.
+     *
+     * @param data     the char array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @since 1.1
+     */
+    public static void write(final char[] data, final OutputStream output, final String encoding)
+            throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write CharSequence
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to a <code>Writer</code>.
+     *
+     * @param data   the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.0
+     */
+    public static void write(final CharSequence data, final Writer output) throws IOException {
+        if (data != null) {
+            write(data.toString(), output);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform.
+     * <p>
+     * This method uses {@link String#getBytes()}.
+     *
+     * @param data   the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.0
+     * @deprecated 2.5 use {@link #write(CharSequence, OutputStream, Charset)} instead
+     */
+    @Deprecated
+    public static void write(final CharSequence data, final OutputStream output)
+            throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>CharSequence</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(final CharSequence data, final OutputStream output, final Charset encoding)
+            throws IOException {
+        if (data != null) {
+            write(data.toString(), output, encoding);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>CharSequence</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @since 2.0
+     */
+    public static void write(final CharSequence data, final OutputStream output, final String encoding)
+            throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write String
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>String</code> to a <code>Writer</code>.
+     *
+     * @param data   the <code>String</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(final String data, final Writer output) throws IOException {
+        if (data != null) {
+            output.write(data);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform.
+     * <p>
+     * This method uses {@link String#getBytes()}.
+     *
+     * @param data   the <code>String</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #write(String, OutputStream, Charset)} instead
+     */
+    @Deprecated
+    public static void write(final String data, final OutputStream output)
+            throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>String</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(final String data, final OutputStream output, final Charset encoding) throws IOException {
+        if (data != null) {
+            output.write(data.getBytes(Charsets.toCharset(encoding)));
+        }
+    }
+
+    /**
+     * Writes chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>String</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @since 1.1
+     */
+    public static void write(final String data, final OutputStream output, final String encoding)
+            throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write StringBuffer
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>StringBuffer</code> to a <code>Writer</code>.
+     *
+     * @param data   the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated replaced by write(CharSequence, Writer)
+     */
+    @Deprecated
+    public static void write(final StringBuffer data, final Writer output)
+            throws IOException {
+        if (data != null) {
+            output.write(data.toString());
+        }
+    }
+
+    /**
+     * Writes chars from a <code>StringBuffer</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform.
+     * <p>
+     * This method uses {@link String#getBytes()}.
+     *
+     * @param data   the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated replaced by write(CharSequence, OutputStream)
+     */
+    @Deprecated
+    public static void write(final StringBuffer data, final OutputStream output)
+            throws IOException {
+        write(data, output, (String) null);
+    }
+
+    /**
+     * Writes chars from a <code>StringBuffer</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>StringBuffer</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @since 1.1
+     * @deprecated replaced by write(CharSequence, OutputStream, String)
+     */
+    @Deprecated
+    public static void write(final StringBuffer data, final OutputStream output, final String encoding)
+            throws IOException {
+        if (data != null) {
+            output.write(data.toString().getBytes(Charsets.toCharset(encoding)));
+        }
+    }
+
+    // writeLines
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * an <code>OutputStream</code> line by line, using the default character
+     * encoding of the platform and the specified line ending.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output     the <code>OutputStream</code> to write to, not null, not closed
+     * @throws NullPointerException if the output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #writeLines(Collection, String, OutputStream, Charset)} instead
+     */
+    @Deprecated
+    public static void writeLines(final Collection<?> lines, final String lineEnding,
+                                  final OutputStream output) throws IOException {
+        writeLines(lines, lineEnding, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * an <code>OutputStream</code> line by line, using the specified character
+     * encoding and the specified line ending.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output     the <code>OutputStream</code> to write to, not null, not closed
+     * @param encoding   the encoding to use, null means platform default
+     * @throws NullPointerException if the output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output,
+                                  final Charset encoding) throws IOException {
+        if (lines == null) {
+            return;
+        }
+        if (lineEnding == null) {
+            lineEnding = LINE_SEPARATOR;
+        }
+        final Charset cs = Charsets.toCharset(encoding);
+        for (final Object line : lines) {
+            if (line != null) {
+                output.write(line.toString().getBytes(cs));
+            }
+            output.write(lineEnding.getBytes(cs));
+        }
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * an <code>OutputStream</code> line by line, using the specified character
+     * encoding and the specified line ending.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output     the <code>OutputStream</code> to write to, not null, not closed
+     * @param encoding   the encoding to use, null means platform default
+     * @throws NullPointerException                         if the output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static void writeLines(final Collection<?> lines, final String lineEnding,
+                                  final OutputStream output, final String encoding) throws IOException {
+        writeLines(lines, lineEnding, output, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * a <code>Writer</code> line by line, using the specified line ending.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param writer     the <code>Writer</code> to write to, not null, not closed
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static void writeLines(final Collection<?> lines, String lineEnding,
+                                  final Writer writer) throws IOException {
+        if (lines == null) {
+            return;
+        }
+        if (lineEnding == null) {
+            lineEnding = LINE_SEPARATOR;
+        }
+        for (final Object line : lines) {
+            if (line != null) {
+                writer.write(line.toString());
+            }
+            writer.write(lineEnding);
+        }
+    }
+
+    // copy from InputStream
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copies bytes from an <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p>
+     * Large streams (over 2GB) will return a bytes copied value of
+     * <code>-1</code> after the copy has completed since the correct
+     * number of bytes cannot be returned as an int. For large streams
+     * use the <code>copyLarge(InputStream, OutputStream)</code> method.
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @return the number of bytes copied, or -1 if &gt; Integer.MAX_VALUE
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static int copy(final InputStream input, final OutputStream output) throws IOException {
+        final long count = copyLarge(input, output);
+        if (count > Integer.MAX_VALUE) {
+            return -1;
+        }
+        return (int) count;
+    }
+
+    /**
+     * Copies bytes from an <code>InputStream</code> to an <code>OutputStream</code> using an internal buffer of the
+     * given size.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a <code>BufferedInputStream</code>.
+     * <p>
+     *
+     * @param input      the <code>InputStream</code> to read from
+     * @param output     the <code>OutputStream</code> to write to
+     * @param bufferSize the bufferSize used to copy from the input to the output
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.5
+     */
+    public static long copy(final InputStream input, final OutputStream output, final int bufferSize)
+            throws IOException {
+        return copyLarge(input, output, new byte[bufferSize]);
+    }
+
+    /**
+     * Copies bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.3
+     */
+    public static long copyLarge(final InputStream input, final OutputStream output)
+            throws IOException {
+        return copy(input, output, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Copies bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p>
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @param buffer the buffer to use for the copy
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(final InputStream input, final OutputStream output, final byte[] buffer)
+            throws IOException {
+        long count = 0;
+        int n;
+        while (EOF != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    /**
+     * Copies some or all bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input bytes.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * </p>
+     * <p>
+     * Note that the implementation uses {@link #skip(InputStream, long)}.
+     * This means that the method may be considerably less efficient than using the actual skip implementation,
+     * this is done to guarantee that the correct number of characters are skipped.
+     * </p>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input       the <code>InputStream</code> to read from
+     * @param output      the <code>OutputStream</code> to write to
+     * @param inputOffset : number of bytes to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of bytes to copy. -ve means all
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,
+                                 final long length) throws IOException {
+        return copyLarge(input, output, inputOffset, length, new byte[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copies some or all bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input bytes.
+     * <p>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * </p>
+     * <p>
+     * Note that the implementation uses {@link #skip(InputStream, long)}.
+     * This means that the method may be considerably less efficient than using the actual skip implementation,
+     * this is done to guarantee that the correct number of characters are skipped.
+     * </p>
+     *
+     * @param input       the <code>InputStream</code> to read from
+     * @param output      the <code>OutputStream</code> to write to
+     * @param inputOffset : number of bytes to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of bytes to copy. -ve means all
+     * @param buffer      the buffer to use for the copy
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(final InputStream input, final OutputStream output,
+                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {
+        if (inputOffset > 0) {
+            skipFully(input, inputOffset);
+        }
+        if (length == 0) {
+            return 0;
+        }
+        final int bufferLength = buffer.length;
+        int bytesToRead = bufferLength;
+        if (length > 0 && length < bufferLength) {
+            bytesToRead = (int) length;
+        }
+        int read;
+        long totalRead = 0;
+        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {
+            output.write(buffer, 0, read);
+            totalRead += read;
+            if (length > 0) { // only adjust length if not reading to the end
+                // Note the cast must work because buffer.length is an integer
+                bytesToRead = (int) Math.min(length - totalRead, bufferLength);
+            }
+        }
+        return totalRead;
+    }
+
+    /**
+     * Copies bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code> using the default character encoding of the platform.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p>
+     * This method uses {@link InputStreamReader}.
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #copy(InputStream, Writer, Charset)} instead
+     */
+    @Deprecated
+    public static void copy(final InputStream input, final Writer output)
+            throws IOException {
+        copy(input, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Copies bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code> using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p>
+     * This method uses {@link InputStreamReader}.
+     *
+     * @param input         the <code>InputStream</code> to read from
+     * @param output        the <code>Writer</code> to write to
+     * @param inputEncoding the encoding to use for the input stream, null means platform default
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void copy(final InputStream input, final Writer output, final Charset inputEncoding)
+            throws IOException {
+        final InputStreamReader in = new InputStreamReader(input, Charsets.toCharset(inputEncoding));
+        copy(in, output);
+    }
+
+    /**
+     * Copies bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code> using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * This method uses {@link InputStreamReader}.
+     *
+     * @param input         the <code>InputStream</code> to read from
+     * @param output        the <code>Writer</code> to write to
+     * @param inputEncoding the encoding to use for the InputStream, null means platform default
+     * @throws NullPointerException                         if the input or output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static void copy(final InputStream input, final Writer output, final String inputEncoding)
+            throws IOException {
+        copy(input, output, Charsets.toCharset(inputEncoding));
+    }
+
+    // copy from Reader
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copies chars from a <code>Reader</code> to a <code>Writer</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     * Large streams (over 2GB) will return a chars copied value of
+     * <code>-1</code> after the copy has completed since the correct
+     * number of chars cannot be returned as an int. For large streams
+     * use the <code>copyLarge(Reader, Writer)</code> method.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static int copy(final Reader input, final Writer output) throws IOException {
+        final long count = copyLarge(input, output);
+        if (count > Integer.MAX_VALUE) {
+            return -1;
+        }
+        return (int) count;
+    }
+
+    /**
+     * Copies chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.3
+     */
+    public static long copyLarge(final Reader input, final Writer output) throws IOException {
+        return copyLarge(input, output, new char[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copies chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
+     * <p>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @param buffer the buffer to be used for the copy
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(final Reader input, final Writer output, final char[] buffer) throws IOException {
+        long count = 0;
+        int n;
+        while (EOF != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    /**
+     * Copies some or all chars from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input chars.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input       the <code>Reader</code> to read from
+     * @param output      the <code>Writer</code> to write to
+     * @param inputOffset : number of chars to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of chars to copy. -ve means all
+     * @return the number of chars copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length)
+            throws IOException {
+        return copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copies some or all chars from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input chars.
+     * <p>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     *
+     * @param input       the <code>Reader</code> to read from
+     * @param output      the <code>Writer</code> to write to
+     * @param inputOffset : number of chars to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of chars to copy. -ve means all
+     * @param buffer      the buffer to be used for the copy
+     * @return the number of chars copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length,
+                                 final char[] buffer)
+            throws IOException {
+        if (inputOffset > 0) {
+            skipFully(input, inputOffset);
+        }
+        if (length == 0) {
+            return 0;
+        }
+        int bytesToRead = buffer.length;
+        if (length > 0 && length < buffer.length) {
+            bytesToRead = (int) length;
+        }
+        int read;
+        long totalRead = 0;
+        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {
+            output.write(buffer, 0, read);
+            totalRead += read;
+            if (length > 0) { // only adjust length if not reading to the end
+                // Note the cast must work because buffer.length is an integer
+                bytesToRead = (int) Math.min(length - totalRead, buffer.length);
+            }
+        }
+        return totalRead;
+    }
+
+    /**
+     * Copies chars from a <code>Reader</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform, and calling flush.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     * Due to the implementation of OutputStreamWriter, this method performs a
+     * flush.
+     * <p>
+     * This method uses {@link OutputStreamWriter}.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     * @deprecated 2.5 use {@link #copy(Reader, OutputStream, Charset)} instead
+     */
+    @Deprecated
+    public static void copy(final Reader input, final OutputStream output)
+            throws IOException {
+        copy(input, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Copies chars from a <code>Reader</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding, and
+     * calling flush.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * </p>
+     * <p>
+     * Due to the implementation of OutputStreamWriter, this method performs a
+     * flush.
+     * </p>
+     * <p>
+     * This method uses {@link OutputStreamWriter}.
+     * </p>
+     *
+     * @param input          the <code>Reader</code> to read from
+     * @param output         the <code>OutputStream</code> to write to
+     * @param outputEncoding the encoding to use for the OutputStream, null means platform default
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.3
+     */
+    public static void copy(final Reader input, final OutputStream output, final Charset outputEncoding)
+            throws IOException {
+        final OutputStreamWriter out = new OutputStreamWriter(output, Charsets.toCharset(outputEncoding));
+        copy(input, out);
+        // XXX Unless anyone is planning on rewriting OutputStreamWriter,
+        // we have to flush here.
+        out.flush();
+    }
+
+    /**
+     * Copies chars from a <code>Reader</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding, and
+     * calling flush.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p>
+     * Due to the implementation of OutputStreamWriter, this method performs a
+     * flush.
+     * <p>
+     * This method uses {@link OutputStreamWriter}.
+     *
+     * @param input          the <code>Reader</code> to read from
+     * @param output         the <code>OutputStream</code> to write to
+     * @param outputEncoding the encoding to use for the OutputStream, null means platform default
+     * @throws NullPointerException                         if the input or output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
+     * @since 1.1
+     */
+    public static void copy(final Reader input, final OutputStream output, final String outputEncoding)
+            throws IOException {
+        copy(input, output, Charsets.toCharset(outputEncoding));
+    }
+
+    // content equals
+    //-----------------------------------------------------------------------
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or
+     * not.
+     * <p>
+     * This method buffers the input internally using
+     * <code>BufferedInputStream</code> if they are not already buffered.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException          if an I/O error occurs
+     */
+    public static boolean contentEquals(InputStream input1, InputStream input2)
+            throws IOException {
+        if (input1 == input2) {
+            return true;
+        }
+        if (!(input1 instanceof BufferedInputStream)) {
+            input1 = new BufferedInputStream(input1);
+        }
+        if (!(input2 instanceof BufferedInputStream)) {
+            input2 = new BufferedInputStream(input2);
+        }
+
+        int ch = input1.read();
+        while (EOF != ch) {
+            final int ch2 = input2.read();
+            if (ch != ch2) {
+                return false;
+            }
+            ch = input1.read();
+        }
+
+        final int ch2 = input2.read();
+        return ch2 == EOF;
+    }
+
+    /**
+     * Compares the contents of two Readers to determine if they are equal or
+     * not.
+     * <p>
+     * This method buffers the input internally using
+     * <code>BufferedReader</code> if they are not already buffered.
+     *
+     * @param input1 the first reader
+     * @param input2 the second reader
+     * @return true if the content of the readers are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 1.1
+     */
+    public static boolean contentEquals(Reader input1, Reader input2)
+            throws IOException {
+        if (input1 == input2) {
+            return true;
+        }
+
+        input1 = toBufferedReader(input1);
+        input2 = toBufferedReader(input2);
+
+        int ch = input1.read();
+        while (EOF != ch) {
+            final int ch2 = input2.read();
+            if (ch != ch2) {
+                return false;
+            }
+            ch = input1.read();
+        }
+
+        final int ch2 = input2.read();
+        return ch2 == EOF;
+    }
+
+    /**
+     * Compares the contents of two Readers to determine if they are equal or
+     * not, ignoring EOL characters.
+     * <p>
+     * This method buffers the input internally using
+     * <code>BufferedReader</code> if they are not already buffered.
+     *
+     * @param input1 the first reader
+     * @param input2 the second reader
+     * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.2
+     */
+    public static boolean contentEqualsIgnoreEOL(final Reader input1, final Reader input2)
+            throws IOException {
+        if (input1 == input2) {
+            return true;
+        }
+        final BufferedReader br1 = toBufferedReader(input1);
+        final BufferedReader br2 = toBufferedReader(input2);
+
+        String line1 = br1.readLine();
+        String line2 = br2.readLine();
+        while (line1 != null && line2 != null && line1.equals(line2)) {
+            line1 = br1.readLine();
+            line2 = br2.readLine();
+        }
+        return line1 == null ? line2 == null ? true : false : line1.equals(line2);
+    }
+
+    /**
+     * Skips bytes from an input byte stream.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * skip() implementations in subclasses of {@link InputStream}.
+     * <p>
+     * Note that the implementation uses {@link InputStream#read(byte[], int, int)} rather
+     * than delegating to {@link InputStream#skip(long)}.
+     * This means that the method may be considerably less efficient than using the actual skip implementation,
+     * this is done to guarantee that the correct number of bytes are skipped.
+     * </p>
+     *
+     * @param input  byte stream to skip
+     * @param toSkip number of bytes to skip.
+     * @return number of bytes actually skipped.
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @see InputStream#skip(long)
+     * @see <a href="https://issues.apache.org/jira/browse/IO-203">IO-203 - Add skipFully() method for InputStreams</a>
+     * @since 2.0
+     */
+    public static long skip(final InputStream input, final long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);
+        }
+        /*
+         * N.B. no need to synchronize this because: - we don't care if the buffer is created multiple times (the data
+         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer
+         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)
+         */
+        if (SKIP_BYTE_BUFFER == null) {
+            SKIP_BYTE_BUFFER = new byte[SKIP_BUFFER_SIZE];
+        }
+        long remain = toSkip;
+        while (remain > 0) {
+            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()
+            final long n = input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));
+            if (n < 0) { // EOF
+                break;
+            }
+            remain -= n;
+        }
+        return toSkip - remain;
+    }
+
+    /**
+     * Skips bytes from a ReadableByteChannel.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up.
+     *
+     * @param input  ReadableByteChannel to skip
+     * @param toSkip number of bytes to skip.
+     * @return number of bytes actually skipped.
+     * @throws IOException              if there is a problem reading the ReadableByteChannel
+     * @throws IllegalArgumentException if toSkip is negative
+     * @since 2.5
+     */
+    public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);
+        }
+        final ByteBuffer skipByteBuffer = ByteBuffer.allocate((int) Math.min(toSkip, SKIP_BUFFER_SIZE));
+        long remain = toSkip;
+        while (remain > 0) {
+            skipByteBuffer.position(0);
+            skipByteBuffer.limit((int) Math.min(remain, SKIP_BUFFER_SIZE));
+            final int n = input.read(skipByteBuffer);
+            if (n == EOF) {
+                break;
+            }
+            remain -= n;
+        }
+        return toSkip - remain;
+    }
+
+    /**
+     * Skips characters from an input character stream.
+     * This implementation guarantees that it will read as many characters
+     * as possible before giving up; this may not always be the case for
+     * skip() implementations in subclasses of {@link Reader}.
+     * <p>
+     * Note that the implementation uses {@link Reader#read(char[], int, int)} rather
+     * than delegating to {@link Reader#skip(long)}.
+     * This means that the method may be considerably less efficient than using the actual skip implementation,
+     * this is done to guarantee that the correct number of characters are skipped.
+     * </p>
+     *
+     * @param input  character stream to skip
+     * @param toSkip number of characters to skip.
+     * @return number of characters actually skipped.
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @see Reader#skip(long)
+     * @see <a href="https://issues.apache.org/jira/browse/IO-203">IO-203 - Add skipFully() method for InputStreams</a>
+     * @since 2.0
+     */
+    public static long skip(final Reader input, final long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);
+        }
+        /*
+         * N.B. no need to synchronize this because: - we don't care if the buffer is created multiple times (the data
+         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer
+         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)
+         */
+        if (SKIP_CHAR_BUFFER == null) {
+            SKIP_CHAR_BUFFER = new char[SKIP_BUFFER_SIZE];
+        }
+        long remain = toSkip;
+        while (remain > 0) {
+            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()
+            final long n = input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));
+            if (n < 0) { // EOF
+                break;
+            }
+            remain -= n;
+        }
+        return toSkip - remain;
+    }
+
+    /**
+     * Skips the requested number of bytes or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link InputStream#skip(long)} may
+     * not skip as many bytes as requested (most likely because of reaching EOF).
+     * <p>
+     * Note that the implementation uses {@link #skip(InputStream, long)}.
+     * This means that the method may be considerably less efficient than using the actual skip implementation,
+     * this is done to guarantee that the correct number of characters are skipped.
+     * </p>
+     *
+     * @param input  stream to skip
+     * @param toSkip the number of bytes to skip
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @throws EOFException             if the number of bytes skipped was incorrect
+     * @see InputStream#skip(long)
+     * @since 2.0
+     */
+    public static void skipFully(final InputStream input, final long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Bytes to skip must not be negative: " + toSkip);
+        }
+        final long skipped = skip(input, toSkip);
+        if (skipped != toSkip) {
+            throw new EOFException("Bytes to skip: " + toSkip + " actual: " + skipped);
+        }
+    }
+
+    /**
+     * Skips the requested number of bytes or fail if there are not enough left.
+     *
+     * @param input  ReadableByteChannel to skip
+     * @param toSkip the number of bytes to skip
+     * @throws IOException              if there is a problem reading the ReadableByteChannel
+     * @throws IllegalArgumentException if toSkip is negative
+     * @throws EOFException             if the number of bytes skipped was incorrect
+     * @since 2.5
+     */
+    public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Bytes to skip must not be negative: " + toSkip);
+        }
+        final long skipped = skip(input, toSkip);
+        if (skipped != toSkip) {
+            throw new EOFException("Bytes to skip: " + toSkip + " actual: " + skipped);
+        }
+    }
+
+    /**
+     * Skips the requested number of characters or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link Reader#skip(long)} may
+     * not skip as many characters as requested (most likely because of reaching EOF).
+     * <p>
+     * Note that the implementation uses {@link #skip(Reader, long)}.
+     * This means that the method may be considerably less efficient than using the actual skip implementation,
+     * this is done to guarantee that the correct number of characters are skipped.
+     * </p>
+     *
+     * @param input  stream to skip
+     * @param toSkip the number of characters to skip
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @throws EOFException             if the number of characters skipped was incorrect
+     * @see Reader#skip(long)
+     * @since 2.0
+     */
+    public static void skipFully(final Reader input, final long toSkip) throws IOException {
+        final long skipped = skip(input, toSkip);
+        if (skipped != toSkip) {
+            throw new EOFException("Chars to skip: " + toSkip + " actual: " + skipped);
+        }
+    }
+
+
+    /**
+     * Reads characters from an input character stream.
+     * This implementation guarantees that it will read as many characters
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link Reader}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset initial offset into buffer
+     * @param length length to read, must be &gt;= 0
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(final Reader input, final char[] buffer, final int offset, final int length)
+            throws IOException {
+        if (length < 0) {
+            throw new IllegalArgumentException("Length must not be negative: " + length);
+        }
+        int remaining = length;
+        while (remaining > 0) {
+            final int location = length - remaining;
+            final int count = input.read(buffer, offset + location, remaining);
+            if (EOF == count) { // EOF
+                break;
+            }
+            remaining -= count;
+        }
+        return length - remaining;
+    }
+
+    /**
+     * Reads characters from an input character stream.
+     * This implementation guarantees that it will read as many characters
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link Reader}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(final Reader input, final char[] buffer) throws IOException {
+        return read(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Reads bytes from an input stream.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link InputStream}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset initial offset into buffer
+     * @param length length to read, must be &gt;= 0
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)
+            throws IOException {
+        if (length < 0) {
+            throw new IllegalArgumentException("Length must not be negative: " + length);
+        }
+        int remaining = length;
+        while (remaining > 0) {
+            final int location = length - remaining;
+            final int count = input.read(buffer, offset + location, remaining);
+            if (EOF == count) { // EOF
+                break;
+            }
+            remaining -= count;
+        }
+        return length - remaining;
+    }
+
+    /**
+     * Reads bytes from an input stream.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link InputStream}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(final InputStream input, final byte[] buffer) throws IOException {
+        return read(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Reads bytes from a ReadableByteChannel.
+     * <p>
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link ReadableByteChannel}.
+     *
+     * @param input  the byte channel to read
+     * @param buffer byte buffer destination
+     * @return the actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.5
+     */
+    public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {
+        final int length = buffer.remaining();
+        while (buffer.remaining() > 0) {
+            final int count = input.read(buffer);
+            if (EOF == count) { // EOF
+                break;
+            }
+        }
+        return length - buffer.remaining();
+    }
+
+    /**
+     * Reads the requested number of characters or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link Reader#read(char[], int, int)} may
+     * not read as many characters as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset initial offset into buffer
+     * @param length length to read, must be &gt;= 0
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException             if the number of characters read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(final Reader input, final char[] buffer, final int offset, final int length)
+            throws IOException {
+        final int actual = read(input, buffer, offset, length);
+        if (actual != length) {
+            throw new EOFException("Length to read: " + length + " actual: " + actual);
+        }
+    }
+
+    /**
+     * Reads the requested number of characters or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link Reader#read(char[], int, int)} may
+     * not read as many characters as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException             if the number of characters read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(final Reader input, final char[] buffer) throws IOException {
+        readFully(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Reads the requested number of bytes or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
+     * not read as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset initial offset into buffer
+     * @param length length to read, must be &gt;= 0
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException             if the number of bytes read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)
+            throws IOException {
+        final int actual = read(input, buffer, offset, length);
+        if (actual != length) {
+            throw new EOFException("Length to read: " + length + " actual: " + actual);
+        }
+    }
+
+    /**
+     * Reads the requested number of bytes or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
+     * not read as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException             if the number of bytes read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(final InputStream input, final byte[] buffer) throws IOException {
+        readFully(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Reads the requested number of bytes or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
+     * not read as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param length length to read, must be &gt;= 0
+     * @return the bytes read from input
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException             if the number of bytes read was incorrect
+     * @since 2.5
+     */
+    public static byte[] readFully(final InputStream input, final int length) throws IOException {
+        final byte[] buffer = new byte[length];
+        readFully(input, buffer, 0, buffer.length);
+        return buffer;
+    }
+
+    /**
+     * Reads the requested number of bytes or fail if there are not enough left.
+     * <p>
+     * This allows for the possibility that {@link ReadableByteChannel#read(ByteBuffer)} may
+     * not read as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  the byte channel to read
+     * @param buffer byte buffer destination
+     * @throws IOException  if there is a problem reading the file
+     * @throws EOFException if the number of bytes read was incorrect
+     * @since 2.5
+     */
+    public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {
+        final int expected = buffer.remaining();
+        final int actual = read(input, buffer);
+        if (actual != expected) {
+            throw new EOFException("Length to read: " + expected + " actual: " + actual);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/io/LineIterator.java b/TMessagesProj/src/main/java/io/bettergram/utils/io/LineIterator.java
new file mode 100644
index 000000000..ac761e2eb
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/io/LineIterator.java
@@ -0,0 +1,210 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.bettergram.utils.io;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+
+/**
+ * An Iterator over the lines in a <code>Reader</code>.
+ * <p>
+ * <code>LineIterator</code> holds a reference to an open <code>Reader</code>.
+ * When you have finished with the iterator you should close the reader
+ * to free internal resources. This can be done by closing the reader directly,
+ * or by calling the {@link #close()} or {@link #closeQuietly(LineIterator)}
+ * method on the iterator.
+ * <p>
+ * The recommended usage pattern is:
+ * <pre>
+ * LineIterator it = FileUtils.lineIterator(file, "UTF-8");
+ * try {
+ *   while (it.hasNext()) {
+ *     String line = it.nextLine();
+ *     // do something with line
+ *   }
+ * } finally {
+ *   it.close();
+ * }
+ * </pre>
+ *
+ * @since 1.2
+ */
+public class LineIterator implements Iterator<String>, Closeable {
+
+    // N.B. This class deliberately does not implement Iterable, see https://issues.apache.org/jira/browse/IO-181
+
+    /**
+     * The reader that is being read.
+     */
+    private final BufferedReader bufferedReader;
+    /**
+     * The current line.
+     */
+    private String cachedLine;
+    /**
+     * A flag indicating if the iterator has been fully read.
+     */
+    private boolean finished = false;
+
+    /**
+     * Constructs an iterator of the lines for a <code>Reader</code>.
+     *
+     * @param reader the <code>Reader</code> to read from, not null
+     * @throws IllegalArgumentException if the reader is null
+     */
+    public LineIterator(final Reader reader) throws IllegalArgumentException {
+        if (reader == null) {
+            throw new IllegalArgumentException("Reader must not be null");
+        }
+        if (reader instanceof BufferedReader) {
+            bufferedReader = (BufferedReader) reader;
+        } else {
+            bufferedReader = new BufferedReader(reader);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Indicates whether the <code>Reader</code> has more lines.
+     * If there is an <code>IOException</code> then {@link #close()} will
+     * be called on this instance.
+     *
+     * @return {@code true} if the Reader has more lines
+     * @throws IllegalStateException if an IO exception occurs
+     */
+    @Override
+    public boolean hasNext() {
+        if (cachedLine != null) {
+            return true;
+        } else if (finished) {
+            return false;
+        } else {
+            try {
+                while (true) {
+                    final String line = bufferedReader.readLine();
+                    if (line == null) {
+                        finished = true;
+                        return false;
+                    } else if (isValidLine(line)) {
+                        cachedLine = line;
+                        return true;
+                    }
+                }
+            } catch (final IOException ioe) {
+                try {
+                    close();
+                } catch (final IOException e) {
+                    ioe.addSuppressed(e);
+                }
+                throw new IllegalStateException(ioe);
+            }
+        }
+    }
+
+    /**
+     * Overridable method to validate each line that is returned.
+     * This implementation always returns true.
+     *
+     * @param line the line that is to be validated
+     * @return true if valid, false to remove from the iterator
+     */
+    protected boolean isValidLine(final String line) {
+        return true;
+    }
+
+    /**
+     * Returns the next line in the wrapped <code>Reader</code>.
+     *
+     * @return the next line from the input
+     * @throws NoSuchElementException if there is no line to return
+     */
+    @Override
+    public String next() {
+        return nextLine();
+    }
+
+    /**
+     * Returns the next line in the wrapped <code>Reader</code>.
+     *
+     * @return the next line from the input
+     * @throws NoSuchElementException if there is no line to return
+     */
+    public String nextLine() {
+        if (!hasNext()) {
+            throw new NoSuchElementException("No more lines");
+        }
+        final String currentLine = cachedLine;
+        cachedLine = null;
+        return currentLine;
+    }
+
+    /**
+     * Closes the underlying {@code Reader}.
+     * This method is useful if you only want to process the first few
+     * lines of a larger file. If you do not close the iterator
+     * then the {@code Reader} remains open.
+     * This method can safely be called multiple times.
+     *
+     * @throws IOException if closing the underlying {@code Reader} fails.
+     */
+    @Override
+    public void close() throws IOException {
+        finished = true;
+        cachedLine = null;
+        if (this.bufferedReader != null) {
+            this.bufferedReader.close();
+        }
+    }
+
+    /**
+     * Unsupported.
+     *
+     * @throws UnsupportedOperationException always
+     */
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException("Remove unsupported on LineIterator");
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Closes a {@code LineIterator} quietly.
+     *
+     * @param iterator The iterator to close, or {@code null}.
+     * @see Throwable#addSuppressed(java.lang.Throwable)
+     * @deprecated As of 2.6 removed without replacement. Please use the try-with-resources statement or handle
+     * suppressed exceptions manually.
+     */
+    @Deprecated
+    public static void closeQuietly(final LineIterator iterator) {
+        try {
+            if (iterator != null) {
+                iterator.close();
+            }
+        } catch (final IOException e) {
+            // Suppressed.
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/io/input/ClosedInputStream.java b/TMessagesProj/src/main/java/io/bettergram/utils/io/input/ClosedInputStream.java
new file mode 100644
index 000000000..6a4822518
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/io/input/ClosedInputStream.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.bettergram.utils.io.input;
+
+import java.io.InputStream;
+
+import static io.bettergram.utils.io.IOUtils.EOF;
+
+/**
+ * Closed input stream. This stream returns EOF to all attempts to read
+ * something from the stream.
+ * <p>
+ * Typically uses of this class include testing for corner cases in methods
+ * that accept input streams and acting as a sentinel value instead of a
+ * {@code null} input stream.
+ *
+ * @since 1.4
+ */
+public class ClosedInputStream extends InputStream {
+
+    /**
+     * A singleton.
+     */
+    public static final ClosedInputStream CLOSED_INPUT_STREAM = new ClosedInputStream();
+
+    /**
+     * Returns -1 to indicate that the stream is closed.
+     *
+     * @return always -1
+     */
+    @Override
+    public int read() {
+        return EOF;
+    }
+
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/io/output/ByteArrayOutputStream.java b/TMessagesProj/src/main/java/io/bettergram/utils/io/output/ByteArrayOutputStream.java
new file mode 100644
index 000000000..340e84154
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/io/output/ByteArrayOutputStream.java
@@ -0,0 +1,432 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.bettergram.utils.io.output;
+
+import io.bettergram.utils.io.input.ClosedInputStream;
+
+import java.io.*;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static io.bettergram.utils.io.IOUtils.EOF;
+
+/**
+ * This class implements an output stream in which the data is
+ * written into a byte array. The buffer automatically grows as data
+ * is written to it.
+ * <p>
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing a {@code ByteArrayOutputStream} has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an {@code IOException}.
+ * <p>
+ * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}
+ * class. The original implementation only allocates 32 bytes at the beginning.
+ * As this class is designed for heavy duty it starts at 1024 bytes. In contrast
+ * to the original it doesn't reallocate the whole memory block but allocates
+ * additional buffers. This way no buffers need to be garbage collected and
+ * the contents don't have to be copied to the new buffer. This class is
+ * designed to behave exactly like the original. The only exception is the
+ * deprecated toString(int) method that has been ignored.
+ */
+public class ByteArrayOutputStream extends OutputStream {
+
+    static final int DEFAULT_SIZE = 1024;
+
+    /**
+     * A singleton empty byte array.
+     */
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /**
+     * The list of buffers, which grows and never reduces.
+     */
+    private final List<byte[]> buffers = new ArrayList<>();
+    /**
+     * The index of the current buffer.
+     */
+    private int currentBufferIndex;
+    /**
+     * The total count of bytes in all the filled buffers.
+     */
+    private int filledBufferSum;
+    /**
+     * The current buffer.
+     */
+    private byte[] currentBuffer;
+    /**
+     * The total count of bytes written.
+     */
+    private int count;
+    /**
+     * Flag to indicate if the buffers can be reused after reset
+     */
+    private boolean reuseBuffers = true;
+
+    /**
+     * Creates a new byte array output stream. The buffer capacity is
+     * initially 1024 bytes, though its size increases if necessary.
+     */
+    public ByteArrayOutputStream() {
+        this(DEFAULT_SIZE);
+    }
+
+    /**
+     * Creates a new byte array output stream, with a buffer capacity of
+     * the specified size, in bytes.
+     *
+     * @param size the initial size
+     * @throws IllegalArgumentException if size is negative
+     */
+    public ByteArrayOutputStream(final int size) {
+        if (size < 0) {
+            throw new IllegalArgumentException(
+                    "Negative initial size: " + size);
+        }
+        synchronized (this) {
+            needNewBuffer(size);
+        }
+    }
+
+    /**
+     * Makes a new buffer available either by allocating
+     * a new one or re-cycling an existing one.
+     *
+     * @param newcount the size of the buffer if one is created
+     */
+    private void needNewBuffer(final int newcount) {
+        if (currentBufferIndex < buffers.size() - 1) {
+            //Recycling old buffer
+            filledBufferSum += currentBuffer.length;
+
+            currentBufferIndex++;
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Creating new buffer
+            int newBufferSize;
+            if (currentBuffer == null) {
+                newBufferSize = newcount;
+                filledBufferSum = 0;
+            } else {
+                newBufferSize = Math.max(
+                        currentBuffer.length << 1,
+                        newcount - filledBufferSum);
+                filledBufferSum += currentBuffer.length;
+            }
+
+            currentBufferIndex++;
+            currentBuffer = new byte[newBufferSize];
+            buffers.add(currentBuffer);
+        }
+    }
+
+    /**
+     * Write the bytes to byte array.
+     *
+     * @param b   the bytes to write
+     * @param off The start offset
+     * @param len The number of bytes to write
+     */
+    @Override
+    public void write(final byte[] b, final int off, final int len) {
+        if ((off < 0)
+                || (off > b.length)
+                || (len < 0)
+                || ((off + len) > b.length)
+                || ((off + len) < 0)) {
+            throw new IndexOutOfBoundsException();
+        } else if (len == 0) {
+            return;
+        }
+        synchronized (this) {
+            final int newcount = count + len;
+            int remaining = len;
+            int inBufferPos = count - filledBufferSum;
+            while (remaining > 0) {
+                final int part = Math.min(remaining, currentBuffer.length - inBufferPos);
+                System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);
+                remaining -= part;
+                if (remaining > 0) {
+                    needNewBuffer(newcount);
+                    inBufferPos = 0;
+                }
+            }
+            count = newcount;
+        }
+    }
+
+    /**
+     * Write a byte to byte array.
+     *
+     * @param b the byte to write
+     */
+    @Override
+    public synchronized void write(final int b) {
+        int inBufferPos = count - filledBufferSum;
+        if (inBufferPos == currentBuffer.length) {
+            needNewBuffer(count + 1);
+            inBufferPos = 0;
+        }
+        currentBuffer[inBufferPos] = (byte) b;
+        count++;
+    }
+
+    /**
+     * Writes the entire contents of the specified input stream to this
+     * byte stream. Bytes from the input stream are read directly into the
+     * internal buffers of this streams.
+     *
+     * @param in the input stream to read from
+     * @return total number of bytes read from the input stream
+     * (and written to this stream)
+     * @throws IOException if an I/O error occurs while reading the input stream
+     * @since 1.4
+     */
+    public synchronized int write(final InputStream in) throws IOException {
+        int readCount = 0;
+        int inBufferPos = count - filledBufferSum;
+        int n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        while (n != EOF) {
+            readCount += n;
+            inBufferPos += n;
+            count += n;
+            if (inBufferPos == currentBuffer.length) {
+                needNewBuffer(currentBuffer.length);
+                inBufferPos = 0;
+            }
+            n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        }
+        return readCount;
+    }
+
+    /**
+     * Return the current size of the byte array.
+     *
+     * @return the current size of the byte array
+     */
+    public synchronized int size() {
+        return count;
+    }
+
+    /**
+     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in
+     * this class can be called after the stream has been closed without
+     * generating an {@code IOException}.
+     *
+     * @throws IOException never (this method should not declare this exception
+     *                     but it has to now due to backwards compatibility)
+     */
+    @Override
+    public void close() throws IOException {
+        //nop
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#reset()
+     */
+    public synchronized void reset() {
+        count = 0;
+        filledBufferSum = 0;
+        currentBufferIndex = 0;
+        if (reuseBuffers) {
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Throw away old buffers
+            currentBuffer = null;
+            final int size = buffers.get(0).length;
+            buffers.clear();
+            needNewBuffer(size);
+            reuseBuffers = true;
+        }
+    }
+
+    /**
+     * Writes the entire contents of this byte stream to the
+     * specified output stream.
+     *
+     * @param out the output stream to write to
+     * @throws IOException if an I/O error occurs, such as if the stream is closed
+     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
+     */
+    public synchronized void writeTo(final OutputStream out) throws IOException {
+        int remaining = count;
+        for (final byte[] buf : buffers) {
+            final int c = Math.min(buf.length, remaining);
+            out.write(buf, 0, c);
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+    }
+
+    /**
+     * Fetches entire contents of an <code>InputStream</code> and represent
+     * same data as result InputStream.
+     * <p>
+     * This method is useful where,
+     * <ul>
+     * <li>Source InputStream is slow.</li>
+     * <li>It has network resources associated, so we cannot keep it open for
+     * long time.</li>
+     * <li>It has network timeout associated.</li>
+     * </ul>
+     * It can be used in favor of {@link #toByteArray()}, since it
+     * avoids unnecessary allocation and copy of byte[].<br>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input Stream to be fully buffered.
+     * @return A fully buffered stream.
+     * @throws IOException if an I/O error occurs
+     * @since 2.0
+     */
+    public static InputStream toBufferedInputStream(final InputStream input)
+            throws IOException {
+        return toBufferedInputStream(input, 1024);
+    }
+
+    /**
+     * Fetches entire contents of an <code>InputStream</code> and represent
+     * same data as result InputStream.
+     * <p>
+     * This method is useful where,
+     * <ul>
+     * <li>Source InputStream is slow.</li>
+     * <li>It has network resources associated, so we cannot keep it open for
+     * long time.</li>
+     * <li>It has network timeout associated.</li>
+     * </ul>
+     * It can be used in favor of {@link #toByteArray()}, since it
+     * avoids unnecessary allocation and copy of byte[].<br>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input Stream to be fully buffered.
+     * @param size  the initial buffer size
+     * @return A fully buffered stream.
+     * @throws IOException if an I/O error occurs
+     * @since 2.5
+     */
+    public static InputStream toBufferedInputStream(final InputStream input, final int size)
+            throws IOException {
+        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op
+        @SuppressWarnings("resource") final ByteArrayOutputStream output = new ByteArrayOutputStream(size);
+        output.write(input);
+        return output.toInputStream();
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a Input Stream. The
+     * returned stream is backed by buffers of <code>this</code> stream,
+     * avoiding memory allocation and copy, thus saving space and time.<br>
+     *
+     * @return the current contents of this output stream.
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     * @see #reset()
+     * @since 2.5
+     */
+    public synchronized InputStream toInputStream() {
+        int remaining = count;
+        if (remaining == 0) {
+            return new ClosedInputStream();
+        }
+        final List<ByteArrayInputStream> list = new ArrayList<>(buffers.size());
+        for (final byte[] buf : buffers) {
+            final int c = Math.min(buf.length, remaining);
+            list.add(new ByteArrayInputStream(buf, 0, c));
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        reuseBuffers = false;
+        return new SequenceInputStream(Collections.enumeration(list));
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a byte array.
+     * The result is independent of this stream.
+     *
+     * @return the current contents of this output stream, as a byte array
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     */
+    public synchronized byte[] toByteArray() {
+        int remaining = count;
+        if (remaining == 0) {
+            return EMPTY_BYTE_ARRAY;
+        }
+        final byte newbuf[] = new byte[remaining];
+        int pos = 0;
+        for (final byte[] buf : buffers) {
+            final int c = Math.min(buf.length, remaining);
+            System.arraycopy(buf, 0, newbuf, pos, c);
+            pos += c;
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        return newbuf;
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a string
+     * using the platform default charset.
+     *
+     * @return the contents of the byte array as a String
+     * @see java.io.ByteArrayOutputStream#toString()
+     * @deprecated 2.5 use {@link #toString(String)} instead
+     */
+    @Override
+    @Deprecated
+    public String toString() {
+        // make explicit the use of the default charset
+        return new String(toByteArray(), Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a string
+     * using the specified encoding.
+     *
+     * @param enc the name of the character encoding
+     * @return the string converted from the byte array
+     * @throws UnsupportedEncodingException if the encoding is not supported
+     * @see java.io.ByteArrayOutputStream#toString(String)
+     */
+    public String toString(final String enc) throws UnsupportedEncodingException {
+        return new String(toByteArray(), enc);
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a string
+     * using the specified encoding.
+     *
+     * @param charset the character encoding
+     * @return the string converted from the byte array
+     * @see java.io.ByteArrayOutputStream#toString(String)
+     * @since 2.5
+     */
+    public String toString(final Charset charset) {
+        return new String(toByteArray(), charset);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/utils/io/output/StringBuilderWriter.java b/TMessagesProj/src/main/java/io/bettergram/utils/io/output/StringBuilderWriter.java
new file mode 100644
index 000000000..8538bde08
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/utils/io/output/StringBuilderWriter.java
@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.bettergram.utils.io.output;
+
+import java.io.Serializable;
+import java.io.Writer;
+
+/**
+ * {@link Writer} implementation that outputs to a {@link StringBuilder}.
+ * <p>
+ * <strong>NOTE:</strong> This implementation, as an alternative to
+ * <code>java.io.StringWriter</code>, provides an <i>un-synchronized</i>
+ * (i.e. for use in a single thread) implementation for better performance.
+ * For safe usage with multiple {@link Thread}s then
+ * <code>java.io.StringWriter</code> should be used.
+ *
+ * @since 2.0
+ */
+public class StringBuilderWriter extends Writer implements Serializable {
+
+    private static final long serialVersionUID = -146927496096066153L;
+    private final StringBuilder builder;
+
+    /**
+     * Constructs a new {@link StringBuilder} instance with default capacity.
+     */
+    public StringBuilderWriter() {
+        this.builder = new StringBuilder();
+    }
+
+    /**
+     * Constructs a new {@link StringBuilder} instance with the specified capacity.
+     *
+     * @param capacity The initial capacity of the underlying {@link StringBuilder}
+     */
+    public StringBuilderWriter(final int capacity) {
+        this.builder = new StringBuilder(capacity);
+    }
+
+    /**
+     * Constructs a new instance with the specified {@link StringBuilder}.
+     *
+     * <p>If {@code builder} is null a new instance with default capacity will be created.</p>
+     *
+     * @param builder The String builder. May be null.
+     */
+    public StringBuilderWriter(final StringBuilder builder) {
+        this.builder = builder != null ? builder : new StringBuilder();
+    }
+
+    /**
+     * Appends a single character to this Writer.
+     *
+     * @param value The character to append
+     * @return This writer instance
+     */
+    @Override
+    public Writer append(final char value) {
+        builder.append(value);
+        return this;
+    }
+
+    /**
+     * Appends a character sequence to this Writer.
+     *
+     * @param value The character to append
+     * @return This writer instance
+     */
+    @Override
+    public Writer append(final CharSequence value) {
+        builder.append(value);
+        return this;
+    }
+
+    /**
+     * Appends a portion of a character sequence to the {@link StringBuilder}.
+     *
+     * @param value The character to append
+     * @param start The index of the first character
+     * @param end   The index of the last character + 1
+     * @return This writer instance
+     */
+    @Override
+    public Writer append(final CharSequence value, final int start, final int end) {
+        builder.append(value, start, end);
+        return this;
+    }
+
+    /**
+     * Closing this writer has no effect.
+     */
+    @Override
+    public void close() {
+        // no-op
+    }
+
+    /**
+     * Flushing this writer has no effect.
+     */
+    @Override
+    public void flush() {
+        // no-op
+    }
+
+
+    /**
+     * Writes a String to the {@link StringBuilder}.
+     *
+     * @param value The value to write
+     */
+    @Override
+    public void write(final String value) {
+        if (value != null) {
+            builder.append(value);
+        }
+    }
+
+    /**
+     * Writes a portion of a character array to the {@link StringBuilder}.
+     *
+     * @param value  The value to write
+     * @param offset The index of the first character
+     * @param length The number of characters to write
+     */
+    @Override
+    public void write(final char[] value, final int offset, final int length) {
+        if (value != null) {
+            builder.append(value, offset, length);
+        }
+    }
+
+    /**
+     * Returns the underlying builder.
+     *
+     * @return The underlying builder
+     */
+    public StringBuilder getBuilder() {
+        return builder;
+    }
+
+    /**
+     * Returns {@link StringBuilder#toString()}.
+     *
+     * @return The contents of the String builder.
+     */
+    @Override
+    public String toString() {
+        return builder.toString();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
index 6026b19fa..4fbb7c3d5 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
@@ -61,7 +61,7 @@ public static File getFilesDirFixed() {
         } catch (Exception e) {
             FileLog.e(e);
         }
-        return new File("/data/data/org.telegram.messenger/files");
+        return new File("/data/data/io.bettergram.messenger/files");
     }
 
     public static void postInitApplication() {
@@ -87,7 +87,7 @@ public static void postInitApplication() {
         }
 
         try {
-            PowerManager pm = (PowerManager)ApplicationLoader.applicationContext.getSystemService(Context.POWER_SERVICE);
+            PowerManager pm = (PowerManager) ApplicationLoader.applicationContext.getSystemService(Context.POWER_SERVICE);
             isScreenOn = pm.isScreenOn();
             if (BuildVars.LOGS_ENABLED) {
                 FileLog.d("screen state = " + isScreenOn);
@@ -109,7 +109,7 @@ public static void postInitApplication() {
             }
         }
 
-        ApplicationLoader app = (ApplicationLoader)ApplicationLoader.applicationContext;
+        ApplicationLoader app = (ApplicationLoader) ApplicationLoader.applicationContext;
         app.initPlayServices();
         if (BuildVars.LOGS_ENABLED) {
             FileLog.d("app initied");
@@ -155,7 +155,7 @@ public static void stopPushService() {
         applicationContext.stopService(new Intent(applicationContext, NotificationsService.class));
 
         PendingIntent pintent = PendingIntent.getService(applicationContext, 0, new Intent(applicationContext, NotificationsService.class), 0);
-        AlarmManager alarm = (AlarmManager)applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarm = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
         alarm.cancel(pintent);
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/Theme.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/Theme.java
index 4100ecc92..11d5ff8a6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/Theme.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/Theme.java
@@ -320,6 +320,9 @@ public int getMinimumHeight() {
     public static Drawable profile_verifiedDrawable;
     public static Drawable profile_verifiedCheckDrawable;
 
+    public static Drawable crypto_priceDownDrawable;
+    public static Drawable crypto_priceUpDrawable;
+
     public static Paint chat_docBackPaint;
     public static Paint chat_deleteProgressPaint;
     public static Paint chat_botProgressPaint;
@@ -2751,6 +2754,9 @@ public static void createCommonResources(Context context) {
 
             dialog_favoriteDrawable = resources.getDrawable(R.drawable.ic_ab_fave);
 
+            crypto_priceDownDrawable = resources.getDrawable(R.drawable.ic_arrow_price_down);
+            crypto_priceUpDrawable = resources.getDrawable(R.drawable.ic_arrow_price_up);
+
             applyCommonTheme();
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java
index 4a8249c86..63d529fa8 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java
@@ -220,7 +220,7 @@ private void resetItems() {
         items.add(new Item(10, LocaleController.getString("Calls", R.string.Calls), R.drawable.menu_calls));
         items.add(new Item(7, LocaleController.getString("InviteFriends", R.string.InviteFriends), R.drawable.menu_invite));
         items.add(new Item(8, LocaleController.getString("Settings", R.string.Settings), R.drawable.menu_settings));
-        items.add(new Item(9, LocaleController.getString("TelegramFAQ", R.string.BettergramFAQ), R.drawable.menu_help));
+        items.add(new Item(9, LocaleController.getString("BettergramFAQ", R.string.BettergramFAQ), R.drawable.menu_help));
     }
 
     public int getId(int position) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardView.java
new file mode 100644
index 000000000..29877f66c
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardView.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Rect;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.widget.FrameLayout;
+import io.bettergram.messenger.R;
+
+/**
+ * A ViewGroup with a rounded corner background and shadow behind.
+ * <p>
+ * CardView uses <code>elevation</code> property on L for shadows and falls back to a custom shadow
+ * implementation on older platforms.
+ *
+ * <strong>Lies!</strong> Unfortunately we cannot compile against L yet without the minSdk version being L.
+ * This means that the support CardView will still be used on L.
+ * <p>
+ * Due to expensive nature of rounded corner clipping, on platforms before L, CardView does not clip
+ * its children that intersect with rounded corners. Instead, it adds padding to avoid such
+ * intersection.
+ *
+ * @attr ref android.support.v7.cardview.R.styleable#CardView_cardBackgroundColor
+ * @attr ref android.support.v7.cardview.R.styleable#CardView_cardCornerRadius
+ */
+public class CardView extends FrameLayout implements CardViewDelegate {
+
+    private static final CardViewImpl IMPL;
+
+    static {
+        if (Build.VERSION.SDK_INT >= 21) {
+            IMPL = new CardViewApi21();
+        } else if (Build.VERSION.SDK_INT >= 17) {
+            IMPL = new CardViewJellybeanMr1();
+        } else {
+            IMPL = new CardViewEclairMr1();
+        }
+        IMPL.initStatic();
+    }
+
+    private boolean mCompatPadding;
+    private boolean mPreventCornerOverlap;
+    private final Rect mContentPadding = new Rect();
+    private final Rect mShadowBounds = new Rect();
+
+    public CardView(Context context) {
+        super(context);
+        initialize(context, null, 0);
+    }
+
+    public CardView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize(context, attrs, 0);
+    }
+
+    public CardView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        initialize(context, attrs, defStyleAttr);
+    }
+
+    @Override
+    public void setPadding(int left, int top, int right, int bottom) {
+        // NO OP
+    }
+
+    public void setPaddingRelative(int start, int top, int end, int bottom) {
+        // NO OP
+    }
+
+    /**
+     * Returns whether CardView will add inner padding on platforms L and after.
+     *
+     * @return True CardView adds inner padding on platforms L and after to have same dimensions
+     * with platforms before L.
+     */
+    @Override
+    public boolean getUseCompatPadding() {
+        return mCompatPadding;
+    }
+
+    /**
+     * CardView adds additional padding to draw shadows on platforms before L.
+     * <p>
+     * This may cause Cards to have different sizes between L and before L. If you need to align
+     * CardView with other Views, you may need api version specific dimension resources to account
+     * for the changes.
+     * As an alternative, you can set this flag to <code>true</code> and CardView will add the same
+     * padding values on platforms L and after.
+     * <p>
+     * Since setting this flag to true adds unnecessary gaps in the UI, default value is
+     * <code>false</code>.
+     *
+     * @param useCompatPadding True if CardView should add padding for the shadows on platforms L
+     *                         and above.
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_cardUseCompatPadding
+     */
+    public void setUseCompatPadding(boolean useCompatPadding) {
+        if (mCompatPadding == useCompatPadding) {
+            return;
+        }
+        mCompatPadding = useCompatPadding;
+        IMPL.onCompatPaddingChanged(this);
+    }
+
+    /**
+     * Sets the padding between the Card's edges and the children of CardView.
+     * <p>
+     * Depending on platform version or {@link #getUseCompatPadding()} settings, CardView may
+     * update these values before calling {@link android.view.View#setPadding(int, int, int, int)}.
+     *
+     * @param left   The left padding in pixels
+     * @param top    The top padding in pixels
+     * @param right  The right padding in pixels
+     * @param bottom The bottom padding in pixels
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_contentPadding
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_contentPaddingLeft
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_contentPaddingTop
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_contentPaddingRight
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_contentPaddingBottom
+     */
+    public void setContentPadding(int left, int top, int right, int bottom) {
+        mContentPadding.set(left, top, right, bottom);
+        IMPL.updatePadding(this);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        if (IMPL instanceof CardViewApi21 == false) {
+            final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+            switch (widthMode) {
+                case MeasureSpec.EXACTLY:
+                case MeasureSpec.AT_MOST:
+                    final int minWidth = (int) Math.ceil(IMPL.getMinWidth(this));
+                    widthMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(minWidth,
+                            MeasureSpec.getSize(widthMeasureSpec)), widthMode);
+                    break;
+            }
+            final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+            switch (heightMode) {
+                case MeasureSpec.EXACTLY:
+                case MeasureSpec.AT_MOST:
+                    final int minHeight = (int) Math.ceil(IMPL.getMinHeight(this));
+                    heightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(minHeight,
+                            MeasureSpec.getSize(heightMeasureSpec)), heightMode);
+                    break;
+            }
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        } else {
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        }
+    }
+
+    private void initialize(Context context, AttributeSet attrs, int defStyleAttr) {
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CardView, defStyleAttr,
+                R.style.CardView_Light);
+        int backgroundColor = a.getColor(R.styleable.CardView_cardBackgroundColor, 0);
+        float radius = a.getDimension(R.styleable.CardView_cardCornerRadius, 0);
+        float elevation = a.getDimension(R.styleable.CardView_cardElevation, 0);
+        float maxElevation = a.getDimension(R.styleable.CardView_cardMaxElevation, 0);
+        mCompatPadding = a.getBoolean(R.styleable.CardView_cardUseCompatPadding, false);
+        mPreventCornerOverlap = a.getBoolean(R.styleable.CardView_cardPreventCornerOverlap, true);
+        int defaultPadding = a.getDimensionPixelSize(R.styleable.CardView_contentPadding, 0);
+        mContentPadding.left = a.getDimensionPixelSize(R.styleable.CardView_contentPaddingLeft,
+                defaultPadding);
+        mContentPadding.top = a.getDimensionPixelSize(R.styleable.CardView_contentPaddingTop,
+                defaultPadding);
+        mContentPadding.right = a.getDimensionPixelSize(R.styleable.CardView_contentPaddingRight,
+                defaultPadding);
+        mContentPadding.bottom = a.getDimensionPixelSize(R.styleable.CardView_contentPaddingBottom,
+                defaultPadding);
+        if (elevation > maxElevation) {
+            maxElevation = elevation;
+        }
+        a.recycle();
+        IMPL.initialize(this, context, backgroundColor, radius, elevation, maxElevation);
+    }
+
+    /**
+     * Updates the background color of the CardView
+     *
+     * @param color The new color to set for the card background
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_cardBackgroundColor
+     */
+    public void setCardBackgroundColor(int color) {
+        IMPL.setBackgroundColor(this, color);
+    }
+
+    /**
+     * Returns the inner padding after the Card's left edge
+     *
+     * @return the inner padding after the Card's left edge
+     */
+    public int getContentPaddingLeft() {
+        return mContentPadding.left;
+    }
+
+    /**
+     * Returns the inner padding before the Card's right edge
+     *
+     * @return the inner padding before the Card's right edge
+     */
+    public int getContentPaddingRight() {
+        return mContentPadding.right;
+    }
+
+    /**
+     * Returns the inner padding after the Card's top edge
+     *
+     * @return the inner padding after the Card's top edge
+     */
+    public int getContentPaddingTop() {
+        return mContentPadding.top;
+    }
+
+    /**
+     * Returns the inner padding before the Card's bottom edge
+     *
+     * @return the inner padding before the Card's bottom edge
+     */
+    public int getContentPaddingBottom() {
+        return mContentPadding.bottom;
+    }
+
+    /**
+     * Updates the corner radius of the CardView.
+     *
+     * @param radius The radius in pixels of the corners of the rectangle shape
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_cardCornerRadius
+     * @see #setRadius(float)
+     */
+    public void setRadius(float radius) {
+        IMPL.setRadius(this, radius);
+    }
+
+    /**
+     * Returns the corner radius of the CardView.
+     *
+     * @return Corner radius of the CardView
+     * @see #getRadius()
+     */
+    public float getRadius() {
+        return IMPL.getRadius(this);
+    }
+
+    /**
+     * Internal method used by CardView implementations to update the padding.
+     *
+     * @hide
+     */
+    @Override
+    public void setShadowPadding(int left, int top, int right, int bottom) {
+        mShadowBounds.set(left, top, right, bottom);
+        super.setPadding(left + mContentPadding.left, top + mContentPadding.top,
+                right + mContentPadding.right, bottom + mContentPadding.bottom);
+    }
+
+    /**
+     * Updates the backward compatible elevation of the CardView.
+     *
+     * @param radius The backward compatible elevation in pixels.
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_cardElevation
+     * @see #getCardElevation()
+     * @see #setMaxCardElevation(float)
+     */
+    public void setCardElevation(float radius) {
+        IMPL.setElevation(this, radius);
+    }
+
+    /**
+     * Returns the backward compatible elevation of the CardView.
+     *
+     * @return Elevation of the CardView
+     * @see #setCardElevation(float)
+     * @see #getMaxCardElevation()
+     */
+    public float getCardElevation() {
+        return IMPL.getElevation(this);
+    }
+
+    /**
+     * Updates the backward compatible elevation of the CardView.
+     * <p>
+     * Calling this method has no effect if device OS version is L or newer and
+     * {@link #getUseCompatPadding()} is <code>false</code>.
+     *
+     * @param radius The backward compatible elevation in pixels.
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_cardElevation
+     * @see #setCardElevation(float)
+     * @see #getMaxCardElevation()
+     */
+    public void setMaxCardElevation(float radius) {
+        IMPL.setMaxElevation(this, radius);
+    }
+
+    /**
+     * Returns the backward compatible elevation of the CardView.
+     *
+     * @return Elevation of the CardView
+     * @see #setMaxCardElevation(float)
+     * @see #getCardElevation()
+     */
+    public float getMaxCardElevation() {
+        return IMPL.getMaxElevation(this);
+    }
+
+    /**
+     * Returns whether CardView should add extra padding to content to avoid overlaps with rounded
+     * corners on API versions 20 and below.
+     *
+     * @return True if CardView prevents overlaps with rounded corners on platforms before L.
+     * Default value is <code>true</code>.
+     */
+    @Override
+    public boolean getPreventCornerOverlap() {
+        return mPreventCornerOverlap;
+    }
+
+    /**
+     * On API 20 and before, CardView does not clip the bounds of the Card for the rounded corners.
+     * Instead, it adds padding to content so that it won't overlap with the rounded corners.
+     * You can disable this behavior by setting this field to <code>false</code>.
+     * <p>
+     * Setting this value on API 21 and above does not have any effect unless you have enabled
+     * compatibility padding.
+     *
+     * @param preventCornerOverlap Whether CardView should add extra padding to content to avoid
+     *                             overlaps with the CardView corners.
+     * @attr ref android.support.v7.cardview.R.styleable#CardView_cardPreventCornerOverlap
+     * @see #setUseCompatPadding(boolean)
+     */
+    public void setPreventCornerOverlap(boolean preventCornerOverlap) {
+        if (preventCornerOverlap == mPreventCornerOverlap) {
+            return;
+        }
+        mPreventCornerOverlap = preventCornerOverlap;
+        IMPL.onPreventCornerOverlapChanged(this);
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewApi21.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewApi21.java
new file mode 100644
index 000000000..9d357b84d
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewApi21.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.ui.Components.CardView;
+
+import android.content.Context;
+import android.view.View;
+
+class CardViewApi21 implements CardViewImpl {
+    @Override
+    public void initialize(CardViewDelegate cardView, Context context, int backgroundColor,
+                           float radius, float elevation, float maxElevation) {
+        final RoundRectDrawable backgroundDrawable = new RoundRectDrawable(backgroundColor, radius);
+        cardView.setBackgroundDrawable(backgroundDrawable);
+        View view = (View) cardView;
+        view.setClipToOutline(true);
+        view.setElevation(elevation);
+        setMaxElevation(cardView, maxElevation);
+    }
+
+    @Override
+    public void setRadius(CardViewDelegate cardView, float radius) {
+        ((RoundRectDrawable) (cardView.getBackground())).setRadius(radius);
+    }
+
+    @Override
+    public void initStatic() {
+    }
+
+    @Override
+    public void setMaxElevation(CardViewDelegate cardView, float maxElevation) {
+        ((RoundRectDrawable) (cardView.getBackground())).setPadding(maxElevation,
+                cardView.getUseCompatPadding(), cardView.getPreventCornerOverlap());
+        updatePadding(cardView);
+    }
+
+    @Override
+    public float getMaxElevation(CardViewDelegate cardView) {
+        return ((RoundRectDrawable) (cardView.getBackground())).getPadding();
+    }
+
+    @Override
+    public float getMinWidth(CardViewDelegate cardView) {
+        return getRadius(cardView) * 2;
+    }
+
+    @Override
+    public float getMinHeight(CardViewDelegate cardView) {
+        return getRadius(cardView) * 2;
+    }
+
+    @Override
+    public float getRadius(CardViewDelegate cardView) {
+        return ((RoundRectDrawable) (cardView.getBackground())).getRadius();
+    }
+
+    @Override
+    public void setElevation(CardViewDelegate cardView, float elevation) {
+        ((View) cardView).setElevation(elevation);
+    }
+
+    @Override
+    public float getElevation(CardViewDelegate cardView) {
+        return ((View) cardView).getElevation();
+    }
+
+    @Override
+    public void updatePadding(CardViewDelegate cardView) {
+        if (!cardView.getUseCompatPadding()) {
+            cardView.setShadowPadding(0, 0, 0, 0);
+            return;
+        }
+        float elevation = getMaxElevation(cardView);
+        final float radius = getRadius(cardView);
+        int hPadding = (int) Math.ceil(RoundRectDrawableWithShadow
+                .calculateHorizontalPadding(elevation, radius, cardView.getPreventCornerOverlap()));
+        int vPadding = (int) Math.ceil(RoundRectDrawableWithShadow
+                .calculateVerticalPadding(elevation, radius, cardView.getPreventCornerOverlap()));
+        cardView.setShadowPadding(hPadding, vPadding, hPadding, vPadding);
+    }
+
+    @Override
+    public void onCompatPaddingChanged(CardViewDelegate cardView) {
+        setMaxElevation(cardView, getMaxElevation(cardView));
+    }
+
+    @Override
+    public void onPreventCornerOverlapChanged(CardViewDelegate cardView) {
+        setMaxElevation(cardView, getMaxElevation(cardView));
+    }
+
+    @Override
+    public void setBackgroundColor(CardViewDelegate cardView, int color) {
+        ((RoundRectDrawable) (cardView.getBackground())).setColor(color);
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewDelegate.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewDelegate.java
new file mode 100644
index 000000000..a6e71ab20
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewDelegate.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+import android.graphics.drawable.Drawable;
+
+/**
+ * Interface provided by CardView to implementations.
+ * <p>
+ * Necessary to resolve circular dependency between base CardView and platform implementations.
+ */
+interface CardViewDelegate {
+    void setBackgroundDrawable(Drawable paramDrawable);
+
+    Drawable getBackground();
+
+    boolean getUseCompatPadding();
+
+    boolean getPreventCornerOverlap();
+
+    float getRadius();
+
+    void setShadowPadding(int left, int top, int right, int bottom);
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewEclairMr1.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewEclairMr1.java
new file mode 100644
index 000000000..ca0413f9d
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewEclairMr1.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.view.View;
+
+class CardViewEclairMr1 implements CardViewImpl {
+    final RectF sCornerRect = new RectF();
+
+    @Override
+    public void initStatic() {
+        // Draws a round rect using 7 draw operations. This is faster than using
+        // canvas.drawRoundRect before JBMR1 because API 11-16 used alpha mask textures to draw
+        // shapes.
+        RoundRectDrawableWithShadow.sRoundRectHelper = (canvas, bounds, cornerRadius, paint) -> {
+            final float twoRadius = cornerRadius * 2;
+            final float innerWidth = bounds.width() - twoRadius - 1;
+            final float innerHeight = bounds.height() - twoRadius - 1;
+            // increment it to account for half pixels.
+            if (cornerRadius >= 1f) {
+                cornerRadius += .5f;
+                sCornerRect.set(-cornerRadius, -cornerRadius, cornerRadius, cornerRadius);
+                int saved = canvas.save();
+                canvas.translate(bounds.left + cornerRadius, bounds.top + cornerRadius);
+                canvas.drawArc(sCornerRect, 180, 90, true, paint);
+                canvas.translate(innerWidth, 0);
+                canvas.rotate(90);
+                canvas.drawArc(sCornerRect, 180, 90, true, paint);
+                canvas.translate(innerHeight, 0);
+                canvas.rotate(90);
+                canvas.drawArc(sCornerRect, 180, 90, true, paint);
+                canvas.translate(innerWidth, 0);
+                canvas.rotate(90);
+                canvas.drawArc(sCornerRect, 180, 90, true, paint);
+                canvas.restoreToCount(saved);
+                //draw top and bottom pieces
+                canvas.drawRect(bounds.left + cornerRadius - 1f, bounds.top,
+                        bounds.right - cornerRadius + 1f, bounds.top + cornerRadius,
+                        paint);
+                canvas.drawRect(bounds.left + cornerRadius - 1f,
+                        bounds.bottom - cornerRadius + 1f, bounds.right - cornerRadius + 1f,
+                        bounds.bottom, paint);
+            }
+            ////                center
+            canvas.drawRect(bounds.left, bounds.top + Math.max(0, cornerRadius - 1f),
+                    bounds.right, bounds.bottom - cornerRadius + 1f, paint);
+        };
+    }
+
+    @Override
+    public void initialize(CardViewDelegate cardView, Context context, int backgroundColor,
+                           float radius, float elevation, float maxElevation) {
+        RoundRectDrawableWithShadow background = createBackground(context, backgroundColor, radius,
+                elevation, maxElevation);
+        background.setAddPaddingForCorners(cardView.getPreventCornerOverlap());
+        cardView.setBackgroundDrawable(background);
+        updatePadding(cardView);
+    }
+
+    RoundRectDrawableWithShadow createBackground(Context context, int backgroundColor,
+                                                 float radius, float elevation, float maxElevation) {
+        return new RoundRectDrawableWithShadow(context.getResources(), backgroundColor, radius,
+                elevation, maxElevation);
+    }
+
+    @Override
+    public void updatePadding(CardViewDelegate cardView) {
+        Rect shadowPadding = new Rect();
+        getShadowBackground(cardView).getMaxShadowAndCornerPadding(shadowPadding);
+        ((View) cardView).setMinimumHeight((int) Math.ceil(getMinHeight(cardView)));
+        ((View) cardView).setMinimumWidth((int) Math.ceil(getMinWidth(cardView)));
+        cardView.setShadowPadding(shadowPadding.left, shadowPadding.top,
+                shadowPadding.right, shadowPadding.bottom);
+    }
+
+    @Override
+    public void onCompatPaddingChanged(CardViewDelegate cardView) {
+        // NO OP
+    }
+
+    @Override
+    public void onPreventCornerOverlapChanged(CardViewDelegate cardView) {
+        getShadowBackground(cardView).setAddPaddingForCorners(cardView.getPreventCornerOverlap());
+        updatePadding(cardView);
+    }
+
+    @Override
+    public void setBackgroundColor(CardViewDelegate cardView, int color) {
+        getShadowBackground(cardView).setColor(color);
+    }
+
+    @Override
+    public void setRadius(CardViewDelegate cardView, float radius) {
+        getShadowBackground(cardView).setCornerRadius(radius);
+        updatePadding(cardView);
+    }
+
+    @Override
+    public float getRadius(CardViewDelegate cardView) {
+        return getShadowBackground(cardView).getCornerRadius();
+    }
+
+    @Override
+    public void setElevation(CardViewDelegate cardView, float elevation) {
+        getShadowBackground(cardView).setShadowSize(elevation);
+    }
+
+    @Override
+    public float getElevation(CardViewDelegate cardView) {
+        return getShadowBackground(cardView).getShadowSize();
+    }
+
+    @Override
+    public void setMaxElevation(CardViewDelegate cardView, float maxElevation) {
+        getShadowBackground(cardView).setMaxShadowSize(maxElevation);
+        updatePadding(cardView);
+    }
+
+    @Override
+    public float getMaxElevation(CardViewDelegate cardView) {
+        return getShadowBackground(cardView).getMaxShadowSize();
+    }
+
+    @Override
+    public float getMinWidth(CardViewDelegate cardView) {
+        return getShadowBackground(cardView).getMinWidth();
+    }
+
+    @Override
+    public float getMinHeight(CardViewDelegate cardView) {
+        return getShadowBackground(cardView).getMinHeight();
+    }
+
+    private RoundRectDrawableWithShadow getShadowBackground(CardViewDelegate cardView) {
+        return ((RoundRectDrawableWithShadow) cardView.getBackground());
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewImpl.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewImpl.java
new file mode 100644
index 000000000..bca321e85
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewImpl.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+import android.content.Context;
+
+/**
+ * Interface for platform specific CardView implementations.
+ */
+interface CardViewImpl {
+    void initialize(CardViewDelegate cardView, Context context, int backgroundColor, float radius, float elevation, float maxElevation);
+
+    void setRadius(CardViewDelegate cardView, float radius);
+
+    float getRadius(CardViewDelegate cardView);
+
+    void setElevation(CardViewDelegate cardView, float elevation);
+
+    float getElevation(CardViewDelegate cardView);
+
+    void initStatic();
+
+    void setMaxElevation(CardViewDelegate cardView, float maxElevation);
+
+    float getMaxElevation(CardViewDelegate cardView);
+
+    float getMinWidth(CardViewDelegate cardView);
+
+    float getMinHeight(CardViewDelegate cardView);
+
+    void updatePadding(CardViewDelegate cardView);
+
+    void onCompatPaddingChanged(CardViewDelegate cardView);
+
+    void onPreventCornerOverlapChanged(CardViewDelegate cardView);
+
+    void setBackgroundColor(CardViewDelegate cardView, int color);
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewJellybeanMr1.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewJellybeanMr1.java
new file mode 100644
index 000000000..4d1b5a5ae
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/CardViewJellybeanMr1.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+class CardViewJellybeanMr1 extends CardViewEclairMr1 {
+
+    @Override
+    public void initStatic() {
+        RoundRectDrawableWithShadow.sRoundRectHelper = (canvas, bounds, cornerRadius, paint) -> canvas.drawRoundRect(bounds, cornerRadius, cornerRadius, paint);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/RoundRectDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/RoundRectDrawable.java
new file mode 100644
index 000000000..b4e69b4aa
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/RoundRectDrawable.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+import android.graphics.*;
+import android.graphics.drawable.Drawable;
+
+import static org.telegram.ui.Components.CardView.RoundRectDrawableWithShadow.calculateHorizontalPadding;
+import static org.telegram.ui.Components.CardView.RoundRectDrawableWithShadow.calculateVerticalPadding;
+
+/**
+ * Very simple drawable that draws a rounded rectangle background with arbitrary corners and also
+ * reports proper outline for L.
+ * <p>
+ * Simpler and uses less resources compared to GradientDrawable or ShapeDrawable.
+ */
+class RoundRectDrawable extends Drawable {
+    private float mRadius;
+    private final Paint mPaint;
+    private final RectF mBoundsF;
+    private final Rect mBoundsI;
+    private float mPadding;
+    private boolean mInsetForPadding = false;
+    private boolean mInsetForRadius = true;
+
+    public RoundRectDrawable(int backgroundColor, float radius) {
+        mRadius = radius;
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
+        mPaint.setColor(backgroundColor);
+        mBoundsF = new RectF();
+        mBoundsI = new Rect();
+    }
+
+    void setPadding(float padding, boolean insetForPadding, boolean insetForRadius) {
+        if (padding == mPadding && mInsetForPadding == insetForPadding &&
+                mInsetForRadius == insetForRadius) {
+            return;
+        }
+        mPadding = padding;
+        mInsetForPadding = insetForPadding;
+        mInsetForRadius = insetForRadius;
+        updateBounds(null);
+        invalidateSelf();
+    }
+
+    float getPadding() {
+        return mPadding;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.drawRoundRect(mBoundsF, mRadius, mRadius, mPaint);
+    }
+
+    private void updateBounds(Rect bounds) {
+        if (bounds == null) {
+            bounds = getBounds();
+        }
+        mBoundsF.set(bounds.left, bounds.top, bounds.right, bounds.bottom);
+        mBoundsI.set(bounds);
+        if (mInsetForPadding) {
+            float vInset = calculateVerticalPadding(mPadding, mRadius, mInsetForRadius);
+            float hInset = calculateHorizontalPadding(mPadding, mRadius, mInsetForRadius);
+            mBoundsI.inset((int) Math.ceil(hInset), (int) Math.ceil(vInset));
+            // to make sure they have same bounds.
+            mBoundsF.set(mBoundsI);
+        }
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        updateBounds(bounds);
+    }
+
+    @Override
+    public void getOutline(Outline outline) {
+        outline.setRoundRect(mBoundsI, mRadius);
+    }
+
+    void setRadius(float radius) {
+        if (radius == mRadius) {
+            return;
+        }
+        mRadius = radius;
+        updateBounds(null);
+        invalidateSelf();
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        // not supported because older versions do not support
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        // not supported because older versions do not support
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+    public float getRadius() {
+        return mRadius;
+    }
+
+    public void setColor(int color) {
+        mPaint.setColor(color);
+        invalidateSelf();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/RoundRectDrawableWithShadow.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/RoundRectDrawableWithShadow.java
new file mode 100644
index 000000000..72b69fe81
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CardView/RoundRectDrawableWithShadow.java
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.CardView;
+
+import android.content.res.Resources;
+import android.graphics.*;
+import android.graphics.drawable.Drawable;
+import io.bettergram.messenger.R;
+
+/**
+ * A rounded rectangle drawable which also includes a shadow around.
+ */
+class RoundRectDrawableWithShadow extends Drawable {
+    // used to calculate content padding
+    final static double COS_45 = Math.cos(Math.toRadians(45));
+    final static float SHADOW_MULTIPLIER = 1.5f;
+    final int mInsetShadow; // extra shadow to avoid gaps between card and shadow
+    /*
+     * This helper is set by CardView implementations.
+     * <p>
+     * Prior to API 17, canvas.drawRoundRect is expensive; which is why we need this interface
+     * to draw efficient rounded rectangles before 17.
+     * */
+    static RoundRectHelper sRoundRectHelper;
+    Paint mPaint;
+    Paint mCornerShadowPaint;
+    Paint mEdgeShadowPaint;
+    final RectF mCardBounds;
+    float mCornerRadius;
+    Path mCornerShadowPath;
+    // updated value with inset
+    float mMaxShadowSize;
+    // actual value set by developer
+    float mRawMaxShadowSize;
+    // multiplied value to account for shadow offset
+    float mShadowSize;
+    // actual value set by developer
+    float mRawShadowSize;
+    private boolean mDirty = true;
+    private final int mShadowStartColor;
+    private final int mShadowEndColor;
+    private boolean mAddPaddingForCorners = true;
+    /**
+     * If shadow size is set to a value above max shadow, we print a warning
+     */
+    private boolean mPrintedShadowClipWarning = false;
+
+    RoundRectDrawableWithShadow(Resources resources, int backgroundColor, float radius,
+                                float shadowSize, float maxShadowSize) {
+        mShadowStartColor = resources.getColor(R.color.cardview_shadow_start_color);
+        mShadowEndColor = resources.getColor(R.color.cardview_shadow_end_color);
+        mInsetShadow = resources.getDimensionPixelSize(R.dimen.cardview_compat_inset_shadow);
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
+        mPaint.setColor(backgroundColor);
+        mCornerShadowPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
+        mCornerShadowPaint.setStyle(Paint.Style.FILL);
+        mCornerRadius = (int) (radius + .5f);
+        mCardBounds = new RectF();
+        mEdgeShadowPaint = new Paint(mCornerShadowPaint);
+        mEdgeShadowPaint.setAntiAlias(false);
+        setShadowSize(shadowSize, maxShadowSize);
+    }
+
+    /**
+     * Casts the value to an even integer.
+     */
+    private int toEven(float value) {
+        int i = (int) (value + .5f);
+        if (i % 2 == 1) {
+            return i - 1;
+        }
+        return i;
+    }
+
+    public void setAddPaddingForCorners(boolean addPaddingForCorners) {
+        mAddPaddingForCorners = addPaddingForCorners;
+        invalidateSelf();
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mPaint.setAlpha(alpha);
+        mCornerShadowPaint.setAlpha(alpha);
+        mEdgeShadowPaint.setAlpha(alpha);
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        mDirty = true;
+    }
+
+    void setShadowSize(float shadowSize, float maxShadowSize) {
+        if (shadowSize < 0 || maxShadowSize < 0) {
+            throw new IllegalArgumentException("invalid shadow size");
+        }
+        shadowSize = toEven(shadowSize);
+        maxShadowSize = toEven(maxShadowSize);
+        if (shadowSize > maxShadowSize) {
+            shadowSize = maxShadowSize;
+            if (!mPrintedShadowClipWarning) {
+                mPrintedShadowClipWarning = true;
+            }
+        }
+        if (mRawShadowSize == shadowSize && mRawMaxShadowSize == maxShadowSize) {
+            return;
+        }
+        mRawShadowSize = shadowSize;
+        mRawMaxShadowSize = maxShadowSize;
+        mShadowSize = (int) (shadowSize * SHADOW_MULTIPLIER + mInsetShadow + .5f);
+        mMaxShadowSize = maxShadowSize + mInsetShadow;
+        mDirty = true;
+        invalidateSelf();
+    }
+
+    @Override
+    public boolean getPadding(Rect padding) {
+        int vOffset = (int) Math.ceil(calculateVerticalPadding(mRawMaxShadowSize, mCornerRadius,
+                mAddPaddingForCorners));
+        int hOffset = (int) Math.ceil(calculateHorizontalPadding(mRawMaxShadowSize, mCornerRadius,
+                mAddPaddingForCorners));
+        padding.set(hOffset, vOffset, hOffset, vOffset);
+        return true;
+    }
+
+    static float calculateVerticalPadding(float maxShadowSize, float cornerRadius,
+                                          boolean addPaddingForCorners) {
+        if (addPaddingForCorners) {
+            return (float) (maxShadowSize * SHADOW_MULTIPLIER + (1 - COS_45) * cornerRadius);
+        } else {
+            return maxShadowSize * SHADOW_MULTIPLIER;
+        }
+    }
+
+    static float calculateHorizontalPadding(float maxShadowSize, float cornerRadius,
+                                            boolean addPaddingForCorners) {
+        if (addPaddingForCorners) {
+            return (float) (maxShadowSize + (1 - COS_45) * cornerRadius);
+        } else {
+            return maxShadowSize;
+        }
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mPaint.setColorFilter(cf);
+        mCornerShadowPaint.setColorFilter(cf);
+        mEdgeShadowPaint.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+    void setCornerRadius(float radius) {
+        radius = (int) (radius + .5f);
+        if (mCornerRadius == radius) {
+            return;
+        }
+        mCornerRadius = radius;
+        mDirty = true;
+        invalidateSelf();
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        if (mDirty) {
+            buildComponents(getBounds());
+            mDirty = false;
+        }
+        canvas.translate(0, mRawShadowSize / 2);
+        drawShadow(canvas);
+        canvas.translate(0, -mRawShadowSize / 2);
+        sRoundRectHelper.drawRoundRect(canvas, mCardBounds, mCornerRadius, mPaint);
+    }
+
+    private void drawShadow(Canvas canvas) {
+        final float edgeShadowTop = -mCornerRadius - mShadowSize;
+        final float inset = mCornerRadius + mInsetShadow + mRawShadowSize / 2;
+        final boolean drawHorizontalEdges = mCardBounds.width() - 2 * inset > 0;
+        final boolean drawVerticalEdges = mCardBounds.height() - 2 * inset > 0;
+        // LT
+        int saved = canvas.save();
+        canvas.translate(mCardBounds.left + inset, mCardBounds.top + inset);
+        canvas.drawPath(mCornerShadowPath, mCornerShadowPaint);
+        if (drawHorizontalEdges) {
+            canvas.drawRect(0, edgeShadowTop,
+                    mCardBounds.width() - 2 * inset, -mCornerRadius,
+                    mEdgeShadowPaint);
+        }
+        canvas.restoreToCount(saved);
+        // RB
+        saved = canvas.save();
+        canvas.translate(mCardBounds.right - inset, mCardBounds.bottom - inset);
+        canvas.rotate(180f);
+        canvas.drawPath(mCornerShadowPath, mCornerShadowPaint);
+        if (drawHorizontalEdges) {
+            canvas.drawRect(0, edgeShadowTop,
+                    mCardBounds.width() - 2 * inset, -mCornerRadius + mShadowSize,
+                    mEdgeShadowPaint);
+        }
+        canvas.restoreToCount(saved);
+        // LB
+        saved = canvas.save();
+        canvas.translate(mCardBounds.left + inset, mCardBounds.bottom - inset);
+        canvas.rotate(270f);
+        canvas.drawPath(mCornerShadowPath, mCornerShadowPaint);
+        if (drawVerticalEdges) {
+            canvas.drawRect(0, edgeShadowTop,
+                    mCardBounds.height() - 2 * inset, -mCornerRadius, mEdgeShadowPaint);
+        }
+        canvas.restoreToCount(saved);
+        // RT
+        saved = canvas.save();
+        canvas.translate(mCardBounds.right - inset, mCardBounds.top + inset);
+        canvas.rotate(90f);
+        canvas.drawPath(mCornerShadowPath, mCornerShadowPaint);
+        if (drawVerticalEdges) {
+            canvas.drawRect(0, edgeShadowTop,
+                    mCardBounds.height() - 2 * inset, -mCornerRadius, mEdgeShadowPaint);
+        }
+        canvas.restoreToCount(saved);
+    }
+
+    private void buildShadowCorners() {
+        RectF innerBounds = new RectF(-mCornerRadius, -mCornerRadius, mCornerRadius, mCornerRadius);
+        RectF outerBounds = new RectF(innerBounds);
+        outerBounds.inset(-mShadowSize, -mShadowSize);
+        if (mCornerShadowPath == null) {
+            mCornerShadowPath = new Path();
+        } else {
+            mCornerShadowPath.reset();
+        }
+        mCornerShadowPath.setFillType(Path.FillType.EVEN_ODD);
+        mCornerShadowPath.moveTo(-mCornerRadius, 0);
+        mCornerShadowPath.rLineTo(-mShadowSize, 0);
+        // outer arc
+        mCornerShadowPath.arcTo(outerBounds, 180f, 90f, false);
+        // inner arc
+        mCornerShadowPath.arcTo(innerBounds, 270f, -90f, false);
+        mCornerShadowPath.close();
+        float startRatio = mCornerRadius / (mCornerRadius + mShadowSize);
+        mCornerShadowPaint.setShader(new RadialGradient(0, 0, mCornerRadius + mShadowSize,
+                new int[]{mShadowStartColor, mShadowStartColor, mShadowEndColor},
+                new float[]{0f, startRatio, 1f}
+                , Shader.TileMode.CLAMP));
+        // we offset the content shadowSize/2 pixels up to make it more realistic.
+        // this is why edge shadow shader has some extra space
+        // When drawing bottom edge shadow, we use that extra space.
+        mEdgeShadowPaint.setShader(new LinearGradient(0, -mCornerRadius + mShadowSize, 0,
+                -mCornerRadius - mShadowSize,
+                new int[]{mShadowStartColor, mShadowStartColor, mShadowEndColor},
+                new float[]{0f, .5f, 1f}, Shader.TileMode.CLAMP));
+        mEdgeShadowPaint.setAntiAlias(false);
+    }
+
+    private void buildComponents(Rect bounds) {
+        // Card is offset SHADOW_MULTIPLIER * maxShadowSize to account for the shadow shift.
+        // We could have different top-bottom offsets to avoid extra gap above but in that case
+        // center aligning Views inside the CardView would be problematic.
+        final float verticalOffset = mRawMaxShadowSize * SHADOW_MULTIPLIER;
+        mCardBounds.set(bounds.left + mRawMaxShadowSize, bounds.top + verticalOffset,
+                bounds.right - mRawMaxShadowSize, bounds.bottom - verticalOffset);
+        buildShadowCorners();
+    }
+
+    float getCornerRadius() {
+        return mCornerRadius;
+    }
+
+    void getMaxShadowAndCornerPadding(Rect into) {
+        getPadding(into);
+    }
+
+    void setShadowSize(float size) {
+        setShadowSize(size, mRawMaxShadowSize);
+    }
+
+    void setMaxShadowSize(float size) {
+        setShadowSize(mRawShadowSize, size);
+    }
+
+    float getShadowSize() {
+        return mRawShadowSize;
+    }
+
+    float getMaxShadowSize() {
+        return mRawMaxShadowSize;
+    }
+
+    float getMinWidth() {
+        final float content = 2 *
+                Math.max(mRawMaxShadowSize, mCornerRadius + mInsetShadow + mRawMaxShadowSize / 2);
+        return content + (mRawMaxShadowSize + mInsetShadow) * 2;
+    }
+
+    float getMinHeight() {
+        final float content = 2 * Math.max(mRawMaxShadowSize, mCornerRadius + mInsetShadow
+                + mRawMaxShadowSize * SHADOW_MULTIPLIER / 2);
+        return content + (mRawMaxShadowSize * SHADOW_MULTIPLIER + mInsetShadow) * 2;
+    }
+
+    public void setColor(int color) {
+        mPaint.setColor(color);
+        invalidateSelf();
+    }
+
+    static interface RoundRectHelper {
+        void drawRoundRect(Canvas canvas, RectF bounds, float cornerRadius, Paint paint);
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
index 6862f97e9..d17748b3c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
@@ -11,11 +11,7 @@
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.Path;
-import android.graphics.RectF;
+import android.graphics.*;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 import android.os.Build;
@@ -24,19 +20,12 @@
 import android.text.TextPaint;
 import android.util.SparseIntArray;
 import android.util.StateSet;
-import android.view.GestureDetector;
-import android.view.HapticFeedbackConstants;
-import android.view.MotionEvent;
-import android.view.SoundEffectConstants;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.ViewGroup;
-
+import android.view.*;
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.FileLog;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.support.widget.LinearLayoutManager;
 import org.telegram.messenger.support.widget.RecyclerView;
-import org.telegram.messenger.FileLog;
 import org.telegram.ui.ActionBar.Theme;
 
 import java.lang.reflect.Field;
@@ -1338,6 +1327,16 @@ protected void onDetachedFromWindow() {
         selectorRect.setEmpty();
     }
 
+    public void postAndNotifyAdapter() {
+        post(() -> {
+            if (!isComputingLayout()) {
+                getAdapter().notifyDataSetChanged();
+            } else {
+                postAndNotifyAdapter();
+            }
+        });
+    }
+
     public ArrayList<View> getHeaders() {
         return headers;
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/TabsView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/TabsView.java
index 26d9bba34..39298444d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/TabsView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/TabsView.java
@@ -327,17 +327,17 @@ private void unreadCount(final ArrayList<TLRPC.TL_dialog> dialogs, int position)
             for (int a = 0; a < dialogs.size(); a++) {
                 TLRPC.TL_dialog dialg = dialogs.get(a);
                 if (dialg != null && dialg.unread_count > 0) {
-                    boolean isMuted = MessagesController.getInstance(currentAccount).isDialogMuted(dialg.id);
-                    if (!isMuted) {
-                        i = dialg.unread_count;
-                        if (i == 0 && plusPreferences.getInt("unread_" + dialg.id, 0) == 1) i = 1;
-                        if (i > 0) {
-                            if (position == 0 || (position == 1 && isDirect(dialg)) || (position == 2 && isGroup(dialg)) || (position == 3 && isAnnouncement(dialg)) || (position == 4 & isFavorite(dialg))) {
-                                unreadCount++;
-                            }
-                            allMuted = false;
-                        }
+                    //boolean isMuted = MessagesController.getInstance(currentAccount).isDialogMuted(dialg.id);
+                    //if (!isMuted) {
+                    i = dialg.unread_count;
+                    //if (i == 0 && plusPreferences.getInt("unread_" + dialg.id, 0) == 1) i = 1;
+                    //if (i > 0) {
+                    if (position == 0 || (position == 1 && isDirect(dialg)) || (position == 2 && isGroup(dialg)) || (position == 3 && isAnnouncement(dialg)) || (position == 4 & isFavorite(dialg))) {
+                        unreadCount++;
                     }
+                    allMuted = false;
+                    //}
+                    //}
                 }
             }
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/UpdateAppAlertDialog.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/UpdateAppAlertDialog.java
index 0c49c9e3f..639818557 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/UpdateAppAlertDialog.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/UpdateAppAlertDialog.java
@@ -47,7 +47,7 @@ public UpdateAppAlertDialog(final Activity activity, TLRPC.TL_help_appUpdate upd
             setSecondTitle(AndroidUtilities.formatFileSize(appUpdate.document.size));
         }
         setDismissDialogByButtons(false);
-        setTitle(LocaleController.getString("UpdateTelegram", R.string.UpdateBettergram));
+        setTitle(LocaleController.getString("UpdateBettergram", R.string.UpdateBettergram));
         setPositiveButton(LocaleController.getString("UpdateNow", R.string.UpdateNow), new DialogInterface.OnClickListener() {
             @Override
             public void onClick(DialogInterface dialog, int which) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java
index 4d54c1017..80221974b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java
@@ -35,7 +35,7 @@
 import android.view.animation.DecelerateInterpolator;
 import android.widget.*;
 import io.bettergram.messenger.R;
-import io.bettergram.ui.adapters.BetterDialogsAdapter;
+import io.bettergram.ui.adapters.*;
 import org.telegram.messenger.*;
 import org.telegram.messenger.support.widget.LinearLayoutManager;
 import org.telegram.messenger.support.widget.LinearSmoothScrollerMiddle;
@@ -57,6 +57,10 @@
     private RecyclerListView listView;
     private LinearLayoutManager layoutManager;
     private BetterDialogsAdapter dialogsAdapter;
+    private NewsAdapter newsAdapter = new NewsAdapter();
+    private CryptoAdapter cryptoAdapter = new CryptoAdapter();
+    private YouTubePlayerAdapter videoAdapter;
+    private ResourcesAdapter resourcesAdapter = new ResourcesAdapter();
     private DialogsSearchAdapter dialogsSearchAdapter;
     private EmptyTextProgressView searchEmptyView;
     private RadialProgressView progressView;
@@ -105,6 +109,8 @@
     private boolean cantSendToChannels;
     private boolean allowSwitchAccount;
 
+    private int currentBottomTabPosition = 0;
+
     private DialogsActivityDelegate delegate;
 
     public interface DialogsActivityDelegate {
@@ -171,6 +177,7 @@ public boolean onFragmentCreate() {
             DataQuery.getInstance(currentAccount).checkFeaturedStickers();
             dialogsLoaded[currentAccount] = true;
         }
+
         return true;
     }
 
@@ -207,6 +214,7 @@ public void onFragmentDestroy() {
         delegate = null;
     }
 
+    @SuppressLint("DefaultLocale")
     @Override
     public View createView(final Context context) {
         searching = false;
@@ -275,7 +283,7 @@ public void onSearchCollapse() {
                         }
                         floatingHidden = true;
                         floatingButton.setTranslationY(AndroidUtilities.dp(100));
-                        hideFloatingButton(false);
+                        hideFloatingButton(false, false);
                     }
                     if (listView.getAdapter() != dialogsAdapter) {
                         listView.setAdapter(dialogsAdapter);
@@ -330,7 +338,7 @@ public void onTextChanged(EditText editText) {
             actionBar.setSupportsHolidayImage(true);
         }
         actionBar.setTitleActionRunnable(() -> {
-            hideFloatingButton(false);
+            hideFloatingButton(false, false);
             listView.smoothScrollToPosition(0);
         });
 
@@ -853,7 +861,7 @@ public boolean onItemClick(View view, int position, float x, float y) {
                                 newTabsView.postDelayed(newTabsView::forceRefreshAction, 500);
                             } else if (which == 1) {
                                 if (MessagesController.getInstance(currentAccount).pinDialog(selectedDialog, !pinned, null, 0) && !pinned) {
-                                    hideFloatingButton(false);
+                                    hideFloatingButton(false, false);
                                     listView.smoothScrollToPosition(0);
                                 }
                             } else if (which == 3) {
@@ -927,7 +935,7 @@ public boolean onItemClick(View view, int position, float x, float y) {
                                 newTabsView.postDelayed(newTabsView::forceRefreshAction, 500);
                             } else if (which == 1) {
                                 if (MessagesController.getInstance(currentAccount).pinDialog(selectedDialog, !pinned, null, 0) && !pinned) {
-                                    hideFloatingButton(false);
+                                    hideFloatingButton(false, false);
                                     listView.smoothScrollToPosition(0);
                                 }
                             } else if (which == 3) {
@@ -1081,7 +1089,7 @@ public void getOutline(View view, Outline outline) {
                         }
                     }
                     if (!found) {
-                        hideFloatingButton(false);
+                        hideFloatingButton(false, false);
                         listView.smoothScrollToPosition(0);
                     }
                 }
@@ -1164,17 +1172,19 @@ public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                 int visibleItemCount = Math.abs(layoutManager.findLastVisibleItemPosition() - firstVisibleItem) + 1;
                 int totalItemCount = recyclerView.getAdapter().getItemCount();
 
-                if (searching && searchWas) {
-                    if (visibleItemCount > 0 && layoutManager.findLastVisibleItemPosition() == totalItemCount - 1 && !dialogsSearchAdapter.isMessagesSearchEndReached()) {
-                        dialogsSearchAdapter.loadMoreSearchMessages();
+                if (currentBottomTabPosition == 0) {
+                    if (searching && searchWas) {
+                        if (visibleItemCount > 0 && layoutManager.findLastVisibleItemPosition() == totalItemCount - 1 && !dialogsSearchAdapter.isMessagesSearchEndReached()) {
+                            dialogsSearchAdapter.loadMoreSearchMessages();
+                        }
+                        return;
                     }
-                    return;
-                }
-                if (visibleItemCount > 0) {
-                    if (layoutManager.findLastVisibleItemPosition() >= dialogsAdapter.getDialogsArray().size() - 10) {
-                        boolean fromCache = !MessagesController.getInstance(currentAccount).dialogsEndReached;
-                        if (fromCache || !MessagesController.getInstance(currentAccount).serverDialogsEndReached) {
-                            listView.post(() -> MessagesController.getInstance(currentAccount).loadDialogs(-1, 100, fromCache));
+                    if (visibleItemCount > 0) {
+                        if (layoutManager.findLastVisibleItemPosition() >= dialogsAdapter.getDialogsArray().size() - 10) {
+                            boolean fromCache = !MessagesController.getInstance(currentAccount).dialogsEndReached;
+                            if (fromCache || !MessagesController.getInstance(currentAccount).serverDialogsEndReached) {
+                                listView.post(() -> MessagesController.getInstance(currentAccount).loadDialogs(-1, 100, fromCache));
+                            }
                         }
                     }
                 }
@@ -1197,7 +1207,7 @@ public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                         goingDown = firstVisibleItem > prevPosition;
                     }
                     if (changed && scrollUpdated && (goingDown || !goingDown && scrollingManually)) {
-                        hideFloatingButton(goingDown);
+                        hideFloatingButton(goingDown, false);
                     }
                     prevPosition = firstVisibleItem;
                     prevTop = firstViewTop;
@@ -1328,12 +1338,65 @@ public void onMessageSend(CharSequence message) {
             });
         }
 
+        Activity activity = getParentActivity();
+        if (activity != null) {
+
+            cryptoAdapter.startService(activity);
+
+            newsAdapter.startService(getParentActivity());
+
+            if (videoAdapter == null) {
+                videoAdapter = new YouTubePlayerAdapter(activity);
+            }
+
+            videoAdapter.startService(activity);
+
+            resourcesAdapter.startService(activity);
+        }
+
         BottomNavigationBar bottomBar = new BottomNavigationBar(context)
                 .setOnSelectListener((position, title) -> {
+                    currentBottomTabPosition = position;
                     actionBar.setTitle(title);
                     boolean isChat = position == 0;
-                    hideFloatingButton(!isChat);
+                    hideFloatingButton(!isChat, true);
                     newTabsView.hide(!isChat);
+
+                    ActionBarMenuItem itemSearch = menu.getItem(0);
+                    itemSearch.setVisibility(!isChat ? View.GONE : View.VISIBLE);
+                    //Handler handler = getParentActivity().getWindow().getDecorView().getHandler();
+                    switch (position) {
+                        case 0:
+                            if (!(listView.getAdapter() instanceof BetterDialogsAdapter)) {
+                                listView.setAdapter(dialogsAdapter);
+                                //handler.postDelayed(dialogsAdapter::notifyDataSetChanged, 1000);
+                            }
+                            break;
+                        case 1:
+                            if (!(listView.getAdapter() instanceof CryptoAdapter)) {
+                                listView.setAdapter(cryptoAdapter);
+                                //handler.postDelayed(cryptoAdapter::notifyDataSetChanged, 1000);
+                            }
+                            break;
+                        case 2:
+                            if (!(listView.getAdapter() instanceof NewsAdapter)) {
+                                listView.setAdapter(newsAdapter);
+                                //handler.postDelayed(newsAdapter::notifyDataSetChanged, 1000);
+                            }
+                            break;
+                        case 3:
+                            if (!(listView.getAdapter() instanceof YouTubePlayerAdapter)) {
+                                listView.setAdapter(videoAdapter);
+                                //handler.postDelayed(videoAdapter::notifyDataSetChanged, 1000);
+                            }
+                            break;
+                        case 4:
+                            if (!(listView.getAdapter() instanceof ResourcesAdapter)) {
+                                listView.setAdapter(resourcesAdapter);
+                                //handler.postDelayed(resourcesAdapter::notifyDataSetChanged, 1000);
+                            }
+                            break;
+                    }
                 })
                 .setOnReselectListener((position, title) -> actionBar.setTitle(title))
                 .selectTabAndTriggerListener(0, true);
@@ -1384,6 +1447,22 @@ public void onResume() {
                 }
             }
         }
+
+        Activity activity = getParentActivity();
+        if (activity != null) {
+            if (cryptoAdapter != null) {
+                cryptoAdapter.registerReceiver(activity);
+            }
+            if (newsAdapter != null) {
+                newsAdapter.registerReceiver(activity);
+            }
+            if (videoAdapter != null) {
+                videoAdapter.registerReceiver(activity);
+            }
+            if (resourcesAdapter != null) {
+                resourcesAdapter.registerReceiver(activity);
+            }
+        }
     }
 
     @Override
@@ -1392,6 +1471,21 @@ public void onPause() {
         if (commentView != null) {
             commentView.onResume();
         }
+        Activity activity = getParentActivity();
+        if (activity != null) {
+            if (cryptoAdapter != null) {
+                cryptoAdapter.unregisterReceiver(activity);
+            }
+            if (newsAdapter != null) {
+                newsAdapter.unregisterReceiver(activity);
+            }
+            if (videoAdapter != null) {
+                videoAdapter.unregisterReceiver(activity);
+            }
+            if (resourcesAdapter != null) {
+                resourcesAdapter.unregisterReceiver(activity);
+            }
+        }
     }
 
     private void checkUnreadCount(boolean animated) {
@@ -1774,7 +1868,7 @@ private void updatePasscodeButton() {
         }
     }
 
-    private void hideFloatingButton(boolean hide) {
+    private void hideFloatingButton(boolean hide, boolean changingTab) {
         if (floatingHidden == hide) {
             return;
         }
@@ -1784,6 +1878,31 @@ private void hideFloatingButton(boolean hide) {
                 ObjectAnimator.ofFloat(unreadFloatingButtonContainer, "translationY", floatingHidden ? AndroidUtilities.dp(74) : 0));
         animatorSet.setDuration(300);
         animatorSet.setInterpolator(floatingInterpolator);
+        animatorSet.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                if (changingTab && floatingButton.getVisibility() == View.GONE && currentBottomTabPosition == 0) {
+                    floatingButton.setVisibility(View.VISIBLE);
+                }
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (changingTab && floatingButton.getVisibility() == View.VISIBLE && currentBottomTabPosition > 0) {
+                    floatingButton.setVisibility(View.GONE);
+                }
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+        });
         floatingButton.setClickable(!hide);
         animatorSet.start();
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
index 6100752e4..1501e7650 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
@@ -376,7 +376,7 @@ protected void onLayout(boolean changed, int l, int t, int r, int b) {
                     presentFragment(new SettingsActivity());
                     drawerLayoutContainer.closeDrawer(false);
                 } else if (id == 9) {
-                    Browser.openUrl(LaunchActivity.this, LocaleController.getString("TelegramFaqUrl", R.string.TelegramFaqUrl));
+                    Browser.openUrl(LaunchActivity.this, LocaleController.getString("BettergramFaqUrl", R.string.BettergramFaqUrl));
                     drawerLayoutContainer.closeDrawer(false);
                 } else if (id == 10) {
                     presentFragment(new CallLogActivity());
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PassportActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PassportActivity.java
index 9d6c1eb03..05cc14498 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PassportActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PassportActivity.java
@@ -1482,7 +1482,7 @@ private void createPasswordInterface(Context context) {
 
         FrameLayout frameLayout = (FrameLayout) fragmentView;
 
-        actionBar.setTitle(LocaleController.getString("TelegramPassport", R.string.BettergramPassport));
+        actionBar.setTitle(LocaleController.getString("BettergramPassport", R.string.BettergramPassport));
 
         emptyView = new EmptyTextProgressView(context);
         emptyView.showProgress();
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
index 7f633a7a0..029ad2612 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
@@ -511,7 +511,7 @@ public void onClick(View widget) {
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
                     showDialog(builder.create());
                 } else if (position == telegramFaqRow) {
-                    Browser.openUrl(getParentActivity(), LocaleController.getString("TelegramFaqUrl", R.string.TelegramFaqUrl));
+                    Browser.openUrl(getParentActivity(), LocaleController.getString("BettergramFaqUrl", R.string.BettergramFaqUrl));
                 } else if (position == privacyPolicyRow) {
                     Browser.openUrl(getParentActivity(), LocaleController.getString("PrivacyPolicyUrl", R.string.PrivacyPolicyUrl));
                 } else if (position == contactsReimportRow) {
@@ -1202,7 +1202,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
                     } else if (position == switchBackendButtonRow) {
                         textCell.setText("Switch Backend", true);
                     } else if (position == telegramFaqRow) {
-                        textCell.setText(LocaleController.getString("TelegramFAQ", R.string.BettergramFAQ), true);
+                        textCell.setText(LocaleController.getString("BettergramFAQ", R.string.BettergramFAQ), true);
                     } else if (position == contactsReimportRow) {
                         textCell.setText(LocaleController.getString("ImportContacts", R.string.ImportContacts), true);
                     } else if (position == stickersRow) {
diff --git a/TMessagesProj/src/main/res/drawable/ic_account_circle.xml b/TMessagesProj/src/main/res/drawable/ic_account_circle.xml
new file mode 100644
index 000000000..232b90bb7
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_account_circle.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp"
+        android:tint="#707A75"
+        android:viewportHeight="24.0"
+        android:viewportWidth="24.0"
+        android:width="24dp">
+    <path
+            android:fillColor="#FF000000"
+            android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,5c1.66,0 3,1.34 3,3s-1.34,3 -3,3 -3,-1.34 -3,-3 1.34,-3 3,-3zM12,19.2c-2.5,0 -4.71,-1.28 -6,-3.22 0.03,-1.99 4,-3.08 6,-3.08 1.99,0 5.97,1.09 6,3.08 -1.29,1.94 -3.5,3.22 -6,3.22z"/>
+</vector>
diff --git a/TMessagesProj/src/main/res/drawable/ic_arrow_price_down.xml b/TMessagesProj/src/main/res/drawable/ic_arrow_price_down.xml
new file mode 100644
index 000000000..f0b60d55f
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_arrow_price_down.xml
@@ -0,0 +1,5 @@
+<vector android:height="24dp" android:tint="#FFFF0000"
+    android:viewportHeight="24.0" android:viewportWidth="24.0"
+    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="#FF000000" android:pathData="M7,10l5,5 5,-5z"/>
+</vector>
diff --git a/TMessagesProj/src/main/res/drawable/ic_arrow_price_up.xml b/TMessagesProj/src/main/res/drawable/ic_arrow_price_up.xml
new file mode 100644
index 000000000..1c4b7db57
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_arrow_price_up.xml
@@ -0,0 +1,5 @@
+<vector android:height="24dp" android:tint="#69BC35"
+    android:viewportHeight="24.0" android:viewportWidth="24.0"
+    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="#FF000000" android:pathData="M7,14l5,-5 5,5z"/>
+</vector>
diff --git a/TMessagesProj/src/main/res/drawable/ic_date.xml b/TMessagesProj/src/main/res/drawable/ic_date.xml
new file mode 100644
index 000000000..2c67a83ec
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_date.xml
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:height="24dp"
+        android:tint="#707A75"
+        android:viewportHeight="24"
+        android:viewportWidth="24"
+        android:width="24dp">
+    <path
+            android:fillColor="#FF000000"
+            android:pathData="M17,12h-5v5h5v-5zM16,1v2L8,3L8,1L6,1v2L5,3c-1.11,0 -1.99,0.9 -1.99,2L3,19c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2h-1L18,1h-2zM19,19L5,19L5,8h14v11z"/>
+</vector>
diff --git a/TMessagesProj/src/main/res/drawable/ic_views.xml b/TMessagesProj/src/main/res/drawable/ic_views.xml
new file mode 100644
index 000000000..ee16dad22
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_views.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:height="24dp"
+  android:viewportHeight="24"
+  android:viewportWidth="24"
+  android:width="24dp">
+  <path
+    android:fillColor="#FF707a75"
+    android:pathData="M12,4.5C7,4.5 2.73,7.61 1,12c1.73,4.39 6,7.5 11,7.5s9.27,-3.11 11,-7.5c-1.73,-4.39 -6,-7.5 -11,-7.5zM12,17c-2.76,0 -5,-2.24 -5,-5s2.24,-5 5,-5 5,2.24 5,5 -2.24,5 -5,5zM12,9c-1.66,0 -3,1.34 -3,3s1.34,3 3,3 3,-1.34 3,-3 -1.34,-3 -3,-3z"/>
+</vector>
diff --git a/TMessagesProj/src/main/res/drawable/youtube_duration_bg.xml b/TMessagesProj/src/main/res/drawable/youtube_duration_bg.xml
new file mode 100644
index 000000000..2d9a0063f
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/youtube_duration_bg.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <solid android:color="#8C000000"/>
+    <corners android:radius="2dp"/>
+</shape>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/header_crypto.xml b/TMessagesProj/src/main/res/layout/header_crypto.xml
new file mode 100644
index 000000000..7b60c7bac
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/header_crypto.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="utf-8"?>
+<org.telegram.ui.Components.CardView.CardView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingTop="16dp"
+        android:paddingBottom="16dp"
+        android:paddingStart="8dp"
+        android:paddingEnd="8dp"
+        app:cardCornerRadius="4dp"
+        app:cardUseCompatPadding="true"
+        android:elevation="2dp">
+
+    <LinearLayout
+            android:layout_marginTop="16dp"
+            android:layout_marginBottom="16dp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+        <TextView
+                android:id="@+id/textCap"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center"
+                android:textSize="18sp"/>
+
+        <TextView
+                android:id="@+id/textDom"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center"
+                android:textSize="18sp"/>
+
+        <TextView
+                android:id="@+id/textVol"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center"
+                android:textSize="18sp"/>
+    </LinearLayout>
+</org.telegram.ui.Components.CardView.CardView>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/item_crypto.xml b/TMessagesProj/src/main/res/layout/item_crypto.xml
new file mode 100644
index 000000000..406e90cf7
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/item_crypto.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              xmlns:tools="http://schemas.android.com/tools"
+              android:layout_width="match_parent"
+              android:layout_height="wrap_content"
+              android:layout_marginTop="2dp"
+              android:layout_marginBottom="2dp"
+              android:orientation="horizontal"
+              android:weightSum="1">
+
+    <LinearLayout
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.50"
+            android:padding="8dp"
+            android:orientation="horizontal">
+
+        <com.sackcentury.shinebuttonlib.ShineButton
+                android:id="@+id/star"
+                android:layout_width="22dp"
+                android:layout_height="22dp"
+                android:layout_marginEnd="8dp"
+                android:layout_gravity="center"
+                app:btn_color="@android:color/darker_gray"
+                app:btn_fill_color="#ffc200"
+                app:enable_flashing="true"
+                app:shine_size="14dp"
+                app:siShape="@raw/star"/>
+
+        <ImageView
+                android:id="@+id/imageCrypto"
+                android:layout_width="32dp"
+                android:layout_height="32dp"
+                android:layout_marginStart="16dp"
+                android:layout_marginEnd="4dp"
+                android:layout_gravity="center"
+                tools:ignore="ContentDescription"/>
+
+        <TextView
+                android:id="@+id/textCryptoName"
+                android:textStyle="bold"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:layout_marginStart="8dp"
+                android:ellipsize="end"
+                android:gravity="center"
+                android:maxLines="1"
+                android:textColor="@color/black"
+                android:textSize="14sp"/>
+
+    </LinearLayout>
+
+    <TextView
+            android:id="@+id/textCryptoPrice"
+            android:textStyle="normal"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.25"
+            android:layout_gravity="center"
+            android:gravity="center"
+            android:textColor="#ff3d4b43"
+            android:textSize="14sp"/>
+
+    <TextView
+            android:id="@+id/textDayDelta"
+            android:textStyle="normal"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.25"
+            android:layout_marginEnd="8dp"
+            android:layout_gravity="center"
+            android:gravity="center|end"
+            android:textColor="#ff69bc35"
+            android:textSize="14sp"/>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/item_crypto_top.xml b/TMessagesProj/src/main/res/layout/item_crypto_top.xml
new file mode 100644
index 000000000..932607370
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/item_crypto_top.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="42dp"
+              android:paddingTop="8dp"
+              android:paddingBottom="8dp"
+              android:background="@null"
+              android:orientation="horizontal"
+              android:weightSum="1">
+
+    <TextView
+            android:textStyle="bold"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.5"
+            android:layout_gravity="center"
+            android:gravity="center"
+            android:text="@string/code"
+            android:textColor="@color/grey3d"
+            android:textSize="14sp"/>
+
+    <TextView
+            android:textStyle="bold"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.25"
+            android:layout_gravity="center"
+            android:gravity="center"
+            android:text="@string/price"
+            android:textColor="@color/grey3d"
+            android:textSize="14sp"/>
+
+    <TextView
+            android:textStyle="bold"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.25"
+            android:layout_gravity="center"
+            android:gravity="center"
+            android:text="@string/_24h"
+            android:textColor="@color/grey3d"
+            android:textSize="14sp"/>
+</LinearLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/item_news_big.xml b/TMessagesProj/src/main/res/layout/item_news_big.xml
new file mode 100644
index 000000000..2440fab48
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/item_news_big.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="utf-8"?>
+<org.telegram.ui.Components.CardView.CardView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="4dp"
+        android:layout_marginBottom="4dp"
+        android:layout_marginStart="8dp"
+        android:layout_marginEnd="8dp"
+        app:cardCornerRadius="4dp"
+        app:cardUseCompatPadding="true"
+        android:elevation="2dp">
+
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+        <TextView
+                android:id="@+id/textTitle"
+                android:textStyle="bold"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="8dp"
+                android:layout_marginBottom="8dp"
+                android:layout_marginStart="4dp"
+                android:layout_marginEnd="4dp"
+                android:background="?android:attr/selectableItemBackground"
+                android:ellipsize="end"
+                android:gravity="start"
+                android:maxLines="2"
+                android:textSize="16sp"/>
+
+        <LinearLayout
+                android:id="@+id/container_text"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginBottom="8dp"
+                android:layout_marginStart="4dp"
+                android:layout_marginEnd="4dp"
+                android:orientation="horizontal"
+                android:weightSum="2">
+
+            <TextView
+                    android:id="@+id/textAccount"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:layout_margin="0dp"
+                    android:drawablePadding="2dp"
+                    android:drawableStart="@drawable/ic_account_circle"
+                    android:ellipsize="end"
+                    android:gravity="center_vertical"
+                    android:maxLines="1"
+                    android:textSize="12sp"/>
+
+            <TextView
+                    android:id="@+id/textDatePosted"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:layout_margin="0dp"
+                    android:drawablePadding="2dp"
+                    android:drawableStart="@drawable/ic_date"
+                    android:gravity="center_vertical"
+                    android:textSize="12sp"/>
+
+        </LinearLayout>
+
+        <ImageView
+                android:id="@+id/imageThumb"
+                android:layout_width="match_parent"
+                android:layout_height="152dp"
+                android:adjustViewBounds="true"
+                android:layout_margin="0dp"
+                android:layout_gravity="center"
+                android:elevation="2dp"
+                android:scaleType="centerCrop"
+                tools:ignore="ContentDescription"/>
+
+    </LinearLayout>
+
+</org.telegram.ui.Components.CardView.CardView>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/item_news_small.xml b/TMessagesProj/src/main/res/layout/item_news_small.xml
new file mode 100644
index 000000000..d343cc071
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/item_news_small.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="utf-8"?>
+<org.telegram.ui.Components.CardView.CardView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="4dp"
+        android:layout_marginBottom="4dp"
+        android:layout_marginStart="8dp"
+        android:layout_marginEnd="8dp"
+        app:cardCornerRadius="4dp"
+        app:cardUseCompatPadding="true"
+        android:elevation="2dp">
+
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+        <ImageView
+                android:id="@+id/imageThumb"
+                android:layout_width="94dp"
+                android:layout_height="94dp"
+                android:layout_marginStart="0dp"
+                android:elevation="2dp"
+                android:layout_marginEnd="4dp"
+                android:layout_gravity="center"
+                android:adjustViewBounds="true"
+                android:scaleType="centerCrop"
+                tools:ignore="ContentDescription"/>
+
+        <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+
+            <TextView
+                    android:id="@+id/textTitle"
+                    android:textStyle="bold"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:layout_marginTop="16dp"
+                    android:layout_marginBottom="8dp"
+                    android:layout_marginStart="4dp"
+                    android:layout_marginEnd="4dp"
+                    android:background="?android:attr/selectableItemBackground"
+                    android:ellipsize="end"
+                    android:gravity="start"
+                    android:maxLines="2"
+                    android:textSize="16sp"/>
+
+            <LinearLayout
+                    android:id="@+id/container_text"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:layout_marginBottom="8dp"
+                    android:layout_marginStart="4dp"
+                    android:layout_marginEnd="4dp"
+                    android:orientation="horizontal"
+                    android:weightSum="2">
+
+                <TextView
+                        android:id="@+id/textAccount"
+                        android:layout_width="0dp"
+                        android:layout_height="wrap_content"
+                        android:layout_weight="1"
+                        android:layout_margin="0dp"
+                        android:drawablePadding="2dp"
+                        android:drawableStart="@drawable/ic_account_circle"
+                        android:ellipsize="end"
+                        android:gravity="center_vertical"
+                        android:maxLines="1"
+                        android:textSize="12sp"/>
+
+                <TextView
+                        android:id="@+id/textDatePosted"
+                        android:layout_width="0dp"
+                        android:layout_height="wrap_content"
+                        android:layout_weight="1"
+                        android:layout_margin="0dp"
+                        android:drawablePadding="2dp"
+                        android:drawableStart="@drawable/ic_date"
+                        android:gravity="center_vertical"
+                        android:textSize="12sp"/>
+
+            </LinearLayout>
+
+        </LinearLayout>
+    </LinearLayout>
+
+</org.telegram.ui.Components.CardView.CardView>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/item_resource_content.xml b/TMessagesProj/src/main/res/layout/item_resource_content.xml
new file mode 100644
index 000000000..2c5e34548
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/item_resource_content.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:tools="http://schemas.android.com/tools"
+              android:layout_width="match_parent"
+              android:layout_height="wrap_content"
+              android:orientation="horizontal"
+              android:layout_margin="4dp"
+              android:clickable="true"
+              android:focusable="true">
+
+    <ImageView
+            android:id="@+id/imageResource"
+            android:layout_width="32dp"
+            android:layout_height="32dp"
+            android:layout_marginStart="16dp"
+            android:layout_marginEnd="4dp"
+            android:layout_marginTop="4dp"
+            android:layout_marginBottom="4dp"
+            android:layout_gravity="center"
+            tools:ignore="ContentDescription"
+            android:clickable="false"
+            android:focusable="false"/>
+
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="4dp"
+            android:layout_marginBottom="4dp"
+            android:layout_gravity="center"
+            android:orientation="vertical"
+            android:clickable="false"
+            android:focusable="false">
+
+        <TextView
+                android:id="@+id/textName"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="18sp"
+                android:textColor="@android:color/black"
+                android:layout_gravity="center|start"
+                android:clickable="false"
+                android:focusable="false"/>
+
+        <TextView
+                android:id="@+id/textDesc"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp"
+                android:textColor="@android:color/darker_gray"
+                android:ellipsize="end"
+                android:layout_gravity="center|start"
+                android:clickable="false"
+                android:focusable="false"/>
+
+    </LinearLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/item_resource_header.xml b/TMessagesProj/src/main/res/layout/item_resource_header.xml
new file mode 100644
index 000000000..55a9fbd1a
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/item_resource_header.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="wrap_content"
+              android:orientation="horizontal"
+              android:layout_margin="8dp">
+
+    <TextView
+            android:id="@+id/textTitle"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="18sp"
+            android:textColor="@android:color/black"
+            android:layout_gravity="center"/>
+
+    <View
+            android:layout_width="match_parent"
+            android:layout_height="1dp"
+            android:layout_gravity="center"
+            android:background="@android:color/darker_gray"
+            android:layout_marginStart="16dp"/>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/youtube_player.xml b/TMessagesProj/src/main/res/layout/youtube_player.xml
new file mode 100644
index 000000000..1fe64b4be
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/youtube_player.xml
@@ -0,0 +1,106 @@
+<?xml version="1.0" encoding="utf-8"?>
+<org.telegram.ui.Components.CardView.CardView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_margin="16dp"
+        android:elevation="2dp"
+        app:cardCornerRadius="4dp"
+        app:cardUseCompatPadding="true"
+        android:minHeight="200dp">
+
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="16dp"
+            android:orientation="vertical">
+
+        <!--<FrameLayout-->
+        <!--android:layout_width="wrap_content"-->
+        <!--android:layout_height="wrap_content">-->
+
+        <com.flipkart.youtubeview.YouTubePlayerView
+                android:id="@+id/youtube_player_view"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"/>
+
+        <!--<TextView-->
+        <!--android:id="@+id/textDuration"-->
+        <!--android:layout_width="wrap_content"-->
+        <!--android:layout_height="wrap_content"-->
+        <!--android:layout_margin="8dp"-->
+        <!--android:layout_gravity="bottom|end"-->
+        <!--android:paddingTop="2dp"-->
+        <!--android:paddingBottom="2dp"-->
+        <!--android:paddingStart="4dp"-->
+        <!--android:paddingEnd="4dp"-->
+        <!--android:background="@drawable/youtube_duration_bg"-->
+        <!--android:textColor="@android:color/white"-->
+        <!--android:visibility="gone"/>-->
+        <!--</FrameLayout>-->
+
+        <TextView
+                android:id="@+id/textTitle"
+                android:textStyle="bold"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp"
+                android:layout_marginBottom="16dp"
+                android:layout_marginStart="4dp"
+                android:layout_marginEnd="4dp"
+                android:ellipsize="end"
+                android:gravity="start"
+                android:maxLines="2"
+                android:textSize="16sp"/>
+
+        <LinearLayout
+                android:id="@+id/container_text"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginBottom="16dp"
+                android:layout_marginStart="4dp"
+                android:layout_marginEnd="4dp"
+                android:orientation="horizontal"
+                android:weightSum="3">
+
+            <TextView
+                    android:id="@+id/textAccount"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:layout_margin="0dp"
+                    android:drawablePadding="2dp"
+                    android:drawableStart="@drawable/ic_account_circle"
+                    android:ellipsize="end"
+                    android:gravity="center_vertical"
+                    android:maxLines="1"
+                    android:textSize="12sp"/>
+
+            <TextView
+                    android:id="@+id/textDatePosted"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:layout_margin="0dp"
+                    android:drawablePadding="2dp"
+                    android:drawableStart="@drawable/ic_date"
+                    android:gravity="center_vertical"
+                    android:textSize="12sp"/>
+
+            <TextView
+                    android:id="@+id/textViewCount"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:layout_margin="0dp"
+                    android:drawablePadding="2dp"
+                    android:drawableStart="@drawable/ic_views"
+                    android:gravity="center_vertical"
+                    android:textSize="12sp"/>
+
+        </LinearLayout>
+
+    </LinearLayout>
+
+</org.telegram.ui.Components.CardView.CardView>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-ar/strings.xml b/TMessagesProj/src/main/res/values-ar/strings.xml
index cd6a820e4..1d0454489 100644
--- a/TMessagesProj/src/main/res/values-ar/strings.xml
+++ b/TMessagesProj/src/main/res/values-ar/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq"> </string>
     <string name="AddAccount"> </string>
     <string name="SelectAccount"> </string>
-    <string name="TelegramFaqUrl">https://telegram.org/faq/ar</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy"> </string>
     <string name="TermsOfService"> </string>
     <string name="TermsOfServiceLogin">  \n   * *.</string>
-    <string name="PrivacyPolicyUrl">https://telegram.org/faq/ar#a10</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization"> </string>
     <string name="IncorrectLocalization">   </string>
     <string name="NotificationsService">   </string>
diff --git a/TMessagesProj/src/main/res/values-de/strings.xml b/TMessagesProj/src/main/res/values-de/strings.xml
index 23fb81dba..839b38269 100644
--- a/TMessagesProj/src/main/res/values-de/strings.xml
+++ b/TMessagesProj/src/main/res/values-de/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq">Fragen und Antworten</string>
     <string name="AddAccount">Konto hinzufgen</string>
     <string name="SelectAccount">Konto auswhlen</string>
-    <string name="TelegramFaqUrl">https://Bettergram.org/faq/de</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">Datenschutzerklrung</string>
     <string name="TermsOfService">Nutzungsbedingungen</string>
     <string name="TermsOfServiceLogin">Mit der Registrierung\nstimmst du den *Nutzungsbedingungen* zu.</string>
-    <string name="PrivacyPolicyUrl">https://Bettergram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization">Lokalisierung lschen?</string>
     <string name="IncorrectLocalization">Falsche Sprachdatei</string>
     <string name="NotificationsService">Keep-Alive-Dienst</string>
diff --git a/TMessagesProj/src/main/res/values-es/strings.xml b/TMessagesProj/src/main/res/values-es/strings.xml
index 927aaf704..de808c816 100644
--- a/TMessagesProj/src/main/res/values-es/strings.xml
+++ b/TMessagesProj/src/main/res/values-es/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq">Preguntas frecuentes</string>
     <string name="AddAccount">Aadir cuenta</string>
     <string name="SelectAccount">Elegir cuenta</string>
-    <string name="TelegramFaqUrl">https://Bettergram.org/faq/es</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">Poltica de privacidad</string>
     <string name="TermsOfService">Trminos de servicio</string>
     <string name="TermsOfServiceLogin">Al inscribirte,\naceptas los *trminos de servicio*.</string>
-    <string name="PrivacyPolicyUrl">https://Bettergram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization">Eliminar traduccin?</string>
     <string name="IncorrectLocalization">Archivo de traduccin incorrecto</string>
     <string name="NotificationsService">Servicio keep-alive</string>
diff --git a/TMessagesProj/src/main/res/values-it/strings.xml b/TMessagesProj/src/main/res/values-it/strings.xml
index 900b1ec62..35def0472 100644
--- a/TMessagesProj/src/main/res/values-it/strings.xml
+++ b/TMessagesProj/src/main/res/values-it/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq">Domande frequenti</string>
     <string name="AddAccount">Aggiungi account</string>
     <string name="SelectAccount">Seleziona Account</string>
-    <string name="TelegramFaqUrl">https://Bettergram.org/faq/it</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">Informativa sulla privacy</string>
     <string name="TermsOfService">Termini di servizio</string>
     <string name="TermsOfServiceLogin">Iscrivendoti,\naccetti i *Termini di servizio*.</string>
-    <string name="PrivacyPolicyUrl">https://Bettergram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization">Eliminare la traduzione?</string>
     <string name="IncorrectLocalization">File di traduzione non valido</string>
     <string name="NotificationsService">Servizio keep-alive</string>
diff --git a/TMessagesProj/src/main/res/values-ko/strings.xml b/TMessagesProj/src/main/res/values-ko/strings.xml
index 57bb73ee8..3aa2b98d8 100644
--- a/TMessagesProj/src/main/res/values-ko/strings.xml
+++ b/TMessagesProj/src/main/res/values-ko/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq">  </string>
     <string name="AddAccount"> </string>
     <string name="SelectAccount"> </string>
-    <string name="TelegramFaqUrl">https://Bettergram.org/faq/ko</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">  </string>
     <string name="TermsOfService"> </string>
     <string name="TermsOfServiceLogin">  * *  .</string>
-    <string name="PrivacyPolicyUrl">https://Bettergram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization"> ?</string>
     <string name="IncorrectLocalization">   </string>
     <string name="NotificationsService">  </string>
diff --git a/TMessagesProj/src/main/res/values-nl/strings.xml b/TMessagesProj/src/main/res/values-nl/strings.xml
index b7c5fa3c7..82bb5b682 100644
--- a/TMessagesProj/src/main/res/values-nl/strings.xml
+++ b/TMessagesProj/src/main/res/values-nl/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq">Veelgestelde vragen</string>
     <string name="AddAccount">Account toevoegen</string>
     <string name="SelectAccount">Account kiezen</string>
-    <string name="TelegramFaqUrl">https://Bettergram.org/faq</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">Privacybeleid</string>
     <string name="TermsOfService">Gebruiksvoorwaarden</string>
     <string name="TermsOfServiceLogin">Door aan te melden ga je akkoord \nmet onze *Gebruiksvoorwaarden*.</string>
-    <string name="PrivacyPolicyUrl">https://Bettergram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization">Vertaling verwijderen?</string>
     <string name="IncorrectLocalization">Ongeldig vertalingsbestand</string>
     <string name="NotificationsService">Meldingenservice</string>
diff --git a/TMessagesProj/src/main/res/values-pt-rBR/strings.xml b/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
index 058126aed..87785d54f 100644
--- a/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
+++ b/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
@@ -990,11 +990,11 @@
     <string name="BettergramFaq">Perguntas Frequentes</string>
     <string name="AddAccount">Adicionar&#160;Conta</string>
     <string name="SelectAccount">Select Account</string>
-    <string name="TelegramFaqUrl">https://Bettergram.org/faq/br</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">Poltica de Privacidade</string>
     <string name="TermsOfService">Termos de Servio</string>
     <string name="TermsOfServiceLogin">Ao se cadastrar,\nvoc concorda com os *Termos de Servio*.</string>
-    <string name="PrivacyPolicyUrl">https://Bettergram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization">Apagar localizao?</string>
     <string name="IncorrectLocalization">Arquivo de localizao incorreto</string>
     <string name="NotificationsService">Manter Servio Ativo</string>
diff --git a/TMessagesProj/src/main/res/values/api_keys.xml b/TMessagesProj/src/main/res/values/api_keys.xml
new file mode 100644
index 000000000..ce70f059a
--- /dev/null
+++ b/TMessagesProj/src/main/res/values/api_keys.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="youtube_api_key">AIzaSyCszABz27ta0sUwJmtuGQWY9MxsOE6Cpt8</string>
+</resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values/card_view.xml b/TMessagesProj/src/main/res/values/card_view.xml
new file mode 100644
index 000000000..d8c57c117
--- /dev/null
+++ b/TMessagesProj/src/main/res/values/card_view.xml
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <!-- From: file:/usr/local/google/buildbot/repo_clients/https___googleplex-android.googlesource.com_a_platform_manifest.git/lmp-preview-release/frameworks/support/v7/cardview/res/values/colors.xml -->
+    <eat-comment/>
+
+    <color name="cardview_dark_background">#FF202020</color>
+    <color name="cardview_light_background">#FFFAFAFA</color>
+    <color name="cardview_shadow_end_color">#03000000</color>
+    <color name="cardview_shadow_start_color">#37000000</color>
+    <!-- From: file:/usr/local/google/buildbot/repo_clients/https___googleplex-android.googlesource.com_a_platform_manifest.git/lmp-preview-release/frameworks/support/v7/cardview/res/values/attrs.xml -->
+    <eat-comment/>
+
+    <declare-styleable name="CardView">
+        <!-- Background color for CardView. -->
+        <attr name="cardBackgroundColor" format="color"/>
+        <!-- Corner radius for CardView. -->
+        <attr name="cardCornerRadius" format="dimension"/>
+        <!-- Elevation for CardView. -->
+        <attr name="cardElevation" format="dimension"/>
+        <!-- Maximum Elevation for CardView. -->
+        <attr name="cardMaxElevation" format="dimension"/>
+        <!-- Add padding in API v21+ as well to have the same measurements with previous versions. -->
+        <attr name="cardUseCompatPadding" format="boolean"/>
+        <!-- Add padding to CardView on v20 and before to prevent intersections between the Card content and rounded corners. -->
+        <attr name="cardPreventCornerOverlap" format="boolean"/>
+        <!-- Inner padding between the edges of the Card and children of the CardView. -->
+        <attr name="contentPadding" format="dimension"/>
+        <!-- Inner padding between the left edge of the Card and children of the CardView. -->
+        <attr name="contentPaddingLeft" format="dimension"/>
+        <!-- Inner padding between the right edge of the Card and children of the CardView. -->
+        <attr name="contentPaddingRight" format="dimension"/>
+        <!-- Inner padding between the top edge of the Card and children of the CardView. -->
+        <attr name="contentPaddingTop" format="dimension"/>
+        <!-- Inner padding between the bottom edge of the Card and children of the CardView. -->
+        <attr name="contentPaddingBottom" format="dimension"/>
+        <!-- Workaround to read user defined minimum width -->
+        <attr name="android:minWidth"/>
+        <!-- Workaround to read user defined minimum height -->
+        <attr name="android:minHeight"/>
+    </declare-styleable>
+    <!-- From: file:/usr/local/google/buildbot/repo_clients/https___googleplex-android.googlesource.com_a_platform_manifest.git/lmp-preview-release/frameworks/support/v7/cardview/res/values/dimens.xml -->
+    <eat-comment/>
+
+    <!-- Default radius for CardView corners. -->
+    <dimen name="cardview_default_radius">2dp</dimen>
+    <!-- Elevation value to use for CardViews. Pre-L, it is equal to shadow size. -->
+    <dimen name="cardview_default_elevation">2dp</dimen>
+    <!-- Inset shadow for RoundRectDrawableWithShadow. It is used to avoid gaps between the card
+     and the shadow. -->
+    <dimen name="cardview_compat_inset_shadow">1dp</dimen>
+    <dimen name="cardview_elevation">2dp</dimen>
+    <dimen name="cardview_shadow_size">2dp</dimen>
+    <!-- From: file:/usr/local/google/buildbot/repo_clients/https___googleplex-android.googlesource.com_a_platform_manifest.git/lmp-preview-release/frameworks/support/v7/cardview/res/values/styles.xml -->
+    <eat-comment/>
+
+    <style name="CardView">
+        <item name="cardBackgroundColor">@color/cardview_light_background</item>
+    </style>
+
+    <style name="CardView.Dark">
+        <item name="cardBackgroundColor">@color/cardview_dark_background</item>
+    </style>
+
+    <style name="CardView.Light">
+        <item name="cardBackgroundColor">@color/cardview_light_background</item>
+    </style>
+
+</resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values/colors.xml b/TMessagesProj/src/main/res/values/colors.xml
index 821125515..4741d69ed 100755
--- a/TMessagesProj/src/main/res/values/colors.xml
+++ b/TMessagesProj/src/main/res/values/colors.xml
@@ -3,4 +3,8 @@
     <color name="divider">#dcdcdc</color>
 
     <color name="actionBarDefault">#FF2DCC70</color>
+    <color name="grey70">#FF707a75</color>
+    <color name="grey3d">#ff3d4b43</color>
+    <color name="grey73">#737876</color>
+    <color name="grey2c">#2c2c2e</color>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values/strings.xml b/TMessagesProj/src/main/res/values/strings.xml
index 547e6fa2f..2bd9560d5 100644
--- a/TMessagesProj/src/main/res/values/strings.xml
+++ b/TMessagesProj/src/main/res/values/strings.xml
@@ -15,7 +15,8 @@
     <string name="AccountAlreadyLoggedIn">This account is already logged in from this app.</string>
     <string name="AccountSwitch">Switch</string>
     <string name="SyncContacts">Sync Contacts</string>
-    <string name="SyncContactsDeleteInfo">This will remove your contacts from the Bettergram servers. If \'Sync Contacts\'
+    <string name="SyncContactsDeleteInfo">This will remove your contacts from the Bettergram servers. If \'Sync
+        Contacts\'
         is enabled, contacts will be re-synced.
     </string>
     <string name="SyncContactsOn">Contacts from this device will be added to this account.</string>
@@ -39,7 +40,8 @@
     <string name="DidNotGetTheCode">Didn\'t get the code?</string>
     <string name="CancelAccountReset">Cancel account reset</string>
     <string name="CancelAccountResetInfo">Somebody with access to your phone number **%1$s** has requested to delete
-        your Bettergram account and reset your 2-Step Verification password.\n\nIf this wasn\'t you, please enter the code
+        your Bettergram account and reset your 2-Step Verification password.\n\nIf this wasn\'t you, please enter the
+        code
         we\'ve just sent you via SMS to your number.
     </string>
     <string name="ResetAccount">Reset account</string>
@@ -179,7 +181,8 @@
     <string name="DisappearingVideo">Secret Video</string>
     <string name="DisappearingGif">Secret GIF</string>
     <string name="CompatibilityChat">%1$s is using an older version of Bettergram, so secret photos will be shown in
-        compatibility mode.\n\nOnce %2$s updates Bettergram, photos with timers for 1 minute or less will start working in
+        compatibility mode.\n\nOnce %2$s updates Bettergram, photos with timers for 1 minute or less will start working
+        in
         \'Tap and hold to view\' mode, and you will be notified whenever the other party takes a screenshot.
     </string>
     <string name="SearchMessages">MESSAGES</string>
@@ -211,7 +214,8 @@
     <string name="Italic">Italic</string>
     <string name="Mono">Mono</string>
     <string name="Regular">Regular</string>
-    <string name="ContactsPermissionAlert">**Bettergram** needs access to your contacts so that you can connect with your
+    <string name="ContactsPermissionAlert">**Bettergram** needs access to your contacts so that you can connect with
+        your
         friends across all your devices. Your contacts will be continuously synced with Bettergram\'s heavily encrypted
         cloud servers.
     </string>
@@ -347,7 +351,8 @@
     <string name="ChannelInviteViaLink">Invite via Link</string>
     <string name="ChannelRemoveUserAdmin">Dismiss admin</string>
     <string name="ChannelMembersInfo">Only channel administrators can see this list.</string>
-    <string name="ChannelLinkInfo">Anyone who has Bettergram installed will be able to join your channel by following this
+    <string name="ChannelLinkInfo">Anyone who has Bettergram installed will be able to join your channel by following
+        this
         link.
     </string>
     <string name="ChannelAdminsInfo">You can add administrators to help you manage your channel. Tap and hold to remove
@@ -629,7 +634,8 @@
     <string name="SendAsFiles">Send as files</string>
     <string name="OpenUrlAlert">Open url %1$s?</string>
     <string name="CancelSending">Cancel sending</string>
-    <string name="BotPermissionGameAlert">Allow %1$s to pass your Bettergram name and id (not your phone number) to pages
+    <string name="BotPermissionGameAlert">Allow %1$s to pass your Bettergram name and id (not your phone number) to
+        pages
         you open with this bot?
     </string>
     <string name="ReportSpam">REPORT SPAM</string>
@@ -853,7 +859,8 @@
     <string name="InviteToBettergram">INVITE TO BETTERGRAM</string>
     <string name="ShareBettergram">Share Bettergram...</string>
     <string name="UpdateContactsTitle">Update contacts?</string>
-    <string name="UpdateContactsMessage">Bettergram has detected many unsynced contacts, would you like to sync them now?
+    <string name="UpdateContactsMessage">Bettergram has detected many unsynced contacts, would you like to sync them
+        now?
         Choose \'OK\' if you\'re using your own device, SIM card and Google account.
     </string>
     <!--group create view-->
@@ -973,7 +980,8 @@
     <string name="UsernameInvalidShort">A username must have at least 5 characters.</string>
     <string name="UsernameInvalidLong">The username must not exceed 32 characters.</string>
     <string name="UsernameInvalidStartNumber">Sorry, a username can\'t start with a number.</string>
-    <string name="UsernameHelp">You can choose a username on **Bettergram**. If you do, other people will be able to find
+    <string name="UsernameHelp">You can choose a username on **Bettergram**. If you do, other people will be able to
+        find
         you by this username and contact you without knowing your phone number.\n\nYou can use **az**, **09** and
         underscores. Minimum length is **5** characters.
     </string>
@@ -1157,11 +1165,11 @@
     <string name="BettergramFaq">Bettergram FAQ</string>
     <string name="AddAccount">Add Account</string>
     <string name="SelectAccount">Select Account</string>
-    <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+    <string name="BettergramFaqUrl">https://bettergram.io/#faq</string>
     <string name="PrivacyPolicy">Privacy Policy</string>
     <string name="TermsOfService">Terms of Service</string>
     <string name="TermsOfServiceLogin">By signing up,\nyou agree to the *Terms of Service*.</string>
-    <string name="PrivacyPolicyUrl">https://telegram.org/privacy</string>
+    <string name="PrivacyPolicyUrl">https://bettergram.io/#</string>
     <string name="DeleteLocalization">Delete localization?</string>
     <string name="IncorrectLocalization">Incorrect localization file</string>
     <string name="NotificationsService">Keep-Alive Service</string>
@@ -1242,7 +1250,8 @@
     <string name="SmartNotificationsAlert">Sound Alert Frequency</string>
     <string name="SmartNotificationsDetail">%1$s within %2$s</string>
     <string name="SecretWebPage">Link Previews</string>
-    <string name="SecretWebPageInfo">Link previews will be generated on Bettergram servers. We do not store data about the
+    <string name="SecretWebPageInfo">Link previews will be generated on Bettergram servers. We do not store data about
+        the
         links you send.
     </string>
     <string name="SecretChat">Secret chats</string>
@@ -1579,10 +1588,12 @@
     <string name="TerminateWebSessionQuestion">Disconnect %1$s?</string>
     <string name="TerminateWebSessionStop">Block %1$s</string>
     <string name="TerminateAllWebSessions">Disconnect All Websites</string>
-    <string name="AreYouSureWebSessions">Are you sure you want to disconnect all websites where you used Bettergram to log
+    <string name="AreYouSureWebSessions">Are you sure you want to disconnect all websites where you used Bettergram to
+        log
         in?
     </string>
-    <string name="ClearOtherWebSessionsHelp">You can log in on websites that support signing in with Bettergram.</string>
+    <string name="ClearOtherWebSessionsHelp">You can log in on websites that support signing in with Bettergram.
+    </string>
     <!--passcode view-->
     <string name="Passcode">Passcode Lock</string>
     <string name="ChangePasscode">Change Passcode</string>
@@ -2089,13 +2100,15 @@
     <string name="AllowReadSms">Please allow Bettergram to receive SMS so that we can automatically enter your code for
         you.
     </string>
-    <string name="AllowReadCall">Please allow Bettergram to receive calls so that we can automatically enter your code for
+    <string name="AllowReadCall">Please allow Bettergram to receive calls so that we can automatically enter your code
+        for
         you.
     </string>
     <string name="AllowFillNumber">Please allow Bettergram to receive calls and SMS so that we can fill in your phone
         number, send you a code, and enter it for you.
     </string>
-    <string name="AllowReadCallAndSms">Please allow Bettergram to receive calls and SMS so that we can automatically enter
+    <string name="AllowReadCallAndSms">Please allow Bettergram to receive calls and SMS so that we can automatically
+        enter
         your code for you.
     </string>
     <string name="UserRestricted">Sorry, you are not allowed to do this.</string>
@@ -2120,7 +2133,8 @@
     <string name="TosDecline">We\'re very sorry, but this means you can\'t sign up for Bettergram.\n\nUnlike others, we
         don\'t use your data for ad targeting or other commercial purposes. Bettergram only stores the information it
         needs to function as a feature-rich cloud service. You can adjust how we use your data (e.g., delete synced
-        contacts) in Privacy &amp; Security settings.\n\nBut if you\'re generally not OK with Bettergram\'s modest needs,
+        contacts) in Privacy &amp; Security settings.\n\nBut if you\'re generally not OK with Bettergram\'s modest
+        needs,
         it won\'t be possible for us to provide this service.
     </string>
     <string name="TosAgeTitle">Age Verification</string>
@@ -2129,7 +2143,8 @@
     <string name="TosUpdateDecline">We\'re very sorry, but this means we must part ways here. Unlike others, we don\'t
         use your data for ad targeting or other commercial purposes. Bettergram only stores the information it needs to
         function as a feature-rich cloud service. You can adjust how we use your data (e.g., delete synced contacts) in
-        Privacy &amp; Security settings.\n\nBut if you\'re generally not OK with Bettergram\'s modest needs, it won\'t be
+        Privacy &amp; Security settings.\n\nBut if you\'re generally not OK with Bettergram\'s modest needs, it won\'t
+        be
         possible for us to provide this service. You can deactivate your account now  or look around some more and
         deactivate it later if you feel you\'re not happy with the way we use your data. How does that sound?
     </string>
@@ -2141,7 +2156,8 @@
     <string name="PermissionContacts">Bettergram needs access to your contacts so that you can connect with your friends
         across all your devices.
     </string>
-    <string name="PermissionStorage">Bettergram needs access to your storage so that you can send and save photos, videos,
+    <string name="PermissionStorage">Bettergram needs access to your storage so that you can send and save photos,
+        videos,
         music and other media.
     </string>
     <string name="PermissionNoAudio">Bettergram needs access to your microphone so that you can send voice messages.
@@ -2280,19 +2296,23 @@
     <string name="BettergramContacts_few">%1$d contacts on Bettergram</string>
     <string name="BettergramContacts_many">%1$d contacts on Bettergram</string>
     <string name="BettergramContacts_other">%1$d contacts on Bettergram</string>
-    <string name="InviteTextNum_zero">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join us!
+    <string name="InviteTextNum_zero">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join
+        us!
         Download it here: %2$s
     </string>
     <string name="InviteTextNum_one">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contact. Join us!
         Download it here: %2$s
     </string>
-    <string name="InviteTextNum_two">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join us!
+    <string name="InviteTextNum_two">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join
+        us!
         Download it here: %2$s
     </string>
-    <string name="InviteTextNum_few">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join us!
+    <string name="InviteTextNum_few">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join
+        us!
         Download it here: %2$s
     </string>
-    <string name="InviteTextNum_many">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join us!
+    <string name="InviteTextNum_many">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join
+        us!
         Download it here: %2$s
     </string>
     <string name="InviteTextNum_other">Hey, I\'m using Bettergram to chat  and so are %1$d of our other contacts. Join
@@ -2577,4 +2597,9 @@
     <string name="socialTwitter">Twitter</string>
     <string name="socialGithub">Github</string>
     <string name="socialTelegram">Telegram</string>
+
+    <!-- Crypto -->
+    <string name="code">CODE</string>
+    <string name="price">PRICE</string>
+    <string name="_24h">24H</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values/urls.xml b/TMessagesProj/src/main/res/values/urls.xml
new file mode 100644
index 000000000..f5c0e0ca6
--- /dev/null
+++ b/TMessagesProj/src/main/res/values/urls.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="youtube_webview_url">https://cdn.rawgit.com/flipkart-incubator/inline-youtube-view/60bae1a1/youtube-android/youtube_iframe_player.html</string>
+</resources>
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index f8805fea7..8bdd79a35 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,8 +1,17 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 buildscript {
     ext {
+        // SDK and tools
+        compileSdkVersion = 28
+        minSdkVersion = 21
+        targetSdkVersion = 28
+        // Gradle
+        gradleVersion = '3.2.0'
         // App Dependencies
         supportVersion = '28.0.0'
+        igjsonVersion = 'master-SNAPSHOT'
+        picassoVersion = '2.71828'
+        romVersion = '1.11.0'
     }
     repositories {
         jcenter()
@@ -10,7 +19,7 @@ buildscript {
         google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.2.0'
+        classpath "com.android.tools.build:gradle:$gradleVersion"
         classpath 'com.google.gms:google-services:4.0.2'
     }
 }
diff --git a/inline-youtube-view/.gitignore b/inline-youtube-view/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/inline-youtube-view/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/inline-youtube-view/build.gradle b/inline-youtube-view/build.gradle
new file mode 100644
index 000000000..692a86c2e
--- /dev/null
+++ b/inline-youtube-view/build.gradle
@@ -0,0 +1,76 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion rootProject.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion rootProject.minSdkVersion
+        targetSdkVersion rootProject.targetSdkVersion
+        versionCode 1
+        versionName "1.0"
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+    buildTypes {
+        release {
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+    lintOptions {
+        abortOnError true
+    }
+}
+
+buildscript {
+    repositories {
+        jcenter()
+        mavenCentral()
+        google()
+    }
+    dependencies {
+        classpath "com.android.tools.build:gradle:$rootProject.gradleVersion"
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.7.5'
+        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+    }
+}
+
+allprojects {
+    repositories {
+        google()
+        jcenter()
+        maven { url "https://plugins.gradle.org/m2/" }
+        maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
+    }
+}
+
+dependencies {
+    implementation fileTree(include: ['*.jar'], dir: 'libs')
+    //implementation "androidx.appcompat:appcompat:$rootProject.appcompatVersion"
+    implementation "com.android.support:appcompat-v7:$rootProject.supportVersion"
+    implementation files('libs/YouTubeAndroidPlayerApi-1.2.2.jar')
+}
+
+apply plugin: 'maven-publish'
+apply plugin: 'com.github.dcendents.android-maven'
+
+configurations {
+    published
+}
+
+task sourceJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier "sources"
+}
+
+configure(install.repositories.mavenInstaller) {
+    pom.project {
+        licenses {
+            license {
+                name 'The Apache Software License, Version 2.0'
+                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                distribution 'repo'
+            }
+        }
+    }
+}
diff --git a/inline-youtube-view/gradle/wrapper/gradle-wrapper.jar b/inline-youtube-view/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 000000000..13372aef5
Binary files /dev/null and b/inline-youtube-view/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/inline-youtube-view/gradle/wrapper/gradle-wrapper.properties b/inline-youtube-view/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 000000000..664ea60f4
--- /dev/null
+++ b/inline-youtube-view/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Mon Jul 17 12:20:00 IST 2017
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/inline-youtube-view/gradlew b/inline-youtube-view/gradlew
new file mode 100644
index 000000000..9d82f7891
--- /dev/null
+++ b/inline-youtube-view/gradlew
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/inline-youtube-view/gradlew.bat b/inline-youtube-view/gradlew.bat
new file mode 100644
index 000000000..8a0b282aa
--- /dev/null
+++ b/inline-youtube-view/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/inline-youtube-view/libs/YouTubeAndroidPlayerApi-1.2.2.jar b/inline-youtube-view/libs/YouTubeAndroidPlayerApi-1.2.2.jar
new file mode 100644
index 000000000..0acbebde9
Binary files /dev/null and b/inline-youtube-view/libs/YouTubeAndroidPlayerApi-1.2.2.jar differ
diff --git a/inline-youtube-view/proguard-rules.pro b/inline-youtube-view/proguard-rules.pro
new file mode 100644
index 000000000..734df8fbf
--- /dev/null
+++ b/inline-youtube-view/proguard-rules.pro
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/anirudh.r/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/inline-youtube-view/src/main/AndroidManifest.xml b/inline-youtube-view/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..9644cb6d0
--- /dev/null
+++ b/inline-youtube-view/src/main/AndroidManifest.xml
@@ -0,0 +1,3 @@
+<manifest
+        package="com.flipkart.youtubeview">
+</manifest>
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/YouTubePlayerView.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/YouTubePlayerView.java
new file mode 100644
index 000000000..6677df5e2
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/YouTubePlayerView.java
@@ -0,0 +1,254 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview;
+
+import android.annotation.SuppressLint;
+import android.app.Fragment;
+import android.app.FragmentManager;
+import android.content.Context;
+import android.graphics.PorterDuff;
+import android.os.Build;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import com.flipkart.youtubeview.fragment.YouTubeBaseFragment;
+import com.flipkart.youtubeview.fragment.YouTubeFragment;
+import com.flipkart.youtubeview.fragment.YouTubeWebViewFragment;
+import com.flipkart.youtubeview.listener.YouTubeEventListener;
+import com.flipkart.youtubeview.models.ImageLoader;
+import com.flipkart.youtubeview.models.YouTubePlayerType;
+import com.flipkart.youtubeview.util.$Precondition$Check;
+import com.flipkart.youtubeview.util.ServiceUtil;
+
+public class YouTubePlayerView extends FrameLayout {
+
+    public static final String TAG = "YouTubeFragmentTAG";
+    private static final double ASPECT_RATIO = 0.5625; //aspect ratio of player 9:16(height/width)
+
+    protected ImageView playIcon;
+    @YouTubePlayerType
+    private int playerType;
+
+    private String videoId;
+    @Nullable
+    private YouTubeEventListener listener;
+    private FragmentManager fragmentManger;
+
+    private String key;
+    private FrameLayout playerContainer;
+    private ImageView thumbnailImageView;
+    private String webViewUrl;
+    private ImageLoader imageLoader;
+
+    public boolean initted = false;
+
+    public YouTubePlayerView(Context context) {
+        super(context);
+        init(context);
+    }
+
+    public YouTubePlayerView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public YouTubePlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init(context);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        int newWidth;
+        int newHeight;
+        newWidth = getMeasuredWidth();
+        newHeight = (int) (newWidth * ASPECT_RATIO);
+        setMeasuredDimension(newWidth, newHeight);
+        if (playerContainer != null && playerContainer.getMeasuredHeight() != newHeight) {
+            ViewGroup.LayoutParams layoutParams = playerContainer.getLayoutParams();
+            layoutParams.height = newHeight;
+            playerContainer.setLayoutParams(layoutParams);
+
+            String url = "https://img.youtube.com/vi/" + videoId + "/0.jpg";
+            if (null != imageLoader) {
+                imageLoader.loadImage(thumbnailImageView, url, getMeasuredHeight(), getMeasuredWidth());
+            }
+        }
+    }
+
+    @MainThread
+    public void initPlayer(@NonNull String apiKey, @NonNull String videoId,
+                           @Nullable String webViewUrl, @YouTubePlayerType int playerType,
+                           @Nullable YouTubeEventListener listener, @NonNull FragmentManager fragmentManager,
+                           @NonNull ImageLoader imageLoader) {
+        $Precondition$Check.checkArgument(!TextUtils.isEmpty(apiKey), "apiKey cannot be null");
+        $Precondition$Check.checkArgument(!TextUtils.isEmpty(videoId), "videoId cannot be null");
+        //noinspection ConstantConditions
+        $Precondition$Check.checkArgument(fragmentManager != null, "Fragment cannot be null");
+        //noinspection ConstantConditions
+        $Precondition$Check.checkArgument(imageLoader != null, "ImageLoader cannot be null");
+
+        this.key = apiKey;
+        this.videoId = videoId;
+        this.webViewUrl = webViewUrl;
+        this.playerType = playerType;
+        this.listener = listener;
+        this.fragmentManger = fragmentManager;
+        this.imageLoader = imageLoader;
+
+        initted = true;
+    }
+
+    public void load() {
+        String url = "https://img.youtube.com/vi/" + videoId + "/0.jpg";
+        if (null != imageLoader) {
+            imageLoader.loadImage(thumbnailImageView, url, getMeasuredHeight(), getMeasuredWidth());
+        }
+    }
+
+    private void init(@NonNull Context context) {
+        LayoutInflater inflater = LayoutInflater.from(context);
+        View itemView = inflater.inflate(R.layout.video_container, this, false);
+        this.addView(itemView);
+        playerContainer = itemView.findViewById(R.id.youtubeFragmentContainer);
+        playerContainer.setId(0);
+        thumbnailImageView = itemView.findViewById(R.id.video_thumbnail_image);
+        playIcon = itemView.findViewById(R.id.play_btn);
+
+        ProgressBar progressBar = itemView.findViewById(R.id.recycler_progressbar);
+        // For else case there is a layout defined for v21 and above
+        if (progressBar != null && Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            int color;
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                color = context.getResources().getColor(R.color.default_progress_bar_color, null);
+            } else {
+                color = context.getResources().getColor(R.color.default_progress_bar_color);
+            }
+            progressBar.getIndeterminateDrawable().setColorFilter(color, PorterDuff.Mode.MULTIPLY);
+        }
+
+        setListeners();
+    }
+
+    private void setListeners() {
+        OnClickListener onClickListener = new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                handleBindPlayer();
+            }
+        };
+
+        thumbnailImageView.setOnClickListener(onClickListener);
+        playIcon.setOnClickListener(onClickListener);
+    }
+
+    private void handleBindPlayer() {
+        switch (playerType) {
+            case YouTubePlayerType.WEB_VIEW:
+                attachPlayer(false);
+                break;
+            case YouTubePlayerType.STRICT_NATIVE:
+                bindPlayer(false);
+                break;
+            case YouTubePlayerType.AUTO:
+            case YouTubePlayerType.INVALID_VIEW:
+            default:
+                bindPlayer(true);
+                break;
+        }
+    }
+
+    private void bindPlayer(boolean auto) {
+        if (!ServiceUtil.isYouTubeServiceAvailable(getContext())) {
+            if (!auto && listener != null) {
+                listener.onNativeNotSupported();
+            } else {
+                attachPlayer(false);
+            }
+        } else {
+            attachPlayer(true);
+        }
+    }
+
+    @SuppressLint("ResourceType")
+    private void attachPlayer(boolean isNative) {
+        if (playerContainer.getId() != R.id.youtubeFragmentContainer) {
+            YouTubeBaseFragment currentYouTubeFragment = removeCurrentYouTubeFragment();
+            playerContainer.setId(R.id.youtubeFragmentContainer);
+            YouTubeBaseFragment youtubePlayerFragment;
+            if (isNative) {
+                youtubePlayerFragment = YouTubeFragment.newInstance(key, videoId);
+            } else {
+                YouTubeWebViewFragment webViewFragment = YouTubeWebViewFragment
+                        .newInstance(webViewUrl, videoId);
+                if (currentYouTubeFragment instanceof YouTubeWebViewFragment) {
+                    webViewFragment
+                            .setWebView(((YouTubeWebViewFragment) currentYouTubeFragment).removeWebView());
+                }
+                youtubePlayerFragment = webViewFragment;
+            }
+            youtubePlayerFragment.setYouTubeEventListener(listener);
+            this.fragmentManger.beginTransaction()
+                    .add(R.id.youtubeFragmentContainer, (Fragment) youtubePlayerFragment, TAG)
+                    .setCustomAnimations(android.R.anim.fade_in, android.R.anim.fade_out)
+                    .commit();
+        }
+    }
+
+    private YouTubeBaseFragment removeCurrentYouTubeFragment() {
+        FragmentManager fragmentManager = fragmentManger;
+        Fragment youTubeFragment = fragmentManager.findFragmentByTag(TAG);
+        YouTubeBaseFragment youTubeBaseFragment = null;
+        if (youTubeFragment instanceof YouTubeBaseFragment) {
+            youTubeBaseFragment = (YouTubeBaseFragment) youTubeFragment;
+            View fragmentView = youTubeFragment.getView();
+            ViewParent parentView = null != fragmentView ? fragmentView.getParent() : null;
+            youTubeBaseFragment.release();
+            fragmentManager.beginTransaction().remove(youTubeFragment).commitAllowingStateLoss();
+            fragmentManager.executePendingTransactions();
+            if (parentView instanceof View
+                    && ((View) parentView).getId() == R.id.youtubeFragmentContainer) {
+                ((View) parentView).setId(0);
+            }
+        }
+        return youTubeBaseFragment;
+    }
+
+    public void unbindPlayer() {
+        if (playerContainer.getId() == R.id.youtubeFragmentContainer) {
+            removeCurrentYouTubeFragment();
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        unbindPlayer();
+        super.onDetachedFromWindow();
+    }
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/activity/YouTubeActivity.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/activity/YouTubeActivity.java
new file mode 100644
index 000000000..36f5af0a2
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/activity/YouTubeActivity.java
@@ -0,0 +1,361 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+
+package com.flipkart.youtubeview.activity;
+
+import android.graphics.PorterDuff;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import android.widget.ProgressBar;
+import com.flipkart.youtubeview.R;
+import com.flipkart.youtubeview.listener.YouTubeEventListener;
+import com.flipkart.youtubeview.models.PlayerStateList;
+import com.flipkart.youtubeview.util.$Precondition$Check;
+import com.flipkart.youtubeview.util.ServiceUtil;
+import com.flipkart.youtubeview.webview.YouTubePlayerWebView;
+import com.google.android.youtube.player.YouTubeBaseActivity;
+import com.google.android.youtube.player.YouTubeInitializationResult;
+import com.google.android.youtube.player.YouTubePlayer;
+import com.google.android.youtube.player.YouTubePlayerView;
+
+import static android.view.View.GONE;
+import static android.view.View.VISIBLE;
+
+public final class YouTubeActivity extends YouTubeBaseActivity implements
+        YouTubePlayer.OnInitializedListener {
+
+    /*
+     * Pass video id as extras
+     */
+    public static final String ARG_VIDEO_ID = "videoId";
+
+    /**
+     * Pass api key as extras
+     */
+    public static final String ARG_API_KEY = "apiKey";
+
+    /**
+     * Pass web-url as extras
+     */
+    public static final String ARG_WEB_URL = "webUrl";
+
+    private static final String TAG = "YoutubeActivity";
+
+    @PlayerStateList.PlayerState
+    private String playerState = PlayerStateList.NONE;
+
+    @Nullable
+    private YouTubePlayer youTubePlayer;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setFullscreen();
+        setContentView(R.layout.youtube_player_view);
+
+        YouTubePlayerView youTubePlayerView = findViewById(R.id.youtube_player);
+
+        String videoId = getVideoId();
+        String apiKey = getApiKey();
+
+        /*
+         * In case videoId or apiKey is null, throw IllegalStateException as apiKey and videoId is mandatory to run
+         * youtube activity.
+         */
+        $Precondition$Check.checkArgument(!TextUtils.isEmpty(videoId), " videoId cannot be null");
+        $Precondition$Check.checkArgument(!TextUtils.isEmpty(apiKey), " apiKey cannot be null");
+
+        /*
+         * In case of YouTube Service not available, fallback to WebView implementation.
+         */
+        if (ServiceUtil.isYouTubeServiceAvailable(this)) {
+            youTubePlayerView.initialize(apiKey, this);
+        } else {
+            String webViewUrl = getWebUrl();
+            if (!TextUtils.isEmpty(webViewUrl)) {
+                youTubePlayerView.setVisibility(GONE);
+                handleWebViewPlayer(videoId, webViewUrl);
+            } else {
+                Log.d(TAG, "Web Url is Null");
+                finish();
+            }
+        }
+    }
+
+    private void setFullscreen() {
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
+                WindowManager.LayoutParams.FLAG_FULLSCREEN);
+    }
+
+    @Nullable
+    private String getVideoId() {
+        Bundle extras = null != getIntent() ? getIntent().getExtras() : null;
+        return null != extras ? extras.getString(ARG_VIDEO_ID) : null;
+    }
+
+    @Nullable
+    private String getApiKey() {
+        Bundle extras = null != getIntent() ? getIntent().getExtras() : null;
+        return null != extras ? extras.getString(ARG_API_KEY) : null;
+    }
+
+    @Nullable
+    private String getWebUrl() {
+        Bundle extras = null != getIntent() ? getIntent().getExtras() : null;
+        return null != extras ? extras.getString(ARG_WEB_URL) : null;
+    }
+
+    private void handleWebViewPlayer(String videoId, String webViewUrl) {
+        //initialize youtube player webview
+        YouTubePlayerWebView youTubePlayerWebView = new YouTubePlayerWebView(this);
+        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+        youTubePlayerWebView.setLayoutParams(layoutParams);
+
+        //initialize progressbar and attach it to the view.
+        ProgressBar progressBar = initializeProgressBar();
+        handleProgressBar(progressBar, true);
+
+        FrameLayout.LayoutParams progressBarParams = new FrameLayout.LayoutParams(
+                FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT);
+        progressBarParams.gravity = Gravity.CENTER;
+        youTubePlayerWebView.setBackgroundColor(getResources().getColor(R.color.black));
+        youTubePlayerWebView.initialize(webViewUrl);
+
+        YouTubeEventListener youTubeEventListener = getYoutubeEventListener(youTubePlayerWebView,
+                progressBar, videoId);
+        youTubePlayerWebView.setYouTubeListener(youTubeEventListener);
+
+        addContentView(youTubePlayerWebView, layoutParams);
+        addContentView(progressBar, progressBarParams);
+    }
+
+    private ProgressBar initializeProgressBar() {
+        ProgressBar progressBar = new ProgressBar(this);
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            int color;
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                color = getResources().getColor(R.color.default_progress_bar_color, null);
+            } else {
+                color = getResources().getColor(R.color.default_progress_bar_color);
+            }
+            progressBar.getIndeterminateDrawable().setColorFilter(color, PorterDuff.Mode.MULTIPLY);
+        }
+
+        return progressBar;
+    }
+
+    private void handleProgressBar(@NonNull ProgressBar progressBar, boolean show) {
+        progressBar.setVisibility(show ? VISIBLE : GONE);
+    }
+
+    @Override
+    public void onInitializationSuccess(YouTubePlayer.Provider provider, final YouTubePlayer player,
+                                        boolean restored) {
+        youTubePlayer = player;
+        youTubePlayer.setPlayerStyle(YouTubePlayer.PlayerStyle.DEFAULT);
+        youTubePlayer.setShowFullscreenButton(true);
+        youTubePlayer.addFullscreenControlFlag(YouTubePlayer.FULLSCREEN_FLAG_CONTROL_ORIENTATION);
+        youTubePlayer.addFullscreenControlFlag(YouTubePlayer.FULLSCREEN_FLAG_CONTROL_SYSTEM_UI);
+
+        youTubePlayer.setPlaybackEventListener(new YouTubePlayer.PlaybackEventListener() {
+            @Override
+            public void onPlaying() {
+                if (youTubePlayer != null && !PlayerStateList.PLAYING.equals(playerState)) {
+                    playerState = PlayerStateList.PLAYING;
+                }
+            }
+
+            @Override
+            public void onPaused() {
+                handleOnPauseEvent();
+            }
+
+            @Override
+            public void onStopped() {
+                handleStopEvent();
+            }
+
+            @Override
+            public void onBuffering(boolean isBuffering) {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onSeekTo(int newPositionMillis) {
+                handleOnPauseEvent();
+            }
+        });
+
+        youTubePlayer.setPlayerStateChangeListener(new YouTubePlayer.PlayerStateChangeListener() {
+            @Override
+            public void onLoading() {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onLoaded(String s) {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onAdStarted() {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onVideoStarted() {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onVideoEnded() {
+                handleStopEvent();
+            }
+
+            @Override
+            public void onError(YouTubePlayer.ErrorReason errorReason) {
+                //intentionally left blank
+            }
+        });
+
+        player.setOnFullscreenListener(new YouTubePlayer.OnFullscreenListener() {
+            @Override
+            public void onFullscreen(boolean b) {
+                handleStopEvent();
+            }
+        });
+
+        if (!restored) {
+            youTubePlayer.loadVideo(getVideoId());
+        }
+    }
+
+    private void handleOnPauseEvent() {
+        if (youTubePlayer != null && (PlayerStateList.PLAYING.equals(playerState))
+                || PlayerStateList.BUFFERING.equals(playerState)) {
+            playerState = PlayerStateList.PAUSED;
+        }
+    }
+
+    private void handleStopEvent() {
+        if (youTubePlayer != null && (PlayerStateList.PLAYING.equals(playerState))
+                || PlayerStateList.BUFFERING.equals(playerState) || PlayerStateList.PAUSED
+                .equals(playerState)) {
+            playerState = PlayerStateList.STOPPED;
+        }
+    }
+
+    private YouTubeEventListener getYoutubeEventListener(
+            @NonNull final YouTubePlayerWebView youTubePlayerWebView,
+            @NonNull final ProgressBar progressBar,
+            @NonNull final String videoId) {
+        return new YouTubeEventListener() {
+            @Override
+            @MainThread
+            public void onReady() {
+                youTubePlayerWebView.loadVideo(videoId);
+                handleProgressBar(progressBar, false);
+            }
+
+            @Override
+            public void onCued() {
+                //intentionally left blank
+            }
+
+            @Override
+            @MainThread
+            public void onPlay(int currentTime) {
+                handleProgressBar(progressBar, false);
+            }
+
+            @Override
+            @MainThread
+            public void onPause(int currentTime) {
+                //intentionally left blank
+            }
+
+            @Override
+            @MainThread
+            public void onStop(int currentTime, int totalDuration) {
+                //intentionally left blank
+            }
+
+            @Override
+            @MainThread
+            public void onBuffering(int currentTime, boolean isBuffering) {
+                //intentionally left blank
+            }
+
+            @Override
+            @MainThread
+            public void onSeekTo(int currentTime, int newPositionMillis) {
+                //intentionally left blank
+            }
+
+            @Override
+            @MainThread
+            public void onInitializationFailure(String error) {
+                //intentionally left blank
+            }
+
+            @Override
+            @MainThread
+            public void onNativeNotSupported() {
+                //intentionally left blank
+            }
+        };
+    }
+
+    @Override
+    public void onInitializationFailure(YouTubePlayer.Provider provider,
+                                        YouTubeInitializationResult result) {
+        this.youTubePlayer = null;
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        handleStopEvent();
+    }
+
+    @Override
+    public void onBackPressed() {
+        finish();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (youTubePlayer != null) {
+            youTubePlayer.release();
+        }
+    }
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeBaseFragment.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeBaseFragment.java
new file mode 100644
index 000000000..9c5c77316
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeBaseFragment.java
@@ -0,0 +1,30 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.fragment;
+
+
+import android.support.annotation.Nullable;
+import com.flipkart.youtubeview.listener.YouTubeEventListener;
+
+public interface YouTubeBaseFragment {
+
+    void setYouTubeEventListener(@Nullable YouTubeEventListener listener);
+
+    void release();
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeFragment.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeFragment.java
new file mode 100644
index 000000000..068e71290
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeFragment.java
@@ -0,0 +1,213 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.fragment;
+
+import android.os.Bundle;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import com.flipkart.youtubeview.listener.YouTubeEventListener;
+import com.flipkart.youtubeview.models.PlayerStateList;
+import com.flipkart.youtubeview.util.$Precondition$Check;
+import com.google.android.youtube.player.YouTubeInitializationResult;
+import com.google.android.youtube.player.YouTubePlayer;
+import com.google.android.youtube.player.YouTubePlayerFragment;
+
+public class YouTubeFragment extends YouTubePlayerFragment implements YouTubePlayer.OnInitializedListener, YouTubeBaseFragment {
+
+    private static final String ARG_VIDEO_ID = "videoId";
+    private static final String ARG_API_KEY = "apiKey";
+
+    @PlayerStateList.PlayerState
+    private String playerState = PlayerStateList.NONE;
+    @Nullable
+    private YouTubeEventListener listener;
+    @Nullable
+    private YouTubePlayer youTubePlayer;
+
+    public static YouTubeFragment newInstance(@NonNull String apiKey, @NonNull final String videoId) {
+        $Precondition$Check.checkArgument(!TextUtils.isEmpty(apiKey), "apiKey cannot be null");
+        $Precondition$Check.checkArgument(!TextUtils.isEmpty(videoId), "videoId cannot be null");
+        YouTubeFragment fragment = new YouTubeFragment();
+        Bundle bundle = new Bundle();
+        bundle.putString(ARG_VIDEO_ID, videoId);
+        bundle.putString(ARG_API_KEY, apiKey);
+        fragment.setArguments(bundle);
+        return fragment;
+    }
+
+    @Override
+    public void setYouTubeEventListener(@Nullable YouTubeEventListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        /* release youTubePlayer when home button pressed. */
+        release();
+        super.onSaveInstanceState(outState);
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        if (null == youTubePlayer) {
+            Bundle arguments = getArguments();
+            if (null != arguments) {
+                initialize(arguments.getString(ARG_API_KEY), this);
+            }
+        }
+    }
+
+    @Override
+    public void onInitializationSuccess(YouTubePlayer.Provider provider, final YouTubePlayer player,
+                                        boolean restored) {
+        youTubePlayer = player;
+        youTubePlayer.setPlayerStyle(YouTubePlayer.PlayerStyle.DEFAULT);
+        youTubePlayer.setShowFullscreenButton(false);
+
+        if (listener != null) {
+            listener.onReady();
+        }
+
+        youTubePlayer.setPlaybackEventListener(new YouTubePlayer.PlaybackEventListener() {
+            @Override
+            public void onPlaying() {
+                if (listener != null && youTubePlayer != null && !PlayerStateList.PLAYING
+                        .equals(playerState)) {
+                    playerState = PlayerStateList.PLAYING;
+                    listener.onPlay(youTubePlayer.getCurrentTimeMillis());
+                }
+            }
+
+            @Override
+            public void onPaused() {
+                handleOnPauseEvent();
+            }
+
+            @Override
+            public void onStopped() {
+                //since these are player stop events in case of any player error so pause event not stop.
+                handleOnPauseEvent();
+            }
+
+            @Override
+            public void onBuffering(boolean isBuffering) {
+                if (listener != null && youTubePlayer != null) {
+                    listener.onBuffering((youTubePlayer.getCurrentTimeMillis()), isBuffering);
+                }
+            }
+
+            @Override
+            public void onSeekTo(int newPositionMillis) {
+                //just to mimick the pause event before play on seek event.
+                handleOnPauseEvent();
+            }
+        });
+
+        youTubePlayer.setPlayerStateChangeListener(new YouTubePlayer.PlayerStateChangeListener() {
+            @Override
+            public void onLoading() {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onLoaded(String s) {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onAdStarted() {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onVideoStarted() {
+                //intentionally left blank
+            }
+
+            @Override
+            public void onVideoEnded() {
+                handleStopEvent();
+            }
+
+            @Override
+            public void onError(YouTubePlayer.ErrorReason errorReason) {
+                //intentionally left blank
+            }
+        });
+
+        if (!restored) {
+            //do any work here to cue video, play video, etc.
+            Bundle arguments = getArguments();
+            String videoId = arguments != null ? arguments.getString(ARG_VIDEO_ID) : null;
+            if (!TextUtils.isEmpty(videoId)) {
+                youTubePlayer.loadVideo(videoId);
+            }
+        }
+    }
+
+    private void handleOnPauseEvent() {
+        if (listener != null && youTubePlayer != null && (PlayerStateList.PLAYING.equals(playerState)
+                || PlayerStateList.BUFFERING.equals(playerState))) {
+            playerState = PlayerStateList.PAUSED;
+            listener.onPause((youTubePlayer.getCurrentTimeMillis()));
+        }
+    }
+
+    private void handleStopEvent() {
+        if (listener != null && youTubePlayer != null && (PlayerStateList.PLAYING.equals(playerState)
+                || PlayerStateList.BUFFERING.equals(playerState) || PlayerStateList.PAUSED
+                .equals(playerState))) {
+            playerState = PlayerStateList.STOPPED;
+            listener.onStop((youTubePlayer.getCurrentTimeMillis()), (youTubePlayer.getDurationMillis()));
+        }
+    }
+
+    @Override
+    public void onInitializationFailure(YouTubePlayer.Provider provider,
+                                        YouTubeInitializationResult result) {
+        youTubePlayer = null;
+        if (listener != null) {
+            listener.onInitializationFailure(result.name());
+        }
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        handleStopEvent();
+        release();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        release();
+    }
+
+    @MainThread
+    public void release() {
+        if (youTubePlayer != null) {
+            youTubePlayer.release();
+            youTubePlayer = null;
+        }
+    }
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeWebViewFragment.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeWebViewFragment.java
new file mode 100644
index 000000000..ccbd9bbb7
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/fragment/YouTubeWebViewFragment.java
@@ -0,0 +1,174 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.fragment;
+
+import android.app.Fragment;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import com.flipkart.youtubeview.R;
+import com.flipkart.youtubeview.listener.YouTubeEventListener;
+import com.flipkart.youtubeview.webview.YouTubePlayerWebView;
+
+public final class YouTubeWebViewFragment extends Fragment implements YouTubeEventListener,
+        YouTubeBaseFragment {
+
+    private static final String WEB_VIEW_URL = "webViewUrl";
+    private static final String VIDEO_ID = "videoId";
+    private YouTubePlayerWebView youTubePlayerWebView = null;
+
+    @Nullable
+    private YouTubeEventListener youTubeEventListener;
+
+    public static YouTubeWebViewFragment newInstance(@NonNull String webViewUrl,
+                                                     @NonNull String videoId) {
+        YouTubeWebViewFragment fragment = new YouTubeWebViewFragment();
+        Bundle bundle = new Bundle();
+        bundle.putString(WEB_VIEW_URL, webViewUrl);
+        bundle.putString(VIDEO_ID, videoId);
+        fragment.setArguments(bundle);
+        return fragment;
+    }
+
+    @Override
+    public void setYouTubeEventListener(@Nullable YouTubeEventListener listener) {
+        youTubeEventListener = listener;
+    }
+
+    @Override
+    public void release() {
+        if (youTubePlayerWebView != null) {
+            youTubePlayerWebView.stopPlayer();
+        }
+    }
+
+    public void setWebView(@NonNull YouTubePlayerWebView webView) {
+        youTubePlayerWebView = webView;
+    }
+
+    @Nullable
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
+                             @Nullable Bundle savedInstanceState) {
+        Bundle arguments = getArguments();
+        String webViewUrl = arguments != null ? arguments.getString(WEB_VIEW_URL) : null;
+        if (TextUtils.isEmpty(webViewUrl)) {
+            throw new IllegalStateException("webViewUrl cannot be null");
+        }
+        return bindYoutubePlayerWebView(inflater, container, webViewUrl);
+    }
+
+    private YouTubePlayerWebView bindYoutubePlayerWebView(LayoutInflater inflater,
+                                                          @Nullable ViewGroup container, @NonNull String webViewUrl) {
+        if (youTubePlayerWebView == null) {
+            youTubePlayerWebView = (YouTubePlayerWebView) inflater
+                    .inflate(R.layout.youtube_player_web_view, container, false);
+            youTubePlayerWebView.initialize(webViewUrl);
+            youTubePlayerWebView.setYouTubeListener(this);
+            setWebViewProps();
+            //on ready event will be fired by default
+        } else {
+            removeWebView();
+            youTubePlayerWebView.initialize(webViewUrl);
+            youTubePlayerWebView.setYouTubeListener(this);
+            setWebViewProps();
+            youTubePlayerWebView.onReadyPlayer();
+        }
+        return youTubePlayerWebView;
+    }
+
+    private void setWebViewProps() {
+        youTubePlayerWebView.resetTime();
+    }
+
+    public YouTubePlayerWebView removeWebView() {
+        youTubePlayerWebView.stopPlayer();
+        return youTubePlayerWebView;
+    }
+
+    @Override
+    public void onReady() {
+        Bundle arguments = getArguments();
+        String videoId = arguments != null ? arguments.getString(VIDEO_ID) : null;
+        youTubePlayerWebView.loadVideo(videoId);
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onReady();
+        }
+    }
+
+    @Override
+    public void onPlay(int currentTime) {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onPlay(currentTime);
+        }
+    }
+
+    @Override
+    public void onPause(int currentTime) {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onPause(currentTime);
+        }
+    }
+
+    @Override
+    public void onStop(int currentTime, int totalDuration) {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onStop(currentTime, totalDuration);
+        }
+    }
+
+    @Override
+    public void onBuffering(int currentTime, boolean isBuffering) {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onBuffering(currentTime, isBuffering);
+        }
+    }
+
+    @Override
+    public void onSeekTo(int currentTime, int newPositionMillis) {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onSeekTo(currentTime, newPositionMillis);
+        }
+    }
+
+    @Override
+    public void onInitializationFailure(String error) {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onInitializationFailure(error);
+        }
+    }
+
+    @Override
+    public void onNativeNotSupported() {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onNativeNotSupported();
+        }
+    }
+
+    @Override
+    public void onCued() {
+        if (youTubeEventListener != null) {
+            youTubeEventListener.onCued();
+        }
+    }
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/listener/YouTubeEventListener.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/listener/YouTubeEventListener.java
new file mode 100644
index 000000000..8187bfcfc
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/listener/YouTubeEventListener.java
@@ -0,0 +1,94 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.listener;
+
+
+import android.support.annotation.MainThread;
+
+public interface YouTubeEventListener {
+
+    /**
+     * fired when youtube player is ready
+     */
+    @MainThread
+    void onReady();
+
+    /**
+     * when video is playing.
+     *
+     * @param currentTime currentTime of seek-bar
+     */
+    @MainThread
+    void onPlay(int currentTime);
+
+    /**
+     * when video has been paused.
+     *
+     * @param currentTime paused time
+     */
+    @MainThread
+    void onPause(int currentTime);
+
+    /**
+     * when video has been stopped
+     *
+     * @param currentTime   stop time
+     * @param totalDuration total duration of video
+     */
+    @MainThread
+    void onStop(int currentTime, int totalDuration);
+
+    /**
+     * when video is buffering
+     *
+     * @param currentTime current buffering time
+     * @param isBuffering is video being buffered
+     */
+    @MainThread
+    void onBuffering(int currentTime, boolean isBuffering);
+
+    /**
+     * when seek-bar is moved
+     *
+     * @param currentTime       time from where seek-bar has been moved
+     * @param newPositionMillis new position moved
+     */
+    @MainThread
+    void onSeekTo(int currentTime, int newPositionMillis);
+
+    /**
+     * when youtube player fails to initialize
+     *
+     * @param error message
+     */
+    @MainThread
+    void onInitializationFailure(String error);
+
+    /**
+     * when native player is not supported
+     */
+    @MainThread
+    void onNativeNotSupported();
+
+    /**
+     * when video is cued
+     */
+    @MainThread
+    void onCued();
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/ImageLoader.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/ImageLoader.java
new file mode 100644
index 000000000..91854b5a8
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/ImageLoader.java
@@ -0,0 +1,35 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.models;
+
+import android.support.annotation.NonNull;
+import android.widget.ImageView;
+
+public interface ImageLoader {
+
+    /**
+     * Callback to load image (thumbnail view)
+     *
+     * @param imageView imageview
+     * @param url       url of image
+     * @param height    height
+     * @param width     width
+     */
+    void loadImage(@NonNull ImageView imageView, @NonNull String url, int height, int width);
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/PlayerStateList.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/PlayerStateList.java
new file mode 100644
index 000000000..55ee06a1f
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/PlayerStateList.java
@@ -0,0 +1,43 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.models;
+
+import android.support.annotation.StringDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@SuppressWarnings("WeakerAccess")
+public class PlayerStateList {
+
+    public static final String NOT_STARTED = "NOT_STARTED";
+    public static final String ENDED = "ENDED";
+    public static final String PLAYING = "PLAYING";
+    public static final String PAUSED = "PAUSED";
+    public static final String BUFFERING = "BUFFERING";
+    public static final String CUED = "CUED";
+    public static final String NONE = "NONE";
+    public static final String STOPPED = "STOPPED";
+
+    @StringDef({NOT_STARTED, ENDED, PLAYING, PAUSED, BUFFERING, CUED, NONE, STOPPED})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface PlayerState {
+
+    }
+}
\ No newline at end of file
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/YouTubePlayerType.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/YouTubePlayerType.java
new file mode 100644
index 000000000..0a12a497f
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/models/YouTubePlayerType.java
@@ -0,0 +1,52 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.models;
+
+
+import android.support.annotation.IntDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@IntDef({YouTubePlayerType.INVALID_VIEW, YouTubePlayerType.AUTO, YouTubePlayerType.STRICT_NATIVE,
+        YouTubePlayerType.WEB_VIEW})
+@Retention(RetentionPolicy.SOURCE)
+public @interface YouTubePlayerType {
+
+    /**
+     * Invalid view
+     */
+    int INVALID_VIEW = 0;
+
+    /**
+     * Auto. If youtube service is available, it will render native player else will fallback to
+     * WebView if web-url provided
+     */
+    int AUTO = 1;
+
+    /**
+     * render only native player
+     */
+    int STRICT_NATIVE = 2;
+
+    /**
+     * render only WebView player
+     */
+    int WEB_VIEW = 3;
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/util/$Precondition$Check.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/util/$Precondition$Check.java
new file mode 100644
index 000000000..71b0bd4e9
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/util/$Precondition$Check.java
@@ -0,0 +1,24 @@
+package com.flipkart.youtubeview.util;
+
+public final class $Precondition$Check {
+
+  public static void checkArgument(boolean expression) {
+    if (!expression) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  /**
+   * Ensures that an expression checking an argument is true.
+   *
+   * @param expression the expression to check
+   * @param errorMessage the exception message to use if the check fails; will be converted to a
+   * string using {@link String#valueOf(Object)}
+   * @throws IllegalArgumentException if {@code expression} is false
+   */
+  public static void checkArgument(boolean expression, final Object errorMessage) {
+    if (!expression) {
+      throw new IllegalArgumentException(String.valueOf(errorMessage));
+    }
+  }
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/util/ServiceUtil.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/util/ServiceUtil.java
new file mode 100644
index 000000000..444c8c059
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/util/ServiceUtil.java
@@ -0,0 +1,39 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.util;
+
+import android.content.Context;
+import com.google.android.youtube.player.YouTubeApiServiceUtil;
+import com.google.android.youtube.player.YouTubeInitializationResult;
+import com.google.android.youtube.player.YouTubeIntents;
+
+public final class ServiceUtil {
+
+  /**
+   * Check if youtube service is available
+   *
+   * @param context {@link Context}
+   * @return true if present, else false
+   */
+  public static boolean isYouTubeServiceAvailable(Context context) {
+    return YouTubeIntents.isYouTubeInstalled(context) ||
+        YouTubeApiServiceUtil.isYouTubeApiServiceAvailable(context)
+            == YouTubeInitializationResult.SUCCESS;
+  }
+}
diff --git a/inline-youtube-view/src/main/java/com/flipkart/youtubeview/webview/YouTubePlayerWebView.java b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/webview/YouTubePlayerWebView.java
new file mode 100644
index 000000000..d914d6329
--- /dev/null
+++ b/inline-youtube-view/src/main/java/com/flipkart/youtubeview/webview/YouTubePlayerWebView.java
@@ -0,0 +1,402 @@
+/*
+ * Apache License
+ * Version 2.0, January 2004
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+ *
+ * Copyright (c) 2018 Flipkart Internet Pvt. Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
+ * this file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed
+ * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package com.flipkart.youtubeview.webview;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+import android.webkit.WebResourceRequest;
+import android.webkit.WebSettings;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import com.flipkart.youtubeview.BuildConfig;
+import com.flipkart.youtubeview.listener.YouTubeEventListener;
+import com.flipkart.youtubeview.models.PlayerStateList;
+import com.flipkart.youtubeview.util.$Precondition$Check;
+
+public class YouTubePlayerWebView extends WebView {
+
+    private static final String TAG = "YoutubePlayerWebView";
+    private static final String SCHEME = "ytplayer";
+    private static final String DATA_QUERY_PARAM = "data";
+    private static final String CURRENT_TIME_PARAM = "currentTime";
+    private static final String EVENT_CALLBACK = "callback";
+    private static final int MULTIPLIER = 1000;
+    private static final double ASPECT_RATIO = 0.5625; //aspect ratio of player 9:16(height/width)
+
+    @Nullable
+    private YouTubeEventListener youTubeListener;
+
+    private String duration = null;
+    private String currentTime = null;
+    private String previousState = PlayerStateList.NONE;
+    private boolean isPlayerReady = false;
+
+    public YouTubePlayerWebView(Context context) {
+        super(context);
+    }
+
+    public YouTubePlayerWebView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        int newWidth;
+        int newHeight;
+        newWidth = getMeasuredWidth();
+        newHeight = (int) (newWidth * ASPECT_RATIO);
+        setMeasuredDimension(newWidth, newHeight);
+    }
+
+    public void initialize(@NonNull String webViewUrl) {
+        $Precondition$Check
+                .checkArgument(!TextUtils.isEmpty(webViewUrl), "WebView url cannot be empty");
+        if (!isPlayerReady) {
+            initWebView(webViewUrl);
+        }
+    }
+
+    public void setYouTubeListener(@Nullable YouTubeEventListener listener) {
+        this.youTubeListener = listener;
+    }
+
+    public void resetTime() {
+        duration = null;
+        currentTime = null;
+        previousState = PlayerStateList.NONE;
+    }
+
+    /**
+     * Initialises YoutubeWebView with given videoId and youtubeListener
+     */
+    @SuppressLint("SetJavaScriptEnabled")
+    private void initWebView(String webViewUrl) {
+        WebSettings set = this.getSettings();
+        set.setJavaScriptEnabled(true);
+        set.setUseWideViewPort(true);
+        set.setLoadWithOverviewMode(true);
+        set.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NORMAL);
+        set.setCacheMode(WebSettings.LOAD_DEFAULT);
+        set.setPluginState(WebSettings.PluginState.ON_DEMAND);
+        set.setAllowContentAccess(true);
+        set.setAllowFileAccess(false);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            set.setMediaPlaybackRequiresUserGesture(false);
+        }
+        this.setLayerType(View.LAYER_TYPE_NONE, null);
+        this.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
+        this.loadUrl(webViewUrl);
+
+        if (BuildConfig.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            setWebContentsDebuggingEnabled(true);
+        }
+
+        this.setWebViewClient(initWebViewClient());
+    }
+
+    @NonNull
+    private WebViewClient initWebViewClient() {
+        return new WebViewClient() {
+            @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
+                return shouldOverrideUrlLoading(request.getUrl());
+            }
+
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                if (!TextUtils.isEmpty(url)) {
+                    Uri uri = Uri.parse(url);
+                    return shouldOverrideUrlLoading(uri);
+                } else {
+                    return false;
+                }
+            }
+
+            private boolean shouldOverrideUrlLoading(@NonNull Uri url) {
+                if (SCHEME.equals(url.getScheme())) {
+                    String methodName = url.getHost();
+                    String data = url.getQueryParameter(DATA_QUERY_PARAM);
+                    String paramCurrentTime = url.getQueryParameter(CURRENT_TIME_PARAM);
+                    String eventCallBack = url.getQueryParameter(EVENT_CALLBACK);
+
+                    if (!TextUtils.isEmpty(eventCallBack)) {
+                        sendAck(eventCallBack, methodName);
+                    }
+                    if (!TextUtils.isEmpty(paramCurrentTime)) {
+                        currentTime(paramCurrentTime);
+                    }
+                    if (!TextUtils.isEmpty(methodName)) {
+                        invokeNativeMethod(methodName, data);
+                    }
+                }
+                return true; // return true in all case as webView shouldn't allow any other url to open.
+            }
+        };
+    }
+
+    @Override
+    public void onScreenStateChanged(int screenState) {
+        if (screenState == SCREEN_STATE_OFF) {
+            stopPlayer();
+        }
+    }
+
+    private void invokeNativeMethod(@NonNull String methodName, String args) {
+        switch (methodName) {
+            case "onReady":
+                onReady(args);
+                break;
+            case "onStateChange":
+                onStateChange(args);
+                break;
+            case "onPlaybackQualityChange":
+                onPlaybackQualityChange(args);
+                break;
+            case "onPlaybackRateChange":
+                onPlaybackRateChange(args);
+                break;
+            case "onError":
+                onError(args);
+                break;
+            case "onApiChange":
+                onApiChange(args);
+                break;
+            case "currentTime":
+                currentTime(args);
+                break;
+            case "duration":
+                duration(args);
+                break;
+            case "logs":
+                logs(args);
+                break;
+            case "onYouTubeIframeAPIFailedToLoad":
+                onYouTubeIframeAPIFailedToLoad(args);
+                break;
+            case "onYouTubeIframeAPIReady":
+                onYouTubeIframeAPIReady(args);
+                break;
+            default:
+                break;
+        }
+    }
+
+    /**
+     * APP TO WEB API's
+     */
+    @SuppressWarnings("unused")
+    public void seekToMillis(double mil) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "seekToMillis : ");
+        }
+        this.loadUrl("javascript:onSeekTo(" + mil + ")");
+    }
+
+    @SuppressWarnings("unused")
+    public void pause() {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "pause");
+        }
+        this.loadUrl("javascript:onVideoPause()");
+    }
+
+    public void stop() {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "stop");
+        }
+        if (youTubeListener != null) {
+            youTubeListener.onStop(getTimeInMilliSec(currentTime), getTimeInMilliSec(duration));
+        }
+        this.loadUrl("javascript:onVideoStop()");
+    }
+
+    public void setDuration() {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "setDuration");
+        }
+        this.loadUrl("javascript:sendDuration()");
+    }
+
+    @SuppressWarnings("unused")
+    public void play() {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "play");
+        }
+        this.loadUrl("javascript:onVideoPlay()");
+    }
+
+    public void loadVideo(String videoId) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "loadVideo : " + videoId);
+        }
+        this.loadUrl("javascript:loadVideo('" + videoId + "')");
+    }
+
+    @SuppressWarnings("unused")
+    public void cueVideo(String videoId) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "cueVideo : " + videoId);
+        }
+        this.loadUrl("javascript:cueVideo('" + videoId + "')");
+    }
+
+    private void sendAck(String callBack, String methodName) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "sendAck for :" + methodName);
+        }
+        this.loadUrl("javascript:" + callBack);
+    }
+
+    //It will make player ready for next video being played
+    public void onReadyPlayer() {
+        if (youTubeListener != null && isPlayerReady) {
+            youTubeListener.onReady();
+        }
+    }
+
+    /**
+     * WEB TO APP
+     */
+    private void onReady(@NonNull String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "onReady(" + arg + ")");
+        }
+
+        isPlayerReady = true;
+        if (youTubeListener != null) {
+            youTubeListener.onReady();
+        }
+    }
+
+    private void onStateChange(String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "onStateChange(" + arg + ")");
+        }
+        previousState = arg;
+        if (youTubeListener != null) {
+            //noinspection StatementWithEmptyBody
+            if (PlayerStateList.NOT_STARTED.equalsIgnoreCase(arg)) {
+                //handle when needed.
+            } else if (PlayerStateList.ENDED.equalsIgnoreCase(arg)) {
+                youTubeListener.onStop(getTimeInMilliSec(currentTime), getTimeInMilliSec(duration));
+            } else if (PlayerStateList.PLAYING.equalsIgnoreCase(arg)) {
+                if (TextUtils.isEmpty(duration)) {
+                    setDuration();
+                }
+                youTubeListener.onPlay(getTimeInMilliSec(currentTime));
+            } else if (PlayerStateList.PAUSED.equalsIgnoreCase(arg)) {
+                youTubeListener.onPause(getTimeInMilliSec(currentTime));
+            } else if (PlayerStateList.BUFFERING.equalsIgnoreCase(arg)) {
+                youTubeListener.onBuffering(getTimeInMilliSec(currentTime), true);
+            } else if (PlayerStateList.CUED.equalsIgnoreCase(arg)) {
+                youTubeListener.onCued();
+            }
+        }
+    }
+
+    private void onPlaybackQualityChange(String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "onPlaybackQualityChange(" + arg + ")");
+        }
+    }
+
+    private void onPlaybackRateChange(String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "onPlaybackRateChange(" + arg + ")");
+        }
+    }
+
+    private void onError(String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.e(TAG, "onError(" + arg + ")");
+        }
+        if (youTubeListener != null) {
+            youTubeListener.onInitializationFailure(arg);
+        }
+    }
+
+    private void onApiChange(String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "onApiChange(" + arg + ")");
+        }
+    }
+
+    private void duration(String seconds) {
+        if (!TextUtils.isEmpty(seconds) && !"UNDEFINED".equalsIgnoreCase(seconds)) {
+            duration = seconds;
+        }
+    }
+
+    private void currentTime(String seconds) {
+        if (!TextUtils.isEmpty(seconds)) {
+            currentTime = seconds;
+        }
+    }
+
+    private void logs(String arg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(TAG, "logs(" + arg + ")");
+        }
+    }
+
+    private void onYouTubeIframeAPIFailedToLoad(String args) {
+        if (youTubeListener != null) {
+            youTubeListener.onInitializationFailure(args);
+        }
+    }
+
+    @SuppressWarnings("unused")
+    private void onYouTubeIframeAPIReady(String args) {
+        //intentionally empty
+    }
+
+    private int getTimeInMilliSec(String seconds) {
+        double time = 0.0;
+        if (!TextUtils.isEmpty(seconds)) {
+            try {
+                time = Double.parseDouble(seconds) * MULTIPLIER;
+            } catch (NumberFormatException ignored) {
+                Log.e(TAG, ignored.getMessage());
+            }
+        }
+        return (int) time;
+    }
+
+    public void stopPlayer() {
+        if (isPlayerReady
+                && (PlayerStateList.PLAYING.equals(previousState)
+                || PlayerStateList.BUFFERING.equals(previousState)
+                || PlayerStateList.PAUSED.equals(previousState)
+                || PlayerStateList.CUED.equals(previousState))) {
+            stop();
+        }
+    }
+}
diff --git a/inline-youtube-view/src/main/res/drawable-hdpi/play_btn_thumbnail.png b/inline-youtube-view/src/main/res/drawable-hdpi/play_btn_thumbnail.png
new file mode 100644
index 000000000..98c9756c4
Binary files /dev/null and b/inline-youtube-view/src/main/res/drawable-hdpi/play_btn_thumbnail.png differ
diff --git a/inline-youtube-view/src/main/res/drawable-xhdpi/play_btn_thumbnail.png b/inline-youtube-view/src/main/res/drawable-xhdpi/play_btn_thumbnail.png
new file mode 100644
index 000000000..5452d03e4
Binary files /dev/null and b/inline-youtube-view/src/main/res/drawable-xhdpi/play_btn_thumbnail.png differ
diff --git a/inline-youtube-view/src/main/res/drawable-xxhdpi/play_btn_thumbnail.png b/inline-youtube-view/src/main/res/drawable-xxhdpi/play_btn_thumbnail.png
new file mode 100644
index 000000000..254216426
Binary files /dev/null and b/inline-youtube-view/src/main/res/drawable-xxhdpi/play_btn_thumbnail.png differ
diff --git a/inline-youtube-view/src/main/res/layout/recycler_progressbar.xml b/inline-youtube-view/src/main/res/layout/recycler_progressbar.xml
new file mode 100644
index 000000000..176b9c8a3
--- /dev/null
+++ b/inline-youtube-view/src/main/res/layout/recycler_progressbar.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ProgressBar xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/recycler_progressbar"
+    android:layout_width="@dimen/progress_bar_dimensions"
+    android:layout_height="@dimen/progress_bar_dimensions"
+    android:layout_gravity="center" />
+
+    
\ No newline at end of file
diff --git a/inline-youtube-view/src/main/res/layout/video_container.xml b/inline-youtube-view/src/main/res/layout/video_container.xml
new file mode 100644
index 000000000..623ec962b
--- /dev/null
+++ b/inline-youtube-view/src/main/res/layout/video_container.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:id="@+id/video_container"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical">
+
+    <ImageView
+            android:id="@+id/video_thumbnail_image"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+
+    <ImageView
+            android:id="@+id/play_btn"
+            android:layout_width="48dp"
+            android:layout_height="48dp"
+            android:layout_centerInParent="true"
+            android:src="@drawable/play_btn_thumbnail"/>
+
+    <include
+            layout="@layout/recycler_progressbar"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerInParent="true"
+            android:visibility="gone"/>
+
+    <FrameLayout
+            android:id="@+id/youtubeFragmentContainer"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:orientation="horizontal"/>
+</RelativeLayout>
\ No newline at end of file
diff --git a/inline-youtube-view/src/main/res/layout/youtube_player_view.xml b/inline-youtube-view/src/main/res/layout/youtube_player_view.xml
new file mode 100644
index 000000000..c63c22478
--- /dev/null
+++ b/inline-youtube-view/src/main/res/layout/youtube_player_view.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.android.youtube.player.YouTubePlayerView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/youtube_player"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:visibility="visible" />
+
diff --git a/inline-youtube-view/src/main/res/layout/youtube_player_web_view.xml b/inline-youtube-view/src/main/res/layout/youtube_player_web_view.xml
new file mode 100644
index 000000000..b320cd92b
--- /dev/null
+++ b/inline-youtube-view/src/main/res/layout/youtube_player_web_view.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.flipkart.youtubeview.webview.YouTubePlayerWebView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+</com.flipkart.youtubeview.webview.YouTubePlayerWebView>
\ No newline at end of file
diff --git a/inline-youtube-view/src/main/res/values/color.xml b/inline-youtube-view/src/main/res/values/color.xml
new file mode 100644
index 000000000..4659de2f6
--- /dev/null
+++ b/inline-youtube-view/src/main/res/values/color.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <color name="default_progress_bar_color">#2196F3</color>
+    <color name="black">#000000</color>
+</resources>
\ No newline at end of file
diff --git a/inline-youtube-view/src/main/res/values/dimens.xml b/inline-youtube-view/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..33222abad
--- /dev/null
+++ b/inline-youtube-view/src/main/res/values/dimens.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <dimen name="progress_bar_dimensions">35dp</dimen>
+</resources>
diff --git a/inline-youtube-view/src/main/res/values/strings.xml b/inline-youtube-view/src/main/res/values/strings.xml
new file mode 100644
index 000000000..1ef8fad19
--- /dev/null
+++ b/inline-youtube-view/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">inline-youtube-view</string>
+</resources>
diff --git a/settings.gradle b/settings.gradle
index 867a4183d..82972fdb0 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1 @@
-include ':TMessagesProj'
+include ':TMessagesProj', ':inline-youtube-view', ':shinebuttonlib'
diff --git a/shinebuttonlib/build.gradle b/shinebuttonlib/build.gradle
new file mode 100644
index 000000000..3e70e43fa
--- /dev/null
+++ b/shinebuttonlib/build.gradle
@@ -0,0 +1,35 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion rootProject.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion rootProject.minSdkVersion
+        targetSdkVersion rootProject.targetSdkVersion
+        versionCode 9
+        versionName "0.1.9"
+
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+    buildTypes {
+        release {
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+repositories {
+    google()
+    mavenCentral()
+    jcenter()
+    maven { url 'https://jitpack.io' }
+}
+
+dependencies {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    testImplementation 'junit:junit:4.12'
+}
diff --git a/shinebuttonlib/proguard-rules.pro b/shinebuttonlib/proguard-rules.pro
new file mode 100644
index 000000000..fe43e53b2
--- /dev/null
+++ b/shinebuttonlib/proguard-rules.pro
@@ -0,0 +1,18 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/ChadSong/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+-keep class com.daasuu.** { *; }
\ No newline at end of file
diff --git a/shinebuttonlib/src/androidTest/java/com/sackcentury/shinebuttonlib/ApplicationTest.java b/shinebuttonlib/src/androidTest/java/com/sackcentury/shinebuttonlib/ApplicationTest.java
new file mode 100644
index 000000000..aee3f9a65
--- /dev/null
+++ b/shinebuttonlib/src/androidTest/java/com/sackcentury/shinebuttonlib/ApplicationTest.java
@@ -0,0 +1,13 @@
+package com.sackcentury.shinebuttonlib;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/shinebuttonlib/src/main/AndroidManifest.xml b/shinebuttonlib/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..0f5d9f172
--- /dev/null
+++ b/shinebuttonlib/src/main/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<manifest package="com.sackcentury.shinebuttonlib">
+
+    <application>
+    </application>
+
+</manifest>
diff --git a/shinebuttonlib/src/main/java/com/daasuu/ei/Ease.java b/shinebuttonlib/src/main/java/com/daasuu/ei/Ease.java
new file mode 100644
index 000000000..767b97015
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/daasuu/ei/Ease.java
@@ -0,0 +1,36 @@
+package com.daasuu.ei;
+
+/**
+ * The Easing class provides a collection of ease functions. It does not use the standard 4 param
+ * ease signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
+ */
+public enum Ease {
+    LINEAR,
+    QUAD_IN,
+    QUAD_OUT,
+    QUAD_IN_OUT,
+    CUBIC_IN,
+    CUBIC_OUT,
+    CUBIC_IN_OUT,
+    QUART_IN,
+    QUART_OUT,
+    QUART_IN_OUT,
+    QUINT_IN,
+    QUINT_OUT,
+    QUINT_IN_OUT,
+    SINE_IN,
+    SINE_OUT,
+    SINE_IN_OUT,
+    BACK_IN,
+    BACK_OUT,
+    BACK_IN_OUT,
+    CIRC_IN,
+    CIRC_OUT,
+    CIRC_IN_OUT,
+    BOUNCE_IN,
+    BOUNCE_OUT,
+    BOUNCE_IN_OUT,
+    ELASTIC_IN,
+    ELASTIC_OUT,
+    ELASTIC_IN_OUT
+}
diff --git a/shinebuttonlib/src/main/java/com/daasuu/ei/EasingInterpolator.java b/shinebuttonlib/src/main/java/com/daasuu/ei/EasingInterpolator.java
new file mode 100644
index 000000000..e42d800e3
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/daasuu/ei/EasingInterpolator.java
@@ -0,0 +1,25 @@
+package com.daasuu.ei;
+
+import android.animation.TimeInterpolator;
+
+/**
+ * The Easing class provides a collection of ease functions. It does not use the standard 4 param
+ * ease signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
+ */
+public class EasingInterpolator implements TimeInterpolator {
+
+    private final Ease ease;
+
+    public EasingInterpolator(Ease ease) {
+        this.ease = ease;
+    }
+
+    @Override
+    public float getInterpolation(float input) {
+        return EasingProvider.get(this.ease, input);
+    }
+
+    public Ease getEase() {
+        return ease;
+    }
+}
diff --git a/shinebuttonlib/src/main/java/com/daasuu/ei/EasingProvider.java b/shinebuttonlib/src/main/java/com/daasuu/ei/EasingProvider.java
new file mode 100644
index 000000000..39c6bb622
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/daasuu/ei/EasingProvider.java
@@ -0,0 +1,198 @@
+package com.daasuu.ei;
+
+/**
+ * The Easing class provides a collection of ease functions. It does not use the standard 4 param
+ * ease signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
+ */
+class EasingProvider {
+    /**
+     * @param ease            Easing type
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @return easedValue
+     */
+    public static float get(Ease ease, float elapsedTimeRate) {
+        switch (ease) {
+            case LINEAR:
+                return elapsedTimeRate;
+            case QUAD_IN:
+                return getPowIn(elapsedTimeRate, 2);
+            case QUAD_OUT:
+                return getPowOut(elapsedTimeRate, 2);
+            case QUAD_IN_OUT:
+                return getPowInOut(elapsedTimeRate, 2);
+            case CUBIC_IN:
+                return getPowIn(elapsedTimeRate, 3);
+            case CUBIC_OUT:
+                return getPowOut(elapsedTimeRate, 3);
+            case CUBIC_IN_OUT:
+                return getPowInOut(elapsedTimeRate, 3);
+            case QUART_IN:
+                return getPowIn(elapsedTimeRate, 4);
+            case QUART_OUT:
+                return getPowOut(elapsedTimeRate, 4);
+            case QUART_IN_OUT:
+                return getPowInOut(elapsedTimeRate, 4);
+            case QUINT_IN:
+                return getPowIn(elapsedTimeRate, 5);
+            case QUINT_OUT:
+                return getPowOut(elapsedTimeRate, 5);
+            case QUINT_IN_OUT:
+                return getPowInOut(elapsedTimeRate, 5);
+            case SINE_IN:
+                return (float) (1f - Math.cos(elapsedTimeRate * Math.PI / 2f));
+            case SINE_OUT:
+                return (float) Math.sin(elapsedTimeRate * Math.PI / 2f);
+            case SINE_IN_OUT:
+                return (float) (-0.5f * (Math.cos(Math.PI * elapsedTimeRate) - 1f));
+            case BACK_IN:
+                return (float) (elapsedTimeRate * elapsedTimeRate * ((1.7 + 1f) * elapsedTimeRate - 1.7));
+            case BACK_OUT:
+                return (float) (--elapsedTimeRate * elapsedTimeRate * ((1.7 + 1f) * elapsedTimeRate + 1.7) + 1f);
+            case BACK_IN_OUT:
+                return getBackInOut(elapsedTimeRate, 1.7f);
+            case CIRC_IN:
+                return (float) -(Math.sqrt(1f - elapsedTimeRate * elapsedTimeRate) - 1);
+            case CIRC_OUT:
+                return (float) Math.sqrt(1f - (--elapsedTimeRate) * elapsedTimeRate);
+            case CIRC_IN_OUT:
+                if ((elapsedTimeRate *= 2f) < 1f) {
+                    return (float) (-0.5f * (Math.sqrt(1f - elapsedTimeRate * elapsedTimeRate) - 1f));
+                }
+                return (float) (0.5f * (Math.sqrt(1f - (elapsedTimeRate -= 2f) * elapsedTimeRate) + 1f));
+            case BOUNCE_IN:
+                return getBounceIn(elapsedTimeRate);
+            case BOUNCE_OUT:
+                return getBounceOut(elapsedTimeRate);
+            case BOUNCE_IN_OUT:
+                if (elapsedTimeRate < 0.5f) {
+                    return getBounceIn(elapsedTimeRate * 2f) * 0.5f;
+                }
+                return getBounceOut(elapsedTimeRate * 2f - 1f) * 0.5f + 0.5f;
+            case ELASTIC_IN:
+                return getElasticIn(elapsedTimeRate, 1, 0.3);
+
+            case ELASTIC_OUT:
+                return getElasticOut(elapsedTimeRate, 1, 0.3);
+
+            case ELASTIC_IN_OUT:
+                return getElasticInOut(elapsedTimeRate, 1, 0.45);
+
+            default:
+                return elapsedTimeRate;
+
+        }
+
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param pow             pow The exponent to use (ex. 3 would return a cubic ease).
+     * @return easedValue
+     */
+    private static float getPowIn(float elapsedTimeRate, double pow) {
+        return (float) Math.pow(elapsedTimeRate, pow);
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param pow             pow The exponent to use (ex. 3 would return a cubic ease).
+     * @return easedValue
+     */
+    private static float getPowOut(float elapsedTimeRate, double pow) {
+        return (float) ((float) 1 - Math.pow(1 - elapsedTimeRate, pow));
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param pow             pow The exponent to use (ex. 3 would return a cubic ease).
+     * @return easedValue
+     */
+    private static float getPowInOut(float elapsedTimeRate, double pow) {
+        if ((elapsedTimeRate *= 2) < 1) {
+            return (float) (0.5 * Math.pow(elapsedTimeRate, pow));
+        }
+
+        return (float) (1 - 0.5 * Math.abs(Math.pow(2 - elapsedTimeRate, pow)));
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param amount          amount The strength of the ease.
+     * @return easedValue
+     */
+    private static float getBackInOut(float elapsedTimeRate, float amount) {
+        amount *= 1.525;
+        if ((elapsedTimeRate *= 2) < 1) {
+            return (float) (0.5 * (elapsedTimeRate * elapsedTimeRate * ((amount + 1) * elapsedTimeRate - amount)));
+        }
+        return (float) (0.5 * ((elapsedTimeRate -= 2) * elapsedTimeRate * ((amount + 1) * elapsedTimeRate + amount) + 2));
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @return easedValue
+     */
+    private static float getBounceIn(float elapsedTimeRate) {
+        return 1f - getBounceOut(1f - elapsedTimeRate);
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @return easedValue
+     */
+    private static float getBounceOut(float elapsedTimeRate) {
+        if (elapsedTimeRate < 1 / 2.75) {
+            return (float) (7.5625 * elapsedTimeRate * elapsedTimeRate);
+        } else if (elapsedTimeRate < 2 / 2.75) {
+            return (float) (7.5625 * (elapsedTimeRate -= 1.5 / 2.75) * elapsedTimeRate + 0.75);
+        } else if (elapsedTimeRate < 2.5 / 2.75) {
+            return (float) (7.5625 * (elapsedTimeRate -= 2.25 / 2.75) * elapsedTimeRate + 0.9375);
+        } else {
+            return (float) (7.5625 * (elapsedTimeRate -= 2.625 / 2.75) * elapsedTimeRate + 0.984375);
+        }
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param amplitude       Amplitude of easing
+     * @param period          Animation of period
+     * @return easedValue
+     */
+    private static float getElasticIn(float elapsedTimeRate, double amplitude, double period) {
+        if (elapsedTimeRate == 0 || elapsedTimeRate == 1) return elapsedTimeRate;
+        double pi2 = Math.PI * 2;
+        double s = period / pi2 * Math.asin(1 / amplitude);
+        return (float) -(amplitude * Math.pow(2f, 10f * (elapsedTimeRate -= 1f)) * Math.sin((elapsedTimeRate - s) * pi2 / period));
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param amplitude       Amplitude of easing
+     * @param period          Animation of period
+     * @return easedValue
+     */
+    private static float getElasticOut(float elapsedTimeRate, double amplitude, double period) {
+        if (elapsedTimeRate == 0 || elapsedTimeRate == 1) return elapsedTimeRate;
+
+        double pi2 = Math.PI * 2;
+        double s = period / pi2 * Math.asin(1 / amplitude);
+        return (float) (amplitude * Math.pow(2, -10 * elapsedTimeRate) * Math.sin((elapsedTimeRate - s) * pi2 / period) + 1);
+    }
+
+    /**
+     * @param elapsedTimeRate Elapsed time / Total time
+     * @param amplitude       Amplitude of easing
+     * @param period          Animation of period
+     * @return easedValue
+     */
+    private static float getElasticInOut(float elapsedTimeRate, double amplitude, double period) {
+        double pi2 = Math.PI * 2;
+
+        double s = period / pi2 * Math.asin(1 / amplitude);
+        if ((elapsedTimeRate *= 2) < 1) {
+            return (float) (-0.5f * (amplitude * Math.pow(2, 10 * (elapsedTimeRate -= 1f)) * Math.sin((elapsedTimeRate - s) * pi2 / period)));
+        }
+        return (float) (amplitude * Math.pow(2, -10 * (elapsedTimeRate -= 1)) * Math.sin((elapsedTimeRate - s) * pi2 / period) * 0.5 + 1);
+
+    }
+}
diff --git a/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/PorterImageView.java b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/PorterImageView.java
new file mode 100644
index 000000000..981fd8f9e
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/PorterImageView.java
@@ -0,0 +1,146 @@
+package com.sackcentury.shinebuttonlib;
+
+import android.content.Context;
+import android.graphics.*;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.widget.ImageView;
+
+public abstract class PorterImageView extends ImageView {
+    private static final String TAG = PorterImageView.class.getSimpleName();
+
+    private static final PorterDuffXfermode PORTER_DUFF_XFERMODE = new PorterDuffXfermode(PorterDuff.Mode.DST_IN);
+
+    private Canvas maskCanvas;
+    private Bitmap maskBitmap;
+    private Paint maskPaint;
+
+    private Canvas drawableCanvas;
+    private Bitmap drawableBitmap;
+    private Paint drawablePaint;
+
+    int paintColor = Color.GRAY;
+
+    private boolean invalidated = true;
+
+    public PorterImageView(Context context) {
+        super(context);
+        setup(context, null, 0);
+    }
+
+    public PorterImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        setup(context, attrs, 0);
+    }
+
+    public PorterImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        setup(context, attrs, defStyle);
+    }
+
+    private void setup(Context context, AttributeSet attrs, int defStyle) {
+        if (getScaleType() == ScaleType.FIT_CENTER) {
+            setScaleType(ScaleType.CENTER_CROP);
+        }
+
+        maskPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        maskPaint.setColor(Color.BLACK);
+    }
+
+    public void setSrcColor(int color) {
+        paintColor = color;
+        setImageDrawable(new ColorDrawable(color));
+        if (drawablePaint != null) {
+            drawablePaint.setColor(color);
+            invalidate();
+        }
+    }
+
+    public void invalidate() {
+        invalidated = true;
+        super.invalidate();
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        createMaskCanvas(w, h, oldw, oldh);
+    }
+
+    private void createMaskCanvas(int width, int height, int oldw, int oldh) {
+        boolean sizeChanged = width != oldw || height != oldh;
+        boolean isValid = width > 0 && height > 0;
+        if (isValid && (maskCanvas == null || sizeChanged)) {
+            maskCanvas = new Canvas();
+            maskBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+            maskCanvas.setBitmap(maskBitmap);
+
+            maskPaint.reset();
+            paintMaskCanvas(maskCanvas, maskPaint, width, height);
+
+            drawableCanvas = new Canvas();
+            drawableBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+            drawableCanvas.setBitmap(drawableBitmap);
+            drawablePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            drawablePaint.setColor(paintColor);
+            invalidated = true;
+        }
+    }
+
+    protected abstract void paintMaskCanvas(Canvas maskCanvas, Paint maskPaint, int width, int height);
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (!isInEditMode()) {
+            int saveCount = canvas.saveLayer(0.0f, 0.0f, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);
+            try {
+                if (invalidated) {
+                    Drawable drawable = getDrawable();
+                    if (drawable != null) {
+                        invalidated = false;
+                        Matrix imageMatrix = getImageMatrix();
+                        if (imageMatrix == null) {// && mPaddingTop == 0 && mPaddingLeft == 0) {
+                            drawable.draw(drawableCanvas);
+                        } else {
+                            int drawableSaveCount = drawableCanvas.getSaveCount();
+                            drawableCanvas.save();
+                            drawableCanvas.concat(imageMatrix);
+                            drawable.draw(drawableCanvas);
+                            drawableCanvas.restoreToCount(drawableSaveCount);
+                        }
+
+                        drawablePaint.reset();
+                        drawablePaint.setFilterBitmap(false);
+                        drawablePaint.setXfermode(PORTER_DUFF_XFERMODE);
+                        drawableCanvas.drawBitmap(maskBitmap, 0.0f, 0.0f, drawablePaint);
+                    }
+                }
+
+                if (!invalidated) {
+                    drawablePaint.setXfermode(null);
+                    canvas.drawBitmap(drawableBitmap, 0.0f, 0.0f, drawablePaint);
+                }
+            } catch (Exception e) {
+                String log = "Exception occured while drawing " + getId();
+                Log.e(TAG, log, e);
+            } finally {
+                canvas.restoreToCount(saveCount);
+            }
+        } else {
+            super.onDraw(canvas);
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        if (widthMeasureSpec == 0) {
+            widthMeasureSpec = 50;
+        }
+        if (heightMeasureSpec == 0) {
+            heightMeasureSpec = 50;
+        }
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+    }
+}
\ No newline at end of file
diff --git a/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/PorterShapeImageView.java b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/PorterShapeImageView.java
new file mode 100644
index 000000000..3c296d8f7
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/PorterShapeImageView.java
@@ -0,0 +1,84 @@
+package com.sackcentury.shinebuttonlib;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+
+public class PorterShapeImageView extends PorterImageView {
+    private Drawable shape;
+    private Matrix matrix;
+    private Matrix drawMatrix;
+
+    public PorterShapeImageView(Context context) {
+        super(context);
+        setup(context, null, 0);
+    }
+
+    public PorterShapeImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        setup(context, attrs, 0);
+    }
+
+    public PorterShapeImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        setup(context, attrs, defStyle);
+    }
+
+    private void setup(Context context, AttributeSet attrs, int defStyle) {
+        if(attrs != null){
+            TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.PorterImageView, defStyle, 0);
+            shape = typedArray.getDrawable(R.styleable.PorterImageView_siShape);
+            typedArray.recycle();
+        }
+        matrix = new Matrix();
+    }
+
+    public void setShape(Drawable drawable) {
+        shape = drawable;
+        invalidate();
+    }
+
+    @Override
+    protected void paintMaskCanvas(Canvas maskCanvas, Paint maskPaint, int width, int height) {
+        if(shape != null) {
+            if (shape instanceof BitmapDrawable) {
+                configureBitmapBounds(getWidth(), getHeight());
+                if(drawMatrix != null) {
+                    int drawableSaveCount = maskCanvas.getSaveCount();
+                    maskCanvas.save();
+                    maskCanvas.concat(matrix);
+                    shape.draw(maskCanvas);
+                    maskCanvas.restoreToCount(drawableSaveCount);
+                    return;
+                }
+            }
+
+            shape.setBounds(0, 0, getWidth(), getHeight());
+            shape.draw(maskCanvas);
+        }
+    }
+
+    private void configureBitmapBounds(int viewWidth, int viewHeight) {
+        drawMatrix = null;
+        int drawableWidth = shape.getIntrinsicWidth();
+        int drawableHeight = shape.getIntrinsicHeight();
+        boolean fits = viewWidth == drawableWidth && viewHeight == drawableHeight;
+
+        if (drawableWidth > 0 && drawableHeight > 0 && !fits) {
+            shape.setBounds(0, 0, drawableWidth, drawableHeight);
+            float widthRatio = (float) viewWidth / (float) drawableWidth;
+            float heightRatio = (float) viewHeight / (float) drawableHeight;
+            float scale = Math.min(widthRatio, heightRatio);
+            float dx = (int) ((viewWidth - drawableWidth * scale) * 0.5f + 0.5f);
+            float dy = (int) ((viewHeight - drawableHeight * scale) * 0.5f + 0.5f);
+
+            matrix.setScale(scale, scale);
+            matrix.postTranslate(dx, dy);
+        }
+    }
+}
diff --git a/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineAnimator.java b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineAnimator.java
new file mode 100644
index 000000000..6275fc257
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineAnimator.java
@@ -0,0 +1,46 @@
+package com.sackcentury.shinebuttonlib;
+
+import android.animation.ValueAnimator;
+import android.graphics.Canvas;
+
+import com.daasuu.ei.Ease;
+import com.daasuu.ei.EasingInterpolator;
+
+/**
+ * @author Chad
+ * @title com.sackcentury.shinebuttonlib
+ * @description
+ * @modifier
+ * @date
+ * @since 16/7/5 5:09
+ **/
+public class ShineAnimator extends ValueAnimator {
+
+    float MAX_VALUE = 1.5f;
+    long ANIM_DURATION = 1500;
+    Canvas canvas;
+
+    ShineAnimator() {
+        setFloatValues(1f, MAX_VALUE);
+        setDuration(ANIM_DURATION);
+        setStartDelay(200);
+        setInterpolator(new EasingInterpolator(Ease.QUART_OUT));
+    }
+    ShineAnimator(long duration,float max_value,long delay) {
+        setFloatValues(1f, max_value);
+        setDuration(duration);
+        setStartDelay(delay);
+        setInterpolator(new EasingInterpolator(Ease.QUART_OUT));
+    }
+
+    public void startAnim(final ShineView shineView, final int centerAnimX, final int centerAnimY) {
+
+        start();
+    }
+
+    public void setCanvas(Canvas canvas) {
+        this.canvas = canvas;
+    }
+
+
+}
diff --git a/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineButton.java b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineButton.java
new file mode 100644
index 000000000..d46803ce9
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineButton.java
@@ -0,0 +1,352 @@
+package com.sackcentury.shinebuttonlib;
+
+import android.animation.Animator;
+import android.animation.ValueAnimator;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.animation.LinearInterpolator;
+
+/**
+ * @author Chad
+ * @title com.sackcentury.shinebuttonlib
+ * @description
+ * @modifier
+ * @date
+ * @since 16/7/5 2:27
+ **/
+public class ShineButton extends PorterShapeImageView {
+    private static final String TAG = "ShineButton";
+    private boolean isChecked = false;
+
+    private int btnColor;
+    private int btnFillColor;
+
+    int DEFAULT_WIDTH = 50;
+    int DEFAULT_HEIGHT = 50;
+
+    DisplayMetrics metrics = new DisplayMetrics();
+
+
+    Activity activity;
+    ShineView shineView;
+    ValueAnimator shakeAnimator;
+    ShineView.ShineParams shineParams = new ShineView.ShineParams();
+
+    OnCheckedChangeListener listener;
+
+    private int bottomHeight;
+    private int realBottomHeight;
+
+    public ShineButton(Context context) {
+        super(context);
+        if (context instanceof Activity) {
+            init((Activity) context);
+        }
+    }
+
+    public ShineButton(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initButton(context, attrs);
+    }
+
+
+    public ShineButton(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        initButton(context, attrs);
+    }
+
+    private void initButton(Context context, AttributeSet attrs) {
+
+        if (context instanceof Activity) {
+            init((Activity) context);
+        }
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ShineButton);
+        btnColor = a.getColor(R.styleable.ShineButton_btn_color, Color.GRAY);
+        btnFillColor = a.getColor(R.styleable.ShineButton_btn_fill_color, Color.BLACK);
+        shineParams.allowRandomColor = a.getBoolean(R.styleable.ShineButton_allow_random_color, false);
+        shineParams.animDuration = a.getInteger(R.styleable.ShineButton_shine_animation_duration, (int) shineParams.animDuration);
+        shineParams.bigShineColor = a.getColor(R.styleable.ShineButton_big_shine_color, shineParams.bigShineColor);
+        shineParams.clickAnimDuration = a.getInteger(R.styleable.ShineButton_click_animation_duration, (int) shineParams.clickAnimDuration);
+        shineParams.enableFlashing = a.getBoolean(R.styleable.ShineButton_enable_flashing, false);
+        shineParams.shineCount = a.getInteger(R.styleable.ShineButton_shine_count, shineParams.shineCount);
+        shineParams.shineDistanceMultiple = a.getFloat(R.styleable.ShineButton_shine_distance_multiple, shineParams.shineDistanceMultiple);
+        shineParams.shineTurnAngle = a.getFloat(R.styleable.ShineButton_shine_turn_angle, shineParams.shineTurnAngle);
+        shineParams.smallShineColor = a.getColor(R.styleable.ShineButton_small_shine_color, shineParams.smallShineColor);
+        shineParams.smallShineOffsetAngle = a.getFloat(R.styleable.ShineButton_small_shine_offset_angle, shineParams.smallShineOffsetAngle);
+        shineParams.shineSize = a.getDimensionPixelSize(R.styleable.ShineButton_shine_size, shineParams.shineSize);
+        a.recycle();
+        setSrcColor(btnColor);
+    }
+
+    public int getBottomHeight(boolean real) {
+        if (real) {
+            return realBottomHeight;
+        }
+        return bottomHeight;
+    }
+
+    public int getColor() {
+        return btnFillColor;
+    }
+
+    public boolean isChecked() {
+        return isChecked;
+    }
+
+
+    public void setBtnColor(int btnColor) {
+        this.btnColor = btnColor;
+        setSrcColor(this.btnColor);
+    }
+
+    public void setBtnFillColor(int btnFillColor) {
+        this.btnFillColor = btnFillColor;
+    }
+
+    public void setChecked(boolean checked, boolean anim) {
+        setChecked(checked, anim, true);
+    }
+
+    private void setChecked(boolean checked, boolean anim, boolean callBack) {
+        isChecked = checked;
+        if (checked) {
+            setSrcColor(btnFillColor);
+            isChecked = true;
+            if (anim) showAnim();
+        } else {
+            setSrcColor(btnColor);
+            isChecked = false;
+            if (anim) setCancel();
+        }
+        if (callBack) {
+            onListenerUpdate(checked);
+        }
+    }
+
+    public void setChecked(boolean checked) {
+        setChecked(checked, false, false);
+    }
+
+    private void onListenerUpdate(boolean checked) {
+        if (listener != null) {
+            listener.onCheckedChanged(this, checked);
+        }
+    }
+
+    public void setCancel() {
+        setSrcColor(btnColor);
+        if (shakeAnimator != null) {
+            shakeAnimator.end();
+            shakeAnimator.cancel();
+        }
+    }
+
+    public void setAllowRandomColor(boolean allowRandomColor) {
+        shineParams.allowRandomColor = allowRandomColor;
+    }
+
+    public void setAnimDuration(int durationMs) {
+        shineParams.animDuration = durationMs;
+    }
+
+    public void setBigShineColor(int color) {
+        shineParams.bigShineColor = color;
+    }
+
+    public void setClickAnimDuration(int durationMs) {
+        shineParams.clickAnimDuration = durationMs;
+    }
+
+    public void enableFlashing(boolean enable) {
+        shineParams.enableFlashing = enable;
+    }
+
+    public void setShineCount(int count) {
+        shineParams.shineCount = count;
+    }
+
+    public void setShineDistanceMultiple(float multiple) {
+        shineParams.shineDistanceMultiple = multiple;
+    }
+
+    public void setShineTurnAngle(float angle) {
+        shineParams.shineTurnAngle = angle;
+    }
+
+    public void setSmallShineColor(int color) {
+        shineParams.smallShineColor = color;
+    }
+
+    public void setSmallShineOffAngle(float angle) {
+        shineParams.smallShineOffsetAngle = angle;
+    }
+
+    public void setShineSize(int size) {
+        shineParams.shineSize = size;
+    }
+
+    @Override
+    public void setOnClickListener(OnClickListener l) {
+        if (l instanceof OnButtonClickListener) {
+            super.setOnClickListener(l);
+        } else {
+            if (onButtonClickListener != null) {
+                onButtonClickListener.setListener(l);
+            }
+        }
+    }
+
+    public void setOnCheckStateChangeListener(OnCheckedChangeListener listener) {
+        this.listener = listener;
+    }
+
+
+    OnButtonClickListener onButtonClickListener;
+
+    public void init(Activity activity) {
+        this.activity = activity;
+        onButtonClickListener = new OnButtonClickListener();
+        setOnClickListener(onButtonClickListener);
+
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        calPixels();
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+    }
+
+    public void showAnim() {
+        if (activity != null) {
+            final ViewGroup rootView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT);
+            shineView = new ShineView(activity, this, shineParams);
+            rootView.addView(shineView, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+            doShareAnim();
+        } else {
+            Log.e(TAG, "Please init.");
+        }
+    }
+
+    public void removeView(View view) {
+        if (activity != null) {
+            final ViewGroup rootView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT);
+            rootView.removeView(view);
+        } else {
+            Log.e(TAG, "Please init.");
+        }
+    }
+
+    public void setShapeResource(int raw) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            setShape(getResources().getDrawable(raw, null));
+        } else {
+            setShape(getResources().getDrawable(raw));
+        }
+    }
+
+    private void doShareAnim() {
+        shakeAnimator = ValueAnimator.ofFloat(0.4f, 1f, 0.9f, 1f);
+        shakeAnimator.setInterpolator(new LinearInterpolator());
+        shakeAnimator.setDuration(500);
+        shakeAnimator.setStartDelay(180);
+        invalidate();
+        shakeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                setScaleX((float) valueAnimator.getAnimatedValue());
+                setScaleY((float) valueAnimator.getAnimatedValue());
+            }
+        });
+        shakeAnimator.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animator) {
+                setSrcColor(btnFillColor);
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animator) {
+                setSrcColor(isChecked ? btnFillColor : btnColor);
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animator) {
+                setSrcColor(btnColor);
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animator) {
+
+            }
+        });
+        shakeAnimator.start();
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+    }
+
+    private void calPixels() {
+        if (activity != null && metrics != null) {
+            activity.getWindowManager().getDefaultDisplay().getMetrics(metrics);
+            int[] location = new int[2];
+            getLocationInWindow(location);
+            Rect visibleFrame = new Rect();
+            activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(visibleFrame);
+            realBottomHeight = visibleFrame.height() - location[1];
+            bottomHeight = metrics.heightPixels - location[1];
+        }
+    }
+
+    public class OnButtonClickListener implements OnClickListener {
+        public void setListener(OnClickListener listener) {
+            this.listener = listener;
+        }
+
+        OnClickListener listener;
+
+        public OnButtonClickListener() {
+        }
+
+        public OnButtonClickListener(OnClickListener l) {
+            listener = l;
+        }
+
+        @Override
+        public void onClick(View view) {
+            if (!isChecked) {
+                isChecked = true;
+                showAnim();
+            } else {
+                isChecked = false;
+                setCancel();
+            }
+            onListenerUpdate(isChecked);
+            if (listener != null) {
+                listener.onClick(view);
+            }
+        }
+    }
+
+    public interface OnCheckedChangeListener {
+        void onCheckedChanged(View view, boolean checked);
+    }
+
+}
diff --git a/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineView.java b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineView.java
new file mode 100644
index 000000000..3617c9225
--- /dev/null
+++ b/shinebuttonlib/src/main/java/com/sackcentury/shinebuttonlib/ShineView.java
@@ -0,0 +1,356 @@
+package com.sackcentury.shinebuttonlib;
+
+import android.animation.Animator;
+import android.animation.ValueAnimator;
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.WindowManager;
+
+import com.daasuu.ei.Ease;
+import com.daasuu.ei.EasingInterpolator;
+
+import java.util.Random;
+
+/**
+ * @author Chad
+ * @title com.sackcentury.shinebuttonlib
+ * @description
+ * @modifier
+ * @date
+ * @since 16/7/5 3:57
+ **/
+public class ShineView extends View {
+    private static final String TAG = "ShineView";
+
+    private static long FRAME_REFRESH_DELAY = 25;//default 10ms ,change to 25ms for saving cpu.
+
+    ShineAnimator shineAnimator;
+    ValueAnimator clickAnimator;
+
+    ShineButton shineButton;
+    private Paint paint;
+    private Paint paint2;
+    private Paint paintSmall;
+
+    int colorCount = 10;
+    static int colorRandom[] = new int[10];
+
+    //Customer property
+    int shineCount;
+    float smallOffsetAngle;
+    float turnAngle;
+    long animDuration;
+    long clickAnimDuration;
+    float shineDistanceMultiple;
+    int smallShineColor = colorRandom[0];
+    int bigShineColor = colorRandom[1];
+
+    int shineSize = 0;
+
+    boolean allowRandomColor = false;
+    boolean enableFlashing = false;
+
+
+    RectF rectF = new RectF();
+    RectF rectFSmall = new RectF();
+
+    Random random = new Random();
+    int centerAnimX;
+    int centerAnimY;
+    int btnWidth;
+    int btnHeight;
+
+    double thirdLength;
+    float value;
+    float clickValue = 0;
+    boolean isRun = false;
+    private float distanceOffset = 0.2f;
+
+
+    public ShineView(Context context) {
+        super(context);
+    }
+
+    public ShineView(Context context, final ShineButton shineButton, ShineParams shineParams) {
+        super(context);
+
+
+        initShineParams(shineParams, shineButton);
+
+
+        this.shineAnimator = new ShineAnimator(animDuration, shineDistanceMultiple, clickAnimDuration);
+        ValueAnimator.setFrameDelay(FRAME_REFRESH_DELAY);
+        this.shineButton = shineButton;
+
+
+        paint = new Paint();
+        paint.setColor(bigShineColor);
+        paint.setStrokeWidth(20);
+        paint.setStyle(Paint.Style.STROKE);
+        paint.setStrokeCap(Paint.Cap.ROUND);
+
+        paint2 = new Paint();
+        paint2.setColor(Color.WHITE);
+        paint2.setStrokeWidth(20);
+        paint2.setStrokeCap(Paint.Cap.ROUND);
+
+        paintSmall = new Paint();
+        paintSmall.setColor(smallShineColor);
+        paintSmall.setStrokeWidth(10);
+        paintSmall.setStyle(Paint.Style.STROKE);
+        paintSmall.setStrokeCap(Paint.Cap.ROUND);
+
+        clickAnimator = ValueAnimator.ofFloat(0f, 1.1f);
+        ValueAnimator.setFrameDelay(FRAME_REFRESH_DELAY);
+        clickAnimator.setDuration(clickAnimDuration);
+        clickAnimator.setInterpolator(new EasingInterpolator(Ease.QUART_OUT));
+        clickAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                clickValue = (float) valueAnimator.getAnimatedValue();
+                invalidate();
+            }
+        });
+        clickAnimator.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animator) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animator) {
+                clickValue = 0;
+                invalidate();
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animator) {
+
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animator) {
+
+            }
+        });
+        shineAnimator.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animator) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animator) {
+                shineButton.removeView(ShineView.this);
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animator) {
+
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animator) {
+
+            }
+        });
+
+    }
+
+
+    public ShineView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public ShineView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+    }
+
+
+    public void showAnimation(ShineButton shineButton) {
+        btnWidth = shineButton.getWidth();
+        btnHeight = shineButton.getHeight();
+        thirdLength = getThirdLength(btnHeight, btnWidth);
+        int[] location = new int[2];
+        shineButton.getLocationInWindow(location);
+
+        Rect visibleFrame = new Rect();
+
+        if (isWindowsNotLimit(shineButton.activity)) {
+            shineButton.activity.getWindow().getDecorView().getLocalVisibleRect(visibleFrame);
+        } else {
+            shineButton.activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(visibleFrame);
+        }
+
+        centerAnimX = location[0] + btnWidth / 2 - visibleFrame.left; // If navigation bar is not displayed on left, visibleFrame.left is 0.
+        if (isTranslucentNavigation(shineButton.activity)) {
+            if (isFullScreen(shineButton.activity)) {
+                centerAnimY = visibleFrame.height() - shineButton.getBottomHeight(false) + btnHeight / 2;
+            } else {
+                centerAnimY = visibleFrame.height() - shineButton.getBottomHeight(true) + btnHeight / 2;
+            }
+        } else {
+            centerAnimY = getMeasuredHeight() - shineButton.getBottomHeight(false) + btnHeight / 2;
+        }
+        shineAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                value = (float) valueAnimator.getAnimatedValue();
+                if (shineSize != 0 && shineSize > 0) {
+                    paint.setStrokeWidth((shineSize) * (shineDistanceMultiple - value));
+                    paintSmall.setStrokeWidth(((float) shineSize / 3 * 2) * (shineDistanceMultiple - value));
+                } else {
+                    paint.setStrokeWidth((btnWidth / 2) * (shineDistanceMultiple - value));
+                    paintSmall.setStrokeWidth((btnWidth / 3) * (shineDistanceMultiple - value));
+                }
+
+
+                rectF.set(centerAnimX - (btnWidth / (3 - shineDistanceMultiple) * value), centerAnimY - (btnHeight / (3 - shineDistanceMultiple) * value), centerAnimX + (btnWidth / (3 - shineDistanceMultiple) * value), centerAnimY + (btnHeight / (3 - shineDistanceMultiple) * value));
+                rectFSmall.set(centerAnimX - (btnWidth / ((3 - shineDistanceMultiple) + distanceOffset) * value), centerAnimY - (btnHeight / ((3 - shineDistanceMultiple) + distanceOffset) * value), centerAnimX + (btnWidth / ((3 - shineDistanceMultiple) + distanceOffset) * value), centerAnimY + (btnHeight / ((3 - shineDistanceMultiple) + distanceOffset) * value));
+
+                invalidate();
+            }
+        });
+        shineAnimator.startAnim(this, centerAnimX, centerAnimY);
+        clickAnimator.start();
+    }
+
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        for (int i = 0; i < shineCount; i++) {
+            if (allowRandomColor) {
+                paint.setColor(colorRandom[Math.abs(colorCount / 2 - i) >= colorCount ? colorCount - 1 : Math.abs(colorCount / 2 - i)]);
+            }
+            canvas.drawArc(rectF, 360f / shineCount * i + 1 + ((value - 1) * turnAngle), 0.1f, false, getConfigPaint(paint));
+        }
+
+        for (int i = 0; i < shineCount; i++) {
+            if (allowRandomColor) {
+                paint.setColor(colorRandom[Math.abs(colorCount / 2 - i) >= colorCount ? colorCount - 1 : Math.abs(colorCount / 2 - i)]);
+            }
+            canvas.drawArc(rectFSmall, 360f / shineCount * i + 1 - smallOffsetAngle + ((value - 1) * turnAngle), 0.1f, false, getConfigPaint(paintSmall));
+
+        }
+        paint.setStrokeWidth(btnWidth * (clickValue) * (shineDistanceMultiple - distanceOffset));
+        if (clickValue != 0) {
+            paint2.setStrokeWidth(btnWidth * (clickValue) * (shineDistanceMultiple - distanceOffset) - 8);
+        } else {
+            paint2.setStrokeWidth(0);
+        }
+        canvas.drawPoint(centerAnimX, centerAnimY, paint);
+        canvas.drawPoint(centerAnimX, centerAnimY, paint2);
+        if (shineAnimator != null && !isRun) {
+            isRun = true;
+            showAnimation(shineButton);
+        }
+    }
+
+    private Paint getConfigPaint(Paint paint) {
+        if (enableFlashing) {
+            paint.setColor(colorRandom[random.nextInt(colorCount - 1)]);
+        }
+        return paint;
+    }
+
+    private double getThirdLength(int btnHeight, int btnWidth) {
+        int all = btnHeight * btnHeight + btnWidth * btnWidth;
+        return Math.sqrt(all);
+    }
+
+    public static class ShineParams {
+        ShineParams() {
+            colorRandom[0] = Color.parseColor("#FFFF99");
+            colorRandom[1] = Color.parseColor("#FFCCCC");
+            colorRandom[2] = Color.parseColor("#996699");
+            colorRandom[3] = Color.parseColor("#FF6666");
+            colorRandom[4] = Color.parseColor("#FFFF66");
+            colorRandom[5] = Color.parseColor("#F44336");
+            colorRandom[6] = Color.parseColor("#666666");
+            colorRandom[7] = Color.parseColor("#CCCC00");
+            colorRandom[8] = Color.parseColor("#666666");
+            colorRandom[9] = Color.parseColor("#999933");
+        }
+
+        public boolean allowRandomColor = false;
+        public long animDuration = 1500;
+        public int bigShineColor = 0;
+        public long clickAnimDuration = 200;
+        public boolean enableFlashing = false;
+        public int shineCount = 7;
+        public float shineTurnAngle = 20;
+        public float shineDistanceMultiple = 1.5f;
+        public float smallShineOffsetAngle = 20;
+        public int smallShineColor = 0;
+        public int shineSize = 0;
+    }
+
+    private void initShineParams(ShineParams shineParams, ShineButton shineButton) {
+        shineCount = shineParams.shineCount;
+        turnAngle = shineParams.shineTurnAngle;
+        smallOffsetAngle = shineParams.smallShineOffsetAngle;
+        enableFlashing = shineParams.enableFlashing;
+        allowRandomColor = shineParams.allowRandomColor;
+        shineDistanceMultiple = shineParams.shineDistanceMultiple;
+        animDuration = shineParams.animDuration;
+        clickAnimDuration = shineParams.clickAnimDuration;
+        smallShineColor = shineParams.smallShineColor;
+        bigShineColor = shineParams.bigShineColor;
+        shineSize = shineParams.shineSize;
+        if (smallShineColor == 0) {
+            smallShineColor = colorRandom[6];
+        }
+
+        if (bigShineColor == 0) {
+            bigShineColor = shineButton.getColor();
+        }
+
+    }
+
+    /**
+     * @param activity
+     * @return isFullScreen
+     */
+    public static boolean isFullScreen(Activity activity) {
+        int flag = activity.getWindow().getAttributes().flags;
+        if ((flag & WindowManager.LayoutParams.FLAG_FULLSCREEN)
+                == WindowManager.LayoutParams.FLAG_FULLSCREEN) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * @param activity
+     * @return isTranslucentNavigation
+     */
+    public static boolean isTranslucentNavigation(Activity activity) {
+        int flag = activity.getWindow().getAttributes().flags;
+        if ((flag & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)
+                == WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isWindowsNotLimit(Activity activity) {
+        int flag = activity.getWindow().getAttributes().flags;
+        if ((flag & WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS)
+                == WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+}
diff --git a/shinebuttonlib/src/main/res/menu/main_menu.xml b/shinebuttonlib/src/main/res/menu/main_menu.xml
new file mode 100644
index 000000000..c4520502b
--- /dev/null
+++ b/shinebuttonlib/src/main/res/menu/main_menu.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item
+        android:id="@+id/fragment_page"
+        android:title="Fragment" />
+</menu>
\ No newline at end of file
diff --git a/shinebuttonlib/src/main/res/raw/heart.png b/shinebuttonlib/src/main/res/raw/heart.png
new file mode 100644
index 000000000..f1baa7763
Binary files /dev/null and b/shinebuttonlib/src/main/res/raw/heart.png differ
diff --git a/shinebuttonlib/src/main/res/raw/like.png b/shinebuttonlib/src/main/res/raw/like.png
new file mode 100644
index 000000000..de3612b6f
Binary files /dev/null and b/shinebuttonlib/src/main/res/raw/like.png differ
diff --git a/shinebuttonlib/src/main/res/raw/smile.png b/shinebuttonlib/src/main/res/raw/smile.png
new file mode 100644
index 000000000..126d3ab43
Binary files /dev/null and b/shinebuttonlib/src/main/res/raw/smile.png differ
diff --git a/shinebuttonlib/src/main/res/raw/star.png b/shinebuttonlib/src/main/res/raw/star.png
new file mode 100644
index 000000000..04215c65e
Binary files /dev/null and b/shinebuttonlib/src/main/res/raw/star.png differ
diff --git a/shinebuttonlib/src/main/res/values/attrs.xml b/shinebuttonlib/src/main/res/values/attrs.xml
new file mode 100644
index 000000000..93ffff686
--- /dev/null
+++ b/shinebuttonlib/src/main/res/values/attrs.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="ShineButton">
+        <attr name="btn_color" format="color" />
+        <attr name="btn_fill_color" format="color" />
+        <attr name="shine_count" format="integer" />
+        <attr name="shine_turn_angle" format="float" />
+        <attr name="small_shine_offset_angle" format="float" />
+        <attr name="enable_flashing" format="boolean" />
+        <attr name="allow_random_color" format="boolean" />
+        <attr name="small_shine_color" format="color" />
+        <attr name="big_shine_color" format="color" />
+        <attr name="shine_animation_duration" format="integer" />
+        <attr name="click_animation_duration" format="integer" />
+        <attr name="shine_distance_multiple" format="float" />
+        <attr name="shine_size" format="dimension" />
+    </declare-styleable>
+    <declare-styleable name="PorterImageView">
+        <attr name="siShape" format="integer|reference" />
+    </declare-styleable>
+</resources>
\ No newline at end of file
diff --git a/shinebuttonlib/src/main/res/values/strings.xml b/shinebuttonlib/src/main/res/values/strings.xml
new file mode 100644
index 000000000..3ec67001c
--- /dev/null
+++ b/shinebuttonlib/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">ShineButtonLib</string>
+</resources>
diff --git a/shinebuttonlib/src/test/java/com/sackcentury/shinebuttonlib/ExampleUnitTest.java b/shinebuttonlib/src/test/java/com/sackcentury/shinebuttonlib/ExampleUnitTest.java
new file mode 100644
index 000000000..a9f757144
--- /dev/null
+++ b/shinebuttonlib/src/test/java/com/sackcentury/shinebuttonlib/ExampleUnitTest.java
@@ -0,0 +1,15 @@
+package com.sackcentury.shinebuttonlib;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
