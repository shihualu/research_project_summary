diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index e809b47d2..e87d4072c 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -81,7 +81,7 @@ android {
         }
     }
 
-    defaultConfig.versionCode = 851 + 13
+    defaultConfig.versionCode = 851 + 15
 
     sourceSets.debug {
         manifest.srcFile 'config/debug/AndroidManifest.xml'
@@ -121,7 +121,9 @@ android {
     defaultConfig {
         minSdkVersion 21
         targetSdkVersion 25
-        versionName "3.13.1.13"
+        versionName "3.13.1.15"
+
+        buildConfigField "String", "BASE64_PUBLIC_KEY", "\"${base64_public_key}\""
 
         /*externalNativeBuild {
             ndkBuild {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java
index 1584d8ea8..d49c92754 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java
@@ -1528,4 +1528,13 @@ public static void setRectToRect(Matrix matrix, RectF src, RectF dst, int rotati
         matrix.preScale(sx, sy);
         matrix.preTranslate(tx, ty);
     }
+
+    public static boolean isPackageInstalled(Context context, String packageName) {
+        try {
+            context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_ACTIVITIES);
+            return true;
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/DonateHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/DonateHelper.java
new file mode 100644
index 000000000..60240877c
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/DonateHelper.java
@@ -0,0 +1,318 @@
+package org.telegram.messenger.support.iap;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.widget.Toast;
+
+import org.telegram.messenger.BuildConfig;
+
+import org.telegram.messenger.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.messenger.support.iap.utils.IabBroadcastReceiver;
+import org.telegram.messenger.support.iap.utils.IabHelper;
+import org.telegram.messenger.support.iap.utils.IabResult;
+import org.telegram.messenger.support.iap.utils.Inventory;
+import org.telegram.messenger.support.iap.utils.Purchase;
+
+/**
+ * Created by Rikka on 2016/9/3.
+ */
+public class DonateHelper implements IabBroadcastReceiver.IabBroadcastListener {
+
+    private static final String TAG = "DonateHelper";
+
+    public static final String SKU_DONATE_1 = "donate_1";
+    public static final String SKU_DONATE_2 = "donate_2";
+    public static final String SKU_DONATE_5 = "donate_5";
+    public static final String SKU_DONATE_10 = "donate_10";
+
+    private static final int RC_REQUEST = 10001;
+
+    private Context mContext;
+
+    // The helper object
+    private IabHelper mHelper;
+
+    // Provides purchase notification while this app is running
+    private IabBroadcastReceiver mBroadcastReceiver;
+
+    private boolean isSuccess;
+
+    public DonateHelper(Context context) {
+        mContext = context;
+
+        String base64EncodedPublicKey = BuildConfig.BASE64_PUBLIC_KEY;
+
+        // Create the helper, passing it our context and the public key to verify signatures with
+        Log.d(TAG, "Creating IAB helper.");
+        mHelper = new IabHelper(context, base64EncodedPublicKey);
+
+        // enable debug logging (for a production application, you should set this to false).
+        mHelper.enableDebugLogging(true);
+
+        // Start setup. This is asynchronous and the specified listener
+        // will be called once setup completes.
+        Log.d(TAG, "Starting setup.");
+        mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {
+            public void onIabSetupFinished(IabResult result) {
+                Log.d(TAG, "Setup finished.");
+
+                if (!result.isSuccess()) {
+                    // Oh noes, there was a problem.
+                    complain("Problem setting up in-app billing: " + result);
+                    isSuccess = false;
+                    return;
+                }
+
+                isSuccess = true;
+
+                // Have we been disposed of in the meantime? If so, quit.
+                if (mHelper == null) return;
+
+                // Important: Dynamically register for broadcast messages about updated purchases.
+                // We register the receiver here instead of as a <receiver> in the Manifest
+                // because we always call getPurchases() at startup, so therefore we can ignore
+                // any broadcasts sent while the app isn't running.
+                // Note: registering this listener in an Activity is a bad idea, but is done here
+                // because this is a SAMPLE. Regardless, the receiver must be registered after
+                // IabHelper is setup, but before first call to getPurchases().
+                mBroadcastReceiver = new IabBroadcastReceiver(DonateHelper.this);
+                IntentFilter broadcastFilter = new IntentFilter(IabBroadcastReceiver.ACTION);
+                mContext.registerReceiver(mBroadcastReceiver, broadcastFilter);
+
+                // IAB is fully set up. Now, let's get an inventory of stuff we own.
+                Log.d(TAG, "Setup successful. Querying inventory.");
+                try {
+                    mHelper.queryInventoryAsync(mGotInventoryListener);
+                } catch (IabHelper.IabAsyncInProgressException e) {
+                    complain("Error querying inventory. Another async operation in progress.");
+                }
+            }
+        });
+    }
+
+    // Listener that's called when we finish querying the items and subscriptions we own
+    IabHelper.QueryInventoryFinishedListener mGotInventoryListener = new IabHelper.QueryInventoryFinishedListener() {
+        public void onQueryInventoryFinished(IabResult result, Inventory inventory) {
+            Log.d(TAG, "Query inventory finished.");
+
+            // Have we been disposed of in the meantime? If so, quit.
+            if (mHelper == null) return;
+
+            // Is it a failure?
+            if (result.isFailure()) {
+                complain("Failed to query inventory: " + result);
+                return;
+            }
+
+            consume(inventory, SKU_DONATE_1);
+            consume(inventory, SKU_DONATE_2);
+            consume(inventory, SKU_DONATE_5);
+            consume(inventory, SKU_DONATE_10);
+
+            Log.d(TAG, "Query inventory was successful.");
+        }
+    };
+
+    private void consume(Inventory inventory, String sku) {
+        Purchase gasPurchase = inventory.getPurchase(sku);
+        if (gasPurchase != null/* && verifyDeveloperPayload(gasPurchase)*/) {
+            Log.d(TAG, "Consuming " + sku);
+            try {
+                mHelper.consumeAsync(inventory.getPurchase(sku), mConsumeFinishedListener);
+            } catch (IabHelper.IabAsyncInProgressException e) {
+                complain("Error consuming. Another async operation in progress.");
+            }
+            return;
+        }
+    }
+
+    // Callback for when a purchase is finished
+    IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() {
+        public void onIabPurchaseFinished(IabResult result, Purchase purchase) {
+            Log.d(TAG, "Purchase finished: " + result + ", purchase: " + purchase);
+
+            // if we were disposed of in the meantime, quit.
+            if (mHelper == null) return;
+
+            if (result.isFailure()) {
+                complain("Error purchasing: " + result);
+                return;
+            }
+            if (!verifyDeveloperPayload(purchase)) {
+                complain("Error purchasing. Authenticity verification failed.");
+                return;
+            }
+
+            Log.d(TAG, "Purchase successful.");
+
+            if (mPurchaseSuccessListener != null) {
+                mPurchaseSuccessListener.onSuccess(purchase.getSku());
+            }
+
+            if (true/*purchase.getSku().equals(SKU_DONATE_1)*/) {
+                // Consume it.
+                try {
+                    mHelper.consumeAsync(purchase, mConsumeFinishedListener);
+                } catch (IabHelper.IabAsyncInProgressException e) {
+                    complain("Error consuming. Another async operation in progress.");
+                    return;
+                }
+            }
+        }
+    };
+
+    // Called when consumption is complete
+    IabHelper.OnConsumeFinishedListener mConsumeFinishedListener = new IabHelper.OnConsumeFinishedListener() {
+        public void onConsumeFinished(Purchase purchase, IabResult result) {
+            Log.d(TAG, "Consumption finished. Purchase: " + purchase + ", result: " + result);
+
+            // if we were disposed of in the meantime, quit.
+            if (mHelper == null) return;
+
+            // We know this is the "gas" sku because it's the only one we consume,
+            // so we don't check which sku was consumed. If you have more than one
+            // sku, you probably should check...
+            if (result.isSuccess()) {
+                // successfully consumed, so we apply the effects of the item in our
+                // game world's logic, which in our case means filling the gas tank a bit
+                Log.d(TAG, "Consumption successful. Provisioning.");
+            } else {
+                complain("Error while consuming: " + result);
+            }
+            Log.d(TAG, "End consumption flow.");
+        }
+    };
+
+
+    private boolean verifyDeveloperPayload(Purchase purchase) {
+        return true;
+    }
+
+
+    @Override
+    public void receivedBroadcast() {
+        // Received a broadcast notification that the inventory of items has changed
+        Log.d(TAG, "Received broadcast notification. Querying inventory.");
+        try {
+            mHelper.queryInventoryAsync(mGotInventoryListener);
+        } catch (IabHelper.IabAsyncInProgressException e) {
+            complain("Error querying inventory. Another async operation in progress.");
+        }
+    }
+
+    void complain(String message) {
+        Log.e(TAG, "**** Error: " + message);
+        alert("Error: " + message);
+    }
+
+    void alert(String message) {
+        /*AlertDialog.Builder bld = new AlertDialog.Builder(mContext);
+        bld.setMessage(message);
+        bld.setNeutralButton("OK", null);
+        Log.d(TAG, "Showing alert dialog: " + message);
+        bld.create().show();*/
+        //Toast.makeText(mContext, message, Toast.LENGTH_SHORT).show();
+    }
+
+    public interface OnPurchaseSuccessListener {
+        void onSuccess(String sku);
+    }
+
+    private OnPurchaseSuccessListener mPurchaseSuccessListener;
+
+    public void start(Activity activity, String sku, @Nullable OnPurchaseSuccessListener listener) {
+        Log.d(TAG, "Launching purchase flow for gas.");
+
+        mPurchaseSuccessListener = listener;
+
+        /* TODO: for security, generate your payload here for verification. See the comments on
+         *        verifyDeveloperPayload() for more info. Since this is a SAMPLE, we just use
+         *        an empty string, but on a production app you should carefully generate this. */
+        String payload = "";
+
+        try {
+            mHelper.launchPurchaseFlow(activity, sku, RC_REQUEST,
+                    mPurchaseFinishedListener, payload);
+        } catch (IabHelper.IabAsyncInProgressException e) {
+            complain("Error launching purchase flow. Another async operation in progress.");
+        }
+    }
+
+    public void onDestroy() {
+        // very important:
+        if (mBroadcastReceiver != null) {
+            mContext.unregisterReceiver(mBroadcastReceiver);
+        }
+
+        // very important:
+        Log.d(TAG, "Destroying helper.");
+        if (mHelper != null) {
+            try {
+                mHelper.disposeWhenFinished();
+            } catch (IllegalArgumentException ignored) {
+
+            }
+            mHelper = null;
+        }
+    }
+
+    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        Log.d(TAG, "onActivityResult(" + requestCode + "," + resultCode + "," + data);
+        if (mHelper == null) return true;
+
+        // Pass on the activity result to the helper for handling
+        if (!mHelper.handleActivityResult(requestCode, resultCode, data)) {
+            // not handled, so handle it ourselves (here's where you'd
+            // perform any handling of activity results not related to in-app
+            // billing...
+            //super.onActivityResult(requestCode, resultCode, data);
+            return false;
+        } else {
+            Log.d(TAG, "onActivityResult handled by IABUtil.");
+        }
+        return true;
+    }
+
+    public boolean isSuccess() {
+        return isSuccess;
+    }
+
+    public Dialog getDialog(final Activity activity) {
+        final DonateHelper.OnPurchaseSuccessListener listener = new DonateHelper.OnPurchaseSuccessListener() {
+            @Override
+            public void onSuccess(String sku) {
+                if (!activity.isFinishing()) {
+                    Toast.makeText(activity, LocaleController.getString("DonateThanks", R.string.DonateThanks), Toast.LENGTH_SHORT).show();
+                }
+            }
+        };
+        return new AlertDialog.Builder(activity)
+                .setItems(new CharSequence[]{"1 USD", "2 USD", "5 USD", "10 USD"}, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        switch (which) {
+                            case 0:
+                                start(activity, DonateHelper.SKU_DONATE_1, listener);
+                                break;
+                            case 1:
+                                start(activity, DonateHelper.SKU_DONATE_2, listener);
+                                break;
+                            case 2:
+                                start(activity, DonateHelper.SKU_DONATE_5, listener);
+                                break;
+                            case 3:
+                                start(activity, DonateHelper.SKU_DONATE_10, listener);
+                                break;
+                        }
+                    }
+                }).create();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabBroadcastReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabBroadcastReceiver.java
new file mode 100644
index 000000000..fd14ee308
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabBroadcastReceiver.java
@@ -0,0 +1,60 @@
+/* Copyright (c) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+/**
+ * Receiver for the "com.android.vending.billing.PURCHASES_UPDATED" Action
+ * from the Play Store.
+ * <p/>
+ * <p>It is possible that an in-app item may be acquired without the
+ * application calling getBuyIntent(), for example if the item can be
+ * redeemed from inside the Play Store using a promotional code. If this
+ * application isn't running at the time, then when it is started a call
+ * to getPurchases() will be sufficient notification. However, if the
+ * application is already running in the background when the item is acquired,
+ * a message to this BroadcastReceiver will indicate that the an item
+ * has been acquired.</p>
+ */
+public class IabBroadcastReceiver extends BroadcastReceiver {
+    /**
+     * Listener interface for received broadcast messages.
+     */
+    public interface IabBroadcastListener {
+        void receivedBroadcast();
+    }
+
+    /**
+     * The Intent action that this Receiver should filter for.
+     */
+    public static final String ACTION = "com.android.vending.billing.PURCHASES_UPDATED";
+
+    private final IabBroadcastListener mListener;
+
+    public IabBroadcastReceiver(IabBroadcastListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (mListener != null) {
+            mListener.receivedBroadcast();
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabException.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabException.java
new file mode 100644
index 000000000..746c1996f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabException.java
@@ -0,0 +1,50 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+/**
+ * Exception thrown when something went wrong with in-app billing.
+ * An IabException has an associated IabResult (an error).
+ * To get the IAB result that caused this exception to be thrown,
+ * call {@link #getResult()}.
+ */
+public class IabException extends Exception {
+    IabResult mResult;
+
+    public IabException(IabResult r) {
+        this(r, null);
+    }
+
+    public IabException(int response, String message) {
+        this(new IabResult(response, message));
+    }
+
+    public IabException(IabResult r, Exception cause) {
+        super(r.getMessage(), cause);
+        mResult = r;
+    }
+
+    public IabException(int response, String message, Exception cause) {
+        this(new IabResult(response, message), cause);
+    }
+
+    /**
+     * Returns the IAB result (error) that this exception signals.
+     */
+    public IabResult getResult() {
+        return mResult;
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabHelper.java
new file mode 100644
index 000000000..050507a4e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabHelper.java
@@ -0,0 +1,1104 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentSender.SendIntentException;
+import android.content.ServiceConnection;
+import android.content.pm.ResolveInfo;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.vending.billing.IInAppBillingService;
+
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Provides convenience methods for in-app billing. You can create one instance of this
+ * class for your application and use it to process in-app billing operations.
+ * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
+ * many common in-app billing operations, as well as automatic signature
+ * verification.
+ * <p/>
+ * After instantiating, you must perform setup in order to start using the object.
+ * To perform setup, call the {@link #startSetup} method and provide a listener;
+ * that listener will be notified when setup is complete, after which (and not before)
+ * you may call other methods.
+ * <p/>
+ * After setup is complete, you will typically want to request an inventory of owned
+ * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
+ * and related methods.
+ * <p/>
+ * When you are done with this object, don't forget to call {@link #dispose}
+ * to ensure proper cleanup. This object holds a binding to the in-app billing
+ * service, which will leak unless you dispose of it correctly. If you created
+ * the object on an Activity's onCreate method, then the recommended
+ * place to dispose of it is the Activity's onDestroy method. It is invalid to
+ * dispose the object while an asynchronous operation is in progress. You can
+ * call {@link #disposeWhenFinished()} to ensure that any in-progress operation
+ * completes before the object is disposed.
+ * <p/>
+ * A note about threading: When using this object from a background thread, you may
+ * call the blocking versions of methods; when using from a UI thread, call
+ * only the asynchronous versions and handle the results via callbacks.
+ * Also, notice that you can only call one asynchronous operation at a time;
+ * attempting to start a second asynchronous operation while the first one
+ * has not yet completed will result in an exception being thrown.
+ */
+public class IabHelper {
+    // Is debug logging enabled?
+    boolean mDebugLog = false;
+    String mDebugTag = "IabHelper";
+
+    // Is setup done?
+    boolean mSetupDone = false;
+
+    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
+    boolean mDisposed = false;
+
+    // Do we need to dispose this object after an in-progress asynchronous operation?
+    boolean mDisposeAfterAsync = false;
+
+    // Are subscriptions supported?
+    boolean mSubscriptionsSupported = false;
+
+    // Is subscription update supported?
+    boolean mSubscriptionUpdateSupported = false;
+
+    // Is an asynchronous operation in progress?
+    // (only one at a time can be in progress)
+    boolean mAsyncInProgress = false;
+
+    // Ensure atomic access to mAsyncInProgress and mDisposeAfterAsync.
+    private final Object mAsyncInProgressLock = new Object();
+
+    // (for logging/debugging)
+    // if mAsyncInProgress == true, what asynchronous operation is in progress?
+    String mAsyncOperation = "";
+
+    // Context we were passed during initialization
+    Context mContext;
+
+    // Connection to the service
+    IInAppBillingService mService;
+    ServiceConnection mServiceConn;
+
+    // The request code used to launch purchase flow
+    int mRequestCode;
+
+    // The item type of the current purchase flow
+    String mPurchasingItemType;
+
+    // Public key for verifying signature, in base64 encoding
+    String mSignatureBase64 = null;
+
+    // Billing response codes
+    public static final int BILLING_RESPONSE_RESULT_OK = 0;
+    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
+    public static final int BILLING_RESPONSE_RESULT_SERVICE_UNAVAILABLE = 2;
+    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
+    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
+    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;
+
+    // IAB Helper error codes
+    public static final int IABHELPER_ERROR_BASE = -1000;
+    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
+    public static final int IABHELPER_BAD_RESPONSE = -1002;
+    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
+    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
+    public static final int IABHELPER_USER_CANCELLED = -1005;
+    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
+    public static final int IABHELPER_MISSING_TOKEN = -1007;
+    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
+    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
+    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;
+    public static final int IABHELPER_SUBSCRIPTION_UPDATE_NOT_AVAILABLE = -1011;
+
+    // Keys for the responses from InAppBillingService
+    public static final String RESPONSE_CODE = "RESPONSE_CODE";
+    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
+    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
+    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
+    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
+    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
+    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";
+
+    // Item types
+    public static final String ITEM_TYPE_INAPP = "inapp";
+    public static final String ITEM_TYPE_SUBS = "subs";
+
+    // some fields on the getSkuDetails response bundle
+    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
+    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";
+
+    /**
+     * Creates an instance. After creation, it will not yet be ready to use. You must perform
+     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
+     * block and is safe to call from a UI thread.
+     *
+     * @param ctx             Your application or Activity context. Needed to bind to the in-app billing service.
+     * @param base64PublicKey Your application's public key, encoded in base64.
+     *                        This is used for verification of purchase signatures. You can find your app's base64-encoded
+     *                        public key in your application's page on Google Play Developer Console. Note that this
+     *                        is NOT your "developer public key".
+     */
+    public IabHelper(Context ctx, String base64PublicKey) {
+        mContext = ctx.getApplicationContext();
+        mSignatureBase64 = base64PublicKey;
+        logDebug("IAB helper created.");
+    }
+
+    /**
+     * Enables or disable debug logging through LogCat.
+     */
+    public void enableDebugLogging(boolean enable, String tag) {
+        checkNotDisposed();
+        mDebugLog = enable;
+        mDebugTag = tag;
+    }
+
+    public void enableDebugLogging(boolean enable) {
+        checkNotDisposed();
+        mDebugLog = enable;
+    }
+
+    /**
+     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
+     * when the setup process is complete.
+     */
+    public interface OnIabSetupFinishedListener {
+        /**
+         * Called to notify that setup is complete.
+         *
+         * @param result The result of the setup process.
+         */
+        void onIabSetupFinished(IabResult result);
+    }
+
+    /**
+     * Starts the setup process. This will start up the setup process asynchronously.
+     * You will be notified through the listener when the setup process is complete.
+     * This method is safe to call from a UI thread.
+     *
+     * @param listener The listener to notify when the setup process is complete.
+     */
+    public void startSetup(final OnIabSetupFinishedListener listener) {
+        // If already set up, can't do it again.
+        checkNotDisposed();
+        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");
+
+        // Connection to IAB service
+        logDebug("Starting in-app billing setup.");
+        mServiceConn = new ServiceConnection() {
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                logDebug("Billing service disconnected.");
+                mService = null;
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                if (mDisposed) return;
+                logDebug("Billing service connected.");
+                mService = IInAppBillingService.Stub.asInterface(service);
+                String packageName = mContext.getPackageName();
+                try {
+                    logDebug("Checking for in-app billing 3 support.");
+
+                    // check for in-app billing v3 support
+                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
+                    if (response != BILLING_RESPONSE_RESULT_OK) {
+                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
+                                "Error checking for billing v3 support."));
+
+                        // if in-app purchases aren't supported, neither are subscriptions
+                        mSubscriptionsSupported = false;
+                        mSubscriptionUpdateSupported = false;
+                        return;
+                    } else {
+                        logDebug("In-app billing version 3 supported for " + packageName);
+                    }
+
+                    // Check for v5 subscriptions support. This is needed for
+                    // getBuyIntentToReplaceSku which allows for subscription update
+                    response = mService.isBillingSupported(5, packageName, ITEM_TYPE_SUBS);
+                    if (response == BILLING_RESPONSE_RESULT_OK) {
+                        logDebug("Subscription re-signup AVAILABLE.");
+                        mSubscriptionUpdateSupported = true;
+                    } else {
+                        logDebug("Subscription re-signup not available.");
+                        mSubscriptionUpdateSupported = false;
+                    }
+
+                    if (mSubscriptionUpdateSupported) {
+                        mSubscriptionsSupported = true;
+                    } else {
+                        // check for v3 subscriptions support
+                        response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
+                        if (response == BILLING_RESPONSE_RESULT_OK) {
+                            logDebug("Subscriptions AVAILABLE.");
+                            mSubscriptionsSupported = true;
+                        } else {
+                            logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
+                            mSubscriptionsSupported = false;
+                            mSubscriptionUpdateSupported = false;
+                        }
+                    }
+
+                    mSetupDone = true;
+                } catch (RemoteException e) {
+                    if (listener != null) {
+                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
+                                "RemoteException while setting up in-app billing."));
+                    }
+                    e.printStackTrace();
+                    return;
+                }
+
+                if (listener != null) {
+                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
+                }
+            }
+        };
+
+        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
+        serviceIntent.setPackage("com.android.vending");
+        List<ResolveInfo> intentServices = mContext.getPackageManager().queryIntentServices(serviceIntent, 0);
+        if (intentServices != null && !intentServices.isEmpty()) {
+            // service available to handle that Intent
+            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
+        } else {
+            // no service available to handle that Intent
+            if (listener != null) {
+                listener.onIabSetupFinished(
+                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
+                                "Billing service unavailable on device."));
+            }
+        }
+    }
+
+    /**
+     * Dispose of object, releasing resources. It's very important to call this
+     * method when you are done with this object. It will release any resources
+     * used by it such as service connections. Naturally, once the object is
+     * disposed of, it can't be used again.
+     */
+    public void dispose() throws IabAsyncInProgressException {
+        synchronized (mAsyncInProgressLock) {
+            if (mAsyncInProgress) {
+                throw new IabAsyncInProgressException("Can't dispose because an async operation " +
+                        "(" + mAsyncOperation + ") is in progress.");
+            }
+        }
+        logDebug("Disposing.");
+        mSetupDone = false;
+        if (mServiceConn != null) {
+            logDebug("Unbinding from service.");
+            if (mContext != null) mContext.unbindService(mServiceConn);
+        }
+        mDisposed = true;
+        mContext = null;
+        mServiceConn = null;
+        mService = null;
+        mPurchaseListener = null;
+    }
+
+    /**
+     * Disposes of object, releasing resources. If there is an in-progress async operation, this
+     * method will queue the dispose to occur after the operation has finished.
+     */
+    public void disposeWhenFinished() {
+        synchronized (mAsyncInProgressLock) {
+            if (mAsyncInProgress) {
+                logDebug("Will dispose after async operation finishes.");
+                mDisposeAfterAsync = true;
+            } else {
+                try {
+                    dispose();
+                } catch (IabAsyncInProgressException e) {
+                    // Should never be thrown, because we call dispose() only after checking that
+                    // there's not already an async operation in progress.
+                }
+            }
+        }
+    }
+
+    private void checkNotDisposed() {
+        if (mDisposed)
+            throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
+    }
+
+    /**
+     * Returns whether subscriptions are supported.
+     */
+    public boolean subscriptionsSupported() {
+        checkNotDisposed();
+        return mSubscriptionsSupported;
+    }
+
+
+    /**
+     * Callback that notifies when a purchase is finished.
+     */
+    public interface OnIabPurchaseFinishedListener {
+        /**
+         * Called to notify that an in-app purchase finished. If the purchase was successful,
+         * then the sku parameter specifies which item was purchased. If the purchase failed,
+         * the sku and extraData parameters may or may not be null, depending on how far the purchase
+         * process went.
+         *
+         * @param result The result of the purchase.
+         * @param info   The purchase information (null if purchase failed)
+         */
+        void onIabPurchaseFinished(IabResult result, Purchase info);
+    }
+
+    // The listener registered on launchPurchaseFlow, which we have to call back when
+    // the purchase finishes
+    OnIabPurchaseFinishedListener mPurchaseListener;
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener)
+            throws IabAsyncInProgressException {
+        launchPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
+                                   OnIabPurchaseFinishedListener listener, String extraData)
+            throws IabAsyncInProgressException {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, null, requestCode, listener, extraData);
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+                                               OnIabPurchaseFinishedListener listener) throws IabAsyncInProgressException {
+        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+                                               OnIabPurchaseFinishedListener listener, String extraData)
+            throws IabAsyncInProgressException {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, null, requestCode, listener, extraData);
+    }
+
+    /**
+     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
+     * which will involve bringing up the Google Play screen. The calling activity will be paused
+     * while the user interacts with Google Play, and the result will be delivered via the
+     * activity's {@link android.app.Activity#onActivityResult} method, at which point you must call
+     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param act         The calling activity.
+     * @param sku         The sku of the item to purchase.
+     * @param itemType    indicates if it's a product or a subscription (ITEM_TYPE_INAPP or
+     *                    ITEM_TYPE_SUBS)
+     * @param oldSkus     A list of SKUs which the new SKU is replacing or null if there are none
+     * @param requestCode A request code (to differentiate from other responses -- as in
+     *                    {@link android.app.Activity#startActivityForResult}).
+     * @param listener    The listener to notify when the purchase process finishes
+     * @param extraData   Extra data (developer payload), which will be returned with the purchase
+     *                    data when the purchase completes. This extra data will be permanently bound to that
+     *                    purchase and will always be returned when the purchase is queried.
+     */
+    public void launchPurchaseFlow(Activity act, String sku, String itemType, List<String> oldSkus,
+                                   int requestCode, OnIabPurchaseFinishedListener listener, String extraData)
+            throws IabAsyncInProgressException {
+        checkNotDisposed();
+        checkSetupDone("launchPurchaseFlow");
+        flagStartAsync("launchPurchaseFlow");
+        IabResult result;
+
+        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
+            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
+                    "Subscriptions are not available.");
+            flagEndAsync();
+            if (listener != null) listener.onIabPurchaseFinished(r, null);
+            return;
+        }
+
+        try {
+            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
+            Bundle buyIntentBundle;
+            if (oldSkus == null || oldSkus.isEmpty()) {
+                // Purchasing a new item or subscription re-signup
+                buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType,
+                        extraData);
+            } else {
+                // Subscription upgrade/downgrade
+                if (!mSubscriptionUpdateSupported) {
+                    IabResult r = new IabResult(IABHELPER_SUBSCRIPTION_UPDATE_NOT_AVAILABLE,
+                            "Subscription updates are not available.");
+                    flagEndAsync();
+                    if (listener != null) listener.onIabPurchaseFinished(r, null);
+                    return;
+                }
+                buyIntentBundle = mService.getBuyIntentToReplaceSkus(5, mContext.getPackageName(),
+                        oldSkus, sku, itemType, extraData);
+            }
+            int response = getResponseCodeFromBundle(buyIntentBundle);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logError("Unable to buy item, Error response: " + getResponseDesc(response));
+                flagEndAsync();
+                result = new IabResult(response, "Unable to buy item");
+                if (listener != null) listener.onIabPurchaseFinished(result, null);
+                return;
+            }
+
+            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
+            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
+            mRequestCode = requestCode;
+            mPurchaseListener = listener;
+            mPurchasingItemType = itemType;
+            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
+                    requestCode, new Intent(),
+                    Integer.valueOf(0), Integer.valueOf(0),
+                    Integer.valueOf(0));
+        } catch (SendIntentException e) {
+            logError("SendIntentException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        } catch (RemoteException e) {
+            logError("RemoteException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+    }
+
+    /**
+     * Handles an activity result that's part of the purchase flow in in-app billing. If you
+     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
+     * Activity's {@link android.app.Activity@onActivityResult} method. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param requestCode The requestCode as you received it.
+     * @param resultCode  The resultCode as you received it.
+     * @param data        The data (Intent) as you received it.
+     * @return Returns true if the result was related to a purchase flow and was handled;
+     * false if the result was not related to a purchase, in which case you should
+     * handle it normally.
+     */
+    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
+        IabResult result;
+        if (requestCode != mRequestCode) return false;
+
+        checkNotDisposed();
+        checkSetupDone("handleActivityResult");
+
+        // end of async purchase operation that started on launchPurchaseFlow
+        flagEndAsync();
+
+        if (data == null) {
+            logError("Null data in IAB activity result.");
+            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+            return true;
+        }
+
+        int responseCode = getResponseCodeFromIntent(data);
+        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
+        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);
+
+        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
+            logDebug("Successful resultcode from purchase activity.");
+            logDebug("Purchase data: " + purchaseData);
+            logDebug("Data signature: " + dataSignature);
+            logDebug("Extras: " + data.getExtras());
+            logDebug("Expected item type: " + mPurchasingItemType);
+
+            if (purchaseData == null || dataSignature == null) {
+                logError("BUG: either purchaseData or dataSignature is null.");
+                logDebug("Extras: " + data.getExtras().toString());
+                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
+                if (mPurchaseListener != null)
+                    mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            Purchase purchase = null;
+            try {
+                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
+                String sku = purchase.getSku();
+
+                // Verify signature
+                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
+                    logError("Purchase signature verification FAILED for sku " + sku);
+                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
+                    if (mPurchaseListener != null)
+                        mPurchaseListener.onIabPurchaseFinished(result, purchase);
+                    return true;
+                }
+                logDebug("Purchase signature successfully verified.");
+            } catch (JSONException e) {
+                logError("Failed to parse purchase data.");
+                e.printStackTrace();
+                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
+                if (mPurchaseListener != null)
+                    mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            if (mPurchaseListener != null) {
+                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
+            }
+        } else if (resultCode == Activity.RESULT_OK) {
+            // result code was OK, but in-app billing response was not OK.
+            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
+            if (mPurchaseListener != null) {
+                result = new IabResult(responseCode, "Problem purchashing item.");
+                mPurchaseListener.onIabPurchaseFinished(result, null);
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        } else {
+            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
+                    + ". Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        return true;
+    }
+
+    public Inventory queryInventory() throws IabException {
+        return queryInventory(false, null, null);
+    }
+
+    /**
+     * Queries the inventory. This will query all owned items from the server, as well as
+     * information on additional skus, if specified. This method may block or take long to execute.
+     * Do not call from a UI thread. For that, use the non-blocking version {@link #queryInventoryAsync}.
+     *
+     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
+     *                        as purchase information.
+     * @param moreItemSkus    additional PRODUCT skus to query information on, regardless of ownership.
+     *                        Ignored if null or if querySkuDetails is false.
+     * @param moreSubsSkus    additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
+     *                        Ignored if null or if querySkuDetails is false.
+     * @throws IabException if a problem occurs while refreshing the inventory.
+     */
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
+                                    List<String> moreSubsSkus) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        try {
+            Inventory inv = new Inventory();
+            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
+            if (r != BILLING_RESPONSE_RESULT_OK) {
+                throw new IabException(r, "Error refreshing inventory (querying owned items).");
+            }
+
+            if (querySkuDetails) {
+                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
+                }
+            }
+
+            // if subscriptions are supported, then also query for subscriptions
+            if (mSubscriptionsSupported) {
+                r = queryPurchases(inv, ITEM_TYPE_SUBS);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
+                }
+
+                if (querySkuDetails) {
+                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreSubsSkus);
+                    if (r != BILLING_RESPONSE_RESULT_OK) {
+                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
+                    }
+                }
+            }
+
+            return inv;
+        } catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
+        } catch (JSONException e) {
+            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
+        }
+    }
+
+    /**
+     * Listener that notifies when an inventory query operation completes.
+     */
+    public interface QueryInventoryFinishedListener {
+        /**
+         * Called to notify that an inventory query operation completed.
+         *
+         * @param result The result of the operation.
+         * @param inv    The inventory.
+         */
+        void onQueryInventoryFinished(IabResult result, Inventory inv);
+    }
+
+
+    /**
+     * Asynchronous wrapper for inventory query. This will perform an inventory
+     * query as described in {@link #queryInventory}, but will do so asynchronously
+     * and call back the specified listener upon completion. This method is safe to
+     * call from a UI thread.
+     *
+     * @param querySkuDetails as in {@link #queryInventory}
+     * @param moreItemSkus    as in {@link #queryInventory}
+     * @param moreSubsSkus    as in {@link #queryInventory}
+     * @param listener        The listener to notify when the refresh operation completes.
+     */
+    public void queryInventoryAsync(final boolean querySkuDetails, final List<String> moreItemSkus,
+                                    final List<String> moreSubsSkus, final QueryInventoryFinishedListener listener)
+            throws IabAsyncInProgressException {
+        final Handler handler = new Handler();
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        flagStartAsync("refresh inventory");
+        (new Thread(new Runnable() {
+            public void run() {
+                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
+                Inventory inv = null;
+                try {
+                    inv = queryInventory(querySkuDetails, moreItemSkus, moreSubsSkus);
+                } catch (IabException ex) {
+                    result = ex.getResult();
+                }
+
+                flagEndAsync();
+
+                final IabResult result_f = result;
+                final Inventory inv_f = inv;
+                if (!mDisposed && listener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            listener.onQueryInventoryFinished(result_f, inv_f);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    public void queryInventoryAsync(QueryInventoryFinishedListener listener)
+            throws IabAsyncInProgressException {
+        queryInventoryAsync(false, null, null, listener);
+    }
+
+    /**
+     * Consumes a given in-app product. Consuming can only be done on an item
+     * that's owned, and as a result of consumption, the user will no longer own it.
+     * This method may block or take long to return. Do not call from the UI thread.
+     * For that, see {@link #consumeAsync}.
+     *
+     * @param itemInfo The PurchaseInfo that represents the item to consume.
+     * @throws IabException if there is a problem during consumption.
+     */
+    void consume(Purchase itemInfo) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+
+        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
+            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
+                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
+        }
+
+        try {
+            String token = itemInfo.getToken();
+            String sku = itemInfo.getSku();
+            if (token == null || token.equals("")) {
+                logError("Can't consume " + sku + ". No token.");
+                throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
+                        + sku + " " + itemInfo);
+            }
+
+            logDebug("Consuming sku: " + sku + ", token: " + token);
+            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
+            if (response == BILLING_RESPONSE_RESULT_OK) {
+                logDebug("Successfully consumed sku: " + sku);
+            } else {
+                logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
+                throw new IabException(response, "Error consuming sku " + sku);
+            }
+        } catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
+        }
+    }
+
+    /**
+     * Callback that notifies when a consumption operation finishes.
+     */
+    public interface OnConsumeFinishedListener {
+        /**
+         * Called to notify that a consumption has finished.
+         *
+         * @param purchase The purchase that was (or was to be) consumed.
+         * @param result   The result of the consumption operation.
+         */
+        void onConsumeFinished(Purchase purchase, IabResult result);
+    }
+
+    /**
+     * Callback that notifies when a multi-item consumption operation finishes.
+     */
+    public interface OnConsumeMultiFinishedListener {
+        /**
+         * Called to notify that a consumption of multiple items has finished.
+         *
+         * @param purchases The purchases that were (or were to be) consumed.
+         * @param results   The results of each consumption operation, corresponding to each
+         *                  sku.
+         */
+        void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
+    }
+
+    /**
+     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
+     * performs the consumption in the background and notifies completion through
+     * the provided listener. This method is safe to call from a UI thread.
+     *
+     * @param purchase The purchase to be consumed.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener)
+            throws IabAsyncInProgressException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        List<Purchase> purchases = new ArrayList<Purchase>();
+        purchases.add(purchase);
+        consumeAsyncInternal(purchases, listener, null);
+    }
+
+    /**
+     * Same as {@link #consumeAsync}, but for multiple items at once.
+     *
+     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
+     * @param listener  The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener)
+            throws IabAsyncInProgressException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        consumeAsyncInternal(purchases, null, listener);
+    }
+
+    /**
+     * Returns a human-readable description for the given response code.
+     *
+     * @param code The response code
+     * @return A human-readable string explaining the result code.
+     * It also includes the result code numerically.
+     */
+    public static String getResponseDesc(int code) {
+        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
+                "3:Billing Unavailable/4:Item unavailable/" +
+                "5:Developer Error/6:Error/7:Item Already Owned/" +
+                "8:Item not owned").split("/");
+        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
+                "-1002:Bad response received/" +
+                "-1003:Purchase signature verification failed/" +
+                "-1004:Send intent failed/" +
+                "-1005:User cancelled/" +
+                "-1006:Unknown purchase response/" +
+                "-1007:Missing token/" +
+                "-1008:Unknown error/" +
+                "-1009:Subscriptions not available/" +
+                "-1010:Invalid consumption attempt").split("/");
+
+        if (code <= IABHELPER_ERROR_BASE) {
+            int index = IABHELPER_ERROR_BASE - code;
+            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
+            else return String.valueOf(code) + ":Unknown IAB Helper Error";
+        } else if (code < 0 || code >= iab_msgs.length)
+            return String.valueOf(code) + ":Unknown";
+        else
+            return iab_msgs[code];
+    }
+
+
+    // Checks that setup was done; if not, throws an exception.
+    void checkSetupDone(String operation) {
+        if (!mSetupDone) {
+            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
+            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromBundle(Bundle b) {
+        Object o = b.get(RESPONSE_CODE);
+        if (o == null) {
+            logDebug("Bundle with null response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        } else if (o instanceof Integer) return ((Integer) o).intValue();
+        else if (o instanceof Long) return (int) ((Long) o).longValue();
+        else {
+            logError("Unexpected type for bundle response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromIntent(Intent i) {
+        Object o = i.getExtras().get(RESPONSE_CODE);
+        if (o == null) {
+            logError("Intent with no response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        } else if (o instanceof Integer) return ((Integer) o).intValue();
+        else if (o instanceof Long) return (int) ((Long) o).longValue();
+        else {
+            logError("Unexpected type for intent response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
+        }
+    }
+
+    void flagStartAsync(String operation) throws IabAsyncInProgressException {
+        synchronized (mAsyncInProgressLock) {
+            if (mAsyncInProgress) {
+                throw new IabAsyncInProgressException("Can't start async operation (" +
+                        operation + ") because another async operation (" + mAsyncOperation +
+                        ") is in progress.");
+            }
+            mAsyncOperation = operation;
+            mAsyncInProgress = true;
+            logDebug("Starting async operation: " + operation);
+        }
+    }
+
+    void flagEndAsync() {
+        synchronized (mAsyncInProgressLock) {
+            logDebug("Ending async operation: " + mAsyncOperation);
+            mAsyncOperation = "";
+            mAsyncInProgress = false;
+            if (mDisposeAfterAsync) {
+                try {
+                    dispose();
+                } catch (IabAsyncInProgressException e) {
+                    // Should not be thrown, because we reset mAsyncInProgress immediately before
+                    // calling dispose().
+                }
+            }
+        }
+    }
+
+    /**
+     * Exception thrown when the requested operation cannot be started because an async operation
+     * is still in progress.
+     */
+    public static class IabAsyncInProgressException extends Exception {
+        public IabAsyncInProgressException(String message) {
+            super(message);
+        }
+    }
+
+    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
+        // Query purchases
+        logDebug("Querying owned items, item type: " + itemType);
+        logDebug("Package name: " + mContext.getPackageName());
+        boolean verificationFailed = false;
+        String continueToken = null;
+
+        do {
+            logDebug("Calling getPurchases with continuation token: " + continueToken);
+            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
+                    itemType, continueToken);
+
+            int response = getResponseCodeFromBundle(ownedItems);
+            logDebug("Owned items response: " + String.valueOf(response));
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getPurchases() failed: " + getResponseDesc(response));
+                return response;
+            }
+            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
+                logError("Bundle returned from getPurchases() doesn't contain required fields.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+
+            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
+                    RESPONSE_INAPP_ITEM_LIST);
+            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
+                    RESPONSE_INAPP_PURCHASE_DATA_LIST);
+            ArrayList<String> signatureList = ownedItems.getStringArrayList(
+                    RESPONSE_INAPP_SIGNATURE_LIST);
+
+            for (int i = 0; i < purchaseDataList.size(); ++i) {
+                String purchaseData = purchaseDataList.get(i);
+                String signature = signatureList.get(i);
+                String sku = ownedSkus.get(i);
+                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
+                    logDebug("Sku is owned: " + sku);
+                    Purchase purchase = new Purchase(itemType, purchaseData, signature);
+
+                    if (TextUtils.isEmpty(purchase.getToken())) {
+                        logWarn("BUG: empty/null token!");
+                        logDebug("Purchase data: " + purchaseData);
+                    }
+
+                    // Record ownership and token
+                    inv.addPurchase(purchase);
+                } else {
+                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
+                    logDebug("   Purchase data: " + purchaseData);
+                    logDebug("   Signature: " + signature);
+                    verificationFailed = true;
+                }
+            }
+
+            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
+            logDebug("Continuation token: " + continueToken);
+        } while (!TextUtils.isEmpty(continueToken));
+
+        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
+    }
+
+    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
+            throws RemoteException, JSONException {
+        logDebug("Querying SKU details.");
+        ArrayList<String> skuList = new ArrayList<String>();
+        skuList.addAll(inv.getAllOwnedSkus(itemType));
+        if (moreSkus != null) {
+            for (String sku : moreSkus) {
+                if (!skuList.contains(sku)) {
+                    skuList.add(sku);
+                }
+            }
+        }
+
+        if (skuList.size() == 0) {
+            logDebug("queryPrices: nothing to do because there are no SKUs.");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+
+        // Split the sku list in blocks of no more than 20 elements.
+        ArrayList<ArrayList<String>> packs = new ArrayList<ArrayList<String>>();
+        ArrayList<String> tempList;
+        int n = skuList.size() / 20;
+        int mod = skuList.size() % 20;
+        for (int i = 0; i < n; i++) {
+            tempList = new ArrayList<String>();
+            for (String s : skuList.subList(i * 20, i * 20 + 20)) {
+                tempList.add(s);
+            }
+            packs.add(tempList);
+        }
+        if (mod != 0) {
+            tempList = new ArrayList<String>();
+            for (String s : skuList.subList(n * 20, n * 20 + mod)) {
+                tempList.add(s);
+            }
+            packs.add(tempList);
+        }
+
+        for (ArrayList<String> skuPartList : packs) {
+            Bundle querySkus = new Bundle();
+            querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuPartList);
+            Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
+                    itemType, querySkus);
+
+            if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
+                int response = getResponseCodeFromBundle(skuDetails);
+                if (response != BILLING_RESPONSE_RESULT_OK) {
+                    logDebug("getSkuDetails() failed: " + getResponseDesc(response));
+                    return response;
+                } else {
+                    logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
+                    return IABHELPER_BAD_RESPONSE;
+                }
+            }
+
+            ArrayList<String> responseList = skuDetails.getStringArrayList(
+                    RESPONSE_GET_SKU_DETAILS_LIST);
+
+            for (String thisResponse : responseList) {
+                SkuDetails d = new SkuDetails(itemType, thisResponse);
+                logDebug("Got sku details: " + d);
+                inv.addSkuDetails(d);
+            }
+        }
+
+        return BILLING_RESPONSE_RESULT_OK;
+    }
+
+    void consumeAsyncInternal(final List<Purchase> purchases,
+                              final OnConsumeFinishedListener singleListener,
+                              final OnConsumeMultiFinishedListener multiListener)
+            throws IabAsyncInProgressException {
+        final Handler handler = new Handler();
+        flagStartAsync("consume");
+        (new Thread(new Runnable() {
+            public void run() {
+                final List<IabResult> results = new ArrayList<IabResult>();
+                for (Purchase purchase : purchases) {
+                    try {
+                        consume(purchase);
+                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
+                    } catch (IabException ex) {
+                        results.add(ex.getResult());
+                    }
+                }
+
+                flagEndAsync();
+                if (!mDisposed && singleListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
+                        }
+                    });
+                }
+                if (!mDisposed && multiListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            multiListener.onConsumeMultiFinished(purchases, results);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    void logDebug(String msg) {
+        if (mDebugLog) Log.d(mDebugTag, msg);
+    }
+
+    void logError(String msg) {
+        Log.e(mDebugTag, "In-app billing error: " + msg);
+    }
+
+    void logWarn(String msg) {
+        Log.w(mDebugTag, "In-app billing warning: " + msg);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabResult.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabResult.java
new file mode 100644
index 000000000..d64db5e41
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/IabResult.java
@@ -0,0 +1,59 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+/**
+ * Represents the result of an in-app billing operation.
+ * A result is composed of a response code (an integer) and possibly a
+ * message (String). You can get those by calling
+ * {@link #getResponse} and {@link #getMessage()}, respectively. You
+ * can also inquire whether a result is a success or a failure by
+ * calling {@link #isSuccess()} and {@link #isFailure()}.
+ */
+public class IabResult {
+    int mResponse;
+    String mMessage;
+
+    public IabResult(int response, String message) {
+        mResponse = response;
+        if (message == null || message.trim().length() == 0) {
+            mMessage = IabHelper.getResponseDesc(response);
+        } else {
+            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
+        }
+    }
+
+    public int getResponse() {
+        return mResponse;
+    }
+
+    public String getMessage() {
+        return mMessage;
+    }
+
+    public boolean isSuccess() {
+        return mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK;
+    }
+
+    public boolean isFailure() {
+        return !isSuccess();
+    }
+
+    public String toString() {
+        return "IabResult: " + getMessage();
+    }
+}
+
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Inventory.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Inventory.java
new file mode 100644
index 000000000..eaad139de
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Inventory.java
@@ -0,0 +1,106 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Represents a block of information about in-app items.
+ * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
+ */
+public class Inventory {
+    Map<String, SkuDetails> mSkuMap = new HashMap<String, SkuDetails>();
+    Map<String, Purchase> mPurchaseMap = new HashMap<String, Purchase>();
+
+    Inventory() {
+    }
+
+    /**
+     * Returns the listing details for an in-app product.
+     */
+    public SkuDetails getSkuDetails(String sku) {
+        return mSkuMap.get(sku);
+    }
+
+    /**
+     * Returns purchase information for a given product, or null if there is no purchase.
+     */
+    public Purchase getPurchase(String sku) {
+        return mPurchaseMap.get(sku);
+    }
+
+    /**
+     * Returns whether or not there exists a purchase of the given product.
+     */
+    public boolean hasPurchase(String sku) {
+        return mPurchaseMap.containsKey(sku);
+    }
+
+    /**
+     * Return whether or not details about the given product are available.
+     */
+    public boolean hasDetails(String sku) {
+        return mSkuMap.containsKey(sku);
+    }
+
+    /**
+     * Erase a purchase (locally) from the inventory, given its product ID. This just
+     * modifies the Inventory object locally and has no effect on the server! This is
+     * useful when you have an existing Inventory object which you know to be up to date,
+     * and you have just consumed an item successfully, which means that erasing its
+     * purchase data from the Inventory you already have is quicker than querying for
+     * a new Inventory.
+     */
+    public void erasePurchase(String sku) {
+        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
+    }
+
+    /**
+     * Returns a list of all owned product IDs.
+     */
+    List<String> getAllOwnedSkus() {
+        return new ArrayList<String>(mPurchaseMap.keySet());
+    }
+
+    /**
+     * Returns a list of all owned product IDs of a given type
+     */
+    List<String> getAllOwnedSkus(String itemType) {
+        List<String> result = new ArrayList<String>();
+        for (Purchase p : mPurchaseMap.values()) {
+            if (p.getItemType().equals(itemType)) result.add(p.getSku());
+        }
+        return result;
+    }
+
+    /**
+     * Returns a list of all purchases.
+     */
+    List<Purchase> getAllPurchases() {
+        return new ArrayList<Purchase>(mPurchaseMap.values());
+    }
+
+    void addSkuDetails(SkuDetails d) {
+        mSkuMap.put(d.getSku(), d);
+    }
+
+    void addPurchase(Purchase p) {
+        mPurchaseMap.put(p.getSku(), p);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Purchase.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Purchase.java
new file mode 100644
index 000000000..3b27d8bd0
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Purchase.java
@@ -0,0 +1,100 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app billing purchase.
+ */
+public class Purchase {
+    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
+    String mOrderId;
+    String mPackageName;
+    String mSku;
+    long mPurchaseTime;
+    int mPurchaseState;
+    String mDeveloperPayload;
+    String mToken;
+    String mOriginalJson;
+    String mSignature;
+    boolean mIsAutoRenewing;
+
+    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
+        mItemType = itemType;
+        mOriginalJson = jsonPurchaseInfo;
+        JSONObject o = new JSONObject(mOriginalJson);
+        mOrderId = o.optString("orderId");
+        mPackageName = o.optString("packageName");
+        mSku = o.optString("productId");
+        mPurchaseTime = o.optLong("purchaseTime");
+        mPurchaseState = o.optInt("purchaseState");
+        mDeveloperPayload = o.optString("developerPayload");
+        mToken = o.optString("token", o.optString("purchaseToken"));
+        mIsAutoRenewing = o.optBoolean("autoRenewing");
+        mSignature = signature;
+    }
+
+    public String getItemType() {
+        return mItemType;
+    }
+
+    public String getOrderId() {
+        return mOrderId;
+    }
+
+    public String getPackageName() {
+        return mPackageName;
+    }
+
+    public String getSku() {
+        return mSku;
+    }
+
+    public long getPurchaseTime() {
+        return mPurchaseTime;
+    }
+
+    public int getPurchaseState() {
+        return mPurchaseState;
+    }
+
+    public String getDeveloperPayload() {
+        return mDeveloperPayload;
+    }
+
+    public String getToken() {
+        return mToken;
+    }
+
+    public String getOriginalJson() {
+        return mOriginalJson;
+    }
+
+    public String getSignature() {
+        return mSignature;
+    }
+
+    public boolean isAutoRenewing() {
+        return mIsAutoRenewing;
+    }
+
+    @Override
+    public String toString() {
+        return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Security.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Security.java
new file mode 100644
index 000000000..8b4b26a74
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/Security.java
@@ -0,0 +1,122 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+import android.text.TextUtils;
+import android.util.Base64;
+import android.util.Log;
+
+import java.security.InvalidKeyException;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.Signature;
+import java.security.SignatureException;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+
+/**
+ * Security-related methods. For a secure implementation, all of this code
+ * should be implemented on a server that communicates with the
+ * application on the device. For the sake of simplicity and clarity of this
+ * example, this code is included here and is executed on the device. If you
+ * must verify the purchases on the phone, you should obfuscate this code to
+ * make it harder for an attacker to replace the code with stubs that treat all
+ * purchases as verified.
+ */
+public class Security {
+    private static final String TAG = "IABUtil/Security";
+
+    private static final String KEY_FACTORY_ALGORITHM = "RSA";
+    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";
+
+    /**
+     * Verifies that the data was signed with the given signature, and returns
+     * the verified purchase. The data is in JSON format and signed
+     * with a private key. The data also contains the {@link PurchaseState}
+     * and product ID of the purchase.
+     *
+     * @param base64PublicKey the base64-encoded public key to use for verifying.
+     * @param signedData      the signed JSON string (signed, not encrypted)
+     * @param signature       the signature for the data, signed with the private key
+     */
+    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
+        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
+                TextUtils.isEmpty(signature)) {
+            Log.e(TAG, "Purchase verification failed: missing data.");
+            return false;
+        }
+
+        PublicKey key = Security.generatePublicKey(base64PublicKey);
+        return Security.verify(key, signedData, signature);
+    }
+
+    /**
+     * Generates a PublicKey instance from a string containing the
+     * Base64-encoded public key.
+     *
+     * @param encodedPublicKey Base64-encoded public key
+     * @throws IllegalArgumentException if encodedPublicKey is invalid
+     */
+    public static PublicKey generatePublicKey(String encodedPublicKey) {
+        try {
+            byte[] decodedKey = Base64.decode(encodedPublicKey, Base64.DEFAULT);
+            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
+            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (InvalidKeySpecException e) {
+            Log.e(TAG, "Invalid key specification.");
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Verifies that the signature from the server matches the computed
+     * signature on the data.  Returns true if the data is correctly signed.
+     *
+     * @param publicKey  public key associated with the developer account
+     * @param signedData signed data from server
+     * @param signature  server signature
+     * @return true if the data and signature match
+     */
+    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
+        byte[] signatureBytes;
+        try {
+            signatureBytes = Base64.decode(signature, Base64.DEFAULT);
+        } catch (IllegalArgumentException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+            return false;
+        }
+        try {
+            Signature sig = Signature.getInstance(SIGNATURE_ALGORITHM);
+            sig.initVerify(publicKey);
+            sig.update(signedData.getBytes());
+            if (!sig.verify(signatureBytes)) {
+                Log.e(TAG, "Signature verification failed.");
+                return false;
+            }
+            return true;
+        } catch (NoSuchAlgorithmException e) {
+            Log.e(TAG, "NoSuchAlgorithmException.");
+        } catch (InvalidKeyException e) {
+            Log.e(TAG, "Invalid key specification.");
+        } catch (SignatureException e) {
+            Log.e(TAG, "Signature exception.");
+        }
+        return false;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/SkuDetails.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/SkuDetails.java
new file mode 100644
index 000000000..fb3d292f0
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/iap/utils/SkuDetails.java
@@ -0,0 +1,84 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.messenger.support.iap.utils;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app product's listing details.
+ */
+public class SkuDetails {
+    private final String mItemType;
+    private final String mSku;
+    private final String mType;
+    private final String mPrice;
+    private final long mPriceAmountMicros;
+    private final String mPriceCurrencyCode;
+    private final String mTitle;
+    private final String mDescription;
+    private final String mJson;
+
+    public SkuDetails(String jsonSkuDetails) throws JSONException {
+        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
+    }
+
+    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
+        mItemType = itemType;
+        mJson = jsonSkuDetails;
+        JSONObject o = new JSONObject(mJson);
+        mSku = o.optString("productId");
+        mType = o.optString("type");
+        mPrice = o.optString("price");
+        mPriceAmountMicros = o.optLong("price_amount_micros");
+        mPriceCurrencyCode = o.optString("price_currency_code");
+        mTitle = o.optString("title");
+        mDescription = o.optString("description");
+    }
+
+    public String getSku() {
+        return mSku;
+    }
+
+    public String getType() {
+        return mType;
+    }
+
+    public String getPrice() {
+        return mPrice;
+    }
+
+    public long getPriceAmountMicros() {
+        return mPriceAmountMicros;
+    }
+
+    public String getPriceCurrencyCode() {
+        return mPriceCurrencyCode;
+    }
+
+    public String getTitle() {
+        return mTitle;
+    }
+
+    public String getDescription() {
+        return mDescription;
+    }
+
+    @Override
+    public String toString() {
+        return "SkuDetails:" + mJson;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
index caf67387b..5400f3805 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
@@ -70,6 +70,7 @@
 import org.telegram.messenger.UserObject;
 import org.telegram.messenger.browser.Browser;
 import org.telegram.messenger.query.StickersQuery;
+import org.telegram.messenger.support.iap.DonateHelper;
 import org.telegram.messenger.support.widget.LinearLayoutManager;
 import org.telegram.messenger.support.widget.RecyclerView;
 import org.telegram.tgnet.ConnectionsManager;
@@ -152,6 +153,7 @@
     private int fakeBoldRow;
     private int nightModeRow;
     private int forceExternalRow;
+    private int donateRow;
 
     private int raiseToSpeakRow;
     private int sendByEnterRow;
@@ -173,6 +175,8 @@
     private final static int edit_name = 1;
     private final static int logout = 2;
 
+    private DonateHelper mDonateHelper;
+
     public SettingsActivity() {
     }
 
@@ -286,6 +290,7 @@ public void run() {
         supportSectionRow = rowCount++;
         supportSectionRow2 = rowCount++;
         //askQuestionRow = rowCount++;
+        donateRow = rowCount++;
         telegramFaqRow = rowCount++;
         privacyPolicyRow = rowCount++;
         if (BuildVars.DEBUG_VERSION) {
@@ -301,9 +306,13 @@ public void run() {
         StickersQuery.checkFeaturedStickers();
         MessagesController.getInstance().loadFullUser(UserConfig.getCurrentUser(), classGuid, true);
 
+        mDonateHelper = new DonateHelper(ApplicationLoader.applicationContext);
+
         return true;
     }
 
+
+
     @Override
     public void onFragmentDestroy() {
         super.onFragmentDestroy();
@@ -314,6 +323,7 @@ public void onFragmentDestroy() {
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.updateInterfaces);
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.featuredStickersDidLoaded);
         avatarUpdater.clear();
+        mDonateHelper.onDestroy();
     }
 
     @Override
@@ -744,6 +754,32 @@ public void onClick(View v) {
                     presentFragment(new NightModeActivity());
                 } else if (position == forceExternalRow) {
                     presentFragment(new ForceExternalLinksActivity());
+                } else if (position == donateRow) {
+                    if (AndroidUtilities.isPackageInstalled(getParentActivity(), "com.eg.android.AlipayGphone")) {
+                        showDialog(new AlertDialog.Builder(getParentActivity())
+                                .setTitle("Donate via")
+                                .setItems(new CharSequence[]{"Google Play", "Alipay"}, new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        switch (which) {
+                                            case 0:
+                                                showDialog(mDonateHelper.getDialog(getParentActivity()));
+                                                break;
+                                            case 1:
+                                                try {
+                                                    getParentActivity().startActivity(new Intent(Intent.ACTION_VIEW,
+                                                            Uri.parse("alipayqr://platformapi/startapp?saId=10000007&qrcode=https%3A%2F%2Fqr.alipay.com%2Faex01083scje5axcttivf13")));
+                                                } catch (Exception ignored) {
+                                                    AndroidUtilities.addToClipboard("rikka@xing.moe");
+                                                    Toast.makeText(getParentActivity(), "rikka@xing.moe has copied to clipboard.", Toast.LENGTH_SHORT).show();
+                                                }
+                                                break;
+                                        }
+                                    }
+                                }).create());
+                    } else {
+                        showDialog(mDonateHelper.getDialog(getParentActivity()));
+                    }
                 }
             }
         });
@@ -1093,7 +1129,9 @@ public void run() {
 
     @Override
     public void onActivityResultFragment(int requestCode, int resultCode, Intent data) {
-        avatarUpdater.onActivityResult(requestCode, resultCode, data);
+        if (!mDonateHelper.onActivityResult(requestCode, resultCode, data)) {
+            avatarUpdater.onActivityResult(requestCode, resultCode, data);
+        }
     }
 
     @Override
@@ -1368,6 +1406,8 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
                         textCell.setTextAndValue(LocaleController.getString("NightMode", R.string.NightMode), NightModeActivity.getNightModeStatus(nightMode), true);
                     } else if (position == forceExternalRow) {
                         textCell.setText(LocaleController.getString("ExternalLinks", R.string.ExternalLinks), true);
+                    } else if (position == donateRow) {
+                        textCell.setText(LocaleController.getString("Donate", R.string.Donate), true);
                     }
                     break;
                 }
@@ -1495,7 +1535,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
                         position == mobileDownloadRow || position == clearLogsRow || position == roamingDownloadRow || position == languageRow || position == usernameRow ||
                         position == switchBackendButtonRow || position == telegramFaqRow || position == contactsSortRow || position == contactsReimportRow || position == saveToGalleryRow ||
                         position == stickersRow || position == cacheRow || position == raiseToSpeakRow || position == privacyPolicyRow || position == customTabsRow || position == directShareRow || position == versionRow ||
-                        position == emojiRow || position == googleEmojiRow || position == fakeBoldRow || position == nightModeRow || position == forceExternalRow) {
+                        position == emojiRow || position == googleEmojiRow || position == fakeBoldRow || position == nightModeRow || position == forceExternalRow || position == donateRow) {
                     if (holder.itemView instanceof ForegroundFrameLayout) {
                         ForegroundFrameLayout view = (ForegroundFrameLayout) holder.itemView;
                         if (view.getForeground() == null) {
@@ -1574,7 +1614,7 @@ public int getItemViewType(int position) {
                 return 1;
             } else if (position == enableAnimationsRow || position == sendByEnterRow || position == saveToGalleryRow || position == autoplayGifsRow || position == raiseToSpeakRow || position == customTabsRow || position == directShareRow || position == googleEmojiRow || position == fakeBoldRow) {
                 return 3;
-            } else if (position == notificationRow || position == backgroundRow || position == askQuestionRow || position == sendLogsRow || position == privacyRow || position == clearLogsRow || position == switchBackendButtonRow || position == telegramFaqRow || position == contactsReimportRow || position == textSizeRow || position == languageRow || position == contactsSortRow || position == stickersRow || position == cacheRow || position == privacyPolicyRow || position == emojiRow || position == nightModeRow || position == forceExternalRow) {
+            } else if (position == notificationRow || position == backgroundRow || position == askQuestionRow || position == sendLogsRow || position == privacyRow || position == clearLogsRow || position == switchBackendButtonRow || position == telegramFaqRow || position == contactsReimportRow || position == textSizeRow || position == languageRow || position == contactsSortRow || position == stickersRow || position == cacheRow || position == privacyPolicyRow || position == emojiRow || position == nightModeRow || position == forceExternalRow || position == donateRow) {
                 return 2;
             } else if (position == versionRow) {
                 return 5;
diff --git a/TMessagesProj/src/main/res/values-ar/strings.xml b/TMessagesProj/src/main/res/values-ar/strings.xml
index 9cd07f021..09a0149ae 100644
--- a/TMessagesProj/src/main/res/values-ar/strings.xml
+++ b/TMessagesProj/src/main/res/values-ar/strings.xml
@@ -1316,4 +1316,10 @@
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
 
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-de/strings.xml b/TMessagesProj/src/main/res/values-de/strings.xml
index 4d794fbb9..d93ee4a09 100644
--- a/TMessagesProj/src/main/res/values-de/strings.xml
+++ b/TMessagesProj/src/main/res/values-de/strings.xml
@@ -1315,4 +1315,11 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-es/strings.xml b/TMessagesProj/src/main/res/values-es/strings.xml
index 41bf06e5f..e52003775 100644
--- a/TMessagesProj/src/main/res/values-es/strings.xml
+++ b/TMessagesProj/src/main/res/values-es/strings.xml
@@ -1315,4 +1315,11 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-it/strings.xml b/TMessagesProj/src/main/res/values-it/strings.xml
index 93ea2f2fa..2d0f99cb0 100644
--- a/TMessagesProj/src/main/res/values-it/strings.xml
+++ b/TMessagesProj/src/main/res/values-it/strings.xml
@@ -1315,4 +1315,11 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-ko/strings.xml b/TMessagesProj/src/main/res/values-ko/strings.xml
index a41ae034e..5dcd25a71 100644
--- a/TMessagesProj/src/main/res/values-ko/strings.xml
+++ b/TMessagesProj/src/main/res/values-ko/strings.xml
@@ -1315,4 +1315,11 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-nl/strings.xml b/TMessagesProj/src/main/res/values-nl/strings.xml
index 879f920e9..50511b361 100644
--- a/TMessagesProj/src/main/res/values-nl/strings.xml
+++ b/TMessagesProj/src/main/res/values-nl/strings.xml
@@ -1315,4 +1315,12 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
+
diff --git a/TMessagesProj/src/main/res/values-pt-rBR/strings.xml b/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
index a4985c92f..9337ab6a9 100644
--- a/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
+++ b/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
@@ -1315,4 +1315,11 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-pt-rPT/strings.xml b/TMessagesProj/src/main/res/values-pt-rPT/strings.xml
index 62913d6c7..db1d6342c 100644
--- a/TMessagesProj/src/main/res/values-pt-rPT/strings.xml
+++ b/TMessagesProj/src/main/res/values-pt-rPT/strings.xml
@@ -1315,4 +1315,11 @@
 
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values-zh-rCN/strings.xml b/TMessagesProj/src/main/res/values-zh-rCN/strings.xml
index 5af7f3bae..fc34f3203 100644
--- a/TMessagesProj/src/main/res/values-zh-rCN/strings.xml
+++ b/TMessagesProj/src/main/res/values-zh-rCN/strings.xml
@@ -1318,4 +1318,11 @@
 
     <string name="ExternalLinks"></string>
     <string name="ExternalLinksAddDomain"></string>
+
+    <string name="Donate"></string>
+    <string name="DonateThanks"></string>
+
+    <string name="SendFeedback"></string>
+    <string name="SendFeedbackSendVia"></string>
+    <string name="SendFeedbackNoMailApp"></string>
 </resources>
diff --git a/TMessagesProj/src/main/res/values/strings.xml b/TMessagesProj/src/main/res/values/strings.xml
index 8ae9f73f9..2c63bc036 100644
--- a/TMessagesProj/src/main/res/values/strings.xml
+++ b/TMessagesProj/src/main/res/values/strings.xml
@@ -1317,4 +1317,12 @@
     
     <string name="ExternalLinks">Links open externally</string>
     <string name="ExternalLinksAddDomain">Add domain</string>
+
+    <string name="Donate">Donate</string>
+    <string name="DonateThanks">Thank you for your support</string>
+
+    <string name="SendFeedback">Send feedback</string>
+    <string name="SendFeedbackSendVia">Send via</string>
+    <string name="SendFeedbackNoMailApp">No mail app</string>
+
 </resources>
diff --git a/gradle.properties b/gradle.properties
index fc7e06a13..bb93b94ee 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,3 +16,4 @@
 RELEASE_KEY_PASSWORD=password
 RELEASE_KEY_ALIAS=alias
 RELEASE_STORE_PASSWORD=password
+base64_public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAggtzbSrB7bf6kz9vh8EvHuNs46/3sCjiWuzLnFvZa6bHYbQ+ZNzP/yChleZN3tHlzM2kzBMOOqMbBgfy3yRtGtBbSmuVOub9nXhWf2pQKrC3oHZmmXq/S0wjlC53dOJq7WJURkiEhA2oFPV8Ud6B8JXQmqtaouN3gpYTjQw64myOccpFDkOrD75/DOvswXmfRHGLTij2zoM+v1yKMv13GwoTfqeg7hPaeaNP3hCh/txJL4DPkp4MKMe5YyJJeP+gfzG5roz8NWibDsYF3VVzl9nhe49ROKXjo1pggHqQ7kFHTAf2J1e+X1ovZkPMgfKlisNnrWkHRbjvm4mG2Q3DzwIDAQAB
