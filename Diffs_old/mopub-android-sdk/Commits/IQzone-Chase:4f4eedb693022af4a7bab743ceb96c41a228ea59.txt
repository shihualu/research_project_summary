diff --git a/mopub-sample/.settings/org.eclipse.jdt.core.prefs b/mopub-sample/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 00000000..48ab4c6b
--- /dev/null
+++ b/mopub-sample/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/mopub-sdk/.settings/org.eclipse.jdt.core.prefs b/mopub-sdk/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 00000000..48ab4c6b
--- /dev/null
+++ b/mopub-sdk/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/mopub-sdk/bin/mopub-sdk.jar b/mopub-sdk/bin/mopub-sdk.jar
deleted file mode 100644
index cd10d246..00000000
Binary files a/mopub-sdk/bin/mopub-sdk.jar and /dev/null differ
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java b/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java
new file mode 100644
index 00000000..630c180e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java
@@ -0,0 +1,8 @@
+package com.mopub.common;
+
+public enum AdFormat {
+    BANNER,
+    INTERSTITIAL,
+    NATIVE,
+    REWARDED_VIDEO,
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdReport.java b/mopub-sdk/src/main/java/com/mopub/common/AdReport.java
new file mode 100644
index 00000000..0415b271
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdReport.java
@@ -0,0 +1,81 @@
+package com.mopub.common;
+
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import com.mopub.network.AdResponse;
+
+import java.io.Serializable;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * A value class used for generating reports to send data back to MoPub
+ */
+public class AdReport implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    private static final String DATE_FORMAT_PATTERN = "M/d/yy hh:mm:ss a z";
+    private final AdResponse mAdResponse;
+    private final String mAdUnitId;
+    private final String mSdkVersion;
+    private final String mDeviceModel;
+    private final Locale mDeviceLocale;
+    private final String mUdid;
+
+    public AdReport(@NonNull String adUnitId, @NonNull ClientMetadata clientMetadata, @NonNull AdResponse adResponse) {
+        mAdUnitId = adUnitId;
+        mSdkVersion = clientMetadata.getSdkVersion();
+        mDeviceModel = clientMetadata.getDeviceModel();
+        mDeviceLocale = clientMetadata.getDeviceLocale();
+        mUdid = clientMetadata.getDeviceId();
+        mAdResponse = adResponse;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder parameters = new StringBuilder();
+        appendKeyValue(parameters, "sdk_version", mSdkVersion);
+        appendKeyValue(parameters, "creative_id", mAdResponse.getDspCreativeId());
+        appendKeyValue(parameters, "platform_version", Integer.toString(Build.VERSION.SDK_INT));
+        appendKeyValue(parameters, "device_model", mDeviceModel);
+        appendKeyValue(parameters, "ad_unit_id", mAdUnitId);
+        appendKeyValue(parameters, "device_locale",
+                mDeviceLocale == null ? null : mDeviceLocale.toString());
+        appendKeyValue(parameters, "device_id", mUdid);
+        appendKeyValue(parameters, "network_type", mAdResponse.getNetworkType());
+        appendKeyValue(parameters, "platform", "android");
+        appendKeyValue(parameters, "timestamp", getFormattedTimeStamp(mAdResponse.getTimestamp()));
+        appendKeyValue(parameters, "ad_type", mAdResponse.getAdType());
+        Integer width = mAdResponse.getWidth();
+        Integer height = mAdResponse.getHeight();
+        appendKeyValue(parameters, "ad_size", "{"
+                + (width == null ? "0" : width)
+                + ", "
+                + (height == null ? "0" : height)
+                + "}");
+
+        return parameters.toString();
+    }
+
+    public String getResponseString() {
+        return mAdResponse.getStringBody();
+    }
+
+    private void appendKeyValue(StringBuilder parameters, String key, String value) {
+        parameters.append(key);
+        parameters.append(" : ");
+        parameters.append(value);
+        parameters.append("\n");
+    }
+
+    private String getFormattedTimeStamp(long timeStamp) {
+        if (timeStamp != -1) {
+            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
+            return dateFormat.format(new Date(timeStamp));
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdType.java b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
new file mode 100644
index 00000000..86543d5a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
@@ -0,0 +1,14 @@
+package com.mopub.common;
+
+/**
+ * Valid values for the "X-Adtype" header from the MoPub ad server. The value of this header
+ * controls the custom event loading behavior.
+ */
+public class AdType {
+    public static final String HTML = "html";
+    public static final String MRAID = "mraid";
+    public static final String INTERSTITIAL = "interstitial";
+    public static final String NATIVE = "json";
+    public static final String CUSTOM = "custom";
+    public static final String CLEAR = "clear";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
index 2a012bed..397a0d04 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -2,25 +2,110 @@
 
 import android.content.Context;
 import android.location.Location;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.DateAndTime;
 
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class AdUrlGenerator extends BaseUrlGenerator {
-    private static TwitterAppInstalledStatus sTwitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
+
+    /**
+     * The ad unit id which identifies a spot for an ad to be placed.
+     */
+    private static final String AD_UNIT_ID_KEY = "id";
+
+    /**
+     * nv = native version. This is the version of MoPub.
+     */
+    private static final String SDK_VERSION_KEY = "nv";
+
+    /**
+     * q = query. This is for big publishers to send up certain
+     * keywords that better match ads.
+     */
+    private static final String KEYWORDS_KEY = "q";
+
+    /**
+     * Location represented in latitude and longitude.
+     * e.g. "47.638,-122.321"
+     */
+    private static final String LAT_LONG_KEY = "ll";
+
+    /**
+     * Estimated accuracy of this location, in meters.
+     * See {@link android.location.Location#getAccuracy()}
+     * for more information.
+     */
+    private static final String LAT_LONG_ACCURACY_KEY = "lla";
+
+    /**
+     * Milliseconds since location was updated.
+     */
+    private static final String LAT_LONG_FRESHNESS_KEY = "llf";
+
+    /**
+     * Whether or not the location came from the MoPub SDK
+     * and not the developer. 1 = from MoPub.
+     */
+    private static final String LAT_LONG_FROM_SDK_KEY = "llsdk";
+
+    /**
+     * Timezone offset. e.g. Pacific Standard Time = -0800.
+     */
+    private static final String TIMEZONE_OFFSET_KEY = "z";
+
+    /**
+     * "p" for portrait, "l" for landscape
+     */
+    private static final String ORIENTATION_KEY = "o";
+
+    /**
+     * Density as represented by a float. See
+     * http://developer.android.com/guide/practices/screens_support.html
+     * for details on values this can be.
+     */
+    private static final String SCREEN_SCALE_KEY = "sc_a";
+
+    /**
+     * Whether or not this is using mraid. 1 = yes.
+     */
+    private static final String IS_MRAID_KEY = "mr";
+
+    /**
+     * mcc, the mobile country code, paired with the mobile network code,
+     * uniquely identifies a carrier in a country.
+     */
+    private static final String MOBILE_COUNTRY_CODE_KEY = "mcc";
+    private static final String MOBILE_NETWORK_CODE_KEY = "mnc";
+
+    /**
+     * The International Organization for Standardization's 2-character country code
+     */
+    private static final String COUNTRY_CODE_KEY = "iso";
+
+    /**
+     * String name of the carrier. e.g. "Verizon%20Wireless"
+     */
+    private static final String CARRIER_NAME_KEY = "cn";
+
+    /**
+     * Carrier type as in what kind of network this device is on.
+     * See {@link android.net.ConnectivityManager} for constants.
+     */
+    private static final String CARRIER_TYPE_KEY = "ct";
+
+    /**
+     * Bundle ID, as in package name.
+     */
+    private static final String BUNDLE_ID_KEY = "bundle";
 
     protected Context mContext;
     protected String mAdUnitId;
     protected String mKeywords;
     protected Location mLocation;
 
-    public static enum TwitterAppInstalledStatus {
-        UNKNOWN,
-        NOT_INSTALLED,
-        INSTALLED,
-    }
-
     public AdUrlGenerator(Context context) {
         mContext = context;
     }
@@ -41,87 +126,132 @@ public AdUrlGenerator withLocation(Location location) {
     }
 
     protected void setAdUnitId(String adUnitId) {
-        addParam("id", adUnitId);
+        addParam(AD_UNIT_ID_KEY, adUnitId);
     }
 
     protected void setSdkVersion(String sdkVersion) {
-        addParam("nv", sdkVersion);
+        addParam(SDK_VERSION_KEY, sdkVersion);
     }
 
     protected void setKeywords(String keywords) {
-        addParam("q", keywords);
+        addParam(KEYWORDS_KEY, keywords);
     }
 
-    protected void setLocation(Location location) {
-        if (location != null) {
-            addParam("ll", location.getLatitude() + "," + location.getLongitude());
-            addParam("lla", "" + (int) location.getAccuracy());
+    protected void setLocation(@Nullable Location location) {
+        Location bestLocation = location;
+        Location locationFromLocationService = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
+
+        if (locationFromLocationService != null &&
+                (location == null || locationFromLocationService.getTime() >= location.getTime())) {
+            bestLocation = locationFromLocationService;
+        }
+
+        if (bestLocation != null) {
+            addParam(LAT_LONG_KEY, bestLocation.getLatitude() + "," + bestLocation.getLongitude());
+            addParam(LAT_LONG_ACCURACY_KEY, String.valueOf((int) bestLocation.getAccuracy()));
+            addParam(LAT_LONG_FRESHNESS_KEY,
+                    String.valueOf(calculateLocationStalenessInMilliseconds(bestLocation)));
+
+            if (bestLocation == locationFromLocationService) {
+                addParam(LAT_LONG_FROM_SDK_KEY, "1");
+            }
         }
     }
 
     protected void setTimezone(String timeZoneOffsetString) {
-        addParam("z", timeZoneOffsetString);
+        addParam(TIMEZONE_OFFSET_KEY, timeZoneOffsetString);
     }
 
     protected void setOrientation(String orientation) {
-        addParam("o", orientation);
+        addParam(ORIENTATION_KEY, orientation);
     }
 
     protected void setDensity(float density) {
-        addParam("sc_a", "" + density);
+        addParam(SCREEN_SCALE_KEY, "" + density);
     }
 
     protected void setMraidFlag(boolean mraid) {
-        if (mraid) addParam("mr", "1");
+        if (mraid) {
+            addParam(IS_MRAID_KEY, "1");
+        }
     }
 
     protected void setMccCode(String networkOperator) {
         String mcc = networkOperator == null ? "" : networkOperator.substring(0, mncPortionLength(networkOperator));
-        addParam("mcc", mcc);
+        addParam(MOBILE_COUNTRY_CODE_KEY, mcc);
     }
 
     protected void setMncCode(String networkOperator) {
         String mnc = networkOperator == null ? "" : networkOperator.substring(mncPortionLength(networkOperator));
-        addParam("mnc", mnc);
+        addParam(MOBILE_NETWORK_CODE_KEY, mnc);
     }
 
     protected void setIsoCountryCode(String networkCountryIso) {
-        addParam("iso", networkCountryIso);
+        addParam(COUNTRY_CODE_KEY, networkCountryIso);
     }
 
     protected void setCarrierName(String networkOperatorName) {
-        addParam("cn", networkOperatorName);
+        addParam(CARRIER_NAME_KEY, networkOperatorName);
     }
 
     protected void setNetworkType(MoPubNetworkType networkType) {
-        addParam("ct", networkType);
+        addParam(CARRIER_TYPE_KEY, networkType);
     }
 
-    private void addParam(String key, MoPubNetworkType value) {
-        addParam(key, value.toString());
+    protected void setBundleId(String bundleId) {
+        if (!TextUtils.isEmpty(bundleId)) {
+            addParam(BUNDLE_ID_KEY, bundleId);
+        }
     }
 
-    private int mncPortionLength(String networkOperator) {
-        return Math.min(3, networkOperator.length());
-    }
+    protected void addBaseParams(final ClientMetadata clientMetadata) {
+        setAdUnitId(mAdUnitId);
 
-    protected void setTwitterAppInstalledFlag() {
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.UNKNOWN) {
-            sTwitterAppInstalledStatus = getTwitterAppInstallStatus();
-        }
+        setSdkVersion(clientMetadata.getSdkVersion());
+        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
+                clientMetadata.getDeviceModel(),
+                clientMetadata.getDeviceProduct());
+        setBundleId(clientMetadata.getAppPackageName());
 
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) {
-            addParam("ts", "1");
-        }
+        setKeywords(mKeywords);
+
+        setLocation(mLocation);
+
+        setTimezone(DateAndTime.getTimeZoneOffsetString());
+
+        setOrientation(clientMetadata.getOrientationString());
+        setDeviceDimensions(clientMetadata.getDeviceDimensions());
+        setDensity(clientMetadata.getDensity());
+
+        final String networkOperator = clientMetadata.getNetworkOperatorForUrl();
+        setMccCode(networkOperator);
+        setMncCode(networkOperator);
+
+        setIsoCountryCode(clientMetadata.getIsoCountryCode());
+        setCarrierName(clientMetadata.getNetworkOperatorName());
+
+        setNetworkType(clientMetadata.getActiveNetworkType());
+
+        setAppVersion(clientMetadata.getAppVersion());
+
+        appendAdvertisingInfoTemplates();
     }
 
-    public TwitterAppInstalledStatus getTwitterAppInstallStatus() {
-        return IntentUtils.canHandleTwitterUrl(mContext) ? TwitterAppInstalledStatus.INSTALLED : TwitterAppInstalledStatus.NOT_INSTALLED;
+    private void addParam(String key, MoPubNetworkType value) {
+        addParam(key, value.toString());
+    }
+
+    private int mncPortionLength(String networkOperator) {
+        return Math.min(3, networkOperator.length());
     }
 
-    @Deprecated // for testing
-    public static void setTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
-        sTwitterAppInstalledStatus = status;
+    private static int calculateLocationStalenessInMilliseconds(final Location location) {
+        Preconditions.checkNotNull(location);
+        final long locationLastUpdatedInMillis = location.getTime();
+        final long nowInMillis = System.currentTimeMillis();
+        return (int) (nowInMillis - locationLastUpdatedInMillis);
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java b/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java
new file mode 100644
index 00000000..994f01db
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java
@@ -0,0 +1,36 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * This empty implementation of {@link com.mopub.common.LifecycleListener} is convenient for writing
+ * your own adapters for an SDK that MoPub can mediate. You can override only the lifecycle callbacks
+ * that the SDK requires.
+ */
+public class BaseLifecycleListener implements LifecycleListener {
+
+    @Override
+    public void onCreate(@NonNull final Activity activity) {}
+
+    @Override
+    public void onStart(@NonNull final Activity activity) {}
+
+    @Override
+    public void onPause(@NonNull final Activity activity) {}
+
+    @Override
+    public void onResume(@NonNull final Activity activity) {}
+
+    @Override
+    public void onRestart(@NonNull final Activity activity) {}
+
+    @Override
+    public void onStop(@NonNull final Activity activity) {}
+
+    @Override
+    public void onDestroy(@NonNull final Activity activity) {}
+
+    @Override
+    public void onBackPressed(@NonNull final Activity activity) {}
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
index 2b7eb021..68d88289 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
@@ -1,12 +1,17 @@
 package com.mopub.common;
 
+import android.graphics.Point;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 
-import static com.mopub.common.util.Strings.isEmpty;
+import com.mopub.network.Networking;
+import com.mopub.network.PlayServicesUrlRewriter;
 
 public abstract class BaseUrlGenerator {
-    private static final String IFA_PREFIX = "ifa:";
-    private static final String SHA_PREFIX = "sha:";
+
+    private static final String WIDTH_KEY = "w";
+    private static final String HEIGHT_KEY = "h";
 
     private StringBuilder mStringBuilder;
     private boolean mFirstParam;
@@ -14,7 +19,8 @@
     public abstract String generateUrlString(String serverHostname);
 
     protected void initUrlString(String serverHostname, String handlerType) {
-        mStringBuilder = new StringBuilder("http://" + serverHostname + handlerType);
+        String scheme = Networking.useHttps() ? Constants.HTTPS : Constants.HTTP;
+        mStringBuilder = new StringBuilder(scheme).append("://").append(serverHostname).append(handlerType);
         mFirstParam = true;
     }
 
@@ -23,7 +29,7 @@ protected String getFinalUrlString() {
     }
 
     protected void addParam(String key, String value) {
-        if (value == null || isEmpty(value)) {
+        if (TextUtils.isEmpty(value)) {
             return;
         }
 
@@ -76,4 +82,23 @@ protected void setDoNotTrack(boolean dnt) {
     protected void setUdid(String udid) {
         addParam("udid", udid);
     }
+
+    /**
+     * Appends special keys/values for advertising id and do-not-track. PlayServicesUrlRewriter will
+     * replace these templates with the correct values when the request is processed.
+     */
+    protected void appendAdvertisingInfoTemplates() {
+        addParam("udid", PlayServicesUrlRewriter.UDID_TEMPLATE);
+        addParam("dnt", PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE);
+    }
+
+    /**
+     * Adds the width and height.
+     *
+     * @param dimensions The width and height of the screen
+     */
+    protected void setDeviceDimensions(@NonNull final Point dimensions) {
+        addParam(WIDTH_KEY, "" + dimensions.x);
+        addParam(HEIGHT_KEY, "" + dimensions.y);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
index fcc5fad2..81f77af7 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
@@ -32,19 +32,6 @@
     private static final int DISK_CACHE_INDEX = 0;
 
     private static DiskLruCache sDiskLruCache;
-    private static BitmapLruCache sBitmapLruCache;
-
-    public static boolean initializeBitmapCache(final Context context) {
-        if (context == null) {
-            return false;
-        }
-
-        if (sBitmapLruCache == null) {
-            final int memoryCacheSizeBytes = DeviceUtils.memoryCacheSizeBytes(context);
-            sBitmapLruCache = new BitmapLruCache(memoryCacheSizeBytes);
-        }
-        return true;
-    }
 
     public static boolean initializeDiskCache(final Context context) {
         if (context == null) {
@@ -69,7 +56,6 @@ public static boolean initializeDiskCache(final Context context) {
     }
 
     public static void initialize(final Context context) {
-        initializeBitmapCache(context);
         initializeDiskCache(context);
     }
 
@@ -110,14 +96,6 @@ public static String getFilePathDiskCache(final String key) {
                 + DISK_CACHE_INDEX;
     }
 
-    public static Bitmap getFromBitmapCache(final String key) {
-        if (sBitmapLruCache == null) {
-            return null;
-        }
-
-        return sBitmapLruCache.get(key);
-    }
-
     public static byte[] getFromDiskCache(final String key) {
         if (sDiskLruCache == null) {
             return null;
@@ -156,14 +134,6 @@ public static void getFromDiskCacheAsync(final String key, final DiskLruCacheGet
         new DiskLruCacheGetTask(key, diskLruCacheGetListener).execute();
     }
 
-    public static void putToBitmapCache(final String key, final Bitmap bitmap) {
-        if (sBitmapLruCache == null) {
-            return;
-        }
-
-        sBitmapLruCache.put(key, bitmap);
-    }
-
     public static boolean putToDiskCache(final String key, final byte[] content) {
         return putToDiskCache(key, new ByteArrayInputStream(content));
     }
@@ -208,21 +178,6 @@ public static void putToDiskCacheAsync(final String key, final byte[] content) {
         new DiskLruCachePutTask(key, content).execute();
     }
 
-    private static class BitmapLruCache extends LruCache<String, Bitmap> {
-        public BitmapLruCache(final int maxSize) {
-            super(maxSize);
-        }
-
-        @Override
-        protected int sizeOf(final String key, final Bitmap bitmap) {
-            if (bitmap != null) {
-                return bitmap.getRowBytes() * bitmap.getHeight();
-            }
-
-            return super.sizeOf(key, bitmap);
-        }
-    }
-
     private static class DiskLruCacheGetTask extends AsyncTask<Void, Void, byte[]> {
         private final DiskLruCacheGetListener mDiskLruCacheGetListener;
         private final String mKey;
@@ -285,17 +240,6 @@ public static void clearAndNullCaches() {
                 sDiskLruCache = null;
             }
         }
-        if (sBitmapLruCache != null) {
-            sBitmapLruCache.evictAll();
-            sBitmapLruCache = null;
-        }
-    }
-
-    // Testing
-    @Deprecated
-    @VisibleForTesting
-    public static LruCache<String, Bitmap> getBitmapLruCache() {
-        return sBitmapLruCache;
     }
 
     // Testing
diff --git a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
index 6589c171..412f47be 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
@@ -1,8 +1,11 @@
 package com.mopub.common;
 
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Build;
@@ -10,9 +13,14 @@
 import android.telephony.TelephonyManager;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 
+import java.util.Locale;
+
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.content.pm.PackageManager.NameNotFoundException;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 
 /**
@@ -30,50 +38,17 @@
     private static final String SHA_PREFIX = "sha:";
     private static final int UNKNOWN_NETWORK = -1;
 
-    private static volatile ClientMetadata sInstance;
-
-    private String mNetworkOperator;
-    private String mIsoCountryCode;
+    private String mNetworkOperatorForUrl;
+    private final String mNetworkOperator;
+    private String mSimOperator;
+    private final String mIsoCountryCode;
+    private final String mSimIsoCountryCode;
     private String mNetworkOperatorName;
+    private String mSimOperatorName;
     private String mUdid;
     private boolean mDoNotTrack = false;
     private boolean mAdvertisingInfoSet = false;
 
-    /**
-     * Returns the singleton ClientMetadata object, using the context to obtain data if necessary.
-     */
-    public static ClientMetadata getInstance(Context context) {
-        // Use a local variable so we can reduce accesses of the volatile field.
-        ClientMetadata result = sInstance;
-        if (result == null) {
-            synchronized (ClientMetadata.class) {
-                result = sInstance;
-                if (result == null) {
-                    result = new ClientMetadata(context);
-                    sInstance = result;
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Can be used by background threads and other objects without a context to attempt to get
-     * ClientMetadata. If the object has never been referenced from a thread with a context,
-     * this will return null.
-     */
-    public static ClientMetadata getInstance() {
-        ClientMetadata result = sInstance;
-        if (result == null) {
-            // If it's being initialized in another thread, wait for the lock.
-            synchronized (ClientMetadata.class) {
-                result = sInstance;
-            }
-        }
-
-        return result;
-    }
-
     public static enum MoPubNetworkType {
         UNKNOWN(0),
         ETHERNET(1),
@@ -81,7 +56,6 @@ public static ClientMetadata getInstance() {
         MOBILE(3);
 
         private final int mId;
-
         private MoPubNetworkType(int id) {
             mId = id;
         }
@@ -107,44 +81,108 @@ private static MoPubNetworkType fromAndroidNetworkType(int type) {
                     return UNKNOWN;
             }
         }
+
+        public int getId() {
+            return mId;
+        }
     }
 
+    private static volatile ClientMetadata sInstance;
+
     // Cached client metadata used for generating URLs and events.
     private final String mDeviceManufacturer;
     private final String mDeviceModel;
     private final String mDeviceProduct;
+    private final String mDeviceOsVersion;
     private final String mSdkVersion;
     private final String mAppVersion;
+    private final String mAppPackageName;
+    private String mAppName;
     private final Context mContext;
     private final ConnectivityManager mConnectivityManager;
 
-    private ClientMetadata(Context context) {
+    /**
+     * Returns the singleton ClientMetadata object, using the context to obtain data if necessary.
+     */
+    public static ClientMetadata getInstance(Context context) {
+        // Use a local variable so we can reduce accesses of the volatile field.
+        ClientMetadata result = sInstance;
+        if (result == null) {
+            synchronized (ClientMetadata.class) {
+                result = sInstance;
+                if (result == null) {
+                    result = new ClientMetadata(context);
+                    sInstance = result;
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Can be used by background threads and other objects without a context to attempt to get
+     * ClientMetadata. If the object has never been referenced from a thread with a context,
+     * this will return null.
+     */
+    public static ClientMetadata getInstance() {
+        ClientMetadata result = sInstance;
+        if (result == null) {
+            // If it's being initialized in another thread, wait for the lock.
+            synchronized (ClientMetadata.class) {
+                result = sInstance;
+            }
+        }
+
+        return result;
+    }
+
+    // NEVER CALL THIS AS A USER. Get it from the Singletons class.
+    public ClientMetadata(Context context) {
         mContext = context.getApplicationContext();
         mConnectivityManager =
                 (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
         mDeviceManufacturer = Build.MANUFACTURER;
         mDeviceModel = Build.MODEL;
         mDeviceProduct = Build.PRODUCT;
+        mDeviceOsVersion = Build.VERSION.RELEASE;
+
         mSdkVersion = MoPub.SDK_VERSION;
 
         // Cache context items that don't change:
         mAppVersion = getAppVersionFromContext(mContext);
+        PackageManager packageManager = mContext.getPackageManager();
+        ApplicationInfo applicationInfo = null;
+        mAppPackageName = context.getPackageName();
+        try {
+            applicationInfo = packageManager.getApplicationInfo(mAppPackageName, 0);
+        } catch (final NameNotFoundException e) {
+            // swallow
+        }
+        if (applicationInfo != null) {
+            mAppName = (String) packageManager.getApplicationLabel(applicationInfo);
+        }
 
         final TelephonyManager telephonyManager =
                 (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
-
+        mNetworkOperatorForUrl = telephonyManager.getNetworkOperator();
         mNetworkOperator = telephonyManager.getNetworkOperator();
         if (telephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA &&
                 telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
-            mNetworkOperator = telephonyManager.getSimOperator();
+            mNetworkOperatorForUrl = telephonyManager.getSimOperator();
+            mSimOperator = telephonyManager.getSimOperator();
         }
 
         mIsoCountryCode = telephonyManager.getNetworkCountryIso();
+        mSimIsoCountryCode = telephonyManager.getSimCountryIso();
         try {
             // Some Lenovo devices require READ_PHONE_STATE here.
             mNetworkOperatorName = telephonyManager.getNetworkOperatorName();
+            if (telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
+                mSimOperatorName = telephonyManager.getSimOperatorName();
+            }
         } catch (SecurityException e) {
             mNetworkOperatorName = null;
+            mSimOperatorName = null;
         }
 
         // Get the device ID. This will be replaced later when the Play Services callbacks complete.
@@ -205,6 +243,13 @@ public float getDensity() {
         return mContext.getResources().getDisplayMetrics().density;
     }
 
+    /**
+     * @return the network operator for URL generators.
+     */
+    public String getNetworkOperatorForUrl() {
+        return mNetworkOperatorForUrl;
+    }
+
     /**
      * @return the network operator.
      */
@@ -212,6 +257,17 @@ public String getNetworkOperator() {
         return mNetworkOperator;
     }
 
+    public Locale getDeviceLocale() {
+        return mContext.getResources().getConfiguration().locale;
+    }
+
+    /**
+     * @return the sim operator.
+     */
+    public String getSimOperator() {
+        return mSimOperator;
+    }
+
     /**
      * @return the country code of the device.
      */
@@ -219,6 +275,13 @@ public String getIsoCountryCode() {
         return mIsoCountryCode;
     }
 
+    /**
+     * @return the sim provider's country code.
+     */
+    public String getSimIsoCountryCode() {
+        return mSimIsoCountryCode;
+    }
+
     /**
      * @return the network operator name.
      */
@@ -226,10 +289,17 @@ public String getNetworkOperatorName() {
         return mNetworkOperatorName;
     }
 
+    /**
+     * @return the sim operator name.
+     */
+    public String getSimOperatorName() {
+        return mSimOperatorName;
+    }
+
     /**
      * @return the stored device ID.
      */
-    public synchronized String getAdvertisingId() {
+    public synchronized String getDeviceId() {
         return mUdid;
     }
 
@@ -272,6 +342,41 @@ public String getDeviceProduct() {
         return mDeviceProduct;
     }
 
+    /**
+     * @return the device os version.
+     */
+    public String getDeviceOsVersion() {
+        return mDeviceOsVersion;
+    }
+
+    /**
+     * @return the device screen width in dips according to current orientation.
+     */
+    public int getDeviceScreenWidthDip() {
+        return Dips.screenWidthAsIntDips(mContext);
+    }
+
+    /**
+     * @return the device screen height in dips according to current orientation.
+     */
+    public int getDeviceScreenHeightDip() {
+        return Dips.screenHeightAsIntDips(mContext);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons. This method only works after
+     * mContext is initialized.
+     *
+     * @return Width and height of the device. This is 0 by 0 if there is no context.
+     */
+    public Point getDeviceDimensions() {
+        if (Preconditions.NoThrow.checkNotNull(mContext)) {
+            return DeviceUtils.getDeviceDimensions(mContext);
+        }
+        return new Point(0, 0);
+    }
+
     /**
      * @return the MoPub SDK Version.
      */
@@ -286,8 +391,30 @@ public String getAppVersion() {
         return mAppVersion;
     }
 
+    /**
+     * @return the package of the application the SDK is included in.
+     */
+    public String getAppPackageName() {
+        return mAppPackageName;
+    }
+
+    /**
+     * @return the name of the application the SDK is included in.
+     */
+    public String getAppName() {
+        return mAppName;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static void setInstance(ClientMetadata clientMetadata) {
+        synchronized (ClientMetadata.class) {
+            sInstance = clientMetadata;
+        }
+    }
+
     @VisibleForTesting
-    public static synchronized void clearForTesting() {
+    public static void clearForTesting() {
         sInstance = null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java b/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java
new file mode 100644
index 00000000..a38f4b52
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java
@@ -0,0 +1,295 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.StateListDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
+import android.view.ViewConfiguration;
+import android.widget.FrameLayout;
+
+import com.mopub.common.util.Dips;
+
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
+
+/**
+ * CloseableLayout provides a layout class that shows a close button, and allows setting a
+ * {@link OnCloseListener}. Otherwise CloseableLayout behaves identically to
+ * {@link FrameLayout}.
+ *
+ * Rather than adding a button to the view tree, CloseableLayout is designed to draw the close
+ * button directly on the canvas and to track MotionEvents on its close region. While
+ * marginally more efficient, the main benefit to this is that CloseableLayout can function
+ * exactly as a regular FrameLayout without needing to override addView, removeView,
+ * removeAllViews, and a host of other methods.
+ *
+ * You can hide the close button using {@link #setCloseVisible} and change its position
+ * using {@link #setClosePosition}.
+ */
+public class CloseableLayout extends FrameLayout {
+    public interface OnCloseListener {
+        void onClose();
+    }
+
+    @VisibleForTesting
+    static final float CLOSE_BUTTON_SIZE_DP = 30.0f;
+    static final float CLOSE_REGION_SIZE_DP = 50.0f;
+
+    @VisibleForTesting
+    static final float CLOSE_BUTTON_PADDING_DP = 8.0f;
+
+    /**
+     * Defines a subset of supported gravity combinations for the CloseableLayout. These values
+     * include the possible values for customClosePosition as defined in the
+     * <a href="http://www.iab.net/media/file/IAB_MRAID_v2_FINAL.pdf">MRAID 2.0
+     * specification</a>.
+     */
+    public static enum ClosePosition {
+        TOP_LEFT(Gravity.TOP | Gravity.LEFT),
+        TOP_CENTER(Gravity.TOP | Gravity.CENTER_HORIZONTAL),
+        TOP_RIGHT(Gravity.TOP | Gravity.RIGHT),
+        CENTER(Gravity.CENTER),
+        BOTTOM_LEFT(Gravity.BOTTOM | Gravity.LEFT),
+        BOTTOM_CENTER(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL),
+        BOTTOM_RIGHT(Gravity.BOTTOM | Gravity.RIGHT);
+
+        private final int mGravity;
+
+        ClosePosition(final int mGravity) {
+            this.mGravity = mGravity;
+        }
+
+        int getGravity() {
+            return mGravity;
+        }
+    }
+
+    // Used in onTouchEvent to be lenient about moving outside the close button bounds. This is the
+    // same pattern used in the Android framework to handle click events.
+    private final int mTouchSlop;
+
+    @Nullable
+    private OnCloseListener mOnCloseListener;
+
+    @NonNull
+    private final StateListDrawable mCloseDrawable;
+    @NonNull
+    private ClosePosition mClosePosition;
+    private final int mCloseRegionSize;  // Size of the touchable close region.
+    private final int mCloseButtonSize;  // Size of the drawn close button.
+    private final int mCloseButtonPadding;
+
+    // Whether we need to recalculate the close bounds on the next draw pass
+    private boolean mCloseBoundChanged;
+
+    // Hang on to our bounds Rects so we don't allocate memory in the draw() method.
+    private final Rect mClosableLayoutRect = new Rect();
+    private final Rect mCloseRegionBounds = new Rect();
+    private final Rect mCloseButtonBounds = new Rect();
+    private final Rect mInsetCloseRegionBounds = new Rect();
+
+    @Nullable
+    private UnsetPressedState mUnsetPressedState;
+
+    public CloseableLayout(@NonNull Context context) {
+        super(context);
+
+        mCloseDrawable = new StateListDrawable();
+        mClosePosition = ClosePosition.TOP_RIGHT;
+
+        mCloseDrawable.addState(SELECTED_STATE_SET,
+                INTERSTITIAL_CLOSE_BUTTON_PRESSED.createDrawable(context));
+        mCloseDrawable.addState(EMPTY_STATE_SET,
+                INTERSTITIAL_CLOSE_BUTTON_NORMAL.createDrawable(context));
+
+        mCloseDrawable.setState(EMPTY_STATE_SET);
+        mCloseDrawable.setCallback(this);
+
+        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
+
+        mCloseRegionSize = Dips.asIntPixels(CLOSE_REGION_SIZE_DP, context);
+        mCloseButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE_DP, context);
+        mCloseButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING_DP, context);
+
+        setWillNotDraw(false);
+    }
+
+    public void setOnCloseListener(@Nullable OnCloseListener onCloseListener) {
+        mOnCloseListener = onCloseListener;
+    }
+
+    public void setClosePosition(@NonNull ClosePosition closePosition) {
+        Preconditions.checkNotNull(closePosition);
+
+        mClosePosition = closePosition;
+        mCloseBoundChanged = true;
+        invalidate();
+    }
+
+    public void setCloseVisible(boolean visible) {
+        if (mCloseDrawable.setVisible(visible, false)) {
+            invalidate(mCloseRegionBounds);
+        }
+    }
+
+    @Override
+    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
+        super.onSizeChanged(width, height, oldWidth, oldHeight);
+        mCloseBoundChanged = true;
+    }
+
+    @Override
+    public void draw(@NonNull final Canvas canvas) {
+        super.draw(canvas);
+
+        // Only recalculate the close bounds if they are dirty
+        if (mCloseBoundChanged) {
+            mCloseBoundChanged = false;
+
+            mClosableLayoutRect.set(0, 0, getWidth(), getHeight());
+            // Create the bounds for our close regions.
+            applyCloseRegionBounds(mClosePosition, mClosableLayoutRect, mCloseRegionBounds);
+
+            // The inset rect applies padding around the visible closeButton.
+            mInsetCloseRegionBounds.set(mCloseRegionBounds);
+            mInsetCloseRegionBounds.inset(mCloseButtonPadding, mCloseButtonPadding);
+            // The close button sits inside the close region with padding and gravity
+            // in the same way the close region sits inside the whole ClosableLayout
+            applyCloseButtonBounds(mClosePosition, mInsetCloseRegionBounds, mCloseButtonBounds);
+            mCloseDrawable.setBounds(mCloseButtonBounds);
+        }
+
+        // Draw last so that this gets drawn as the top layer. This is also why we override
+        // draw instead of onDraw.
+        if (mCloseDrawable.isVisible()) {
+            mCloseDrawable.draw(canvas);
+        }
+    }
+
+    public void applyCloseRegionBounds(ClosePosition closePosition, Rect bounds, Rect closeBounds) {
+        applyCloseBoundsWithSize(closePosition, mCloseRegionSize, bounds, closeBounds);
+    }
+
+    private void applyCloseButtonBounds(ClosePosition closePosition, Rect bounds, Rect outBounds) {
+        applyCloseBoundsWithSize(closePosition, mCloseButtonSize, bounds, outBounds);
+    }
+
+    private void applyCloseBoundsWithSize(ClosePosition closePosition, final int size, Rect bounds, Rect outBounds) {
+        Gravity.apply(closePosition.getGravity(), size, size, bounds, outBounds);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(@NonNull final MotionEvent event) {
+        // See http://developer.android.com/training/gestures/viewgroup.html for details on
+        // capturing motion events
+
+        // Start intercepting touch events only when we see a down event
+        if (event.getAction() != MotionEvent.ACTION_DOWN) {
+            return false;
+        }
+
+        // Start intercepting if the down event is in the close bounds. Returning true
+        // here causes onTouchEvent to get called for all events up until ACTION_CANCEL gets called.
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        return pointInCloseBounds(x, y, 0);
+    }
+
+    @Override
+    public boolean onTouchEvent(@NonNull MotionEvent event) {
+        // Stop receiving touch events if we aren't within the bounds, including some slop.
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        if (!pointInCloseBounds(x, y, mTouchSlop)) {
+            setClosePressed(false);
+            super.onTouchEvent(event);
+            return false;
+        }
+
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                setClosePressed(true);
+                break;
+            case MotionEvent.ACTION_CANCEL:
+                // Cancelled by a parent
+                setClosePressed(false);
+                break;
+            case MotionEvent.ACTION_UP:
+                if (isClosePressed()) {
+                    // Delay setting the unpressed state so that the button remains pressed
+                    // at least long enough to respond to the close event.
+                    if (mUnsetPressedState == null) {
+                        mUnsetPressedState = new UnsetPressedState();
+                    }
+                    postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
+                    performClose();
+                }
+                break;
+        }
+        return true;
+    }
+
+    private void setClosePressed(boolean pressed) {
+        if (pressed == isClosePressed()) {
+            return;
+        }
+
+        mCloseDrawable.setState(pressed ? SELECTED_STATE_SET : EMPTY_STATE_SET);
+        invalidate(mCloseRegionBounds);
+    }
+
+    @VisibleForTesting
+    boolean isClosePressed() {
+        return mCloseDrawable.getState() == SELECTED_STATE_SET;
+    }
+
+    @VisibleForTesting
+    boolean pointInCloseBounds(int x, int y, int slop) {
+        return x >= mCloseRegionBounds.left - slop
+                && y >= mCloseRegionBounds.top - slop
+                && x < mCloseRegionBounds.right + slop
+                && y < mCloseRegionBounds.bottom + slop;
+    }
+
+    private void performClose() {
+        playSoundEffect(SoundEffectConstants.CLICK);
+        if (mOnCloseListener != null) {
+            mOnCloseListener.onClose();
+        }
+    }
+
+    /**
+     * This is a copy of the UnsetPressedState pattern from Android's View.java, which is used
+     * to unset the pressed state of a button after a delay.
+     */
+    private final class UnsetPressedState implements Runnable {
+        public void run() {
+            setClosePressed(false);
+        }
+    }
+
+    @VisibleForTesting
+    void setCloseBounds(Rect closeBounds) {
+        mCloseRegionBounds.set(closeBounds);
+    }
+
+    @VisibleForTesting
+    Rect getCloseBounds() {
+        return mCloseRegionBounds;
+    }
+
+    @VisibleForTesting
+    void setCloseBoundChanged(boolean changed) {
+        mCloseBoundChanged = changed;
+    }
+
+    @VisibleForTesting
+    public boolean isCloseVisible() {
+        return mCloseDrawable.isVisible();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/Constants.java b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
new file mode 100644
index 00000000..0ca157fe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
@@ -0,0 +1,20 @@
+package com.mopub.common;
+
+public class Constants {
+    private Constants() {}
+
+    public static final String HTTP = "http";
+    public static final String HTTPS = "https";
+
+    public static final String HOST = "ads.mopub.com";
+
+    public static final String AD_HANDLER = "/m/ad";
+    public static final String CONVERSION_TRACKING_HANDLER = "/m/open";
+    public static final String POSITIONING_HANDLER = "/m/pos";
+
+
+    public static final int TEN_SECONDS_MILLIS = 10 * 1000;
+    public static final int THIRTY_SECONDS_MILLIS = 30 * 1000;
+
+    public static final int TEN_MB = 10 * 1024 * 1024;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
new file mode 100644
index 00000000..f6fec437
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
@@ -0,0 +1,24 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * Represents the orientation returned for MoPub ads from the MoPub ad server.
+ */
+public enum CreativeOrientation {
+    PORTRAIT, LANDSCAPE, UNDEFINED;
+
+    @NonNull
+    public static CreativeOrientation fromHeader(@Nullable String orientation) {
+        if ("l".equalsIgnoreCase(orientation)) {
+            return LANDSCAPE;
+        }
+
+        if ("p".equalsIgnoreCase(orientation)) {
+            return PORTRAIT;
+        }
+
+        return UNDEFINED;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
new file mode 100644
index 00000000..3adb73e3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
@@ -0,0 +1,18 @@
+package com.mopub.common;
+
+/**
+ * Keys used in localExtras and serverExtras maps for MoPub custom events.
+ */
+public class DataKeys {
+    public static final String AD_REPORT_KEY = "mopub-intent-ad-report";
+    public static final String HTML_RESPONSE_BODY_KEY = "Html-Response-Body";
+    public static final String REDIRECT_URL_KEY = "Redirect-Url";
+    public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
+    public static final String SCROLLABLE_KEY = "Scrollable";
+    public static final String CREATIVE_ORIENTATION_KEY = "com_mopub_orientation";
+    public static final String JSON_BODY_KEY = "com_mopub_native_json";
+    public static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
+    public static final String AD_UNIT_ID_KEY = "com_mopub_ad_unit_id";
+    public static final String AD_WIDTH = "com_mopub_ad_width";
+    public static final String AD_HEIGHT = "com_mopub_ad_height";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java b/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
index 0c603e66..c62d6594 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
@@ -16,6 +16,8 @@
 
 package com.mopub.common;
 
+import android.support.annotation.NonNull;
+
 import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -846,7 +848,7 @@ private FaultHidingOutputStream(OutputStream out) {
         }
       }
 
-      @Override public void write(byte[] buffer, int offset, int length) {
+      @Override public void write(@NonNull byte[] buffer, int offset, int length) {
         try {
           out.write(buffer, offset, length);
         } catch (IOException e) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
index 6b396539..6ce126e8 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
@@ -4,6 +4,7 @@
 import com.mopub.common.util.Streams;
 
 import org.apache.http.Header;
+import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 
 import java.io.BufferedInputStream;
@@ -19,9 +20,12 @@ public DownloadResponse(final HttpResponse httpResponse) throws Exception {
         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         BufferedInputStream inputStream = null;
         try {
-            inputStream = new BufferedInputStream(httpResponse.getEntity().getContent());
-            Streams.copyContent(inputStream, outputStream);
-            mBytes = outputStream.toByteArray();
+            HttpEntity httpEntity = httpResponse.getEntity();
+            if (httpEntity != null) {
+                inputStream = new BufferedInputStream(httpEntity.getContent());
+                Streams.copyContent(inputStream, outputStream);
+                mBytes = outputStream.toByteArray();
+            }
         } finally {
             Streams.closeStream(inputStream);
             Streams.closeStream(outputStream);
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
index fc31c97c..7230a2ae 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
@@ -2,7 +2,9 @@
 
 import android.net.http.AndroidHttpClient;
 import android.os.AsyncTask;
+
 import com.mopub.common.logging.MoPubLog;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
 
@@ -39,7 +41,6 @@ protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequest
             return new DownloadResponse(httpResponse);
         } catch (Exception e) {
             MoPubLog.d("Download task threw an internal exception", e);
-            cancel(true);
             return null;
         } finally {
             if (httpClient != null) {
@@ -60,6 +61,6 @@ protected void onPostExecute(final DownloadResponse downloadResponse) {
 
     @Override
     protected void onCancelled() {
-        mDownloadTaskListener.onComplete(mUrl, null);
+        MoPubLog.d("DownloadTask was cancelled.");
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
index 75b9bdf7..e26371b0 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.os.AsyncTask;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
@@ -18,11 +20,21 @@
     private static String sPlayServicesUtilClassName = "com.google.android.gms.common.GooglePlayServicesUtil";
     private static String sAdvertisingIdClientClassName = "com.google.android.gms.ads.identifier.AdvertisingIdClient";
 
+    public static class AdvertisingInfo {
+        public final String advertisingId;
+        public final boolean limitAdTracking;
+
+        public AdvertisingInfo(String adId, boolean limitAdTrackingEnabled) {
+            advertisingId = adId;
+            limitAdTracking = limitAdTrackingEnabled;
+        }
+    }
+
     public interface GpsHelperListener {
         public void onFetchAdInfoCompleted();
     }
 
-    static boolean isPlayServicesAvailable(final Context context) {
+    public static boolean isPlayServicesAvailable(final Context context) {
         try {
             MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "isGooglePlayServicesAvailable")
                     .setStatic(Class.forName(sPlayServicesUtilClassName))
@@ -68,6 +80,29 @@ static public void fetchAdvertisingInfoAsync(final Context context, final GpsHel
         }
     }
 
+    @Nullable
+    static public AdvertisingInfo fetchAdvertisingInfoSync(final Context context) {
+        if (context == null) {
+            return null;
+        }
+        Object adInfo = null;
+        try {
+            MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "getAdvertisingIdInfo")
+                    .setStatic(Class.forName(sAdvertisingIdClientClassName))
+                    .addParam(Context.class, context);
+
+            adInfo = methodBuilder.execute();
+        } catch (Exception e) {
+            MoPubLog.d("Unable to obtain Google AdvertisingIdClient.Info via reflection.");
+            return null;
+        }
+
+        String advertisingId = reflectedGetAdvertisingId(adInfo, null);
+        boolean isLimitAdTrackingEnabled = reflectedIsLimitAdTrackingEnabled(adInfo, false);
+
+        return new AdvertisingInfo(advertisingId, isLimitAdTrackingEnabled);
+    }
+
     static private void internalFetchAdvertisingInfoAsync(final Context context, final GpsHelperListener gpsHelperListener) {
         if (!classFound(sAdvertisingIdClientClassName)) {
             if (gpsHelperListener != null) {
@@ -114,7 +149,7 @@ protected Void doInBackground(Void... voids) {
                     updateClientMetadata(context, adInfo);
                 }
             } catch (Exception exception) {
-                MoPubLog.d("Unable to obtain AdvertisingIdClient.getAdvertisingIdInfo()");
+                MoPubLog.d("Unable to obtain Google AdvertisingIdClient.Info via reflection.");
             }
 
             return null;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java b/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
index 88e4f7bd..c1161d70 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
@@ -2,31 +2,34 @@
 
 import android.content.Context;
 import android.net.http.AndroidHttpClient;
-import android.os.Handler;
-import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.webkit.WebView;
 
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.logging.MoPubLog;
 
-import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.params.HttpClientParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 
-import java.util.Arrays;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLDecoder;
 
 import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 
 public class HttpClient {
     private static final int CONNECTION_TIMEOUT = 10000;
     private static final int SOCKET_TIMEOUT = 10000;
+    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
     private static String sWebViewUserAgent;
 
     public static AndroidHttpClient getHttpClient() {
-        String userAgent = DeviceUtils.getUserAgent();
+        final String userAgent = getWebViewUserAgent(DEFAULT_USER_AGENT);
 
         AndroidHttpClient httpClient = AndroidHttpClient.newInstance(userAgent);
 
@@ -38,8 +41,22 @@ public static AndroidHttpClient getHttpClient() {
         return httpClient;
     }
 
-    public static HttpGet initializeHttpGet(final String url, final Context context) {
-        final HttpGet httpGet = new HttpGet(url);
+    public static HttpGet initializeHttpGet(@NonNull final String url) {
+        return initializeHttpGet(url, null);
+    }
+
+    public static HttpGet initializeHttpGet(@NonNull String url, @Nullable final Context context) {
+        Preconditions.checkNotNull(url);
+
+        // Try to encode url. If this fails, then fallback on the original url
+        String getUrl;
+        try {
+            getUrl = urlEncode(url);
+        } catch (Exception e) {
+            getUrl = url;
+        }
+
+        final HttpGet httpGet = new HttpGet(getUrl);
 
         if (getWebViewUserAgent() == null && context != null) {
             // Memoize the user agent since creating WebViews is expensive
@@ -55,56 +72,90 @@ public static HttpGet initializeHttpGet(final String url, final Context context)
         return httpGet;
     }
 
-    public static void makeTrackingHttpRequest(final Iterable<String> urls, final Context context) {
-        if (urls == null || context == null) {
-            return;
+    /**
+     * This method constructs a properly encoded and valid URI adhering to legal characters for
+     * each component. See Android docs on these classes for reference.
+     */
+    public static String urlEncode(@NonNull final String url) throws Exception {
+        Preconditions.checkNotNull(url);
+
+        // If the URL is improperly encoded, then fail
+        if (isUrlImproperlyEncoded(url)) {
+            throw new UnsupportedEncodingException("URL is improperly encoded: " + url);
+        }
+
+        // If the url is unencoded, then encode it. Otherwise it is already properly encoded
+        // and leave it as is.
+        URI uri;
+        if (isUrlUnencoded(url)) {
+            uri = encodeUrl(url);
+        } else {
+            uri = new URI(url);
         }
 
-        final DownloadTask.DownloadTaskListener downloadTaskListener = new DownloadTask.DownloadTaskListener() {
-            @Override
-            public void onComplete(final String url, final DownloadResponse downloadResponse) {
-                if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                    return;
-                }
-
-                String result = HttpResponses.asResponseString(downloadResponse);
-
-                if (result != null) {
-                    MoPubLog.d("Successfully hit tracking endpoint: " + url);
-                } else {
-                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                }
-            }
-        };
-
-        // Hold onto the application context in closure instead of activity context
-        final Context appContext = context.getApplicationContext();
-        final Runnable trackingHttpRequestRunnable = new Runnable() {
-            @Override
-            public void run() {
-                for (final String url : urls) {
-                    try {
-                        final HttpGet httpGet = initializeHttpGet(url, appContext);
-                        AsyncTasks.safeExecuteOnExecutor(new DownloadTask(downloadTaskListener), httpGet);
-                    } catch (Exception e) {
-                        MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                    }
-                }
-            }
-        };
-
-        new Handler(Looper.getMainLooper()).post(trackingHttpRequestRunnable);
+        return uri.toURL().toString();
     }
 
-    public static void makeTrackingHttpRequest(final String url, final Context context) {
-        makeTrackingHttpRequest(Arrays.asList(url), context);
+    /**
+     * This method tries to decode the URL and returns false if it can't due to improper encoding.
+     */
+    static boolean isUrlImproperlyEncoded(@NonNull String url) {
+        try {
+            URLDecoder.decode(url, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            MoPubLog.w("Url is improperly encoded: " + url);
+            return true;
+        }
+        return false;
     }
 
-    public synchronized static String getWebViewUserAgent() {
+    /**
+     * This method tries to construct a URI and returns true if it can't due to illegal characters
+     * in the url.
+     */
+    static boolean isUrlUnencoded(@NonNull String url) {
+        try {
+            new URI(url);
+        } catch (URISyntaxException e) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * This method encodes each component of the URL into a valid URI.
+     */
+    static URI encodeUrl(@NonNull String urlString) throws Exception {
+        URI uri;
+        try {
+            URL url = new URL(urlString);
+            uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(),
+                    url.getPath(), url.getQuery(), url.getRef());
+        } catch (Exception e) {
+            MoPubLog.w("Failed to encode url: " + urlString);
+            throw e;
+        }
+        return uri;
+    }
+
+    /**
+     * @param defaultUserAgent the String to return if the WebView user agent hasn't been generated.
+     * @return the user agent of an Android WebView, or {@code defaultUserAgent}
+     */
+    public synchronized static String getWebViewUserAgent(String defaultUserAgent) {
+        if (TextUtils.isEmpty(sWebViewUserAgent)) {
+            return defaultUserAgent;
+        }
         return sWebViewUserAgent;
     }
 
+    /**
+     * @return the user agent of an Android WebView or {@code null}
+     */
+    public synchronized static String getWebViewUserAgent() {
+        return getWebViewUserAgent(null);
+    }
+
     public synchronized static void setWebViewUserAgent(final String userAgent) {
         sWebViewUserAgent = userAgent;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java b/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java
new file mode 100644
index 00000000..d92f8d5d
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java
@@ -0,0 +1,21 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * This is a uniform interface to 3rd party SDKs that need to know when Activity lifecycle events
+ * occur.
+ */
+public interface LifecycleListener {
+
+    public void onCreate(@NonNull Activity activity);
+    public void onStart(@NonNull Activity activity);
+    public void onPause(@NonNull Activity activity);
+    public void onResume(@NonNull Activity activity);
+
+    public void onRestart(@NonNull Activity activity);
+    public void onStop(@NonNull Activity activity);
+    public void onDestroy(@NonNull Activity activity);
+    public void onBackPressed(@NonNull Activity activity);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
index 52b2c67b..6602db66 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.logging.MoPubLog;
 
@@ -48,6 +49,7 @@
      * - The location providers don't exist
      * - Location awareness is disabled in the parent MoPubView
      */
+    @Nullable
     public static Location getLastKnownLocation(final Context context,
             final int locationPrecision,
             final MoPub.LocationAwareness locationLocationAwareness) {
@@ -65,6 +67,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve GPS location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
+        } catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
         }
 
         Location networkLocation = null;
@@ -74,6 +78,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve network location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve network location: device has no network provider.");
+        }  catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no network provider.");
         }
 
         if (gpsLocation == null && networkLocation == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java b/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java
new file mode 100644
index 00000000..42e7b7a6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java
@@ -0,0 +1,6 @@
+package com.mopub.common;
+
+/**
+ * A marker interface for 3rd party SDK options.
+ */
+public interface MediationSettings {}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 808400cf..12e2921d 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -1,7 +1,14 @@
 package com.mopub.common;
 
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+import com.mopub.mobileads.MoPubRewardedVideoManager;
+
 public class MoPub {
-    public static final String SDK_VERSION = "3.2.2";
+    public static final String SDK_VERSION = "3.8.0";
 
     public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
@@ -28,4 +35,68 @@ public static int getLocationPrecision() {
     public static void setLocationPrecision(int precision) {
         sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
     }
+
+
+    //////// MoPub LifecycleListener messages ////////
+
+    public static void onCreate(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onCreate(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onPause(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onPause(activity);
+    }
+
+    public static void onResume(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onResume(activity);
+        updateActivity(activity);
+    }
+
+    public static void onRestart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onRestart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStop(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStop(activity);
+    }
+
+    public static void onDestroy(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onDestroy(activity);
+    }
+
+    public static void onBackPressed(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onBackPressed(activity);
+    }
+
+    ////////// MoPub RewardedVideoControl methods //////////
+    public static void initializeRewardedVideo(@NonNull Activity activity, MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.init(activity, mediationSettings);
+    }
+
+    private static void updateActivity(@NonNull Activity activity) {
+        MoPubRewardedVideoManager.updateActivity(activity);
+    }
+
+    public static void setRewardedVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        MoPubRewardedVideoManager.setVideoListener(listener);
+    }
+
+    public static void loadRewardedVideo(@NonNull String adUnitId, @Nullable MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.loadVideo(adUnitId, mediationSettings);
+    }
+
+    public static boolean hasRewardedVideo(@NonNull String adUnitId) {
+        return MoPubRewardedVideoManager.hasVideo(adUnitId);
+    }
+
+    public static void showRewardedVideo(@NonNull String adUnitId) {
+        MoPubRewardedVideoManager.showVideo(adUnitId);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
index 4e55f583..b4e88938 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -10,6 +10,7 @@
 import android.os.Bundle;
 import android.view.Gravity;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.Window;
 import android.webkit.CookieSyncManager;
 import android.webkit.WebChromeClient;
@@ -19,9 +20,10 @@
 import android.widget.ImageButton;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
-import android.widget.Toast;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.util.WebViews;
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
@@ -32,8 +34,7 @@
 import static com.mopub.common.util.Drawables.RIGHT_ARROW;
 import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
 import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
-import static com.mopub.common.util.IntentUtils.deviceCanHandleIntent;
-import static com.mopub.common.util.IntentUtils.isDeepLink;
+import static com.mopub.common.util.Intents.deviceCanHandleIntent;
 
 public class MoPubBrowser extends Activity {
     public static final String DESTINATION_URL_KEY = "URL";
@@ -88,7 +89,7 @@ private void initializeWebView() {
             @Override
             public void onReceivedError(WebView view, int errorCode, String description,
                     String failingUrl) {
-                Toast.makeText(MoPubBrowser.this, "MoPubBrowser error: " + description, Toast.LENGTH_SHORT).show();
+                MoPubLog.d("MoPubBrowser error: " + description);
             }
 
             @Override
@@ -98,7 +99,8 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 }
 
                 final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-                if (isDeepLink(url) && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
+                if (UrlAction.FOLLOW_DEEP_LINK.shouldTryHandlingUrl(Uri.parse(url))
+                        && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
                     startActivity(intent);
                     finish();
                     return true;
@@ -110,7 +112,7 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
             @Override
             public void onPageStarted(WebView view, String url, Bitmap favicon) {
                 super.onPageStarted(view, url, favicon);
-                mForwardButton.setImageDrawable(UNRIGHT_ARROW.decodeImage(MoPubBrowser.this));
+                mForwardButton.setImageDrawable(UNRIGHT_ARROW.createDrawable(MoPubBrowser.this));
             }
 
             @Override
@@ -118,13 +120,13 @@ public void onPageFinished(WebView view, String url) {
                 super.onPageFinished(view, url);
 
                 Drawable backImageDrawable = view.canGoBack()
-                        ? LEFT_ARROW.decodeImage(MoPubBrowser.this)
-                        : UNLEFT_ARROW.decodeImage(MoPubBrowser.this);
+                        ? LEFT_ARROW.createDrawable(MoPubBrowser.this)
+                        : UNLEFT_ARROW.createDrawable(MoPubBrowser.this);
                 mBackButton.setImageDrawable(backImageDrawable);
 
                 Drawable forwardImageDrawable = view.canGoForward()
-                        ? RIGHT_ARROW.decodeImage(MoPubBrowser.this)
-                        : UNRIGHT_ARROW.decodeImage(MoPubBrowser.this);
+                        ? RIGHT_ARROW.createDrawable(MoPubBrowser.this)
+                        : UNRIGHT_ARROW.createDrawable(MoPubBrowser.this);
                 mForwardButton.setImageDrawable(forwardImageDrawable);
             }
         });
@@ -183,12 +185,30 @@ private void enableCookies() {
     protected void onPause() {
         super.onPause();
         CookieSyncManager.getInstance().stopSync();
+        WebViews.onPause(mWebView, isFinishing());
     }
 
     @Override
     protected void onResume() {
         super.onResume();
         CookieSyncManager.getInstance().startSync();
+        WebViews.onResume(mWebView);
+    }
+
+    @Override
+    public void finish() {
+        // ZoomButtonController adds buttons to the window's decorview. If they're still visible
+        // when finish() is called, they need to be removed or a Window object will be leaked.
+        ViewGroup decorView = (ViewGroup) getWindow().getDecorView();
+        decorView.removeAllViews();
+        super.finish();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mWebView.destroy();
+        mWebView = null;
     }
 
     private View getMoPubBrowserView() {
@@ -207,20 +227,20 @@ private View getMoPubBrowserView() {
         RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
         innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
         innerLayout.setLayoutParams(innerLayoutParams);
-        innerLayout.setBackgroundDrawable(BACKGROUND.decodeImage(this));
+        innerLayout.setBackgroundDrawable(BACKGROUND.createDrawable(this));
         outerLayout.addView(innerLayout);
 
-        mBackButton = getButton(LEFT_ARROW.decodeImage(this));
-        mForwardButton = getButton(RIGHT_ARROW.decodeImage(this));
-        mRefreshButton = getButton(REFRESH.decodeImage(this));
-        mCloseButton = getButton(CLOSE.decodeImage(this));
+        mBackButton = getButton(LEFT_ARROW.createDrawable(this));
+        mForwardButton = getButton(RIGHT_ARROW.createDrawable(this));
+        mRefreshButton = getButton(REFRESH.createDrawable(this));
+        mCloseButton = getButton(CLOSE.createDrawable(this));
 
         innerLayout.addView(mBackButton);
         innerLayout.addView(mForwardButton);
         innerLayout.addView(mRefreshButton);
         innerLayout.addView(mCloseButton);
 
-        mWebView = new WebView(this);
+        mWebView = new BaseWebView(this);
         RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
         layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
         mWebView.setLayoutParams(layoutParams);
@@ -240,4 +260,10 @@ private ImageButton getButton(final Drawable drawable) {
 
         return imageButton;
     }
+
+    @Deprecated
+    @VisibleForTesting
+    void setWebView(WebView webView) {
+        mWebView = webView;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java
new file mode 100644
index 00000000..41394805
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java
@@ -0,0 +1,107 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.lang.ref.WeakReference;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * This class handles delegating lifecycle callback events to ads SDKs that require them.
+ */
+public class MoPubLifecycleManager implements LifecycleListener {
+    private static MoPubLifecycleManager sInstance;
+
+    @NonNull private final Set<LifecycleListener> mLifecycleListeners;
+    @NonNull private final WeakReference<Activity> mMainActivity;
+
+    private MoPubLifecycleManager(Activity mainActivity) {
+        mLifecycleListeners = new HashSet<LifecycleListener>();
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+    }
+
+    @NonNull public static synchronized MoPubLifecycleManager getInstance(Activity mainActivity) {
+        if (sInstance == null) {
+            sInstance = new MoPubLifecycleManager(mainActivity);
+        }
+
+        return sInstance;
+    }
+
+    /**
+     * Adds a lifecycle listener to the manager. The manager takes ownership with a strong reference.
+     *
+     * @param listener the listener to add to the lifecycle manager.
+     */
+    public void addLifecycleListener(@Nullable LifecycleListener listener) {
+        // Get the instance or bail if not initialized.
+        if (listener == null) {
+            return;
+        }
+        if (mLifecycleListeners.add(listener)) {
+            Activity activity = mMainActivity.get();
+            if (activity != null) {
+                listener.onCreate(activity);
+                listener.onStart(activity);
+            }
+        }
+    }
+
+    @Override
+    public void onCreate(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onCreate(activity);
+        }
+    }
+
+    @Override
+    public void onStart(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onStart(activity);
+        }
+    }
+
+    @Override
+    public void onPause(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onPause(activity);
+        }
+    }
+
+    @Override
+    public void onResume(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onResume(activity);
+        }
+    }
+
+    @Override
+    public void onRestart(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onStop(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onDestroy(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onBackPressed(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onBackPressed(activity);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java
new file mode 100644
index 00000000..85f0f3c2
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java
@@ -0,0 +1,43 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+
+/**
+ * Represents a reward to the user for completing a rewarded task like watching a video.
+ */
+public final class MoPubReward {
+    public static final String NO_REWARD_LABEL = "";
+    public static final int NO_REWARD_AMOUNT = -123;
+    private final boolean mSuccess;
+    private final @NonNull String mLabel;
+    private final int mAmount;
+
+    private MoPubReward(boolean success, @NonNull String label, int amount) {
+        mSuccess = success;
+        mLabel = label;
+        mAmount = amount;
+    }
+
+    @NonNull
+    public static MoPubReward failure() {
+        return new MoPubReward(false, NO_REWARD_LABEL, 0);
+    }
+
+    @NonNull
+    public static MoPubReward success(@NonNull final String rewardLabel, final int amount) {
+        return new MoPubReward(true, rewardLabel, amount);
+    }
+
+    public final boolean isSuccessful() {
+        return mSuccess;
+    }
+
+    @NonNull
+    public final String getLabel() {
+        return mLabel;
+    }
+
+    public final int getAmount() {
+        return mAmount;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
new file mode 100644
index 00000000..d8fd9c92
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
@@ -0,0 +1,246 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import static com.mopub.common.Constants.HTTP;
+import static com.mopub.common.Constants.HTTPS;
+import static com.mopub.common.UrlHandler.MoPubSchemeListener;
+
+/**
+ * {@code UrlAction} describes the different kinds of actions for URLs that {@link UrlHandler} can
+ * potentially perform and how to match against each URL.
+ */
+public enum UrlAction {
+    /**
+     * NOTE: The order in which these are defined determines the priority when matching URLs!
+     * If a URL matches multiple Url Actions, it will be handled by the one that appears first in
+     * this enum (see {@link UrlHandler#handleUrl(Context, String)}).
+     *
+     * Each UrlAction includes its ordinal in a comment as a reminder of this fact.
+     */
+
+    /* 0 */ HANDLE_MOPUB_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopub".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String host = uri.getHost();
+
+            if ("finishLoad".equals(host)) {
+                moPubSchemeListener.onFinishLoad();
+            } else if ("close".equals(host)) {
+                moPubSchemeListener.onClose();
+            } else if ("failLoad".equals(host)) {
+                moPubSchemeListener.onFailLoad();
+            } else {
+                throw new IntentNotResolvableException("Could not handle MoPub Scheme url: " + uri);
+            }
+        }
+    },
+
+    /* 1 */ IGNORE_ABOUT_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "about".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            MoPubLog.d("Link to about page ignored.");
+        }
+    },
+
+    /* 2 */ HANDLE_PHONE_SCHEME(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return "tel".equals(scheme) || "voicemail".equals(scheme)
+                    || "sms".equals(scheme) || "mailto".equals(scheme)
+                    || "geo".equals(scheme)
+                    || "google.streetview".equals(scheme);
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Could not handle intent with URI: " + uri + "\n\tIs " +
+                    "this intent supported on your phone?";
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        }
+    },
+
+    /* 3 */ OPEN_NATIVE_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopubnativebrowser".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Unable to load mopub native browser url: " + uri;
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(uri);
+                Intents.launchIntentForUserClick(context, intent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 4 */ OPEN_APP_MARKET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+
+            return "play.google.com".equals(host) || "market.android.com".equals(host)
+                    || "market".equals(scheme)
+                    || uri.toString().startsWith("play.google.com/")
+                    || uri.toString().startsWith("market.android.com/");
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* 5 */ OPEN_IN_APP_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return (HTTP.equals(scheme) || HTTPS.equals(scheme));
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            if (!skipShowMoPubBrowser) {
+                Intents.showMoPubBrowserForUrl(context, uri);
+            }
+        }
+    },
+
+    /**
+     * This handles tweet sharing via the chooser dialog.
+     * See {@link Intents#intentForShareTweet(Uri)} for more details.
+     */
+    /* 6 */ HANDLE_SHARE_TWEET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            Preconditions.checkNotNull(uri);
+            return "mopubshare".equals(uri.getScheme()) && "tweet".equals(uri.getHost());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(uri);
+
+            final String chooserText = "Share via";
+            final String errorMessage = "Could not handle share tweet intent with URI " + uri;
+            try {
+                final Intent shareTweetIntent = Intents.intentForShareTweet(uri);
+                final Intent chooserIntent = Intent.createChooser(shareTweetIntent, chooserText);
+                Intents.launchIntentForUserClick(context, chooserIntent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 7 */ FOLLOW_DEEP_LINK(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+            return !TextUtils.isEmpty(scheme) && !TextUtils.isEmpty(host);
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* This is essentially an "unspecified" value for UrlAction. */
+    NOOP(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return false;
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException { }
+    };
+
+    public void handleUrl(
+            @NonNull final Context context,
+            @NonNull final Uri destinationUri,
+            final boolean fromUserInteraction,
+            final boolean skipShowMoPubBrowser,
+            @Nullable final MoPubSchemeListener moPubSchemeListener)
+            throws IntentNotResolvableException {
+        MoPubLog.d("Ad event URL: " + destinationUri);
+        if (mRequiresUserInteraction && !fromUserInteraction) {
+            throw new IntentNotResolvableException("Attempted to handle action without user " +
+                    "interaction.");
+        } else {
+            performAction(context, destinationUri, skipShowMoPubBrowser,
+                    moPubSchemeListener);
+        }
+    }
+
+    private final boolean mRequiresUserInteraction;
+
+    UrlAction(boolean requiresUserInteraction) {
+        mRequiresUserInteraction = requiresUserInteraction;
+    }
+
+    public abstract boolean shouldTryHandlingUrl(@NonNull final Uri uri);
+
+    protected abstract void performAction(
+            @NonNull final Context context,
+            @NonNull final Uri uri,
+            final boolean skipShowMoPubBrowser,
+            @Nullable final MoPubSchemeListener moPubSchemeListener)
+            throws IntentNotResolvableException;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
new file mode 100644
index 00000000..9d62edc1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
@@ -0,0 +1,224 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.util.EnumSet;
+
+
+/**
+ * {@code UrlHandler} facilitates handling user clicks on different URLs, allowing configuration
+ * for which kinds of URLs to handle and then responding accordingly for a given URL.
+ *
+ * This class is designed to be instantiated for a single use by immediately calling its {@link
+ * #handleUrl(Context, String)} method upon constructing it.
+ */
+public class UrlHandler {
+
+    /**
+     * {@code ClickListener} defines the methods that {@link UrlHandler} calls when handling a
+     * certain click succeeds or fails.
+     */
+    public interface ResultActions {
+        /**
+         * Called if the URL matched a supported {@link UrlAction} and was resolvable. Will be
+         * called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingFailed(String, UrlAction)}.
+         */
+        void urlHandlingSucceeded(@NonNull final String url, @NonNull final UrlAction urlAction);
+
+        /**
+         * Called with {@link UrlAction#NOOP} if the URL did not match any supported
+         * {@link UrlAction}s; or, called with the last matching {@link UrlAction} if URL was
+         * unresolvable. Will be called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingSucceeded(String, UrlAction)}.
+         */
+        void urlHandlingFailed(@NonNull final String url,
+                @NonNull final UrlAction lastFailedUrlAction);
+    }
+
+    /**
+     * {@code MoPubSchemeListener} defines the methods that {@link UrlHandler} calls when handling
+     * {@code HANDLE_MOPUB_SCHEME} URLs.
+     */
+    public interface MoPubSchemeListener {
+        void onFinishLoad();
+        void onClose();
+        void onFailLoad();
+    }
+
+    /**
+     * {@code Builder} provides an API to configure an immutable {@link UrlHandler} and create it.
+     */
+    public static class Builder {
+        @NonNull
+        private EnumSet<UrlAction> supportedUrlActions = EnumSet.of(UrlAction.NOOP);
+        @NonNull
+        private ResultActions resultActions = EMPTY_CLICK_LISTENER;
+        @NonNull
+        private MoPubSchemeListener moPubSchemeListener = EMPTY_MOPUB_SCHEME_LISTENER;
+        private boolean skipShowMoPubBrowser = false;
+
+        /**
+         * Sets the {@link UrlAction}s to support in the {@code UrlHandler} to build.
+         *
+         * @param first A {@code UrlAction} for the {@code UrlHandler} to support.
+         * @param others An arbitrary number of {@code UrlAction}s for the {@code UrlHandler} to
+         * support.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired supported
+         * {@code UrlAction}s added.
+         */
+        public Builder withSupportedUrlActions(@NonNull final UrlAction first,
+                @Nullable final UrlAction... others) {
+            this.supportedUrlActions = EnumSet.of(first, others);
+            return this;
+        }
+
+        /**
+         * Sets the {@link ResultActions} for the {@code UrlHandler} to
+         * build.
+         *
+         * @param resultActions A {@code ClickListener} for the {@code UrlHandler}.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired
+         * {@code ClickListener} added.
+         */
+        public Builder withResultActions(@NonNull final ResultActions resultActions) {
+            this.resultActions = resultActions;
+            return this;
+        }
+
+        /**
+         * Sets the {@link com.mopub.common.UrlHandler.MoPubSchemeListener} for the
+         * {@code UrlHandler} to build.
+         *
+         * @param moPubSchemeListener A {@code MoPubSchemeListener} for the {@code UrlHandler}.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired
+         * {@code MoPubSchemeListener} added.
+         */
+        public Builder withMoPubSchemeListener(
+                @NonNull final MoPubSchemeListener moPubSchemeListener) {
+            this.moPubSchemeListener = moPubSchemeListener;
+            return this;
+        }
+
+        /**
+         * If called, will avoid starting a {@link MoPubBrowser} activity where applicable.
+         * (see {@link Intents#showMoPubBrowserForUrl(Context, Uri)})
+         *
+         * @return A {@link com.mopub.common.UrlHandler.Builder} that will skip starting a
+         * {@code MoPubBrowser}.
+         */
+        public Builder withoutMoPubBrowser() {
+            this.skipShowMoPubBrowser = true;
+            return this;
+        }
+
+        /**
+         * Creates an immutable {@link UrlHandler} with the desired configuration, according to the
+         * other {@link com.mopub.common.UrlHandler.Builder} methods called before.
+         *
+         * @return An immutable {@code UrlHandler} with the desired configuration.
+         */
+        public UrlHandler build() {
+            return new UrlHandler(supportedUrlActions, resultActions, moPubSchemeListener,
+                    skipShowMoPubBrowser);
+        }
+    }
+
+    private static final ResultActions EMPTY_CLICK_LISTENER = new ResultActions() {
+        @Override
+        public void urlHandlingSucceeded(@NonNull String url, @NonNull UrlAction urlAction) { }
+        @Override
+        public void urlHandlingFailed(@NonNull String url, @NonNull UrlAction lastFailedUrlAction) { }
+    };
+
+    private static final MoPubSchemeListener EMPTY_MOPUB_SCHEME_LISTENER =
+            new MoPubSchemeListener() {
+        @Override public void onFinishLoad() { }
+
+        @Override public void onClose() { }
+
+        @Override public void onFailLoad() { }
+    };
+
+    @NonNull
+    private EnumSet<UrlAction> mSupportedUrlActions;
+    @NonNull
+    private ResultActions mResultActions;
+    @NonNull
+    private MoPubSchemeListener mMoPubSchemeListener;
+    private boolean mSkipShowMoPubBrowser;
+
+    /**
+     * Do not instantiate UrlHandler directly; use {@link com.mopub.common.UrlHandler.Builder}
+     * instead.
+     */
+    private UrlHandler(
+            @NonNull final EnumSet<UrlAction> supportedUrlActions,
+            @NonNull final ResultActions resultActions,
+            @NonNull final MoPubSchemeListener moPubSchemeListener,
+            final boolean skipShowMoPubBrowser) {
+        mResultActions = resultActions;
+        mMoPubSchemeListener = moPubSchemeListener;
+        mSkipShowMoPubBrowser = skipShowMoPubBrowser;
+        mSupportedUrlActions = supportedUrlActions;
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl) {
+        handleUrl(context, destinationUrl, true);
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     * @param fromUserInteraction Whether this handling was triggered from a user interaction.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl,
+            final boolean fromUserInteraction) {
+        UrlAction lastFailedUrlAction = UrlAction.NOOP;
+
+        if (TextUtils.isEmpty(destinationUrl)) {
+            MoPubLog.d("Attempted to handle empty url.");
+        } else {
+            final Uri destinationUri = Uri.parse(destinationUrl);
+            for (final UrlAction urlAction : mSupportedUrlActions) {
+                if (urlAction.shouldTryHandlingUrl(destinationUri)) {
+                    try {
+                        urlAction.handleUrl(context, destinationUri, fromUserInteraction,
+                                mSkipShowMoPubBrowser, mMoPubSchemeListener);
+                        if (!UrlAction.IGNORE_ABOUT_SCHEME.equals(urlAction) &&
+                                !UrlAction.HANDLE_MOPUB_SCHEME.equals(urlAction)) {
+                            mResultActions.urlHandlingSucceeded(destinationUri.toString(),
+                                    urlAction);
+                        }
+                        return;
+                    } catch (IntentNotResolvableException e) {
+                        MoPubLog.d(e.getMessage(), e);
+                        lastFailedUrlAction = urlAction;
+                        // continue trying to match...
+                    }
+                }
+            }
+            MoPubLog.d("Link ignored. Unable to handle url: " + destinationUrl);
+        }
+
+        mResultActions.urlHandlingFailed(destinationUrl, lastFailedUrlAction);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
index 4e053528..db599026 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
@@ -1,43 +1,572 @@
 package com.mopub.common.event;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class BaseEvent {
-    public enum Type {
-        NETWORK_REQUEST("request"),
-        DATA_ERROR("invalid_data");
 
-        public final String mName;
-        Type(String name) {
+    public static enum ScribeCategory {
+        EXCHANGE_CLIENT_EVENT("exchange_client_event"),
+        EXCHANGE_CLIENT_ERROR("exchange_client_error");
+
+        @NonNull private final String mScribeCategory;
+        private ScribeCategory(@NonNull String scribeCategory) {
+            mScribeCategory = scribeCategory;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mScribeCategory;
+        }
+    }
+
+    public static enum SdkProduct {
+        NONE(0),
+        WEB_VIEW(1),
+        NATIVE(2);
+
+        private final int mType;
+        private SdkProduct(int type) {
+            mType = type;
+        }
+
+        public int getType() {
+            return mType;
+        }
+    }
+
+    public static enum AppPlatform {
+        NONE(0),
+        IOS(1),
+        ANDROID(2),
+        MOBILE_WEB(3);
+
+        private final int mType;
+        private AppPlatform(int type) {
+            mType = type;
+        }
+
+        public int getType() {
+            return mType;
+        }
+    }
+
+    public enum Name {
+        AD_REQUEST("ad_request"),
+        IMPRESSION_REQUEST("impression_request"),
+        CLICK_REQUEST("click_request");
+
+        @NonNull private final String mName;
+        private Name(@NonNull String name) {
             mName = name;
         }
+
+        @NonNull
+        public String getName() {
+            return mName;
+        }
+    }
+
+    public enum Category {
+        REQUESTS("requests");
+
+        @NonNull private final String mCategory;
+        private Category(@NonNull String category) {
+            mCategory = category;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mCategory;
+        }
+    }
+
+    public enum SamplingRate {
+        AD_REQUEST(0.1);
+
+        private final double mSamplingRate;
+        private SamplingRate(double samplingRate) {
+            mSamplingRate = samplingRate;
+        }
+
+        public double getSamplingRate() {
+            return mSamplingRate;
+        }
+    }
+
+    @NonNull private final ScribeCategory mScribeCategory;
+    @NonNull private final Name mName;
+    @NonNull private final Category mCategory;
+    @Nullable private final SdkProduct mSdkProduct;
+    @Nullable private final String mAdUnitId;
+    @Nullable private final String mAdCreativeId;
+    @Nullable private final String mAdType;
+    @Nullable private final String mAdNetworkType;
+    @Nullable private final Double mAdWidthPx;
+    @Nullable private final Double mAdHeightPx;
+    @Nullable private final Integer mDeviceScreenWidthDip;
+    @Nullable private final Integer mDeviceScreenHeightDip;
+    @Nullable private final Double mGeoLat;
+    @Nullable private final Double mGeoLon;
+    @Nullable private final Double mGeoAccuracy;
+    @Nullable private final MoPubNetworkType mNetworkType;
+    @Nullable private final String mNetworkOperator;
+    @Nullable private final String mNetworkOperatorName;
+    @Nullable private final String mIsoCountryCode;
+    @Nullable private final String mSimOperator;
+    @Nullable private final String mSimOperatorName;
+    @Nullable private final String mSimIsoCountryCode;
+    @Nullable private final Double mPerformanceDurationMs;
+    @Nullable private final String mRequestId;
+    @Nullable private final Integer mRequestStatusCode;
+    @Nullable private final String mRequestUri;
+    @Nullable private final Integer mRequestRetries;
+    private final long mTimestampUtcMs;
+    @Nullable private ClientMetadata mClientMetaData;
+
+     /**
+     * The percentage of events, in range 0 - 1.0, to be logged.
+     */
+    private final double mSamplingRate;
+
+    public BaseEvent(@NonNull final Builder builder) {
+        Preconditions.checkNotNull(builder);
+
+        mScribeCategory = builder.mScribeCategory;
+        mName = builder.mName;
+        mCategory = builder.mCategory;
+        mSdkProduct = builder.mSdkProduct;
+        mAdUnitId = builder.mAdUnitId;
+        mAdCreativeId = builder.mAdCreativeId;
+        mAdType = builder.mAdType;
+        mAdNetworkType = builder.mAdNetworkType;
+        mAdWidthPx = builder.mAdWidthPx;
+        mAdHeightPx = builder.mAdHeightPx;
+        mGeoLat = builder.mGeoLat;
+        mGeoLon = builder.mGeoLon;
+        mGeoAccuracy = builder.mGeoAccuracy;
+        mPerformanceDurationMs = builder.mPerformanceDurationMs;
+        mRequestId = builder.mRequestId;
+        mRequestStatusCode = builder.mRequestStatusCode;
+        mRequestUri = builder.mRequestUri;
+        mRequestRetries = builder.mRequestRetries;
+        mSamplingRate = builder.mSamplingRate;
+        mTimestampUtcMs = System.currentTimeMillis();
+
+        mClientMetaData = ClientMetadata.getInstance();
+        if (mClientMetaData != null) {
+            mDeviceScreenWidthDip = mClientMetaData.getDeviceScreenWidthDip();
+            mDeviceScreenHeightDip = mClientMetaData.getDeviceScreenHeightDip();
+            mNetworkType = mClientMetaData.getActiveNetworkType();
+            mNetworkOperator = mClientMetaData.getNetworkOperator();
+            mNetworkOperatorName = mClientMetaData.getNetworkOperatorName();
+            mIsoCountryCode = mClientMetaData.getIsoCountryCode();
+            mSimOperator = mClientMetaData.getSimOperator();
+            mSimOperatorName = mClientMetaData.getSimOperatorName();
+            mSimIsoCountryCode = mClientMetaData.getSimIsoCountryCode();
+        } else {
+            // Need to silence warnings about variables not being initialized
+            mDeviceScreenWidthDip = null;
+            mDeviceScreenHeightDip = null;
+            mNetworkType = null;
+            mNetworkOperator = null;
+            mNetworkOperatorName = null;
+            mIsoCountryCode = null;
+            mSimOperator = null;
+            mSimOperatorName = null;
+            mSimIsoCountryCode = null;
+        }
+    }
+
+    @NonNull
+    public ScribeCategory getScribeCategory() {
+        return mScribeCategory;
+    }
+
+    @NonNull
+    public Name getName() {
+        return mName;
+    }
+
+    @NonNull
+    public Category getCategory() {
+        return mCategory;
+    }
+
+    @Nullable
+    public SdkProduct getSdkProduct() {
+        return mSdkProduct;
+    }
+
+    @Nullable
+    public String getSdkVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getSdkVersion();
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    @Nullable
+    public String getAdCreativeId() {
+        return mAdCreativeId;
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mAdType;
+    }
+
+    @Nullable
+    public String getAdNetworkType() {
+        return mAdNetworkType;
+    }
+
+    @Nullable
+    public Double getAdWidthPx() {
+        return mAdWidthPx;
+    }
+
+    @Nullable
+    public Double getAdHeightPx() {
+        return mAdHeightPx;
+    }
+
+    @Nullable
+    public AppPlatform getAppPlatform() {
+        return AppPlatform.ANDROID;
+    }
+
+    @Nullable
+    public String getAppName() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppName();
+    }
+
+    @Nullable
+    public String getAppPackageName() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppPackageName();
+    }
+
+    @Nullable
+    public String getAppVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppVersion();
+    }
+
+    @Nullable
+    public String getClientAdvertisingId() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceId();
+    }
+
+    @NonNull
+    public String getObfuscatedClientAdvertisingId() {
+        // This is a placeholder for the advertising id until we approve a plan to use the
+        // real value
+        return "ifa:XXXX";
     }
 
-    private final ClientMetadata mMetadata;
-    private final String mEventName;
-    private final String mRequestUrl;
-    private final long mEventTimeUtcMillis;
+    @NonNull
+    public Boolean getClientDoNotTrack() {
+        // Default to true if we don't have access to the client meta data
+        return mClientMetaData == null || mClientMetaData.isDoNotTrackSet();
+    }
+
+    @Nullable
+    public String getDeviceManufacturer() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceManufacturer();
+    }
+
+    @Nullable
+    public String getDeviceModel() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceModel();
+    }
+
+    @Nullable
+    public String getDeviceProduct() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceProduct();
+    }
+
+    @Nullable
+    public String getDeviceOsVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceOsVersion();
+    }
+
+    @Nullable
+    public Integer getDeviceScreenWidthDip() {
+        return mDeviceScreenWidthDip;
+    }
+
+    @Nullable
+    public Integer getDeviceScreenHeightDip() {
+        return mDeviceScreenHeightDip;
+    }
+
+    @Nullable
+    public Double getGeoLat() {
+        return mGeoLat;
+    }
+
+    @Nullable
+    public Double getGeoLon() {
+        return mGeoLon;
+    }
+
+    @Nullable
+    public Double getGeoAccuracy() {
+        return mGeoAccuracy;
+    }
+
+    @Nullable
+    public Double getPerformanceDurationMs() {
+        return mPerformanceDurationMs;
+    }
+
+    @Nullable
+    public MoPubNetworkType getNetworkType() {
+        return mNetworkType;
+    }
+
+    @Nullable
+    public String getNetworkOperatorCode() {
+        return mNetworkOperator;
+    }
+
+    @Nullable
+    public String getNetworkOperatorName() {
+        return mNetworkOperatorName;
+    }
+
+    @Nullable
+    public String getNetworkIsoCountryCode() {
+        return mIsoCountryCode;
+    }
+
+    @Nullable
+    public String getNetworkSimCode() {
+        return mSimOperator;
+    }
+
+    @Nullable
+    public String getNetworkSimOperatorName() {
+        return mSimOperatorName;
+    }
+
+    @Nullable
+    public String getNetworkSimIsoCountryCode() {
+        return mSimIsoCountryCode;
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
+    @Nullable
+    public Integer getRequestStatusCode() {
+        return mRequestStatusCode;
+    }
 
-    BaseEvent(Type eventType, String requestUrl, ClientMetadata metadata) {
-        mEventTimeUtcMillis = System.currentTimeMillis();
-        mEventName = eventType.mName;
-        mRequestUrl = requestUrl;
-        mMetadata = metadata;
+    @Nullable
+    public String getRequestUri() {
+        return mRequestUri;
     }
 
-    public long getEventTimeUtcMillis() {
-        return mEventTimeUtcMillis;
+    @Nullable
+    public Integer getRequestRetries() {
+        return mRequestRetries;
     }
 
-    public String getRequestUrl() {
-        return mRequestUrl;
+    public double getSamplingRate() {
+        return mSamplingRate;
     }
 
-    public String getEventName() {
-        return mEventName;
+    @NonNull
+    public Long getTimestampUtcMs() {
+        return mTimestampUtcMs;
     }
 
-    public ClientMetadata getMetadata() {
-        return mMetadata;
+    @Override
+    public String toString() {
+        return  "BaseEvent\n" +
+                "ScribeCategory: " + getScribeCategory() + "\n" +
+                "Name: " + getName() + "\n" +
+                "Category: " + getCategory() + "\n" +
+                "SdkProduct: " + getSdkProduct() + "\n" +
+                "SdkVersion: " + getSdkVersion() + "\n" +
+                "AdUnitId: " + getAdUnitId() + "\n" +
+                "AdCreativeId: " + getAdCreativeId() + "\n" +
+                "AdType: " + getAdType() + "\n" +
+                "AdNetworkType: " + getAdNetworkType() + "\n" +
+                "AdWidthPx: " + getAdWidthPx() + "\n" +
+                "AdHeightPx: " + getAdHeightPx() + "\n" +
+                "AppPlatform: " + getAppPlatform() + "\n" +
+                "AppName: " + getAppName() + "\n" +
+                "AppPackageName: " + getAppPackageName() + "\n" +
+                "AppVersion: " + getAppVersion() + "\n" +
+                "DeviceManufacturer: " + getDeviceManufacturer() + "\n" +
+                "DeviceModel: " + getDeviceModel() + "\n" +
+                "DeviceProduct: " + getDeviceProduct() + "\n" +
+                "DeviceOsVersion: " + getDeviceOsVersion() + "\n" +
+                "DeviceScreenWidth: " + getDeviceScreenWidthDip() + "\n" +
+                "DeviceScreenHeight: " + getDeviceScreenHeightDip() + "\n" +
+                "GeoLat: " + getGeoLat() + "\n" +
+                "GeoLon: " + getGeoLon() + "\n" +
+                "GeoAccuracy: " + getGeoAccuracy() + "\n" +
+                "PerformanceDurationMs: " + getPerformanceDurationMs() + "\n" +
+                "NetworkType: " + getNetworkType() + "\n" +
+                "NetworkOperatorCode: " + getNetworkOperatorCode() + "\n" +
+                "NetworkOperatorName: " + getNetworkOperatorName() + "\n" +
+                "NetworkIsoCountryCode: " + getNetworkIsoCountryCode() + "\n" +
+                "NetworkSimCode: " + getNetworkSimCode() + "\n" +
+                "NetworkSimOperatorName: " + getNetworkSimOperatorName() + "\n" +
+                "NetworkSimIsoCountryCode: " + getNetworkSimIsoCountryCode() + "\n" +
+                "RequestId: " + getRequestId() + "\n" +
+                "RequestStatusCode: " + getRequestStatusCode() + "\n" +
+                "RequestUri: " + getRequestUri() + "\n" +
+                "RequestRetries: " + getRequestRetries() + "\n" +
+                "SamplingRate: " + getSamplingRate() + "\n" +
+                "TimestampUtcMs: " + new SimpleDateFormat().format(new Date(getTimestampUtcMs())) + "\n";
+    }
+
+    public static abstract class Builder {
+        @NonNull private ScribeCategory mScribeCategory;
+        @NonNull private Name mName;
+        @NonNull private Category mCategory;
+        @Nullable private SdkProduct mSdkProduct;
+        @Nullable private String mAdUnitId;
+        @Nullable private String mAdCreativeId;
+        @Nullable private String mAdType;
+        @Nullable private String mAdNetworkType;
+        @Nullable private Double mAdWidthPx;
+        @Nullable private Double mAdHeightPx;
+        @Nullable private Double mGeoLat;
+        @Nullable private Double mGeoLon;
+        @Nullable private Double mGeoAccuracy;
+        @Nullable private Double mPerformanceDurationMs;
+        @Nullable private String mRequestId;
+        @Nullable private Integer mRequestStatusCode;
+        @Nullable private String mRequestUri;
+        @Nullable private Integer mRequestRetries;
+
+        /**
+         * The percentage of events, in range 0 - 1.0, to be logged.
+         */
+        private double mSamplingRate;
+
+        public Builder(@NonNull ScribeCategory scribeCategory,
+                @NonNull Name name,
+                @NonNull Category category,
+                double samplingRate) {
+            Preconditions.checkNotNull(scribeCategory);
+            Preconditions.checkNotNull(name);
+            Preconditions.checkNotNull(category);
+            Preconditions.checkArgument(samplingRate >= 0 && samplingRate <= 1.0);
+
+            mScribeCategory = scribeCategory;
+            mName = name;
+            mCategory = category;
+            mSamplingRate = samplingRate;
+        }
+
+        @NonNull
+        public Builder withSdkProduct(@Nullable SdkProduct sdkProduct) {
+            mSdkProduct = sdkProduct;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdUnitId(@Nullable String adUnitId) {
+            mAdUnitId = adUnitId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdCreativeId(@Nullable String adCreativeId) {
+            mAdCreativeId = adCreativeId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdType(@Nullable String adType) {
+            mAdType = adType;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdNetworkType(@Nullable String adNetworkType) {
+            mAdNetworkType = adNetworkType;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdWidthPx(@Nullable Double adWidthPx) {
+            mAdWidthPx = adWidthPx;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdHeightPx(@Nullable Double adHeightPx) {
+            mAdHeightPx = adHeightPx;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoLat(@Nullable Double geoLat) {
+            mGeoLat = geoLat;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoLon(@Nullable Double geoLon) {
+            mGeoLon = geoLon;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoAccuracy(@Nullable Double geoAccuracy) {
+            mGeoAccuracy = geoAccuracy;
+            return this;
+        }
+
+        @NonNull
+        public Builder withPerformanceDurationMs(@Nullable Double performanceDurationMs) {
+            mPerformanceDurationMs = performanceDurationMs;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestId(@Nullable String requestId) {
+            mRequestId = requestId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestStatusCode(@Nullable Integer requestStatusCode) {
+            mRequestStatusCode = requestStatusCode;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestUri(@Nullable String requestUri) {
+            mRequestUri = requestUri;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestRetries(@Nullable Integer requestRetries) {
+            mRequestRetries = requestRetries;
+            return this;
+        }
+
+        public abstract BaseEvent build();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
new file mode 100644
index 00000000..05a3d93f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
@@ -0,0 +1,160 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+/**
+ * Immutable data class with error event data.
+ */
+public class ErrorEvent extends BaseEvent {
+    @Nullable private final String mErrorExceptionClassName;
+    @Nullable private final String mErrorMessage;
+    @Nullable private final String mErrorStackTrace;
+    @Nullable private final String mErrorFileName;
+    @Nullable private final String mErrorClassName;
+    @Nullable private final String mErrorMethodName;
+    @Nullable private final Integer mErrorLineNumber;
+
+    private ErrorEvent(@NonNull Builder builder) {
+        super(builder);
+        mErrorExceptionClassName = builder.mErrorExceptionClassName;
+        mErrorMessage = builder.mErrorMessage;
+        mErrorStackTrace = builder.mErrorStackTrace;
+        mErrorFileName = builder.mErrorFileName;
+        mErrorClassName = builder.mErrorClassName;
+        mErrorMethodName = builder.mErrorMethodName;
+        mErrorLineNumber = builder.mErrorLineNumber;
+    }
+
+    @Nullable
+    public String getErrorExceptionClassName() {
+        return mErrorExceptionClassName;
+    }
+
+    @Nullable
+    public String getErrorMessage() {
+        return mErrorMessage;
+    }
+
+    @Nullable
+    public String getErrorStackTrace() {
+        return mErrorStackTrace;
+    }
+
+    @Nullable
+    public String getErrorFileName() {
+        return mErrorFileName;
+    }
+
+    @Nullable
+    public String getErrorClassName() {
+        return mErrorClassName;
+    }
+
+    @Nullable
+    public String getErrorMethodName() {
+        return mErrorMethodName;
+    }
+
+    @Nullable
+    public Integer getErrorLineNumber() {
+        return mErrorLineNumber;
+    }
+
+    @Override
+    public String toString() {
+        final String string = super.toString();
+        return string +
+                "ErrorEvent\n" +
+                "ErrorExceptionClassName: " + getErrorExceptionClassName() + "\n" +
+                "ErrorMessage: " + getErrorMessage() + "\n" +
+                "ErrorStackTrace: " + getErrorStackTrace() + "\n" +
+                "ErrorFileName: " + getErrorFileName() + "\n" +
+                "ErrorClassName: " + getErrorClassName() + "\n" +
+                "ErrorMethodName: " + getErrorMethodName() + "\n" +
+                "ErrorLineNumber: " + getErrorLineNumber() + "\n";
+    }
+
+    public static class Builder extends BaseEvent.Builder {
+        @Nullable private String mErrorExceptionClassName;
+        @Nullable private String mErrorMessage;
+        @Nullable private String mErrorStackTrace;
+        @Nullable private String mErrorFileName;
+        @Nullable private String mErrorClassName;
+        @Nullable private String mErrorMethodName;
+        @Nullable private Integer mErrorLineNumber;
+
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_ERROR, name, category, samplingRate);
+        }
+
+        @NonNull
+        public Builder withErrorExceptionClassName(@Nullable String errorExceptionClassName) {
+            mErrorExceptionClassName = errorExceptionClassName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorMessage(@Nullable String errorMessage) {
+            mErrorMessage = errorMessage;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorStackTrace(@Nullable String errorStackTrace) {
+            mErrorStackTrace = errorStackTrace;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorFileName(@Nullable String errorFileName) {
+            mErrorFileName = errorFileName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorClassName(@Nullable String errorClassName) {
+            mErrorClassName = errorClassName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorMethodName(@Nullable String errorMethodName) {
+            mErrorMethodName = errorMethodName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorLineNumber(@Nullable Integer errorLineNumber) {
+            mErrorLineNumber = errorLineNumber;
+            return this;
+        }
+
+        @NonNull
+        public Builder withException(@Nullable Exception exception) {
+            mErrorExceptionClassName = exception.getClass().getName();
+            mErrorMessage = exception.getMessage();
+
+            StringWriter stringWriter = new StringWriter();
+            exception.printStackTrace(new PrintWriter(stringWriter));
+            mErrorStackTrace = stringWriter.toString();
+
+            if (exception.getStackTrace().length > 0) {
+                mErrorFileName = exception.getStackTrace()[0].getFileName();
+                mErrorClassName = exception.getStackTrace()[0].getClassName();
+                mErrorMethodName = exception.getStackTrace()[0].getMethodName();
+                mErrorLineNumber = exception.getStackTrace()[0].getLineNumber();
+            }
+            return this;
+        }
+
+        @NonNull
+        @Override
+        public ErrorEvent build() {
+            return new ErrorEvent(this);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
index fee902fd..4228ab35 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
@@ -1,12 +1,24 @@
 package com.mopub.common.event;
 
-import com.mopub.common.ClientMetadata;
+import android.support.annotation.NonNull;
 
 /**
  * Immutable data class with client event data.
  */
 public class Event extends BaseEvent {
-    Event(final Type eventType, final String requestUrl, final ClientMetadata metadata) {
-        super(eventType, requestUrl, metadata);
+    private Event(@NonNull Builder builder) {
+        super(builder);
+    }
+
+    public static class Builder extends BaseEvent.Builder {
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_EVENT, name, category, samplingRate);
+        }
+
+        @NonNull
+        @Override
+        public Event build() {
+            return new Event(this);
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
new file mode 100644
index 00000000..f5ca5dbc
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
@@ -0,0 +1,49 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+public class EventDispatcher {
+    private final Iterable<EventRecorder> mEventRecorders;
+    private final Looper mLooper;
+    private final Handler mMessageHandler;
+    private final Handler.Callback mHandlerCallback;
+
+    @VisibleForTesting
+    EventDispatcher(Iterable<EventRecorder> recorders, Looper looper) {
+        mEventRecorders = recorders;
+        mLooper = looper;
+        mHandlerCallback = new Handler.Callback() {
+            @Override
+            public boolean handleMessage(final Message msg) {
+                if (msg.obj instanceof BaseEvent) {
+                    for (final EventRecorder recorder : mEventRecorders) {
+                        recorder.record((BaseEvent) msg.obj);
+                    }
+                } else {
+                    MoPubLog.d("EventDispatcher received non-BaseEvent message type.");
+                }
+                return true;
+            }
+        };
+        mMessageHandler = new Handler(mLooper, mHandlerCallback);
+    }
+
+    public void dispatch(BaseEvent event) {
+        Message.obtain(mMessageHandler, 0, event).sendToTarget();
+    }
+
+    @VisibleForTesting
+    Iterable<EventRecorder> getEventRecorders() {
+        return mEventRecorders;
+    }
+
+    @VisibleForTesting
+    Handler.Callback getHandlerCallback() {
+        return mHandlerCallback;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
index 13ed5518..efaa5515 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
@@ -4,6 +4,5 @@
  * This interface represents a backend to which MoPub client events are logged.
  */
 public interface EventRecorder {
-    public void recordEvent(Event event);
-    public void recordTimedEvent(TimedEvent event);
+    public void record(BaseEvent baseEvent);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
new file mode 100644
index 00000000..607d28d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
@@ -0,0 +1,39 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.Random;
+
+/**
+ * Samples events based on rules defined in the sample method.
+ */
+public class EventSampler {
+
+    @NonNull private Random mRandom;
+
+    public EventSampler() {
+        this(new Random());
+    }
+
+    @VisibleForTesting
+    public EventSampler(@NonNull Random random) {
+        mRandom = random;
+    }
+
+    /**
+     * Samples events based on custom rules.
+     *
+     * @param baseEvent The event to be sampled.
+     *
+     * @return Will return {@code true} if the event passed sampling and {@code false}
+     * if it is to be discarded.
+     */
+    boolean sample(@NonNull BaseEvent baseEvent) {
+        Preconditions.checkNotNull(baseEvent);
+
+        return mRandom.nextDouble() < baseEvent.getSamplingRate();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
new file mode 100644
index 00000000..94cf7c31
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.List;
+
+/**
+ * Serializes events to the data format expected by the Scribe service.
+ */
+public class EventSerializer {
+
+    /**
+     * Serializes a list of events as a JSON array of flattened JSON objects.
+     *
+     * @param events The events to be serialized.
+     *
+     * @return Will return a {@code JSONArray} of serialized {@code JSONObject}s.
+     */
+    @NonNull
+    public JSONArray serializeAsJson(@NonNull List<BaseEvent> events) {
+        Preconditions.checkNotNull(events);
+
+        JSONArray jsonArray = new JSONArray();
+        for (BaseEvent event : events) {
+            try {
+                jsonArray.put(serializeAsJson(event));
+            } catch (JSONException e) {
+                MoPubLog.d("Failed to serialize event \"" + event.getName() + "\" to JSON: ", e);
+            }
+        }
+        return jsonArray;
+    }
+
+    /**
+     * Serializes a single event as a flattened JSON object. Key values are expected by the Scribe
+     * service.
+     *
+     * @param event The event to be serialized.
+     *
+     * @return Will return a single serialized {@code JSONObject}.
+     */
+    @NonNull
+    public JSONObject serializeAsJson(@NonNull BaseEvent event) throws JSONException {
+        Preconditions.checkNotNull(event);
+
+        // Note: adding null values to the JSONObject will remove the key value pair
+        JSONObject jsonObject = new JSONObject();
+
+        // Required Scribe Request Keys
+        jsonObject.put("_category_", event.getScribeCategory().getCategory());
+        jsonObject.put("ts", event.getTimestampUtcMs());
+
+        // Name Details
+        jsonObject.put("name",  event.getName().getName());
+        jsonObject.put("name_category", event.getCategory().getCategory());
+
+        // SDK Details
+        BaseEvent.SdkProduct sdkProduct = event.getSdkProduct();
+        jsonObject.put("sdk_product", sdkProduct == null ? null : sdkProduct.getType());
+        jsonObject.put("sdk_version", event.getSdkVersion());
+
+        // Ad Details
+        jsonObject.put("ad_unit_id", event.getAdUnitId());
+        jsonObject.put("ad_creative_id", event.getAdCreativeId());
+        jsonObject.put("ad_type", event.getAdType());
+        jsonObject.put("ad_network_type", event.getAdNetworkType());
+        jsonObject.put("ad_width_px", event.getAdWidthPx());
+        jsonObject.put("ad_height_px", event.getAdHeightPx());
+
+        // App Details
+        BaseEvent.AppPlatform appPlatform = event.getAppPlatform();
+        jsonObject.put("app_platform", appPlatform == null ? null : appPlatform.getType());
+        jsonObject.put("app_name", event.getAppName());
+        jsonObject.put("app_package_name", event.getAppPackageName());
+        jsonObject.put("app_version", event.getAppVersion());
+
+        // Client Details
+        // Server side requires these values to be populated to satisfy thrift union
+        jsonObject.put("client_advertising_id", event.getObfuscatedClientAdvertisingId());
+        jsonObject.put("client_do_not_track", event.getClientDoNotTrack());
+
+        // Device Details
+        jsonObject.put("device_manufacturer", event.getDeviceManufacturer());
+        jsonObject.put("device_model", event.getDeviceModel());
+        jsonObject.put("device_product", event.getDeviceProduct());
+        jsonObject.put("device_os_version", event.getDeviceOsVersion());
+
+        // These fields will actually be the dip value until deprecated and new fields
+        // added for future releases
+        jsonObject.put("device_screen_width_px", event.getDeviceScreenWidthDip());
+        jsonObject.put("device_screen_height_px", event.getDeviceScreenHeightDip());
+
+        // Geo Details
+        jsonObject.put("geo_lat", event.getGeoLat());
+        jsonObject.put("geo_lon", event.getGeoLon());
+        jsonObject.put("geo_accuracy_radius_meters", event.getGeoAccuracy());
+
+        // Performance Details
+        jsonObject.put("perf_duration_ms", event.getPerformanceDurationMs());
+
+        // Network Details
+        ClientMetadata.MoPubNetworkType moPubNetworkType = event.getNetworkType();
+        jsonObject.put("network_type", moPubNetworkType == null ? null : moPubNetworkType.getId());
+        jsonObject.put("network_operator_code", event.getNetworkOperatorCode());
+        jsonObject.put("network_operator_name", event.getNetworkOperatorName());
+        jsonObject.put("network_iso_country_code", event.getNetworkIsoCountryCode());
+        jsonObject.put("network_sim_code", event.getNetworkSimCode());
+        jsonObject.put("network_sim_operator_name", event.getNetworkSimOperatorName());
+        jsonObject.put("network_sim_iso_country_code", event.getNetworkSimIsoCountryCode());
+
+        // Request Details
+        jsonObject.put("req_id", event.getRequestId());
+        jsonObject.put("req_status_code", event.getRequestStatusCode());
+        jsonObject.put("req_uri", event.getRequestUri());
+        jsonObject.put("req_retries", event.getRequestRetries());
+
+        // Timestamp Details
+        jsonObject.put("timestamp_client", event.getTimestampUtcMs());
+
+        if (event instanceof ErrorEvent) {
+            ErrorEvent errorEvent = (ErrorEvent) event;
+            // Error Details
+            jsonObject.put("error_exception_class_name", errorEvent.getErrorExceptionClassName());
+            jsonObject.put("error_message", errorEvent.getErrorMessage());
+            jsonObject.put("error_stack_trace", errorEvent.getErrorStackTrace());
+            jsonObject.put("error_file_name", errorEvent.getErrorFileName());
+            jsonObject.put("error_class_name", errorEvent.getErrorClassName());
+            jsonObject.put("error_method_name", errorEvent.getErrorMethodName());
+            jsonObject.put("error_line_number", errorEvent.getErrorLineNumber());
+        }
+
+        return jsonObject;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java
new file mode 100644
index 00000000..f983de70
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java
@@ -0,0 +1,11 @@
+package com.mopub.common.event;
+
+import com.mopub.common.logging.MoPubLog;
+
+class LogCatEventRecorder implements EventRecorder {
+    @Override
+    public void record(final BaseEvent baseEvent) {
+        MoPubLog.d(baseEvent.toString());
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
index a36c4f9f..3e76abff 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
@@ -1,36 +1,24 @@
 package com.mopub.common.event;
 
-import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.Message;
 
-import com.mopub.common.ClientMetadata;
 import com.mopub.common.VisibleForTesting;
 
 import java.util.ArrayList;
 
 /**
- * Records both untimed and timed events. This class maintains a queue of events to be recorded and
- * launches a background thread to handler their recording.
+ * Public interface used to record client events.
  */
 public class MoPubEvents {
 
     private static volatile EventDispatcher sEventDispatcher;
 
-    private static EventDispatcher getDispatcher() {
-        EventDispatcher result = sEventDispatcher;
-        if (result == null) {
-            synchronized (MoPubEvents.class) {
-                result = sEventDispatcher;
-                if (result == null) {
-                    ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
-                    recorders.add(new NoopEventRecorder());
-                    HandlerThread handlerThread = new HandlerThread("mopub_event_queue");
-                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread);
-                }
-            }
-        }
-        return result;
+    /**
+     * Log a BaseEvent. MoPub uses logged events to analyze and improve performance.
+     * This method should not be called by app developers.
+     */
+    public static void log(BaseEvent baseEvent) {
+        MoPubEvents.getDispatcher().dispatch(baseEvent);
     }
 
     @VisibleForTesting
@@ -39,87 +27,29 @@ public static void setEventDispatcher(EventDispatcher dispatcher) {
     }
 
     /**
-     * Log a ClientEvent. MoPub uses logged events to analyze and improve performance.
-     * This method should not be called by app developers.
+     * Returns a singleton event dispatcher constructed with a single background thread meant to be
+     * used for all event logging operations. Operations that end up on the main thread, such as
+     * the result of a network request, should post to this background thread when interacting
+     * with shared resources in order to avoid concurrency issues.
+     *
+     * This design is meant to emulate an {@code IntentService} which we can't use due to
+     * the requirement of the publisher having to update their manifest file.
      */
-    public static void event(Event.Type eventType, String requestUrl) {
-        final EventDispatcher dispatcher = MoPubEvents.getDispatcher();
-        final Event event = new Event(eventType, requestUrl, ClientMetadata.getInstance());
-        dispatcher.sendEventToHandlerThread(event);
-    }
-
-
-    /**
-     * Create and start a TimedEvent. A TimedEvent isn't recored until
-     * {@link com.mopub.common.event.TimedEvent#stop(int)} is called.
-     */
-    public static TimedEvent timedEvent(Event.Type eventType, String requestUrl) {
-        final EventDispatcher events = getDispatcher();
-        final TimedEvent event =
-                new TimedEvent(eventType, requestUrl, ClientMetadata.getInstance(), events);
-        return event;
-    }
-
-    private static class NoopEventRecorder implements EventRecorder {
-
-        @Override
-        public void recordEvent(final Event event) {
-
-        }
-
-        @Override
-        public void recordTimedEvent(final TimedEvent event) {
-
-        }
-    }
-
     @VisibleForTesting
-    public static class EventDispatcher implements TimedEvent.Listener {
-        private final Iterable<EventRecorder> mEventRecorders;
-        private final HandlerThread mHandlerThread;
-        private final Handler mMessageHandler;
-
-        @VisibleForTesting Handler.Callback mHandlerCallback;
-
-        @VisibleForTesting
-        EventDispatcher(Iterable<EventRecorder> recorders, HandlerThread handlerThread) {
-            mEventRecorders = recorders;
-            mHandlerCallback = new Handler.Callback() {
-                @Override
-                public boolean handleMessage(final Message msg) {
-                    if (msg.obj instanceof TimedEvent) {
-                        final TimedEvent event = (TimedEvent) msg.obj;
-                        for (final EventRecorder recorder : mEventRecorders) {
-                            recorder.recordTimedEvent(event);
-                        }
-
-                    } else if (msg.obj instanceof Event) {
-                        final Event event = (Event) msg.obj;
-                        for (final EventRecorder recorder : mEventRecorders) {
-                            recorder.recordEvent(event);
-                        }
-                    }
-                    return true; // Even if it's not an event, swallow the message.
+    static EventDispatcher getDispatcher() {
+        EventDispatcher result = sEventDispatcher;
+        if (result == null) {
+            synchronized (MoPubEvents.class) {
+                result = sEventDispatcher;
+                if (result == null) {
+                    ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
+                    HandlerThread handlerThread = new HandlerThread("mopub_event_logging");
+                    handlerThread.start();
+                    recorders.add(new ScribeEventRecorder(handlerThread.getLooper()));
+                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread.getLooper());
                 }
-            };
-            mHandlerThread = handlerThread;
-            mHandlerThread.start();
-            mMessageHandler = new Handler(mHandlerThread.getLooper(), mHandlerCallback);
-        }
-
-        private void sendEventToHandlerThread(BaseEvent event) {
-            final Message message = Message.obtain(mMessageHandler, 0, event);
-            message.sendToTarget();
-        }
-
-        @Override
-        public void onStopped(final TimedEvent event) {
-            this.sendEventToHandlerThread(event);
-        }
-
-        @Override
-        public void onCancelled(final TimedEvent event) {
-            // Nothing to do for now.
+            }
         }
+        return result;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java
new file mode 100644
index 00000000..5459ffbe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java
@@ -0,0 +1,8 @@
+package com.mopub.common.event;
+
+class NoopEventRecorder implements EventRecorder {
+    @Override
+    public void record(final BaseEvent baseEvent) {
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
new file mode 100644
index 00000000..96a63ae9
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+/**
+ * The ScribeEventRecorder manages events being sent to the Scribe service. It is responsible for
+ * sampling, batching and kicking off network requests. It is also responsible for ensuring batched
+ * events don't grow unbounded.
+ */
+public class ScribeEventRecorder implements EventRecorder {
+    private static final String SCRIBE_URL = "https://analytics.mopub.com/i/jot/exchange_client_event";
+    private static final int QUEUE_MAX_SIZE = 500;
+
+    /**
+     * As of SDK 3.6.0, events are roughly 1200 bytes in size. 1200 * 100 = 0.114441 MiB
+     * This threshhold must always be < 1 MiB
+     */
+    private static final int EVENT_COUNT_SEND_THRESHHOLD = 100;
+
+    /**
+     * 2 minute polling time to check for send up events
+     */
+    private static final int POLLING_PERIOD_MS = 2 * 60 * 1000;
+
+    @NonNull private final EventSampler mEventSampler;
+    @NonNull private final Queue<BaseEvent> mEventQueue;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequestManager mScribeRequestManager;
+
+    @NonNull private final Handler mPollHandler;
+    @NonNull private final PollingRunnable mPollingRunnable;
+
+    ScribeEventRecorder(@NonNull Looper looper) {
+        this(new EventSampler(),
+                new LinkedList<BaseEvent>(),
+                new EventSerializer(),
+                new ScribeRequestManager(looper),
+                new Handler(looper));
+    }
+
+    @VisibleForTesting
+    ScribeEventRecorder(@NonNull EventSampler eventSampler,
+            @NonNull Queue<BaseEvent> eventQueue,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull ScribeRequestManager scribeRequestManager,
+            @NonNull Handler handler) {
+        mEventSampler = eventSampler;
+        mEventQueue = eventQueue;
+        mEventSerializer = eventSerializer;
+        mScribeRequestManager = scribeRequestManager;
+        mPollHandler = handler;
+        mPollingRunnable = new PollingRunnable();
+    }
+
+    @Override
+    public void record(@NonNull BaseEvent baseEvent) {
+        if (!mEventSampler.sample(baseEvent)) {
+            return;
+        }
+
+        if (mEventQueue.size() >= QUEUE_MAX_SIZE) {
+            MoPubLog.d("EventQueue is at max capacity. " +
+                    "Event \"" + baseEvent.getName() + "\" is being dropped.");
+            return;
+        }
+
+        mEventQueue.add(baseEvent);
+        if (mEventQueue.size() >= EVENT_COUNT_SEND_THRESHHOLD) {
+            sendEvents();
+        }
+
+        scheduleNextPoll();
+    }
+
+    @VisibleForTesting
+    void sendEvents() {
+        if (mScribeRequestManager.isAtCapacity()) {
+            return;
+        }
+
+        final List<BaseEvent> events = dequeueEvents();
+        if (events.isEmpty()) {
+            return;
+        }
+
+        mScribeRequestManager.makeRequest(
+                new ScribeRequest.ScribeRequestFactory() {
+                    @Override
+                    public ScribeRequest createRequest(ScribeRequest.Listener listener) {
+                        return new ScribeRequest(SCRIBE_URL, events, mEventSerializer, listener);
+                    }
+                },
+                new ScribeBackoffPolicy()
+        );
+    }
+
+    @VisibleForTesting
+    @NonNull
+    List<BaseEvent> dequeueEvents() {
+        ArrayList<BaseEvent> baseEvents = new ArrayList<BaseEvent>();
+
+        // Note: Some queues do not have constant time O(1) performance for its #size()
+        // method, so we're peeking and polling instead
+        while (mEventQueue.peek() != null && baseEvents.size() < EVENT_COUNT_SEND_THRESHHOLD) {
+            baseEvents.add(mEventQueue.poll());
+        }
+        return baseEvents;
+    }
+
+    @VisibleForTesting
+    void scheduleNextPoll() {
+        // Only schedule if there are no messages already scheduled.
+        // The user defined message code, the 'what' param in Handler#hasMessages, defaults to
+        // 0 for posting a delayed runnable
+        if (mPollHandler.hasMessages(0) || mEventQueue.isEmpty()) {
+            return;
+        }
+
+        mPollHandler.postDelayed(mPollingRunnable, POLLING_PERIOD_MS);
+    }
+
+    class PollingRunnable implements Runnable {
+        @Override
+        public void run() {
+            sendEvents();
+            scheduleNextPoll();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java b/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
index 70ac4e7b..d12ea28a 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
@@ -1,12 +1,8 @@
 package com.mopub.common.logging;
 
 import android.util.Log;
-import android.util.SparseArray;
 
-import java.util.ArrayList;
-import java.util.EnumMap;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.logging.Handler;
 import java.util.logging.Level;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
index 01e6edb3..27f49bc5 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
@@ -2,6 +2,7 @@
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Locale;
 import java.util.TimeZone;
 
 public class DateAndTime {
@@ -23,7 +24,7 @@ public static Date now() {
     public static String getTimeZoneOffsetString() {
         // A new instance is created with each call because DateFormat objects have
         // internal state and are not thread safe.
-        SimpleDateFormat format = new SimpleDateFormat("Z");
+        SimpleDateFormat format = new SimpleDateFormat("Z", Locale.US);
         format.setTimeZone(localTimeZone());
         return format.format(now());
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
index 3ac25c61..8d9b34c6 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
@@ -1,14 +1,28 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
+import android.app.Activity;
 import android.app.ActivityManager;
 import android.content.Context;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.os.Build;
 import android.os.StatFs;
 import android.provider.Settings;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
 
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
 
 import org.apache.http.conn.util.InetAddressUtils;
@@ -17,11 +31,11 @@
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
+import java.util.Locale;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
 import static com.mopub.common.util.Reflection.MethodBuilder;
-
 import static com.mopub.common.util.VersionCode.HONEYCOMB;
 import static com.mopub.common.util.VersionCode.currentApiLevel;
 import static java.util.Collections.list;
@@ -33,6 +47,30 @@
 
     private DeviceUtils() {}
 
+    public static enum ForceOrientation {
+        FORCE_PORTRAIT("portrait"),
+        FORCE_LANDSCAPE("landscape"),
+        DEVICE_ORIENTATION("device"),
+        UNDEFINED("");
+
+        @NonNull private final String mKey;
+
+        private ForceOrientation(@NonNull final String key) {
+            mKey = key;
+        }
+
+        @NonNull
+        public static ForceOrientation getForceOrientation(@Nullable String key) {
+            for (final ForceOrientation orientation : ForceOrientation.values()) {
+                if (orientation.mKey.equalsIgnoreCase(key)) {
+                    return orientation;
+                }
+            }
+
+            return UNDEFINED;
+        }
+    }
+
     public static enum IP {
         IPv4,
         IPv6;
@@ -64,7 +102,7 @@ public static String getIpAddress(IP ip) throws SocketException {
         for (final NetworkInterface networkInterface : list(NetworkInterface.getNetworkInterfaces())) {
             for (final InetAddress address : list(networkInterface.getInetAddresses())) {
                 if (!address.isLoopbackAddress()) {
-                    String hostAddress = address.getHostAddress().toUpperCase();
+                    String hostAddress = address.getHostAddress().toUpperCase(Locale.US);
                     if (ip.matches(hostAddress)) {
                         return ip.toString(hostAddress);
                     }
@@ -84,11 +122,7 @@ public static String getHashedUdid(final Context context) {
         return Utils.sha1(udid);
     }
 
-    public static String getUserAgent() {
-        return System.getProperty("http.agent");
-    }
-
-    public static boolean isNetworkAvailable(final Context context) {
+    public static boolean isNetworkAvailable(@Nullable final Context context) {
         if (context == null) {
             return false;
         }
@@ -138,9 +172,8 @@ public static int memoryCacheSizeBytes(final Context context) {
         return (int) result;
     }
 
-    public static long diskCacheSizeBytes(File dir) {
-        long size = MIN_DISK_CACHE_SIZE;
-
+    public static long diskCacheSizeBytes(File dir, long minSize) {
+        long size = minSize;
         try {
             StatFs statFs = new StatFs(dir.getAbsolutePath());
             long availableBytes = ((long) statFs.getBlockCount()) * statFs.getBlockSize();
@@ -152,4 +185,126 @@ public static long diskCacheSizeBytes(File dir) {
         // Bound inside min/max size for disk cache.
         return Math.max(Math.min(size, MAX_DISK_CACHE_SIZE), MIN_DISK_CACHE_SIZE);
     }
+
+    public static long diskCacheSizeBytes(File dir) {
+        return diskCacheSizeBytes(dir, MIN_DISK_CACHE_SIZE);
+    }
+
+    public static int getScreenOrientation(@NonNull final Activity activity) {
+        final int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        return getScreenOrientationFromRotationAndOrientation(rotation, deviceOrientation);
+    }
+
+    static int getScreenOrientationFromRotationAndOrientation(int rotation, int orientation) {
+        if (Configuration.ORIENTATION_PORTRAIT == orientation) {
+            switch (rotation) {
+                case Surface.ROTATION_180:
+                case Surface.ROTATION_270:
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
+                default:
+                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (Configuration.ORIENTATION_LANDSCAPE == orientation) {
+            switch (rotation) {
+                case Surface.ROTATION_180:
+                case Surface.ROTATION_270:
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
+                default:
+                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            MoPubLog.d("Unknown screen orientation. Defaulting to portrait.");
+            return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+        }
+    }
+
+    /**
+     * Lock this activity in the requested orientation, rotating the display if necessary.
+     *
+     * @param creativeOrientation the orientation of the screen needed by the ad creative.
+     */
+    public static void lockOrientation(@NonNull Activity activity, @NonNull CreativeOrientation creativeOrientation) {
+        if (!Preconditions.NoThrow.checkNotNull(creativeOrientation) || !Preconditions.NoThrow.checkNotNull(activity)) {
+            return;
+        }
+
+        Display display = ((WindowManager) activity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        final int currentRotation = display.getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        final int currentOrientation = getScreenOrientationFromRotationAndOrientation(currentRotation, deviceOrientation);
+        int requestedOrientation;
+
+        // Choose a requested orientation that will result in the smallest change from the existing orientation.
+        if (CreativeOrientation.PORTRAIT == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (CreativeOrientation.LANDSCAPE == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            // Don't lock screen orientation if the creative doesn't care.
+            return;
+        }
+
+        activity.setRequestedOrientation(requestedOrientation);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons.
+     *
+     * @param context Needs a context (application is fine) to determine width/height.
+     * @return Width and height of the device
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    public static Point getDeviceDimensions(@NonNull final Context context) {
+        Integer bestWidthPixels = null;
+        Integer bestHeightPixels = null;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final WindowManager windowManager = (WindowManager) context.getSystemService(
+                    Context.WINDOW_SERVICE);
+            final Display display = windowManager.getDefaultDisplay();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+                final Point screenSize = new Point();
+                display.getRealSize(screenSize);
+                bestWidthPixels = screenSize.x;
+                bestHeightPixels = screenSize.y;
+            } else {
+                try {
+                    bestWidthPixels = (Integer) new MethodBuilder(display,
+                            "getRawWidth").execute();
+                    bestHeightPixels = (Integer) new MethodBuilder(display,
+                            "getRawHeight").execute();
+                } catch (Exception e) {
+                    // Best effort. If this fails, just get the height and width normally,
+                    // which may not capture the pixels used in the notification bar.
+                    MoPubLog.v("Display#getRawWidth/Height failed.", e);
+                }
+            }
+        }
+
+        if (bestWidthPixels == null || bestHeightPixels == null) {
+            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+            bestWidthPixels = displayMetrics.widthPixels;
+            bestHeightPixels = displayMetrics.heightPixels;
+        }
+
+        return new Point(bestWidthPixels, bestHeightPixels);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
index 71e2f464..bde599fa 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
@@ -1,9 +1,12 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.util.DisplayMetrics;
 import android.util.TypedValue;
 
+import com.mopub.common.Preconditions;
+
 public class Dips {
     public static float pixelsToFloatDips(final float pixels, final Context context) {
         return pixels / getDensity(context);
@@ -33,4 +36,16 @@ public static float asFloatPixels(float dips, Context context) {
     public static int asIntPixels(float dips, Context context) {
         return (int) (asFloatPixels(dips, context) + 0.5f);
     }
+
+    public static int screenWidthAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().widthPixels, context);
+    }
+
+    public static int screenHeightAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().heightPixels, context);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
index 63d32fa3..5e1b1a68 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
@@ -1,13 +1,13 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.util.Base64;
 import android.util.DisplayMetrics;
 
-import java.io.ByteArrayInputStream;
-
 public enum Drawables {
     BACKGROUND("iVBORw0KGgoAAAANSUhEUgAAAAEAAAAsCAIAAAArRUU2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEFJREFUeNpicPP0Zvr3/z/T/3//gDQQg+i//5j+gum/QBqIQXwg+x+YjckH6fkL0/f3NwMPHz8jKxsbAw0AQIABAGYHPKslk98oAAAAAElFTkSuQmCC"),
     DEFAULT_VIDEO_POSTER("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"),
@@ -19,32 +19,40 @@
     REFRESH("iVBORw0KGgoAAAANSUhEUgAAABMAAAAUCAYAAABvVQZ0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2NJREFUeNqMVF1Ik1EYPm7TpsIca84pGs6VrboYaeRPpFgXKUzBH4S8sLoIMVCpRERCAgfSZXpR2ZVJCEIgaIQm+MdCIkXRTTTnQG0qorCFm21zp+f9+IQ5NHvh4eP7vnOe877Ped5Xyv4dEYAMSK2rq/tkt9tlXq83Cu9BwC8+zyQ4B5wHLgAG4M7IyAgfHR31FhcXv8F7EXAZUADSo43SMCLKQimS0GKDTqfLys7OvlldXZ2Vnp4uy8nJuZGWlmacnp52ejyeANZ4AB/AQ4kigSQgT6/XPzebzd8pk4WFBb6+vs6xkVP4/X6+s7PDx8bGPJWVlWasTxGTOJZRInC3oaHh88zMjLDh4OCA+3w+4RkIBPhRHB4e8u3tbd7f38+rqqpM2CcJ1YhKu4Vsvq2urnKIzN1uN3c4HHxqaso1Pj7+Y3d3VyAicqfTyaHhenNzc1Eo0VF5F2traz+srKwIRFtbW3xoaMjW1tZ2X9Q12WazcZfLxefn53lXV9fbiooKjZjIsVAkJSXdIw1IFyqvt7d3pLy8PCFksXJgYIAPDg5aGxsbs8OzCY2E+vr692tra4LIFovld15eXmrYqbKmpiZzuNAnRXJ3d7eVStjc3OQo7ZXos7OC5ImjZAA1EE0nSbRarUYulzNoxeCfb/gW+A+yGEAvuoC8ZieyoFKpVEulUgYPMVy3Qyzn8IwuiYWNXl5FQB4/9r0gIf+gxG34iEVFRbH8/HwSOPakmwovMTMz81JZWZm+oKDAkJiYGENk3o2NjSVYgsXFxbHc3NxCMXX5KYRkFRU2XzEajQZUxSQSCdvb2/tJZAfLy8uDyI4pFApmMpkKNRpNJr7rxEaWiaS0NhrQAuk1NTVPoDWDiRmS2RweHrYK9aO0FPjMvb+/z3EC7+vr+6VWqx/j321xauhEsa8DJjR9NxIQDI6xxFtbW58emx4tLS0PFhcXhT4kwomJCS/67qNKparH/4fAo4yMDHNHR8c8EdDB1J8w+NRJVors7Ox8t7S0JCwkIH1utVr57Owsn5ub49RudBAdSC2HG7SVlJRoT7ssaXt7e+3k5KSLiIiQJgRFMBgUmpzIqE97enq+lJaWhrbciYwRKE+NW32GIVgcHx9/TSaTMfAxkLsx2ywge40J8zV8bP8VYACAQuluULZPjQAAAABJRU5ErkJggg=="),
     CLOSE("iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAg9JREFUeNp8kk1rWkEUhodc5aJUEbVqJQRcqCUgERottIKYQhdZSEh1pcWFSFd2HdzFhfobpOJCFLEbddONEUUQEUSDxi4KtWIq+LGQanOLFqdnJAO3peTAe+98PXPmvDMMQkgE0ikUilcajca2WCx+Q58DbUAYJARpQccmk+l8Op1CE/0inycqlcqdTCZvi8XincViCcHYEUgKYkH7oNfhcLhRKpWw1+v9AH0zMhgMh6lU6utkMsGQDddqNQo/Az0lUCQSaQyHQ7xcLnGn08GBQOCSsdlsKtB7nU7HSqVSJJfLhWaz+UWv15uPx2M2Go1eeDye51qtFgkEAgQwgvEv5Kh7wWDwZb1e/wGBt9stJv9Wq8Wl0+mb0WiEN5vNTiRrIpHI3deN/guv12vMcdyDEA3W5XKdtdvtnwTix3w+x/F4/BOsUZAkfEhI3ctms9ckEz+gJmy32/lu7/0FgRENWhM/VqsV320Ko8egE2o5rYkcj2QiEDWMwFar9QLWHxLwIBaLlfkQaWcymVwoFLL/63alUrlzOBxvGTDkyOl0Xur1+t09QRYEL+Sjz+fzQIZvYrG4qlar3TKZjBWJRLvSYPNHTL/fvzUajTOlUnlKLrdareb8fr+XvtVms/mdwDDvhqxst9v9nM/nzxgyWS6XW7DreDAYDOE+391DNHawRCK5ms1mmkKh8AY0/SPAAEsFgVbY4GziAAAAAElFTkSuQmCC"),
 
-    INTERSTITIAL_CLOSE_BUTTON_NORMAL("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"),
-    INTERSTITIAL_CLOSE_BUTTON_PRESSED("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"),
+    INTERSTITIAL_CLOSE_BUTTON_NORMAL("iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAUVBMVEUAAAD///////////////////////////////////////////////8AAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICfn5+/v7/Pz8/v7+////9QtCtmAAAADXRSTlMAECBQYHCAj5+/z9/v87rZqQAAAfxJREFUeAHslc2SgyAQhHeJ8UcZVBIJ+P4PuoWZA26t7ehySZV9DKn+GLoz+bp06dKlD5IqqqabWV1TFiqn+61m71Rdfct090rPG9KV+r99PUPVKpu9d9PImpzPg7hrNgnOGlrJWBf4UN/PXr9lh5elP2Vf/IVWnaoOX9/1tKne8RAnClXy7UeCGnmK8qj/O93wpF09wzvrM/5+IIEGDwnA3xkSyThAAO/vSCx3LIcb8IcEYZeUBv6QoJUI0CJ/TGhF+2Hpj6GDMkuX7sIHCgMd1hAkj8QNTX5fDwQbwiP5xYm6qpb9kPijceKlE8KyNZRkgDH1Z8KGf0oYBSOoXw0K8zZh4EOzbhIeoYpf6dcmawI66uMHFQRoTgDZgIOYgt5dEhYboY8tLwwYccBXxYOFnZg7jhgQgD/H3O10yOI4cfQW96iIxwYXBlfLxIMCltQTQQLwj/Lwj6fhCCAB+HMIDcx4IkzA/jTBlHkPQQL05320A8AE5C8HYALwxwCFAUyA/hjwnQ+Q4Yk+L+QsNf1pzw4NAIBhEAi6iqruP21lTCTnYIcEePih8VfBnx1/19xwuGVy0/exhQcvHx15+OXx3RcQXKF8CfQ11hdxjxI8DPE4xwMpj9Q8FPRY04NZj5Y9HN/x/kvifT9Q+InFj0Qzc52ZuW505vKqqqr6JLIRlkedBesAAAAASUVORK5CYII="),
+    INTERSTITIAL_CLOSE_BUTTON_PRESSED("iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAY1BMVEUAAAAjHyD///93cXH///9bVlZ3cXF3cXFxbGx3cXFybGx3cXF3cXFzbW13cXF3cXF0bm53cXF3cXETEhIZGBggHh4mJCQsKioyMDA5NjY/PDxFQkJSTU1eWVlkX19xa2t3cXE1H1L7AAAAE3RSTlMACBAgIDBQYHiAiI+fp7/P19/vm4QQ3gAAAg9JREFUeAHsld1ygyAUhNumahKNjoBIIhHf/ylb8cwEO2XBn5vMuJcysx/HXY8fhw4dOvRGOmV5WQ+kurxmpz3d04K8XdVFutPdczZ4xPLtcyS3AeqWbLt98bLqddeSOt2/nhcbpjgzMjFaCT6TUNrQITuvvX5FDk/F/5V6DpOqVUOkdH3dcK8aTUOsKNSFbt9yqJamuCz1n9I1Dx7Uw0xZr/HvJY+Q7AEB+mvBoyQ0IID3r3m09LIcUugPCGlk/xn0BwQW9z1U2B8Rqqj9YPsjlgKE7dI58gUZyRdLmtlLwg11vq87gklzd764qK4mdj84/mAce2mHYLdGEgDY/0vr+hPB4+8SWvsHCiTwp0Fm8BMkHYp5k3AK+fCrZm4yI8CjZnyQQwCzCQAbcEApsOCSUMgIP1ZwYVBHDb4qHswEmlpTxIAA/CnmOtAhhePE0Svco2w8FrgwuFpiPMhgSXtUeYn8rcaVd/UCSooAEKA/hVDCjDuOCdifdzBl2kOQAP1pHwUAmAD8YwGYgP0x4JsAiED+GPDpAXztCNj+it4v5F1q+tOeHVoBAMIwEBUI3kOx/7TILsB3lx3aJBd+aPpV+GfH3zU3HG6Z3vR5bOHBy0dHHn55fPcFRFcoXwJ9jfVF3KMEDkM8zvFAyiM1DwU91vRg1qNlD8c93vcDhZ9Y+Eg0WvvMzHW/zlxeKaX0AEs5cjxqSuS5AAAAAElFTkSuQmCC"),
 
     THATCHED_BACKGROUND("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");
 
     private final String encodedString;
-    private BitmapDrawable cachedImage;
+
+    // We cache a bitmap, NOT a drawable. Drawables maintain view specific properties,
+    // such as their bounds, and caching them causes problems when the same drawable is used by
+    // multiple views.
+    private Bitmap cachedBitmap;
 
     private Drawables(final String encodedString) {
         this.encodedString = encodedString;
     }
 
-    public Drawable decodeImage(final Context context) {
-        if (cachedImage == null) {
-            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
-            int scaledDensity = Dips.asIntPixels(displayMetrics.xdpi, context);
+    public Drawable createDrawable(final Context context) {
+        Bitmap bitmap = getBitmap();
+        BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
 
+        final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+        drawable.setTargetDensity(Dips.asIntPixels(displayMetrics.xdpi, context));
+        return drawable;
+    }
+
+    public Bitmap getBitmap() {
+        if (cachedBitmap == null) {
             byte[] rawImageData = Base64.decode(encodedString, Base64.DEFAULT);
-            cachedImage = new BitmapDrawable(new ByteArrayInputStream(rawImageData));
-            cachedImage.setTargetDensity(scaledDensity);
+            cachedBitmap = BitmapFactory.decodeByteArray(rawImageData, 0, rawImageData.length);
         }
-
-        return cachedImage;
+        return cachedBitmap;
     }
 
     public void clear() {
-        cachedImage = null;
+        cachedBitmap = null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
new file mode 100644
index 00000000..3fe591be
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
@@ -0,0 +1,260 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+
+public class Intents {
+
+    private Intents() {}
+
+    public static void startActivity(@NonNull final Context context, @NonNull final Intent intent)
+            throws IntentNotResolvableException {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(intent);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        try {
+            context.startActivity(intent);
+        } catch (ActivityNotFoundException e) {
+            throw new IntentNotResolvableException(e);
+        }
+    }
+
+    /**
+     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
+     * RESULT_CANCELED, so don't use it for Activity contexts.
+     */
+    public static Intent getStartActivityIntent(@NonNull final Context context,
+            @NonNull final Class clazz, @Nullable final Bundle extras) {
+        final Intent intent = new Intent(context, clazz);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        if (extras != null) {
+            intent.putExtras(extras);
+        }
+
+        return intent;
+    }
+
+    public static boolean deviceCanHandleIntent(@NonNull final Context context,
+            @NonNull final Intent intent) {
+        try {
+            final PackageManager packageManager = context.getPackageManager();
+            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
+            return !activities.isEmpty();
+        } catch (NullPointerException e) {
+            return false;
+        }
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri) {
+        return canHandleApplicationUrl(context, uri, true);
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri,
+            final boolean logError) {
+        // Determine which activities can handle the intent
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+
+        // If there are no relevant activities, don't follow the link
+        if (!Intents.deviceCanHandleIntent(context, intent)) {
+            if (logError) {
+                MoPubLog.w("Could not handle application specific action: " + uri + ". " +
+                        "You may be running in the emulator or another device which does not " +
+                        "have the required application.");
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Native Browser Scheme URLs provide a means for advertisers to include links that click out to
+     * an external browser, rather than the MoPub in-app browser. Properly formatted native browser
+     * URLs take the form of "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com".
+     *
+     * @param uri The Native Browser Scheme URL to open in the external browser.
+     * @return An Intent that will open an app-external browser taking the user to a page specified
+     * in the query parameter of the passed-in url
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForNativeBrowserScheme(@NonNull final Uri uri)
+            throws UrlParseException {
+        Preconditions.checkNotNull(uri);
+
+        if (!UrlAction.OPEN_NATIVE_BROWSER.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
+        }
+
+        if (!"navigate".equals(uri.getHost())) {
+            throw new UrlParseException("URL missing 'navigate' host parameter.");
+        }
+
+        final String urlToOpenInNativeBrowser;
+        try {
+            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        if (urlToOpenInNativeBrowser == null) {
+            throw new UrlParseException("URL missing 'url' query parameter.");
+        }
+
+        final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
+        return new Intent(Intent.ACTION_VIEW, intentUri);
+    }
+
+    /**
+     * Share Tweet URLs provide a means for advertisers on Twitter to include tweet links
+     * promoting their products that can be shared via supporting apps on the device.  Any
+     * app with a filter that matches ACTION_SEND and MIME type text/plain is capable of sharing
+     * the tweet link.
+     *
+     * Properly formatted share tweet URLs take the form of
+     * "mopubshare://tweet?screen_name=<SCREEN_NAME>&tweet_id=<TWEET_ID>"
+     *
+     * Both screen_name and tweet_id are required query parameters.  This method does not verify
+     * that their values are existent and valid on Twitter, but UrlParseException would be thrown
+     * if either is missing or empty.
+     *
+     * Example user flow:
+     * Upon clicking "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802" in an ad,
+     * a chooser dialog with message "Share via" pops up listing existing apps on the device
+     * capable of sharing this tweet link.  After the user chooses an app to share the tweet,
+     * the message Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802
+     * is ready to be shared in the chosen app.
+     *
+     * @param uri The Share Tweet URL indicating the tweet to share
+     * @return An ACTION_SEND intent that will be wrapped in a chooser intent
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForShareTweet(@NonNull final Uri uri)
+            throws UrlParseException {
+        if (!UrlAction.HANDLE_SHARE_TWEET.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubshare://tweet? format.");
+        }
+
+        final String screenName;
+        final String tweetId;
+
+        try {
+            screenName = uri.getQueryParameter("screen_name");
+            tweetId = uri.getQueryParameter("tweet_id");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        // If either query parameter is null or empty, throw UrlParseException
+        if (TextUtils.isEmpty(screenName)) {
+            throw new UrlParseException("URL missing non-empty 'screen_name' query parameter.");
+        }
+        if (TextUtils.isEmpty(tweetId)) {
+            throw new UrlParseException("URL missing non-empty 'tweet_id' query parameter.");
+        }
+
+        // Derive the tweet link on Twitter
+        final String tweetUrl = String.format("https://twitter.com/%s/status/%s", screenName, tweetId);
+
+        // Compose the share message
+        final String shareMessage = String.format("Check out @%s's Tweet: %s", screenName, tweetUrl);
+
+        // Construct share intent with the shareMessage in subject and text
+        Intent shareTweetIntent = new Intent(Intent.ACTION_SEND);
+        shareTweetIntent.setType("text/plain");
+        shareTweetIntent.putExtra(Intent.EXTRA_SUBJECT, shareMessage);
+        shareTweetIntent.putExtra(Intent.EXTRA_TEXT, shareMessage);
+
+        return shareTweetIntent;
+    }
+
+    /**
+     * Launches a {@link MoPubBrowser} activity with the desired URL.
+     *  @param context The activity context.
+     * @param uri The URL to load in the started {@link MoPubBrowser} activity.
+     */
+    public static void showMoPubBrowserForUrl(@NonNull final Context context,
+            @NonNull Uri uri) throws IntentNotResolvableException {
+        MoPubLog.d("Final URI to show in browser: " + uri);
+
+        final Bundle extras = new Bundle();
+        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, uri.toString());
+        Intent intent = getStartActivityIntent(context, MoPubBrowser.class, extras);
+
+        String errorMessage = "Could not show MoPubBrowser for url: " + uri + "\n\tPerhaps you " +
+                "forgot to declare com.mopub.common.MoPubBrowser in your Android manifest file.";
+        
+        Log.i("MOPUB_TEST", "launching mopub browser....");
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchActionViewIntent(Context context, @NonNull final Uri uri,
+            @NonNull final String errorMessage) throws IntentNotResolvableException {
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchIntentForUserClick(@NonNull final Context context,
+            @NonNull final Intent intent, @Nullable final String errorMessage)
+            throws IntentNotResolvableException {
+        Preconditions.NoThrow.checkNotNull(context);
+        Preconditions.NoThrow.checkNotNull(intent);
+
+        try {
+            Intents.startActivity(context, intent);
+        } catch (IntentNotResolvableException e) {
+            throw new IntentNotResolvableException(errorMessage + "\n" + e.getMessage());
+        }
+    }
+
+    public static void launchApplicationUrl(@NonNull final Context context,
+            @NonNull final Uri uri) throws IntentNotResolvableException {
+        if (Intents.canHandleApplicationUrl(context, uri)) {
+            final String errorMessage = "Unable to open intent for: " + uri;
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        } else {
+            throw new IntentNotResolvableException("Could not handle application specific " +
+                    "action: " + uri + "\n\tYou may be running in the emulator or another " +
+                    "device which does not have the required application.");
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Json.java b/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
index e33ac0b3..91e0e614 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
@@ -1,5 +1,7 @@
 package com.mopub.common.util;
 
+import android.text.TextUtils;
+
 import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
@@ -12,10 +14,10 @@
 import java.util.Map;
 
 public class Json {
-    public static Map<String, String> jsonStringToMap(String jsonParams) throws Exception {
+    public static Map<String, String> jsonStringToMap(String jsonParams) throws JSONException {
         Map<String, String> jsonMap = new HashMap<String, String>();
 
-        if (jsonParams == null || jsonParams.equals("")) return jsonMap;
+        if (TextUtils.isEmpty(jsonParams)) return jsonMap;
 
         JSONObject jsonObject = (JSONObject) new JSONTokener(jsonParams).nextValue();
         Iterator<?> keys = jsonObject.keys();
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
index aff7bb39..aaf7b4bf 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
@@ -1,21 +1,37 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 import android.view.Gravity;
 import android.widget.Toast;
 
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
+
 public class ManifestUtils {
     private ManifestUtils() {}
 
     private static final List<Class<? extends Activity>> REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
+    private static FlagCheckUtil sFlagCheckUtil = new FlagCheckUtil();
+
+    /**
+     * This class maintains two different lists of required Activity permissions,
+     * for the WebView and Native SDKs.
+     */
     static {
         REQUIRED_WEB_VIEW_SDK_ACTIVITIES = new ArrayList<Class<? extends Activity>>(4);
         // As a convenience, full class paths are provided here, in case the MoPub SDK was imported
@@ -32,90 +48,233 @@ private ManifestUtils() {}
         REQUIRED_NATIVE_SDK_ACTIVITIES.add(com.mopub.common.MoPubBrowser.class);
     }
 
-    public static void checkWebViewActivitiesDeclared(final Context context) {
+    public static void checkWebViewActivitiesDeclared(@NonNull final Context context) {
+        if (!Preconditions.NoThrow.checkNotNull(context, "context is not allowed to be null")) {
+            return;
+        }
+
         displayWarningForMissingActivities(context, REQUIRED_WEB_VIEW_SDK_ACTIVITIES);
+        displayWarningForMisconfiguredActivities(context, REQUIRED_WEB_VIEW_SDK_ACTIVITIES);
     }
 
-    public static void checkNativeActivitiesDeclared(final Context context) {
+    public static void checkNativeActivitiesDeclared(@NonNull final Context context) {
+        if (!Preconditions.NoThrow.checkNotNull(context, "context is not allowed to be null")) {
+            return;
+        }
+
         displayWarningForMissingActivities(context, REQUIRED_NATIVE_SDK_ACTIVITIES);
+        displayWarningForMisconfiguredActivities(context, REQUIRED_NATIVE_SDK_ACTIVITIES);
     }
 
     /**
      * This method is intended to display a warning to developers when they have accidentally
-     * omitted Activity declarations in their application's AndroidManifest. This class maintains
-     * two different lists of required Activity permissions, for the WebView and Native SDKs.
+     * omitted Activity declarations in their application's AndroidManifest.
      * Calling this when there are inadequate permissions will always Log a warning to the
      * developer, and if the the application is debuggable, it will also display a Toast.
      */
-    static void displayWarningForMissingActivities(final Context context,
-            final List<Class<? extends Activity>> requiredActivities) {
-        if (context == null) {
-            return;
-        }
+    @VisibleForTesting
+    static void displayWarningForMissingActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities) {
 
-        final List<String> undeclaredActivities = getUndeclaredActivities(context, requiredActivities);
+        final List<Class<? extends Activity>> undeclaredActivities =
+                filterDeclaredActivities(context, requiredActivities, false);
 
         if (undeclaredActivities.isEmpty()) {
             return;
         }
 
-        // If the application is debuggable, display a loud toast
-        if (isDebuggable(context)) {
-            final String message =  "ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\n" +
-                    "Check logcat and update your AndroidManifest.xml with the correct activities.";
-            final Toast toast = Toast.makeText(context, message, Toast.LENGTH_LONG);
-            toast.setGravity(Gravity.FILL_HORIZONTAL, 0, 0);
-            toast.show();
-        }
+        logWarningToast(context);
 
         // Regardless, log a warning
         logMissingActivities(undeclaredActivities);
     }
 
-    static boolean isDebuggable(final Context context) {
-        if (context == null || context.getApplicationInfo() == null) {
-            return false;
+    /**
+     * This method is intended to display a warning to developers when they have accidentally
+     * omitted configChanges values from Activity declarations in their application's AndroidManifest.
+     * Calling this when there are inadequate permissions will always Log a warning to the
+     * developer, and if the the application is debuggable, it will also display a Toast.
+     */
+    @VisibleForTesting
+    static void displayWarningForMisconfiguredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities) {
+
+        final List<Class<? extends Activity>> declaredActivities =
+                filterDeclaredActivities(context, requiredActivities, true);
+        final List<Class<? extends Activity>> misconfiguredActivities =
+                getMisconfiguredActivities(context, declaredActivities);
+
+        if (misconfiguredActivities.isEmpty()) {
+            return;
         }
 
-        final int applicationFlags = context.getApplicationInfo().flags;
+        logWarningToast(context);
+
+        // Regardless, log a warning
+        logMisconfiguredActivities(context, misconfiguredActivities);
+    }
 
+    public static boolean isDebuggable(@NonNull final Context context) {
+        final int applicationFlags = context.getApplicationInfo().flags;
         return Utils.bitMaskContainsFlag(applicationFlags, ApplicationInfo.FLAG_DEBUGGABLE);
     }
 
-    private static List<String> getUndeclaredActivities(final Context context,
-            List<Class<? extends Activity>> requiredActivities) {
-        final List<String> undeclaredActivities = new ArrayList<String>();
+    /**
+     * Filters in activities to be returned based on matching their declaration state
+     * in the Android Manifest with the isDeclared param.
+     *
+     * @param context
+     * @param requiredActivities activities to filter against
+     * @param isDeclared desired declaration state of activities in Android Manifest to be returned
+     * @return the list of filtered in activities
+     */
+    private static List<Class<? extends Activity>> filterDeclaredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities,
+            final boolean isDeclared) {
+        final List<Class<? extends Activity>> activities =
+                new ArrayList<Class<? extends Activity>>();
 
         for (final Class<? extends Activity> activityClass : requiredActivities) {
             final Intent intent = new Intent(context, activityClass);
 
-            if (!IntentUtils.deviceCanHandleIntent(context, intent)) {
-                undeclaredActivities.add(activityClass.getName());
+            if (Intents.deviceCanHandleIntent(context, intent) == isDeclared) {
+                activities.add(activityClass);
             }
         }
 
-        return undeclaredActivities;
+        return activities;
     }
 
-    private static void logMissingActivities(final List<String> undeclaredActivities) {
+    @TargetApi(13)
+    private static List<Class<? extends Activity>> getMisconfiguredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> activities) {
+        final List<Class<? extends Activity>> misconfiguredActivities =
+                new ArrayList<Class<? extends Activity>>();
+
+        for (final Class<? extends Activity> activity : activities) {
+            ActivityConfigChanges activityConfigChanges;
+            try {
+                activityConfigChanges = getActivityConfigChanges(context, activity);
+            } catch (PackageManager.NameNotFoundException e) {
+                continue;
+            }
+
+            if (!activityConfigChanges.hasKeyboardHidden || !activityConfigChanges.hasOrientation || !activityConfigChanges.hasScreenSize) {
+                misconfiguredActivities.add(activity);
+            }
+        }
+
+        return misconfiguredActivities;
+    }
+
+    private static void logMissingActivities(@NonNull final List<Class<? extends Activity>> undeclaredActivities) {
         final StringBuilder stringBuilder =
                 new StringBuilder("AndroidManifest permissions for the following required MoPub activities are missing:\n");
 
-        for (final String activity : undeclaredActivities) {
-            stringBuilder.append("\n\t").append(activity);
+        for (final Class<? extends Activity> activity : undeclaredActivities) {
+            stringBuilder.append("\n\t").append(activity.getName());
+        }
+        stringBuilder.append("\n\nPlease update your manifest to include them.");
+
+        MoPubLog.w(stringBuilder.toString());
+    }
+
+    private static void logMisconfiguredActivities(@NonNull Context context,
+            @NonNull final List<Class<? extends Activity>> misconfiguredActivities) {
+        final StringBuilder stringBuilder =
+                new StringBuilder("In AndroidManifest, the android:configChanges param is missing values for the following MoPub activities:\n");
+
+        for (final Class<? extends Activity> activity: misconfiguredActivities) {
+
+            ActivityConfigChanges activityConfigChanges;
+            try {
+                activityConfigChanges = getActivityConfigChanges(context, activity);
+            } catch (PackageManager.NameNotFoundException e) {
+                continue;
+            }
+
+            if (!activityConfigChanges.hasKeyboardHidden) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include keyboardHidden.");
+            }
+            if (!activityConfigChanges.hasOrientation) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include orientation.");
+            }
+            if (!activityConfigChanges.hasScreenSize) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include screenSize.");
+            }
         }
+
         stringBuilder.append("\n\nPlease update your manifest to include them.");
 
         MoPubLog.w(stringBuilder.toString());
     }
 
+    private static ActivityConfigChanges getActivityConfigChanges(@NonNull Context context,
+            @NonNull Class<? extends Activity> activity) throws PackageManager.NameNotFoundException {
+        ActivityInfo activityInfo;
+
+        // This line can throw NameNotFoundException but we don't expect it to happen since we
+        // should only be operating on declared activities
+        activityInfo = context.getPackageManager()
+                .getActivityInfo(new ComponentName(context, activity.getName()), 0);
+
+        ActivityConfigChanges activityConfigChanges = new ActivityConfigChanges();
+        activityConfigChanges.hasKeyboardHidden = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_KEYBOARD_HIDDEN);
+        activityConfigChanges.hasOrientation = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_ORIENTATION);
+        activityConfigChanges.hasScreenSize = true;
+
+        // For screenSize, only set to false if the API level and target API are >= 13
+        // If the target API is < 13, then Android will implement its own backwards compatibility
+        if (currentApiLevel().isAtLeast(HONEYCOMB_MR2) &&
+                context.getApplicationInfo().targetSdkVersion >= VersionCode.HONEYCOMB_MR2.getApiLevel()) {
+            activityConfigChanges.hasScreenSize = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_SCREEN_SIZE);
+        }
+
+        return activityConfigChanges;
+    }
+
+    private static void logWarningToast(@NonNull final Context context) {
+        // If the application is debuggable, display a loud toast
+        if (isDebuggable(context)) {
+            final String message = "ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\n" +
+                    "Check logcat and update your AndroidManifest.xml with the correct activities and configuration.";
+            final Toast toast = Toast.makeText(context, message, Toast.LENGTH_LONG);
+            toast.setGravity(Gravity.FILL_HORIZONTAL, 0, 0);
+            toast.show();
+        }
+    }
+
+    private static class ActivityConfigChanges {
+        public boolean hasKeyboardHidden;
+        public boolean hasOrientation;
+        public boolean hasScreenSize;
+    }
+
+    @VisibleForTesting
     @Deprecated // for testing
     static List<Class<? extends Activity>> getRequiredWebViewSdkActivities() {
         return REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
     }
 
+    @VisibleForTesting
     @Deprecated // for testing
     static List<Class<? extends Activity>> getRequiredNativeSdkActivities() {
         return REQUIRED_NATIVE_SDK_ACTIVITIES;
     }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    static void setFlagCheckUtil(final FlagCheckUtil flagCheckUtil) {
+        sFlagCheckUtil = flagCheckUtil;
+    }
+
+    static class FlagCheckUtil {
+        // We're only passing in the Class param here to ease testing and
+        // allow mocks to match on it
+        public boolean hasFlag(@SuppressWarnings("unused") Class clazz,
+                int bitMask,
+                int flag) {
+            return Utils.bitMaskContainsFlag(bitMask, flag);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java b/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java
new file mode 100644
index 00000000..a83bec24
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java
@@ -0,0 +1,15 @@
+package com.mopub.common.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class MoPubCollections {
+    public static <T> void addAllNonNull(@NonNull final Collection<? super T> c,
+            @Nullable final T... a) {
+        Collections.addAll(c, a);
+        c.removeAll(Collections.singleton(null));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
index bfb34e9a..3efa8598 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
@@ -1,5 +1,11 @@
 package com.mopub.common.util;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
@@ -88,4 +94,17 @@ public static boolean classFound(final String className) {
             return false;
         }
     }
+
+    public static <T> T instantiateClassWithEmptyConstructor(@NonNull final String className,
+            @NonNull final Class<? extends T> superclass)
+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
+            InvocationTargetException, InstantiationException, NullPointerException {
+        Preconditions.checkNotNull(className);
+
+        final Class<? extends T> clazz = Class.forName(className).asSubclass(superclass);
+        final Constructor<? extends T> constructor = clazz.getDeclaredConstructor((Class[]) null);
+        constructor.setAccessible(true);
+
+        return constructor.newInstance();
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
index 4e0987b7..6e407f85 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -3,7 +3,7 @@
 public enum ResponseHeader {
     AD_TIMEOUT("X-AdTimeout"),
     AD_TYPE("X-Adtype"),
-    CLICKTHROUGH_URL("X-Clickthrough"),
+    CLICK_TRACKING_URL("X-Clickthrough"),
     CUSTOM_EVENT_DATA("X-Custom-Event-Class-Data"),
     CUSTOM_EVENT_NAME("X-Custom-Event-Class-Name"),
     CUSTOM_EVENT_HTML_DATA("X-Custom-Event-Html-Data"),
@@ -15,6 +15,7 @@
     REDIRECT_URL("X-Launchpage"),
     NATIVE_PARAMS("X-Nativeparams"),
     NETWORK_TYPE("X-Networktype"),
+    ORIENTATION("X-Orientation"),
     REFRESH_TIME("X-Refreshtime"),
     SCROLLABLE("X-Scrollable"),
     WARMUP("X-Warmup"),
@@ -22,6 +23,7 @@
 
     LOCATION("Location"),
     USER_AGENT("User-Agent"),
+    ACCEPT_LANGUAGE("Accept-Language"),
 
     @Deprecated CUSTOM_SELECTOR("X-Customselector");
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
index dd20902e..bcb949c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
@@ -1,12 +1,19 @@
 package com.mopub.common.util;
 
+import android.text.TextUtils;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.regex.Pattern;
 
 public class Strings {
+    // Regex patterns
+    private static Pattern percentagePattern = Pattern.compile("((\\d{1,2})|(100))%");
+    private static Pattern absolutePattern = Pattern.compile("\\d{2}:\\d{2}:\\d{2}(.\\d{3})?");
+
     public static String fromStream(InputStream inputStream) throws IOException {
         int numberBytesRead = 0;
-        StringBuffer out = new StringBuffer();
+        StringBuilder out = new StringBuilder();
         byte[] bytes = new byte[4096];
 
         while (numberBytesRead != -1) {
@@ -19,11 +26,24 @@ public static String fromStream(InputStream inputStream) throws IOException {
         return out.toString();
     }
 
-    public static boolean isEmpty(String input) {
-        if (input == null) {
-            return false;
-        } else {
-            return input.length() == 0;
+    public static boolean isPercentageTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && percentagePattern.matcher(progressValue).matches();
+    }
+
+    public static boolean isAbsoluteTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && absolutePattern.matcher(progressValue).matches();
+    }
+
+    public static Integer parseAbsoluteOffset(String progressValue) {
+        final String[] split = progressValue.split(":");
+        if (split.length != 3) {
+            return null;
         }
+
+        return Integer.parseInt(split[0]) * 60 * 60 * 1000 // Hours
+                + Integer.parseInt(split[1]) * 60 * 1000 // Minutes
+                + (int)(Float.parseFloat(split[2]) * 1000);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java b/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java
new file mode 100644
index 00000000..b53c4de3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java
@@ -0,0 +1,38 @@
+package com.mopub.common.util;
+
+import java.util.concurrent.TimeUnit;
+
+public class Timer {
+    private static enum State { STARTED, STOPPED }
+    private long mStopTimeNanos;
+    private long mStartTimeNanos;
+    private State mState;
+
+    public Timer() {
+        mState = State.STOPPED;
+    }
+
+    public void start() {
+        // System.nanoTime isn't affected by changing the system time
+        mStartTimeNanos = System.nanoTime();
+        mState = State.STARTED;
+    }
+
+    public void stop() {
+        if (mState != State.STARTED) {
+            throw new IllegalStateException("EventTimer was not started.");
+        }
+        mState = State.STOPPED;
+        mStopTimeNanos = System.nanoTime();
+    }
+
+    public long getTime() {
+        long endTime;
+        if (mState == State.STARTED) {
+            endTime = System.nanoTime();
+        } else {
+            endTime = mStopTimeNanos;
+        }
+        return TimeUnit.MILLISECONDS.convert(endTime - mStartTimeNanos, TimeUnit.NANOSECONDS);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
index ae829979..c4b620de 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
@@ -1,6 +1,9 @@
 package com.mopub.common.util;
 
+import com.mopub.common.VisibleForTesting;
+
 import java.security.MessageDigest;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicLong;
 
 public class Utils {
@@ -19,7 +22,7 @@ public static String sha1(String string) {
                 stringBuilder.append(String.format("%02X", b));
             }
 
-            return stringBuilder.toString().toLowerCase();
+            return stringBuilder.toString().toLowerCase(Locale.US);
         } catch (Exception e) {
             return "";
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
new file mode 100644
index 00000000..4eb87f6f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
@@ -0,0 +1,11 @@
+package com.mopub.exceptions;
+
+public class IntentNotResolvableException extends Exception {
+    public IntentNotResolvableException(Throwable throwable) {
+        super(throwable);
+    }
+
+    public IntentNotResolvableException(String message) {
+        super(message);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java
new file mode 100644
index 00000000..cca732da
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java
@@ -0,0 +1,11 @@
+package com.mopub.exceptions;
+
+public class UrlParseException extends Exception {
+    public UrlParseException(final String detailMessage) {
+        super(detailMessage);
+    }
+
+    public UrlParseException(final Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
index 57567c9e..ced94fa6 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
@@ -1,13 +1,17 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+
 public class AdAlertGestureListener extends GestureDetector.SimpleOnGestureListener{
     private static final int MINIMUM_NUMBER_OF_ZIGZAGS_TO_FLAG = 4;
     private static final float MAXIMUM_THRESHOLD_X_IN_DIPS = 100;
-    private static final float MAXIMUM_THRESHOLD_Y_IN_DIPS = 50;
+    private static final float MAXIMUM_THRESHOLD_Y_IN_DIPS = 100;
+    @Nullable private final AdReport mAdReport;
 
     private float mCurrentThresholdInDips = MAXIMUM_THRESHOLD_X_IN_DIPS;
     private float mPreviousPositionX;
@@ -21,15 +25,14 @@
     private ZigZagState mCurrentZigZagState = ZigZagState.UNSET;
 
     private View mView;
-    private AdConfiguration mAdConfiguration;
 
-    AdAlertGestureListener(View view, AdConfiguration adConfiguration) {
+    AdAlertGestureListener(View view, @Nullable AdReport adReport) {
         super();
         if (view != null && view.getWidth() > 0) {
             mCurrentThresholdInDips = Math.min(MAXIMUM_THRESHOLD_X_IN_DIPS, view.getWidth() / 3f);
         }
         mView = view;
-        mAdConfiguration = adConfiguration;
+        mAdReport = adReport;
     }
 
     @Override
@@ -69,7 +72,7 @@ public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float d
 
     void finishGestureDetection() {
         if (mCurrentZigZagState == mCurrentZigZagState.FINISHED) {
-            mAdAlertReporter = new AdAlertReporter(mView.getContext(), mView, mAdConfiguration);
+            mAdAlertReporter = new AdAlertReporter(mView.getContext(), mView, mAdReport);
             mAdAlertReporter.send();
         }
         reset();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index 47ac6f49..ca5087ce 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -4,15 +4,21 @@
 import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.support.annotation.Nullable;
+import android.util.Base64;
 import android.view.View;
+
+import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DateAndTime;
 import com.mopub.common.util.Streams;
-import com.mopub.mobileads.util.Base64;
 
-import java.io.*;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.text.SimpleDateFormat;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Locale;
 
 public class AdAlertReporter {
     private static final String EMAIL_RECIPIENT = "creative-review@mopub.com";
@@ -28,30 +34,32 @@
 
     private final View mView;
     private final Context mContext;
-    private final AdConfiguration mAdConfiguration;
     private Intent mEmailIntent;
     private ArrayList<Uri> mEmailAttachments;
     private String mParameters;
     private String mResponse;
 
-    public AdAlertReporter(final Context context, final View view, final AdConfiguration adConfiguration) {
+    public AdAlertReporter(final Context context, final View view, @Nullable final AdReport adReport) {
         mView = view;
         mContext = context;
-        mAdConfiguration = adConfiguration;
 
         mEmailAttachments = new ArrayList<Uri>();
 
-        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
+        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
         mDateString = dateFormat.format(DateAndTime.now());
 
         initEmailIntent();
         Bitmap screenShot = takeScreenShot();
         String screenShotString = convertBitmapInWEBPToBase64EncodedString(screenShot);
-        mParameters = formParameters();
-        mResponse = getResponseString();
+        mParameters = "";
+        mResponse = "";
+        if (adReport != null) {
+            mParameters = adReport.toString();
+            mResponse = adReport.getResponseString();
+        }
 
         addEmailSubject();
-        addEmailBody( new String[]{ mParameters, mResponse, screenShotString });
+        addEmailBody(mParameters, mResponse, screenShotString);
         addTextAttachment(PARAMETERS_FILENAME, mParameters);
         addTextAttachment(MARKUP_FILENAME, mResponse);
         addImageAttachment(SCREEN_SHOT_FILENAME, screenShot);
@@ -63,13 +71,12 @@ public void send() {
         Intent chooserIntent = Intent.createChooser(mEmailIntent, "Send Email...");
         chooserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         mContext.startActivity(chooserIntent);
-
     }
 
     private void initEmailIntent() {
         Uri emailScheme = Uri.parse(EMAIL_SCHEME);
-        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE, emailScheme);
-        mEmailIntent.setType("plain/text");
+        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE);
+        mEmailIntent.setDataAndType(emailScheme, "plain/text");
         mEmailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{EMAIL_RECIPIENT});
     }
 
@@ -108,38 +115,6 @@ private String convertBitmapInWEBPToBase64EncodedString(Bitmap bitmap) {
         return result;
     }
 
-    private String formParameters() {
-        StringBuilder parameters = new StringBuilder();
-
-        if (mAdConfiguration != null) {
-            appendKeyValue(parameters, "sdk_version", mAdConfiguration.getSdkVersion());
-            appendKeyValue(parameters, "creative_id", mAdConfiguration.getDspCreativeId());
-            appendKeyValue(parameters, "platform_version", Integer.toString(mAdConfiguration.getPlatformVersion()));
-            appendKeyValue(parameters, "device_model", mAdConfiguration.getDeviceModel());
-            appendKeyValue(parameters, "ad_unit_id", mAdConfiguration.getAdUnitId());
-            appendKeyValue(parameters, "device_locale", mAdConfiguration.getDeviceLocale());
-            appendKeyValue(parameters, "device_id", mAdConfiguration.getHashedUdid());
-            appendKeyValue(parameters, "network_type", mAdConfiguration.getNetworkType());
-            appendKeyValue(parameters, "platform", mAdConfiguration.getPlatform());
-            appendKeyValue(parameters, "timestamp", getFormattedTimeStamp(mAdConfiguration.getTimeStamp()));
-            appendKeyValue(parameters, "ad_type", mAdConfiguration.getAdType());
-            appendKeyValue(parameters, "ad_size", "{" + mAdConfiguration.getWidth() + ", " + mAdConfiguration.getHeight() + "}");
-        }
-
-        return parameters.toString();
-    }
-
-    private String getResponseString() {
-        return (mAdConfiguration != null) ? mAdConfiguration.getResponseString() : "";
-    }
-
-    private void appendKeyValue(StringBuilder parameters, String key, String value) {
-        parameters.append(key);
-        parameters.append(" : ");
-        parameters.append(value);
-        parameters.append("\n");
-    }
-
     private void addEmailSubject() {
         mEmailIntent.putExtra(Intent.EXTRA_SUBJECT, "New creative violation report - " + mDateString);
     }
@@ -198,15 +173,6 @@ private void addTextAttachment(String fileName, String body) {
         }
     }
 
-    private String getFormattedTimeStamp(long timeStamp) {
-        if (timeStamp != -1) {
-            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
-            return dateFormat.format(new Date(timeStamp));
-        } else {
-            return null;
-        }
-    }
-
     @Deprecated // for testing
     Intent getEmailIntent() {
         return mEmailIntent;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java
new file mode 100644
index 00000000..3b0e073c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java
@@ -0,0 +1,72 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.AdResponse;
+
+import java.lang.ref.WeakReference;
+import java.util.Map;
+
+abstract class AdLoader {
+
+    WeakReference<AdViewController> mWeakAdViewController;
+    AdLoader(AdViewController adViewController) {
+        mWeakAdViewController = new WeakReference<AdViewController>(adViewController);
+    }
+
+    abstract void load();
+
+    @Nullable
+    static AdLoader fromAdResponse(AdResponse response, AdViewController adViewController) {
+        MoPubLog.i("Performing custom event.");
+
+        // If applicable, try to invoke the new custom event system (which uses custom classes)
+        String adTypeCustomEventName = response.getCustomEventClassName();
+        if (adTypeCustomEventName != null) {
+            Map<String, String> customEventData = response.getServerExtras();
+            return new CustomEventAdLoader(adViewController, adTypeCustomEventName, customEventData);
+        }
+
+        MoPubLog.i("Failed to create custom event.");
+        return null;
+    }
+
+    static class CustomEventAdLoader extends AdLoader {
+        private String mCustomEventClassName;
+        private Map<String,String> mServerExtras;
+
+        public CustomEventAdLoader(AdViewController adViewController,
+                String customEventCLassName,
+                Map<String, String> serverExtras) {
+            super(adViewController);
+            mCustomEventClassName = customEventCLassName;
+            mServerExtras = serverExtras;
+        }
+
+        @Override
+        void load() {
+            AdViewController adViewController = mWeakAdViewController.get();
+            if (adViewController == null
+                    || adViewController.isDestroyed()
+                    || TextUtils.isEmpty(mCustomEventClassName)) {
+                return;
+            }
+            adViewController.setNotLoading();
+
+            final MoPubView moPubView = adViewController.getMoPubView();
+            if (moPubView == null) {
+                MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
+                return;
+            }
+            moPubView.loadCustomEvent(mCustomEventClassName, mServerExtras);
+        }
+
+        @VisibleForTesting
+        Map<String, String> getServerExtras() {
+            return mServerExtras;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java
new file mode 100644
index 00000000..10d6625b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java
@@ -0,0 +1,199 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.AdRequest;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+public class AdRequestStatusMapping {
+    @NonNull
+    private final Map<String, AdRequestStatus> mAdUnitToAdRequestStatus;
+
+    public AdRequestStatusMapping() {
+        mAdUnitToAdRequestStatus = new TreeMap<String, AdRequestStatus>();
+    }
+
+    void markFail(@NonNull final String adUnitId) {
+        mAdUnitToAdRequestStatus.remove(adUnitId);
+    }
+
+    void markLoading(@NonNull final String adUnitId) {
+        mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(LoadingStatus.LOADING));
+    }
+
+    void markLoaded(
+            @NonNull final String adUnitId,
+            @Nullable final String failUrlString,
+            @Nullable final String impressionTrackerUrlString,
+            @Nullable final String clickTrackerUrlString) {
+        mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(
+                LoadingStatus.LOADED,
+                failUrlString,
+                impressionTrackerUrlString,
+                clickTrackerUrlString));
+    }
+
+    void markPlayed(@NonNull final String adUnitId) {
+        // If possible, attempt to keep the URL fields in AdRequestStatus
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            final AdRequestStatus adRequestStatus = mAdUnitToAdRequestStatus.get(adUnitId);
+            adRequestStatus.setStatus(LoadingStatus.PLAYED);
+        } else {
+            mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(LoadingStatus.PLAYED));
+        }
+    }
+
+    boolean canPlay(@NonNull final String adUnitId) {
+        final AdRequestStatus adRequestStatus = mAdUnitToAdRequestStatus.get(adUnitId);
+        return adRequestStatus != null
+            && LoadingStatus.LOADED.equals(adRequestStatus.getStatus());
+    }
+
+    boolean isLoading(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return false;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getStatus() == LoadingStatus.LOADING;
+    }
+
+    @Nullable String getFailoverUrl(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getFailurl();
+    }
+
+    @Nullable String getImpressionTrackerUrlString(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getImpressionUrl();
+    }
+
+    @Nullable String getClickTrackerUrlString(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getClickUrl();
+    }
+
+    void clearImpressionUrl(@NonNull final String adUnitId) {
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            mAdUnitToAdRequestStatus.get(adUnitId).setImpressionUrl(null);
+        }
+    }
+
+    void clearClickUrl(@NonNull final String adUnitId) {
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            mAdUnitToAdRequestStatus.get(adUnitId).setClickUrl(null);
+        }
+    }
+
+    private static enum LoadingStatus { LOADING, LOADED, PLAYED }
+    private static class AdRequestStatus {
+        @NonNull
+        private LoadingStatus mLoadingStatus;
+        @Nullable
+        private String mFailUrl;
+        @Nullable
+        private String mImpressionUrl;
+        @Nullable
+        private String mClickUrl;
+
+        public AdRequestStatus(@NonNull final LoadingStatus loadingStatus) {
+            this(loadingStatus, null, null, null);
+        }
+
+        public AdRequestStatus(
+                @NonNull final LoadingStatus loadingStatus,
+                @Nullable final String failUrl,
+                @Nullable final String impressionUrl,
+                @Nullable final String clickUrl) {
+            Preconditions.checkNotNull(loadingStatus);
+
+            mLoadingStatus = loadingStatus;
+            mFailUrl = failUrl;
+            mImpressionUrl = impressionUrl;
+            mClickUrl = clickUrl;
+        }
+
+        @NonNull
+        private LoadingStatus getStatus() {
+            return mLoadingStatus;
+        }
+
+        private void setStatus(@NonNull final LoadingStatus loadingStatus) {
+            mLoadingStatus = loadingStatus;
+        }
+
+        @Nullable
+        private String getFailurl() {
+            return mFailUrl;
+        }
+
+        @Nullable
+        private String getImpressionUrl() {
+            return mImpressionUrl;
+        }
+
+        private void setImpressionUrl(@Nullable final String impressionUrl) {
+            mImpressionUrl = impressionUrl;
+        }
+
+        @Nullable
+        private String getClickUrl() {
+            return mClickUrl;
+        }
+
+        private void setClickUrl(@Nullable final String clickUrl) {
+            mClickUrl = clickUrl;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o == null) {
+                return false;
+            }
+
+            if (this == o) {
+                return true;
+            }
+
+            if (!(o instanceof AdRequestStatus)) {
+                return false;
+            }
+
+            final AdRequestStatus that = (AdRequestStatus) o;
+
+            return this.mLoadingStatus.equals(that.mLoadingStatus) &&
+                    TextUtils.equals(this.mFailUrl, that.mFailUrl) &&
+                    TextUtils.equals(this.mImpressionUrl, that.mImpressionUrl) &&
+                    TextUtils.equals(this.mClickUrl, that.mClickUrl);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = 29;
+            result = 31 * result + mLoadingStatus.ordinal();
+            result = 31 * result + (mFailUrl != null
+                    ? mFailUrl.hashCode()
+                    : 0);
+            result = 31 * result + (mImpressionUrl != null
+                    ? mImpressionUrl.hashCode()
+                    : 0);
+            result = 31 * result + (mClickUrl != null
+                    ? mClickUrl.hashCode()
+                    : 0);
+            return result;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index 2ac1f294..f2d5e8c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -1,18 +1,31 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.util.ResponseHeader;
+
+import java.util.Map;
+
+import static com.mopub.network.HeaderUtils.extractHeader;
+
 public class AdTypeTranslator {
     public enum CustomEventType {
-        // With the deprecation of a standalone AdMob SDK, these now point to Google Play Services
+        // "Special" custom events that we let people choose in the UI.
         GOOGLE_PLAY_SERVICES_BANNER("admob_native_banner", "com.mopub.mobileads.GooglePlayServicesBanner"),
         GOOGLE_PLAY_SERVICES_INTERSTITIAL("admob_full_interstitial", "com.mopub.mobileads.GooglePlayServicesInterstitial"),
-
         MILLENNIAL_BANNER("millennial_native_banner", "com.mopub.mobileads.MillennialBanner"),
         MILLENNIAL_INTERSTITIAL("millennial_full_interstitial", "com.mopub.mobileads.MillennialInterstitial"),
-        MRAID_BANNER("mraid_banner", "com.mopub.mobileads.MraidBanner"),
-        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mobileads.MraidInterstitial"),
+
+        // MoPub-specific custom events.
+        MRAID_BANNER("mraid_banner", "com.mopub.mraid.MraidBanner"),
+        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mraid.MraidInterstitial"),
         HTML_BANNER("html_banner", "com.mopub.mobileads.HtmlBanner"),
         HTML_INTERSTITIAL("html_interstitial", "com.mopub.mobileads.HtmlInterstitial"),
         VAST_VIDEO_INTERSTITIAL("vast_interstitial", "com.mopub.mobileads.VastVideoInterstitial"),
+        MOPUB_NATIVE("mopub_native", "com.mopub.nativeads.MoPubCustomEventNative"),
 
         UNSPECIFIED("", null);
 
@@ -40,28 +53,30 @@ public String toString() {
         }
     }
 
+    public static final String BANNER_SUFFIX = "_banner";
+    public static final String INTERSTITIAL_SUFFIX = "_interstitial";
+
     static String getAdNetworkType(String adType, String fullAdType) {
-        String adNetworkType = "interstitial".equals(adType) ? fullAdType : adType;
+        String adNetworkType = AdType.INTERSTITIAL.equals(adType) ? fullAdType : adType;
         return adNetworkType != null ? adNetworkType : "unknown";
     }
 
-    static String getCustomEventNameForAdType(MoPubView moPubView, String adType, String fullAdType) {
-        CustomEventType customEventType;
-
-        if ("html".equals(adType) || "mraid".equals(adType)) {
-            customEventType = (isInterstitial(moPubView))
-                    ? CustomEventType.fromString(adType + "_interstitial")
-                    : CustomEventType.fromString(adType + "_banner");
+    public static String getCustomEventName(@NonNull AdFormat adFormat,
+            @NonNull String adType,
+            @Nullable String fullAdType,
+            @NonNull Map<String, String> headers) {
+        if (AdType.CUSTOM.equalsIgnoreCase(adType)) {
+            return extractHeader(headers, ResponseHeader.CUSTOM_EVENT_NAME);
+        } else if (AdType.NATIVE.equalsIgnoreCase(adType)){
+            return CustomEventType.MOPUB_NATIVE.toString();
+        } else if (AdType.HTML.equalsIgnoreCase(adType) || AdType.MRAID.equalsIgnoreCase(adType)) {
+            return (AdFormat.INTERSTITIAL.equals(adFormat)
+                    ? CustomEventType.fromString(adType + INTERSTITIAL_SUFFIX)
+                    : CustomEventType.fromString(adType + BANNER_SUFFIX)).toString();
+        } else if (AdType.INTERSTITIAL.equalsIgnoreCase(adType)) {
+            return CustomEventType.fromString(fullAdType + INTERSTITIAL_SUFFIX).toString();
         } else {
-            customEventType = ("interstitial".equals(adType))
-                    ? CustomEventType.fromString(fullAdType + "_interstitial")
-                    : CustomEventType.fromString(adType + "_banner");
+            return CustomEventType.fromString(adType + BANNER_SUFFIX).toString();
         }
-
-        return customEventType.toString();
-    }
-
-    private static boolean isInterstitial(MoPubView moPubView) {
-        return moPubView instanceof MoPubInterstitial.MoPubInterstitialView;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index e1d33ec6..a049e317 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -6,51 +6,75 @@
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Handler;
-import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Log;
 import android.view.Gravity;
 import android.view.View;
 import android.widget.FrameLayout;
 
-import com.mopub.common.GpsHelper;
-import com.mopub.common.MoPub;
+import com.mopub.common.AdReport;
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Dips;
-import com.mopub.mobileads.factories.AdFetcherFactory;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
-
-import java.util.*;
+import com.mopub.common.util.Utils;
+import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.WeakHashMap;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.common.GpsHelper.GpsHelperListener;
-import static com.mopub.common.LocationService.getLastKnownLocation;
 
 public class AdViewController {
-    static final int MINIMUM_REFRESH_TIME_MILLISECONDS = 10000;
-    static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;
+    static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;  // 1 minute
+    static final int MAX_REFRESH_TIME_MILLISECONDS = 600000; // 10 minutes
+    static final double BACKOFF_FACTOR = 1.5;
     private static final FrameLayout.LayoutParams WRAP_AND_CENTER_LAYOUT_PARAMS =
             new FrameLayout.LayoutParams(
                     FrameLayout.LayoutParams.WRAP_CONTENT,
                     FrameLayout.LayoutParams.WRAP_CONTENT,
                     Gravity.CENTER);
-    private static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();;
+    private final static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();
+
+    private final long mBroadcastIdentifier;
 
-    private final Context mContext;
-    private GpsHelperListener mGpsHelperListener;
+    @Nullable
+    private Context mContext;
+    @Nullable
     private MoPubView mMoPubView;
-    private final WebViewAdUrlGenerator mUrlGenerator;
-    private AdFetcher mAdFetcher;
-    private AdConfiguration mAdConfiguration;
+    @Nullable
+    private WebViewAdUrlGenerator mUrlGenerator;
+
+    @Nullable
+    private AdResponse mAdResponse;
     private final Runnable mRefreshRunnable;
+    @NonNull
+    private final AdRequest.Listener mAdListener;
 
     private boolean mIsDestroyed;
     private Handler mHandler;
     private boolean mIsLoading;
     private String mUrl;
 
+    // This is the power of the exponential term in the exponential backoff calculation.
+    @VisibleForTesting
+    int mBackoffPower = 1;
+
     private Map<String, Object> mLocalExtras = new HashMap<String, Object>();
     private boolean mAutoRefreshEnabled = true;
     private boolean mPreviousAutoRefreshSetting = true;
@@ -58,8 +82,15 @@
     private Location mLocation;
     private boolean mIsTesting;
     private boolean mAdWasLoaded;
-
-    protected static void setShouldHonorServerDimensions(View view) {
+    @Nullable
+    private String mAdUnitId;
+    private int mTimeoutMilliseconds;
+    @Nullable
+    private AdRequest mActiveRequest;
+    @Nullable
+    private Integer mRefreshTimeMillis;
+
+    public static void setShouldHonorServerDimensions(View view) {
         sViewShouldHonorServerDimensions.put(view, true);
     }
 
@@ -67,36 +98,127 @@ private static boolean getShouldHonorServerDimensions(View view) {
         return sViewShouldHonorServerDimensions.get(view) != null;
     }
 
-    public AdViewController(Context context, MoPubView view) {
+    public AdViewController(@NonNull Context context, @NonNull MoPubView view) {
         mContext = context;
         mMoPubView = view;
 
-        mUrlGenerator = new WebViewAdUrlGenerator(context);
-        mAdConfiguration = new AdConfiguration(mContext);
+        // Default timeout means "never refresh"
+        mTimeoutMilliseconds = -1;
+        mBroadcastIdentifier = Utils.generateUniqueId();
 
-        mAdFetcher = AdFetcherFactory.create(this, mAdConfiguration.getUserAgent());
+        mUrlGenerator = new WebViewAdUrlGenerator(mContext.getApplicationContext(),
+                MraidNativeCommandHandler.isStorePictureSupported(mContext));
 
-        mGpsHelperListener = new AdViewControllerGpsHelperListener();
+        mAdListener = new AdRequest.Listener() {
+            @Override
+            public void onSuccess(final AdResponse response) {
+                onAdLoadSuccess(response);
+            }
 
-        GpsHelper.fetchAdvertisingInfoAsync(mContext, null);
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                onAdLoadError(volleyError);
+            }
+        };
 
         mRefreshRunnable = new Runnable() {
             public void run() {
-                loadAd();
+                internalLoadAd();
             }
         };
+        mRefreshTimeMillis = DEFAULT_REFRESH_TIME_MILLISECONDS;
+        mHandler = new Handler();
+    }
+
+    @VisibleForTesting
+    void onAdLoadSuccess(@NonNull final AdResponse adResponse) {
+        mBackoffPower = 1;
+        mAdResponse = adResponse;
+        // Do other ad loading setup. See AdFetcher & AdLoadTask.
+        mTimeoutMilliseconds = mAdResponse.getAdTimeoutMillis() == null
+                ? mTimeoutMilliseconds
+                : mAdResponse.getAdTimeoutMillis();
+        mRefreshTimeMillis = mAdResponse.getRefreshTimeMillis();
+        setNotLoading();
 
-        mHandler = new Handler(Looper.getMainLooper());
+        // Get our custom event from the ad response and load into the view.
+        AdLoader adLoader = AdLoader.fromAdResponse(mAdResponse, this);
+        if (adLoader != null) {
+            adLoader.load();
+        }
+        scheduleRefreshTimerIfEnabled();
     }
 
+    @VisibleForTesting
+    void onAdLoadError(final VolleyError error) {
+        if (error instanceof MoPubNetworkError) {
+            // If provided, the MoPubNetworkError's refresh time takes precedence over the
+            // previously set refresh time.
+            // The only types of NetworkErrors that can possibly modify
+            // an ad's refresh time are CLEAR requests. For CLEAR requests that (erroneously) omit a
+            // refresh time header and for all other non-CLEAR types of NetworkErrors, we simply
+            // maintain the previous refresh time value.
+            final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) error;
+            if (moPubNetworkError.getRefreshTimeMillis() != null) {
+                mRefreshTimeMillis = moPubNetworkError.getRefreshTimeMillis();
+            }
+        }
+
+        final MoPubErrorCode errorCode = getErrorCodeFromVolleyError(error, mContext);
+        if (errorCode == MoPubErrorCode.SERVER_ERROR) {
+            mBackoffPower++;
+        }
+
+        setNotLoading();
+        adDidFail(errorCode);
+    }
+
+    @VisibleForTesting
+    @NonNull
+    static MoPubErrorCode getErrorCodeFromVolleyError(@NonNull final VolleyError error,
+            @Nullable final Context context) {
+        final NetworkResponse networkResponse = error.networkResponse;
+
+        // For MoPubNetworkErrors, networkResponse is null.
+        if (error instanceof MoPubNetworkError) {
+            switch (((MoPubNetworkError) error).getReason()) {
+                case WARMING_UP:
+                    return MoPubErrorCode.WARMUP;
+                case NO_FILL:
+                    return MoPubErrorCode.NO_FILL;
+                default:
+                    return MoPubErrorCode.UNSPECIFIED;
+            }
+        }
+
+        if (networkResponse == null) {
+            if (!DeviceUtils.isNetworkAvailable(context)) {
+                return MoPubErrorCode.NO_CONNECTION;
+            }
+            return MoPubErrorCode.UNSPECIFIED;
+        }
+
+        if (error.networkResponse.statusCode >= 400) {
+            return MoPubErrorCode.SERVER_ERROR;
+        }
+
+        return MoPubErrorCode.UNSPECIFIED;
+    }
+
+    @Nullable
     public MoPubView getMoPubView() {
         return mMoPubView;
     }
 
     public void loadAd() {
+        mBackoffPower = 1;
+        internalLoadAd();
+    }
+
+    private void internalLoadAd() {
         mAdWasLoaded = true;
-        if (mAdConfiguration.getAdUnitId() == null) {
-            MoPubLog.d("Can't load an ad in this ad view because the ad unit ID is null. " +
+        if (TextUtils.isEmpty(mAdUnitId)) {
+            MoPubLog.d("Can't load an ad in this ad view because the ad unit ID is not set. " +
                     "Did you forget to call setAdUnitId()?");
             return;
         }
@@ -107,16 +229,8 @@ public void loadAd() {
             return;
         }
 
-        if (mLocation == null) {
-            mLocation = getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-
-        // If we have access to Google Play Services (GPS) but the advertising info
-        // is not cached then guarantee we get it before building the ad request url
-        // in the callback, this is a requirement from Google
-        GpsHelper.fetchAdvertisingInfoAsync(mContext, mGpsHelperListener);
+        String adUrl = generateAdUrl();
+        loadNonJavascript(adUrl);
     }
 
     void loadNonJavascript(String url) {
@@ -124,14 +238,13 @@ void loadNonJavascript(String url) {
 
         MoPubLog.d("Loading url: " + url);
         if (mIsLoading) {
-            if (mAdConfiguration.getAdUnitId() != null) {
-                MoPubLog.i("Already loading an ad for " + mAdConfiguration.getAdUnitId() + ", wait to finish.");
+            if (!TextUtils.isEmpty(mAdUnitId)) {  // This shouldn't be able to happen?
+                MoPubLog.i("Already loading an ad for " + mAdUnitId + ", wait to finish.");
             }
             return;
         }
 
         mUrl = url;
-        mAdConfiguration.setFailUrl(null);
         mIsLoading = true;
 
         fetchAd(mUrl);
@@ -147,21 +260,29 @@ void loadFailUrl(MoPubErrorCode errorCode) {
 
         Log.v("MoPub", "MoPubErrorCode: " + (errorCode == null ? "" : errorCode.toString()));
 
-        if (mAdConfiguration.getFailUrl() != null) {
-            MoPubLog.d("Loading failover url: " + mAdConfiguration.getFailUrl());
-            loadNonJavascript(mAdConfiguration.getFailUrl());
+        final String failUrl = mAdResponse == null ? "" : mAdResponse.getFailoverUrl();
+        if (!TextUtils.isEmpty(failUrl)) {
+            MoPubLog.d("Loading failover url: " + failUrl);
+            loadNonJavascript(failUrl);
         } else {
             // No other URLs to try, so signal a failure.
             adDidFail(MoPubErrorCode.NO_FILL);
         }
     }
 
+    @Deprecated
     void setFailUrl(String failUrl) {
-        mAdConfiguration.setFailUrl(failUrl);
+        // Does nothing.
     }
 
     void setNotLoading() {
         this.mIsLoading = false;
+        if (mActiveRequest != null) {
+            if (!mActiveRequest.isCanceled()) {
+                mActiveRequest.cancel();
+            }
+            mActiveRequest = null;
+        }
     }
 
     public String getKeywords() {
@@ -181,37 +302,50 @@ public void setLocation(Location location) {
     }
 
     public String getAdUnitId() {
-        return mAdConfiguration.getAdUnitId();
+        return mAdUnitId;
+    }
+
+    public void setAdUnitId(@NonNull String adUnitId) {
+        mAdUnitId = adUnitId;
     }
 
-    public void setAdUnitId(String adUnitId) {
-        mAdConfiguration.setAdUnitId(adUnitId);
+    public long getBroadcastIdentifier() {
+        return mBroadcastIdentifier;
     }
 
     public void setTimeout(int milliseconds) {
-        if (mAdFetcher != null) {
-            mAdFetcher.setTimeout(milliseconds);
-        }
+       mTimeoutMilliseconds = milliseconds;
     }
 
     public int getAdWidth() {
-        return mAdConfiguration.getWidth();
+        if (mAdResponse != null && mAdResponse.getWidth() != null) {
+            return mAdResponse.getWidth();
+        }
+
+        return 0;
     }
 
     public int getAdHeight() {
-        return mAdConfiguration.getHeight();
+        if (mAdResponse != null && mAdResponse.getHeight() != null) {
+            return mAdResponse.getHeight();
+        }
+
+        return 0;
     }
 
-    public String getClickthroughUrl() {
-        return mAdConfiguration.getClickthroughUrl();
+    @Deprecated
+    public String getClickTrackingUrl() {
+        return mAdResponse == null ? null : mAdResponse.getClickTrackingUrl();
     }
 
+    @Deprecated
     public String getRedirectUrl() {
-        return mAdConfiguration.getRedirectUrl();
+        return mAdResponse == null ? null : mAdResponse.getRedirectUrl();
     }
 
+    @Deprecated
     public String getResponseString() {
-        return mAdConfiguration.getResponseString();
+        return mAdResponse == null ? null : mAdResponse.getStringBody();
     }
 
     public boolean getAutorefreshEnabled() {
@@ -236,9 +370,7 @@ private void setAutorefreshEnabled(boolean enabled) {
         final boolean autorefreshChanged = mAdWasLoaded && (mAutoRefreshEnabled != enabled);
         if (autorefreshChanged) {
             final String enabledString = (enabled) ? "enabled" : "disabled";
-            final String adUnitId = (mAdConfiguration != null) ? mAdConfiguration.getAdUnitId() : null;
-
-            MoPubLog.d("Refresh " + enabledString + " for ad unit (" + adUnitId + ").");
+            MoPubLog.d("Refresh " + enabledString + " for ad unit (" + mAdUnitId + ").");
         }
 
         mAutoRefreshEnabled = enabled;
@@ -249,6 +381,14 @@ private void setAutorefreshEnabled(boolean enabled) {
         }
     }
 
+    @Nullable
+    public AdReport getAdReport() {
+        if (mAdUnitId != null && mAdResponse != null) {
+            return new AdReport(mAdUnitId, ClientMetadata.getInstance(mContext), mAdResponse);
+        }
+        return null;
+    }
+
     public boolean getTesting() {
         return mIsTesting;
     }
@@ -257,8 +397,9 @@ public void setTesting(boolean enabled) {
         mIsTesting = enabled;
     }
 
-    AdConfiguration getAdConfiguration() {
-        return mAdConfiguration;
+    @Deprecated
+    Object getAdConfiguration() {
+        return null;
     }
 
     boolean isDestroyed() {
@@ -273,84 +414,60 @@ void cleanup() {
             return;
         }
 
+        if (mActiveRequest != null) {
+            mActiveRequest.cancel();
+            mActiveRequest = null;
+        }
+
         setAutorefreshEnabled(false);
         cancelRefreshTimer();
 
         // WebView subclasses are not garbage-collected in a timely fashion on Froyo and below,
         // thanks to some persistent references in WebViewCore. We manually release some resources
         // to compensate for this "leak".
-
-        mAdFetcher.cleanup();
-        mAdFetcher = null;
-
-        mAdConfiguration.cleanup();
-
         mMoPubView = null;
+        mContext = null;
+        mUrlGenerator = null;
 
         // Flag as destroyed. LoadUrlTask checks this before proceeding in its onPostExecute().
         mIsDestroyed = true;
     }
 
-    void configureUsingHttpResponse(final HttpResponse response) {
-        mAdConfiguration.addHttpResponse(response);
-    }
-
     Integer getAdTimeoutDelay() {
-        return mAdConfiguration.getAdTimeoutDelay();
-    }
-
-    int getRefreshTimeMilliseconds() {
-        return mAdConfiguration.getRefreshTimeMilliseconds();
-    }
-
-    @Deprecated
-    void setRefreshTimeMilliseconds(int refreshTimeMilliseconds) {
-        mAdConfiguration.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+        return mAdResponse == null ? null : mAdResponse.getAdTimeoutMillis();
     }
 
     void trackImpression() {
-        new Thread(new Runnable() {
-            public void run () {
-                if (mAdConfiguration.getImpressionUrl() == null) return;
-
-                DefaultHttpClient httpClient = HttpClientFactory.create();
-                try {
-                    HttpGet httpget = new HttpGet(mAdConfiguration.getImpressionUrl());
-                    httpget.addHeader("User-Agent", mAdConfiguration.getUserAgent());
-                    httpClient.execute(httpget);
-                } catch (Exception e) {
-                    MoPubLog.d("Impression tracking failed : " + mAdConfiguration.getImpressionUrl(), e);
-                } finally {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
+        if (mAdResponse != null) {
+            TrackingRequest.makeTrackingHttpRequest(mAdResponse.getImpressionTrackingUrl(),
+                    mContext, BaseEvent.Name.IMPRESSION_REQUEST);
+        }
     }
 
     void registerClick() {
-        new Thread(new Runnable() {
-            public void run () {
-                if (mAdConfiguration.getClickthroughUrl() == null) return;
-
-                DefaultHttpClient httpClient = HttpClientFactory.create();
-                try {
-                    MoPubLog.d("Tracking click for: " + mAdConfiguration.getClickthroughUrl());
-                    HttpGet httpget = new HttpGet(mAdConfiguration.getClickthroughUrl());
-                    httpget.addHeader("User-Agent", mAdConfiguration.getUserAgent());
-                    httpClient.execute(httpget);
-                } catch (Exception e) {
-                    MoPubLog.d("Click tracking failed: " + mAdConfiguration.getClickthroughUrl(), e);
-                } finally {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
+        if (mAdResponse != null) {
+            TrackingRequest.makeTrackingHttpRequest(mAdResponse.getClickTrackingUrl(),
+                    mContext, BaseEvent.Name.CLICK_REQUEST);
+        }
     }
 
-    void fetchAd(String mUrl) {
-        if (mAdFetcher != null) {
-            mAdFetcher.fetchAdForUrl(mUrl);
+    void fetchAd(String url) {
+        MoPubView moPubView = getMoPubView();
+        if (moPubView == null || mContext == null) {
+            MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
+            setNotLoading();
+            return;
         }
+
+        AdRequest adRequest = new AdRequest(url,
+                moPubView.getAdFormat(),
+                mAdUnitId,
+                mContext,
+                mAdListener
+        );
+        RequestQueue requestQueue = Networking.getRequestQueue(mContext);
+        requestQueue.add(adRequest);
+        mActiveRequest = adRequest;
     }
 
     void forceRefresh() {
@@ -358,50 +475,61 @@ void forceRefresh() {
         loadAd();
     }
 
+    @Nullable
     String generateAdUrl() {
-        return mUrlGenerator
-                .withAdUnitId(mAdConfiguration.getAdUnitId())
+        return mUrlGenerator == null ? null : mUrlGenerator
+                .withAdUnitId(mAdUnitId)
                 .withKeywords(mKeywords)
                 .withLocation(mLocation)
-                .generateUrlString(getServerHostname());
+                .generateUrlString(Constants.HOST);
     }
 
     void adDidFail(MoPubErrorCode errorCode) {
         MoPubLog.i("Ad failed to load.");
         setNotLoading();
+
+        MoPubView moPubView = getMoPubView();
+        if (moPubView == null) {
+            return;
+        }
+
         scheduleRefreshTimerIfEnabled();
-        getMoPubView().adFailed(errorCode);
+        moPubView.adFailed(errorCode);
     }
 
     void scheduleRefreshTimerIfEnabled() {
         cancelRefreshTimer();
-        if (mAutoRefreshEnabled && mAdConfiguration.getRefreshTimeMilliseconds() > 0) {
-            mHandler.postDelayed(mRefreshRunnable, mAdConfiguration.getRefreshTimeMilliseconds());
-        }
+        if (mAutoRefreshEnabled && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
 
+            mHandler.postDelayed(mRefreshRunnable,
+                    Math.min(MAX_REFRESH_TIME_MILLISECONDS,
+                            mRefreshTimeMillis * (long) Math.pow(BACKOFF_FACTOR, mBackoffPower)));
+        }
     }
 
     void setLocalExtras(Map<String, Object> localExtras) {
         mLocalExtras = (localExtras != null)
-                ? new HashMap<String,Object>(localExtras)
-                : new HashMap<String,Object>();
+                ? new TreeMap<String,Object>(localExtras)
+                : new TreeMap<String,Object>();
     }
 
+    /**
+     * Returns a copied map of localExtras
+     */
     Map<String, Object> getLocalExtras() {
         return (mLocalExtras != null)
-                ? new HashMap<String,Object>(mLocalExtras)
-                : new HashMap<String,Object>();
+                ? new TreeMap<String,Object>(mLocalExtras)
+                : new TreeMap<String,Object>();
     }
 
     private void cancelRefreshTimer() {
         mHandler.removeCallbacks(mRefreshRunnable);
     }
 
-    private String getServerHostname() {
-        return mIsTesting ? MoPubView.HOST_FOR_TESTING : MoPubView.HOST;
-    }
-
     private boolean isNetworkAvailable() {
+        if (mContext == null) {
+            return false;
+        }
         // If we don't have network state access, just assume the network is up.
         int result = mContext.checkCallingPermission(ACCESS_NETWORK_STATE);
         if (result == PackageManager.PERMISSION_DENIED) return true;
@@ -420,26 +548,25 @@ void setAdContentView(final View view) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
-            	MoPubView moPubView = getMoPubView();
-            	if (moPubView == null) {
-            		return;
-            	}
-            	try {
-            		moPubView.removeAllViews();
-	                moPubView.addView(view, getAdLayoutParams(view));
-            	}
-            	catch(Exception e) {
-            		moPubView.adFailed(MoPubErrorCode.INTERNAL_ERROR);
-            	}
+                MoPubView moPubView = getMoPubView();
+                if (moPubView == null) {
+                    return;
+                }
+                moPubView.removeAllViews();
+                moPubView.addView(view, getAdLayoutParams(view));
             }
         });
     }
 
     private FrameLayout.LayoutParams getAdLayoutParams(View view) {
-        int width = mAdConfiguration.getWidth();
-        int height = mAdConfiguration.getHeight();
+        Integer width = null;
+        Integer height = null;
+        if (mAdResponse != null) {
+            width = mAdResponse.getWidth();
+            height = mAdResponse.getHeight();
+        }
 
-        if (getShouldHonorServerDimensions(view) && width > 0 && height > 0) {
+        if (width != null && height != null && getShouldHonorServerDimensions(view) && width > 0 && height > 0) {
             int scaledWidth = Dips.asIntPixels(width, mContext);
             int scaledHeight = Dips.asIntPixels(height, mContext);
 
@@ -449,17 +576,16 @@ public void run() {
         }
     }
 
-    class AdViewControllerGpsHelperListener implements GpsHelperListener {
-        @Override
-        public void onFetchAdInfoCompleted() {
-            String adUrl = generateAdUrl();
-            loadNonJavascript(adUrl);
-        }
+    @Deprecated // for testing
+    @VisibleForTesting
+    Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
     }
 
-    @Deprecated
-    void setGpsHelperListener(GpsHelperListener gpsHelperListener) {
-        mGpsHelperListener = gpsHelperListener;
+    @Deprecated // for testing
+    @VisibleForTesting
+    void setRefreshTimeMillis(@Nullable final Integer refreshTimeMillis) {
+        mRefreshTimeMillis = refreshTimeMillis;
     }
 
     @Deprecated
@@ -481,7 +607,7 @@ public void customEventActionWillBegin() {
 
     @Deprecated
     public void setClickthroughUrl(String clickthroughUrl) {
-        mAdConfiguration.setClickthroughUrl(clickthroughUrl);
+        // Does nothing
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
index 6f8cea10..6af45e32 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
@@ -4,6 +4,9 @@
 import android.graphics.Color;
 import android.view.MotionEvent;
 import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
 import com.mopub.common.logging.MoPubLog;
 
 import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
@@ -14,13 +17,13 @@
     private final ViewGestureDetector mViewGestureDetector;
     private boolean mClicked;
 
-    public BaseHtmlWebView(Context context, AdConfiguration adConfiguration) {
+    public BaseHtmlWebView(Context context, AdReport adReport) {
         super(context);
 
         disableScrollingAndZoom();
         getSettings().setJavaScriptEnabled(true);
 
-        mViewGestureDetector = new ViewGestureDetector(context, this, adConfiguration);
+        mViewGestureDetector = new ViewGestureDetector(context, this, adReport);
         mViewGestureDetector.setUserClickListener(this);
 
         if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
@@ -52,7 +55,8 @@ private void disableScrollingAndZoom() {
     }
 
     void loadHtmlResponse(String htmlResponse) {
-        loadDataWithBaseURL("http://ads.mopub.com/", htmlResponse, "text/html", "utf-8", null);
+        loadDataWithBaseURL("http://" + Constants.HOST + "/", htmlResponse, "text/html", "utf-8",
+                null);
     }
 
     void initializeOnTouchListener(final boolean isScrollable) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
index 5fb5f449..1b1ddf21 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
@@ -1,50 +1,46 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.graphics.drawable.StateListDrawable;
+import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
-import android.view.View.OnClickListener;
 import android.view.Window;
 import android.view.WindowManager;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout.LayoutParams;
 
-import com.mopub.common.util.Dips;
-import com.mopub.mobileads.util.Interstitials;
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.DataKeys;
 
-import static android.view.View.INVISIBLE;
-import static android.view.View.VISIBLE;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 
 abstract class BaseInterstitialActivity extends Activity {
-    private OnClickListener mCloseOnClickListener;
+    protected AdReport mAdReport;
 
     enum JavaScriptWebViewCallbacks {
-        WEB_VIEW_DID_APPEAR("javascript:webviewDidAppear();"),
-        WEB_VIEW_DID_CLOSE("javascript:webviewDidClose();");
+        // The ad server appends these functions to the MRAID javascript to help with third party
+        // impression tracking.
+        WEB_VIEW_DID_APPEAR("webviewDidAppear();"),
+        WEB_VIEW_DID_CLOSE("webviewDidClose();");
+
+        private String mJavascript;
+        private JavaScriptWebViewCallbacks(String javascript) {
+            mJavascript = javascript;
+        }
 
-        private String mUrl;
-        private JavaScriptWebViewCallbacks(String url) {
-            mUrl = url;
+        protected String getJavascript() {
+            return mJavascript;
         }
 
         protected String getUrl() {
-            return mUrl;
+            return "javascript:" + mJavascript;
         }
     }
 
-    private static final float CLOSE_BUTTON_SIZE_DP = 50f;
-    private static final float CLOSE_BUTTON_PADDING = 8f;
-
-    private ImageView mCloseButton;
-    private RelativeLayout mLayout;
-    private int mButtonSize;
-    private int mButtonPadding;
-    private long mBroadcastIdentifier;
+    private CloseableLayout mCloseableLayout;
+    private Long mBroadcastIdentifier;
 
     public abstract View getAdView();
 
@@ -52,85 +48,60 @@ protected String getUrl() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        Intent intent = getIntent();
+        mBroadcastIdentifier = getBroadcastIdentifierFromIntent(intent);
+        mAdReport = getAdReportFromIntent(intent);
+
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        mButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE_DP, this);
-        mButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING, this);
-        mCloseOnClickListener = new OnClickListener() {
+        View adView = getAdView();
+
+        mCloseableLayout = new CloseableLayout(this);
+        mCloseableLayout.setOnCloseListener(new OnCloseListener() {
             @Override
-            public void onClick(final View view) {
+            public void onClose() {
                 finish();
             }
-        };
-
-        // The contentView needs to be a RelativeLayout so the close button can be properly aligned
-        mLayout = new RelativeLayout(this);
-        final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
-        mLayout.addView(getAdView(), adViewLayout);
-        setContentView(mLayout);
-
-        final AdConfiguration adConfiguration = getAdConfiguration();
-        if (adConfiguration != null) {
-            mBroadcastIdentifier = adConfiguration.getBroadcastIdentifier();
-        }
+        });
+        mCloseableLayout.addView(adView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        setContentView(mCloseableLayout);
+
 
-        createInterstitialCloseButton();
     }
 
     @Override
     protected void onDestroy() {
-        mLayout.removeAllViews();
+        mCloseableLayout.removeAllViews();
         super.onDestroy();
     }
 
-    long getBroadcastIdentifier() {
+    Long getBroadcastIdentifier() {
         return mBroadcastIdentifier;
     }
 
     protected void showInterstitialCloseButton() {
-        mCloseButton.setVisibility(VISIBLE);
+        mCloseableLayout.setCloseVisible(true);
     }
 
     protected void hideInterstitialCloseButton() {
-        mCloseButton.setVisibility(INVISIBLE);
+        mCloseableLayout.setCloseVisible(false);
     }
 
-    protected AdConfiguration getAdConfiguration() {
-        AdConfiguration adConfiguration;
-        try {
-            adConfiguration = (AdConfiguration) getIntent().getSerializableExtra(AD_CONFIGURATION_KEY);
-        } catch (ClassCastException e) {
-            adConfiguration = null;
+    protected static Long getBroadcastIdentifierFromIntent(Intent intent) {
+        if (intent.hasExtra(BROADCAST_IDENTIFIER_KEY)) {
+            return intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1L);
         }
-        return adConfiguration;
+        return null;
     }
 
-    void addCloseEventRegion() {
-        final int buttonSizePixels = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, this);
-        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(buttonSizePixels, buttonSizePixels);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
-        Interstitials.addCloseEventRegion(mLayout, layoutParams, mCloseOnClickListener);
-    }
-
-    private void createInterstitialCloseButton() {
-        mCloseButton = new ImageButton(this);
-        StateListDrawable states = new StateListDrawable();
-        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(this));
-        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(this));
-        mCloseButton.setImageDrawable(states);
-        mCloseButton.setBackgroundDrawable(null);
-        mCloseButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                finish();
-            }
-        });
-
-        RelativeLayout.LayoutParams buttonLayout = new RelativeLayout.LayoutParams(mButtonSize, mButtonSize);
-        buttonLayout.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
-        buttonLayout.setMargins(mButtonPadding, 0, mButtonPadding, 0);
-        mLayout.addView(mCloseButton, buttonLayout);
+    @Nullable
+    protected static AdReport getAdReportFromIntent(Intent intent) {
+        try {
+            return (AdReport) intent.getSerializableExtra(DataKeys.AD_REPORT_KEY);
+        } catch (ClassCastException e) {
+            return null;
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
index ec9ce51c..ba2482a7 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
@@ -9,15 +9,15 @@
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
 
-class BaseVideoPlayerActivity extends Activity {
+public class BaseVideoPlayerActivity extends Activity {
     static final String VIDEO_CLASS_EXTRAS_KEY = "video_view_class_name";
-    static final String VIDEO_URL = "video_url";
+    public static final String VIDEO_URL = "video_url";
 
-    static void startMraid(final Context context, final String videoUrl, final AdConfiguration adConfiguration) {
-        final Intent intentVideoPlayerActivity = createIntentMraid(context, videoUrl, adConfiguration);
+    public static void startMraid(final Context context, final String videoUrl) {
+        final Intent intentVideoPlayerActivity = createIntentMraid(context, videoUrl);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -26,20 +26,18 @@ static void startMraid(final Context context, final String videoUrl, final AdCon
     }
 
     static Intent createIntentMraid(final Context context,
-            final String videoUrl,
-            final AdConfiguration adConfiguration) {
+            final String videoUrl) {
         final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
         intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
         intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "mraid");
         intentVideoPlayerActivity.putExtra(VIDEO_URL, videoUrl);
-        intentVideoPlayerActivity.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
         return intentVideoPlayerActivity;
     }
 
     static void startVast(final Context context,
             final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
-        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfiguration, adConfiguration);
+            final long broadcastIdentifier) {
+        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfiguration, broadcastIdentifier);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -49,12 +47,12 @@ static void startVast(final Context context,
 
     static Intent createIntentVast(final Context context,
             final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
+            final long broadcastIdentifier) {
         final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
         intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
         intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "vast");
         intentVideoPlayerActivity.putExtra(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-        intentVideoPlayerActivity.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intentVideoPlayerActivity.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         return intentVideoPlayerActivity;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
index 195b1612..d9ab5587 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
@@ -4,22 +4,23 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.logging.MoPubLog;
 
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 
-abstract class BaseVideoViewController {
+public abstract class BaseVideoViewController {
     private final Context mContext;
     private final RelativeLayout mLayout;
     private final BaseVideoViewControllerListener mBaseVideoViewControllerListener;
-    private long mBroadcastIdentifier;
+    @Nullable private Long mBroadcastIdentifier;
 
-    interface BaseVideoViewControllerListener {
+    public interface BaseVideoViewControllerListener {
         void onSetContentView(final View view);
         void onSetRequestedOrientation(final int requestedOrientation);
         void onFinish();
@@ -28,14 +29,14 @@ void onStartActivityForResult(final Class<? extends Activity> clazz,
                 final Bundle extras);
     }
 
-    BaseVideoViewController(final Context context, final long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+    protected BaseVideoViewController(final Context context, @Nullable final Long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
         mContext = context.getApplicationContext();
         mBroadcastIdentifier = broadcastIdentifier;
         mBaseVideoViewControllerListener = baseVideoViewControllerListener;
         mLayout = new RelativeLayout(mContext);
     }
 
-     void onCreate() {
+     protected void onCreate() {
         final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
                 RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
         adViewLayout.addRule(RelativeLayout.CENTER_IN_PARENT);
@@ -43,12 +44,12 @@ void onCreate() {
         mBaseVideoViewControllerListener.onSetContentView(mLayout);
     }
 
-    abstract VideoView getVideoView();
-    abstract void onPause();
-    abstract void onResume();
-    abstract void onDestroy();
+    protected abstract VideoView getVideoView();
+    protected abstract void onPause();
+    protected abstract void onResume();
+    protected abstract void onDestroy();
 
-    boolean backButtonEnabled() {
+    public boolean backButtonEnabled() {
         return true;
     }
 
@@ -56,38 +57,37 @@ void onActivityResult(final int requestCode, final int resultCode, final Intent
         // By default, the activity result is ignored
     }
 
-    BaseVideoViewControllerListener getBaseVideoViewControllerListener() {
+    protected BaseVideoViewControllerListener getBaseVideoViewControllerListener() {
         return mBaseVideoViewControllerListener;
     }
 
-    Context getContext() {
+    protected Context getContext() {
         return mContext;
     }
 
-    ViewGroup getLayout() {
+    public ViewGroup getLayout() {
         return mLayout;
     }
 
-
-    void videoError(boolean shouldFinish) {
-        MoPubLog.d("Error: video can not be played.");
+    protected void videoError(boolean shouldFinish) {
+        MoPubLog.e("Video cannot be played.");
         broadcastAction(ACTION_INTERSTITIAL_FAIL);
         if (shouldFinish) {
            mBaseVideoViewControllerListener.onFinish();
         }
     }
 
-    void videoCompleted(boolean shouldFinish) {
+    protected void videoCompleted(boolean shouldFinish) {
         if (shouldFinish) {
             mBaseVideoViewControllerListener.onFinish();
         }
     }
 
-    void videoClicked() {
-        broadcastAction(ACTION_INTERSTITIAL_CLICK);
-    }
-
     void broadcastAction(final String action) {
-        EventForwardingBroadcastReceiver.broadcastAction(mContext, mBroadcastIdentifier, action);
+        if (mBroadcastIdentifier != null) {
+            EventForwardingBroadcastReceiver.broadcastAction(mContext, mBroadcastIdentifier, action);
+        } else {
+            MoPubLog.w("Tried to broadcast a video event without a braodcast identifier to send to.");
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
index c9f633be..a9331a31 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
@@ -1,6 +1,13 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.graphics.Color;
+import android.graphics.PixelFormat;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
+import android.view.Gravity;
+import android.view.WindowManager;
 import android.webkit.WebSettings;
 import android.webkit.WebView;
 
@@ -9,6 +16,7 @@
 import com.mopub.mobileads.util.WebViews;
 
 public class BaseWebView extends WebView {
+    private static boolean sDeadlockCleared = false;
     protected boolean mIsDestroyed;
 
     public BaseWebView(Context context) {
@@ -20,6 +28,11 @@ public BaseWebView(Context context) {
         enablePlugins(false);
 
         WebViews.setDisableJSChromeClient(this);
+
+        if (!sDeadlockCleared) {
+            clearWebViewDeadlock(getContext());
+            sDeadlockCleared = true;
+        }
     }
 
     protected void enablePlugins(final boolean enabled) {
@@ -39,7 +52,13 @@ protected void enablePlugins(final boolean enabled) {
     public void destroy() {
         mIsDestroyed = true;
 
+        // Needed to prevent receiving the following error on Android versions using WebViewClassic
+        // https://code.google.com/p/android/issues/detail?id=65833.
         Views.removeFromParent(this);
+
+        // Even after removing from the parent, WebViewClassic can leak because of a static
+        // reference from HTML5VideoViewProcessor. Removing children fixes this problem.
+        removeAllViews();
         super.destroy();
     }
 
@@ -47,4 +66,43 @@ public void destroy() {
     void setIsDestroyed(boolean isDestroyed) {
         mIsDestroyed = isDestroyed;
     }
+
+    /**
+     * This fixes https://code.google.com/p/android/issues/detail?id=63754,
+     * which occurs on KitKat devices. When a WebView containing an HTML5 video is
+     * is destroyed it can deadlock the WebView thread until another hardware accelerated WebView
+     * is added to the view hierarchy and restores the GL context. Since we need to use WebView
+     * before adding it to the view hierarchy, this method clears the deadlock by adding a
+     * separate invisible WebView.
+     *
+     * This potential deadlock must be cleared anytime you attempt to access a WebView that
+     * is not added to the view hierarchy.
+     */
+    private void clearWebViewDeadlock(@NonNull final Context context) {
+        if (VERSION.SDK_INT == VERSION_CODES.KITKAT) {
+            // Create an invisible webview
+            final WebView webView = new WebView(context.getApplicationContext());
+            webView.setBackgroundColor(Color.TRANSPARENT);
+
+            // For the deadlock to be cleared, we must load content and add to the view hierarchy. Since
+            // we don't have an activity context, we'll use a system window.
+            webView.loadDataWithBaseURL(null, "", "text/html", "UTF-8", null);
+            final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
+            params.width = 1;
+            params.height = 1;
+            // Unlike other system window types TYPE_TOAST doesn't require extra permissions
+            params.type = WindowManager.LayoutParams.TYPE_TOAST;
+            params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                    | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
+                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
+            params.format = PixelFormat.TRANSPARENT;
+            params.gravity = Gravity.START | Gravity.TOP;
+            final WindowManager windowManager =
+                    (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+
+            windowManager.addView(webView, params);
+        }
+    }
+
+
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
index 5cdad507..bd9abaad 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
@@ -2,23 +2,30 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
 import com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.AD_HEIGHT;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.AD_WIDTH;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 public class CustomEventBannerAdapter implements CustomEventBannerListener {
-    public static final int DEFAULT_BANNER_TIMEOUT_DELAY = 10000;
+    public static final int DEFAULT_BANNER_TIMEOUT_DELAY = Constants.TEN_SECONDS_MILLIS;
     private boolean mInvalidated;
     private MoPubView mMoPubView;
     private Context mContext;
@@ -30,12 +37,15 @@
     private final Runnable mTimeout;
     private boolean mStoredAutorefresh;
 
-    public CustomEventBannerAdapter(MoPubView moPubView, String className, String classData) {
+    public CustomEventBannerAdapter(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @Nullable AdReport adReport) {
+        Preconditions.checkNotNull(serverExtras);
         mHandler = new Handler();
         mMoPubView = moPubView;
         mContext = moPubView.getContext();
-        mLocalExtras = new HashMap<String, Object>();
-        mServerExtras = new HashMap<String, String>();
         mTimeout = new Runnable() {
             @Override
             public void run() {
@@ -55,19 +65,16 @@ public void run() {
         }
 
         // Attempt to load the JSON extras into mServerExtras.
-        try {
-            mServerExtras = Json.jsonStringToMap(classData);
-        } catch (Exception exception) {
-            MoPubLog.d("Failed to create Map from JSON: " + classData + exception.toString());
-        }
+        mServerExtras = new TreeMap<String,String>(serverExtras);
 
         mLocalExtras = mMoPubView.getLocalExtras();
         if (mMoPubView.getLocation() != null) {
             mLocalExtras.put("location", mMoPubView.getLocation());
         }
-        if (mMoPubView.getAdViewController() != null) {
-            mLocalExtras.put(AD_CONFIGURATION_KEY, mMoPubView.getAdViewController().getAdConfiguration());
-        }
+        mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        mLocalExtras.put(AD_REPORT_KEY, adReport);
+        mLocalExtras.put(AD_WIDTH, mMoPubView.getAdWidth());
+        mLocalExtras.put(AD_HEIGHT, mMoPubView.getAdHeight());
     }
 
     void loadAd() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
index f4a74c41..e9139058 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
@@ -2,22 +2,27 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
 import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 public class CustomEventInterstitialAdapter implements CustomEventInterstitialListener {
-    public static final int DEFAULT_INTERSTITIAL_TIMEOUT_DELAY = 30000;
+    public static final int DEFAULT_INTERSTITIAL_TIMEOUT_DELAY = Constants.THIRTY_SECONDS_MILLIS;
 
     private final MoPubInterstitial mMoPubInterstitial;
     private boolean mInvalidated;
@@ -29,11 +34,14 @@
     private final Handler mHandler;
     private final Runnable mTimeout;
 
-    public CustomEventInterstitialAdapter(final MoPubInterstitial moPubInterstitial, final String className, final String jsonParams) {
+    public CustomEventInterstitialAdapter(@NonNull final MoPubInterstitial moPubInterstitial,
+            @NonNull final String className,
+            @NonNull final Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @Nullable AdReport adReport) {
+        Preconditions.checkNotNull(serverExtras);
         mHandler = new Handler();
         mMoPubInterstitial = moPubInterstitial;
-        mServerExtras = new HashMap<String, String>();
-        mLocalExtras = new HashMap<String, Object>();
         mContext = mMoPubInterstitial.getActivity();
         mTimeout = new Runnable() {
             @Override
@@ -53,22 +61,13 @@ public void run() {
             return;
         }
 
-        // Attempt to load the JSON extras into mServerExtras.
-        try {
-            mServerExtras = Json.jsonStringToMap(jsonParams);
-        } catch (Exception exception) {
-            MoPubLog.d("Failed to create Map from JSON: " + jsonParams);
-        }
-
+        mServerExtras = new TreeMap<String, String>(serverExtras);
         mLocalExtras = mMoPubInterstitial.getLocalExtras();
         if (mMoPubInterstitial.getLocation() != null) {
             mLocalExtras.put("location", mMoPubInterstitial.getLocation());
         }
-
-        final AdViewController adViewController = mMoPubInterstitial.getMoPubInterstitialView().getAdViewController();
-        if (adViewController != null) {
-            mLocalExtras.put(AD_CONFIGURATION_KEY, adViewController.getAdConfiguration());
-        }
+        mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        mLocalExtras.put(AD_REPORT_KEY, adReport);
     }
     
     void loadInterstitial() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
new file mode 100644
index 00000000..ec9edbb4
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
@@ -0,0 +1,124 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubLifecycleManager;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ *
+ */
+public abstract class CustomEventRewardedVideo {
+    /**
+     * This marker interface is used to indicate that an object is a listener for a 3rd party SDKs
+     * rewarded video system.
+     */
+    @VisibleForTesting
+    protected static interface CustomEventRewardedVideoListener {}
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract CustomEventRewardedVideoListener getVideoListenerForSdk();
+
+    /**
+     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
+     * activity lifecycle events in the application.
+     *
+     * @return a LifecycleListener. May be null.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract LifecycleListener getLifecycleListener();
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     * This should return the "ad unit id", "zone id" or similar identifier for the network.
+     * May be empty if the network does not have anything more specific than an application ID.
+     *
+     * @return the id string for this ad unit with the ad network.
+     */
+    @NonNull
+    protected abstract String getAdNetworkId();
+
+    /**
+     * Called to when the custom event is no longer used. Implementers should cancel any
+     * pending requests. The initialized SDK may be reused by another CustomEvent instance
+     * and should not be shut down or cleaned up.
+     */
+    protected abstract void onInvalidate();
+
+    /**
+     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
+     * be loaded.
+     *
+     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    final void loadCustomEvent(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) {
+        try {
+            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
+                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(getLifecycleListener());
+            }
+            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
+        } catch (Exception e) {
+            MoPubLog.e(e.getMessage());
+        }
+    }
+
+    /**
+     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
+     * to do any static initialization the first time this method is run by any class instance.
+     * From then on, the SDK should be reused without initialization.
+     *
+     * @return true if the SDK performed initialization, false if the SDK was already initialized.
+     */
+    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
+     * contain all the data needed to load an ad.
+     *
+     * Implementers should also use this method (or checkAndInitializeSdk)
+     * to register a listener for their SDK, wrap it in a
+     * {@link com.mopub.mobileads.CustomEventRewardedVideo.CustomEventRewardedVideoListener}
+     *
+     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
+     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
+     *
+     * @param activity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Implementers should query the 3rd party SDK for whether there is a video available for the
+     * 3rd party SDK & ID represented by the custom event.
+     *
+     * @return true iff a video is available to play.
+     */
+    protected abstract boolean hasVideoAvailable();
+
+    /**
+     * Implementers should now play the rewarded video for this custom event.
+     */
+    protected abstract void showVideo();
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java b/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
index 624995f2..d5561d92 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
@@ -6,19 +6,20 @@
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
 
+import com.mopub.common.DataKeys;
+
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
-class EventForwardingBroadcastReceiver extends BroadcastReceiver {
+public class EventForwardingBroadcastReceiver extends BroadcastReceiver {
     private final CustomEventInterstitialListener mCustomEventInterstitialListener;
     private final long mBroadcastIdentifier;
     private Context mContext;
 
-    static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
-    static final String ACTION_INTERSTITIAL_FAIL = "com.mopub.action.interstitial.fail";
-    static final String ACTION_INTERSTITIAL_SHOW = "com.mopub.action.interstitial.show";
-    static final String ACTION_INTERSTITIAL_DISMISS = "com.mopub.action.interstitial.dismiss";
-    static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
+    public static final String ACTION_INTERSTITIAL_FAIL = "com.mopub.action.interstitial.fail";
+    public static final String ACTION_INTERSTITIAL_SHOW = "com.mopub.action.interstitial.show";
+    public static final String ACTION_INTERSTITIAL_DISMISS = "com.mopub.action.interstitial.dismiss";
+    public static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
     private static IntentFilter sIntentFilter;
 
 
@@ -30,11 +31,11 @@ public EventForwardingBroadcastReceiver(CustomEventInterstitialListener customEv
 
     static void broadcastAction(final Context context, final long broadcastIdentifier, final String action) {
         Intent intent = new Intent(action);
-        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(DataKeys.BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         LocalBroadcastManager.getInstance(context.getApplicationContext()).sendBroadcast(intent);
     }
 
-    static IntentFilter getHtmlInterstitialIntentFilter() {
+    public static IntentFilter getHtmlInterstitialIntentFilter() {
         if (sIntentFilter == null) {
             sIntentFilter = new IntentFilter();
             sIntentFilter.addAction(ACTION_INTERSTITIAL_FAIL);
@@ -57,7 +58,7 @@ public void onReceive(Context context, Intent intent) {
          * this here because there is no appropriate IntentFilter condition that can recreate this
          * behavior.
          */
-        final long receivedIdentifier = intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1);
+        final long receivedIdentifier = intent.getLongExtra(DataKeys.BROADCAST_IDENTIFIER_KEY, -1);
         if (mBroadcastIdentifier != receivedIdentifier) {
             return;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
index c6598308..dcdf11bd 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
@@ -1,25 +1,21 @@
 package com.mopub.mobileads;
 
-import android.app.Activity;
 import android.content.Context;
-import android.net.Uri;
-import android.os.Looper;
 
-import com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.HtmlBannerWebViewFactory;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
 public class HtmlBanner extends CustomEventBanner {
 
     private HtmlBannerWebView mHtmlBannerWebView;
-    private Activity mActivity;
 
     @Override
     protected void loadBanner(
@@ -32,58 +28,37 @@ protected void loadBanner(
         String redirectUrl;
         String clickthroughUrl;
         Boolean isScrollable;
+        AdReport adReport;
         if (extrasAreValid(serverExtras)) {
-            htmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-            redirectUrl = serverExtras.get(REDIRECT_URL_KEY);
-            clickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
-            isScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
+            htmlData = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
+            redirectUrl = serverExtras.get(DataKeys.REDIRECT_URL_KEY);
+            clickthroughUrl = serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY);
+            isScrollable = Boolean.valueOf(serverExtras.get(DataKeys.SCROLLABLE_KEY));
+            try {
+                adReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            } catch (ClassCastException e) {
+                MoPubLog.e("LocalExtras contained an incorrect type.");
+                customEventBannerListener.onBannerFailed(INTERNAL_ERROR);
+                return;
+            }
         } else {
             customEventBannerListener.onBannerFailed(NETWORK_INVALID_STATE);
             return;
         }
 
-        AdConfiguration adConfiguration = AdConfiguration.extractFromMap(localExtras);
-        if (Looper.myLooper() == Looper.getMainLooper()) {
-        	mHtmlBannerWebView = HtmlBannerWebViewFactory.create(context, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
-            AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
-            mHtmlBannerWebView.loadHtmlResponse(htmlData);
-        } else {
-        	final Context pContext = context;
-            final CustomEventBannerListener pCustomEventBannerListener = customEventBannerListener;
-            final Boolean pIsScrollable = isScrollable;
-            final String pRedirectUrl = redirectUrl;
-            final String pClickthroughUrl = clickthroughUrl;
-            final AdConfiguration pAdConfiguration = adConfiguration;
-            final String pHtmlData = htmlData;
-            mActivity = (Activity)context; 
-            mActivity.runOnUiThread(new Runnable() {
-    			@Override
-    			public void run() {
-    				mHtmlBannerWebView = HtmlBannerWebViewFactory.create(pContext, pCustomEventBannerListener, pIsScrollable, pRedirectUrl, pClickthroughUrl, pAdConfiguration);
-    		        AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
-    		        mHtmlBannerWebView.loadHtmlResponse(pHtmlData);
-    			}
-    		});
-        }
+        mHtmlBannerWebView = HtmlBannerWebViewFactory.create(context, adReport, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
+        AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
+        mHtmlBannerWebView.loadHtmlResponse(htmlData);
     }
 
     @Override
     protected void onInvalidate() {
         if (mHtmlBannerWebView != null) {
-            if (Looper.myLooper() == Looper.getMainLooper()) {
-        		mHtmlBannerWebView.destroy();
-        	} else {
-        		mActivity.runOnUiThread(new Runnable() {
-    				@Override
-    				public void run() {
-    					mHtmlBannerWebView.destroy();
-    				}
-    			});
-        	}
+            mHtmlBannerWebView.destroy();
         }
     }
 
     private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
+        return serverExtras.containsKey(DataKeys.HTML_RESPONSE_BODY_KEY);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
index b707d66f..358ea16c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
@@ -2,13 +2,15 @@
 
 import android.content.Context;
 
+import com.mopub.common.AdReport;
+
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 
 public class HtmlBannerWebView extends BaseHtmlWebView {
     public static final String EXTRA_AD_CLICK_DATA = "com.mopub.intent.extra.AD_CLICK_DATA";
 
-    public HtmlBannerWebView(Context context, AdConfiguration adConfiguration) {
-        super(context, adConfiguration);
+    public HtmlBannerWebView(Context context, AdReport adReport) {
+        super(context, adReport);
     }
 
     public void init(CustomEventBannerListener customEventBannerListener, boolean isScrollable, String redirectUrl, String clickthroughUrl) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
index d3ddf4a9..f0643055 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
@@ -1,35 +1,43 @@
 package com.mopub.mobileads;
 
-import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.CreativeOrientation;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 
 public class HtmlInterstitial extends ResponseBodyInterstitial {
     private String mHtmlData;
     private boolean mIsScrollable;
     private String mRedirectUrl;
     private String mClickthroughUrl;
+    @NonNull
+    private CreativeOrientation mOrientation;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
-        mHtmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
+        mHtmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
         mIsScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
         mRedirectUrl = serverExtras.get(REDIRECT_URL_KEY);
         mClickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
+        mOrientation = CreativeOrientation.fromHeader(serverExtras.get(CREATIVE_ORIENTATION_KEY));
     }
 
     @Override
     protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener) {
-        MoPubActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
+        MoPubActivity.preRenderHtml(mContext, mAdReport, customEventInterstitialListener, mHtmlData);
     }
 
     @Override
-    protected void showInterstitial() {
-        MoPubActivity.start(mContext, mHtmlData, mIsScrollable, mRedirectUrl, mClickthroughUrl, mAdConfiguration);
+    public void showInterstitial() {
+        MoPubActivity.start(mContext, mHtmlData, mAdReport, mIsScrollable,
+                mRedirectUrl, mClickthroughUrl, mOrientation,
+                mBroadcastIdentifier);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
index 54f10701..78795c1b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
@@ -1,25 +1,17 @@
 package com.mopub.mobileads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Handler;
-import android.webkit.JavascriptInterface;
 
-import static com.mopub.common.util.VersionCode.HONEYCOMB;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
+import com.mopub.common.AdReport;
+
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 
 public class HtmlInterstitialWebView extends BaseHtmlWebView {
     private Handler mHandler;
 
-    protected static final String MOPUB_JS_INTERFACE_NAME = "mopubUriInterface";
-
-    interface MoPubUriJavascriptFireFinishLoadListener {
-        abstract void onInterstitialLoaded();
-    }
-
-    public HtmlInterstitialWebView(Context context, AdConfiguration adConfiguration) {
-        super(context, adConfiguration);
+    public HtmlInterstitialWebView(Context context, AdReport adReport) {
+        super(context, adReport);
 
         mHandler = new Handler();
     }
@@ -30,61 +22,12 @@ public void init(final CustomEventInterstitialListener customEventInterstitialLi
         HtmlInterstitialWebViewListener htmlInterstitialWebViewListener = new HtmlInterstitialWebViewListener(customEventInterstitialListener);
         HtmlWebViewClient htmlWebViewClient = new HtmlWebViewClient(htmlInterstitialWebViewListener, this, clickthroughUrl, redirectUrl);
         setWebViewClient(htmlWebViewClient);
-
-        addMoPubUriJavascriptInterface(new MoPubUriJavascriptFireFinishLoadListener() {
-            @Override
-            public void onInterstitialLoaded() {
-                if (!mIsDestroyed) {
-                    customEventInterstitialListener.onInterstitialLoaded();
-                }
-            }
-        });
     }
 
     private void postHandlerRunnable(Runnable r) {
         mHandler.post(r);
     }
 
-    /*
-     * XXX (2/15/12): This is a workaround for a problem on ICS devices where
-     * WebViews with layout height WRAP_CONTENT can mysteriously render with
-     * zero height. This seems to happen when calling loadData() with HTML that
-     * sets window.location during its "onload" event. We use loadData() when
-     * displaying interstitials, and our creatives use window.location to
-     * communicate ad loading status to AdViews. This results in zero-height
-     * interstitials. We counteract this by using a Javascript interface object
-     * to signal loading status, rather than modifying window.location.
-     */
-    void addMoPubUriJavascriptInterface(final MoPubUriJavascriptFireFinishLoadListener moPubUriJavascriptFireFinishLoadListener) {
-        final class MoPubUriJavascriptInterface {
-            // This method appears to be unused, since it will only be called from JavaScript.
-            @SuppressWarnings("unused")
-            @JavascriptInterface
-            public boolean fireFinishLoad() {
-                HtmlInterstitialWebView.this.postHandlerRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        moPubUriJavascriptFireFinishLoadListener.onInterstitialLoaded();
-                    }
-                });
-
-                return true;
-            }
-        }
-
-        addJavascriptInterface(new MoPubUriJavascriptInterface(), MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @TargetApi(11)
-    @Override
-    public void destroy() {
-        if (currentApiLevel().isAtLeast(HONEYCOMB)) {
-            removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        }
-
-        super.destroy();
-    }
-
     static class HtmlInterstitialWebViewListener implements HtmlWebViewListener {
         private final CustomEventInterstitialListener mCustomEventInterstitialListener;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
index 1b8726d3..b581bb8b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
@@ -1,16 +1,17 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
-import com.mopub.common.MoPubBrowser;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.mobileads.util.Utils;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
 
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
@@ -33,21 +34,49 @@
     }
 
     @Override
-    public boolean shouldOverrideUrlLoading(WebView view, String url) {
-        if (handleSpecialMoPubScheme(url) || handlePhoneScheme(url) || handleNativeBrowserScheme(url)) {
-            return true;
-        }
-
-        MoPubLog.d("Ad clicked. Click URL: " + url);
-
-        // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
-            if (launchApplicationUrl(url)) {
-                return true;
-            }
-        }
-
-        showMoPubBrowserForUrl(url);
+    public boolean shouldOverrideUrlLoading(final WebView view, final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.HANDLE_MOPUB_SCHEME,
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.HANDLE_PHONE_SCHEME,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (mHtmlWebView.wasClicked()) {
+                            mHtmlWebViewListener.onClicked();
+                            mHtmlWebView.onResetUserClick();
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withMoPubSchemeListener(new UrlHandler.MoPubSchemeListener() {
+                    @Override
+                    public void onFinishLoad() {
+                        mHtmlWebViewListener.onLoaded(mHtmlWebView);
+                    }
+
+                    @Override
+                    public void onClose() {
+                        mHtmlWebViewListener.onCollapsed();
+                    }
+
+                    @Override
+                    public void onFailLoad() {
+                        mHtmlWebViewListener.onFailed(UNSPECIFIED);
+                    }
+                })
+                .build().handleUrl(mContext, url, mHtmlWebView.wasClicked());
         return true;
     }
 
@@ -56,156 +85,16 @@ public void onPageStarted(WebView view, String url, Bitmap favicon) {
         // If the URL being loaded shares the redirectUrl prefix, open it in the browser.
         if (mRedirectUrl != null && url.startsWith(mRedirectUrl)) {
             view.stopLoading();
-            showMoPubBrowserForUrl(url);
-        }
-    }
-
-    private boolean isSpecialMoPubScheme(String url) {
-        return url.startsWith("mopub://");
-    }
-
-    private boolean handleSpecialMoPubScheme(String url) {
-        if (!isSpecialMoPubScheme(url)) {
-            return false;
-        }
-        Uri uri = Uri.parse(url);
-        String host = uri.getHost();
-
-        if ("finishLoad".equals(host)) {
-            mHtmlWebViewListener.onLoaded(mHtmlWebView);
-        } else if ("close".equals(host)) {
-            mHtmlWebViewListener.onCollapsed();
-        } else if ("failLoad".equals(host)) {
-            mHtmlWebViewListener.onFailed(UNSPECIFIED);
-        } else if ("custom".equals(host)) {
-            handleCustomIntentFromUri(uri);
-        }
-
-        return true;
-    }
-
-    private boolean isPhoneScheme(String url) {
-        return url.startsWith("tel:") || url.startsWith("voicemail:") ||
-                url.startsWith("sms:") || url.startsWith("mailto:") ||
-                url.startsWith("geo:") || url.startsWith("google.streetview:");
-    }
-
-    private boolean handlePhoneScheme(String url) {
-        if (!isPhoneScheme(url)) {
-            return false;
-        }
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean isNativeBrowserScheme(String url) {
-        return url.startsWith("mopubnativebrowser://");
-    }
-
-    private boolean handleNativeBrowserScheme(String url) {
-        if (!isNativeBrowserScheme(url)) {
-            return false;
-        }
-
-        Uri uri = Uri.parse(url);
-
-        String urlToOpenInNativeBrowser;
-        try {
-            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle url: " + url);
-            return false;
-        }
-
-        if (!"navigate".equals(uri.getHost()) || urlToOpenInNativeBrowser == null) {
-            return false;
-        }
-
-        Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
-
-        Intent intent = new Intent(Intent.ACTION_VIEW, intentUri);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean isWebSiteUrl(String url) {
-        return url.startsWith("http://") || url.startsWith("https://");
-    }
-
-    private boolean launchApplicationUrl(String url) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Unable to open intent.";
-
-        return launchIntentForUserClick(mContext, intent, errorMessage);
-    }
-
-    private void showMoPubBrowserForUrl(String url) {
-        if (url == null || url.equals("")) url = "about:blank";
-        MoPubLog.d("Final URI to show in browser: " + url);
-        Intent intent = new Intent(mContext, MoPubBrowser.class);
-        intent.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent action. "
-                + ". Perhaps you forgot to declare com.mopub.common.MoPubBrowser"
-                + " in your Android manifest file.";
-
-        boolean handledByMoPubBrowser = launchIntentForUserClick(mContext, intent, errorMessage);
-
-        if (!handledByMoPubBrowser) {
-            intent = new Intent(Intent.ACTION_VIEW, Uri.parse("about:blank"));
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            launchIntentForUserClick(mContext, intent, null);
-        }
-    }
-
-    private void handleCustomIntentFromUri(Uri uri) {
-        String action;
-        String adData;
-        try {
-            action = uri.getQueryParameter("fnc");
-            adData = uri.getQueryParameter("data");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle custom intent with uri: " + uri);
-            return;
+            if (mHtmlWebView.wasClicked()) {
+                try {
+                    Intents.showMoPubBrowserForUrl(mContext, Uri.parse(url));
+                } catch (IntentNotResolvableException e) {
+                    MoPubLog.d(e.getMessage());
+                }
+            } else {
+                MoPubLog.d("Attempted to redirect without user interaction");
+            }
         }
-
-        Intent customIntent = new Intent(action);
-        customIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        customIntent.putExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA, adData);
-
-        String errorMessage = "Could not handle custom intent: " + action
-                + ". Is your intent spelled correctly?";
-
-        launchIntentForUserClick(mContext, customIntent, errorMessage);
     }
 
-    boolean launchIntentForUserClick(Context context, Intent intent, String errorMessage) {
-        if (!mHtmlWebView.wasClicked()) {
-            return false;
-        }
-
-        boolean wasIntentStarted = Utils.executeIntent(context, intent, errorMessage);
-        if (wasIntentStarted) {
-            mHtmlWebViewListener.onClicked();
-            mHtmlWebView.onResetUserClick();
-        }
-
-        return wasIntentStarted;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
index 223c015e..bf0168d3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
@@ -9,13 +9,21 @@
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.DataKeys;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import java.io.Serializable;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -30,8 +38,11 @@
 public class MoPubActivity extends BaseInterstitialActivity {
     private HtmlInterstitialWebView mHtmlInterstitialWebView;
 
-    public static void start(Context context, String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
-        Intent intent = createIntent(context, htmlData, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+    public static void start(Context context, String htmlData, AdReport adReport,
+            boolean isScrollable, String redirectUrl, String clickthroughUrl,
+            CreativeOrientation creativeOrientation, long broadcastIdentifier) {
+        Intent intent = createIntent(context, htmlData, adReport, isScrollable,
+                redirectUrl, clickthroughUrl, creativeOrientation, broadcastIdentifier);
         try {
             context.startActivity(intent);
         } catch (ActivityNotFoundException anfe) {
@@ -39,27 +50,26 @@ public static void start(Context context, String htmlData, boolean isScrollable,
         }
     }
 
-    static Intent createIntent(Context context, String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
+    static Intent createIntent(Context context,
+            String htmlData, AdReport adReport, boolean isScrollable, String redirectUrl,
+            String clickthroughUrl, CreativeOrientation orientation, long broadcastIdentifier) {
         Intent intent = new Intent(context, MoPubActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
         intent.putExtra(SCROLLABLE_KEY, isScrollable);
         intent.putExtra(CLICKTHROUGH_URL_KEY, clickthroughUrl);
         intent.putExtra(REDIRECT_URL_KEY, redirectUrl);
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
+        intent.putExtra(CREATIVE_ORIENTATION_KEY, orientation);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
-    static void preRenderHtml(final Context context, final CustomEventInterstitialListener customEventInterstitialListener, String htmlData) {
-        HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, customEventInterstitialListener, false, null, null, null);
+    static void preRenderHtml(final Context context, final AdReport adReport,
+            final CustomEventInterstitialListener customEventInterstitialListener,
+            String htmlData) {
+        HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, adReport, customEventInterstitialListener, false, null, null);
         dummyWebView.enablePlugins(false);
-
-        dummyWebView.addMoPubUriJavascriptInterface(new HtmlInterstitialWebView.MoPubUriJavascriptFireFinishLoadListener() {
-            @Override
-            public void onInterstitialLoaded() {
-                customEventInterstitialListener.onInterstitialLoaded();
-            }
-        });
         dummyWebView.setWebViewClient(new WebViewClient() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
@@ -83,7 +93,7 @@ public View getAdView() {
         String clickthroughUrl = intent.getStringExtra(CLICKTHROUGH_URL_KEY);
         String htmlResponse = intent.getStringExtra(HTML_RESPONSE_BODY_KEY);
 
-        mHtmlInterstitialWebView = HtmlInterstitialWebViewFactory.create(getApplicationContext(), new BroadcastingInterstitialListener(), isScrollable, redirectUrl, clickthroughUrl, getAdConfiguration());
+        mHtmlInterstitialWebView = HtmlInterstitialWebViewFactory.create(getApplicationContext(), mAdReport, new BroadcastingInterstitialListener(), isScrollable, redirectUrl, clickthroughUrl);
         mHtmlInterstitialWebView.loadHtmlResponse(htmlResponse);
 
         return mHtmlInterstitialWebView;
@@ -93,6 +103,15 @@ public View getAdView() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        // Lock the device orientation
+        Serializable orientationExtra = getIntent().getSerializableExtra(DataKeys.CREATIVE_ORIENTATION_KEY);
+        CreativeOrientation requestedOrientation;
+        if (orientationExtra == null || !(orientationExtra instanceof CreativeOrientation)) {
+            requestedOrientation = CreativeOrientation.UNDEFINED;
+        } else {
+            requestedOrientation = (CreativeOrientation) orientationExtra;
+        }
+        DeviceUtils.lockOrientation(this, requestedOrientation);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
index f1f98dc6..edcf4b3f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
@@ -2,31 +2,21 @@
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.GpsHelper;
+import com.mopub.common.Constants;
 import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.VolleyError;
 
 public class MoPubConversionTracker {
-    private static final String TRACK_HOST = "ads.mopub.com";
-    private static final String TRACK_HANDLER = "/m/open";
-
     private Context mContext;
     private String mIsTrackedKey;
     private SharedPreferences mSharedPreferences;
     private String mPackageName;
-    private ConversionTrackerGpsHelperListener mConversionTrackerGpsHelperListener;
-
-    public MoPubConversionTracker() {
-        mConversionTrackerGpsHelperListener = new ConversionTrackerGpsHelperListener();
-    }
 
     public void reportAppOpen(Context context) {
         if (context == null) {
@@ -39,7 +29,19 @@ public void reportAppOpen(Context context) {
         mSharedPreferences = SharedPreferencesHelper.getSharedPreferences(mContext);
 
         if (!isAlreadyTracked()) {
-            GpsHelper.fetchAdvertisingInfoAsync(mContext, mConversionTrackerGpsHelperListener);
+            TrackingRequest.makeTrackingHttpRequest(new ConversionUrlGenerator().generateUrlString(Constants.HOST),
+                    mContext, new TrackingRequest.Listener() {
+                @Override
+                public void onResponse(@NonNull String url) {
+                    mSharedPreferences
+                            .edit()
+                            .putBoolean(mIsTrackedKey, true)
+                            .commit();
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) { }
+            });
         } else {
             MoPubLog.d("Conversion already tracked");
         }
@@ -52,15 +54,12 @@ private boolean isAlreadyTracked() {
     private class ConversionUrlGenerator extends BaseUrlGenerator {
         @Override
         public String generateUrlString(String serverHostname) {
-            initUrlString(serverHostname, TRACK_HANDLER);
-
+            initUrlString(serverHostname, Constants.CONVERSION_TRACKING_HANDLER);
             setApiVersion("6");
             setPackageId(mPackageName);
-
             ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-            setUdid(clientMetadata.getAdvertisingId());
-            setDoNotTrack(clientMetadata.isDoNotTrackSet());
             setAppVersion(clientMetadata.getAppVersion());
+            appendAdvertisingInfoTemplates();
             return getFinalUrlString();
         }
 
@@ -68,46 +67,4 @@ private void setPackageId(String packageName) {
             addParam("id", packageName);
         }
     }
-
-    private class TrackOpen implements Runnable {
-        public void run() {
-            String url = new ConversionUrlGenerator().generateUrlString(TRACK_HOST);
-            MoPubLog.d("Conversion track: " + url);
-
-            DefaultHttpClient httpClient = HttpClientFactory.create();
-            HttpResponse response;
-            try {
-                HttpGet httpget = new HttpGet(url);
-                response = httpClient.execute(httpget);
-            } catch (Exception e) {
-                MoPubLog.d("Conversion track failed [" + e.getClass().getSimpleName() + "]: " + url);
-                return;
-            }
-
-            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.d("Conversion track failed: Status code != 200.");
-                return;
-            }
-
-            HttpEntity entity = response.getEntity();
-            if (entity == null || entity.getContentLength() == 0) {
-                MoPubLog.d("Conversion track failed: Response was empty.");
-                return;
-            }
-
-            // If we made it here, the request has been tracked
-            MoPubLog.d("Conversion track successful.");
-            mSharedPreferences
-                    .edit()
-                    .putBoolean(mIsTrackedKey, true)
-                    .commit();
-        }
-    }
-
-    class ConversionTrackerGpsHelperListener implements GpsHelper.GpsHelperListener {
-        @Override
-        public void onFetchAdInfoCompleted() {
-            new Thread(new TrackOpen()).start();
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index a858a746..d3322c04 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -2,10 +2,12 @@
 
 public enum MoPubErrorCode {
     NO_FILL("No ads found."),
+    WARMUP("Ad unit is warming up. Try again in a few minutes."),
     SERVER_ERROR("Unable to connect to MoPub adserver."),
     INTERNAL_ERROR("Unable to serve ad due to invalid internal state."),
     CANCELLED("Ad request was cancelled."),
-    
+    NO_CONNECTION("No internet connection detected."),
+
     ADAPTER_NOT_FOUND("Unable to find Native Network or Custom Event adapter."),
     ADAPTER_CONFIGURATION_ERROR("Native Network or Custom Event adapter was configured incorrectly."),
     NETWORK_TIMEOUT("Third-party network failed to respond in a timely manner."),
@@ -15,14 +17,17 @@
     VIDEO_CACHE_ERROR("Error creating a cache to store downloaded videos."),
     VIDEO_DOWNLOAD_ERROR("Error downloading video."),
 
+    VIDEO_NOT_AVAILABLE("No video loaded for ad unit."),
+    VIDEO_PLAYBACK_ERROR("Error playing a video."),
+
     UNSPECIFIED("Unspecified error.");
-    
+
     private final String message;
-    
+
     private MoPubErrorCode(String message) {
         this.message = message;
     }
-    
+
     @Override
     public String toString() {
         return this.message;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index be773f6c..5f5f82e1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -3,7 +3,9 @@
 import android.app.Activity;
 import android.content.Context;
 import android.location.Location;
+import android.text.TextUtils;
 
+import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
@@ -11,8 +13,6 @@
 import java.util.Map;
 
 import static com.mopub.common.LocationService.LocationAwareness;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubInterstitial implements CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener {
@@ -29,7 +29,7 @@ boolean isReady() {
     private MoPubInterstitialView mInterstitialView;
     private CustomEventInterstitialAdapter mCustomEventInterstitialAdapter;
     private InterstitialAdListener mInterstitialAdListener;
-    private Activity mActivity;
+    private Context mActivity;
     private String mAdUnitId;
     private InterstitialState mCurrentInterstitialState;
     private boolean mIsDestroyed;
@@ -50,7 +50,7 @@ boolean isReady() {
         public void OnInterstitialFailed();
     }
 
-    public MoPubInterstitial(Activity activity, String id) {
+    public MoPubInterstitial(Context activity, String id) {
         mActivity = activity;
         mAdUnitId = id;
 
@@ -121,7 +121,7 @@ public String getKeywords() {
         return mInterstitialView.getKeywords();
     }
 
-    public Activity getActivity() {
+    public Context getActivity() {
         return mActivity;
     }
 
@@ -253,8 +253,17 @@ public MoPubInterstitialView(Context context) {
         }
 
         @Override
-        protected void loadCustomEvent(Map<String, String> paramsMap) {
-            if (paramsMap == null) {
+        public AdFormat getAdFormat() {
+            return AdFormat.INTERSTITIAL;
+        }
+
+        @Override
+        protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+            if (mAdViewController == null) {
+                return;
+            }
+
+            if (TextUtils.isEmpty(customEventClassName)) {
                 MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
                 loadFailUrl(ADAPTER_NOT_FOUND);
                 return;
@@ -268,8 +277,10 @@ protected void loadCustomEvent(Map<String, String> paramsMap) {
 
             mCustomEventInterstitialAdapter = CustomEventInterstitialAdapterFactory.create(
                     MoPubInterstitial.this,
-                    paramsMap.get(CUSTOM_EVENT_NAME.getKey()),
-                    paramsMap.get(CUSTOM_EVENT_DATA.getKey()));
+                    customEventClassName,
+                    serverExtras,
+                    mAdViewController.getBroadcastIdentifier(),
+                    mAdViewController.getAdReport());
             mCustomEventInterstitialAdapter.setAdapterListener(MoPubInterstitial.this);
             mCustomEventInterstitialAdapter.loadInterstitial();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
new file mode 100644
index 00000000..ff9361f1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
@@ -0,0 +1,46 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.MoPubReward;
+
+import java.util.Set;
+
+/**
+ * Listener for rewarded video events. Implementers of this interface will receive events for all
+ * rewarded video ad units in the app.:
+ */
+public interface MoPubRewardedVideoListener {
+
+    /**
+     * Called when the adUnitId has loaded. At this point you should be able to call
+     * {@link com.mopub.common.MoPub#showRewardedVideo(String)} to show the video.
+     */
+    public void onRewardedVideoLoadSuccess(@NonNull String adUnitId);
+
+    /**
+     * Called when a video fails to load for the given ad unit id. The provided error code will
+     * give more insight into the reason for the failure to load.
+     */
+    public void onRewardedVideoLoadFailure(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video starts playing.
+     */
+    public void onRewardedVideoStarted(@NonNull String adUnitId);
+
+    /**
+     * Called when there is an error during video playback.
+     */
+    public void onRewardedVideoPlaybackError(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video is closed. At this point your application should resume.
+     */
+    public void onRewardedVideoClosed(@NonNull String adUnitId);
+
+    /**
+     * Called when a rewarded video is completed and the user should be rewarded.
+     */
+    public void onRewardedVideoCompleted(@NonNull Set<String> adUnitIds, @NonNull MoPubReward reward);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
new file mode 100644
index 00000000..cc285b42
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -0,0 +1,523 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.Constants;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.MoPubCollections;
+import com.mopub.common.util.Reflection;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+/**
+ */
+public class MoPubRewardedVideoManager {
+    private static MoPubRewardedVideoManager sInstance;
+    private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
+
+    @NonNull private final Handler mCallbackHandler;
+    @NonNull private WeakReference<Activity> mMainActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final AdRequestStatusMapping mAdRequestStatus;
+    @NonNull private final RewardedVideoData mRewardedVideoData;
+    @Nullable private MoPubRewardedVideoListener mVideoListener;
+    
+    @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
+    @NonNull private final Map<String, Set<MediationSettings>> mInstanceMediationSettings;
+
+    @NonNull private final Handler mCustomEventTimeoutHandler;
+    @NonNull private final Map<String, Runnable> mTimeoutMap;
+
+    public static class RewardedVideoRequestListener implements AdRequest.Listener {
+        public final String adUnitId;
+        private final MoPubRewardedVideoManager mVideoManager;
+
+        public RewardedVideoRequestListener(MoPubRewardedVideoManager videoManager, String adUnitId) {
+            this.adUnitId = adUnitId;
+            this.mVideoManager = videoManager;
+        }
+
+        @Override
+        public void onSuccess(final AdResponse response) {
+            mVideoManager.onAdSuccess(response, adUnitId);
+        }
+
+        @Override
+        public void onErrorResponse(final VolleyError volleyError) {
+            mVideoManager.onAdError(volleyError, adUnitId);
+        }
+    }
+
+    private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+        mContext = mainActivity.getApplicationContext();
+        mRewardedVideoData = new RewardedVideoData();
+        mCallbackHandler = new Handler(Looper.getMainLooper());
+        mGlobalMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
+        mInstanceMediationSettings = new HashMap<String, Set<MediationSettings>>();
+        mCustomEventTimeoutHandler = new Handler();
+        mTimeoutMap = new HashMap<String, Runnable>();
+        
+        mAdRequestStatus = new AdRequestStatusMapping();
+    }
+
+    public static synchronized void init(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            sInstance = new MoPubRewardedVideoManager(mainActivity, mediationSettings);
+        } else {
+            MoPubLog.e("Tried to call initializeRewardedVideo more than once. Only the first " +
+                    "initialization call has any effect.");
+        }
+    }
+
+    public static void updateActivity(@NonNull Activity activity) {
+        if (sInstance != null) {
+            sInstance.mMainActivity = new WeakReference<Activity>(activity);
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Returns a global {@link MediationSettings} object of the type 'clazz', if one is registered.
+     * This method will only return an object if its type is identical to 'clazz', not if it is a
+     * subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getGlobalMediationSettings(@NonNull final Class<T> clazz) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : sInstance.mGlobalMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns an instance {@link MediationSettings} object of the type 'clazz', if one is
+     * registered. This method will only return an object if its type is identical to 'clazz', not
+     * if it is a subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @param adUnitId String identifier used to obtain the appropriate instance MediationSettings
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getInstanceMediationSettings(
+            @NonNull final Class<T> clazz, @NonNull final String adUnitId) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        final Set<MediationSettings> instanceMediationSettings =
+                sInstance.mInstanceMediationSettings.get(adUnitId);
+        if (instanceMediationSettings == null) {
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : instanceMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Sets the {@link MoPubRewardedVideoListener} that will receive events from the
+     * rewarded video system. Set this to null to stop receiving event callbacks.
+     */
+    public static void setVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        if (sInstance != null) {
+            sInstance.mVideoListener = listener;
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Builds an AdRequest for the given adUnitId and adds it to the singleton RequestQueue. This
+     * method will not make a new request if there is already a video loading for this adUnitId.
+     *
+     * @param adUnitId MoPub adUnitId String
+     * @param mediationSettings Optional instance-level MediationSettings to associate with the
+     *                          above adUnitId.
+     */
+    public static void loadVideo(@NonNull String adUnitId, @Nullable final MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        // If any instance MediationSettings have been specified, update the internal map.
+        // Note: This always clears the MediationSettings for the ad unit, whether or not any
+        // MediationSettings have been provided.
+        final Set<MediationSettings> newInstanceMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(newInstanceMediationSettings, mediationSettings);
+        sInstance.mInstanceMediationSettings.put(adUnitId, newInstanceMediationSettings);
+
+        final AdUrlGenerator urlGenerator = new WebViewAdUrlGenerator(sInstance.mContext, false);
+        final String adUrlString = urlGenerator.withAdUnitId(adUnitId)
+                .withLocation(
+                        LocationService.getLastKnownLocation(
+                                sInstance.mContext,
+                                MoPub.getLocationPrecision(),
+                                MoPub.getLocationAwareness()
+                        )
+                )
+                .generateUrlString(Constants.HOST);
+
+        loadVideo(adUnitId, adUrlString);
+    }
+
+    private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlString) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
+                    "unit %s. A request is already pending.", adUnitId));
+            return;
+        }
+
+        // Issue MoPub request
+        final AdRequest request = new AdRequest(
+                adUrlString,
+                AdFormat.REWARDED_VIDEO,
+                adUnitId,
+                sInstance.mContext,
+                new RewardedVideoRequestListener(sInstance, adUnitId)
+        );
+        final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
+        requestQueue.add(request);
+        sInstance.mAdRequestStatus.markLoading(adUnitId);
+    }
+
+    public static boolean hasVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            return isPlayable(adUnitId, customEvent);
+        } else {
+            logErrorNotInitialized();
+            return false;
+        }
+    }
+
+    public static void showVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            if (isPlayable(adUnitId, customEvent)) {
+                sInstance.mAdRequestStatus.markPlayed(adUnitId);
+                customEvent.showVideo();
+            } else {
+                sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
+            }
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedVideo customEvent) {
+        return (sInstance != null
+                && sInstance.mAdRequestStatus.canPlay(adUnitId)
+                && customEvent != null
+                && customEvent.hasVideoAvailable());
+    }
+
+    ///// Ad Request / Response methods /////
+    private void onAdSuccess(AdResponse adResponse, String adUnitId) {
+        mAdRequestStatus.markLoaded(adUnitId,
+                adResponse.getFailoverUrl(),
+                adResponse.getImpressionTrackingUrl(),
+                adResponse.getClickTrackingUrl());
+
+        Integer timeoutMillis = adResponse.getAdTimeoutMillis();
+        if (timeoutMillis == null || timeoutMillis <= 0) {
+            timeoutMillis = DEFAULT_LOAD_TIMEOUT;
+        }
+
+        final String customEventClassName = adResponse.getCustomEventClassName();
+        if (customEventClassName == null) {
+            MoPubLog.e("Couldn't create custom event, class name was null.");
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        try {
+            // Instantiate a custom event
+            final CustomEventRewardedVideo customEvent =
+                    Reflection.instantiateClassWithEmptyConstructor(
+                            customEventClassName,
+                            CustomEventRewardedVideo.class);
+
+            // Put important data into localExtras...
+            final Map<String, Object> localExtras = new TreeMap<String, Object>();
+            localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
+
+            Activity mainActivity = mMainActivity.get();
+            if (mainActivity == null) {
+                MoPubLog.d("Could not load custom event because Activity reference was null. Call" +
+                        " MoPub#updateActivity before requesting more rewarded videos.");
+
+                // Don't go through the ordinary failover process since we have
+                // no activity for the failover to use.
+                mAdRequestStatus.markFail(adUnitId);
+                return;
+            }
+
+            // Set up timeout calls.
+            Runnable timeout = new Runnable() {
+                @Override
+                public void run() {
+                    MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
+                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(),
+                            MoPubErrorCode.NETWORK_TIMEOUT);
+                    customEvent.onInvalidate();
+                }
+            };
+            mCustomEventTimeoutHandler.postDelayed(timeout, timeoutMillis);
+            mTimeoutMap.put(adUnitId, timeout);
+
+            // Load custom event
+            customEvent.loadCustomEvent(mainActivity, localExtras, adResponse.getServerExtras());
+
+            final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
+                    customEvent.getVideoListenerForSdk();
+            final String adNetworkId = customEvent.getAdNetworkId();
+            mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
+        } catch (Exception e) {
+            MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+        }
+    }
+
+    private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitId) {
+        MoPubErrorCode errorCode = MoPubErrorCode.INTERNAL_ERROR;
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError err = (MoPubNetworkError) volleyError;
+            switch (err.getReason()) {
+                case NO_FILL:
+                case WARMING_UP:
+                    errorCode = MoPubErrorCode.NO_FILL;
+                    break;
+                case BAD_BODY:
+                case BAD_HEADER_DATA:
+                default:
+                    errorCode = MoPubErrorCode.INTERNAL_ERROR;
+            }
+        }
+        if (volleyError instanceof com.mopub.volley.NoConnectionError) {
+            errorCode = MoPubErrorCode.NO_CONNECTION;
+        }
+        failover(adUnitId, errorCode);
+    }
+
+    private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
+        mAdRequestStatus.markFail(adUnitId);
+
+        if (failoverUrl != null) {
+            loadVideo(adUnitId, failoverUrl);
+        } else if (mVideoListener != null) {
+            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
+        }
+    }
+
+    private void cancelTimeouts(@NonNull String moPubId) {
+        final Runnable runnable = mTimeoutMap.remove(moPubId);
+        if (runnable != null) {  // We can't pass null or all callbacks will be removed.
+            mCustomEventTimeoutHandler.removeCallbacks(runnable);
+        }
+    }
+
+    //////// Listener methods that should be called by third-party SDKs. //////////
+
+    /**
+     * Notify the manager that a rewarded video loaded successfully.
+     *
+     * @param customEventClass - the Class of the third-party custom event object.
+     * @param thirdPartyId - the ad id of the third party SDK. This may be an empty String if the
+     *                     SDK does not use ad ids, zone ids, or a analogous concept.
+     * @param <T> - a class that extends {@link CustomEventRewardedVideo}. Only rewarded video
+     *           custom events should use these methods.
+     */
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                sInstance.cancelTimeouts(moPubId);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                   sInstance.cancelTimeouts(moPubId);
+                   sInstance.failover(moPubId, errorCode);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
+                }
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getImpressionTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearImpressionUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
+                }
+            }
+        });
+
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getClickTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearClickUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
+        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
+        postToInstance(new Runnable() {
+            @Override
+            public void run() {
+                final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
+                Set<String> rewarded = new HashSet<String>(moPubIds);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
+                }
+            }
+        });
+    }
+
+    /**
+     * Posts the runnable to the static instance's handler. Does nothing if sInstance is null.
+     * Useful for ensuring that all event callbacks run on the main thread.
+     * The {@link Runnable} can assume that sInstance is non-null.
+     */
+    private static void postToInstance(@NonNull Runnable runnable) {
+        if (sInstance != null) {
+            sInstance.mCallbackHandler.post(runnable);
+        }
+    }
+
+    private static void logErrorNotInitialized() {
+        MoPubLog.e("MoPub rewarded video was not initialized. You must call " +
+                "MoPub.initializeRewardedVideo() before loading or attempting " +
+                "to play video ads.");
+    }
+
+    /**
+     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
+     */
+    private static abstract class ForEachMoPubIdRunnable implements Runnable {
+
+        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
+        @NonNull private final String mThirdPartyId;
+
+        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String thirdPartyId) {
+            Preconditions.checkNotNull(customEventClass);
+            Preconditions.checkNotNull(thirdPartyId);
+            mCustomEventClass = customEventClass;
+            mThirdPartyId = thirdPartyId;
+        }
+
+        protected abstract void forEach(@NonNull final String moPubId);
+
+        @Override
+        public void run() {
+            final Set<String> moPubIds = sInstance.mRewardedVideoData
+                    .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
+            for (String moPubId : moPubIds) {
+                forEach(moPubId);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
index 86aad8f7..ca0f5422 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -6,10 +6,14 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.location.Location;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.View;
 import android.webkit.WebViewDatabase;
 import android.widget.FrameLayout;
+
+import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.ManifestUtils;
@@ -17,11 +21,10 @@
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
-import java.util.*;
+import java.util.Map;
+import java.util.TreeMap;
 
 import static com.mopub.common.LocationService.LocationAwareness;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubView extends FrameLayout {
@@ -33,11 +36,8 @@
         public void onBannerCollapsed(MoPubView banner);
     }
 
-    public static final String HOST = "ads.mopub.com";
-    public static final String HOST_FOR_TESTING = "testing.ads.mopub.com";
-    public static final String AD_HANDLER = "/m/ad";
     public static final int DEFAULT_LOCATION_PRECISION = 6;
-
+    @Nullable
     protected AdViewController mAdViewController;
     protected CustomEventBannerAdapter mCustomEventBannerAdapter;
 
@@ -148,8 +148,11 @@ protected void loadFailUrl(MoPubErrorCode errorCode) {
         if (mAdViewController != null) mAdViewController.loadFailUrl(errorCode);
     }
 
-    protected void loadCustomEvent(Map<String, String> paramsMap) {
-        if (paramsMap == null) {
+    protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+        if (mAdViewController == null) {
+            return;
+        }
+        if (TextUtils.isEmpty(customEventClassName)) {
             MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
             loadFailUrl(ADAPTER_NOT_FOUND);
             return;
@@ -163,8 +166,10 @@ protected void loadCustomEvent(Map<String, String> paramsMap) {
 
         mCustomEventBannerAdapter = CustomEventBannerAdapterFactory.create(
                 this,
-                paramsMap.get(CUSTOM_EVENT_NAME.getKey()),
-                paramsMap.get(CUSTOM_EVENT_DATA.getKey()));
+                customEventClassName,
+                serverExtras,
+                mAdViewController.getBroadcastIdentifier(),
+                mAdViewController.getAdReport());
         mCustomEventBannerAdapter.loadAd();
     }
 
@@ -292,12 +297,18 @@ public String getResponseString() {
         return (mAdViewController != null) ? mAdViewController.getResponseString() : null;
     }
 
+    @Deprecated
     public void setClickthroughUrl(String url) {
-        if (mAdViewController != null) mAdViewController.setClickthroughUrl(url);
+        // Does nothing.
     }
 
+    public String getClickTrackingUrl() {
+        return (mAdViewController != null) ? mAdViewController.getClickTrackingUrl() : null;
+    }
+
+    @Deprecated
     public String getClickthroughUrl() {
-        return (mAdViewController != null) ? mAdViewController.getClickthroughUrl() : null;
+        return getClickTrackingUrl();
     }
 
     public Activity getActivity() {
@@ -317,8 +328,10 @@ public void setLocalExtras(Map<String, Object> localExtras) {
     }
 
     public Map<String, Object> getLocalExtras() {
-        if (mAdViewController != null) return mAdViewController.getLocalExtras();
-        return Collections.emptyMap();
+        if (mAdViewController != null) {
+            return mAdViewController.getLocalExtras();
+        }
+        return new TreeMap<String, Object>();
     }
 
     public void setAutorefreshEnabled(boolean enabled) {
@@ -366,6 +379,10 @@ AdViewController getAdViewController() {
         return mAdViewController;
     }
 
+    public AdFormat getAdFormat() {
+        return AdFormat.BANNER;
+    }
+
     @Deprecated
     public void setLocationAwareness(LocationAwareness locationAwareness) {
         MoPub.setLocationAwareness(locationAwareness.getNewLocationAwareness());
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
index ac5dedce..62bf5b27 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
@@ -1,163 +1,199 @@
 package com.mopub.mobileads;
 
-import android.annotation.TargetApi;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.View;
 import android.view.WindowManager;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
-import com.mopub.mobileads.MraidView.ExpansionStyle;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.MraidViewFactory;
-import com.mopub.mobileads.util.WebViews;
-
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.MraidController.MraidListener;
+import com.mopub.mraid.MraidController.UseCustomCloseListener;
+import com.mopub.mraid.MraidWebViewDebugListener;
+import com.mopub.mraid.PlacementType;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidActivity extends BaseInterstitialActivity {
-    private MraidView mMraidView;
+    @Nullable private MraidController mMraidController;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
 
-    static void preRenderHtml(final Context context, final CustomEventInterstitial.CustomEventInterstitialListener customEventInterstitialListener, final String htmlData) {
-        MraidView dummyMraidView = MraidViewFactory.create(context, null, ExpansionStyle.DISABLED, NativeCloseButtonStyle.ALWAYS_VISIBLE, PlacementType.INTERSTITIAL);
+    public static void preRenderHtml(@NonNull final Context context,
+            @NonNull final CustomEventInterstitialListener customEventInterstitialListener,
+            @NonNull final String htmlData) {
+        BaseWebView dummyWebView = new BaseWebView(context);
 
-        dummyMraidView.enablePlugins(false);
-        dummyMraidView.setMraidListener(new MraidView.MraidListener() {
+        dummyWebView.enablePlugins(false);
+        dummyWebView.setWebViewClient(new WebViewClient() {
             @Override
-            public void onReady(MraidView view) {
+            public void onPageFinished(final WebView view, final String url) {
                 customEventInterstitialListener.onInterstitialLoaded();
             }
 
-            @Override
-            public void onFailure(MraidView view) {
-                customEventInterstitialListener.onInterstitialFailed(null);
-            }
-
-            @Override
-            public void onExpand(MraidView view) {
-            }
-
-            @Override
-            public void onOpen(MraidView view) {
-            }
-
-            @Override
-            public void onClose(MraidView view, MraidView.ViewState newViewState) {
-            }
-        });
-        dummyMraidView.setWebViewClient(new WebViewClient() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 return true;
             }
 
             @Override
-            public void onPageFinished(WebView view, String url) {
-                customEventInterstitialListener.onInterstitialLoaded();
+            public void onReceivedError(final WebView view, final int errorCode,
+                    final String description,
+                    final String failingUrl) {
+                super.onReceivedError(view, errorCode, description, failingUrl);
+                customEventInterstitialListener.onInterstitialFailed(
+                        MoPubErrorCode.MRAID_LOAD_ERROR);
             }
         });
-        dummyMraidView.loadHtmlData(htmlData);
+
+        dummyWebView.loadDataWithBaseURL(null, htmlData, "text/html", "UTF-8", null);
     }
 
-    public static void start(Context context, String htmlData, AdConfiguration adConfiguration) {
-        Intent intent = createIntent(context, htmlData, adConfiguration);
+    public static void start(@NonNull Context context, @Nullable AdReport adreport, @NonNull String htmlData, long broadcastIdentifier) {
+        Intent intent = createIntent(context, adreport, htmlData, broadcastIdentifier);
         try {
             context.startActivity(intent);
-        } catch (ActivityNotFoundException anfe) {
+        } catch (ActivityNotFoundException exception) {
             Log.d("MraidInterstitial", "MraidActivity.class not found. Did you declare MraidActivity in your manifest?");
         }
     }
 
-    private static Intent createIntent(Context context, String htmlData, AdConfiguration adConfiguration) {
+    @VisibleForTesting
+    protected static Intent createIntent(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull String htmlData, long broadcastIdentifier) {
         Intent intent = new Intent(context, MraidActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
     @Override
     public View getAdView() {
-        mMraidView = MraidViewFactory.create(this, getAdConfiguration(), ExpansionStyle.DISABLED, NativeCloseButtonStyle.AD_CONTROLLED, PlacementType.INTERSTITIAL);
+        String htmlData = getIntent().getStringExtra(HTML_RESPONSE_BODY_KEY);
+        if (htmlData == null) {
+            MoPubLog.w("MraidActivity received a null HTML body. Finishing the activity.");
+            finish();
+            return new View(this);
+        }
 
-        mMraidView.setMraidListener(new MraidView.BaseMraidListener(){
-            public void onReady(MraidView view) {
-                mMraidView.loadUrl(WEB_VIEW_DID_APPEAR.getUrl());
-                showInterstitialCloseButton();
+        mMraidController = new MraidController(
+                this, mAdReport, PlacementType.INTERSTITIAL);
+
+        mMraidController.setDebugListener(mDebugListener);
+        mMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // This is only done for the interstitial. Banners have a different mechanism
+                // for tracking third party impressions.
+                mMraidController.loadJavascript(WEB_VIEW_DID_APPEAR.getJavascript());
             }
 
             @Override
-            public void onOpen(MraidView view) {
-                broadcastAction(MraidActivity.this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_CLICK);
+            public void onFailedToLoad() {
+                MoPubLog.d("MraidActivity failed to load. Finishing the activity");
+                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_FAIL);
+                finish();
             }
 
-            public void onClose(MraidView view, ViewState newViewState) {
-                mMraidView.loadUrl(WEB_VIEW_DID_CLOSE.getUrl());
+            public void onClose() {
+                mMraidController.loadJavascript(WEB_VIEW_DID_CLOSE.getJavascript());
                 finish();
             }
+
+            @Override
+            public void onExpand() {
+                // No-op. The interstitial is always expanded.
+            }
+
+            @Override
+            public void onOpen() {
+                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_CLICK);
+            }
         });
 
-        mMraidView.setOnCloseButtonStateChange(new MraidView.OnCloseButtonStateChangeListener() {
-            public void onCloseButtonStateChange(MraidView view, boolean enabled) {
-                if (enabled) {
-                    showInterstitialCloseButton();
-                } else {
+        // Needed because the Activity provides the close button, not the controller. This
+        // gets called if the creative calls mraid.useCustomClose.
+        mMraidController.setUseCustomCloseListener(new UseCustomCloseListener() {
+            public void useCustomCloseChanged(boolean useCustomClose) {
+                if (useCustomClose) {
                     hideInterstitialCloseButton();
+                } else {
+                    showInterstitialCloseButton();
                 }
             }
         });
 
-        String source = getIntent().getStringExtra(HTML_RESPONSE_BODY_KEY);
-        mMraidView.loadHtmlData(source);
-
-        return mMraidView;
+        mMraidController.loadContent(htmlData);
+        return mMraidController.getAdContainer();
     }
 
-    @TargetApi(11)
     @Override
-    public void onCreate(Bundle savedInstanceState) {
+    public void onCreate(@Nullable Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
 
-        if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
+        if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
             getWindow().setFlags(
                     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
                     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         }
-
-        addCloseEventRegion();
     }
 
     @Override
     protected void onPause() {
+        if (mMraidController != null) {
+            mMraidController.pause(isFinishing());
+        }
         super.onPause();
-        WebViews.onPause(mMraidView);
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        WebViews.onResume(mMraidView);
+        if (mMraidController != null) {
+            mMraidController.resume();
+        }
     }
 
     @Override
     protected void onDestroy() {
-        mMraidView.destroy();
+        if (mMraidController != null) {
+            mMraidController.destroy();
+        }
+
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_DISMISS);
         super.onDestroy();
     }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mMraidController != null) {
+            mMraidController.setDebugListener(debugListener);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
index 7c9a2202..8fa79451 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
@@ -4,18 +4,21 @@
 import android.content.ActivityNotFoundException;
 import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
 
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.Intents;
+import com.mopub.mraid.MraidVideoViewController;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidVideoPlayerActivity extends BaseVideoPlayerActivity implements BaseVideoViewController.BaseVideoViewControllerListener {
-    private BaseVideoViewController mBaseVideoController;
+    @Nullable private BaseVideoViewController mBaseVideoController;
     private long mBroadcastIdentifier;
 
     @Override
@@ -25,16 +28,14 @@ protected void onCreate(Bundle savedInstanceState) {
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        final AdConfiguration adConfiguration = getAdConfiguration();
-        if (adConfiguration != null) {
-            mBroadcastIdentifier = adConfiguration.getBroadcastIdentifier();
-        } else {
-            MoPubLog.d("Unable to obtain broadcast identifier. Video interactions cannot be tracked.");
-        }
+        mBroadcastIdentifier = getBroadcastIdentifierFromIntent(getIntent());
 
         try {
             mBaseVideoController = createVideoViewController();
         } catch (IllegalStateException e) {
+            // This can happen if the activity was started without valid intent extras. We leave
+            // mBaseVideoController set to null, and finish the activity immediately.
+            
             broadcastAction(this, mBroadcastIdentifier, ACTION_INTERSTITIAL_FAIL);
             finish();
             return;
@@ -45,42 +46,40 @@ protected void onCreate(Bundle savedInstanceState) {
 
     @Override
     protected void onPause() {
-        mBaseVideoController.onPause();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onPause();
+        }
         super.onPause();
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        mBaseVideoController.onResume();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onResume();
+        }
     }
 
     @Override
     protected void onDestroy() {
-        mBaseVideoController.onDestroy();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onDestroy();
+        }
         super.onDestroy();
     }
 
     @Override
     public void onBackPressed() {
-        if (mBaseVideoController.backButtonEnabled()) {
+        if (mBaseVideoController != null && mBaseVideoController.backButtonEnabled()) {
             super.onBackPressed();
         }
     }
 
     @Override
     protected void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
-        mBaseVideoController.onActivityResult(requestCode, resultCode, data);
-    }
-
-    private AdConfiguration getAdConfiguration() {
-        AdConfiguration adConfiguration;
-        try {
-            adConfiguration = (AdConfiguration) getIntent().getSerializableExtra(AdFetcher.AD_CONFIGURATION_KEY);
-        } catch (ClassCastException e) {
-            adConfiguration = null;
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onActivityResult(requestCode, resultCode, data);
         }
-        return adConfiguration;
     }
 
     private BaseVideoViewController createVideoViewController() throws IllegalStateException {
@@ -89,7 +88,7 @@ private BaseVideoViewController createVideoViewController() throws IllegalStateE
         if ("vast".equals(clazz)) {
             return new VastVideoViewController(this, getIntent().getExtras(), mBroadcastIdentifier, this);
         } else if ("mraid".equals(clazz)) {
-            return new MraidVideoViewController(this, getIntent().getExtras(), mBroadcastIdentifier, this);
+            return new MraidVideoViewController(this, getIntent().getExtras(), this);
         } else {
             throw new IllegalStateException("Unsupported video type: " + clazz);
         }
@@ -122,7 +121,7 @@ public void onStartActivityForResult(final Class<? extends Activity> clazz,
             return;
         }
 
-        final Intent intent = IntentUtils.getStartActivityIntent(this, clazz, extras);
+        final Intent intent = Intents.getStartActivityIntent(this, clazz, extras);
 
         try {
             startActivityForResult(intent, requestCode);
@@ -131,6 +130,10 @@ public void onStartActivityForResult(final Class<? extends Activity> clazz,
         }
     }
 
+    protected static long getBroadcastIdentifierFromIntent(Intent intent) {
+        return intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1);
+    }
+
     @Deprecated // for testing
     BaseVideoViewController getBaseVideoViewController() {
         return mBaseVideoController;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
new file mode 100644
index 00000000..2c26fa69
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
@@ -0,0 +1,57 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * A generic runnable that handles scheduling itself periodically on a Handler and stops when
+ * requested.
+ */
+public abstract class RepeatingHandlerRunnable implements Runnable {
+    @NonNull protected final Handler mHandler;
+    private volatile boolean mIsRunning;
+    private volatile long mUpdateIntervalMillis;
+
+    RepeatingHandlerRunnable(@NonNull final Handler handler) {
+        Preconditions.checkNotNull(handler);
+        mHandler = handler;
+    }
+
+    @Override
+    public void run() {
+        if (mIsRunning) {
+            doWork();
+            mHandler.postDelayed(this, mUpdateIntervalMillis);
+        }
+    }
+
+    public abstract void doWork();
+
+    /**
+     * Start this runnable immediately, repeating at the provided interval.
+     */
+    public void startRepeating(long intervalMillis) {
+        Preconditions.checkArgument(intervalMillis > 0, "intervalMillis must be greater than 0. " +
+                "Saw: %d", intervalMillis);
+        mUpdateIntervalMillis = intervalMillis;
+        if (!mIsRunning) {
+            mIsRunning = true;
+            mHandler.post(this);
+        }
+    }
+
+    /**
+     * Stop this repeating runnable.
+     */
+    public void stop() {
+        mIsRunning = false;
+    }
+
+    @VisibleForTesting
+    boolean shouldBeRunning() {
+        return mIsRunning;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
index 2d73912e..a6b3c625 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
@@ -2,23 +2,28 @@
 
 import android.content.Context;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.logging.MoPubLog;
+
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
-abstract class ResponseBodyInterstitial extends CustomEventInterstitial {
+public abstract class ResponseBodyInterstitial extends CustomEventInterstitial {
     private EventForwardingBroadcastReceiver mBroadcastReceiver;
     protected Context mContext;
-    protected AdConfiguration mAdConfiguration;
-    long mBroadcastIdentifier;
+    protected AdReport mAdReport;
+    protected long mBroadcastIdentifier;
 
     abstract protected void extractExtras(Map<String, String> serverExtras);
     abstract protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener);
-    abstract protected void showInterstitial();
+    public abstract void showInterstitial();
 
     @Override
-    protected void loadInterstitial(
+    public void loadInterstitial(
             Context context,
             CustomEventInterstitialListener customEventInterstitialListener,
             Map<String, Object> localExtras,
@@ -33,19 +38,31 @@ protected void loadInterstitial(
             return;
         }
 
-        mAdConfiguration = AdConfiguration.extractFromMap(localExtras);
-        if (mAdConfiguration != null) {
-            mBroadcastIdentifier = mAdConfiguration.getBroadcastIdentifier();
+
+        try {
+            mAdReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            Long boxedBroadcastId = (Long) localExtras.get(BROADCAST_IDENTIFIER_KEY);
+            if (boxedBroadcastId == null) {
+                MoPubLog.e("Broadcast Identifier was not set in localExtras");
+                customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                return;
+            }
+            mBroadcastIdentifier = boxedBroadcastId;
+        } catch (ClassCastException e) {
+            MoPubLog.e("LocalExtras contained an incorrect type.");
+            customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+            return;
         }
 
-        mBroadcastReceiver = new EventForwardingBroadcastReceiver(customEventInterstitialListener, mBroadcastIdentifier);
+        mBroadcastReceiver = new EventForwardingBroadcastReceiver(customEventInterstitialListener,
+                mBroadcastIdentifier);
         mBroadcastReceiver.register(context);
 
         preRenderHtml(customEventInterstitialListener);
     }
 
     @Override
-    protected void onInvalidate() {
+    public void onInvalidate() {
         if (mBroadcastReceiver != null) {
             mBroadcastReceiver.unregister();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java
new file mode 100644
index 00000000..c3d45cec
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java
@@ -0,0 +1,118 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Pair;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+/**
+ * Used to manage the mapping between MoPub ad unit ids and third-party ad network ids for rewarded videos.
+ */
+class RewardedVideoData {
+    @NonNull
+    private final Map<String, CustomEventRewardedVideo> mAdUnitToCustomEventMap;
+    @NonNull
+    private final Map<TwoPartKey, Set<String>> mCustomEventToMoPubIdMap;
+    @NonNull
+    private final Set<CustomEventRewardedVideo.CustomEventRewardedVideoListener> mAdNetworkListeners;
+
+    RewardedVideoData() {
+        mAdUnitToCustomEventMap = new TreeMap<String, CustomEventRewardedVideo>();
+        mCustomEventToMoPubIdMap = new HashMap<TwoPartKey, Set<String>>();
+        mAdNetworkListeners = new HashSet<CustomEventRewardedVideo.CustomEventRewardedVideoListener>();
+    }
+
+    @Nullable
+    CustomEventRewardedVideo getCustomEvent(@NonNull String moPubId) {
+        return mAdUnitToCustomEventMap.get(moPubId);
+    }
+
+    @NonNull
+    Set<String> getMoPubIdsForAdNetwork(
+            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @Nullable String adNetworkId) {
+        if (adNetworkId == null) {
+            final Set<String> allIds = new HashSet<String>();
+            for (final Map.Entry<TwoPartKey, Set<String>> entry : mCustomEventToMoPubIdMap.entrySet()) {
+                final Class<?> clazz = entry.getKey().customEventClass;
+                if (customEventClass == clazz) {
+                    allIds.addAll(entry.getValue());
+                }
+            }
+            return allIds;
+        } else {
+            final TwoPartKey key = new TwoPartKey(customEventClass, adNetworkId);
+            return mCustomEventToMoPubIdMap.containsKey(key)
+                    ? mCustomEventToMoPubIdMap.get(key)
+                    : Collections.<String>emptySet();
+        }
+    }
+
+    void updateAdUnitCustomEventMapping(
+            @NonNull String moPubId,
+            @NonNull CustomEventRewardedVideo customEvent,
+            @Nullable CustomEventRewardedVideo.CustomEventRewardedVideoListener listener,
+            @NonNull String adNetworkId) {
+        mAdUnitToCustomEventMap.put(moPubId, customEvent);
+        mAdNetworkListeners.add(listener);
+        associateCustomEventWithMoPubId(customEvent.getClass(), adNetworkId, moPubId);
+    }
+
+    void associateCustomEventWithMoPubId(
+            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @NonNull String adNetworkId,
+            @NonNull String moPubId) {
+        final TwoPartKey newCustomEventMapping = new TwoPartKey(customEventClass, adNetworkId);
+
+        // Remove previous mapping for this moPubId
+        final Iterator<Map.Entry<TwoPartKey, Set<String>>> entryIterator =
+                mCustomEventToMoPubIdMap.entrySet().iterator();
+        while (entryIterator.hasNext()) {
+            final Map.Entry<TwoPartKey, Set<String>> entry = entryIterator.next();
+
+            if (!entry.getKey().equals(newCustomEventMapping)) {
+                if (entry.getValue().contains(moPubId)) {
+                    entry.getValue().remove(moPubId);
+                    // Ensure that entries containing empty Sets are completely removed from the Map
+                    if (entry.getValue().isEmpty()) {
+                        entryIterator.remove();
+                    }
+
+                    // moPubIds can exist at most once in the Map values, so break upon finding a match
+                    break;
+                }
+            }
+        }
+
+        // Add a new mapping if necessary.
+        Set<String> moPubIds = mCustomEventToMoPubIdMap.get(newCustomEventMapping);
+        if (moPubIds == null) {
+            moPubIds = new HashSet<String>();
+            mCustomEventToMoPubIdMap.put(newCustomEventMapping, moPubIds);
+        }
+        moPubIds.add(moPubId);
+    }
+
+    private static class TwoPartKey extends Pair<Class<? extends CustomEventRewardedVideo>, String> {
+        @NonNull
+        final Class<? extends CustomEventRewardedVideo> customEventClass;
+        @NonNull
+        final String adNetworkId;
+
+        public TwoPartKey(
+                @NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String adNetworkId) {
+            super(customEventClass, adNetworkId);
+
+            this.customEventClass = customEventClass;
+            this.adNetworkId = adNetworkId;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
index 382b0e03..df1fd823 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
@@ -1,6 +1,7 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.Drawable;
 import android.text.TextUtils;
@@ -11,10 +12,13 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.util.Dips;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.resource.TextDrawable;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
@@ -105,6 +109,7 @@ ToolbarWidget build() {
 
     private TextView mTextView;
     private ImageView mImageView;
+    private final ImageLoader mImageLoader;
 
     private static final int TEXT_PADDING_DIPS = 5;
     private static final int IMAGE_PADDING_DIPS = 5;
@@ -125,6 +130,8 @@ private ToolbarWidget(Builder builder) {
         mImagePadding = Dips.dipsToIntPixels(IMAGE_PADDING_DIPS, getContext());
         mImageSideLength = Dips.dipsToIntPixels(IMAGE_SIDE_LENGTH_DIPS, getContext());
 
+        mImageLoader = Networking.getImageLoader(getContext());
+
         setVisibility(builder.visibility);
 
         if (builder.hasDrawable) {
@@ -188,13 +195,48 @@ void updateImageText(final String text) {
         }
     }
 
+    void updateImage(final String imageUrl) {
+        mImageLoader.get(imageUrl, new ImageLoader.ImageListener() {
+            @Override
+            public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                    final boolean isImmediate) {
+                Bitmap bitmap = imageContainer.getBitmap();
+                if (bitmap != null) {
+                    mImageView.setImageBitmap(bitmap);
+                } else {
+                    MoPubLog.d(String.format("%s returned null bitmap", imageUrl));
+                }
+            }
+
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to load image.", volleyError);
+            }
+        });
+    }
+
+    @Deprecated // for testing
+    ImageView getImageView() {
+        return mImageView;
+    }
+
+    @Deprecated // for testing
+    void setImageView(ImageView imageView) {
+        mImageView = imageView;
+    }
+
+    @Deprecated // for testing
+    Drawable getImageViewDrawable() {
+        return mImageView.getDrawable();
+    }
+
     @Deprecated // for testing
-    TextDrawable getImageViewDrawable() {
-        return (TextDrawable) mImageView.getDrawable();
+    void setImageViewDrawable(Drawable drawable) {
+        mImageView.setImageDrawable(drawable);
     }
 
     @Deprecated // for testing
-    void setImageViewDrawable(TextDrawable drawable) {
-        mImageView.setImageDrawable((Drawable) drawable);
+    String getTextViewText() {
+        return mTextView.getText().toString();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
new file mode 100644
index 00000000..63fd8513
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with an "absolute" trigger threshold. The tracker should be triggered
+ * after a fixed number of milliseconds have been played.
+ */
+public class VastAbsoluteProgressTracker extends VastTracker implements Comparable<VastAbsoluteProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final int mTrackingMilliseconds;
+
+    public VastAbsoluteProgressTracker(@NonNull final String trackingUrl, int trackingMilliseconds) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingMilliseconds >= 0);
+        mTrackingMilliseconds = trackingMilliseconds;
+    }
+
+    public int getTrackingMilliseconds() {
+        return mTrackingMilliseconds;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastAbsoluteProgressTracker other) {
+        int you = other.getTrackingMilliseconds();
+        int me = getTrackingMilliseconds();
+
+        return me - you;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%dms: %s", mTrackingMilliseconds, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
new file mode 100644
index 00000000..824f9516
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with a "fractional" tracking threshold on the interval [0.0, 1.0].
+ * The tracker should be triggered after the given fraction of the video has been played.
+ */
+public class VastFractionalProgressTracker extends VastTracker implements Comparable<VastFractionalProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final float mFraction;
+
+    public VastFractionalProgressTracker(@NonNull final String trackingUrl, float trackingFraction) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingFraction >= 0);
+        mFraction = trackingFraction;
+    }
+
+    public float trackingFraction() {
+        return mFraction;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastFractionalProgressTracker other) {
+        float you = other.trackingFraction();
+        float me = trackingFraction();
+
+        return Double.compare(me, you);
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%2f: %s", mFraction, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
new file mode 100644
index 00000000..36f07711
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
@@ -0,0 +1,35 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+
+/**
+ * State encapsulation for VAST tracking URLs that should only be called once. For example, progress
+ * trackers are only called once.
+ */
+public class VastTracker implements Serializable {
+    private static final long serialVersionUID = 0L;
+    @NonNull protected final String mTrackingUrl;
+    private boolean mCalled;
+
+    public VastTracker(@NonNull String trackingUrl) {
+        Preconditions.checkNotNull(trackingUrl);
+        mTrackingUrl = trackingUrl;
+    }
+
+    @NonNull
+    public String getTrackingUrl() {
+        return mTrackingUrl;
+    }
+
+    public void setTracked() {
+        mCalled = true;
+    }
+
+    public boolean isTracked() {
+        return mCalled;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
index 778d7de1..9077525a 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
@@ -37,7 +37,7 @@ protected Boolean doInBackground(final String... params) {
         AndroidHttpClient httpClient = null;
         try {
             httpClient = HttpClient.getHttpClient();
-            final HttpGet httpget = new HttpGet(videoUrl);
+            final HttpGet httpget = HttpClient.initializeHttpGet(videoUrl);
             final HttpResponse response = httpClient.execute(httpget);
 
             if (response == null || response.getEntity() == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
index b96d0f89..3ca5a8d3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
@@ -1,8 +1,7 @@
 package com.mopub.mobileads;
 
-import android.net.Uri;
-
 import com.mopub.common.CacheService;
+import com.mopub.common.DataKeys;
 import com.mopub.mobileads.factories.VastManagerFactory;
 import com.mopub.mobileads.util.vast.VastManager;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
@@ -17,7 +16,7 @@
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
-        mVastResponse = Uri.decode(serverExtras.get(AdFetcher.HTML_RESPONSE_BODY_KEY));
+        mVastResponse = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
     }
 
     @Override
@@ -34,12 +33,12 @@ protected void preRenderHtml(CustomEventInterstitialListener customEventIntersti
     }
 
     @Override
-    protected void showInterstitial() {
-        MraidVideoPlayerActivity.startVast(mContext, mVastVideoConfiguration, mAdConfiguration);
+    public void showInterstitial() {
+        MraidVideoPlayerActivity.startVast(mContext, mVastVideoConfiguration, mBroadcastIdentifier);
     }
 
     @Override
-    protected void onInvalidate() {
+    public void onInvalidate() {
         if (mVastManager != null) {
             mVastManager.cancel();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
index 2d4431bf..cb89e081 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
@@ -6,6 +6,7 @@
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.resource.CloseButtonDrawable;
@@ -16,7 +17,7 @@
 import static android.view.Gravity.CENTER_VERTICAL;
 import static android.view.Gravity.LEFT;
 import static android.view.Gravity.RIGHT;
-import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 
 class VastVideoToolbar extends LinearLayout {
     private static final int TOOLBAR_HEIGHT_DIPS = 44;
@@ -42,7 +43,7 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
 
         final int videoToolbarHeight = Dips.dipsToIntPixels(TOOLBAR_HEIGHT_DIPS, getContext());
         final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
-                FILL_PARENT,
+                MATCH_PARENT,
                 videoToolbarHeight);
         setLayoutParams(layoutParams);
 
@@ -60,25 +61,59 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         addView(mCloseButtonWidget);
     }
 
-    String getDisplaySeconds(final long millisecondsRemaining) {
-        return String.valueOf(Math.round(Math.ceil(millisecondsRemaining / 1000f)));
+    /**
+     * Rounds up to the nearest full second. Formally, this is the long
+     * closest to negative infinity above or equal to millis, in milliseconds,
+     * converted to seconds.
+     *
+     * @param millis Time in milliseconds
+     * @return Time in seconds, rounded up.
+     */
+    @VisibleForTesting
+    long convertMillisecondsToSecondsRoundedUp(final long millis) {
+        return Math.round(Math.ceil(millis / 1000f));
     }
 
+    @VisibleForTesting
     void updateDurationWidget(final int remainingTime) {
         if (remainingTime >= THRESHOLD_FOR_HIDING_VIDEO_DURATION) {
-            mDurationWidget.updateText("Ends in " + getDisplaySeconds(remainingTime) + " seconds");
+            mDurationWidget.updateText("Ends in " + formatTime(remainingTime));
         } else if (remainingTime >= 0) {
             mDurationWidget.updateText("Thanks for watching");
         }
     }
 
+    @VisibleForTesting
+    String formatTime(final long milliseconds) {
+        final long seconds = convertMillisecondsToSecondsRoundedUp(milliseconds);
+
+        if (seconds == 1) {
+            return "1 second";
+        } else {
+            return String.valueOf(seconds) + " seconds";
+        }
+    }
+
     void updateCountdownWidget(final int remainingTime) {
         if (remainingTime >= 0 && mCountdownWidget.getVisibility() == View.INVISIBLE) {
             mCloseButtonWidget.setVisibility(View.GONE);
             mCountdownWidget.setVisibility(View.VISIBLE);
         }
 
-        mCountdownWidget.updateImageText(getDisplaySeconds(remainingTime));
+        mCountdownWidget.updateImageText(String.valueOf(convertMillisecondsToSecondsRoundedUp(
+                remainingTime)));
+    }
+
+    void updateLearnMoreButtonText(final String customCtaText) {
+        mLearnMoreWidget.updateText(customCtaText);
+    }
+
+    void updateCloseButtonText(final String customSkipText) {
+        mCloseButtonWidget.updateText(customSkipText);
+    }
+
+    void updateCloseButtonIcon(final String customCloseIconUrl) {
+        mCloseButtonWidget.updateImage(customCloseIconUrl);
     }
 
     void makeInteractable() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index c73582b5..0125daa1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -11,49 +11,63 @@
 import android.media.MediaPlayer;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.DownloadTask;
 import com.mopub.common.HttpResponses;
 import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Drawables;
 import com.mopub.common.util.Streams;
+import com.mopub.common.util.Strings;
 import com.mopub.common.util.VersionCode;
 import com.mopub.mobileads.util.vast.VastCompanionAd;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.TrackingRequest;
+
 import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
 
-import java.io.*;
-import java.util.*;
-import java.util.concurrent.*;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
 import static com.mopub.common.HttpClient.initializeHttpGet;
-import static com.mopub.common.HttpClient.makeTrackingHttpRequest;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
 
 public class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {
     static final String VAST_VIDEO_CONFIGURATION = "vast_video_configuration";
 
-    private static final float FIRST_QUARTER_MARKER = 0.25f;
-    private static final float MID_POINT_MARKER = 0.50f;
-    private static final float THIRD_QUARTER_MARKER = 0.75f;
     private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
+    private static final long VIDEO_COUNTDOWN_UPDATE_INTERVAL = 250;
     private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
     private static final int MAX_VIDEO_RETRIES = 1;
     private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
 
-    private static final ThreadPoolExecutor sThreadPoolExecutor = new ThreadPoolExecutor(10, 50, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
     static final int DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON = 5 * 1000;
     static final int MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON = 16 * 1000;
 
@@ -64,28 +78,27 @@
     private final ImageView mCompanionAdImageView;
     private final View.OnTouchListener mClickThroughListener;
 
-    private final Handler mHandler;
-    private final Runnable mVideoProgressCheckerRunnable;
-    private boolean mIsVideoProgressShouldBeChecked;
+    private final VastVideoViewProgressRunnable mProgressCheckerRunnable;
+    private final VastVideoViewCountdownRunnable mCountdownRunnable;
     private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 
     private boolean mShowCloseButtonEventFired;
-    private boolean mIsStartMarkHit;
-    private boolean mIsFirstMarkHit;
-    private boolean mIsSecondMarkHit;
-    private boolean mIsThirdMarkHit;
+
     private int mSeekerPositionOnPause;
     private boolean mIsVideoFinishedPlaying;
     private int mVideoRetries;
 
+    private boolean mVideoError;
+    private boolean mCompletionTrackerFired;
+
+    private boolean mHasSkipOffset = false;
+
     VastVideoViewController(final Context context,
             final Bundle bundle,
             final long broadcastIdentifier,
             final BaseVideoViewControllerListener baseVideoViewControllerListener)
             throws IllegalStateException {
         super(context, broadcastIdentifier, baseVideoViewControllerListener);
-        mHandler = new Handler();
-        mIsVideoProgressShouldBeChecked = false;
         mSeekerPositionOnPause = -1;
         mVideoRetries = 0;
 
@@ -125,32 +138,51 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
 
         mCompanionAdImageView = createCompanionAdImageView(context);
 
-        makeTrackingHttpRequest(mVastVideoConfiguration.getImpressionTrackers(), context);
-
-        mVideoProgressCheckerRunnable = createVideoProgressCheckerRunnable();
+        Handler mainHandler = new Handler(Looper.getMainLooper());
+        mProgressCheckerRunnable = new VastVideoViewProgressRunnable(this, mainHandler);
+        mCountdownRunnable = new VastVideoViewCountdownRunnable(this, mainHandler);
     }
 
     @Override
-    VideoView getVideoView() {
+    protected VideoView getVideoView() {
         return mVideoView;
     }
 
     @Override
-    void onCreate() {
+    protected void onCreate() {
         super.onCreate();
-        getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
 
-        broadcastAction(ACTION_INTERSTITIAL_SHOW);
+        switch (mVastVideoConfiguration.getCustomForceOrientation()) {
+            case FORCE_PORTRAIT:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+                break;
+            case FORCE_LANDSCAPE:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+                break;
+            case DEVICE_ORIENTATION:
+                break;  // don't do anything
+            case UNDEFINED:
+                break;  // don't do anything
+            default:
+                break;
+        }
 
         downloadCompanionAd();
+
+        makeTrackingHttpRequest(
+                mVastVideoConfiguration.getImpressionTrackers(),
+                getContext(),
+                BaseEvent.Name.IMPRESSION_REQUEST
+        );
+        broadcastAction(ACTION_INTERSTITIAL_SHOW);
     }
 
     @Override
-    void onResume() {
+    protected void onResume() {
         // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
         // and therefore reset the count to zero, to let it retry on error
         mVideoRetries = 0;
-        startProgressChecker();
+        startRunnables();
 
         mVideoView.seekTo(mSeekerPositionOnPause);
         if (!mIsVideoFinishedPlaying) {
@@ -159,21 +191,21 @@ void onResume() {
     }
 
     @Override
-    void onPause() {
-        stopProgressChecker();
-        mSeekerPositionOnPause = mVideoView.getCurrentPosition();
+    protected void onPause() {
+        stopRunnables();
+        mSeekerPositionOnPause = getCurrentPosition();
         mVideoView.pause();
     }
 
     @Override
-    void onDestroy() {
-        stopProgressChecker();
+    protected void onDestroy() {
+        stopRunnables();
         broadcastAction(ACTION_INTERSTITIAL_DISMISS);
     }
 
     // Enable the device's back button when the video close button has been displayed
     @Override
-    boolean backButtonEnabled() {
+    public boolean backButtonEnabled() {
         return mShowCloseButtonEventFired;
     }
 
@@ -227,61 +259,95 @@ private void downloadCompanionAd() {
         }
     }
 
-    private Runnable createVideoProgressCheckerRunnable() {
-        return new Runnable() {
-            @Override
-            public void run() {
-                float videoLength = mVideoView.getDuration();
-                float currentPosition = mVideoView.getCurrentPosition();
-
-                if (videoLength > 0) {
-                    float progressPercentage = currentPosition / videoLength;
-
-                    if (!mIsStartMarkHit && currentPosition >= 1000) {
-                        mIsStartMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getStartTrackers(), getContext());
-                    }
-
-                    if (!mIsFirstMarkHit && progressPercentage > FIRST_QUARTER_MARKER) {
-                        mIsFirstMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getFirstQuartileTrackers(), getContext());
-                    }
-
-                    if (!mIsSecondMarkHit && progressPercentage > MID_POINT_MARKER) {
-                        mIsSecondMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getMidpointTrackers(), getContext());
-                    }
+    private void adjustSkipOffset() {
+        int videoDuration = getDuration();
 
-                    if (!mIsThirdMarkHit && progressPercentage > THIRD_QUARTER_MARKER) {
-                        mIsThirdMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getThirdQuartileTrackers(), getContext());
-                    }
+        // Default behavior: video is non-skippable if duration < 16 seconds
+        if (videoDuration < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
+            mShowCloseButtonDelay = videoDuration;
+        }
 
-                    if (isLongVideo(mVideoView.getDuration()) ) {
-                        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - mVideoView.getCurrentPosition());
+        // Override if skipoffset attribute is specified in VAST
+        String skipOffsetString = mVastVideoConfiguration.getSkipOffset();
+        if (skipOffsetString != null) {
+            try {
+                if (Strings.isAbsoluteTracker(skipOffsetString)) {
+                    Integer skipOffsetMilliseconds = Strings.parseAbsoluteOffset(skipOffsetString);
+                    if (skipOffsetMilliseconds != null && skipOffsetMilliseconds < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMilliseconds;
+                        mHasSkipOffset = true;
                     }
-
-                    if (shouldBeInteractable()) {
-                        makeVideoInteractable();
+                } else if (Strings.isPercentageTracker(skipOffsetString)) {
+                    float percentage = Float.parseFloat(skipOffsetString.replace("%", "")) / 100f;
+                    int skipOffsetMillisecondsRounded = Math.round(videoDuration * percentage);
+                    if (skipOffsetMillisecondsRounded < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMillisecondsRounded;
+                        mHasSkipOffset = true;
                     }
+                } else {
+                    MoPubLog.d(String.format("Invalid VAST skipoffset format: %s", skipOffsetString));
                 }
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Failed to parse skipoffset %s", skipOffsetString));
+            }
+        }
+    }
 
-                mVastVideoToolbar.updateDurationWidget(mVideoView.getDuration() - mVideoView.getCurrentPosition());
+    /**
+     * Returns untriggered VAST progress trackers with a progress before the provided position.
+     *
+     * @param currentPositionMillis the current video position in milliseconds.
+     * @param videoLengthMillis the total video length.
+     */
+    @NonNull
+    List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
+        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
+            float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
+            List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
+
+            final ArrayList<VastAbsoluteProgressTracker> absoluteTrackers = mVastVideoConfiguration.getAbsoluteTrackers();
+            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
+            int absoluteTrackerCount = absoluteTrackers.size();
+            for (int i = 0; i < absoluteTrackerCount; i++) {
+                VastAbsoluteProgressTracker tracker = absoluteTrackers.get(i);
+                if (tracker.compareTo(absoluteTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
 
-                if (mIsVideoProgressShouldBeChecked) {
-                    mHandler.postDelayed(mVideoProgressCheckerRunnable, VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
+            final ArrayList<VastFractionalProgressTracker> fractionalTrackers = mVastVideoConfiguration.getFractionalTrackers();
+            final VastFractionalProgressTracker fractionalTest = new VastFractionalProgressTracker("", progressFraction);
+            int fractionalTrackerCount = fractionalTrackers.size();
+            for (int i = 0; i < fractionalTrackerCount; i++) {
+                VastFractionalProgressTracker tracker = fractionalTrackers.get(i);
+                if (tracker.compareTo(fractionalTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
                 }
             }
-        };
+
+            return untriggeredTrackers;
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private int remainingProgressTrackerCount() {
+        return getUntriggeredTrackersBefore(Integer.MAX_VALUE, Integer.MAX_VALUE).size();
     }
 
     private void createVideoBackground(final Context context) {
         GradientDrawable gradientDrawable = new GradientDrawable(
                 GradientDrawable.Orientation.TOP_BOTTOM,
-                new int[] {Color.argb(0,0,0,0), Color.argb(255,0,0,0)}
+                new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)}
         );
         Drawable[] layers = new Drawable[2];
-        layers[0] = Drawables.THATCHED_BACKGROUND.decodeImage(context);
+        layers[0] = Drawables.THATCHED_BACKGROUND.createDrawable(context);
         layers[1] = gradientDrawable;
         LayerDrawable layerList = new LayerDrawable(layers);
         getLayout().setBackgroundDrawable(layerList);
@@ -293,12 +359,35 @@ private VastVideoToolbar createVastVideoToolBar(final Context context) {
             @Override
             public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getCloseTrackers(), context);
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getSkipTrackers(), context);
                     getBaseVideoViewControllerListener().onFinish();
                 }
                 return true;
             }
         });
         vastVideoToolbar.setLearnMoreButtonOnTouchListener(mClickThroughListener);
+
+        // update custom CTA text if specified in VAST extension
+        String customCtaText = mVastVideoConfiguration.getCustomCtaText();
+        if (customCtaText != null) {
+            vastVideoToolbar.updateLearnMoreButtonText(customCtaText);
+        }
+
+        // update custom skip text if specified in VAST extensions
+        String customSkipText = mVastVideoConfiguration.getCustomSkipText();
+        if (customSkipText != null) {
+            vastVideoToolbar.updateCloseButtonText(customSkipText);
+        }
+
+        // update custom close icon if specified in VAST extensions
+        String customCloseIconUrl = mVastVideoConfiguration.getCustomCloseIconUrl();
+        if (customCloseIconUrl != null) {
+            vastVideoToolbar.updateCloseButtonIcon(customCloseIconUrl);
+        }
+
         return vastVideoToolbar;
     }
 
@@ -307,9 +396,8 @@ private VideoView createVideoView(final Context context) {
         videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
             @Override
             public void onPrepared(MediaPlayer mp) {
-                if (mVideoView.getDuration() < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
-                    mShowCloseButtonDelay = mVideoView.getDuration();
-                }
+                // Called when media source is ready for playback
+                adjustSkipOffset();
             }
         });
         videoView.setOnTouchListener(mClickThroughListener);
@@ -317,14 +405,19 @@ public void onPrepared(MediaPlayer mp) {
         videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
             @Override
             public void onCompletion(MediaPlayer mp) {
-                stopProgressChecker();
+                stopRunnables();
                 makeVideoInteractable();
 
                 videoCompleted(false);
-
-                makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
                 mIsVideoFinishedPlaying = true;
 
+                // Only fire the completion tracker if we hit all the progress marks. Some Android implementations
+                // fire the completion event even if the whole video isn't watched.
+                if (!mVideoError && remainingProgressTrackerCount() == 0 && !mCompletionTrackerFired) {
+                    makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
+                    mCompletionTrackerFired = true;
+                }
+
                 videoView.setVisibility(View.GONE);
                 // check the drawable to see if the image view was populated with content
                 if (mCompanionAdImageView.getDrawable() != null) {
@@ -339,9 +432,10 @@ public boolean onError(final MediaPlayer mediaPlayer, final int what, final int
                 if (retryMediaPlayer(mediaPlayer, what, extra)) {
                     return true;
                 } else {
-                    stopProgressChecker();
+                    stopRunnables();
                     makeVideoInteractable();
                     videoError(false);
+                    mVideoError = true;
                     return false;
                 }
             }
@@ -389,6 +483,48 @@ boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final in
         return false;
     }
 
+    /**
+     * Called upon user click. Attempts open mopubnativebrowser links in the device browser and all
+     * other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
+        makeTrackingHttpRequest(clickThroughTrackers, getContext(), BaseEvent.Name.CLICK_REQUEST);
+
+        if (TextUtils.isEmpty(clickThroughUrl)) {
+            return;
+        }
+
+        broadcastAction(ACTION_INTERSTITIAL_CLICK);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction == UrlAction.OPEN_IN_APP_BROWSER) {
+                            Bundle bundle = new Bundle();
+                            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+
+                            getBaseVideoViewControllerListener().onStartActivityForResult(
+                                    MoPubBrowser.class, MOPUB_BROWSER_REQUEST_CODE, bundle);
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withoutMoPubBrowser()
+                .build().handleUrl(getContext(), clickThroughUrl);
+    }
+
     private ImageView createCompanionAdImageView(final Context context) {
         RelativeLayout relativeLayout = new RelativeLayout(context);
         relativeLayout.setGravity(Gravity.CENTER);
@@ -412,94 +548,130 @@ private ImageView createCompanionAdImageView(final Context context) {
         return imageView;
     }
 
-    private void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
-        makeTrackingHttpRequest(clickThroughTrackers, getContext());
-
-        videoClicked();
-
-        Bundle bundle = new Bundle();
-        bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+    int getDuration() {
+        return mVideoView.getDuration();
+    }
 
-        getBaseVideoViewControllerListener().onStartActivityForResult(MoPubBrowser.class,
-                MOPUB_BROWSER_REQUEST_CODE, bundle);
+    int getCurrentPosition() {
+        return mVideoView.getCurrentPosition();
     }
 
-    private boolean isLongVideo(final int duration) {
+    boolean isLongVideo(final int duration) {
         return (duration >= MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON);
     }
 
-    private void makeVideoInteractable() {
+    void makeVideoInteractable() {
         mShowCloseButtonEventFired = true;
         mVastVideoToolbar.makeInteractable();
     }
 
-    private boolean shouldBeInteractable() {
-        return !mShowCloseButtonEventFired && mVideoView.getCurrentPosition() > mShowCloseButtonDelay;
+    boolean shouldBeInteractable() {
+        return !mShowCloseButtonEventFired && getCurrentPosition() >= mShowCloseButtonDelay;
+    }
+
+    boolean shouldShowCountdown() {
+        // show countdown if any of the following conditions is satisfied:
+        // 1) long video
+        // 2) skipoffset is specified in VAST and is less than video duration
+        final int duration = getDuration();
+        return isLongVideo(duration) || (mHasSkipOffset && mShowCloseButtonDelay < duration);
+    }
+
+    void updateCountdown() {
+        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - getCurrentPosition());
+    }
+
+    void updateDuration() {
+        mVastVideoToolbar.updateDurationWidget(getDuration() - getCurrentPosition());
     }
 
     private boolean shouldAllowClickThrough() {
         return mShowCloseButtonEventFired;
     }
 
-    private void startProgressChecker() {
-        if (!mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = true;
-            mHandler.post(mVideoProgressCheckerRunnable);
-        }
+    private void startRunnables() {
+        mProgressCheckerRunnable.startRepeating(VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
+        mCountdownRunnable.startRepeating(VIDEO_COUNTDOWN_UPDATE_INTERVAL);
     }
 
-    private void stopProgressChecker() {
-        if (mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = false;
-            mHandler.removeCallbacks(mVideoProgressCheckerRunnable);
-        }
+    private void stopRunnables() {
+        mProgressCheckerRunnable.stop();
+        mCountdownRunnable.stop();
     }
 
     // for testing
     @Deprecated
-    boolean getIsVideoProgressShouldBeChecked() {
-        return mIsVideoProgressShouldBeChecked;
+    @VisibleForTesting
+    VastVideoViewProgressRunnable getProgressCheckerRunnable() {
+        return mProgressCheckerRunnable;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    VastVideoViewCountdownRunnable getCountdownRunnable() {
+        return mCountdownRunnable;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     int getVideoRetries() {
         return mVideoRetries;
     }
 
     // for testing
     @Deprecated
-    Runnable getVideoProgressCheckerRunnable() {
-        return mVideoProgressCheckerRunnable;
+    @VisibleForTesting
+    boolean getHasSkipOffset() {
+        return mHasSkipOffset;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     int getShowCloseButtonDelay() {
         return mShowCloseButtonDelay;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean isShowCloseButtonEventFired() {
         return mShowCloseButtonEventFired;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     void setCloseButtonVisible(boolean visible) {
         mShowCloseButtonEventFired = visible;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean isVideoFinishedPlaying() {
         return mIsVideoFinishedPlaying;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     ImageView getCompanionAdImageView() {
         return mCompanionAdImageView;
     }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setVideoError() {
+        mVideoError = true;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean getVideoError() {
+        return mVideoError;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
new file mode 100644
index 00000000..14323626
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
@@ -0,0 +1,39 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+/**
+ * This class is used to update a {@link VastVideoViewController}'s countdown display according to rules
+ * contained in the {@link VastVideoViewController}
+ */
+public class VastVideoViewCountdownRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+
+    public VastVideoViewCountdownRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+        Preconditions.checkNotNull(handler);
+        Preconditions.checkNotNull(videoViewController);
+
+
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        // Countdown and interactable are mutually exclusive. Should we refactor to collapse them?
+        if (mVideoViewController.shouldShowCountdown()) {
+            mVideoViewController.updateCountdown();
+        }
+
+        if (mVideoViewController.shouldBeInteractable()) {
+            mVideoViewController.makeVideoInteractable();
+        }
+
+        mVideoViewController.updateDuration();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
new file mode 100644
index 00000000..1936ada0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
@@ -0,0 +1,46 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.TrackingRequest;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A runnable that is used to measure video progress and track video progress events for video ads.
+ *
+ */
+public class VastVideoViewProgressRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+    public VastVideoViewProgressRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+
+        Preconditions.checkNotNull(videoViewController);
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        int videoLength = mVideoViewController.getDuration();
+        int currentPosition = mVideoViewController.getCurrentPosition();
+
+        if (videoLength > 0) {
+            final List<VastTracker> trackersToTrack =
+                    mVideoViewController.getUntriggeredTrackersBefore(currentPosition, videoLength);
+            if (!trackersToTrack.isEmpty()) {
+                final List<String> trackUrls = new ArrayList<String>();
+                for (VastTracker tracker : trackersToTrack) {
+                    trackUrls.add(tracker.getTrackingUrl());
+                    tracker.setTracked();
+                }
+                TrackingRequest.makeTrackingHttpRequest(trackUrls, mVideoViewController.getContext());
+            }
+
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
index bb9a23df..cdb92180 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
@@ -1,16 +1,19 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 
 public class ViewGestureDetector extends GestureDetector {
     private final View mView;
 
-    interface UserClickListener {
+    public interface UserClickListener {
         void onUserClick();
         void onResetUserClick();
         boolean wasClicked();
@@ -19,8 +22,8 @@
     private AdAlertGestureListener mAdAlertGestureListener;
     private UserClickListener mUserClickListener;
 
-    public ViewGestureDetector(Context context, View view, AdConfiguration adConfiguration)  {
-        this(context, view, new AdAlertGestureListener(view, adConfiguration));
+    public ViewGestureDetector(@NonNull Context context, @NonNull View view, @Nullable AdReport adReport)  {
+        this(context, view, new AdAlertGestureListener(view, adReport));
     }
 
     private ViewGestureDetector(Context context, View view, AdAlertGestureListener adAlertGestureListener) {
@@ -32,7 +35,7 @@ private ViewGestureDetector(Context context, View view, AdAlertGestureListener a
         setIsLongpressEnabled(false);
     }
 
-    void sendTouchEvent(MotionEvent motionEvent) {
+    public void sendTouchEvent(MotionEvent motionEvent) {
         switch (motionEvent.getAction()) {
             case MotionEvent.ACTION_UP:
                 if (mUserClickListener != null) {
@@ -60,7 +63,7 @@ void sendTouchEvent(MotionEvent motionEvent) {
         }
     }
 
-    void setUserClickListener(UserClickListener listener) {
+    public void setUserClickListener(UserClickListener listener) {
         mUserClickListener = listener;
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
index e4d92329..975b69cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
@@ -1,84 +1,32 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.location.Location;
 
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-
-import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
+import com.mopub.common.Constants;
 
 public class WebViewAdUrlGenerator extends AdUrlGenerator {
-    public WebViewAdUrlGenerator(Context context) {
+    private final boolean mIsStorePictureSupported;
+
+    public WebViewAdUrlGenerator(Context context, boolean isStorePictureSupported) {
         super(context);
+        mIsStorePictureSupported = isStorePictureSupported;
     }
 
     @Override
     public String generateUrlString(String serverHostname) {
-        initUrlString(serverHostname, MoPubView.AD_HANDLER);
-
-        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        initUrlString(serverHostname, Constants.AD_HANDLER);
 
         setApiVersion("6");
 
-        setAdUnitId(mAdUnitId);
-
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setUdid(clientMetadata.getAdvertisingId());
-
-        setDoNotTrack(clientMetadata.isDoNotTrackSet());
-
-        setKeywords(mKeywords);
-
-        Location location = mLocation;
-        if (location == null) {
-            location = LocationService.getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-        setLocation(location);
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        setMraidFlag(detectIsMraidSupported());
-
-        String networkOperator = clientMetadata.getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        addBaseParams(clientMetadata);
 
-        setExternalStoragePermission(isStorePictureSupported(mContext));
+        setMraidFlag(true);
 
-        setTwitterAppInstalledFlag();
+        setExternalStoragePermission(mIsStorePictureSupported);
 
         return getFinalUrlString();
     }
-
-    private boolean detectIsMraidSupported() {
-        boolean mraid = true;
-        try {
-            Class.forName("com.mopub.mobileads.MraidView");
-        } catch (ClassNotFoundException e) {
-            mraid = false;
-        }
-        return mraid;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
index bf363e57..d6a53767 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
@@ -1,8 +1,13 @@
 package com.mopub.mobileads.factories;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventBannerAdapter;
 import com.mopub.mobileads.MoPubView;
 
+import java.util.Map;
+
 public class CustomEventBannerAdapterFactory {
     protected static CustomEventBannerAdapterFactory instance = new CustomEventBannerAdapterFactory();
 
@@ -11,11 +16,19 @@ public static void setInstance(CustomEventBannerAdapterFactory factory) {
         instance = factory;
     }
 
-    public static CustomEventBannerAdapter create(MoPubView moPubView, String className, String classData) {
-        return instance.internalCreate(moPubView, className, classData);
+    public static CustomEventBannerAdapter create(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @NonNull AdReport adReport) {
+        return instance.internalCreate(moPubView, className, serverExtras, broadcastIdentifier, adReport);
     }
 
-    protected CustomEventBannerAdapter internalCreate(MoPubView moPubView, String className, String classData) {
-        return new CustomEventBannerAdapter(moPubView, className, classData);
+    protected CustomEventBannerAdapter internalCreate(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @NonNull AdReport adReport) {
+        return new CustomEventBannerAdapter(moPubView, className, serverExtras, broadcastIdentifier, adReport);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
index f6534dda..e7042f5c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
@@ -1,8 +1,11 @@
 package com.mopub.mobileads.factories;
 
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventInterstitialAdapter;
 import com.mopub.mobileads.MoPubInterstitial;
 
+import java.util.Map;
+
 public class CustomEventInterstitialAdapterFactory {
     protected static CustomEventInterstitialAdapterFactory instance = new CustomEventInterstitialAdapterFactory();
 
@@ -11,11 +14,11 @@ public static void setInstance(CustomEventInterstitialAdapterFactory factory) {
         instance = factory;
     }
 
-    public static CustomEventInterstitialAdapter create(MoPubInterstitial moPubInterstitial, String className, String classData) {
-        return instance.internalCreate(moPubInterstitial, className, classData);
+    public static CustomEventInterstitialAdapter create(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
+        return instance.internalCreate(moPubInterstitial, className, serverExtras, broadcastIdentifier, adReport);
     }
 
-    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, String classData) {
-        return new CustomEventInterstitialAdapter(moPubInterstitial, className, classData);
+    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
+        return new CustomEventInterstitialAdapter(moPubInterstitial, className, serverExtras, broadcastIdentifier, adReport);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
index e7d300b1..59b9544d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlBannerWebView;
 
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
@@ -12,22 +12,22 @@
 
     public static HtmlBannerWebView create(
             Context context,
+            AdReport adReport,
             CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+            String clickthroughUrl) {
+        return instance.internalCreate(context, adReport, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
     }
 
     public HtmlBannerWebView internalCreate(
             Context context,
+            AdReport adReport,
             CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        HtmlBannerWebView htmlBannerWebView = new HtmlBannerWebView(context, adConfiguration);
+            String clickthroughUrl) {
+        HtmlBannerWebView htmlBannerWebView = new HtmlBannerWebView(context, adReport);
         htmlBannerWebView.init(customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
         return htmlBannerWebView;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
index ab8c4490..65d97a39 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlInterstitialWebView;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -12,22 +12,22 @@
 
     public static HtmlInterstitialWebView create(
             Context context,
+            AdReport adReport,
             CustomEventInterstitialListener customEventInterstitialListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+            String clickthroughUrl) {
+        return instance.internalCreate(context, adReport, customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl);
     }
 
     public HtmlInterstitialWebView internalCreate(
             Context context,
+            AdReport adReport,
             CustomEventInterstitialListener customEventInterstitialListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        HtmlInterstitialWebView htmlInterstitialWebView = new HtmlInterstitialWebView(context, adConfiguration);
+            String clickthroughUrl) {
+        HtmlInterstitialWebView htmlInterstitialWebView = new HtmlInterstitialWebView(context, adReport);
         htmlInterstitialWebView.init(customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl);
         return htmlInterstitialWebView;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java
new file mode 100644
index 00000000..50c5391e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java
@@ -0,0 +1,30 @@
+package com.mopub.mobileads.factories;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.PlacementType;
+
+public class MraidControllerFactory {
+    protected static MraidControllerFactory instance = new MraidControllerFactory();
+
+    @VisibleForTesting
+    public static void setInstance(MraidControllerFactory factory) {
+        instance = factory;
+    }
+
+    public static MraidController create(@NonNull final Context context, 
+            @NonNull final AdReport adReport, 
+            @NonNull final PlacementType placementType) {
+        return instance.internalCreate(context, adReport, placementType);
+    }
+
+    protected MraidController internalCreate(@NonNull final Context context, 
+            @NonNull final AdReport adReport, 
+            @NonNull final PlacementType placementType) {
+        return new MraidController(context, adReport, placementType);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
index af32b51a..557b6e11 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
@@ -2,7 +2,6 @@
 
 import android.graphics.Canvas;
 import android.graphics.Paint;
-import android.graphics.Path;
 import android.graphics.Point;
 
 public class CloseButtonDrawable extends CircleDrawable {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
index 94228d44..7071ffa0 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
@@ -17,63 +17,48 @@
             "  }\n" +
             "}());\n" +
             "\n" +
-            "(function() {\n" +
-            "  // Establish the root mraidbridge object.\n" +
-            "  var mraidbridge = window.mraidbridge = {};\n" +
-            "\n" +
-            "  // native SDK is ready to process mraid commands.\n" +
-            "  var nativeSDKFiredReady = false;\n" +
-            "\n" +
-            "  // Listeners for bridge events.\n" +
-            "  var listeners = {};\n" +
-            "\n" +
-            "  // Queue to track pending calls to the native SDK.\n" +
-            "  var nativeCallQueue = [];\n" +
             "\n" +
-            "  // Whether a native call is currently in progress.\n" +
-            "  var nativeCallInFlight = false;\n" +
+            "(function() {\n" +
+            "  var mraid = window.mraid = {};\n" +
             "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  mraidbridge.fireReadyEvent = function() {\n" +
-            "    nativeSDKFiredReady = true;\n" +
-            "    mraidbridge.fireEvent('ready');\n" +
-            "  };\n" +
+            "  // Bridge interface to SDK\n" +
             "\n" +
-            "  mraidbridge.fireChangeEvent = function(properties) {\n" +
-            "    mraidbridge.fireEvent('change', properties);\n" +
+            "  var bridge = window.mraidbridge = {\n" +
+            "    nativeSDKFiredReady: false,\n" +
+            "    nativeCallQueue: [],\n" +
+            "    nativeCallInFlight: false,\n" +
+            "    lastSizeChangeProperties: null\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.fireErrorEvent = function(message, action) {\n" +
-            "    mraidbridge.fireEvent('error', message, action);\n" +
-            "  };\n" +
             "\n" +
-            "  mraidbridge.fireEvent = function(type) {\n" +
-            "    var ls = listeners[type];\n" +
-            "    if (ls) {\n" +
-            "      var args = Array.prototype.slice.call(arguments);\n" +
-            "      args.shift();\n" +
-            "      var l = ls.length;\n" +
-            "      for (var i = 0; i < l; i++) {\n" +
-            "        ls[i].apply(null, args);\n" +
+            "  bridge.fireChangeEvent = function(properties) {\n" +
+            "    for (var p in properties) {\n" +
+            "      if (properties.hasOwnProperty(p)) {\n" +
+            "        // Change handlers defined by MRAID below\n" +
+            "        var handler = changeHandlers[p];\n" +
+            "        handler(properties[p]);\n" +
             "      }\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.nativeCallComplete = function(command) {\n" +
-            "    if (nativeCallQueue.length === 0) {\n" +
-            "      nativeCallInFlight = false;\n" +
+            "  bridge.nativeCallComplete = function(command) {\n" +
+            "    if (this.nativeCallQueue.length === 0) {\n" +
+            "      this.nativeCallInFlight = false;\n" +
             "      return;\n" +
             "    }\n" +
             "\n" +
-            "    var nextCall = nativeCallQueue.pop();\n" +
+            "    var nextCall = this.nativeCallQueue.pop();\n" +
             "    window.location = nextCall;\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.executeNativeCall = function(command) {\n" +
-            "    if (!nativeSDKFiredReady) {\n" +
+            "  bridge.executeNativeCall = function(args) {\n" +
+            "    var command = args.shift();\n" +
+            "\n" +
+            "    if (!this.nativeSDKFiredReady) {\n" +
             "        console.log('rejecting ' + command + ' because mraid is not ready');\n" +
-            "        mraidbridge.fireErrorEvent('mraid is not ready', command);\n" +
+            "        bridge.notifyErrorEvent('mraid is not ready', command);\n" +
             "        return;\n" +
             "    }\n" +
             "\n" +
@@ -82,9 +67,9 @@
             "    var key, value;\n" +
             "    var isFirstArgument = true;\n" +
             "\n" +
-            "    for (var i = 1; i < arguments.length; i += 2) {\n" +
-            "      key = arguments[i];\n" +
-            "      value = arguments[i + 1];\n" +
+            "    for (var i = 0; i < args.length; i += 2) {\n" +
+            "      key = args[i];\n" +
+            "      value = args[i + 1];\n" +
             "\n" +
             "      if (value === null) continue;\n" +
             "\n" +
@@ -98,55 +83,133 @@
             "      call += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n" +
             "    }\n" +
             "\n" +
-            "    if (nativeCallInFlight) {\n" +
-            "      nativeCallQueue.push(call);\n" +
+            "    if (this.nativeCallInFlight) {\n" +
+            "      this.nativeCallQueue.push(call);\n" +
             "    } else {\n" +
-            "      nativeCallInFlight = true;\n" +
+            "      this.nativeCallInFlight = true;\n" +
             "      window.location = call;\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  mraidbridge.addEventListener = function(event, listener) {\n" +
-            "    var eventListeners;\n" +
-            "    listeners[event] = listeners[event] || [];\n" +
-            "    eventListeners = listeners[event];\n" +
+            "  bridge.setCurrentPosition = function(x, y, width, height) {\n" +
+            "    currentPosition = {\n" +
+            "      x: x,\n" +
+            "      y: y,\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set current position to ' + stringify(currentPosition));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setDefaultPosition = function(x, y, width, height) {\n" +
+            "    defaultPosition = {\n" +
+            "      x: x,\n" +
+            "      y: y,\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set default position to ' + stringify(defaultPosition));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setMaxSize = function(width, height) {\n" +
+            "    maxSize = {\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "\n" +
+            "    expandProperties.width = width;\n" +
+            "    expandProperties.height = height;\n" +
             "\n" +
-            "    for (var l in eventListeners) {\n" +
-            "      // Listener already registered, so no need to add it.\n" +
-            "      if (listener === l) return;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set max size to ' + stringify(maxSize));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setPlacementType = function(_placementType) {\n" +
+            "    placementType = _placementType;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set placement type to ' + stringify(placementType));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setScreenSize = function(width, height) {\n" +
+            "    screenSize = {\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set screen size to ' + stringify(screenSize));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setState = function(_state) {\n" +
+            "    state = _state;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));\n" +
+            "    broadcastEvent(EVENTS.STATECHANGE, state);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setIsViewable = function(_isViewable) {\n" +
+            "    isViewable = _isViewable;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));\n" +
+            "    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setSupports = function(sms, tel, calendar, storePicture, inlineVideo) {\n" +
+            "    supportProperties = {\n" +
+            "      sms: sms,\n" +
+            "      tel: tel,\n" +
+            "      calendar: calendar,\n" +
+            "      storePicture: storePicture,\n" +
+            "      inlineVideo: inlineVideo\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyReadyEvent = function() {\n" +
+            "    this.nativeSDKFiredReady = true;\n" +
+            "    broadcastEvent(EVENTS.READY);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyErrorEvent = function(message, action) {\n" +
+            "    broadcastEvent(EVENTS.ERROR, message, action);\n" +
+            "  };\n" +
+            "\n" +
+            "  // Temporary aliases while we migrate to the new API\n" +
+            "  bridge.fireReadyEvent = bridge.notifyReadyEvent;\n" +
+            "  bridge.fireErrorEvent = bridge.notifyErrorEvent;\n" +
+            "\n" +
+            "  bridge.notifySizeChangeEvent = function(width, height) {\n" +
+            "    if (this.lastSizeChangeProperties &&\n" +
+            "          width == this.lastSizeChangeProperties.width && height == this.lastSizeChangeProperties.height) {\n" +
+            "      return;\n" +
             "    }\n" +
             "\n" +
-            "    eventListeners.push(listener);\n" +
+            "    this.lastSizeChangeProperties = {\n" +
+            "        width: width,\n" +
+            "        height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.SIZECHANGE, width, height);\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.removeEventListener = function(event, listener) {\n" +
-            "    if (listeners.hasOwnProperty(event)) {\n" +
-            "      var eventListeners = listeners[event];\n" +
-            "      if (eventListeners) {\n" +
-            "        var idx = eventListeners.indexOf(listener);\n" +
-            "        if (idx !== -1) {\n" +
-            "          eventListeners.splice(idx, 1);\n" +
-            "        }\n" +
-            "      }\n" +
+            "  bridge.notifyStateChangeEvent = function() {\n" +
+            "    if (state === STATES.LOADING) {\n" +
+            "      broadcastEvent(EVENTS.INFO, 'Native SDK initialized.');\n" +
             "    }\n" +
+            "\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));\n" +
+            "    broadcastEvent(EVENTS.STATECHANGE, state);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyViewableChangeEvent = function() {\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));\n" +
+            "    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);\n" +
             "  };\n" +
-            "}());\n" +
             "\n" +
-            "(function() {\n" +
-            "  var mraid = window.mraid = {};\n" +
-            "  var bridge = window.mraidbridge;\n" +
             "\n" +
             "  // Constants. ////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  var VERSION = mraid.VERSION = '1.0';\n" +
+            "  var VERSION = mraid.VERSION = '2.0';\n" +
             "\n" +
             "  var STATES = mraid.STATES = {\n" +
-            "    LOADING: 'loading',     // Initial state.\n" +
+            "    LOADING: 'loading',\n" +
             "    DEFAULT: 'default',\n" +
             "    EXPANDED: 'expanded',\n" +
-            "    HIDDEN: 'hidden'\n" +
+            "    HIDDEN: 'hidden',\n" +
+            "    RESIZED: 'resized'\n" +
             "  };\n" +
             "\n" +
             "  var EVENTS = mraid.EVENTS = {\n" +
@@ -154,7 +217,8 @@
             "    INFO: 'info',\n" +
             "    READY: 'ready',\n" +
             "    STATECHANGE: 'stateChange',\n" +
-            "    VIEWABLECHANGE: 'viewableChange'\n" +
+            "    VIEWABLECHANGE: 'viewableChange',\n" +
+            "    SIZECHANGE: 'sizeChange'\n" +
             "  };\n" +
             "\n" +
             "  var PLACEMENT_TYPES = mraid.PLACEMENT_TYPES = {\n" +
@@ -167,14 +231,44 @@
             "\n" +
             "  // Properties which define the behavior of an expandable ad.\n" +
             "  var expandProperties = {\n" +
-            "    width: -1,\n" +
-            "    height: -1,\n" +
+            "    width: false,\n" +
+            "    height: false,\n" +
             "    useCustomClose: false,\n" +
-            "    isModal: true,\n" +
-            "    lockOrientation: false\n" +
+            "    isModal: true\n" +
+            "  };\n" +
+            "\n" +
+            "  var resizeProperties = {\n" +
+            "    width: false,\n" +
+            "    height: false,\n" +
+            "    offsetX: false,\n" +
+            "    offsetY: false,\n" +
+            "    customClosePosition: 'top-right',\n" +
+            "    allowOffscreen: true\n" +
+            "  };\n" +
+            "\n" +
+            "  var orientationProperties = {\n" +
+            "    allowOrientationChange: true,\n" +
+            "    forceOrientation: \"none\"\n" +
+            "  };\n" +
+            "\n" +
+            "  var supportProperties = {\n" +
+            "    sms: false,\n" +
+            "    tel: false,\n" +
+            "    calendar: false,\n" +
+            "    storePicture: false,\n" +
+            "    inlineVideo: false\n" +
             "  };\n" +
             "\n" +
-            "  var hasSetCustomSize = false;\n" +
+            "  // default is undefined so that notifySizeChangeEvent can track changes\n" +
+            "  var lastSizeChangeProperties;\n" +
+            "\n" +
+            "  var maxSize = {};\n" +
+            "\n" +
+            "  var currentPosition = {};\n" +
+            "\n" +
+            "  var defaultPosition = {};\n" +
+            "\n" +
+            "  var screenSize = {};\n" +
             "\n" +
             "  var hasSetCustomClose = false;\n" +
             "\n" +
@@ -186,18 +280,8 @@
             "\n" +
             "  var isViewable = false;\n" +
             "\n" +
-            "  var screenSize = { width: -1, height: -1 };\n" +
-            "\n" +
             "  var placementType = PLACEMENT_TYPES.UNKNOWN;\n" +
             "\n" +
-            "  var supports = {\n" +
-            "    sms: false,\n" +
-            "    tel: false,\n" +
-            "    calendar: false,\n" +
-            "    storePicture: false,\n" +
-            "    inlineVideo: false\n" +
-            "  };\n" +
-            "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
             "  var EventListeners = function(event) {\n" +
@@ -233,7 +317,7 @@
             "\n" +
             "    this.broadcast = function(args) {\n" +
             "      for (var id in listeners) {\n" +
-            "        if (listeners.hasOwnProperty(id)) listeners[id].apply({}, args);\n" +
+            "        if (listeners.hasOwnProperty(id)) listeners[id].apply(mraid, args);\n" +
             "      }\n" +
             "    };\n" +
             "\n" +
@@ -309,29 +393,17 @@
             "      placementType = val;\n" +
             "    },\n" +
             "\n" +
-            "    screenSize: function(val) {\n" +
+            "    sizeChange: function(val) {\n" +
             "      broadcastEvent(EVENTS.INFO, 'Set screenSize to ' + stringify(val));\n" +
             "      for (var key in val) {\n" +
             "        if (val.hasOwnProperty(key)) screenSize[key] = val[key];\n" +
             "      }\n" +
-            "\n" +
-            "      if (!hasSetCustomSize) {\n" +
-            "        expandProperties['width'] = screenSize['width'];\n" +
-            "        expandProperties['height'] = screenSize['height'];\n" +
-            "      }\n" +
-            "    },\n" +
-            "\n" +
-            "    expandProperties: function(val) {\n" +
-            "      broadcastEvent(EVENTS.INFO, 'Merging expandProperties with ' + stringify(val));\n" +
-            "      for (var key in val) {\n" +
-            "        if (val.hasOwnProperty(key)) expandProperties[key] = val[key];\n" +
-            "      }\n" +
             "    },\n" +
             "\n" +
             "    supports: function(val) {\n" +
             "      broadcastEvent(EVENTS.INFO, 'Set supports to ' + stringify(val));\n" +
-            "        supports = val;\n" +
-            "    },\n" +
+            "        supportProperties = val;\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
             "  var validate = function(obj, validators, action, merge) {\n" +
@@ -343,7 +415,7 @@
             "      } else {\n" +
             "        for (var i in validators) {\n" +
             "          if (validators.hasOwnProperty(i) && obj[i] === undefined) {\n" +
-            "            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i + '.', action);\n" +
+            "            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i, action);\n" +
             "            return false;\n" +
             "          }\n" +
             "        }\n" +
@@ -355,8 +427,7 @@
             "      var value = obj[prop];\n" +
             "      if (validator && !validator(value)) {\n" +
             "        // Failed validation.\n" +
-            "        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid.',\n" +
-            "          action);\n" +
+            "        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid: ' + value, action);\n" +
             "        return false;\n" +
             "      }\n" +
             "    }\n" +
@@ -364,40 +435,20 @@
             "  };\n" +
             "\n" +
             "  var expandPropertyValidators = {\n" +
-            "    width: function(v) { return !isNaN(v) && v >= 0; },\n" +
-            "    height: function(v) { return !isNaN(v) && v >= 0; },\n" +
             "    useCustomClose: function(v) { return (typeof v === 'boolean'); },\n" +
-            "    lockOrientation: function(v) { return (typeof v === 'boolean'); }\n" +
             "  };\n" +
             "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  bridge.addEventListener('change', function(properties) {\n" +
-            "    for (var p in properties) {\n" +
-            "      if (properties.hasOwnProperty(p)) {\n" +
-            "        var handler = changeHandlers[p];\n" +
-            "        handler(properties[p]);\n" +
-            "      }\n" +
-            "    }\n" +
-            "  });\n" +
-            "\n" +
-            "  bridge.addEventListener('error', function(message, action) {\n" +
-            "    broadcastEvent(EVENTS.ERROR, message, action);\n" +
-            "  });\n" +
-            "\n" +
-            "  bridge.addEventListener('ready', function() {\n" +
-            "    broadcastEvent(EVENTS.READY);\n" +
-            "  });\n" +
-            "\n" +
-            "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
-            "\n" +
             "  mraid.addEventListener = function(event, listener) {\n" +
             "    if (!event || !listener) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Both event and listener are required.', 'addEventListener');\n" +
             "    } else if (!contains(event, EVENTS)) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Unknown MRAID event: ' + event, 'addEventListener');\n" +
             "    } else {\n" +
-            "      if (!listeners[event]) listeners[event] = new EventListeners(event);\n" +
+            "      if (!listeners[event]) {\n" +
+            "        listeners[event] = new EventListeners(event);\n" +
+            "      }\n" +
             "      listeners[event].add(listener);\n" +
             "    }\n" +
             "  };\n" +
@@ -406,45 +457,25 @@
             "    if (state === STATES.HIDDEN) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Ad cannot be closed when it is already hidden.',\n" +
             "        'close');\n" +
-            "    } else bridge.executeNativeCall('close');\n" +
+            "    } else bridge.executeNativeCall(['close']);\n" +
             "  };\n" +
             "\n" +
             "  mraid.expand = function(URL) {\n" +
-            "    if (this.getState() !== STATES.DEFAULT) {\n" +
-            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default state.', 'expand');\n" +
+            "    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default or resized state.', 'expand');\n" +
             "    } else {\n" +
-            "      var args = ['expand'];\n" +
-            "\n" +
-            "      if (this.getHasSetCustomClose()) {\n" +
-            "        args = args.concat(['shouldUseCustomClose', expandProperties.useCustomClose ? 'true' : 'false']);\n" +
-            "      }\n" +
-            "\n" +
-            "      if (this.getHasSetCustomSize()) {\n" +
-            "        if (expandProperties.width >= 0 && expandProperties.height >= 0) {\n" +
-            "          args = args.concat(['w', expandProperties.width, 'h', expandProperties.height]);\n" +
-            "        }\n" +
-            "      }\n" +
-            "\n" +
-            "      if (typeof expandProperties.lockOrientation !== 'undefined') {\n" +
-            "        args = args.concat(['lockOrientation', expandProperties.lockOrientation]);\n" +
-            "      }\n" +
+            "      var args = ['expand',\n" +
+            "        'shouldUseCustomClose', expandProperties.useCustomClose\n" +
+            "      ];\n" +
             "\n" +
             "      if (URL) {\n" +
             "        args = args.concat(['url', URL]);\n" +
             "      }\n" +
             "\n" +
-            "      bridge.executeNativeCall.apply(this, args);\n" +
+            "      bridge.executeNativeCall(args);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getHasSetCustomClose = function() {\n" +
-            "      return hasSetCustomClose;\n" +
-            "  };\n" +
-            "\n" +
-            "  mraid.getHasSetCustomSize = function() {\n" +
-            "      return hasSetCustomSize;\n" +
-            "  };\n" +
-            "\n" +
             "  mraid.getExpandProperties = function() {\n" +
             "    var properties = {\n" +
             "      width: expandProperties.width,\n" +
@@ -455,56 +486,93 @@
             "    return properties;\n" +
             "  };\n" +
             "\n" +
+            "\n" +
+            "  mraid.getCurrentPosition = function() {\n" +
+            "    return {\n" +
+            "      x: currentPosition.x,\n" +
+            "      y: currentPosition.y,\n" +
+            "      width: currentPosition.width,\n" +
+            "      height: currentPosition.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  mraid.getDefaultPosition = function() {\n" +
+            "    return {\n" +
+            "      x: defaultPosition.x,\n" +
+            "      y: defaultPosition.y,\n" +
+            "      width: defaultPosition.width,\n" +
+            "      height: defaultPosition.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  mraid.getMaxSize = function() {\n" +
+            "    return {\n" +
+            "      width: maxSize.width,\n" +
+            "      height: maxSize.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
             "  mraid.getPlacementType = function() {\n" +
             "    return placementType;\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getState = function() {\n" +
-            "    return state;\n" +
+            "  mraid.getScreenSize = function() {\n" +
+            "    return {\n" +
+            "      width: screenSize.width,\n" +
+            "      height: screenSize.height\n" +
+            "    };\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getVersion = function() {\n" +
-            "    return mraid.VERSION;\n" +
+            "  mraid.getState = function() {\n" +
+            "    return state;\n" +
             "  };\n" +
             "\n" +
             "  mraid.isViewable = function() {\n" +
             "    return isViewable;\n" +
             "  };\n" +
             "\n" +
+            "  mraid.getVersion = function() {\n" +
+            "    return mraid.VERSION;\n" +
+            "  };\n" +
+            "\n" +
             "  mraid.open = function(URL) {\n" +
             "    if (!URL) broadcastEvent(EVENTS.ERROR, 'URL is required.', 'open');\n" +
-            "    else bridge.executeNativeCall('open', 'url', URL);\n" +
+            "    else bridge.executeNativeCall(['open', 'url', URL]);\n" +
             "  };\n" +
             "\n" +
             "  mraid.removeEventListener = function(event, listener) {\n" +
-            "    if (!event) broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');\n" +
-            "    else {\n" +
-            "      if (listener && (!listeners[event] || !listeners[event].remove(listener))) {\n" +
-            "        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.',\n" +
-            "          'removeEventListener');\n" +
-            "        return;\n" +
-            "      } else if (listeners[event]) listeners[event].removeAll();\n" +
+            "    if (!event) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');\n" +
+            "      return;\n" +
+            "    }\n" +
             "\n" +
-            "      if (listeners[event] && listeners[event].count === 0) {\n" +
-            "        listeners[event] = null;\n" +
-            "        delete listeners[event];\n" +
+            "    if (listener) {\n" +
+            "      // If we have a valid event, we'll try to remove the listener from it.\n" +
+            "      var success = false;\n" +
+            "      if (listeners[event]) {\n" +
+            "        success = listeners[event].remove(listener);\n" +
+            "      }\n" +
+            "\n" +
+            "      // If we didn't have a valid event or couldn't remove the listener from the event, broadcast an error and return early.\n" +
+            "      if (!success) {\n" +
+            "        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.', 'removeEventListener');\n" +
+            "        return;\n" +
             "      }\n" +
+            "\n" +
+            "    } else if (!listener && listeners[event]) {\n" +
+            "      listeners[event].removeAll();\n" +
+            "    }\n" +
+            "\n" +
+            "    if (listeners[event] && listeners[event].count === 0) {\n" +
+            "      listeners[event] = null;\n" +
+            "      delete listeners[event];\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
             "  mraid.setExpandProperties = function(properties) {\n" +
             "    if (validate(properties, expandPropertyValidators, 'setExpandProperties', true)) {\n" +
-            "      if (properties.hasOwnProperty('width') || properties.hasOwnProperty('height')) {\n" +
-            "        hasSetCustomSize = true;\n" +
-            "      }\n" +
-            "\n" +
-            "      if (properties.hasOwnProperty('useCustomClose')) hasSetCustomClose = true;\n" +
-            "\n" +
-            "      var desiredProperties = ['width', 'height', 'useCustomClose', 'lockOrientation'];\n" +
-            "      var length = desiredProperties.length;\n" +
-            "      for (var i = 0; i < length; i++) {\n" +
-            "        var propname = desiredProperties[i];\n" +
-            "        if (properties.hasOwnProperty(propname)) expandProperties[propname] = properties[propname];\n" +
+            "      if (properties.hasOwnProperty('useCustomClose')) {\n" +
+            "        expandProperties.useCustomClose = properties.useCustomClose;\n" +
             "      }\n" +
             "    }\n" +
             "  };\n" +
@@ -512,7 +580,7 @@
             "  mraid.useCustomClose = function(shouldUseCustomClose) {\n" +
             "    expandProperties.useCustomClose = shouldUseCustomClose;\n" +
             "    hasSetCustomClose = true;\n" +
-            "    bridge.executeNativeCall('usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose);\n" +
+            "    bridge.executeNativeCall(['usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose]);\n" +
             "  };\n" +
             "\n" +
             "  // MRAID 2.0 APIs ////////////////////////////////////////////////////////////////////////////////\n" +
@@ -520,14 +588,14 @@
             "  mraid.createCalendarEvent = function(parameters) {\n" +
             "    CalendarEventParser.initialize(parameters);\n" +
             "    if (CalendarEventParser.parse()) {\n" +
-            "      bridge.executeNativeCall.apply(this, CalendarEventParser.arguments);\n" +
+            "      bridge.executeNativeCall(CalendarEventParser.arguments);\n" +
             "    } else {\n" +
             "      broadcastEvent(EVENTS.ERROR, CalendarEventParser.errors[0], 'createCalendarEvent');\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
             "  mraid.supports = function(feature) {\n" +
-            "    return supports[feature];\n" +
+            "    return supportProperties[feature];\n" +
             "  };\n" +
             "\n" +
             "  mraid.playVideo = function(uri) {\n" +
@@ -539,7 +607,7 @@
             "    if (!uri) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'playVideo must be called with a valid URI', 'playVideo');\n" +
             "    } else {\n" +
-            "      bridge.executeNativeCall.apply(this, ['playVideo', 'uri', uri]);\n" +
+            "      bridge.executeNativeCall(['playVideo', 'uri', uri]);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
@@ -552,36 +620,102 @@
             "    if (!uri) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'storePicture must be called with a valid URI', 'storePicture');\n" +
             "    } else {\n" +
-            "      bridge.executeNativeCall.apply(this, ['storePicture', 'uri', uri]);\n" +
+            "      bridge.executeNativeCall(['storePicture', 'uri', uri]);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.resize = function() {\n" +
-            "    bridge.executeNativeCall('resize');\n" +
-            "  };\n" +
             "\n" +
-            "  mraid.getResizeProperties = function() {\n" +
-            "    bridge.executeNativeCall('getResizeProperties');\n" +
+            "  var resizePropertyValidators = {\n" +
+            "    width: function(v) {\n" +
+            "      return !isNaN(v) && v > 0;\n" +
+            "    },\n" +
+            "    height: function(v) {\n" +
+            "      return !isNaN(v) && v > 0;\n" +
+            "    },\n" +
+            "    offsetX: function(v) {\n" +
+            "      return !isNaN(v);\n" +
+            "    },\n" +
+            "    offsetY: function(v) {\n" +
+            "      return !isNaN(v);\n" +
+            "    },\n" +
+            "    customClosePosition: function(v) {\n" +
+            "      return (typeof v === 'string' &&\n" +
+            "        ['top-right', 'bottom-right', 'top-left', 'bottom-left', 'center', 'top-center', 'bottom-center'].indexOf(v) > -1);\n" +
+            "    },\n" +
+            "    allowOffscreen: function(v) {\n" +
+            "      return (typeof v === 'boolean');\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.setResizeProperties = function(resizeProperties) {\n" +
-            "    bridge.executeNativeCall('setResizeProperties', 'resizeProperties', resizeProperties);\n" +
+            "  mraid.setOrientationProperties = function(properties) {\n" +
+            "\n" +
+            "    if (properties.hasOwnProperty('allowOrientationChange')) {\n" +
+            "      orientationProperties.allowOrientationChange = properties.allowOrientationChange;\n" +
+            "    }\n" +
+            "\n" +
+            "    if (properties.hasOwnProperty('forceOrientation')) {\n" +
+            "      orientationProperties.forceOrientation = properties.forceOrientation;\n" +
+            "    }\n" +
+            "\n" +
+            "    var args = ['setOrientationProperties',\n" +
+            "      'allowOrientationChange', orientationProperties.allowOrientationChange,\n" +
+            "      'forceOrientation', orientationProperties.forceOrientation\n" +
+            "    ];\n" +
+            "    bridge.executeNativeCall(args);\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getCurrentPosition = function() {\n" +
-            "    bridge.executeNativeCall('getCurrentPosition');\n" +
+            "  mraid.getOrientationProperties = function() {\n" +
+            "    return {\n" +
+            "      allowOrientationChange: orientationProperties.allowOrientationChange,\n" +
+            "      forceOrientation: orientationProperties.forceOrientation\n" +
+            "    };\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getDefaultPosition = function() {\n" +
-            "    bridge.executeNativeCall('getDefaultPosition');\n" +
+            "  mraid.resize = function() {\n" +
+            "    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be resized from the default or resized state.', 'resize');\n" +
+            "    } else if (!resizeProperties.width || !resizeProperties.height) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Must set resize properties before calling resize()', 'resize');\n" +
+            "    } else {\n" +
+            "      var args = ['resize',\n" +
+            "        'width', resizeProperties.width,\n" +
+            "        'height', resizeProperties.height,\n" +
+            "        'offsetX', resizeProperties.offsetX || 0,\n" +
+            "        'offsetY', resizeProperties.offsetY || 0,\n" +
+            "        'customClosePosition', resizeProperties.customClosePosition,\n" +
+            "        'allowOffscreen', !!resizeProperties.allowOffscreen\n" +
+            "        ];\n" +
+            "\n" +
+            "      bridge.executeNativeCall(args);\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getMaxSize = function() {\n" +
-            "    bridge.executeNativeCall('getMaxSize');\n" +
+            "  mraid.getResizeProperties = function() {\n" +
+            "    var properties = {\n" +
+            "      width: resizeProperties.width,\n" +
+            "      height: resizeProperties.height,\n" +
+            "      offsetX: resizeProperties.offsetX,\n" +
+            "      offsetY: resizeProperties.offsetY,\n" +
+            "      customClosePosition: resizeProperties.customClosePosition,\n" +
+            "      allowOffscreen: resizeProperties.allowOffscreen\n" +
+            "    };\n" +
+            "    return properties;\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getScreenSize = function() {\n" +
-            "    bridge.executeNativeCall('getScreenSize');\n" +
+            "  mraid.setResizeProperties = function(properties) {\n" +
+            "    if (validate(properties, resizePropertyValidators, 'setResizeProperties', true)) {\n" +
+            "\n" +
+            "      var desiredProperties = ['width', 'height', 'offsetX', 'offsetY', 'customClosePosition', 'allowOffscreen'];\n" +
+            "\n" +
+            "      var length = desiredProperties.length;\n" +
+            "\n" +
+            "      for (var i = 0; i < length; i++) {\n" +
+            "        var propname = desiredProperties[i];\n" +
+            "        if (properties.hasOwnProperty(propname)) {\n" +
+            "          resizeProperties[propname] = properties[propname];\n" +
+            "        }\n" +
+            "      }\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
             "  var CalendarEventParser = {\n" +
@@ -663,7 +797,7 @@
             "      var validValues = ['opaque', 'transparent'];\n" +
             "\n" +
             "      if (this.parameters.hasOwnProperty('transparency')) {\n" +
-            "        var transparency = this.parameters['transparency'];\n" +
+            "        var transparency = this.parameters.transparency;\n" +
             "        if (contains(transparency, validValues)) {\n" +
             "          this.arguments.push('transparency');\n" +
             "          this.arguments.push(transparency);\n" +
@@ -688,7 +822,7 @@
             "\n" +
             "    parseRecurrenceInterval: function(recurrenceDict) {\n" +
             "      if (recurrenceDict.hasOwnProperty('interval')) {\n" +
-            "        var interval = recurrenceDict['interval'];\n" +
+            "        var interval = recurrenceDict.interval;\n" +
             "        if (!interval) {\n" +
             "          this.errors.push('Recurrence interval cannot be null.');\n" +
             "        } else {\n" +
@@ -704,7 +838,7 @@
             "\n" +
             "    parseRecurrenceFrequency: function(recurrenceDict) {\n" +
             "      if (recurrenceDict.hasOwnProperty('frequency')) {\n" +
-            "        var frequency = recurrenceDict['frequency'];\n" +
+            "        var frequency = recurrenceDict.frequency;\n" +
             "        var validFrequencies = ['daily', 'weekly', 'monthly', 'yearly'];\n" +
             "        if (contains(frequency, validFrequencies)) {\n" +
             "          this.arguments.push('frequency');\n" +
@@ -716,7 +850,7 @@
             "    },\n" +
             "\n" +
             "    parseRecurrenceEndDate: function(recurrenceDict) {\n" +
-            "      var expires = recurrenceDict['expires'];\n" +
+            "      var expires = recurrenceDict.expires;\n" +
             "\n" +
             "      if (!expires) {\n" +
             "        return;\n" +
@@ -748,7 +882,7 @@
             "        this.arguments.push(kind);\n" +
             "        this.arguments.push(dateString);\n" +
             "      }\n" +
-            "    },\n" +
+            "    }\n" +
             "  };\n" +
             "}());\n";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
index f368ccd3..57eb0f0c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
@@ -1,33 +1,55 @@
 package com.mopub.mobileads.util;
 
-import android.util.Log;
+import android.annotation.TargetApi;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
 import android.webkit.JsPromptResult;
 import android.webkit.JsResult;
 import android.webkit.WebChromeClient;
 import android.webkit.WebView;
 
-import java.lang.reflect.Method;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Reflection.MethodBuilder;
 
 public class WebViews {
-    private static final String LOGTAG = "MoPub - WebViewsUtil";
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    public static void onResume(@NonNull WebView webView) {
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
+            webView.onResume();
+            return;
+        }
 
-    public static void onPause(WebView webView) {
+        // Method is still available, but hidden. Invoke using reflection.
         try {
-            Method onPause = WebView.class.getDeclaredMethod("onPause");
-            onPause.invoke(webView);
+            new MethodBuilder(webView, "onResume").setAccessible().execute();
         } catch (Exception e) {
-            // can't call this before API level 11
-            return;
+            // no-op
         }
     }
 
-    public static void onResume(WebView webView) {
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    public static void onPause(@NonNull WebView webView, boolean isFinishing) {
+        // XXX
+        // We need to call WebView#stopLoading and WebView#loadUrl here due to an Android
+        // bug where the audio of an HTML5 video will continue to play after the activity has been
+        // destroyed. The web view must stop then load an invalid url during the onPause lifecycle
+        // event in order to stop the audio.
+        if (isFinishing) {
+            webView.stopLoading();
+            webView.loadUrl("");
+        }
+
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
+            webView.onPause();
+            return;
+        }
+
+        // Method is still available, but hidden. Invoke using reflection.
         try {
-            Method onResume = WebView.class.getDeclaredMethod("onResume");
-            onResume.invoke(webView);
+            new MethodBuilder(webView, "onPause").setAccessible().execute();
         } catch (Exception e) {
-            // can't call this before API level 11
-            return;
+            // no-op
         }
     }
 
@@ -35,25 +57,29 @@ public static void setDisableJSChromeClient(WebView webView) {
         webView.setWebChromeClient(new WebChromeClient() {
             @Override
             public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsBeforeUnload(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
         });
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
index ab6c0dce..c396547f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
@@ -3,12 +3,16 @@
 import android.content.Context;
 import android.view.Display;
 import android.view.WindowManager;
+
 import com.mopub.common.CacheService;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.mobileads.VastVideoDownloadTask;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
 
 import static com.mopub.mobileads.VastVideoDownloadTask.VastVideoDownloadTaskListener;
 import static com.mopub.mobileads.util.vast.VastXmlManagerAggregator.VastXmlManagerAggregatorListener;
@@ -44,10 +48,7 @@ public void prepareVastVideoConfiguration(final String vastXml, final VastManage
                 AsyncTasks.safeExecuteOnExecutor(mVastXmlManagerAggregator, vastXml);
             } catch (Exception e) {
                 MoPubLog.d("Failed to aggregate vast xml", e);
-
-                if (mVastManagerListener != null) {
-                    mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                }
+                mVastManagerListener.onVastVideoConfigurationPrepared(null);
             }
         }
     }
@@ -63,9 +64,7 @@ public void cancel() {
     public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
         mVastXmlManagerAggregator = null;
         if (vastXmlManagers == null) {
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-            }
+            mVastManagerListener.onVastVideoConfigurationPrepared(null);
             return;
         }
 
@@ -73,9 +72,7 @@ public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
                 createVastVideoConfigurationFromXml(vastXmlManagers);
 
         if (updateDiskMediaFileUrl(vastVideoConfiguration)) {
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
-            }
+            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
             return;
         }
 
@@ -84,13 +81,9 @@ public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
                     @Override
                     public void onComplete(boolean success) {
                         if (success && updateDiskMediaFileUrl(vastVideoConfiguration)) {
-                            if (mVastManagerListener != null) {
-                                mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
-                            }
+                            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
                         } else {
-                            if (mVastManagerListener != null) {
-                                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                            }
+                            mVastManagerListener.onVastVideoConfigurationPrepared(null);
                         }
                     }
                 }
@@ -103,10 +96,7 @@ public void onComplete(boolean success) {
             );
         } catch (Exception e) {
             MoPubLog.d("Failed to download vast video", e);
-
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-            }
+            mVastManagerListener.onVastVideoConfigurationPrepared(null);
         }
     }
 
@@ -140,12 +130,11 @@ private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<Va
         final List<VastXmlManager.ImageCompanionAdXmlManager> companionXmlManagers = new ArrayList<VastXmlManager.ImageCompanionAdXmlManager>();
         for (VastXmlManager xmlManager : xmlManagers) {
             vastVideoConfiguration.addImpressionTrackers(xmlManager.getImpressionTrackers());
-
-            vastVideoConfiguration.addStartTrackers(xmlManager.getVideoStartTrackers());
-            vastVideoConfiguration.addFirstQuartileTrackers(xmlManager.getVideoFirstQuartileTrackers());
-            vastVideoConfiguration.addMidpointTrackers(xmlManager.getVideoMidpointTrackers());
-            vastVideoConfiguration.addThirdQuartileTrackers(xmlManager.getVideoThirdQuartileTrackers());
+            vastVideoConfiguration.addAbsoluteTrackers(xmlManager.getAbsoluteProgressTrackers());
+            vastVideoConfiguration.addFractionalTrackers(xmlManager.getFractionalProgressTrackers());
             vastVideoConfiguration.addCompleteTrackers(xmlManager.getVideoCompleteTrackers());
+            vastVideoConfiguration.addCloseTrackers(xmlManager.getVideoCloseTrackers());
+            vastVideoConfiguration.addSkipTrackers(xmlManager.getVideoSkipTrackers());
 
             vastVideoConfiguration.addClickTrackers(xmlManager.getClickTrackers());
 
@@ -155,6 +144,13 @@ private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<Va
 
             mediaXmlManagers.addAll(xmlManager.getMediaXmlManagers());
             companionXmlManagers.addAll(xmlManager.getCompanionAdXmlManagers());
+
+            // Load custom extensions
+            vastVideoConfiguration.setCustomCtaText(xmlManager.getCustomCtaText());
+            vastVideoConfiguration.setCustomSkipText(xmlManager.getCustomSkipText());
+            vastVideoConfiguration.setCustomCloseIconUrl(xmlManager.getCustomCloseIconUrl());
+            vastVideoConfiguration.setCustomForceOrientation(xmlManager.getCustomForceOrientation());
+            vastVideoConfiguration.setSkipOffset(xmlManager.getSkipOffset());
         }
 
         vastVideoConfiguration.setNetworkMediaFileUrl(getBestMediaFileUrl(mediaXmlManagers));
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
index aeae8b9f..ef638cd9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
@@ -1,31 +1,45 @@
 package com.mopub.mobileads.util.vast;
 
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 public class VastVideoConfiguration implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private ArrayList<String> mImpressionTrackers;
-    private ArrayList<String> mStartTrackers;
-    private ArrayList<String> mFirstQuartileTrackers;
-    private ArrayList<String> mMidpointTrackers;
-    private ArrayList<String> mThirdQuartileTrackers;
-    private ArrayList<String> mCompleteTrackers;
-    private ArrayList<String> mClickTrackers;
+    private static final long serialVersionUID = 1L;
+
+    private final ArrayList<String> mImpressionTrackers;
+    private final ArrayList<VastFractionalProgressTracker> mFractionalTrackers;
+    private final ArrayList<VastAbsoluteProgressTracker> mAbsoluteTrackers;
+    private final ArrayList<String> mCompleteTrackers;
+    private final ArrayList<String> mCloseTrackers;
+    private final ArrayList<String> mSkipTrackers;
+    private final ArrayList<String> mClickTrackers;
     private String mClickThroughUrl;
     private String mNetworkMediaFileUrl;
     private String mDiskMediaFileUrl;
+    private String mSkipOffset;
     private VastCompanionAd mVastCompanionAd;
 
+    // Custom extensions
+    private String mCustomCtaText;
+    private String mCustomSkipText;
+    private String mCustomCloseIconUrl;
+    private DeviceUtils.ForceOrientation mCustomForceOrientation = DeviceUtils.ForceOrientation.FORCE_LANDSCAPE; // Default is forcing landscape
+
     public VastVideoConfiguration() {
         mImpressionTrackers = new ArrayList<String>();
-        mStartTrackers = new ArrayList<String>();
-        mFirstQuartileTrackers = new ArrayList<String>();
-        mMidpointTrackers = new ArrayList<String>();
-        mThirdQuartileTrackers = new ArrayList<String>();
+        mFractionalTrackers = new ArrayList<VastFractionalProgressTracker>();
+        mAbsoluteTrackers = new ArrayList<VastAbsoluteProgressTracker>();
         mCompleteTrackers = new ArrayList<String>();
+        mCloseTrackers = new ArrayList<String>();
+        mSkipTrackers = new ArrayList<String>();
         mClickTrackers = new ArrayList<String>();
     }
 
@@ -37,24 +51,33 @@ public void addImpressionTrackers(final List<String> impressionTrackers) {
         mImpressionTrackers.addAll(impressionTrackers);
     }
 
-    public void addStartTrackers(final List<String> startTrackers) {
-        mStartTrackers.addAll(startTrackers);
+    /**
+     * Add trackers for percentage-based tracking. This includes all quartile trackers and any
+     * "progress" events with other percentages.
+     */
+    public void addFractionalTrackers(final List<VastFractionalProgressTracker> fractionalTrackers) {
+        mFractionalTrackers.addAll(fractionalTrackers);
+        Collections.sort(mFractionalTrackers);
     }
 
-    public void addFirstQuartileTrackers(final List<String> firstQuartileTrackers) {
-        mFirstQuartileTrackers.addAll(firstQuartileTrackers);
+    /**
+     * Add trackers for absolute tracking. This includes start trackers, which have an absolute threshold of 2 seconds.
+     */
+    public void addAbsoluteTrackers(final List<VastAbsoluteProgressTracker> absoluteTrackers) {
+        mAbsoluteTrackers.addAll(absoluteTrackers);
+        Collections.sort(mAbsoluteTrackers);
     }
 
-    public void addMidpointTrackers(final List<String> midpointTrackers) {
-        mMidpointTrackers.addAll(midpointTrackers);
+    public void addCompleteTrackers(final List<String> completeTrackers) {
+        mCompleteTrackers.addAll(completeTrackers);
     }
 
-    public void addThirdQuartileTrackers(final List<String> thirdQuartileTrackers) {
-        mThirdQuartileTrackers.addAll(thirdQuartileTrackers);
+    public void addCloseTrackers(final List<String> closeTrackers) {
+        mCloseTrackers.addAll(closeTrackers);
     }
 
-    public void addCompleteTrackers(final List<String> completeTrackers) {
-        mCompleteTrackers.addAll(completeTrackers);
+    public void addSkipTrackers(final List<String> skipTrackers) {
+        mSkipTrackers.addAll(skipTrackers);
     }
 
     public void addClickTrackers(final List<String> clickTrackers) {
@@ -77,6 +100,36 @@ public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
         mVastCompanionAd = vastCompanionAd;
     }
 
+    public void setCustomCtaText(@Nullable final String customCtaText) {
+        if (customCtaText != null) {
+            mCustomCtaText = customCtaText;
+        }
+    }
+
+    public void setCustomSkipText(@Nullable final String customSkipText) {
+        if (customSkipText != null) {
+            mCustomSkipText = customSkipText;
+        }
+    }
+
+    public void setCustomCloseIconUrl(@Nullable final String customCloseIconUrl) {
+        if (customCloseIconUrl != null) {
+            mCustomCloseIconUrl = customCloseIconUrl;
+        }
+    }
+
+    public void setCustomForceOrientation(@Nullable final DeviceUtils.ForceOrientation customForceOrientation) {
+        if (customForceOrientation != null && customForceOrientation != DeviceUtils.ForceOrientation.UNDEFINED) {
+            mCustomForceOrientation = customForceOrientation;
+        }
+    }
+
+    public void setSkipOffset(@Nullable final String skipOffset) {
+        if (skipOffset != null) {
+            mSkipOffset = skipOffset;
+        }
+    }
+
     /**
      * Getters
      */
@@ -85,24 +138,24 @@ public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
         return mImpressionTrackers;
     }
 
-    public List<String> getStartTrackers() {
-        return mStartTrackers;
+    public ArrayList<VastAbsoluteProgressTracker> getAbsoluteTrackers() {
+        return mAbsoluteTrackers;
     }
 
-    public List<String> getFirstQuartileTrackers() {
-        return mFirstQuartileTrackers;
+    public ArrayList<VastFractionalProgressTracker> getFractionalTrackers() {
+        return mFractionalTrackers;
     }
 
-    public List<String> getMidpointTrackers() {
-        return mMidpointTrackers;
+    public List<String> getCompleteTrackers() {
+        return mCompleteTrackers;
     }
 
-    public List<String> getThirdQuartileTrackers() {
-        return mThirdQuartileTrackers;
+    public List<String> getCloseTrackers() {
+        return mCloseTrackers;
     }
 
-    public List<String> getCompleteTrackers() {
-        return mCompleteTrackers;
+    public List<String> getSkipTrackers() {
+        return mSkipTrackers;
     }
 
     public List<String> getClickTrackers() {
@@ -124,4 +177,28 @@ public String getDiskMediaFileUrl() {
     public VastCompanionAd getVastCompanionAd() {
         return mVastCompanionAd;
     }
+
+    public String getCustomCtaText() {
+        return mCustomCtaText;
+    }
+
+    public String getCustomSkipText() {
+        return mCustomSkipText;
+    }
+
+    public String getCustomCloseIconUrl() {
+        return mCustomCloseIconUrl;
+    }
+
+    /**
+     * Get custom force orientation
+     * @return ForceOrientation enum (default is FORCE_LANDSCAPE)
+     */
+    public DeviceUtils.ForceOrientation getCustomForceOrientation() {
+        return mCustomForceOrientation;
+    }
+
+    public String getSkipOffset() {
+        return mSkipOffset;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
index 8b098a7d..299288ed 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
@@ -1,16 +1,30 @@
 package com.mopub.mobileads.util.vast;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.common.util.Strings;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
-import java.io.*;
-import java.util.*;
 
 class VastXmlManager {
     private static final String ROOT_TAG = "MPMoVideoXMLDocRoot";
@@ -26,18 +40,40 @@
     private static final String VAST_AD_TAG = "VASTAdTagURI";
     private static final String MP_IMPRESSION_TRACKER = "MP_TRACKING_URL";
     private static final String COMPANION = "Companion";
+    private static final String LINEAR = "Linear";
+
+    // Custom element names for VAST 3.0 extensions
+    private static final String CUSTOM_CTA_TEXT = "MoPubCtaText";
+    private static final String CUSTOM_SKIP_TEXT = "MoPubSkipText";
+    private static final String CUSTOM_CLOSE_ICON = "MoPubCloseIcon";
+    private static final String CUSTOM_FORCE_ORIENTATION = "MoPubForceOrientation";
 
     // Attribute names
     private static final String EVENT = "event";
     private static final String WIDTH = "width";
     private static final String HEIGHT = "height";
+    private static final String OFFSET = "offset";
+    private static final String SKIP_OFFSET = "skipoffset";
 
-    // Attibute values
+    // Event Attribute values
     private static final String START = "start";
     private static final String FIRST_QUARTILE = "firstQuartile";
     private static final String MIDPOINT = "midpoint";
     private static final String THIRD_QUARTILE = "thirdQuartile";
     private static final String COMPLETE = "complete";
+    private static final String CLOSE = "close";
+    private static final String PROGRESS = "progress";
+    private static final String SKIP = "skip";
+
+    private static final int START_TRACKER_THRESHOLD = 2000;
+    private static final float FIRST_QUARTER_MARKER = 0.25f;
+    private static final float MID_POINT_MARKER = 0.50f;
+    private static final float THIRD_QUARTER_MARKER = 0.75f;
+
+    // constants for custom extensions
+    private static final int MAX_CTA_TEXT_LENGTH = 15;
+    private static final int MAX_SKIP_TEXT_LENGTH = 8;
+
 
     // This class currently assumes an image type companion ad since that is what we are supporting
     class ImageCompanionAdXmlManager {
@@ -181,29 +217,114 @@ String getVastAdTagURI() {
         return impressionTrackers;
     }
 
-    List<String> getVideoStartTrackers() {
-        return getVideoTrackerByAttribute(START);
-    }
+    /**
+     * Return a sorted list of the video's percent-based progress-trackers. These are the
+     * quartile trackers and any "progress" nodes with percent-based offsets.
+     *
+     * Quartile trackers look like:
+     * {@code
+     * <Tracking event="firstQuartile">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     *
+     * Percent-based progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="11%">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastFractionalProgressTracker> getFractionalProgressTrackers() {
+        // Add all the quartile trackers from VAST 2.0:
+        List<VastFractionalProgressTracker> percentTrackers = new ArrayList<VastFractionalProgressTracker>();
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(FIRST_QUARTILE), FIRST_QUARTER_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(MIDPOINT), MID_POINT_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(THIRD_QUARTILE), THIRD_QUARTER_MARKER);
+
+        // Get any other trackers with event="progress" offset="n%"
+        final List<Node> progressNodes = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, VIDEO_TRACKER, EVENT, PROGRESS);
+        for (Node progressNode : progressNodes) {
+            final String offsetString = XmlUtils.getAttributeValue(progressNode, OFFSET).trim();
+            if (Strings.isPercentageTracker(offsetString)) {
+                String trackingUrl = XmlUtils.getNodeValue(progressNode).trim();
+                try {
+                    float trackingFraction = Float.parseFloat(offsetString.replace("%", "")) / 100f;
+                    percentTrackers.add(new VastFractionalProgressTracker(trackingUrl, trackingFraction));
+                } catch (NumberFormatException e) {
+                    MoPubLog.d(String.format("Failed to parse VAST progress tracker %s", offsetString));
+                }
+            }
+        }
 
-    List<String> getVideoFirstQuartileTrackers() {
-        return getVideoTrackerByAttribute(FIRST_QUARTILE);
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(percentTrackers);
+        return percentTrackers;
     }
 
-    List<String> getVideoMidpointTrackers() {
-        return getVideoTrackerByAttribute(MIDPOINT);
-    }
+    /**
+     * Return a sorted list of the video's absolute progress trackers. This includes start trackers
+     * and any "progress" nodes with absolute offsets.
+     *
+     * Start trackers live in nodes like:
+     * {@code
+     * <Tracking event="start">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     * Absolute progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="00:00:10.000">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastAbsoluteProgressTracker> getAbsoluteProgressTrackers() {
+        List<VastAbsoluteProgressTracker> trackers = new ArrayList<VastAbsoluteProgressTracker>();
+        // Start trackers are treated as absolute trackers with a 2s offset.
+        final List<String> startTrackers = getVideoTrackerByAttribute(START);
+        for (String url : startTrackers) {
+            trackers.add(new VastAbsoluteProgressTracker(url, START_TRACKER_THRESHOLD));
+        }
+
+        // Parse progress trackers and extract the absolute offsets of the form "HH:MM:SS[.mmm]"
+        final List<Node> progressNodes = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, VIDEO_TRACKER, EVENT, PROGRESS);
+        for (Node progressNode : progressNodes) {
+            final String offSetString = XmlUtils.getAttributeValue(progressNode, OFFSET).trim();
+            if (Strings.isAbsoluteTracker(offSetString)) {
+                String trackingUrl = XmlUtils.getNodeValue(progressNode).trim();
+                try {
+                    Integer trackingMilliseconds = Strings.parseAbsoluteOffset(offSetString);
+                    if (trackingMilliseconds != null) {
+                        trackers.add(new VastAbsoluteProgressTracker(trackingUrl, trackingMilliseconds));
+                    }
+                } catch (NumberFormatException e) {
+                    MoPubLog.d(String.format("Failed to parse VAST progress tracker %s", offSetString));
+                }
+            }
+        }
 
-    List<String> getVideoThirdQuartileTrackers() {
-        return getVideoTrackerByAttribute(THIRD_QUARTILE);
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(trackers);
+        return trackers;
     }
 
     List<String> getVideoCompleteTrackers() {
         return getVideoTrackerByAttribute(COMPLETE);
     }
 
+    List<String> getVideoCloseTrackers() {
+        return getVideoTrackerByAttribute(CLOSE);
+    }
+
+    List<String> getVideoSkipTrackers() {
+        return getVideoTrackerByAttribute(SKIP);
+    }
+
     String getClickThroughUrl() {
-        List<String> clickUrlWrapper = XmlUtils.getStringDataAsList(mVastDoc, CLICK_THROUGH);
-        return (clickUrlWrapper.size() > 0) ? clickUrlWrapper.get(0) : null;
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CLICK_THROUGH);
     }
 
     List<String> getClickTrackers() {
@@ -211,8 +332,58 @@ String getClickThroughUrl() {
     }
 
     String getMediaFileUrl() {
-        List<String> urlWrapper = XmlUtils.getStringDataAsList(mVastDoc, MEDIA_FILE);
-        return (urlWrapper.size() > 0) ? urlWrapper.get(0) : null;
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, MEDIA_FILE);
+    }
+
+    @Nullable
+    String getCustomCtaText() {
+        String customCtaText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CTA_TEXT);
+        if (customCtaText != null && customCtaText.length() <= MAX_CTA_TEXT_LENGTH) {
+            return customCtaText;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    String getCustomSkipText() {
+        String customSkipText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_SKIP_TEXT);
+        if (customSkipText != null && customSkipText.length() <= MAX_SKIP_TEXT_LENGTH) {
+            return customSkipText;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    String getCustomCloseIconUrl() {
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CLOSE_ICON);
+    }
+
+    @NonNull
+    ForceOrientation getCustomForceOrientation() {
+        return ForceOrientation.getForceOrientation(
+                XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_FORCE_ORIENTATION));
+    }
+
+    @Nullable
+    String getSkipOffset() {
+        List<Node> linearNodeWrapper = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, LINEAR, SKIP_OFFSET, null);
+        Node linearNode = (linearNodeWrapper.isEmpty()) ? null : linearNodeWrapper.get(0);
+        if (linearNode == null) {
+            return null;
+        }
+
+        final String skipOffsetString = XmlUtils.getAttributeValue(linearNode, SKIP_OFFSET);
+        if (skipOffsetString == null) {
+            return null;
+        }
+
+        if (skipOffsetString.trim().isEmpty()) {
+            return null;
+        }
+
+        return skipOffsetString.trim();
     }
 
     List<MediaXmlManager> getMediaXmlManagers() {
@@ -238,4 +409,10 @@ String getMediaFileUrl() {
     private List<String> getVideoTrackerByAttribute(final String attributeValue) {
         return XmlUtils.getStringDataAsList(mVastDoc, VIDEO_TRACKER, EVENT, attributeValue);
     }
+
+    private void addQuartileTrackerWithFraction(List<VastFractionalProgressTracker> trackers, List<String> urls, float fraction) {
+        for (String url : urls) {
+            trackers.add(new VastFractionalProgressTracker(url, fraction));
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
index e9d377ed..9248a3e8 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
@@ -79,7 +79,7 @@ String followVastRedirect(final AndroidHttpClient httpClient, final String redir
         if (redirectUrl != null && mTimesFollowedVastRedirect < MAX_TIMES_TO_FOLLOW_VAST_REDIRECT) {
             mTimesFollowedVastRedirect++;
 
-            final HttpGet httpget = new HttpGet(redirectUrl);
+            final HttpGet httpget = HttpClient.initializeHttpGet(redirectUrl);
             final HttpResponse response = httpClient.execute(httpget);
             final HttpEntity entity = response.getEntity();
             return (entity != null) ? Strings.fromStream(entity.getContent()) : null;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
index 79e92584..9a69d13d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
@@ -12,11 +12,30 @@
 class XmlUtils {
     private XmlUtils() {}
 
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName}.
+     *
+     * Only direct children are checked.
+     */
     static Node getFirstMatchingChildNode(final Node node, final String nodeName) {
         return getFirstMatchingChildNode(node, nodeName, null, null);
     }
 
-    static Node getFirstMatchingChildNode(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName} that has an
+     * attribute named {@code attributeName} with a value that matches one of {@code attributeValues}.
+     *
+     * Only direct children are checked.
+     *
+     * @param nodeName matching nodes must have this name.
+     * @param attributeName matching nodes must have an attribute with this name.
+     *                      Use null to match nodes with any attributes.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values. Use null to match nodes with any attribute
+     *                        value.
+     */
+    static Node getFirstMatchingChildNode(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
         if (node == null || nodeName == null) {
             return null;
         }
@@ -28,7 +47,21 @@ static Node getFirstMatchingChildNode(final Node node, final String nodeName, fi
         return null;
     }
 
-    static List<Node> getMatchingChildNodes(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
+    /**
+     * Return children of the {@code node} parameter with a matching {@code nodeName} &
+     * {@code attributeName} that matches at least one of the passed-in {@code attributeValues}.
+     * If {@code attributeValues} is empty, no nodes will match. To match names only,
+     * pass null for both {@code attributeName} and {@code attributeValues}.
+     *
+     * @param node the root node to look beneath.
+     * @param nodeName all child nodes will match this element.
+     * @param attributeName all matching child nodes will have an attribute of this name.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values.
+     * @return child nodes that match all parameters
+     */
+    static List<Node> getMatchingChildNodes(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
         if (node == null || nodeName == null) {
             return null;
         }
@@ -45,6 +78,10 @@ static Node getFirstMatchingChildNode(final Node node, final String nodeName, fi
         return nodes;
     }
 
+    /**
+     * Returns {@code true} iff the node has the attribute {@code attributeName} with a value that
+     * matches one of {@code attributeValues}.
+     */
     static boolean nodeMatchesAttributeFilter(final Node node, final String attributeName, final List<String> attributeValues) {
         if (attributeName == null || attributeValues == null) {
             return true;
@@ -95,35 +132,124 @@ static String getAttributeValue(final Node node, final String attributeName) {
         return null;
     }
 
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
-        return getStringDataAsList(vastDoc, elementName, null, null);
-    }
-
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
-        final ArrayList<String> results = new ArrayList<String>();
+    /**
+     * Get a list of data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Each node that matches these is
+     * processed by the {@code nodeProcessor} and all non-null results returned by the processor are
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return a {@code List<T>} with processed node data.
+     */
+    static <T> List<T> getListFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        final ArrayList<T> results = new ArrayList<T>();
 
         if (vastDoc == null) {
             return results;
         }
 
         final NodeList nodes = vastDoc.getElementsByTagName(elementName);
-
         if (nodes == null) {
             return results;
         }
 
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
         for (int i = 0; i < nodes.getLength(); i++) {
             final Node node = nodes.item(i);
 
-            if (node != null && nodeMatchesAttributeFilter(node, attributeName, Arrays.asList(attributeValue))) {
-                // since we parsed with coalescing set to true, CDATA is added as the child of the element
-                final String nodeValue = getNodeValue(node);
-                if (nodeValue != null) {
-                    results.add(nodeValue);
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    results.add(processed);
                 }
             }
         }
 
         return results;
     }
+
+    /**
+     * Get first matching data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Nodes that match are processed by
+     * the {@code nodeProcessor} until the first non-null result returned by the processor is
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return node data of type {@code <T>} from first node that matches.
+     */
+    static <T> T getFirstMatchFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        if (vastDoc == null) {
+            return null;
+        }
+
+        final NodeList nodes = vastDoc.getElementsByTagName(elementName);
+        if (nodes == null) {
+            return null;
+        }
+
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
+        for (int i = 0; i < nodes.getLength(); i++) {
+            final Node node = nodes.item(i);
+
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    return processed;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    static String getFirstMatchingStringData(final Document vastDoc, final String elementName) {
+        return getFirstMatchingStringData(vastDoc, elementName, null, null);
+    }
+
+    static String getFirstMatchingStringData(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getFirstMatchFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
+        return getStringDataAsList(vastDoc, elementName, null, null);
+    }
+
+    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    static List<Node> getNodesWithElementAndAttribute(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+       return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<Node>() {
+           @Override
+           public Node process(final Node node) {
+               return node;
+           }
+       });
+    }
+
+    public interface NodeProcessor<T> {
+        public T process(Node node);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java
new file mode 100644
index 00000000..558439d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java
@@ -0,0 +1,105 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.AdViewController;
+import com.mopub.mobileads.CustomEventBanner;
+import com.mopub.mobileads.factories.MraidControllerFactory;
+import com.mopub.mraid.MraidController.MraidListener;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
+
+class MraidBanner extends CustomEventBanner {
+
+    @Nullable private MraidController mMraidController;
+    @Nullable private CustomEventBannerListener mBannerListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    @Override
+    protected void loadBanner(@NonNull Context context,
+                    @NonNull CustomEventBannerListener customEventBannerListener,
+                    @NonNull Map<String, Object> localExtras,
+                    @NonNull Map<String, String> serverExtras) {
+        mBannerListener = customEventBannerListener;
+
+        String htmlData;
+        if (extrasAreValid(serverExtras)) {
+            htmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
+        } else {
+            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            return;
+        }
+
+        try {
+            AdReport adReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            mMraidController = MraidControllerFactory.create(
+                    context, adReport, PlacementType.INLINE);
+        } catch (ClassCastException e) {
+            MoPubLog.w("MRAID banner creating failed:", e);
+            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            return;
+        }
+
+        mMraidController.setDebugListener(mDebugListener);
+        mMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // Honoring the server dimensions forces the WebView to be the size of the banner
+                AdViewController.setShouldHonorServerDimensions(view);
+                mBannerListener.onBannerLoaded(view);
+            }
+
+            @Override
+            public void onFailedToLoad() {
+                mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            }
+
+            @Override
+            public void onExpand() {
+                mBannerListener.onBannerExpanded();
+                mBannerListener.onBannerClicked();
+            }
+
+            @Override
+            public void onOpen() {
+                mBannerListener.onBannerClicked();
+            }
+
+            @Override
+            public void onClose() {
+                mBannerListener.onBannerCollapsed();
+            }
+        });
+        mMraidController.loadContent(htmlData);
+    }
+
+    @Override
+    protected void onInvalidate() {
+        if (mMraidController != null) {
+            mMraidController.setMraidListener(null);
+            mMraidController.destroy();
+        }
+    }
+
+    private boolean extrasAreValid(Map<String, String> serverExtras) {
+        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
+    }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mMraidController != null) {
+            mMraidController.setDebugListener(debugListener);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java
new file mode 100644
index 00000000..1430763d
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java
@@ -0,0 +1,613 @@
+package com.mopub.mraid;
+
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.ViewGestureDetector;
+import com.mopub.mobileads.ViewGestureDetector.UserClickListener;
+import com.mopub.mobileads.resource.MraidJavascript;
+import com.mopub.mraid.MraidBridge.MraidWebView.OnVisibilityChangedListener;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
+import org.apache.http.NameValuePair;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MraidBridge {
+    private final AdReport mAdReport;
+
+    public interface MraidBridgeListener {
+        void onPageLoaded();
+
+        void onPageFailedToLoad();
+
+        void onVisibilityChanged(boolean isVisible);
+
+        boolean onJsAlert(@NonNull String message, @NonNull JsResult result);
+
+        boolean onConsoleMessage(@NonNull ConsoleMessage consoleMessage);
+
+        void onResize(int width, int height, int offsetX,
+                int offsetY, @NonNull ClosePosition closePosition, boolean allowOffscreen)
+                throws MraidCommandException;
+
+        void onExpand(URI uri, boolean shouldUseCustomClose) throws MraidCommandException;
+
+        void onClose();
+
+        void onUseCustomClose(boolean shouldUseCustomClose);
+
+        void onSetOrientationProperties(boolean allowOrientationChange, MraidOrientation
+                forceOrientation) throws MraidCommandException;
+
+        void onOpen(URI uri);
+
+        void onPlayVideo(URI uri);
+    }
+
+    private final String FILTERED_JAVASCRIPT_SOURCE = MraidJavascript.JAVASCRIPT_SOURCE
+            .replaceAll("(?m)^\\s+", "")
+            .replaceAll("(?m)^//.*(?=\\n)", "");
+
+    @NonNull private final PlacementType mPlacementType;
+
+    @NonNull private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    @Nullable private MraidBridgeListener mMraidBridgeListener;
+
+    @Nullable private MraidWebView mMraidWebView;
+
+    private boolean mIsClicked;
+
+    private boolean mHasLoaded;
+
+    MraidBridge(@Nullable AdReport adReport, @NonNull PlacementType placementType) {
+        this(adReport, placementType, new MraidNativeCommandHandler());
+    }
+
+    @VisibleForTesting
+    MraidBridge(@Nullable AdReport adReport, @NonNull PlacementType placementType,
+            @NonNull MraidNativeCommandHandler mraidNativeCommandHandler) {
+        mAdReport = adReport;
+        mPlacementType = placementType;
+        mMraidNativeCommandHandler = mraidNativeCommandHandler;
+    }
+
+    void setMraidBridgeListener(@Nullable MraidBridgeListener listener) {
+        mMraidBridgeListener = listener;
+    }
+
+    void attachView(@NonNull MraidWebView mraidWebView) {
+        mMraidWebView = mraidWebView;
+        mMraidWebView.getSettings().setJavaScriptEnabled(true);
+
+        mMraidWebView.loadUrl("javascript:" + FILTERED_JAVASCRIPT_SOURCE);
+        mMraidWebView.setScrollContainer(false);
+        mMraidWebView.setVerticalScrollBarEnabled(false);
+        mMraidWebView.setHorizontalScrollBarEnabled(false);
+        mMraidWebView.setBackgroundColor(Color.BLACK);
+
+        mMraidWebView.setWebViewClient(mMraidWebViewClient);
+
+        mMraidWebView.setWebChromeClient(new WebChromeClient() {
+            @Override
+            public boolean onJsAlert(final WebView view, final String url, final String message,
+                    final JsResult result) {
+                if (mMraidBridgeListener != null) {
+                    return mMraidBridgeListener.onJsAlert(message, result);
+                }
+                return super.onJsAlert(view, url, message, result);
+            }
+
+            @Override
+            public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+                if (mMraidBridgeListener != null) {
+                    return mMraidBridgeListener.onConsoleMessage(consoleMessage);
+                }
+                return super.onConsoleMessage(consoleMessage);
+            }
+
+            @Override
+            public void onShowCustomView(final View view, final CustomViewCallback callback) {
+                super.onShowCustomView(view, callback);
+            }
+        });
+
+        final ViewGestureDetector gestureDetector = new ViewGestureDetector(
+                mMraidWebView.getContext(), mMraidWebView, mAdReport);
+        gestureDetector.setUserClickListener(new UserClickListener() {
+            @Override
+            public void onUserClick() {
+                mIsClicked = true;
+            }
+
+            @Override
+            public void onResetUserClick() {
+                mIsClicked = false;
+            }
+
+            @Override
+            public boolean wasClicked() {
+                return mIsClicked;
+            }
+        });
+
+        mMraidWebView.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(final View v, final MotionEvent event) {
+                gestureDetector.sendTouchEvent(event);
+
+                switch (event.getAction()) {
+                    case MotionEvent.ACTION_DOWN:
+                    case MotionEvent.ACTION_UP:
+                        if (!v.hasFocus()) {
+                            v.requestFocus();
+                        }
+                        break;
+                }
+                return false;
+            }
+        });
+
+        mMraidWebView.setVisibilityChangedListener(new OnVisibilityChangedListener() {
+            @Override
+            public void onVisibilityChanged(final boolean isVisible) {
+                if (mMraidBridgeListener != null) {
+                    mMraidBridgeListener.onVisibilityChanged(isVisible);
+                }
+            }
+        });
+    }
+
+    void detach() {
+        mMraidWebView = null;
+    }
+
+    public void setContentHtml(@NonNull String htmlData) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("MRAID bridge called setContentHtml before WebView was attached");
+            return;
+        }
+
+        mHasLoaded = false;
+        mMraidWebView.loadDataWithBaseURL(null, htmlData, "text/html", "UTF-8", null);
+    }
+
+    public void setContentUrl(String url) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("MRAID bridge called setContentHtml while WebView was not attached");
+            return;
+        }
+
+        mHasLoaded = false;
+        mMraidWebView.loadUrl(url);
+    }
+
+    void injectJavaScript(@NonNull String javascript) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("Attempted to inject Javascript into MRAID WebView while was not "
+                    + "attached:\n\t" + javascript);
+            return;
+        }
+        MoPubLog.v("Injecting Javascript into MRAID WebView:\n\t" + javascript);
+        mMraidWebView.loadUrl("javascript:" + javascript);
+    }
+
+    private void fireErrorEvent(@NonNull MraidJavascriptCommand command, @NonNull String message) {
+        injectJavaScript("window.mraidbridge.notifyErrorEvent("
+                + JSONObject.quote(command.toJavascriptString()) + ", "
+                + JSONObject.quote(message) + ")");
+    }
+
+    private void fireNativeCommandCompleteEvent(@NonNull MraidJavascriptCommand command) {
+        injectJavaScript("window.mraidbridge.nativeCallComplete("
+                + JSONObject.quote(command.toJavascriptString()) + ")");
+    }
+
+    public static class MraidWebView extends BaseWebView {
+        public interface OnVisibilityChangedListener {
+            void onVisibilityChanged(boolean isVisible);
+        }
+
+        @Nullable private OnVisibilityChangedListener mOnVisibilityChangedListener;
+
+        private boolean mIsVisible;
+
+        public MraidWebView(Context context) {
+            super(context);
+            mIsVisible = getVisibility() == View.VISIBLE;
+        }
+
+        void setVisibilityChangedListener(@Nullable OnVisibilityChangedListener listener) {
+            mOnVisibilityChangedListener = listener;
+        }
+
+        @Override
+        protected void onVisibilityChanged(@NonNull View changedView, int visibility) {
+            super.onVisibilityChanged(changedView, visibility);
+            boolean newIsVisible = (visibility == View.VISIBLE);
+            if (newIsVisible != mIsVisible) {
+                mIsVisible = newIsVisible;
+                if (mOnVisibilityChangedListener != null) {
+                    mOnVisibilityChangedListener.onVisibilityChanged(mIsVisible);
+                }
+            }
+        }
+
+        public boolean isVisible() {
+            return mIsVisible;
+        }
+    }
+
+    private final WebViewClient mMraidWebViewClient = new WebViewClient() {
+        @Override
+        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
+            MoPubLog.d("Error: " + description);
+            super.onReceivedError(view, errorCode, description, failingUrl);
+        }
+
+        @Override
+        public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String url) {
+            return handleShouldOverrideUrl(url);
+        }
+
+        @Override
+        public void onPageFinished(@NonNull WebView view, @NonNull String url) {
+            handlePageFinished();
+        }
+    };
+
+    @VisibleForTesting
+    boolean handleShouldOverrideUrl(@NonNull final String url) {
+        URI uri;
+        try {
+            uri = new URI(url);
+        } catch (URISyntaxException e) {
+            MoPubLog.w("Invalid MRAID URL: " + url);
+            fireErrorEvent(MraidJavascriptCommand.UNSPECIFIED, "Mraid command sent an invalid URL");
+            return true;
+        }
+
+        // Note that scheme will be null when we are passed a relative Uri
+        String scheme = uri.getScheme();
+        String host = uri.getHost();
+
+        if ("mopub".equals(scheme)) {
+            if ("failLoad".equals(host)) {
+                if (mPlacementType == PlacementType.INLINE && mMraidBridgeListener != null) {
+                    mMraidBridgeListener.onPageFailedToLoad();
+                }
+            }
+            return true;
+        }
+
+        if ("mraid".equals(scheme)) {
+            Map<String, String> params = new HashMap<String, String>();
+            for (NameValuePair pair : URLEncodedUtils.parse(uri, "UTF-8")) {
+                params.put(pair.getName(), pair.getValue());
+            }
+            MraidJavascriptCommand command = MraidJavascriptCommand.fromJavascriptString(host);
+            try {
+                runCommand(command, params);
+            } catch (MraidCommandException exception) {
+                fireErrorEvent(command, exception.getMessage());
+            }
+            fireNativeCommandCompleteEvent(command);
+            return true;
+        }
+
+        // This block handles all other URLs, including sms://, tel://,
+        // clicking a hyperlink, or setting window.location directly in Javascript. It checks for
+        // clicked in order to avoid interfering with automatically browser redirects.
+        if (mIsClicked) {
+            Intent intent = new Intent();
+            intent.setAction(Intent.ACTION_VIEW);
+            intent.setData(Uri.parse(url));
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+            try {
+                if (mMraidWebView == null) {
+                    MoPubLog.d("WebView was detached. Unable to load a URL");
+                    return true;
+                }
+                mMraidWebView.getContext().startActivity(intent);
+                return true;
+            } catch (ActivityNotFoundException e) {
+                MoPubLog.d("No activity found to handle this URL " + url);
+                return false;
+            }
+        }
+
+        return false;
+    }
+
+    @VisibleForTesting
+    private void handlePageFinished() {
+        // This can happen a second time if the ad does something that changes the window location,
+        // such as a redirect, changing window.location in Javascript, or programmatically clicking
+        // a hyperlink. Note that the handleShouldOverrideUrl method skips doing its own
+        // processing if the user hasn't clicked the ad.
+        if (mHasLoaded) {
+            return;
+        }
+
+        mHasLoaded = true;
+        if (mMraidBridgeListener != null) {
+            mMraidBridgeListener.onPageLoaded();
+        }
+    }
+
+    @VisibleForTesting
+    void runCommand(@NonNull final MraidJavascriptCommand command,
+            @NonNull Map<String, String> params)
+            throws MraidCommandException {
+        if (command.requiresClick(mPlacementType) && !mIsClicked) {
+            throw new MraidCommandException("Cannot execute this command unless the user clicks");
+        }
+
+        if (mMraidBridgeListener == null) {
+            throw new MraidCommandException("Invalid state to execute this command");
+        }
+
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("The current WebView is being destroyed");
+        }
+
+        switch (command) {
+            case CLOSE:
+                mMraidBridgeListener.onClose();
+                break;
+            case RESIZE:
+                // All these params are required
+                int width = checkRange(parseSize(params.get("width")), 0, 100000);
+                int height = checkRange(parseSize(params.get("height")), 0, 100000);
+                int offsetX = checkRange(parseSize(params.get("offsetX")), -100000, 100000);
+                int offsetY = checkRange(parseSize(params.get("offsetY")), -100000, 100000);
+                ClosePosition closePosition = parseClosePosition(
+                        params.get("customClosePosition"), ClosePosition.TOP_RIGHT);
+                boolean allowOffscreen = parseBoolean(params.get("allowOffscreen"), true);
+                mMraidBridgeListener.onResize(
+                        width, height, offsetX, offsetY, closePosition, allowOffscreen);
+                break;
+            case EXPAND:
+                URI uri = parseURI(params.get("url"), null);
+                boolean shouldUseCustomClose = parseBoolean(params.get("shouldUseCustomClose"),
+                        false);
+                mMraidBridgeListener.onExpand(uri, shouldUseCustomClose);
+                break;
+            case USE_CUSTOM_CLOSE:
+                shouldUseCustomClose = parseBoolean(params.get("shouldUseCustomClose"), false);
+                mMraidBridgeListener.onUseCustomClose(shouldUseCustomClose);
+                break;
+            case OPEN:
+                uri = parseURI(params.get("url"));
+                mMraidBridgeListener.onOpen(uri);
+                break;
+            case SET_ORIENTATION_PROPERTIES:
+                boolean allowOrientationChange = parseBoolean(params.get("allowOrientationChange"));
+                MraidOrientation forceOrientation = parseOrientation(params.get("forceOrientation"));
+
+                mMraidBridgeListener.onSetOrientationProperties(allowOrientationChange,
+                        forceOrientation);
+                break;
+            case PLAY_VIDEO:
+                uri = parseURI(params.get("uri"));
+                mMraidBridgeListener.onPlayVideo(uri);
+                break;
+            case STORE_PICTURE:
+                uri = parseURI(params.get("uri"));
+                mMraidNativeCommandHandler.storePicture(mMraidWebView.getContext(), uri.toString(),
+                        new MraidCommandFailureListener() {
+                            @Override
+                            public void onFailure(final MraidCommandException exception) {
+                                fireErrorEvent(command, exception.getMessage());
+                            }
+                        });
+                break;
+
+            case CREATE_CALENDAR_EVENT:
+                mMraidNativeCommandHandler.createCalendarEvent(mMraidWebView.getContext(), params);
+                break;
+            case UNSPECIFIED:
+                throw new MraidCommandException("Unspecified MRAID Javascript command");
+        }
+    }
+
+    private ClosePosition parseClosePosition(@NonNull String text,
+            @NonNull ClosePosition defaultValue)
+            throws MraidCommandException {
+        if (TextUtils.isEmpty(text)) {
+            return defaultValue;
+        }
+
+        if (text.equals("top-left")) {
+            return ClosePosition.TOP_LEFT;
+        } else if (text.equals("top-right")) {
+            return ClosePosition.TOP_RIGHT;
+        } else if (text.equals("center")) {
+            return ClosePosition.CENTER;
+        } else if (text.equals("bottom-left")) {
+            return ClosePosition.BOTTOM_LEFT;
+        } else if (text.equals("bottom-right")) {
+            return ClosePosition.BOTTOM_RIGHT;
+        } else if (text.equals("top-center")) {
+            return ClosePosition.TOP_CENTER;
+        } else if (text.equals("bottom-center")) {
+            return ClosePosition.BOTTOM_CENTER;
+        } else {
+            throw new MraidCommandException("Invalid close position: " + text);
+        }
+    }
+
+    private int parseSize(@NonNull String text) throws MraidCommandException {
+        int result;
+        try {
+            result = Integer.parseInt(text, 10);
+        } catch (NumberFormatException e) {
+            throw new MraidCommandException("Invalid numeric parameter: " + text);
+        }
+        return result;
+    }
+
+    private MraidOrientation parseOrientation(String text) throws MraidCommandException {
+        if ("portrait".equals(text)) {
+            return MraidOrientation.PORTRAIT;
+        } else if ("landscape".equals(text)) {
+            return MraidOrientation.LANDSCAPE;
+        } else if ("none".equals(text)) {
+            return MraidOrientation.NONE;
+        } else {
+            throw new MraidCommandException("Invalid orientation: " + text);
+        }
+    }
+
+    private int checkRange(int value, int min, int max) throws MraidCommandException {
+        if (value < min || value > max) {
+            throw new MraidCommandException("Integer parameter out of range: " + value);
+        }
+        return value;
+    }
+
+    private boolean parseBoolean(
+            @Nullable String text, boolean defaultValue) throws MraidCommandException {
+        if (text == null) {
+            return defaultValue;
+        }
+        return parseBoolean(text);
+    }
+
+    private boolean parseBoolean(final String text) throws MraidCommandException {
+        if ("true".equals(text)) {
+            return true;
+        } else if ("false".equals(text)) {
+            return false;
+        }
+        throw new MraidCommandException("Invalid boolean parameter: " + text);
+    }
+
+    @NonNull
+    private URI parseURI(@Nullable String encodedText, URI defaultValue)
+            throws MraidCommandException {
+        if (encodedText == null) {
+            return defaultValue;
+        }
+        return parseURI(encodedText);
+    }
+
+    @NonNull
+    private URI parseURI(@Nullable String encodedText) throws MraidCommandException {
+        if (encodedText == null) {
+            throw new MraidCommandException("Parameter cannot be null");
+        }
+        try {
+            return new URI(encodedText);
+        } catch (URISyntaxException e) {
+            throw new MraidCommandException("Invalid URL parameter: " + encodedText);
+        }
+    }
+
+    void notifyViewability(boolean isViewable) {
+        injectJavaScript("mraidbridge.setIsViewable("
+                + isViewable
+                + ")");
+    }
+
+    void notifyPlacementType(PlacementType placementType) {
+        injectJavaScript("mraidbridge.setPlacementType("
+                + JSONObject.quote(placementType.toJavascriptString())
+                + ")");
+    }
+
+    void notifyViewState(ViewState state) {
+        injectJavaScript("mraidbridge.setState("
+                + JSONObject.quote(state.toJavascriptString())
+                + ")");
+    }
+
+    void notifySupports(boolean sms, boolean telephone, boolean calendar,
+            boolean storePicture, boolean inlineVideo) {
+        injectJavaScript("mraidbridge.setSupports("
+                + sms + "," + telephone + "," + calendar + "," + storePicture + "," + inlineVideo
+                + ")");
+    }
+
+    @NonNull
+    private String stringifyRect(Rect rect) {
+        return rect.left + "," + rect.top + "," + rect.width() + "," + rect.height();
+    }
+
+    @NonNull
+    private String stringifySize(Rect rect) {
+        return rect.width() + "," + rect.height();
+    }
+
+    public void notifyScreenMetrics(@NonNull final MraidScreenMetrics screenMetrics) {
+        injectJavaScript("mraidbridge.setScreenSize("
+                + stringifySize(screenMetrics.getScreenRectDips())
+                + ");mraidbridge.setMaxSize("
+                + stringifySize(screenMetrics.getRootViewRectDips())
+                + ");mraidbridge.setCurrentPosition("
+                + stringifyRect(screenMetrics.getCurrentAdRectDips())
+                + ");mraidbridge.setDefaultPosition("
+                + stringifyRect(screenMetrics.getDefaultAdRectDips())
+                + ")");
+        injectJavaScript("mraidbridge.notifySizeChangeEvent("
+                + stringifySize(screenMetrics.getCurrentAdRect())
+                + ")");
+    }
+
+    void notifyReady() {
+        injectJavaScript("mraidbridge.notifyReadyEvent();");
+    }
+
+    boolean isClicked() {
+        return mIsClicked;
+    }
+
+    boolean isVisible() {
+        return mMraidWebView != null && mMraidWebView.isVisible();
+    }
+
+    boolean isAttached() {
+        return mMraidWebView != null;
+    }
+
+    boolean isLoaded() {
+        return mHasLoaded;
+    }
+
+    @VisibleForTesting
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    void setClicked(boolean clicked) {
+        mIsClicked = clicked;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java
new file mode 100644
index 00000000..3db8e050
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java
@@ -0,0 +1,19 @@
+package com.mopub.mraid;
+
+class MraidCommandException extends Exception {
+    MraidCommandException() {
+        super();
+    }
+
+    MraidCommandException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    MraidCommandException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+
+    MraidCommandException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
new file mode 100644
index 00000000..cfb4bcf9
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
@@ -0,0 +1,1116 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.graphics.Rect;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver.OnPreDrawListener;
+import android.view.WindowManager;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Views;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.util.WebViews;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+
+import java.lang.ref.WeakReference;
+import java.net.URI;
+
+import static android.content.pm.ActivityInfo.CONFIG_ORIENTATION;
+import static android.content.pm.ActivityInfo.CONFIG_SCREEN_SIZE;
+import static com.mopub.common.util.Utils.bitMaskContainsFlag;
+
+public class MraidController {
+    private final AdReport mAdReport;
+
+    public interface MraidListener {
+        public void onLoaded(View view);
+        public void onFailedToLoad();
+        public void onExpand();
+        public void onOpen();
+        public void onClose();
+    }
+
+    public interface UseCustomCloseListener {
+        public void useCustomCloseChanged(boolean useCustomClose);
+    }
+
+    /**
+     * Holds a weak reference to the activity if the context that is passed in is an activity.
+     * While this field is never null, the reference could become null. This reference starts out
+     * null if the passed-in context is not an activity.
+     */
+    @NonNull private final WeakReference<Activity> mWeakActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final PlacementType mPlacementType;
+
+    // An ad container, which contains the ad web view in default state, but is empty when expanded.
+    @NonNull private final FrameLayout mDefaultAdContainer;
+
+    // Ad ad container which contains the ad view in expanded state.
+    @NonNull private final CloseableLayout mCloseableAdContainer;
+
+    // Root view, where we'll add the expanded ad
+    @Nullable private ViewGroup mRootView;
+
+    // Helper classes for updating screen values
+    @NonNull private final ScreenMetricsWaiter mScreenMetricsWaiter;
+    @NonNull private final MraidScreenMetrics mScreenMetrics;
+
+    // Current view state
+    @NonNull private ViewState mViewState = ViewState.LOADING;
+
+    // Listeners
+    @Nullable private MraidListener mMraidListener;
+    @Nullable private UseCustomCloseListener mOnCloseButtonListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    // The WebView which will display the ad. "Two part" creatives, loaded via handleExpand(URL)
+    // are shown in a separate web view
+    @Nullable private MraidWebView mMraidWebView;
+    @Nullable private MraidWebView mTwoPartWebView;
+
+    // A bridge to handle all interactions with the WebView HTML and Javascript.
+    @NonNull private final MraidBridge mMraidBridge;
+    @NonNull private final MraidBridge mTwoPartBridge;
+
+    @NonNull private OrientationBroadcastReceiver mOrientationBroadcastReceiver =
+            new OrientationBroadcastReceiver();
+
+    // Stores the requested orientation for the Activity to which this controller's view belongs.
+    // This is needed to restore the Activity's requested orientation in the event that the view
+    // itself requires an orientation lock.
+    @Nullable private Integer mOriginalActivityOrientation;
+
+    private boolean mAllowOrientationChange = true;
+    private MraidOrientation mForceOrientation = MraidOrientation.NONE;
+
+    private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    private boolean mIsPaused;
+
+    public MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType) {
+        this(context, adReport, placementType,
+                new MraidBridge(adReport, placementType),
+                new MraidBridge(adReport, PlacementType.INTERSTITIAL),
+                new ScreenMetricsWaiter());
+    }
+
+    @VisibleForTesting
+    MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType,
+            @NonNull MraidBridge bridge, @NonNull MraidBridge twoPartBridge,
+            @NonNull ScreenMetricsWaiter screenMetricsWaiter) {
+        mContext = context.getApplicationContext();
+        Preconditions.checkNotNull(mContext);
+        mAdReport = adReport;
+        if (context instanceof Activity) {
+            mWeakActivity = new WeakReference<Activity>((Activity) context);
+        } else {
+            // Make sure mWeakActivity itself is never null, though the reference
+            // it's pointing to could be null.
+            mWeakActivity = new WeakReference<Activity>(null);
+        }
+
+        mPlacementType = placementType;
+        mMraidBridge = bridge;
+        mTwoPartBridge = twoPartBridge;
+        mScreenMetricsWaiter = screenMetricsWaiter;
+
+        mViewState = ViewState.LOADING;
+
+        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+        mScreenMetrics = new MraidScreenMetrics(mContext, displayMetrics.density);
+        mDefaultAdContainer = new FrameLayout(mContext);
+        mCloseableAdContainer = new CloseableLayout(mContext);
+        mCloseableAdContainer.setOnCloseListener(new OnCloseListener() {
+            @Override
+            public void onClose() {
+                handleClose();
+            }
+        });
+
+        View dimmingView = new View(mContext);
+        dimmingView.setOnTouchListener(new OnTouchListener() {
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+        mCloseableAdContainer.addView(dimmingView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        mOrientationBroadcastReceiver.register(mContext);
+
+        mMraidBridge.setMraidBridgeListener(mMraidBridgeListener);
+        mTwoPartBridge.setMraidBridgeListener(mTwoPartBridgeListener);
+        mMraidNativeCommandHandler = new MraidNativeCommandHandler();
+    }
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mMraidBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handlePageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            if (mMraidListener != null) {
+                mMraidListener.onFailedToLoad();
+            }
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The bridge only receives visibility events if there is no 2 part covering it
+            if (!mTwoPartBridge.isAttached()) {
+                mMraidBridge.notifyViewability(isVisible);
+            }
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            handleResize(width, height, offsetX, offsetY, closePosition, allowOffscreen);
+        }
+
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose)
+                throws MraidCommandException {
+            handleExpand(uri, shouldUseCustomClose);
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(@NonNull final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mTwoPartBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handleTwoPartPageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            // no-op for two-part expandables. An expandable failing to load should not trigger failover.
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The original web view must see the 2-part bridges visibility
+            mMraidBridge.notifyViewability(isVisible);
+            mTwoPartBridge.notifyViewability(isVisible);
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            throw new MraidCommandException("Not allowed to resize from an expanded state");
+        }
+
+        @Override
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose) {
+            // The MRAID spec dictates that this is ignored rather than firing an error
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    public void setMraidListener(@Nullable MraidListener mraidListener) {
+        mMraidListener = mraidListener;
+    }
+
+    public void setUseCustomCloseListener(@Nullable UseCustomCloseListener listener) {
+        mOnCloseButtonListener = listener;
+    }
+
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+    }
+
+    public void loadContent(@NonNull String htmlData) {
+        Preconditions.checkState(mMraidWebView == null, "loadContent should only be called once");
+
+        mMraidWebView = new MraidWebView(mContext);
+        mMraidBridge.attachView(mMraidWebView);
+        mDefaultAdContainer.addView(mMraidWebView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        // onPageLoaded gets fired once the html is loaded into the webView
+        mMraidBridge.setContentHtml(htmlData);
+    }
+
+    // onPageLoaded gets fired once the html is loaded into the webView.
+    private int getDisplayRotation() {
+        WindowManager wm = (WindowManager) mContext
+                .getSystemService(Context.WINDOW_SERVICE);
+        return wm.getDefaultDisplay().getRotation();
+    }
+
+    @VisibleForTesting
+    boolean handleConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+        //noinspection SimplifiableIfStatement
+        if (mDebugListener != null) {
+            return mDebugListener.onConsoleMessage(consoleMessage);
+        }
+        return true;
+    }
+
+    @VisibleForTesting
+    boolean handleJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+        if (mDebugListener != null) {
+            return mDebugListener.onJsAlert(message, result);
+        }
+        result.confirm();
+        return true;
+    }
+
+    @VisibleForTesting
+    static class ScreenMetricsWaiter {
+        static class WaitRequest {
+            @NonNull private final View[] mViews;
+            @NonNull private final Handler mHandler;
+            @Nullable private Runnable mSuccessRunnable;
+            int mWaitCount;
+
+            private WaitRequest(@NonNull Handler handler, @NonNull final View[] views) {
+                mHandler = handler;
+                mViews = views;
+            }
+
+            private void countDown() {
+                mWaitCount--;
+                if (mWaitCount == 0 && mSuccessRunnable != null) {
+                    mSuccessRunnable.run();
+                    mSuccessRunnable = null;
+                }
+            }
+
+            private final Runnable mWaitingRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    for (final View view : mViews) {
+                        // Immediately count down for any views that already have a size
+                        if (view.getHeight() > 0 || view.getWidth() > 0) {
+                            countDown();
+                            continue;
+                        }
+
+                        // For views that didn't have a size, listen (once) for a preDraw. Note
+                        // that this doesn't leak because the ViewTreeObserver gets detached when
+                        // the view is no longer part of the view hierarchy.
+                        view.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
+                            @Override
+                            public boolean onPreDraw() {
+                                view.getViewTreeObserver().removeOnPreDrawListener(this);
+                                countDown();
+                                return true;
+                            }
+                        });
+                    }
+                }
+            };
+
+            void start(@NonNull Runnable successRunnable) {
+                mSuccessRunnable = successRunnable;
+                mWaitCount = mViews.length;
+                mHandler.post(mWaitingRunnable);
+            }
+
+            void cancel() {
+                mHandler.removeCallbacks(mWaitingRunnable);
+                mSuccessRunnable = null;
+            }
+        }
+
+        @NonNull private final Handler mHandler = new Handler();
+        @Nullable private WaitRequest mLastWaitRequest;
+
+        WaitRequest waitFor(@NonNull View... views) {
+            mLastWaitRequest = new WaitRequest(mHandler, views);
+            return mLastWaitRequest;
+        }
+
+        void cancelLastRequest() {
+            if (mLastWaitRequest != null) {
+                mLastWaitRequest.cancel();
+                mLastWaitRequest = null;
+            }
+        }
+    }
+
+    @Nullable
+    private View getCurrentWebView() {
+        return mTwoPartBridge.isAttached() ? mTwoPartWebView : mMraidWebView;
+    }
+
+    private boolean isInlineVideoAvailable() {
+        //noinspection SimplifiableIfStatement
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || getCurrentWebView() == null) {
+            return false;
+        }
+
+        return mMraidNativeCommandHandler.isInlineVideoAvailable(activity, getCurrentWebView());
+    }
+
+    @VisibleForTesting
+    void handlePageLoad() {
+        setViewState(ViewState.DEFAULT, new Runnable() {
+            @Override
+            public void run() {
+                mMraidBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        MraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        MraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mMraidBridge.notifyPlacementType(mPlacementType);
+                mMraidBridge.notifyViewability(mMraidBridge.isVisible());
+                mMraidBridge.notifyReady();
+            }
+        });
+
+        // Call onLoaded immediately. This causes the container to get added to the view hierarchy
+        if (mMraidListener != null) {
+            mMraidListener.onLoaded(mDefaultAdContainer);
+        }
+    }
+
+    @VisibleForTesting
+    void handleTwoPartPageLoad() {
+        updateScreenMetricsAsync(new Runnable() {
+            @Override
+            public void run() {
+                mTwoPartBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        mMraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        mMraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mTwoPartBridge.notifyViewState(mViewState);
+                mTwoPartBridge.notifyPlacementType(mPlacementType);
+                mTwoPartBridge.notifyViewability(mTwoPartBridge.isVisible());
+                mTwoPartBridge.notifyReady();
+            }
+        });
+    }
+
+    /**
+     * Updates screen metrics, calling the successRunnable once they are available. The
+     * successRunnable will always be called asynchronously, ie on the next main thread loop.
+     */
+    private void updateScreenMetricsAsync(@Nullable final Runnable successRunnable) {
+        // Don't allow multiple metrics wait requests at once
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        // Determine which web view should be used for the current ad position
+        final View currentWebView = getCurrentWebView();
+        if (currentWebView == null) {
+            return;
+        }
+
+        // Wait for the next draw pass on the default ad container and current web view
+        mScreenMetricsWaiter.waitFor(mDefaultAdContainer, currentWebView).start(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+                        mScreenMetrics.setScreenSize(
+                                displayMetrics.widthPixels, displayMetrics.heightPixels);
+
+                        int[] location = new int[2];
+                        View rootView = getRootView();
+                        rootView.getLocationOnScreen(location);
+                        mScreenMetrics.setRootViewPosition(location[0], location[1],
+                                rootView.getWidth(),
+                                rootView.getHeight());
+
+                        mDefaultAdContainer.getLocationOnScreen(location);
+                        mScreenMetrics.setDefaultAdPosition(location[0], location[1],
+                                mDefaultAdContainer.getWidth(),
+                                mDefaultAdContainer.getHeight());
+
+                        currentWebView.getLocationOnScreen(location);
+                        mScreenMetrics.setCurrentAdPosition(location[0], location[1],
+                                currentWebView.getWidth(),
+                                currentWebView.getHeight());
+
+                        // Always notify both bridges of the new metrics
+                        mMraidBridge.notifyScreenMetrics(mScreenMetrics);
+                        if (mTwoPartBridge.isAttached()) {
+                            mTwoPartBridge.notifyScreenMetrics(mScreenMetrics);
+                        }
+
+                        if (successRunnable != null) {
+                            successRunnable.run();
+                        }
+                    }
+                });
+    }
+
+    void handleOrientationChange(int currentRotation) {
+        updateScreenMetricsAsync(null);
+    }
+
+    public void pause(boolean isFinishing) {
+        mIsPaused = true;
+
+        // This causes an inline video to pause if there is one playing
+        if (mMraidWebView != null) {
+            WebViews.onPause(mMraidWebView, isFinishing);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onPause(mTwoPartWebView, isFinishing);
+        }
+    }
+
+    public void resume() {
+        mIsPaused = false;
+
+        // This causes an inline video to resume if it was playing previously
+        if (mMraidWebView != null) {
+            WebViews.onResume(mMraidWebView);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onResume(mTwoPartWebView);
+        }
+    }
+
+    public void destroy() {
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        try {
+            mOrientationBroadcastReceiver.unregister();
+        } catch (IllegalArgumentException e) {
+            if (!e.getMessage().contains("Receiver not registered")) {
+                throw e;
+            } // Else ignore this exception.
+        }
+
+        // Pause the controller to make sure the video gets stopped.
+        if (!mIsPaused) {
+            pause(true);
+        }
+
+        // Remove the closeable ad container from the view hierarchy, if necessary
+        Views.removeFromParent(mCloseableAdContainer);
+
+        // Calling destroy eliminates a memory leak on Gingerbread devices
+        mMraidBridge.detach();
+        if (mMraidWebView != null) {
+            mMraidWebView.destroy();
+            mMraidWebView = null;
+        }
+        mTwoPartBridge.detach();
+        if (mTwoPartWebView != null) {
+            mTwoPartWebView.destroy();
+            mTwoPartWebView = null;
+        }
+    }
+
+    private void setViewState(@NonNull ViewState viewState) {
+        setViewState(viewState, null);
+    }
+
+    private void setViewState(@NonNull ViewState viewState, @Nullable Runnable successRunnable) {
+        // Make sure this is a valid transition.
+        MoPubLog.d("MRAID state set to " + viewState);
+        mViewState = viewState;
+        mMraidBridge.notifyViewState(viewState);
+
+        // Changing state notifies the two part view, but only if it's loaded
+        if (mTwoPartBridge.isLoaded()) {
+            mTwoPartBridge.notifyViewState(viewState);
+        }
+
+        if (mMraidListener != null) {
+            if (viewState == ViewState.EXPANDED) {
+                mMraidListener.onExpand();
+            } else if (viewState == ViewState.HIDDEN) {
+                mMraidListener.onClose();
+            }
+        }
+
+        updateScreenMetricsAsync(successRunnable);
+    }
+
+    int clampInt(int min, int target, int max) {
+        return Math.max(min, Math.min(target, max));
+    }
+
+    @VisibleForTesting
+    void handleResize(final int widthDips, final int heightDips, final int offsetXDips,
+            final int offsetYDips, @NonNull final ClosePosition closePosition,
+            final boolean allowOffscreen)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to resize after the WebView is destroyed");
+        }
+
+        // The spec says that there is no effect calling resize from loaded or hidden, but that
+        // calling it from expanded should raise an error.
+        if (mViewState == ViewState.LOADING
+                || mViewState == ViewState.HIDDEN) {
+            return;
+        } else if (mViewState == ViewState.EXPANDED) {
+            throw new MraidCommandException("Not allowed to resize from an already expanded ad");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            throw new MraidCommandException("Not allowed to resize from an interstitial ad");
+        }
+
+        // Translate coordinates to px and get the resize rect
+        int width = Dips.dipsToIntPixels(widthDips, mContext);
+        int height = Dips.dipsToIntPixels(heightDips, mContext);
+        int offsetX = Dips.dipsToIntPixels(offsetXDips, mContext);
+        int offsetY = Dips.dipsToIntPixels(offsetYDips, mContext);
+        int left = mScreenMetrics.getDefaultAdRect().left + offsetX;
+        int top = mScreenMetrics.getDefaultAdRect().top + offsetY;
+        Rect resizeRect = new Rect(left, top, left + width, top + height);
+
+        if (!allowOffscreen) {
+            // Require the entire ad to be on-screen.
+            Rect bounds = mScreenMetrics.getRootViewRect();
+            if (resizeRect.width() > bounds.width() || resizeRect.height() > bounds.height()) {
+                throw new MraidCommandException("resizeProperties specified a size ("
+                        + widthDips + ", " + heightDips + ") and offset ("
+                        + offsetXDips + ", " + offsetYDips + ") that doesn't allow the ad to"
+                        + " appear within the max allowed size ("
+                        + mScreenMetrics.getRootViewRectDips().width() + ", "
+                        + mScreenMetrics.getRootViewRectDips().height() + ")");
+            }
+
+            // Offset the resize rect so that it displays on the screen
+            int newLeft = clampInt(bounds.left, resizeRect.left, bounds.right - resizeRect.width());
+            int newTop = clampInt(bounds.top, resizeRect.top, bounds.bottom - resizeRect.height());
+            resizeRect.offsetTo(newLeft, newTop);
+        }
+
+        // The entire close region must always be visible.
+        Rect closeRect = new Rect();
+        mCloseableAdContainer.applyCloseRegionBounds(closePosition, resizeRect, closeRect);
+        if (!mScreenMetrics.getRootViewRect().contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + heightDips + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that doesn't allow the close"
+                    + " region to appear within the max allowed size ("
+                    + mScreenMetrics.getRootViewRectDips().width() + ", "
+                    + mScreenMetrics.getRootViewRectDips().height() + ")");
+        }
+
+        if (!resizeRect.contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + height + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
+                    + "within the resized ad.");
+        }
+
+        // Resized ads always rely on the creative's close button (as if useCustomClose were true)
+        mCloseableAdContainer.setCloseVisible(false);
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        // Put the ad in the closeable container and resize it
+        LayoutParams layoutParams = new LayoutParams(resizeRect.width(), resizeRect.height());
+        layoutParams.leftMargin = resizeRect.left - mScreenMetrics.getRootViewRect().left;
+        layoutParams.topMargin = resizeRect.top - mScreenMetrics.getRootViewRect().top;
+        if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.removeView(mMraidWebView);
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            mCloseableAdContainer.addView(mMraidWebView,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+            getRootView().addView(mCloseableAdContainer, layoutParams);
+        } else if (mViewState == ViewState.RESIZED) {
+            mCloseableAdContainer.setLayoutParams(layoutParams);
+        }
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        setViewState(ViewState.RESIZED);
+    }
+
+    void handleExpand(@Nullable URI uri, boolean shouldUseCustomClose)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to expand after the WebView is destroyed");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            return;
+        }
+
+        if (mViewState != ViewState.DEFAULT && mViewState != ViewState.RESIZED) {
+            return;
+        }
+
+        applyOrientation();
+
+        // For two part expands, create a new web view
+        boolean isTwoPart = (uri != null);
+        if (isTwoPart) {
+            // Of note: the two part ad will start off with its view state as LOADING, and will
+            // transition to EXPANDED once the page is fully loaded
+            mTwoPartWebView = new MraidWebView(mContext);
+            mTwoPartBridge.attachView(mTwoPartWebView);
+
+            // onPageLoaded gets fired once the html is loaded into the two part webView
+            mTwoPartBridge.setContentUrl(uri.toString());
+        }
+
+        // Make sure the correct webView is in the closeable  container and make it full screen
+        LayoutParams layoutParams = new LayoutParams(
+                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        if (mViewState == ViewState.DEFAULT) {
+            if (isTwoPart) {
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            } else {
+                mDefaultAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mMraidWebView, layoutParams);
+            }
+            getRootView().addView(mCloseableAdContainer,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        } else if (mViewState == ViewState.RESIZED) {
+            if (isTwoPart) {
+                // Move the ad back to the original container so that when we close the
+                // resized ad, it will be in the correct place
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, layoutParams);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            }
+            // If we were resized and not 2 part, nothing to do.
+        }
+        mCloseableAdContainer.setLayoutParams(layoutParams);
+        handleCustomClose(shouldUseCustomClose);
+
+        // Update to expanded once we have new screen metrics. This won't update the two-part ad,
+        // because it is not yet loaded.
+        setViewState(ViewState.EXPANDED);
+    }
+
+    @VisibleForTesting
+    void handleClose() {
+        if (mMraidWebView == null) {
+            // Doesn't throw an exception because the ad has been destroyed
+            return;
+        }
+
+        if (mViewState == ViewState.LOADING || mViewState == ViewState.HIDDEN) {
+            return;
+        }
+
+        // Unlock the orientation before changing the view hierarchy.
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            unApplyOrientation();
+        }
+
+        if (mViewState == ViewState.RESIZED || mViewState == ViewState.EXPANDED) {
+            if (mTwoPartBridge.isAttached() && mTwoPartWebView != null) {
+                // If we have a two part web view, simply remove it from the closeable container
+                mCloseableAdContainer.removeView(mTwoPartWebView);
+                mTwoPartBridge.detach();
+            } else {
+                // Move the web view from the closeable container back to the default container
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, new LayoutParams(
+                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+                mDefaultAdContainer.setVisibility(View.VISIBLE);
+            }
+            getRootView().removeView(mCloseableAdContainer);
+
+            // Set the view state to default
+            setViewState(ViewState.DEFAULT);
+        } else if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            setViewState(ViewState.HIDDEN);
+        }
+    }
+
+    @NonNull
+    @TargetApi(VERSION_CODES.KITKAT)
+    private ViewGroup getRootView() {
+        if (mRootView == null) {
+            // This method should never be called this method before the container is ready, ie before
+            // handlePageLoad.
+            if (VERSION.SDK_INT >= VERSION_CODES.KITKAT) {
+                Preconditions.checkState(mDefaultAdContainer.isAttachedToWindow());
+            }
+
+            mRootView = (ViewGroup) mDefaultAdContainer.getRootView().findViewById(
+                    android.R.id.content);
+        }
+
+        return mRootView;
+    }
+
+    @VisibleForTesting
+    void handleShowVideo(@NonNull String videoUrl) {
+        MraidVideoPlayerActivity.startMraid(mContext, videoUrl);
+    }
+
+    @VisibleForTesting
+    void lockOrientation(final int screenOrientation) throws MraidCommandException {
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || !shouldAllowForceOrientation(mForceOrientation)) {
+            throw new MraidCommandException("Attempted to lock orientation to unsupported value: " +
+                    mForceOrientation.name());
+        }
+
+        if (mOriginalActivityOrientation == null) {
+            mOriginalActivityOrientation = activity.getRequestedOrientation();
+        }
+
+        activity.setRequestedOrientation(screenOrientation);
+    }
+
+    @VisibleForTesting
+    void applyOrientation() throws MraidCommandException {
+        if (mForceOrientation == MraidOrientation.NONE) {
+            if (mAllowOrientationChange) {
+                // If screen orientation can be changed, an orientation of NONE means that any
+                // orientation lock should be removed
+                unApplyOrientation();
+            } else {
+                final Activity activity = mWeakActivity.get();
+                if (activity == null) {
+                    throw new MraidCommandException("Unable to set MRAID expand orientation to " +
+                            "'none'; expected passed in Activity Context.");
+                }
+
+                // If screen orientation cannot be changed and we can obtain the current
+                // screen orientation, locking it to the current orientation is a best effort
+                lockOrientation(DeviceUtils.getScreenOrientation(activity));
+            }
+        } else {
+            // Otherwise, we have a valid, non-NONE orientation. Lock the screen based on this value
+            lockOrientation(mForceOrientation.getActivityInfoOrientation());
+        }
+    }
+
+    @VisibleForTesting
+    void unApplyOrientation() {
+        final Activity activity = mWeakActivity.get();
+        if (activity != null && mOriginalActivityOrientation != null) {
+            activity.setRequestedOrientation(mOriginalActivityOrientation);
+        }
+        mOriginalActivityOrientation = null;
+    }
+
+    @TargetApi(VERSION_CODES.HONEYCOMB_MR2)
+    @VisibleForTesting
+    boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
+        // NONE is the default and always allowed
+        if (newOrientation == MraidOrientation.NONE) {
+            return true;
+        }
+
+        final Activity activity = mWeakActivity.get();
+        // If we can't obtain an Activity, return false
+        if (activity == null) {
+            return false;
+        }
+
+        final ActivityInfo activityInfo;
+        try {
+            activityInfo = activity.getPackageManager().getActivityInfo(
+                    new ComponentName(activity, activity.getClass()), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        // If an orientation is explicitly declared in the manifest, allow forcing this orientation
+        final int activityOrientation = activityInfo.screenOrientation;
+        if (activityOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+            return activityOrientation == newOrientation.getActivityInfoOrientation();
+        }
+
+        // Make sure the config changes won't tear down the activity when moving to this orientation
+        // The necessary configChanges must always include "orientation"
+        boolean containsNecessaryConfigChanges =
+                bitMaskContainsFlag(activityInfo.configChanges, CONFIG_ORIENTATION);
+
+        // And on API 13+, configChanges must also include "screenSize"
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR2) {
+            containsNecessaryConfigChanges = containsNecessaryConfigChanges
+                    && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
+        }
+
+        return containsNecessaryConfigChanges;
+    }
+
+    @VisibleForTesting
+    void handleCustomClose(boolean useCustomClose) {
+        boolean wasUsingCustomClose = !mCloseableAdContainer.isCloseVisible();
+        if (useCustomClose == wasUsingCustomClose) {
+            return;
+        }
+
+        mCloseableAdContainer.setCloseVisible(!useCustomClose);
+        if (mOnCloseButtonListener != null) {
+            mOnCloseButtonListener.useCustomCloseChanged(useCustomClose);
+        }
+    }
+
+    @NonNull
+    public FrameLayout getAdContainer() {
+        return mDefaultAdContainer;
+    }
+
+    /**
+     * Loads a javascript URL. Useful for running callbacks, such as javascript:webviewDidClose()
+     */
+    public void loadJavascript(@NonNull String javascript) {
+        mMraidBridge.injectJavaScript(javascript);
+    }
+
+    @VisibleForTesting
+    class OrientationBroadcastReceiver extends BroadcastReceiver {
+        @Nullable private Context mContext;
+
+        // -1 until this gets set at least once
+        private int mLastRotation = -1;
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (mContext == null) {
+                return;
+            }
+
+            if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {
+                int orientation = getDisplayRotation();
+
+                if (orientation != mLastRotation) {
+                    mLastRotation = orientation;
+                    handleOrientationChange(mLastRotation);
+                }
+            }
+        }
+
+        public void register(@NonNull final Context context) {
+            Preconditions.checkNotNull(context);
+            mContext = context.getApplicationContext();
+            if (mContext != null) {
+                mContext.registerReceiver(this,
+                        new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
+            }
+        }
+
+        public void unregister() {
+            if (mContext != null) {
+                mContext.unregisterReceiver(this);
+                mContext = null;
+            }
+        }
+    }
+
+    @NonNull
+    public Context getContext() {
+        return mContext;
+    }
+
+    @VisibleForTesting
+    void handleSetOrientationProperties(final boolean allowOrientationChange,
+            final MraidOrientation forceOrientation) throws MraidCommandException {
+        if (!shouldAllowForceOrientation(forceOrientation)) {
+            throw new MraidCommandException(
+                    "Unable to force orientation to " + forceOrientation);
+        }
+
+        mAllowOrientationChange = allowOrientationChange;
+        mForceOrientation = forceOrientation;
+
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            applyOrientation();
+        }
+    }
+
+    /**
+     * Attempts to handle mopubnativebrowser links in the device browser, deep-links in the
+     * corresponding application, and all other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleOpen(@NonNull final String url) {
+        if (mMraidListener != null) {
+            mMraidListener.onOpen();
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .build().handleUrl(mContext, url);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    ViewState getViewState() {
+        return mViewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setViewStateForTesting(@NonNull ViewState viewState) {
+        mViewState = viewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    CloseableLayout getExpandedAdContainer() {
+        return mCloseableAdContainer;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootView(FrameLayout rootView) {
+        mRootView = rootView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootViewSize(int width, int height) {
+        mScreenMetrics.setRootViewPosition(0, 0, width, height);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    Integer getOriginalActivityOrientation() {
+        return mOriginalActivityOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    boolean getAllowOrientationChange() {
+        return mAllowOrientationChange;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidOrientation getForceOrientation() {
+        return mForceOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setOrientationBroadcastReceiver(OrientationBroadcastReceiver receiver) {
+        mOrientationBroadcastReceiver = receiver;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getTwoPartWebView() {
+        return mTwoPartWebView;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java
new file mode 100644
index 00000000..f7e1ae39
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java
@@ -0,0 +1,31 @@
+package com.mopub.mraid;
+
+
+import android.support.annotation.NonNull;
+
+import com.mopub.mobileads.MraidActivity;
+import com.mopub.mobileads.ResponseBodyInterstitial;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+
+class MraidInterstitial extends ResponseBodyInterstitial {
+    private String mHtmlData;
+
+    @Override
+    protected void extractExtras(Map<String, String> serverExtras) {
+        mHtmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
+    }
+
+    @Override
+    protected void preRenderHtml(@NonNull CustomEventInterstitialListener
+            customEventInterstitialListener) {
+        MraidActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
+    }
+
+    @Override
+    public void showInterstitial() {
+        MraidActivity.start(mContext, mAdReport, mHtmlData, mBroadcastIdentifier);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java
new file mode 100644
index 00000000..bb1b175e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java
@@ -0,0 +1,70 @@
+package com.mopub.mraid;
+
+import android.support.annotation.NonNull;
+
+public enum MraidJavascriptCommand {
+    CLOSE("close"),
+    EXPAND("expand") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return placementType == PlacementType.INLINE;
+        }
+    },
+    USE_CUSTOM_CLOSE("usecustomclose"),
+    OPEN("open") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    RESIZE("resize") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    SET_ORIENTATION_PROPERTIES("setOrientationProperties"),
+    PLAY_VIDEO("playVideo") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return placementType == PlacementType.INLINE;
+        }
+    },
+    STORE_PICTURE("storePicture") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    CREATE_CALENDAR_EVENT("createCalendarEvent") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    UNSPECIFIED("");
+
+    @NonNull private final String mJavascriptString;
+
+    MraidJavascriptCommand(@NonNull String javascriptString) {
+        mJavascriptString = javascriptString;
+    }
+
+    static MraidJavascriptCommand fromJavascriptString(@NonNull String string) {
+        for (MraidJavascriptCommand command : MraidJavascriptCommand.values()) {
+            if (command.mJavascriptString.equals(string)) {
+                return command;
+            }
+        }
+
+        return UNSPECIFIED;
+    }
+
+    String toJavascriptString() {
+        return mJavascriptString;
+    }
+
+    boolean requiresClick(@NonNull PlacementType placementType) {
+        return false;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
new file mode 100644
index 00000000..bc0a2d82
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
@@ -0,0 +1,582 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.media.MediaScannerConnection;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build.VERSION_CODES;
+import android.os.Environment;
+import android.provider.CalendarContract;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Intents;
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.VersionCode;
+import com.mopub.mobileads.factories.HttpClientFactory;
+import com.mopub.network.HeaderUtils;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.os.Environment.MEDIA_MOUNTED;
+import static com.mopub.common.HttpClient.*;
+import static com.mopub.common.util.ResponseHeader.LOCATION;
+
+public class MraidNativeCommandHandler {
+    interface MraidCommandFailureListener {
+        void onFailure(MraidCommandException exception);
+    }
+
+    @VisibleForTesting
+    static final String MIME_TYPE_HEADER = "Content-Type";
+
+    private static final int MAX_NUMBER_DAYS_IN_MONTH = 31;
+    private static final String[] DATE_FORMATS = {
+            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
+            "yyyy-MM-dd'T'HH:mmZZZZZ"
+    };
+
+    public static final String ANDROID_CALENDAR_CONTENT_TYPE = "vnd.android.cursor.item/event";
+
+    void createCalendarEvent(final Context context, final Map<String, String> params)
+            throws MraidCommandException {
+        if (isCalendarAvailable(context)) {
+            try {
+                Map<String, Object> calendarParams = translateJSParamsToAndroidCalendarEventMapping(params);
+                Intent intent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
+                for (String key : calendarParams.keySet()) {
+                    Object value = calendarParams.get(key);
+                    if (value instanceof Long) {
+                        intent.putExtra(key, ((Long) value).longValue());
+                    } else if (value instanceof Integer) {
+                        intent.putExtra(key, ((Integer) value).intValue());
+                    } else {
+                        intent.putExtra(key, (String) value);
+                    }
+                }
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                context.startActivity(intent);
+            } catch (ActivityNotFoundException e) {
+                MoPubLog.d("no calendar app installed");
+                throw new MraidCommandException(
+                        "Action is unsupported on this device - no calendar app installed");
+            } catch (IllegalArgumentException e) {
+                MoPubLog.d("create calendar: invalid parameters " + e.getMessage());
+                throw new MraidCommandException(e);
+            } catch (Exception e) {
+                MoPubLog.d("could not create calendar event");
+                throw new MraidCommandException(e);
+            }
+        } else {
+            MoPubLog.d("unsupported action createCalendarEvent for devices pre-ICS");
+            throw new MraidCommandException("Action is " +
+                    "unsupported on this device (need Android version Ice Cream Sandwich or " +
+                    "above)");
+        }
+    }
+
+    void storePicture(@NonNull final Context context,
+            @NonNull final String imageUrl,
+            @NonNull MraidCommandFailureListener failureListener) throws MraidCommandException {
+        if (!isStorePictureSupported(context)) {
+            MoPubLog.d("Error downloading file - the device does not have an SD card mounted, or " +
+                    "the Android permission is not granted.");
+            throw new MraidCommandException("Error downloading file " +
+                    " - the device does not have an SD card mounted, " +
+                    "or the Android permission is not granted.");
+        }
+
+        if (context instanceof Activity) {
+            showUserDialog(context, imageUrl, failureListener);
+        } else {
+            Toast.makeText(context, "Downloading image to Picture gallery...", Toast.LENGTH_SHORT).show();
+            downloadImage(context, imageUrl, failureListener);
+        }
+    }
+
+    boolean isTelAvailable(Context context) {
+        Intent telIntent = new Intent(Intent.ACTION_DIAL);
+        telIntent.setData(Uri.parse("tel:"));
+
+        return Intents.deviceCanHandleIntent(context, telIntent);
+    }
+
+    boolean isSmsAvailable(Context context) {
+        Intent smsIntent = new Intent(Intent.ACTION_VIEW);
+        smsIntent.setData(Uri.parse("sms:"));
+
+        return Intents.deviceCanHandleIntent(context, smsIntent);
+    }
+
+    public static boolean isStorePictureSupported(Context context) {
+        return MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
+                && context.checkCallingOrSelfPermission(WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
+    }
+
+    static boolean isCalendarAvailable(Context context) {
+        Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
+
+        return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
+                && Intents.deviceCanHandleIntent(context, calendarIntent);
+    }
+
+    /**
+     * Inline video support was added in 3.1. Returns true if the activity has hardware acceleration
+     * enabled in its foreground window and only if the View or any ParentView in the view tree
+     * has not had hardware acceleration explicitly turned off.
+     */
+    // TargetApi is needed to access hardware accelerated flags
+    @TargetApi(11)
+    boolean isInlineVideoAvailable(@NonNull Activity activity, @NonNull View view) {
+        // In addition to potential hardware acceleration problems, there is a problem in the WebKit
+        // HTML5VideoView implementation pre-Gingerbread that would result in HTML5VideoViewProxy
+        // holding on to an instance of the WebView even after the WebView is destroyed. For
+        // this reason, we never allow inline video on Gingerbread devices.
+        if (VersionCode.currentApiLevel().isBelow(VersionCode.HONEYCOMB_MR1)) {
+            return false;
+        }
+
+        // Hardware Acceleration
+        // Hardware acceleration for the application and activity is enabled by default
+        // in API >= 14 (Ice Cream Sandwich)
+        // http://developer.android.com/reference/android/R.attr.html#hardwareAccelerated
+        // http://developer.android.com/guide/topics/graphics/hardware-accel.html
+
+        // HTML5 Inline Video
+        // http://developer.android.com/about/versions/android-3.1.html
+
+        // Traverse up the View tree to determine if any views are being software rendered
+        // You can only disable hardware acceleration at the view level by setting the layer type
+        View tempView = view;
+        while (true) {
+            // View#isHardwareAccelerated does not reflect the layer type used to render the view
+            // therefore we have to check for both
+            if (!tempView.isHardwareAccelerated()
+                    || Utils.bitMaskContainsFlag(tempView.getLayerType(), View.LAYER_TYPE_SOFTWARE)) {
+                return false;
+            }
+
+            // If parent is not a view or parent is null then break
+            if (!(tempView.getParent() instanceof View)) {
+                break;
+            }
+
+            tempView = (View)tempView.getParent();
+        }
+
+        // Has hardware acceleration been enabled in the current window?
+        // Hardware acceleration can only be enabled for a window, not disabled
+        // This flag is automatically set by the system if the android:hardwareAccelerated
+        // XML attribute is set to true on an activity or on the application.
+        // http://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_HARDWARE_ACCELERATED
+        Window window = activity.getWindow();
+        if (window != null) {
+            if (Utils.bitMaskContainsFlag(window.getAttributes().flags,
+                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
+    private Map<String, Object> translateJSParamsToAndroidCalendarEventMapping(Map<String, String> params) {
+        Map<String, Object> validatedParamsMapping = new HashMap<String, Object>();
+        if (!params.containsKey("description") || !params.containsKey("start")) {
+            throw new IllegalArgumentException("Missing start and description fields");
+        }
+
+        validatedParamsMapping.put(CalendarContract.Events.TITLE, params.get("description"));
+
+        if (params.containsKey("start") && params.get("start") != null) {
+            Date startDateTime = parseDate(params.get("start"));
+            if (startDateTime != null) {
+                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_BEGIN_TIME, startDateTime.getTime());
+            } else {
+                throw new IllegalArgumentException("Invalid calendar event: start time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
+            }
+        } else {
+            throw new IllegalArgumentException("Invalid calendar event: start is null.");
+        }
+
+        if (params.containsKey("end") && params.get("end") != null) {
+            Date endDateTime = parseDate(params.get("end"));
+            if (endDateTime != null) {
+                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_END_TIME, endDateTime.getTime());
+            } else {
+                throw new IllegalArgumentException("Invalid calendar event: end time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
+            }
+        }
+
+        if (params.containsKey("location")) {
+            validatedParamsMapping.put(CalendarContract.Events.EVENT_LOCATION, params.get("location"));
+        }
+
+        if (params.containsKey("summary")) {
+            validatedParamsMapping.put(CalendarContract.Events.DESCRIPTION, params.get("summary"));
+        }
+
+        if (params.containsKey("transparency")) {
+            validatedParamsMapping.put(
+                    CalendarContract.Events.AVAILABILITY,
+                    params.get("transparency").equals("transparent") ?
+                            CalendarContract.Events.AVAILABILITY_FREE :
+                            CalendarContract.Events.AVAILABILITY_BUSY
+            );
+        }
+
+        validatedParamsMapping.put(CalendarContract.Events.RRULE, parseRecurrenceRule(params));
+
+        return validatedParamsMapping;
+    }
+
+    private Date parseDate(String dateTime) {
+        Date result = null;
+        for (final String DATE_FORMAT : DATE_FORMATS) {
+            try {
+                result = new SimpleDateFormat(DATE_FORMAT, Locale.US).parse(dateTime);
+                if (result != null) {
+                    break;
+                }
+            } catch (ParseException e) {
+                // an exception is okay, just try the next format and find the first one that works
+            }
+        }
+        return result;
+    }
+
+    private String parseRecurrenceRule(Map<String, String> params) throws IllegalArgumentException {
+        StringBuilder rule = new StringBuilder();
+        if (params.containsKey("frequency")) {
+            String frequency = params.get("frequency");
+            int interval = -1;
+            if (params.containsKey("interval")) {
+                interval = Integer.parseInt(params.get("interval"));
+            }
+            if ("daily".equals(frequency)) {
+                rule.append("FREQ=DAILY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+            } else if ("weekly".equals(frequency)) {
+                rule.append("FREQ=WEEKLY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+                if (params.containsKey("daysInWeek")) {
+                    String weekdays = translateWeekIntegersToDays(params.get("daysInWeek"));
+                    if (weekdays == null) {
+                        throw new IllegalArgumentException("invalid ");
+                    }
+                    rule.append("BYDAY=" + weekdays + ";");
+                }
+            } else if ("monthly".equals(frequency)) {
+                rule.append("FREQ=MONTHLY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+                if (params.containsKey("daysInMonth")) {
+                    String monthDays = translateMonthIntegersToDays(params.get("daysInMonth"));
+                    if (monthDays == null) {
+                        throw new IllegalArgumentException();
+                    }
+                    rule.append("BYMONTHDAY=" + monthDays + ";");
+                }
+            } else {
+                throw new IllegalArgumentException("frequency is only supported for daily, weekly, and monthly.");
+            }
+        }
+        return rule.toString();
+    }
+
+    private String translateWeekIntegersToDays(String expression) throws IllegalArgumentException {
+        StringBuilder daysResult = new StringBuilder();
+        boolean[] daysAlreadyCounted = new boolean[7];
+        String[] days = expression.split(",");
+        int dayNumber;
+        for (final String day : days) {
+            dayNumber = Integer.parseInt(day);
+            dayNumber = dayNumber == 7 ? 0 : dayNumber;
+            if (!daysAlreadyCounted[dayNumber]) {
+                daysResult.append(dayNumberToDayOfWeekString(dayNumber) + ",");
+                daysAlreadyCounted[dayNumber] = true;
+            }
+        }
+        if (days.length == 0) {
+            throw new IllegalArgumentException("must have at least 1 day of the week if specifying repeating weekly");
+        }
+        daysResult.deleteCharAt(daysResult.length() - 1);
+        return daysResult.toString();
+    }
+
+    private String translateMonthIntegersToDays(String expression) throws IllegalArgumentException {
+        StringBuilder daysResult = new StringBuilder();
+        boolean[] daysAlreadyCounted = new boolean[2 * MAX_NUMBER_DAYS_IN_MONTH + 1]; //for -31 to 31
+        String[] days = expression.split(",");
+        int dayNumber;
+        for (final String day : days) {
+            dayNumber = Integer.parseInt(day);
+            if (!daysAlreadyCounted[dayNumber + MAX_NUMBER_DAYS_IN_MONTH]) {
+                daysResult.append(dayNumberToDayOfMonthString(dayNumber) + ",");
+                daysAlreadyCounted[dayNumber + MAX_NUMBER_DAYS_IN_MONTH] = true;
+            }
+        }
+        if (days.length == 0) {
+            throw new IllegalArgumentException("must have at least 1 day of the month if specifying repeating weekly");
+        }
+        daysResult.deleteCharAt(daysResult.length() - 1);
+        return daysResult.toString();
+    }
+
+    private String dayNumberToDayOfWeekString(int number) throws IllegalArgumentException {
+        String dayOfWeek;
+        switch (number) {
+            case 0:
+                dayOfWeek = "SU";
+                break;
+            case 1:
+                dayOfWeek = "MO";
+                break;
+            case 2:
+                dayOfWeek = "TU";
+                break;
+            case 3:
+                dayOfWeek = "WE";
+                break;
+            case 4:
+                dayOfWeek = "TH";
+                break;
+            case 5:
+                dayOfWeek = "FR";
+                break;
+            case 6:
+                dayOfWeek = "SA";
+                break;
+            default:
+                throw new IllegalArgumentException("invalid day of week " + number);
+        }
+        return dayOfWeek;
+    }
+
+    private String dayNumberToDayOfMonthString(int number) throws IllegalArgumentException {
+        String dayOfMonth;
+        // https://android.googlesource.com/platform/frameworks/opt/calendar/+/504844526f1b7afec048c6d2976ffb332670d5ba/src/com/android/calendarcommon2/EventRecurrence.java
+        if (number != 0 && number >= -MAX_NUMBER_DAYS_IN_MONTH && number <= MAX_NUMBER_DAYS_IN_MONTH) {
+            dayOfMonth = "" + number;
+        } else {
+            throw new IllegalArgumentException("invalid day of month " + number);
+        }
+        return dayOfMonth;
+    }
+
+    void downloadImage(final Context context, final String uriString,
+            final MraidCommandFailureListener failureListener) {
+        final DownloadImageAsyncTask downloadImageAsyncTask = new DownloadImageAsyncTask(context,
+                new DownloadImageAsyncTask.DownloadImageAsyncTaskListener() {
+                    @Override
+                    public void onSuccess() {
+                        MoPubLog.d("Image successfully saved.");
+                    }
+
+                    @Override
+                    public void onFailure() {
+                        Toast.makeText(context, "Image failed to download.", Toast.LENGTH_SHORT).show();
+                        MoPubLog.d("Error downloading and saving image file.");
+                        failureListener.onFailure(new MraidCommandException("Error " +
+                                "downloading and saving image file."));
+                    }
+                });
+        AsyncTasks.safeExecuteOnExecutor(downloadImageAsyncTask, uriString);
+    }
+
+    private void showUserDialog(final Context context, final String imageUrl,
+            final MraidCommandFailureListener failureListener) {
+        AlertDialog.Builder alertDialogDownloadImage = new AlertDialog.Builder(context);
+        alertDialogDownloadImage
+                .setTitle("Save Image")
+                .setMessage("Download image to Picture gallery?")
+                .setNegativeButton("Cancel", null)
+                .setPositiveButton("Okay", new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        downloadImage(context, imageUrl, failureListener);
+                    }
+                })
+                .setCancelable(true)
+                .show();
+    }
+
+    private static class DownloadImageAsyncTask extends AsyncTask<String, Void, Boolean> {
+        interface DownloadImageAsyncTaskListener {
+            void onSuccess();
+
+            void onFailure();
+        }
+
+        private final Context mContext;
+        private final DownloadImageAsyncTaskListener mListener;
+
+        public DownloadImageAsyncTask(@NonNull final Context context,
+                @NonNull final DownloadImageAsyncTaskListener listener) {
+            super();
+            mContext = context.getApplicationContext();
+            mListener = listener;
+        }
+
+        @Override
+        protected Boolean doInBackground(@NonNull String[] params) {
+            Preconditions.checkState(params.length > 0);
+            Preconditions.checkNotNull(params[0]);
+
+            final File pictureStoragePath = getPictureStoragePath();
+
+            //noinspection ResultOfMethodCallIgnored
+            pictureStoragePath.mkdirs();
+
+            final String uriString = params[0];
+            URI uri = URI.create(uriString);
+
+            final HttpClient httpClient = HttpClientFactory.create();
+            final HttpGet httpGet = initializeHttpGet(uri.toString());
+
+            InputStream pictureInputStream = null;
+            OutputStream pictureOutputStream = null;
+            try {
+                final HttpResponse httpResponse = httpClient.execute(httpGet);
+                pictureInputStream = httpResponse.getEntity().getContent();
+
+                final String redirectLocation = HeaderUtils.extractHeader(httpResponse, LOCATION);
+                if (redirectLocation != null) {
+                    uri = URI.create(redirectLocation);
+                }
+
+                final String pictureFileName = getFileNameForUriAndHttpResponse(uri, httpResponse);
+                final File pictureFile = new File(pictureStoragePath, pictureFileName);
+                pictureOutputStream = new FileOutputStream(pictureFile);
+                Streams.copyContent(pictureInputStream, pictureOutputStream);
+
+                final String pictureFileFullPath = pictureFile.toString();
+                loadPictureIntoGalleryApp(pictureFileFullPath);
+
+                return true;
+            } catch (IOException e) {
+                return false;
+            } finally {
+                Streams.closeStream(pictureInputStream);
+                Streams.closeStream(pictureOutputStream);
+            }
+        }
+
+        @Override
+        protected void onPostExecute(final Boolean success) {
+            if (success != null && success) {
+                mListener.onSuccess();
+            } else {
+                mListener.onFailure();
+            }
+        }
+
+        private String getFileNameForUriAndHttpResponse(final URI uri, final HttpResponse response) {
+            final String path = uri.getPath();
+
+            if (path == null) {
+                return null;
+            }
+
+            String filename = new File(path).getName();
+
+            Header header = response.getFirstHeader(MIME_TYPE_HEADER);
+            if (header != null) {
+                String[] fields = header.getValue().split(";");
+                for (final String field : fields) {
+                    String extension;
+                    if (field.contains("image/")) {
+                        extension = "." + field.split("/")[1];
+                        if (!filename.endsWith(extension)) {
+                            filename += extension;
+                        }
+                        break;
+                    }
+                }
+            }
+
+            return filename;
+        }
+
+        private File getPictureStoragePath() {
+            return new File(Environment.getExternalStorageDirectory(), "Pictures");
+        }
+
+        private void loadPictureIntoGalleryApp(final String filename) {
+            MoPubMediaScannerConnectionClient mediaScannerConnectionClient =
+                    new MoPubMediaScannerConnectionClient(filename, null);
+            final MediaScannerConnection mediaScannerConnection =
+                    new MediaScannerConnection(mContext, mediaScannerConnectionClient);
+            mediaScannerConnectionClient.setMediaScannerConnection(mediaScannerConnection);
+            mediaScannerConnection.connect();
+        }
+    }
+
+    private static class MoPubMediaScannerConnectionClient
+            implements MediaScannerConnection.MediaScannerConnectionClient {
+        private final String mFilename;
+        private final String mMimeType;
+        private MediaScannerConnection mMediaScannerConnection;
+
+        private MoPubMediaScannerConnectionClient(String filename, String mimeType) {
+            mFilename = filename;
+            mMimeType = mimeType;
+        }
+
+        private void setMediaScannerConnection(MediaScannerConnection connection) {
+            mMediaScannerConnection = connection;
+        }
+
+        @Override
+        public void onMediaScannerConnected() {
+            if (mMediaScannerConnection != null) {
+                mMediaScannerConnection.scanFile(mFilename, mMimeType);
+            }
+        }
+
+        @Override
+        public void onScanCompleted(String path, Uri uri) {
+            if (mMediaScannerConnection != null) {
+                mMediaScannerConnection.disconnect();
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java
new file mode 100644
index 00000000..5b2bdb56
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java
@@ -0,0 +1,19 @@
+package com.mopub.mraid;
+
+import android.content.pm.ActivityInfo;
+
+enum MraidOrientation {
+    PORTRAIT(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT),
+    LANDSCAPE(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE),
+    NONE(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+
+    private final int mActivityInfoOrientation;
+
+    MraidOrientation(final int activityInfoOrientation) {
+        mActivityInfoOrientation = activityInfoOrientation;
+    }
+
+    int getActivityInfoOrientation() {
+        return mActivityInfoOrientation;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java
new file mode 100644
index 00000000..972a0577
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java
@@ -0,0 +1,118 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.util.Dips;
+
+/**
+ * Screen metrics needed by the MRAID container.
+ *
+ * Each rectangle is stored using both it's original and scaled coordinates to avoid allocating
+ * extra memory that would otherwise be needed to do these conversions.
+ */
+class MraidScreenMetrics {
+    @NonNull private final Context mContext;
+    @NonNull private final Rect mScreenRect;
+    @NonNull private final Rect mScreenRectDips;
+
+    @NonNull private final Rect mRootViewRect;
+    @NonNull private final Rect mRootViewRectDips;
+
+    @NonNull private final Rect mCurrentAdRect;
+    @NonNull private final Rect mCurrentAdRectDips;
+
+    @NonNull private final Rect mDefaultAdRect;
+    @NonNull private final Rect mDefaultAdRectDips;
+
+    private final float mDensity;
+
+    MraidScreenMetrics(Context context, float density) {
+        mContext = context.getApplicationContext();
+        mDensity = density;
+
+        mScreenRect = new Rect();
+        mScreenRectDips = new Rect();
+
+        mRootViewRect = new Rect();
+        mRootViewRectDips = new Rect();
+
+        mCurrentAdRect = new Rect();
+        mCurrentAdRectDips = new Rect();
+
+        mDefaultAdRect = new Rect();
+        mDefaultAdRectDips = new Rect();
+    }
+
+    private void convertToDips(Rect sourceRect, Rect outRect) {
+        outRect.set(Dips.pixelsToIntDips(sourceRect.left, mContext),
+                Dips.pixelsToIntDips(sourceRect.top, mContext),
+                Dips.pixelsToIntDips(sourceRect.right, mContext),
+                Dips.pixelsToIntDips(sourceRect.bottom, mContext));
+    }
+
+    public float getDensity() {
+        return mDensity;
+    }
+
+    void setScreenSize(int width, int height) {
+        mScreenRect.set(0, 0, width, height);
+        convertToDips(mScreenRect, mScreenRectDips);
+    }
+
+    @NonNull
+    Rect getScreenRect() {
+        return mScreenRect;
+    }
+
+    @NonNull
+    Rect getScreenRectDips() {
+        return mScreenRectDips;
+    }
+
+    void setRootViewPosition(int x, int y, int width, int height) {
+        mRootViewRect.set(x, y, x + width, y + height);
+        convertToDips(mRootViewRect, mRootViewRectDips);
+    }
+
+    @NonNull
+    Rect getRootViewRect() {
+        return mRootViewRect;
+    }
+
+    @NonNull
+    Rect getRootViewRectDips() {
+        return mRootViewRectDips;
+    }
+
+    void setCurrentAdPosition(int x, int y, int width, int height) {
+        mCurrentAdRect.set(x, y, x + width, y + height);
+        convertToDips(mCurrentAdRect, mCurrentAdRectDips);
+    }
+
+    @NonNull
+    Rect getCurrentAdRect() {
+        return mCurrentAdRect;
+    }
+
+    @NonNull
+    Rect getCurrentAdRectDips() {
+        return mCurrentAdRectDips;
+    }
+
+    void setDefaultAdPosition(int x, int y, int width, int height) {
+        mDefaultAdRect.set(x, y, x + width, y + height);
+        convertToDips(mDefaultAdRect, mDefaultAdRectDips);
+    }
+
+    @NonNull
+    Rect getDefaultAdRect() {
+        return mDefaultAdRect;
+    }
+
+    @NonNull
+    Rect getDefaultAdRectDips() {
+        return mDefaultAdRectDips;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
new file mode 100644
index 00000000..ddf7e408
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
@@ -0,0 +1,102 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.graphics.drawable.StateListDrawable;
+import android.media.MediaPlayer;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ImageButton;
+import android.widget.RelativeLayout;
+import android.widget.VideoView;
+
+import com.mopub.common.util.Dips;
+import com.mopub.mobileads.BaseVideoViewController;
+
+import static android.view.View.GONE;
+import static android.view.View.OnClickListener;
+import static android.view.View.VISIBLE;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
+
+public class MraidVideoViewController extends BaseVideoViewController {
+    private static final float CLOSE_BUTTON_SIZE = 50f;
+    private static final float CLOSE_BUTTON_PADDING = 8f;
+
+    private final VideoView mVideoView;
+    private ImageButton mCloseButton;
+    private int mButtonPadding;
+    private int mButtonSize;
+
+    public MraidVideoViewController(final Context context, final Bundle bundle, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+        // No broadcast identifiers are used by MraidVideoViews.
+        super(context, null, baseVideoViewControllerListener);
+
+        mVideoView = new VideoView(context);
+        mVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
+            @Override
+            public void onCompletion(MediaPlayer mp) {
+                mCloseButton.setVisibility(VISIBLE);
+                videoCompleted(true);
+            }
+        });
+
+        mVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener() {
+            @Override
+            public boolean onError(MediaPlayer mediaPlayer, int what, int extra) {
+                mCloseButton.setVisibility(VISIBLE);
+                videoError(false);
+
+                return false;
+            }
+        });
+
+        mVideoView.setVideoPath(bundle.getString(VIDEO_URL));
+    }
+
+    @Override
+    protected void onCreate() {
+        super.onCreate();
+        mButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE, getContext());
+        mButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING, getContext());
+        createInterstitialCloseButton();
+        mCloseButton.setVisibility(GONE);
+        mVideoView.start();
+    }
+
+    @Override
+    protected VideoView getVideoView() {
+        return mVideoView;
+    }
+
+    @Override
+    protected void onDestroy() {}
+
+    @Override
+    protected void onPause() {}
+
+    @Override
+    protected void onResume() {}
+
+    private void createInterstitialCloseButton() {
+        mCloseButton = new ImageButton(getContext());
+        StateListDrawable states = new StateListDrawable();
+        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.createDrawable(
+                getContext()));
+        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.createDrawable(
+                getContext()));
+        mCloseButton.setImageDrawable(states);
+        //noinspection deprecation
+        mCloseButton.setBackgroundDrawable(null);
+        mCloseButton.setOnClickListener(new OnClickListener() {
+            public void onClick(View v) {
+                getBaseVideoViewControllerListener().onFinish();
+            }
+        });
+
+        RelativeLayout.LayoutParams buttonLayout = new RelativeLayout.LayoutParams(mButtonSize, mButtonSize);
+        buttonLayout.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+        buttonLayout.setMargins(mButtonPadding, 0, mButtonPadding, 0);
+        getLayout().addView(mCloseButton, buttonLayout);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java
new file mode 100644
index 00000000..5d1d92c6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java
@@ -0,0 +1,25 @@
+package com.mopub.mraid;
+
+import android.support.annotation.NonNull;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * Debugging callback interface to make it easier for integration tests to debug MRAID ads.
+ */
+@VisibleForTesting
+public interface MraidWebViewDebugListener {
+    /**
+     * @see WebChromeClient#onJsAlert(WebView, String, String, JsResult)
+     */
+    boolean onJsAlert(@NonNull String message, @NonNull JsResult result);
+
+    /**
+     * @see WebChromeClient#onConsoleMessage(ConsoleMessage)
+     */
+    boolean onConsoleMessage(@NonNull ConsoleMessage consoleMessage);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java b/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java
new file mode 100644
index 00000000..5d43c066
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java
@@ -0,0 +1,12 @@
+package com.mopub.mraid;
+
+import java.util.Locale;
+
+public enum PlacementType {
+    INLINE,
+    INTERSTITIAL;
+
+    String toJavascriptString() {
+        return toString().toLowerCase(Locale.US);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java b/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java
new file mode 100644
index 00000000..40fc1cef
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java
@@ -0,0 +1,15 @@
+package com.mopub.mraid;
+
+import java.util.Locale;
+
+public enum ViewState {
+    LOADING,
+    DEFAULT,
+    RESIZED,
+    EXPANDED,
+    HIDDEN;
+
+    public String toJavascriptString() {
+        return toString().toLowerCase(Locale.US);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
index 6cc0ca94..28bd5620 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -2,9 +2,12 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
@@ -18,22 +21,17 @@
  */
 @Deprecated
 public final class AdapterHelper {
-    private final WeakReference<Activity> mActivity;
-    private final Context mApplicationContext;
+    @NonNull private final WeakReference<Activity> mActivity;
+    @NonNull private final Context mApplicationContext;
     private final int mStart;
     private final int mInterval;
 
     @Deprecated
-    public AdapterHelper(final Context context, final int start, final int interval) throws IllegalArgumentException {
-        if (context == null) {
-            throw new IllegalArgumentException("Illegal argument: Context was null.");
-        } else if (!(context instanceof Activity)) {
-            throw new IllegalArgumentException("Illegal argument: Context must be instance of Activity.");
-        } else if (start < 0) {
-            throw new IllegalArgumentException("Illegal argument: negative starting position.");
-        } else if (interval < 2) {
-            throw new IllegalArgumentException("Illegal argument: interval must be at least 2.");
-        }
+    public AdapterHelper(@NonNull final Context context, final int start, final int interval) {
+        Preconditions.checkNotNull(context, "Context cannot be null.");
+        Preconditions.checkArgument(context instanceof Activity, "Context must be an Activity.");
+        Preconditions.checkArgument(start >= 0, "start position must be non-negative");
+        Preconditions.checkArgument(interval >= 2, "interval must be at least 2");
 
         mActivity = new WeakReference<Activity>((Activity) context);
         mApplicationContext = context.getApplicationContext();
@@ -42,15 +40,16 @@ public AdapterHelper(final Context context, final int start, final int interval)
     }
 
     @Deprecated
-    public View getAdView(final View convertView,
-            final ViewGroup parent,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder,
-            final MoPubNativeListener moPubNativeListener) {
+    @NonNull
+    public View getAdView(@Nullable final View convertView,
+            @Nullable final ViewGroup parent,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder,
+            @Nullable @SuppressWarnings("unused") final MoPubNativeListener moPubNativeListener) {
         final Activity activity = mActivity.get();
         if (activity == null) {
-            MoPubLog.d("Weak reference to Activity Context in AdapterHelper became null. " +
-                    "Returning empty view.");
+            MoPubLog.w("Weak reference to Activity Context in"
+                    + " AdapterHelper became null. Returning empty view.");
             return new View(mApplicationContext);
         }
 
@@ -59,8 +58,7 @@ public View getAdView(final View convertView,
                 parent,
                 activity,
                 nativeResponse,
-                viewBinder,
-                moPubNativeListener
+                viewBinder
         );
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
index 9f5b58cf..4f463ba5 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
@@ -1,16 +1,24 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.view.View;
 
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.CustomEventNative.ImageListener;
@@ -22,26 +30,26 @@
         public void onAdImpressed();
         public void onAdClicked();
     }
-    private NativeEventListener mNativeEventListener;
+    @Nullable private NativeEventListener mNativeEventListener;
 
     static final double MIN_STAR_RATING = 0;
     static final double MAX_STAR_RATING = 5;
 
     // Basic fields
-    private String mMainImageUrl;
-    private String mIconImageUrl;
-    private String mClickDestinationUrl;
-    private String mCallToAction;
-    private String mTitle;
-    private String mText;
-    private Double mStarRating;
+    @Nullable private String mMainImageUrl;
+    @Nullable private String mIconImageUrl;
+    @Nullable private String mClickDestinationUrl;
+    @Nullable private String mCallToAction;
+    @Nullable private String mTitle;
+    @Nullable private String mText;
+    @Nullable private Double mStarRating;
 
     // Impression logistics
-    private final Set<String> mImpressionTrackers;
+    @NonNull private final Set<String> mImpressionTrackers;
     private int mImpressionMinTimeViewed;
 
     // Extras
-    private final Map<String, Object> mExtras;
+    @NonNull private final Map<String, Object> mExtras;
 
     // Event Logistics
     private boolean mIsOverridingClickTracker;
@@ -58,6 +66,7 @@
     /**
      * Returns the String url corresponding to the ad's main image.
      */
+    @Nullable
     @Override
     final public String getMainImageUrl() {
         return mMainImageUrl;
@@ -66,6 +75,7 @@ final public String getMainImageUrl() {
     /**
      * Returns the String url corresponding to the ad's icon image.
      */
+    @Nullable
     @Override
     final public String getIconImageUrl() {
         return mIconImageUrl;
@@ -78,6 +88,7 @@ final public String getIconImageUrl() {
      * and {@link BaseForwardingNativeAd#getImpressionMinTimeViewed()} for relevant
      * impression-tracking parameters.
      */
+    @NonNull
     @Override
     final public Set<String> getImpressionTrackers() {
         return new HashSet<String>(mImpressionTrackers);
@@ -86,6 +97,7 @@ final public String getIconImageUrl() {
     /**
      * Returns the String url that the device will attempt to resolve when the ad is clicked.
      */
+    @Nullable
     @Override
     final public String getClickDestinationUrl() {
         return mClickDestinationUrl;
@@ -94,6 +106,7 @@ final public String getClickDestinationUrl() {
     /**
      * Returns the Call To Action String (i.e. "Download" or "Learn More") associated with this ad.
      */
+    @Nullable
     @Override
     final public String getCallToAction() {
         return mCallToAction;
@@ -102,6 +115,7 @@ final public String getCallToAction() {
     /**
      * Returns the String corresponding to the ad's title.
      */
+    @Nullable
     @Override
     final public String getTitle() {
         return mTitle;
@@ -110,6 +124,7 @@ final public String getTitle() {
     /**
      * Returns the String corresponding to the ad's body text.
      */
+    @Nullable
     @Override
     final public String getText() {
         return mText;
@@ -120,6 +135,7 @@ final public String getText() {
      * advertised app. Note that this method may return null if the star rating was either never set
      * or invalid.
      */
+    @Nullable
     @Override
     final public Double getStarRating() {
         return mStarRating;
@@ -150,8 +166,12 @@ final public int getImpressionMinTimeViewed() {
      * Given a particular String key, return the associated Object value from the ad's extras map.
      * See {@link BaseForwardingNativeAd#getExtras()} for more information.
      */
+    @Nullable
     @Override
-    final public Object getExtra(final String key) {
+    final public Object getExtra(@NonNull final String key) {
+        if (!NoThrow.checkNotNull(key, "getExtra key is not allowed to be null")) {
+            return null;
+        }
         return mExtras.get(key);
     }
 
@@ -161,6 +181,7 @@ final public Object getExtra(final String key) {
      * with MoPub's direct-sold native ads or from mediated networks that pass back additional
      * fields.
      */
+    @NonNull
     @Override
     final public Map<String, Object> getExtras() {
         return new HashMap<String, Object>(mExtras);
@@ -190,35 +211,36 @@ final public boolean isOverridingClickTracker() {
 
     // Setters
     @Override
-    public final void setNativeEventListener(final NativeEventListener nativeEventListener) {
+    public final void setNativeEventListener(
+            @Nullable final NativeEventListener nativeEventListener) {
         mNativeEventListener = nativeEventListener;
     }
 
-    final void setMainImageUrl(final String mainImageUrl) {
+    final void setMainImageUrl(@Nullable final String mainImageUrl) {
         mMainImageUrl = mainImageUrl;
     }
 
-    final void setIconImageUrl(final String iconImageUrl) {
+    final void setIconImageUrl(@Nullable final String iconImageUrl) {
         mIconImageUrl = iconImageUrl;
     }
 
-    final void setClickDestinationUrl(final String clickDestinationUrl) {
+    final void setClickDestinationUrl(@Nullable final String clickDestinationUrl) {
         mClickDestinationUrl = clickDestinationUrl;
     }
 
-    final void setCallToAction(final String callToAction) {
+    final void setCallToAction(@Nullable final String callToAction) {
         mCallToAction = callToAction;
     }
 
-    final void setTitle(final String title) {
+    final void setTitle(@Nullable final String title) {
         mTitle = title;
     }
 
-    final void setText(final String text) {
+    final void setText(@Nullable final String text) {
         mText = text;
     }
 
-    final void setStarRating(final Double starRating) {
+    final void setStarRating(@Nullable final Double starRating) {
         if (starRating == null) {
             mStarRating = null;
         } else if (starRating >= MIN_STAR_RATING && starRating <= MAX_STAR_RATING) {
@@ -229,11 +251,17 @@ final void setStarRating(final Double starRating) {
         }
     }
 
-    final void addExtra(final String key, final Object value) {
+    final void addExtra(@NonNull final String key, @Nullable final Object value) {
+        if (!NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
+            return;
+        }
         mExtras.put(key, value);
     }
 
-    final void addImpressionTracker(final String url) {
+    final void addImpressionTracker(@NonNull final String url) {
+        if (!NoThrow.checkNotNull(url, "impressionTracker url is not allowed to be null")) {
+            return;
+        }
         mImpressionTrackers.add(url);
     }
 
@@ -259,7 +287,7 @@ final void setOverridingClickTracker(final boolean isOverridingClickTracker) {
      * This method is optional.
      */
     @Override
-    public void prepare(final View view) { }
+    public void prepare(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -277,7 +305,7 @@ public void recordImpression() { }
      * This method is optional.
      */
     @Override
-    public void handleClick(final View view) { }
+    public void handleClick(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -287,7 +315,7 @@ public void handleClick(final View view) { }
      * This method is optional.
      */
     @Override
-    public void clear(final View view) { }
+    public void clear(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -307,7 +335,9 @@ public void destroy() { }
      * {@link BaseForwardingNativeAd#prepare}.
      */
     protected final void notifyAdImpressed() {
-        mNativeEventListener.onAdImpressed();
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdImpressed();
+        }
     }
 
     /**
@@ -318,7 +348,9 @@ protected final void notifyAdImpressed() {
      * {@link BaseForwardingNativeAd#prepare}.
      */
     protected final void notifyAdClicked() {
-        mNativeEventListener.onAdClicked();
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdClicked();
+        }
     }
 
     /**
@@ -326,19 +358,45 @@ protected final void notifyAdClicked() {
      * cache before calling {@link CustomEventNativeListener#onNativeAdLoaded}. Doing so will
      * force images to cache before displaying the ad.
      */
-    static void preCacheImages(final Context context,
-            final List<String> imageUrls,
-            final ImageListener imageListener) {
-        ImageService.get(context, imageUrls, new ImageService.ImageServiceListener() {
+    static void preCacheImages(@NonNull final Context context,
+            @NonNull final List<String> imageUrls,
+            @NonNull final ImageListener imageListener) {
+        final ImageLoader imageLoader = Networking.getImageLoader(context);
+        // These Atomics are only accessed on the main thread.
+        // We use Atomics here so we can change their values while keeping a reference for the inner class.
+        final AtomicInteger imageCounter = new AtomicInteger(imageUrls.size());
+        final AtomicBoolean anyFailures = new AtomicBoolean(false);
+        ImageLoader.ImageListener volleyImageListener = new ImageLoader.ImageListener() {
             @Override
-            public void onSuccess(final Map<String, Bitmap> bitmaps) {
-                imageListener.onImagesCached();
+            public void onResponse(final ImageLoader.ImageContainer imageContainer, final boolean isImmediate) {
+                // Image Loader returns a "default" response immediately. We want to ignore this
+                // unless the image is already cached.
+                if (imageContainer.getBitmap() != null) {
+                    final int count = imageCounter.decrementAndGet();
+                    if (count == 0 && !anyFailures.get()) {
+                        imageListener.onImagesCached();
+                    }
+                }
             }
 
             @Override
-            public void onFail() {
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to download a native ads image:", volleyError);
+                boolean anyPreviousErrors = anyFailures.getAndSet(true);
+                imageCounter.decrementAndGet();
+                if (!anyPreviousErrors) {
+                    imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                }
+            }
+        };
+
+        for (String url : imageUrls) {
+            if (TextUtils.isEmpty(url)) {
+                anyFailures.set(true);
                 imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                return;
             }
-        });
+            imageLoader.get(url, volleyImageListener);
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
new file mode 100644
index 00000000..8c5961c1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
@@ -0,0 +1,74 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+
+class ClickDestinationResolutionListener implements UrlResolutionTask.UrlResolutionListener {
+    private final Context mContext;
+    private final Iterator<String> mUrlIterator;
+    private final WeakReference<SpinningProgressView> mSpinningProgressView;
+
+    public ClickDestinationResolutionListener(@NonNull final Context context,
+            @NonNull final Iterator<String> urlIterator,
+            @NonNull final SpinningProgressView spinningProgressView) {
+        mContext = context.getApplicationContext();
+        mUrlIterator = urlIterator;
+        mSpinningProgressView = new WeakReference<SpinningProgressView>(spinningProgressView);
+    }
+
+    /**
+     * Called upon user click, after the corresponding UrlResolutionTask has followed all redirects
+     * successfully. Attempts to open mopubnativebrowser links in the device browser, deep-links in
+     * the corresponding application, and all other links in the MoPub in-app browser. In the first
+     * two cases, malformed URLs will try to fallback to the next entry in mUrlIterator, and failing
+     * that, will no-op.
+     */
+    @Override
+    public void onSuccess(@NonNull final String resolvedUrl) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                        if (mUrlIterator.hasNext()) {
+                            UrlResolutionTask.getResolvedUrl(mUrlIterator.next(),
+                                    ClickDestinationResolutionListener.this);
+                        }
+                    }
+                })
+                .build().handleUrl(mContext, resolvedUrl);
+        removeSpinningProgressView();
+    }
+
+    @Override
+    public void onFailure() {
+        MoPubLog.d("Failed to resolve URL for click.");
+        removeSpinningProgressView();
+    }
+
+    private void removeSpinningProgressView() {
+        final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
+        if (spinningProgressView != null) {
+            spinningProgressView.removeFromRoot();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
index bcfea7c7..0809b8d2 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
@@ -1,6 +1,7 @@
 package com.mopub.nativeads;
 
 import android.os.Handler;
+import android.support.annotation.NonNull;
 
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
@@ -8,15 +9,16 @@
  * Returns a preset client positioning object.
  */
 class ClientPositioningSource implements PositioningSource {
-    private Handler mHandler = new Handler();
-    private final MoPubClientPositioning mPositioning;
+    @NonNull private final Handler mHandler = new Handler();
+    @NonNull private final MoPubClientPositioning mPositioning;
 
-    ClientPositioningSource(MoPubClientPositioning positioning) {
+    ClientPositioningSource(@NonNull MoPubClientPositioning positioning) {
         mPositioning = MoPubNativeAdPositioning.clone(positioning);
     }
 
     @Override
-    public void loadPositions(final String adUnitId, final PositioningListener listener) {
+    public void loadPositions(@NonNull final String adUnitId,
+            @NonNull final PositioningListener listener) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
index 03397057..8893bd1f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
@@ -1,47 +1,53 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import java.util.Map;
 
 /**
- * CustomEventNative is a base class for custom events that support native ads. By implementing
- * subclasses of CustomEventNative, you can enable the MoPub SDK to support a wider
- * variety of third-party ad networks, or execute any of your application code on demand.
+ * {@code CustomEventNative} is a base class for custom events that support native ads. By
+ * implementing subclasses of {@code CustomEventNative}, you can enable the MoPub SDK to support a
+ * wider variety of third-party ad networks, or execute any of your application code on demand.
  *
- * At runtime, the MoPub SDK will find and instantiate a CustomEventNative subclass as needed
- * and invoke its loadNativeAd() method.
+ * At runtime, the MoPub SDK will find and instantiate a {@code CustomEventNative} subclass as
+ * needed and invoke its {@link #loadNativeAd} method.
  */
 public abstract class CustomEventNative {
     /**
      * When the MoPub SDK receives a response indicating it should load a custom event, it will send
-     * this message to your custom event class. Your implementation of this method can either load
-     * a native ad from a third-party ad network, or execute any application code. It must also
-     * notify the provided CustomEventNativeListener Object of certain lifecycle events.
+     * this message to your custom event class. Your implementation of this method can either load a
+     * native ad from a third-party ad network, or execute any application code. It must also notify
+     * the provided {@link CustomEventNativeListener} Object of certain lifecycle events.
      *
-     * The localExtras parameter is a Map containing additional custom data that is set within
-     * your application by calling MoPubNative.setLocalExtras(Map<String, Object>). Note that the
-     * localExtras Map is a copy of the Map supplied to setLocalExtras().
-     *
-     * The serverExtras parameter is a Map containing additional custom data configurable on the
-     * MoPub website that you want to associate with a given custom event request. This data may be
-     * used to pass dynamic information, such as publisher IDs, without changes in application code.
+     * @param context The activity context.
+     * @param customEventNativeListener An Object that must be notified of certain lifecycle
+     * events.
+     * @param localExtras A Map containing additional custom data that is set within your
+     * application by calling {@link MoPubNative#setLocalExtras(Map<String, Object>)}. Note that the
+     * localExtras Map is a copy of the Map supplied to {@link MoPubNative#setLocalExtras(Map<String,
+     * Object>)}.
+     * @param serverExtras A Map containing additional custom data configurable on the MoPub website
+     * that you want to associate with a given custom event request. This data may be used to pass
+     * dynamic information, such as publisher IDs, without changes in application code.
      */
-    protected abstract void loadNativeAd(final Context context,
-            final CustomEventNativeListener customEventNativeListener,
-            final Map<String, Object> localExtras,
-            final Map<String, String> serverExtras);
+    protected abstract void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras);
 
     public interface ImageListener {
         /**
-         * Called when images are successfully cached. If you haven't already called
-         * {@link CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
+         * Called when images are successfully cached. If you haven't already called {@link
+         * CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
          */
         void onImagesCached();
 
         /**
-         * Called when images failed to cache. You should typically call
-         * {@link CustomEventNativeListener#onNativeAdFailed} from this callback.
+         * Called when images failed to cache. You should typically call {@link
+         * CustomEventNativeListener#onNativeAdFailed} from this callback.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onImagesFailedToCache(NativeErrorCode errorCode);
     }
@@ -51,6 +57,8 @@ protected abstract void loadNativeAd(final Context context,
          * Your custom event subclass must call this method when it successfully loads a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param nativeAd The ad that was succesfully loaded.
          */
         void onNativeAdLoaded(NativeAdInterface nativeAd);
 
@@ -58,6 +66,8 @@ protected abstract void loadNativeAd(final Context context,
          * Your custom event subclass must call this method when it fails to load a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onNativeAdFailed(NativeErrorCode errorCode);
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
index 224fa646..2f91b815 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
@@ -1,31 +1,25 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.util.Json;
+import com.mopub.common.DataKeys;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
+import com.mopub.network.AdResponse;
 
-import java.util.HashMap;
 import java.util.Map;
 
 final class CustomEventNativeAdapter {
     private CustomEventNativeAdapter() {}
 
-    static final String RESPONSE_BODY_KEY = "response_body_key";
-
-    public static void loadNativeAd(final Context context,
-            final Map<String, Object> localExtras,
-            final DownloadResponse downloadResponse,
-            final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
-
-        final String customEventNativeData = downloadResponse.getFirstHeader(ResponseHeader.CUSTOM_EVENT_DATA);
-        final String customEventNativeClassName = downloadResponse.getFirstHeader(ResponseHeader.CUSTOM_EVENT_NAME);
+    public static void loadNativeAd(@NonNull final Context context,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final AdResponse adResponse,
+            @NonNull final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
 
         final CustomEventNative customEventNative;
+        String customEventNativeClassName = adResponse.getCustomEventClassName();
         try {
             customEventNative = CustomEventNativeFactory.create(customEventNativeClassName);
         } catch (Exception e) {
@@ -34,21 +28,15 @@ public static void loadNativeAd(final Context context,
             return;
         }
 
-        Map<String, String> serverExtras = new HashMap<String, String>();
-        // Attempt to load the JSON extras into mServerExtras.
-        try {
-            serverExtras = Json.jsonStringToMap(customEventNativeData);
-        } catch (Exception e) {
-            MoPubLog.w("Failed to create Map from JSON: " + customEventNativeData, e);
+        if (adResponse.hasJson()) {
+            localExtras.put(DataKeys.JSON_BODY_KEY, adResponse.getJsonBody());
         }
 
-        serverExtras.put(RESPONSE_BODY_KEY, HttpResponses.asResponseString(downloadResponse));
-
         customEventNative.loadNativeAd(
                 context,
                 customEventNativeListener,
                 localExtras,
-                serverExtras
+                adResponse.getServerExtras()
         );
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
index 35508618..176f0e65 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 import com.mopub.common.VisibleForTesting;
@@ -19,27 +21,27 @@
     private static final int PERIOD = 250;
 
     // Object tracking visibility of added views
-    private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
 
     // All views and responses being tracked for impressions
-    private final Map<View, NativeResponse> mTrackedViews;
+    @NonNull private final Map<View, NativeResponse> mTrackedViews;
 
     // Visible views being polled for time on screen before tracking impression
-    private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
+    @NonNull private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
 
     // Handler for polling visible views
-    private final Handler mPollHandler;
+    @NonNull private final Handler mPollHandler;
 
     // Runnable to run on each visibility loop
-    private final PollingRunnable mPollingRunnable;
+    @NonNull private final PollingRunnable mPollingRunnable;
 
     // Object to check actual visibility
-    private final VisibilityChecker mVisibilityChecker;
+    @NonNull private final VisibilityChecker mVisibilityChecker;
 
     // Listener for when a view becomes visible or non visible
-    private VisibilityTrackerListener mVisibilityTrackerListener;
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
-    ImpressionTracker(final Context context) {
+    ImpressionTracker(@NonNull final Context context) {
         this(new WeakHashMap<View, NativeResponse>(),
                 new WeakHashMap<View, TimestampWrapper<NativeResponse>>(),
                 new VisibilityChecker(),
@@ -48,11 +50,11 @@
     }
 
     @VisibleForTesting
-    ImpressionTracker(final Map<View, NativeResponse> trackedViews,
-                      final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
-                      final VisibilityChecker visibilityChecker,
-                      final VisibilityTracker visibilityTracker,
-                      final Handler handler) {
+    ImpressionTracker(@NonNull final Map<View, NativeResponse> trackedViews,
+            @NonNull final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final VisibilityTracker visibilityTracker,
+            @NonNull final Handler handler) {
         mTrackedViews = trackedViews;
         mPollingViews = pollingViews;
         mVisibilityChecker = visibilityChecker;
@@ -60,7 +62,7 @@
 
         mVisibilityTrackerListener = new VisibilityTrackerListener() {
             @Override
-            public void onVisibilityChanged(final List<View> visibleViews, final List<View> invisibleViews) {
+            public void onVisibilityChanged(@NonNull final List<View> visibleViews, @NonNull final List<View> invisibleViews) {
                 for (final View view : visibleViews) {
                     // It's possible for native response to be null if the view was GC'd from this class
                     // but not from VisibilityTracker
@@ -96,7 +98,7 @@ public void onVisibilityChanged(final List<View> visibleViews, final List<View>
     /**
      * Tracks the given view for impressions.
      */
-    void addView(final View view, final NativeResponse nativeResponse) {
+    void addView(final View view, @NonNull final NativeResponse nativeResponse) {
         // View is already associated with same native response
         if (mTrackedViews.get(view) == nativeResponse) {
             return;
@@ -153,7 +155,7 @@ private void removePollingView(final View view) {
     class PollingRunnable implements Runnable {
         // Create this once to avoid excessive garbage collection observed when calculating
         // these on each pass.
-        private final ArrayList<View> mRemovedViews;
+        @NonNull private final ArrayList<View> mRemovedViews;
 
         PollingRunnable() {
             mRemovedViews = new ArrayList<View>();
@@ -189,6 +191,7 @@ public void run() {
         }
     }
 
+    @Nullable
     @Deprecated
     @VisibleForTesting
     VisibilityTrackerListener getVisibilityTrackerListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
index ddd2aac8..23b71feb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.database.DataSetObserver;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Adapter;
@@ -9,12 +11,15 @@
 import android.widget.BaseAdapter;
 import android.widget.ListAdapter;
 import android.widget.ListView;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 
-import java.util.*;
+import java.util.List;
+import java.util.WeakHashMap;
 
 import static android.widget.AdapterView.OnItemClickListener;
 import static android.widget.AdapterView.OnItemLongClickListener;
@@ -32,12 +37,12 @@
  * wish to avoid wrapping your original adapter, you can use {@code MoPubStreamAdPlacer} directly.
  */
 public class MoPubAdAdapter extends BaseAdapter {
-    private final WeakHashMap<View, Integer> mViewPositionMap;
-    private final Adapter mOriginalAdapter;
-    private final MoPubStreamAdPlacer mStreamAdPlacer;
-    private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final WeakHashMap<View, Integer> mViewPositionMap;
+    @NonNull private final Adapter mOriginalAdapter;
+    @NonNull private final MoPubStreamAdPlacer mStreamAdPlacer;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
 
-    private MoPubNativeAdLoadedListener mAdLoadedListener;
+    @Nullable private MoPubNativeAdLoadedListener mAdLoadedListener;
 
     /**
      * Creates a new MoPubAdAdapter object.
@@ -49,7 +54,7 @@
      * @param context The activity context.
      * @param originalAdapter Your original adapter.
      */
-    public MoPubAdAdapter(final Context context, final Adapter originalAdapter) {
+    public MoPubAdAdapter(@NonNull final Context context, @NonNull final Adapter originalAdapter) {
         this(context, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
     }
 
@@ -61,9 +66,9 @@ public MoPubAdAdapter(final Context context, final Adapter originalAdapter) {
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubAdAdapter(final Context context,
-            final Adapter originalAdapter,
-            final MoPubServerPositioning adPositioning) {
+    public MoPubAdAdapter(@NonNull final Context context,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final MoPubServerPositioning adPositioning) {
         this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
                 new VisibilityTracker(context));
     }
@@ -76,17 +81,17 @@ public MoPubAdAdapter(final Context context,
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubAdAdapter(final Context context,
-            final Adapter originalAdapter,
-            final MoPubClientPositioning adPositioning) {
+    public MoPubAdAdapter(@NonNull final Context context,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final MoPubClientPositioning adPositioning) {
         this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
                 new VisibilityTracker(context));
     }
 
     @VisibleForTesting
-    MoPubAdAdapter(final MoPubStreamAdPlacer streamAdPlacer,
-            final Adapter originalAdapter,
-            final VisibilityTracker visibilityTracker) {
+    MoPubAdAdapter(@NonNull final MoPubStreamAdPlacer streamAdPlacer,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final VisibilityTracker visibilityTracker) {
         mOriginalAdapter = originalAdapter;
         mStreamAdPlacer = streamAdPlacer;
         mViewPositionMap = new WeakHashMap<View, Integer>();
@@ -94,7 +99,7 @@ public MoPubAdAdapter(final Context context,
         mVisibilityTracker = visibilityTracker;
         mVisibilityTracker.setVisibilityTrackerListener(new VisibilityTrackerListener() {
             @Override
-            public void onVisibilityChanged(final List<View> visibleViews,
+            public void onVisibilityChanged(@NonNull final List<View> visibleViews,
                     final List<View> invisibleViews) {
                 handleVisibilityChange(visibleViews);
             }
@@ -153,9 +158,9 @@ void handleAdRemoved(final int position) {
      *
      * @param adRenderer The ad renderer.
      */
-    public final void registerAdRenderer(final MoPubAdRenderer adRenderer) {
-        if (adRenderer == null) {
-            MoPubLog.w("Tried to set a null ad renderer on the placer.");
+    public final void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        if (!Preconditions.NoThrow.checkNotNull(
+                adRenderer, "Tried to set a null ad renderer on the placer.")) {
             return;
         }
         mStreamAdPlacer.registerAdRenderer(adRenderer);
@@ -173,7 +178,7 @@ public final void registerAdRenderer(final MoPubAdRenderer adRenderer) {
      *
      * @param listener The listener.
      */
-    public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
+    public final void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
         mAdLoadedListener = listener;
     }
 
@@ -185,7 +190,7 @@ public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void loadAds(final String adUnitId) {
+    public void loadAds(@NonNull final String adUnitId) {
         mStreamAdPlacer.loadAds(adUnitId);
     }
 
@@ -203,8 +208,8 @@ public void loadAds(final String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void loadAds(final String adUnitId,
-            final RequestParameters requestParameters) {
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
         mStreamAdPlacer.loadAds(adUnitId, requestParameters);
     }
 
@@ -280,6 +285,7 @@ public int getCount() {
      *
      * @inheritDoc
      */
+    @Nullable
     @Override
     public Object getItem(final int position) {
         final Object ad = mStreamAdPlacer.getAdData(position);
@@ -323,6 +329,7 @@ public boolean hasStableIds() {
      *
      * @inheritDoc
      */
+    @Nullable
     @Override
     public View getView(final int position, final View view, final ViewGroup viewGroup) {
         final View resultView;
@@ -377,7 +384,7 @@ public boolean isEmpty() {
         return mOriginalAdapter.isEmpty() && mStreamAdPlacer.getAdjustedCount(0) == 0;
     }
 
-    private void handleVisibilityChange(final List<View> visibleViews) {
+    private void handleVisibilityChange(@NonNull final List<View> visibleViews) {
         // Loop through all visible positions in order to build a max and min range, and then
         // place ads into that range.
         int min = Integer.MAX_VALUE;
@@ -451,7 +458,6 @@ public void removeItem(final int originalPosition) {
         mStreamAdPlacer.removeItem(originalPosition);
     }
 
-
     /**
      * Sets an on click listener for the given ListView, automatically adjusting the listener
      * callback positions based on ads in the adapter.
@@ -461,8 +467,17 @@ public void removeItem(final int originalPosition) {
      * @param listView The ListView for this adapter.
      * @param listener An on click listener.
      */
-    public void setOnClickListener(final ListView listView,
-            final OnItemClickListener listener) {
+    public void setOnClickListener(@NonNull final ListView listView,
+            @Nullable final OnItemClickListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setOnClickListener with a" +
+                " null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemClickListener(null);
+            return;
+        }
+
         listView.setOnItemClickListener(new OnItemClickListener() {
             @Override
             public void onItemClick(final AdapterView<?> adapterView, final View view,
@@ -484,8 +499,17 @@ public void onItemClick(final AdapterView<?> adapterView, final View view,
      * @param listView The ListView for this adapter.
      * @param listener An an long click listener.
      */
-    public void setOnItemLongClickListener(final ListView listView,
-            final OnItemLongClickListener listener) {
+    public void setOnItemLongClickListener(@NonNull final ListView listView,
+            @Nullable final OnItemLongClickListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter." +
+                "setOnItemLongClickListener with a null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemLongClickListener(null);
+            return;
+        }
+
         listView.setOnItemLongClickListener(new OnItemLongClickListener() {
             @Override
             public boolean onItemLongClick(final AdapterView<?> adapterView,
@@ -503,8 +527,17 @@ public boolean onItemLongClick(final AdapterView<?> adapterView,
      * @param listView The ListView for this adapter.
      * @param listener An an item selected listener.
      */
-    public void setOnItemSelectedListener(final ListView listView,
-            final OnItemSelectedListener listener) {
+    public void setOnItemSelectedListener(@NonNull final ListView listView,
+            @Nullable final OnItemSelectedListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setOnItemSelectedListener" +
+                " with a null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemSelectedListener(null);
+            return;
+        }
+
         listView.setOnItemSelectedListener(new OnItemSelectedListener() {
             @Override
             public void onItemSelected(final AdapterView<?> adapterView,
@@ -529,7 +562,12 @@ public void onNothingSelected(final AdapterView<?> adapterView) {
      * @param listView The ListView for this adapter.
      * @param originalPosition The original content position before loading ads.
      */
-    public void setSelection(final ListView listView, final int originalPosition) {
+    public void setSelection(@NonNull final ListView listView, final int originalPosition) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setSelection with a null " +
+                "ListView")) {
+            return;
+        }
+
         listView.setSelection(mStreamAdPlacer.getAdjustedPosition(originalPosition));
     }
 
@@ -540,7 +578,13 @@ public void setSelection(final ListView listView, final int originalPosition) {
      * @param listView The ListView for this adapter.
      * @param originalPosition The original content position before loading ads.
      */
-    public void smoothScrollToPosition(final ListView listView, final int originalPosition) {
+    public void smoothScrollToPosition(@NonNull final ListView listView,
+            final int originalPosition) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.smoothScrollToPosition " +
+                "with a null ListView")) {
+            return;
+        }
+
         listView.smoothScrollToPosition(mStreamAdPlacer.getAdjustedPosition(originalPosition));
     }
 
@@ -552,7 +596,7 @@ public void smoothScrollToPosition(final ListView listView, final int originalPo
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void refreshAds(final ListView listView, String adUnitId) {
+    public void refreshAds(@NonNull final ListView listView, @NonNull String adUnitId) {
         refreshAds(listView, adUnitId, null);
     }
 
@@ -565,10 +609,10 @@ public void refreshAds(final ListView listView, String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void refreshAds(final ListView listView,
-            String adUnitId, RequestParameters requestParameters) {
-        if (listView.getAdapter() != this) {
-            MoPubLog.w("You called refreshAds on a ListView whose adapter is not an ad placer");
+    public void refreshAds(@NonNull final ListView listView,
+            @NonNull String adUnitId, @Nullable RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.refreshAds with a null " +
+                "ListView")) {
             return;
         }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
index 87542fb1..ac2f0f29 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
@@ -1,6 +1,8 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
@@ -9,8 +11,8 @@
  *
  * Normally you will use the subclass {@link com.mopub.nativeads.MoPubNativeAdRenderer} with {@link
  * com.mopub.nativeads.ViewBinder} to customize your ad view with your own layout. However, if you
- * wish to programmatically create or manage your ad view, you can implement {@code
- * }MoPubAdRenderer} directly.
+ * wish to programmatically create or manage your ad view, you can implement {@code MoPubAdRenderer}
+ * directly.
  *
  * @param <T> The ad payload type.
  */
@@ -19,21 +21,21 @@
      * Creates a new view to be used as an ad.
      *
      * This method is called when you call {@link com.mopub.nativeads.MoPubStreamAdPlacer#getAdView}
-     * when the convertView is null. You must return a valid view.
+     * and the convertView is null. You must return a valid view.
      *
+     * @param context The context. Useful for creating a view.
      * @param parent The parent that the view will eventually be attached to. You might use the
      * parent to determine layout parameters, but should return the view without attaching it to the
      * parent.
-     * @param context The context. Useful for creating a view.
      * @return A new ad view.
      */
-    View createAdView(Context context, ViewGroup parent);
+    View createAdView(@NonNull Context context, @Nullable ViewGroup parent);
 
     /**
      * Renders a view created by {@link #createAdView} by filling it with ad data.
      *
-     * @param view The ad View
+     * @param view The ad {@link View}
      * @param ad The ad data that should be bound to the view.
      */
-    void renderAdView(View view, T ad);
+    void renderAdView(@NonNull View view, @NonNull T ad);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
index 93f1ad45..6c71875d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
@@ -1,87 +1,87 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.mopub.common.event.ErrorEvent;
+import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import org.json.JSONTokener;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
 import static com.mopub.common.util.Numbers.parseDouble;
-import static com.mopub.nativeads.CustomEventNativeAdapter.RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.JSON_BODY_KEY;
 import static com.mopub.nativeads.NativeResponse.Parameter;
 
 public class MoPubCustomEventNative extends CustomEventNative {
 
     @Override
-    protected void loadNativeAd(final Context context,
-            final CustomEventNativeListener customEventNativeListener,
-            final Map<String, Object> localExtras,
-            final Map<String, String> serverExtras) {
+    protected void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) {
+
+        Object json = localExtras.get(JSON_BODY_KEY);
+        // null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
+        if (!(json instanceof JSONObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
+            return;
+        }
 
         final MoPubForwardingNativeAd moPubForwardingNativeAd =
                 new MoPubForwardingNativeAd(context.getApplicationContext(),
-                        serverExtras.get(RESPONSE_BODY_KEY),
+                        (JSONObject) json,
                         customEventNativeListener);
 
         try {
             moPubForwardingNativeAd.loadAd();
         } catch (IllegalArgumentException e) {
             customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
-            return;
-        } catch (JSONException e) {
-            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
-            return;
         }
     }
 
     static class MoPubForwardingNativeAd extends BaseForwardingNativeAd {
-        private final Context mContext;
-        private final String mJsonString;
-        private final CustomEventNativeListener mCustomEventNativeListener;
-
-        MoPubForwardingNativeAd(final Context context,
-                final String jsonString,
-                final CustomEventNativeListener customEventNativeListener) {
+        @NonNull private final Context mContext;
+        @NonNull private final CustomEventNativeListener mCustomEventNativeListener;
+        @NonNull private final JSONObject mJsonObject;
+
+        MoPubForwardingNativeAd(@NonNull final Context context,
+                @NonNull final JSONObject jsonBody,
+                @NonNull final CustomEventNativeListener customEventNativeListener) {
+            mJsonObject = jsonBody;
             mContext = context;
-            mJsonString = jsonString;
             mCustomEventNativeListener = customEventNativeListener;
         }
 
-        void loadAd() throws IllegalArgumentException, JSONException {
-            if (mJsonString == null) {
-                throw new IllegalArgumentException("Json String cannot be null");
-            }
-
-            final JSONTokener jsonTokener = new JSONTokener(mJsonString);
-            final JSONObject jsonObject = new JSONObject(jsonTokener);
-
-            if (!containsRequiredKeys(jsonObject)) {
+        void loadAd() throws IllegalArgumentException {
+            if (!containsRequiredKeys(mJsonObject)) {
                 throw new IllegalArgumentException("JSONObject did not contain required keys.");
             }
 
-            final Iterator<String> keys = jsonObject.keys();
+            final Iterator<String> keys = mJsonObject.keys();
             while (keys.hasNext()) {
                 final String key = keys.next();
                 final Parameter parameter = Parameter.from(key);
 
                 if (parameter != null) {
                     try {
-                        addInstanceVariable(parameter, jsonObject.opt(key));
+                        addInstanceVariable(parameter, mJsonObject.opt(key));
                     } catch (ClassCastException e) {
                         throw new IllegalArgumentException("JSONObject key (" + key + ") contained unexpected value.");
                     }
                 } else {
-                    addExtra(key, jsonObject.opt(key));
+                    addExtra(key, mJsonObject.opt(key));
                 }
             }
 
@@ -98,9 +98,8 @@ public void onImagesFailedToCache(final NativeErrorCode errorCode) {
             });
         }
 
-        private boolean containsRequiredKeys(final JSONObject jsonObject) {
+        private boolean containsRequiredKeys(@NonNull final JSONObject jsonObject) {
             final Set<String> keys = new HashSet<String>();
-
             final Iterator<String> jsonKeys = jsonObject.keys();
             while (jsonKeys.hasNext()) {
                 keys.add(jsonKeys.next());
@@ -109,7 +108,8 @@ private boolean containsRequiredKeys(final JSONObject jsonObject) {
             return keys.containsAll(Parameter.requiredKeys);
         }
 
-        private void addInstanceVariable(final Parameter key, final Object value) throws ClassCastException {
+        private void addInstanceVariable(@NonNull final Parameter key,
+                @Nullable final Object value) throws ClassCastException {
             try {
                 switch (key) {
                     case MAIN_IMAGE:
@@ -167,10 +167,11 @@ private void addImpressionTrackers(final Object impressionTrackers) throws Class
             }
         }
 
-        private boolean isImageKey(final String name) {
-            return name != null && name.toLowerCase().endsWith("image");
+        private boolean isImageKey(@Nullable final String name) {
+            return name != null && name.toLowerCase(Locale.US).endsWith("image");
         }
 
+        @NonNull
         List<String> getExtrasImageUrls() {
             final List<String> extrasBitmapUrls = new ArrayList<String>(getExtras().size());
             for (final Map.Entry<String, Object> entry : getExtras().entrySet()) {
@@ -182,6 +183,7 @@ private boolean isImageKey(final String name) {
             return extrasBitmapUrls;
         }
 
+        @NonNull
         List<String> getAllImageUrls() {
             final List<String> imageUrls = new ArrayList<String>();
             if (getMainImageUrl() != null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
index 8c718eb4..04123976 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -1,35 +1,41 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.HttpClient;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.ManifestUtils;
-import com.mopub.common.util.ResponseHeader;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpUriRequest;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
 
 import java.lang.ref.WeakReference;
-import java.util.*;
+import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.common.GpsHelper.GpsHelperListener;
 import static com.mopub.common.GpsHelper.fetchAdvertisingInfoAsync;
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.NativeErrorCode.CONNECTION_ERROR;
 import static com.mopub.nativeads.NativeErrorCode.EMPTY_AD_RESPONSE;
+import static com.mopub.nativeads.NativeErrorCode.INVALID_JSON;
 import static com.mopub.nativeads.NativeErrorCode.INVALID_REQUEST_URL;
 import static com.mopub.nativeads.NativeErrorCode.SERVER_ERROR_RESPONSE_CODE;
-import static com.mopub.nativeads.NativeErrorCode.UNEXPECTED_RESPONSE_CODE;
 import static com.mopub.nativeads.NativeErrorCode.UNSPECIFIED;
 
 public class MoPubNative {
+
     public interface MoPubNativeNetworkListener {
         public void onNativeLoad(final NativeResponse nativeResponse);
         public void onNativeFail(final NativeErrorCode errorCode);
@@ -38,7 +44,7 @@
     static final MoPubNativeNetworkListener EMPTY_NETWORK_LISTENER = new
             MoPubNativeNetworkListener() {
         @Override
-        public void onNativeLoad(final NativeResponse nativeResponse) {
+        public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
             // If this listener is invoked, it means that MoPubNative instance has been destroyed
             // so destroy any leftover incoming NativeResponses
             nativeResponse.destroy();
@@ -51,10 +57,10 @@ public void onNativeFail(final NativeErrorCode errorCode) {
     static final MoPubNativeEventListener EMPTY_EVENT_LISTENER = new
             MoPubNativeEventListener() {
         @Override
-        public void onNativeImpression(final View view) {
+        public void onNativeImpression(@Nullable final View view) {
         }
         @Override
-        public void onNativeClick(final View view) {
+        public void onNativeClick(@Nullable final View view) {
         }
     };
 
@@ -72,11 +78,15 @@ public void onNativeClick(final View view) {
     }
 
     // must be an activity context since 3rd party networks need it
-    private final WeakReference<Context> mContext;
-    private final String mAdUnitId;
-    private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
-    private MoPubNativeEventListener mMoPubNativeEventListener;
-    private Map<String, Object> mLocalExtras;
+    @NonNull private final WeakReference<Context> mContext;
+    @NonNull private final String mAdUnitId;
+    @NonNull private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
+
+    // For small sets TreeMap, takes up less memory than HashMap
+    @NonNull private Map<String, Object> mLocalExtras = new TreeMap<String, Object>();
+    @NonNull private final AdRequest.Listener mVolleyListener;
+    @Nullable private AdRequest mNativeRequest;
 
     /**
      * @deprecated As of release 2.4, use {@link MoPubNative(Context, String,
@@ -84,23 +94,19 @@ public void onNativeClick(final View view) {
      * instead.
      */
     @Deprecated
-    public MoPubNative(final Context context,
-            final String adUnitId,
-            final MoPubNativeListener moPubNativeListener) {
-        this(context, adUnitId, (MoPubNativeNetworkListener)moPubNativeListener);
+    public MoPubNative(@NonNull final Context context,
+            @NonNull final String adUnitId,
+            @NonNull final MoPubNativeListener moPubNativeListener) {
+        this(context, adUnitId, (MoPubNativeNetworkListener) moPubNativeListener);
         setNativeEventListener(moPubNativeListener);
     }
 
-    public MoPubNative(final Context context,
-                final String adUnitId,
-                final MoPubNativeNetworkListener moPubNativeNetworkListener) {
-        if (context == null) {
-            throw new IllegalArgumentException("Context may not be null.");
-        } else if (adUnitId == null) {
-            throw new IllegalArgumentException("AdUnitId may not be null.");
-        } else if (moPubNativeNetworkListener == null) {
-            throw new IllegalArgumentException("MoPubNativeNetworkListener may not be null.");
-        }
+    public MoPubNative(@NonNull final Context context,
+                @NonNull final String adUnitId,
+                @NonNull final MoPubNativeNetworkListener moPubNativeNetworkListener) {
+        Preconditions.checkNotNull(context, "Context may not be null.");
+        Preconditions.checkNotNull(adUnitId, "AdUnitId may not be null.");
+        Preconditions.checkNotNull(moPubNativeNetworkListener, "MoPubNativeNetworkListener may not be null.");
 
         ManifestUtils.checkNativeActivitiesDeclared(context);
 
@@ -108,40 +114,55 @@ public MoPubNative(final Context context,
         mAdUnitId = adUnitId;
         mMoPubNativeNetworkListener = moPubNativeNetworkListener;
         mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
+        mVolleyListener = new AdRequest.Listener() {
+            @Override
+            public void onSuccess(@NonNull final AdResponse response) {
+                onAdLoad(response);
+            }
+
+            @Override
+            public void onErrorResponse(@NonNull final VolleyError volleyError) {
+                onAdError(volleyError);
+            }
+        };
 
         // warm up cache for google play services info
         fetchAdvertisingInfoAsync(context, null);
     }
 
-    public void setNativeEventListener(final MoPubNativeEventListener nativeEventListener) {
+    public void setNativeEventListener(@Nullable final MoPubNativeEventListener nativeEventListener) {
         mMoPubNativeEventListener = (nativeEventListener == null)
                 ? EMPTY_EVENT_LISTENER : nativeEventListener;
     }
 
     public void destroy() {
         mContext.clear();
+        if (mNativeRequest != null) {
+            mNativeRequest.cancel();
+            mNativeRequest = null;
+        }
         mMoPubNativeNetworkListener = EMPTY_NETWORK_LISTENER;
         mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
     }
 
-    public void setLocalExtras(final Map<String, Object> localExtras) {
-        mLocalExtras = new HashMap<String, Object>(localExtras);
+    public void setLocalExtras(@Nullable final Map<String, Object> localExtras) {
+        if (localExtras == null) {
+            mLocalExtras = new TreeMap<String, Object>();
+        } else {
+            mLocalExtras = new TreeMap<String, Object>(localExtras);
+        }
     }
 
     public void makeRequest() {
         makeRequest((RequestParameters)null);
     }
 
-    public void makeRequest(final RequestParameters requestParameters) {
+    public void makeRequest(@Nullable final RequestParameters requestParameters) {
         makeRequest(requestParameters, null);
     }
 
-    public void makeRequest(final RequestParameters requestParameters,
-            Integer sequenceNumber) {
-        makeRequest(new NativeGpsHelperListener(requestParameters, sequenceNumber));
-    }
-
-    void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
+    public void makeRequest(@Nullable final RequestParameters requestParameters,
+            @Nullable Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -152,18 +173,12 @@ void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
             return;
         }
 
-        // If we have access to Google Play Services (GPS) but the advertising info
-        // is not cached then guarantee we get it before building the ad request url
-        // in the callback, this is a requirement from Google
-        GpsHelper.fetchAdvertisingInfoAsync(
-                context,
-                nativeGpsHelperListener
-        );
+        loadNativeAd(requestParameters, sequenceNumber);
     }
 
-
-    private void loadNativeAd(final RequestParameters requestParameters,
-            final Integer sequenceNumber) {
+    private void loadNativeAd(
+            @Nullable final RequestParameters requestParameters,
+            @Nullable final Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -177,7 +192,7 @@ private void loadNativeAd(final RequestParameters requestParameters,
             generator.withSequenceNumber(sequenceNumber);
         }
 
-        final String endpointUrl = generator.generateUrlString(Constants.NATIVE_HOST);
+        final String endpointUrl = generator.generateUrlString(Constants.HOST);
 
         if (endpointUrl != null) {
             MoPubLog.d("Loading ad from: " + endpointUrl);
@@ -186,11 +201,7 @@ private void loadNativeAd(final RequestParameters requestParameters,
         requestNativeAd(endpointUrl);
     }
 
-    void loadNativeAd(final RequestParameters requestParameters) {
-        loadNativeAd(requestParameters, null);
-    }
-
-    void requestNativeAd(final String endpointUrl) {
+    void requestNativeAd(@Nullable final String endpointUrl) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -201,70 +212,86 @@ void requestNativeAd(final String endpointUrl) {
             return;
         }
 
-        final HttpGet httpGet;
-        try {
-            httpGet = HttpClient.initializeHttpGet(endpointUrl, context);
-        } catch (IllegalArgumentException e) {
-            mMoPubNativeNetworkListener.onNativeFail(INVALID_REQUEST_URL);
-            return;
-        }
-
-        downloadJson(httpGet);
+        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, context, mVolleyListener);
+        RequestQueue requestQueue = Networking.getRequestQueue(context);
+        requestQueue.add(mNativeRequest);
     }
 
-    private void downloadJson(final HttpUriRequest httpUriRequest) {
-        final DownloadTask jsonDownloadTask = new DownloadTask(new DownloadTask.DownloadTaskListener() {
-            @Override
-            public void onComplete(final String url, final DownloadResponse downloadResponse) {
-                if (downloadResponse == null) {
-                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
-                } else if (downloadResponse.getStatusCode() >= 500 &&
-                        downloadResponse.getStatusCode() < 600) {
-                    mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
-                } else if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    mMoPubNativeNetworkListener.onNativeFail(UNEXPECTED_RESPONSE_CODE);
-                } else if (downloadResponse.getContentLength() == 0) {
-                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
-                } else {
-                    final CustomEventNativeListener customEventNativeListener = new CustomEventNativeListener() {
-                        @Override
-                        public void onNativeAdLoaded(final NativeAdInterface nativeAd) {
-                            final Context context = getContextOrDestroy();
-                            if (context == null) {
-                                return;
-                            }
-                            mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context, downloadResponse, mAdUnitId, nativeAd, mMoPubNativeEventListener));
-                        }
-
-                        @Override
-                        public void onNativeAdFailed(final NativeErrorCode errorCode) {
-                            requestNativeAd(downloadResponse.getFirstHeader(ResponseHeader.FAIL_URL));
+    private void onAdLoad(@NonNull final AdResponse response) {
+        final Context context = getContextOrDestroy();
+        if (context == null) {
+            return;
+        }
+        final CustomEventNativeListener customEventNativeListener =
+                new CustomEventNativeListener() {
+                    @Override
+                    public void onNativeAdLoaded(@NonNull final NativeAdInterface nativeAd) {
+                        final Context context = getContextOrDestroy();
+                        if (context == null) {
+                            return;
                         }
-                    };
+                        mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context,
+                                response.getImpressionTrackingUrl(),
+                                response.getClickTrackingUrl(),
+                                mAdUnitId,
+                                nativeAd,
+                                mMoPubNativeEventListener));
+                    }
 
-                    final Context context = getContextOrDestroy();
-                    if (context == null) {
-                        return;
+                    @Override
+                    public void onNativeAdFailed(final NativeErrorCode errorCode) {
+                        requestNativeAd(response.getFailoverUrl());
                     }
+                };
 
-                    CustomEventNativeAdapter.loadNativeAd(
-                            context,
-                            mLocalExtras,
-                            downloadResponse,
-                            customEventNativeListener
-                    );
-                }
-            }
-        });
 
-        try {
-            AsyncTasks.safeExecuteOnExecutor(jsonDownloadTask, httpUriRequest);
-        } catch (Exception e) {
-            MoPubLog.d("Failed to download json", e);
 
-            mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
-        }
+        CustomEventNativeAdapter.loadNativeAd(
+                context,
+                mLocalExtras,
+                response,
+                customEventNativeListener
+        );
+    }
 
+    @VisibleForTesting
+    void onAdError(@NonNull final VolleyError volleyError) {
+        MoPubLog.d("Native ad request failed.", volleyError);
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError error = (MoPubNetworkError) volleyError;
+            switch (error.getReason()) {
+                case BAD_BODY:
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    return;
+                case BAD_HEADER_DATA:
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    return;
+                case WARMING_UP:
+                    // Used for the sample app to signal a toast.
+                    // This is not customer-facing except in the sample app.
+                    MoPubLog.c(MoPubErrorCode.WARMUP.toString());
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
+                case NO_FILL:
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
+                case UNSPECIFIED:
+                default:
+                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
+                    return;
+            }
+        } else {
+            // Process our other status code errors.
+            NetworkResponse response = volleyError.networkResponse;
+            if (response != null && response.statusCode >= 500 && response.statusCode < 600) {
+                mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
+            } else if (response == null && !DeviceUtils.isNetworkAvailable(mContext.get())) {
+                MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
+            } else {
+                mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
+            }
+        }
     }
 
     Context getContextOrDestroy() {
@@ -277,33 +304,14 @@ Context getContextOrDestroy() {
         return context;
     }
 
-    // Do not store this class as a member of MoPubNative; will result in circular reference
-    class NativeGpsHelperListener implements GpsHelperListener {
-        private final RequestParameters mRequestParameters;
-        private final Integer mSequenceNumber;
-
-        NativeGpsHelperListener(RequestParameters requestParameters, Integer sequenceNumber) {
-            mRequestParameters = requestParameters;
-            mSequenceNumber = sequenceNumber;
-        }
-
-        NativeGpsHelperListener(RequestParameters requestParameters) {
-            this(requestParameters, null);
-        }
-
-        @Override
-        public void onFetchAdInfoCompleted() {
-
-            loadNativeAd(mRequestParameters, mSequenceNumber);
-        }
-    }
-
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
         return mMoPubNativeNetworkListener;
     }
 
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeEventListener getMoPubNativeEventListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
index 593439ee..d3e1b6c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 import com.mopub.common.Preconditions;
 
 import java.util.ArrayList;
@@ -38,7 +40,7 @@
          */
         public static final int NO_REPEAT = Integer.MAX_VALUE;
 
-        private final ArrayList<Integer> mFixedPositions = new ArrayList<Integer>();
+        @NonNull private final ArrayList<Integer> mFixedPositions = new ArrayList<Integer>();
         private int mRepeatInterval = NO_REPEAT;
 
         public MoPubClientPositioning() {
@@ -50,6 +52,7 @@ public MoPubClientPositioning() {
          * @param position The ad position.
          * @return This object for easy use in chained setters.
          */
+        @NonNull
         public MoPubClientPositioning addFixedPosition(final int position) {
             if (!Preconditions.NoThrow.checkArgument(position >= 0)) {
                 return this;
@@ -68,6 +71,7 @@ public MoPubClientPositioning addFixedPosition(final int position) {
          *
          * @return Fixed ad positions.
          */
+        @NonNull
         List<Integer> getFixedPositions() {
             return mFixedPositions;
         }
@@ -79,6 +83,7 @@ public MoPubClientPositioning addFixedPosition(final int position) {
          * the constant NO_REPEAT.
          * @return This object for easy use in chained setters.
          */
+        @NonNull
         public MoPubClientPositioning enableRepeatingPositions(final int interval) {
             if (!Preconditions.NoThrow.checkArgument(
                     interval > 1, "Repeating interval must be greater than 1")) {
@@ -102,7 +107,10 @@ int getRepeatingInterval() {
         }
     }
 
-    static MoPubClientPositioning clone(MoPubClientPositioning positioning) {
+    @NonNull
+    static MoPubClientPositioning clone(@NonNull MoPubClientPositioning positioning) {
+        Preconditions.checkNotNull(positioning);
+
         MoPubClientPositioning clone = new MoPubClientPositioning();
         clone.mFixedPositions.addAll(positioning.mFixedPositions);
         clone.mRepeatInterval = positioning.mRepeatInterval;
@@ -113,6 +121,7 @@ static MoPubClientPositioning clone(MoPubClientPositioning positioning) {
      * Creates and returns a {@link MoPubClientPositioning} object.
      * @return A new positioning object.
      */
+    @NonNull
     public static MoPubClientPositioning clientPositioning() {
         return new MoPubClientPositioning();
     }
@@ -121,6 +130,7 @@ public static MoPubClientPositioning clientPositioning() {
      * Creates and returns a {@link MoPubServerPositioning} object.
      * @return A new positioning object.
      */
+    @NonNull
     public static MoPubServerPositioning serverPositioning() {
         return new MoPubServerPositioning();
     }
@@ -133,6 +143,7 @@ public static MoPubServerPositioning serverPositioning() {
      * the MoPub UI. If you still want to hard-code positioning information in your app,
      * use {@link #clientPositioning} instead of this builder.
      */
+    @NonNull
     @Deprecated
     public static Builder newBuilder() {
         return new Builder();
@@ -143,12 +154,14 @@ public static Builder newBuilder() {
      */
     @Deprecated
     public static final class Builder extends MoPubClientPositioning {
+        @NonNull
         @Override
         public Builder addFixedPosition(final int position) {
             super.addFixedPosition(position);
             return this;
         }
 
+        @NonNull
         @Override
         public Builder enableRepeatingPositions(final int interval) {
             super.enableRepeatingPositions(interval);
@@ -160,6 +173,7 @@ public Builder enableRepeatingPositions(final int interval) {
          *
          * @return A new positioning object.
          */
+        @NonNull
         @Deprecated
         public MoPubClientPositioning build() {
             return this;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
index e33dd2c6..4fd91ecf 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
@@ -16,60 +17,40 @@
  * An implementation of {@link com.mopub.nativeads.MoPubAdRenderer} for rendering native ads.
  */
 public class MoPubNativeAdRenderer implements MoPubAdRenderer<NativeResponse> {
-
-    private final ViewBinder mViewBinder;
+    @NonNull private final ViewBinder mViewBinder;
 
     // This is used instead of View.setTag, which causes a memory leak in 2.3
     // and earlier: https://code.google.com/p/android/issues/detail?id=18273
-    private final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
+    @VisibleForTesting @NonNull final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
 
     /**
      * Constructs a native ad renderer with a view binder.
      *
      * @param viewBinder The view binder to use when inflating and rendering an ad.
      */
-    public MoPubNativeAdRenderer(final ViewBinder viewBinder) {
+    public MoPubNativeAdRenderer(@NonNull final ViewBinder viewBinder) {
         mViewBinder = viewBinder;
         mViewHolderMap = new WeakHashMap<View, NativeViewHolder>();
     }
 
     @Override
-    public View createAdView(final Context context, final ViewGroup parent) {
+    @NonNull
+    public View createAdView(@NonNull final Context context, @Nullable final ViewGroup parent) {
         return LayoutInflater
                 .from(context)
                 .inflate(mViewBinder.layoutId, parent, false);
     }
 
     @Override
-    public void renderAdView(final View view, final NativeResponse nativeResponse) {
-        final NativeViewHolder nativeViewHolder = getOrCreateNativeViewHolder(view, mViewBinder);
-
-        if (nativeViewHolder == null) {
-            MoPubLog.d("Could not create NativeViewHolder.");
-            return;
-        }
-
-        populateConvertViewSubViews(view, nativeViewHolder, nativeResponse, mViewBinder);
-        view.setVisibility(VISIBLE);
-    }
-
-    @VisibleForTesting
-    NativeViewHolder getOrCreateNativeViewHolder(final View view, final ViewBinder viewBinder) {
-        // Create view holder and put it in the view tag
+    public void renderAdView(@NonNull final View view,
+            @NonNull final NativeResponse nativeResponse) {
         NativeViewHolder nativeViewHolder = mViewHolderMap.get(view);
         if (nativeViewHolder == null) {
-            nativeViewHolder = NativeViewHolder.fromViewBinder(view, viewBinder);
+            nativeViewHolder = NativeViewHolder.fromViewBinder(view, mViewBinder);
             mViewHolderMap.put(view, nativeViewHolder);
-            return nativeViewHolder;
         }
-        return nativeViewHolder;
-    }
-
-    private void populateConvertViewSubViews(final View view,
-            final NativeViewHolder nativeViewHolder,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder) {
         nativeViewHolder.update(nativeResponse);
-        nativeViewHolder.updateExtras(view, nativeResponse, viewBinder);
+        nativeViewHolder.updateExtras(view, nativeResponse, mViewBinder);
+        view.setVisibility(VISIBLE);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
index 0234a56b..e89f5d88 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -2,17 +2,26 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
 
-import java.util.*;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.WeakHashMap;
 
 /**
- * @code MoPubStreamAdPlacer facilitates loading ads and placing them into a content stream.
+ * {@code MoPubStreamAdPlacer} facilitates loading ads and placing them into a content stream.
  *
  * If you are inserting ads into a ListView, we recommend that you use a {@link MoPubAdAdapter}
  * instead of this class.
@@ -29,25 +38,39 @@
      * instead of an ad.
      */
     public static final int CONTENT_VIEW_TYPE = 0;
+    private final static MoPubNativeAdLoadedListener EMPTY_NATIVE_AD_LOADED_LISTENER =
+            new MoPubNativeAdLoadedListener() {
+                @Override
+                public void onAdLoaded(final int position) {
+                }
+
+                @Override
+                public void onAdRemoved(final int position) {
+                }
+            };
+
+    @NonNull private final Context mContext;
+    @NonNull private final Handler mPlacementHandler;
+    @NonNull private final Runnable mPlacementRunnable;
+    @NonNull private final PositioningSource mPositioningSource;
+    @NonNull private final NativeAdSource mAdSource;
+    @NonNull private final ImpressionTracker mImpressionTracker;
 
-    private final Context mContext;
-    private final Handler mPlacementHandler;
-    private final Runnable mPlacementRunnable;
-    private final PositioningSource mPositioningSource;
-    private final NativeAdSource mAdSource;
-    private final ImpressionTracker mImpressionTracker;
-    private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
+    @NonNull private final HashMap<NativeResponse, WeakReference<View>> mViewMap;
+    @NonNull private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
 
     private boolean mHasReceivedPositions;
-    private PlacementData mPendingPlacementData;
+    @NonNull private PlacementData mPendingPlacementData;
     private boolean mHasReceivedAds;
     private boolean mHasPlacedAds;
-    private PlacementData mPlacementData;
+    @NonNull private PlacementData mPlacementData;
     
-    private MoPubAdRenderer mAdRenderer;
-    private String mAdUnitId;
+    @Nullable private MoPubAdRenderer mAdRenderer;
+    @Nullable private String mAdUnitId;
+
+    @NonNull private MoPubNativeAdLoadedListener mAdLoadedListener =
+            EMPTY_NATIVE_AD_LOADED_LISTENER;
 
-    private MoPubNativeAdLoadedListener mAdLoadedListener;
     // The visible range is the range of items which we believe are visible, inclusive.
     // Placing ads near this range makes for a smoother user experience when scrolling up
     // or down.
@@ -69,7 +92,7 @@
      *
      * @param context The activity context.
      */
-    public MoPubStreamAdPlacer(final Context context) {
+    public MoPubStreamAdPlacer(@NonNull final Context context) {
         // MoPubClientPositioning is mutable, so we must take care not to hold a
         // reference to it that might be subsequently modified by the caller.
         this(context, MoPubNativeAdPositioning.serverPositioning());
@@ -82,7 +105,8 @@ public MoPubStreamAdPlacer(final Context context) {
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubStreamAdPlacer(final Context context, final MoPubServerPositioning adPositioning) {
+    public MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final MoPubServerPositioning adPositioning) {
         this(context,
                 new NativeAdSource(),
                 new ImpressionTracker(context),
@@ -96,7 +120,8 @@ public MoPubStreamAdPlacer(final Context context, final MoPubServerPositioning a
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubStreamAdPlacer(final Context context, final MoPubClientPositioning adPositioning) {
+    public MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final MoPubClientPositioning adPositioning) {
         // MoPubClientPositioning is mutable, so we must take care not to hold a
         // reference to it that might be subsequently modified by the caller.
         this(context,
@@ -106,16 +131,25 @@ public MoPubStreamAdPlacer(final Context context, final MoPubClientPositioning a
     }
 
     @VisibleForTesting
-    MoPubStreamAdPlacer(final Context context,
-            final NativeAdSource adSource,
-            final ImpressionTracker impressionTracker,
-            final PositioningSource positioningSource) {
+    MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final NativeAdSource adSource,
+            @NonNull final ImpressionTracker impressionTracker,
+            @NonNull final PositioningSource positioningSource) {
+        Preconditions.checkNotNull(context, "context is not allowed to be null");
+        Preconditions.checkNotNull(adSource, "adSource is not allowed to be null");
+        Preconditions.checkNotNull(impressionTracker, "impressionTracker is not allowed to be " +
+                "null");
+        Preconditions.checkNotNull(positioningSource, "positioningSource is not allowed to be " +
+                "null");
+
         mContext = context;
         mImpressionTracker = impressionTracker;
         mPositioningSource = positioningSource;
         mAdSource = adSource;
         mPlacementData = PlacementData.empty();
+
         mNativeResponseMap = new WeakHashMap<View, NativeResponse>();
+        mViewMap = new HashMap<NativeResponse, WeakReference<View>>();
 
         mPlacementHandler = new Handler();
         mPlacementRunnable = new Runnable() {
@@ -142,7 +176,10 @@ public void run() {
      *
      * @param adRenderer The ad renderer.
      */
-    public void registerAdRenderer(final MoPubAdRenderer adRenderer) {
+    public void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        if (!NoThrow.checkNotNull(adRenderer, "Cannot register a null adRenderer")) {
+            return;
+        }
         mAdRenderer = adRenderer;
     }
 
@@ -158,8 +195,8 @@ public void registerAdRenderer(final MoPubAdRenderer adRenderer) {
      *
      * @param listener The listener.
      */
-    public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
-        mAdLoadedListener = listener;
+    public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = (listener == null) ? EMPTY_NATIVE_AD_LOADED_LISTENER : listener;
     }
 
     /**
@@ -170,14 +207,14 @@ public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void loadAds(final String adUnitId) {
+    public void loadAds(@NonNull final String adUnitId) {
         loadAds(adUnitId, /* requestParameters */ null);
     }
 
     /**
      * Start loading ads from the MoPub server, using the given request targeting information.
      *
-     * When loading ads, use {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
      * each ad that is added to the stream.
      *
      * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
@@ -188,8 +225,17 @@ public void loadAds(final String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void loadAds(final String adUnitId,
-            final RequestParameters requestParameters) {
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(adUnitId, "Cannot load ads with a null ad unit ID")) {
+            return;
+        }
+
+        if (mAdRenderer == null) {
+            MoPubLog.w("You must call registerAdRenderer before loading ads");
+            return;
+        }
+
         mAdUnitId = adUnitId;
 
         mHasPlacedAds = false;
@@ -198,12 +244,15 @@ public void loadAds(final String adUnitId,
 
         mPositioningSource.loadPositions(adUnitId, new PositioningListener() {
             @Override
-            public void onLoad(final MoPubClientPositioning positioning) {
+            public void onLoad(@NonNull final MoPubClientPositioning positioning) {
                 handlePositioningLoad(positioning);
             }
 
             @Override
             public void onFailed() {
+                // This will happen only if positions couldn't be loaded after several tries
+                MoPubLog.d("Unable to show ads because ad positions could not be loaded from " +
+                        "the MoPub ad server.");
             }
         });
 
@@ -218,7 +267,7 @@ public void onAdsAvailable() {
     }
 
     @VisibleForTesting
-    void handlePositioningLoad(final MoPubClientPositioning positioning) {
+    void handlePositioningLoad(@NonNull final MoPubClientPositioning positioning) {
         PlacementData placementData = PlacementData.fromAdPositioning(positioning);
         if (mHasReceivedAds) {
             placeInitialAds(placementData);
@@ -257,7 +306,7 @@ private void placeInitialAds(PlacementData placementData) {
      * Inserts ads that should appear in the given range.
      *
      * By default, the ad placer will place ads withing the first 10 positions in your stream,
-     * according the positions you've specified. You can should use this method as your user scrolls
+     * according to the positions you've specified. You can use this method as your user scrolls
      * through your stream to place ads into the currently visible range.
      *
      * This method takes advantage of a short-lived in memory ad cache, and will immediately place
@@ -333,6 +382,7 @@ public void destroy() {
      * @param position The position where to place an ad.
      * @return An object representing ad data.
      */
+    @Nullable
     public Object getAdData(final int position) {
         return mPlacementData.getPlacedAd(position);
     }
@@ -343,36 +393,46 @@ public Object getAdData(final int position) {
      * This method will attempt to reuse the convertView if it is not {@code null}, and will
      * otherwise create it. See {@link MoPubAdRenderer#createAdView(Context, ViewGroup)}.
      *
-     * @param position The position where to place an ad.
+     * @param position The position to place an ad into.
      * @param convertView A recycled view into which to render data, or {@code null}.
      * @param parent The parent that the view will eventually be attached to.
      * @return The newly placed ad view.
      */
-    public View getAdView(final int position, final View convertView, final ViewGroup parent) {
-        if (!isAd(position)) {
+    @Nullable
+    public View getAdView(final int position, @Nullable final View convertView,
+            @Nullable final ViewGroup parent) {
+        final NativeAdData adData = mPlacementData.getPlacedAd(position);
+        if (adData == null) {
             return null;
         }
 
-        final NativeAdData adData = mPlacementData.getPlacedAd(position);
         final MoPubAdRenderer adRenderer = adData.getAdRenderer();
         final View view = (convertView != null) ?
                 convertView : adRenderer.createAdView(mContext, parent);
 
         NativeResponse nativeResponse = adData.getAd();
-        if (!nativeResponse.equals(mNativeResponseMap.get(view))) {
+        WeakReference<View> mappedViewRef = mViewMap.get(nativeResponse);
+        View mappedView = null;
+        if (mappedViewRef != null) {
+            mappedView = mappedViewRef.get();
+        }
+        if (!view.equals(mappedView)) {
+            clearNativeResponse(mappedView);
             clearNativeResponse(view);
             prepareNativeResponse(nativeResponse, view);
+            //noinspection unchecked
             adRenderer.renderAdView(view, nativeResponse);
         }
+
         return view;
     }
 
     /**
-     * Removes ads in the given range from [startRange, endRange).
+     * Removes ads in the given range from [originalStartPosition, originalEndPosition).
      *
-     * @param originalStartPosition The start position to clear, expressed as the original content
+     * @param originalStartPosition The start position to clear (inclusive), expressed as the original content
      * position before ads were inserted.
-     * @param originalEndPosition The position after end position to clear, expressed as the
+     * @param originalEndPosition The position after end position to clear (exclusive), expressed as the
      * original content position before ads were inserted.
      * @return The number of ads removed.
      */
@@ -487,14 +547,17 @@ public int getAdjustedCount(final int originalCount) {
      *
      * You must call this method so that the placer knows where valid positions are to place ads.
      * After calling this method, the ad placer will call {@link
-     * MoPubNativeAdLoadedListener#onAdLoaded
-     * (int)} each time an ad is loaded in the stream.
+     * MoPubNativeAdLoadedListener#onAdLoaded (int)} each time an ad is loaded in the stream.
      *
      * @param originalCount The original number of items.
      */
     public void setItemCount(final int originalCount) {
         mItemCount = mPlacementData.getAdjustedCount(originalCount);
-        notifyNeedsPlacement();
+
+        // If we haven't already placed ads, we'll let ads get placed by the normal loadAds call
+        if (mHasPlacedAds) {
+            notifyNeedsPlacement();
+        }
     }
 
     /**
@@ -509,7 +572,7 @@ public void setItemCount(final int originalCount) {
      *
      * and you insert an item at position 2, your new stream will look like:
      *
-     * {@code Item0 Ad Item1 Item2 New Item Ad Item3}
+     * {@code Item0 Ad Item1 Item2 NewItem Ad Item3}
      *
      * @param originalPosition The position at which to add an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
@@ -545,6 +608,14 @@ public void removeItem(final int originalPosition) {
      * Use this method if you are moving an item in your stream and want to have ad positions move
      * as well.
      *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you move item at position 2 to position 3, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3 Item2}
+     *
      * @param originalPosition The position from which to move an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
      * @param newPosition The new position, also expressed in terms of the original position.
@@ -580,8 +651,12 @@ private void placeAds() {
     }
 
     /**
-     * Attempts to place ads in the range (start, end], returning false if there is no ad available
+     * Attempts to place ads in the range [start, end], returning false if there is no ad available
      * to be placed.
+     *
+     * @param start The start of the range in which to place ads, inclusive.
+     * @param end The end of the range in which to place ads, exclusive.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAdsInRange(final int start, final int end) {
         int position = start;
@@ -604,6 +679,9 @@ private boolean tryPlaceAdsInRange(final int start, final int end) {
     /**
      * Attempts to place an ad at the given position, returning false if there is no ad available to
      * be placed.
+     *
+     * @param position The position to place the ad at.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAd(final int position) {
         final NativeResponse adResponse = mAdSource.dequeueAd();
@@ -615,25 +693,34 @@ private boolean tryPlaceAd(final int position) {
         mPlacementData.placeAd(position, adData);
         mItemCount++;
 
-        if (mAdLoadedListener != null) {
-            mAdLoadedListener.onAdLoaded(position);
-        }
+        mAdLoadedListener.onAdLoaded(position);
         return true;
     }
 
-    private NativeAdData createAdData(final int position, final NativeResponse adResponse) {
+    @NonNull
+    private NativeAdData createAdData(final int position, @NonNull final NativeResponse adResponse) {
+        Preconditions.checkNotNull(mAdUnitId);
+        Preconditions.checkNotNull(mAdRenderer);
+
+        //noinspection ConstantConditions
         return new NativeAdData(mAdUnitId, mAdRenderer, adResponse);
     }
 
-    private void clearNativeResponse(final View view) {
+    private void clearNativeResponse(@Nullable final View view) {
+        if (view == null) {
+            return;
+        }
         mImpressionTracker.removeView(view);
         final NativeResponse lastNativeResponse = mNativeResponseMap.get(view);
         if (lastNativeResponse != null) {
             lastNativeResponse.clear(view);
+            mNativeResponseMap.remove(view);
+            mViewMap.remove(lastNativeResponse);
         }
     }
 
-    private void prepareNativeResponse(final NativeResponse nativeResponse, final View view) {
+    private void prepareNativeResponse(@NonNull final NativeResponse nativeResponse, @NonNull final View view) {
+        mViewMap.put(nativeResponse, new WeakReference<View>(view));
         mNativeResponseMap.put(view, nativeResponse);
         if (!nativeResponse.isOverridingImpressionTracker()) {
             mImpressionTracker.addView(view, nativeResponse);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
index d4623a35..1f110083 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
@@ -1,29 +1,34 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 /**
  * An object that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer}
  */
 class NativeAdData {
-    private final String adUnitId;
-    private final MoPubAdRenderer adRenderer;
-    private final NativeResponse adResponse;
+    @NonNull private final String adUnitId;
+    @NonNull private final MoPubAdRenderer adRenderer;
+    @NonNull private final NativeResponse adResponse;
 
-    NativeAdData(final String adUnitId,
-            final MoPubAdRenderer adRenderer,
-            final NativeResponse adResponse) {
+    NativeAdData(@NonNull final String adUnitId,
+            @NonNull final MoPubAdRenderer adRenderer,
+            @NonNull final NativeResponse adResponse) {
         this.adUnitId = adUnitId;
         this.adRenderer = adRenderer;
         this.adResponse = adResponse;
     }
 
+    @NonNull
     String getAdUnitId() {
         return adUnitId;
     }
 
+    @NonNull
     MoPubAdRenderer getAdRenderer() {
         return adRenderer;
     }
 
+    @NonNull
     NativeResponse getAd() {
         return adResponse;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
index d748a681..2b52e576 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 import java.util.Map;
@@ -9,32 +11,52 @@
 
 interface NativeAdInterface {
     // Getters
+    @Nullable
     String getMainImageUrl();
+
+    @Nullable
     String getIconImageUrl();
+
+    @Nullable
     String getClickDestinationUrl();
+
+    @Nullable
     String getCallToAction();
+
+    @Nullable
     String getTitle();
+
+    @Nullable
     String getText();
+
+    @Nullable
     Double getStarRating();
 
+    @NonNull
     Set<String> getImpressionTrackers();
+
     int getImpressionMinPercentageViewed();
+
     int getImpressionMinTimeViewed();
 
     boolean isOverridingClickTracker();
+
     boolean isOverridingImpressionTracker();
 
     // Extras Getters
+    @Nullable
     Object getExtra(final String key);
+
+    @NonNull
     Map<String, Object> getExtras();
 
     // Setters
-    void setNativeEventListener(final NativeEventListener nativeEventListener);
+    void setNativeEventListener(@Nullable final NativeEventListener nativeEventListener);
 
     // Event Handlers
-    void prepare(final View view);
+    void prepare(@NonNull final View view);
     void recordImpression();
-    void handleClick(final View view);
-    void clear(final View view);
+    void handleClick(@Nullable final View view);
+    void clear(@NonNull final View view);
     void destroy();
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
index 29d8fda9..6e6a4fd8 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
@@ -3,6 +3,8 @@
 import android.content.Context;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.VisibleForTesting;
 
@@ -34,21 +36,21 @@
     private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
     private static final double EXPONENTIAL_BACKOFF_FACTOR = 2.0;
 
-    private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
-    private final Handler mReplenishCacheHandler;
-    private final Runnable mReplenishCacheRunnable;
-    private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    @NonNull private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
+    @NonNull private final Handler mReplenishCacheHandler;
+    @NonNull private final Runnable mReplenishCacheRunnable;
+    @NonNull private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
 
     @VisibleForTesting boolean mRequestInFlight;
     @VisibleForTesting boolean mRetryInFlight;
     @VisibleForTesting int mSequenceNumber;
     @VisibleForTesting int mRetryTimeMilliseconds;
 
-    private AdSourceListener mAdSourceListener;
+    @Nullable private AdSourceListener mAdSourceListener;
 
     // We will need collections of these when we support multiple ad units.
-    private RequestParameters mRequestParameters;
-    private MoPubNative mMoPubNative;
+    @Nullable private RequestParameters mRequestParameters;
+    @Nullable private MoPubNative mMoPubNative;
 
     /**
      * A listener for when ads are available for dequeueing.
@@ -65,8 +67,8 @@
     }
 
     @VisibleForTesting
-    NativeAdSource(final List<TimestampWrapper<NativeResponse>> nativeAdCache,
-            final Handler replenishCacheHandler) {
+    NativeAdSource(@NonNull final List<TimestampWrapper<NativeResponse>> nativeAdCache,
+            @NonNull final Handler replenishCacheHandler) {
         mNativeAdCache = nativeAdCache;
         mReplenishCacheHandler = replenishCacheHandler;
         mReplenishCacheRunnable = new Runnable() {
@@ -80,7 +82,7 @@ public void run() {
         // Construct native URL and start filling the cache
         mMoPubNativeNetworkListener = new MoPubNativeNetworkListener() {
             @Override
-            public void onNativeLoad(final NativeResponse nativeResponse) {
+            public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
                 // This can be null if the ad source was cleared as the AsyncTask is posting
                 // back to the UI handler. Drop this response.
                 if (mMoPubNative == null) {
@@ -125,12 +127,12 @@ public void onNativeFail(final NativeErrorCode errorCode) {
      * Sets a adSourceListener for determining when ads are available.
      * @param adSourceListener An AdSourceListener.
      */
-    void setAdSourceListener(final AdSourceListener adSourceListener) {
+    void setAdSourceListener(@Nullable final AdSourceListener adSourceListener) {
         mAdSourceListener = adSourceListener;
     }
 
-    void loadAds(final Context context,
-            final String adUnitId,
+    void loadAds(@NonNull final Context context,
+            @NonNull final String adUnitId,
             final RequestParameters requestParameters) {
         loadAds(requestParameters, new MoPubNative(context, adUnitId, mMoPubNativeNetworkListener));
     }
@@ -179,6 +181,7 @@ void clear() {
      *
      * @return Ad ad item that should be rendered into a view.
      */
+    @Nullable
     NativeResponse dequeueAd() {
         final long now = SystemClock.uptimeMillis();
 
@@ -231,6 +234,7 @@ void setMoPubNative(final MoPubNative moPubNative) {
         mMoPubNative = moPubNative;
     }
 
+    @NonNull
     @Deprecated
     @VisibleForTesting
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
index 969d27d6..2f1c838c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -1,23 +1,30 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
-import static android.view.View.GONE;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-
 /**
  * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubNativeAdRenderer} instead
  */
 @Deprecated
 class NativeAdViewHelper {
-    private NativeAdViewHelper() {}
+    private NativeAdViewHelper() {
+    }
+
+    @VisibleForTesting
+    enum ViewType {
+        EMPTY,
+        AD
+    }
 
     // Because the impression tracker requires tracking drawing views,
     // each context requires a separate impression tracker. To avoid leaking, keep weak references.
@@ -31,33 +38,34 @@ private NativeAdViewHelper() {}
             new WeakHashMap<View, NativeResponse>();
 
     @Deprecated
-    static View getAdView(View convertView,
-                          final ViewGroup parent,
-                          final Context context,
-                          final NativeResponse nativeResponse,
-                          final ViewBinder viewBinder,
-                          final MoPubNativeListener moPubNativeListener) {
+    @NonNull
+    static View getAdView(@Nullable View convertView,
+            @Nullable final ViewGroup parent,
+            @NonNull final Context context,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder) {
 
-        if (viewBinder == null) {
-            MoPubLog.d("ViewBinder is null, returning empty view.");
-            return new View(context);
-        }
+        Preconditions.NoThrow.checkNotNull(viewBinder, "ViewBinder is null.");
 
-        final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
-        if (convertView == null) {
-            convertView = moPubNativeAdRenderer.createAdView(context, parent);
+        if (convertView != null) {
+            clearNativeResponse(context, convertView);
         }
 
-        clearNativeResponse(context, convertView);
-
-        if (nativeResponse == null) {
-            // If we don't have content for the view, then hide the view for now
-            MoPubLog.d("NativeResponse is null, returning hidden view.");
-            convertView.setVisibility(GONE);
-        } else if (nativeResponse.isDestroyed()) {
-            MoPubLog.d("NativeResponse is destroyed, returning hidden view.");
-            convertView.setVisibility(GONE);
+        if (nativeResponse == null || nativeResponse.isDestroyed() || viewBinder == null) {
+            MoPubLog.d("nativeResponse or viewBinder null or invalid. Returning empty view");
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.EMPTY.equals(convertView.getTag())) {
+                convertView = new View(context);
+                convertView.setTag(ViewType.EMPTY);
+                convertView.setVisibility(View.GONE);
+            }
         } else {
+            final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.AD.equals(convertView.getTag())) {
+                convertView = moPubNativeAdRenderer.createAdView(context, parent);
+                convertView.setTag(ViewType.AD);
+            }
             prepareNativeResponse(context, convertView, nativeResponse);
             moPubNativeAdRenderer.renderAdView(convertView, nativeResponse);
         }
@@ -65,7 +73,8 @@ static View getAdView(View convertView,
         return convertView;
     }
 
-    private static void clearNativeResponse(final Context context, final View view) {
+    private static void clearNativeResponse(@NonNull final Context context,
+            @NonNull final View view) {
         getImpressionTracker(context).removeView(view);
         final NativeResponse nativeResponse = sNativeResponseMap.get(view);
         if (nativeResponse != null) {
@@ -73,9 +82,9 @@ private static void clearNativeResponse(final Context context, final View view)
         }
     }
 
-    private static void prepareNativeResponse(final Context context,
-            final View view,
-            final NativeResponse nativeResponse) {
+    private static void prepareNativeResponse(@NonNull final Context context,
+            @NonNull final View view,
+            @NonNull final NativeResponse nativeResponse) {
         sNativeResponseMap.put(view, nativeResponse);
         if (!nativeResponse.isOverridingImpressionTracker()) {
             getImpressionTracker(context).addView(view, nativeResponse);
@@ -83,7 +92,7 @@ private static void prepareNativeResponse(final Context context,
         nativeResponse.prepare(view);
     }
 
-    private static ImpressionTracker getImpressionTracker(final Context context) {
+    private static ImpressionTracker getImpressionTracker(@NonNull final Context context) {
         ImpressionTracker impressionTracker = sImpressionTrackerMap.get(context);
         if (impressionTracker == null) {
             impressionTracker = new ImpressionTracker(context);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
index 7999f22f..0dd85382 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 public enum NativeErrorCode {
     EMPTY_AD_RESPONSE("Server returned empty response."),
     INVALID_JSON("Unable to parse JSON response from server."),
@@ -24,6 +26,7 @@ private NativeErrorCode(String message) {
         this.message = message;
     }
 
+    @NonNull
     @Override
     public final String toString() {
         return message;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
index c0eeb9ed..e332c6cf 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
@@ -1,22 +1,21 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.HttpClient;
-import com.mopub.common.MoPubBrowser;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
-import java.lang.ref.SoftReference;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
@@ -36,8 +35,6 @@
 import static com.mopub.nativeads.NativeResponse.Parameter.STAR_RATING;
 import static com.mopub.nativeads.NativeResponse.Parameter.TEXT;
 import static com.mopub.nativeads.NativeResponse.Parameter.TITLE;
-import static com.mopub.nativeads.UrlResolutionTask.UrlResolutionListener;
-import static com.mopub.nativeads.UrlResolutionTask.getResolvedUrl;
 
 public class NativeResponse {
     enum Parameter {
@@ -54,15 +51,16 @@
         CALL_TO_ACTION("ctatext", false),
         STAR_RATING("starrating", false);
 
-        final String name;
+        @NonNull final String name;
         final boolean required;
 
-        Parameter(final String name, boolean required) {
+        Parameter(@NonNull final String name, boolean required) {
             this.name = name;
             this.required = required;
         }
 
-        static Parameter from(final String name) {
+        @Nullable
+        static Parameter from(@NonNull final String name) {
             for (final Parameter parameter : values()) {
                 if (parameter.name.equals(name)) {
                     return parameter;
@@ -72,6 +70,7 @@ static Parameter from(final String name) {
             return null;
         }
 
+        @NonNull
         @VisibleForTesting
         static final Set<String> requiredKeys = new HashSet<String>();
         static {
@@ -83,24 +82,26 @@ static Parameter from(final String name) {
         }
     }
 
-    private final Context mContext;
-    private MoPubNativeEventListener mMoPubNativeEventListener;
-    private final NativeAdInterface mNativeAd;
+    @NonNull private final Context mContext;
+    @NonNull private final ImageLoader mImageLoader;
+    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
+    @NonNull private final NativeAdInterface mNativeAd;
 
     // Impression and click trackers for the MoPub adserver
-    private final Set<String> mMoPubImpressionTrackers;
-    private final String mMoPubClickTracker;
-    private final String mAdUnitId;
+    @NonNull private final Set<String> mMoPubImpressionTrackers;
+    @NonNull private final String mMoPubClickTracker;
+    @NonNull private final String mAdUnitId;
 
     private boolean mRecordedImpression;
     private boolean mIsClicked;
     private boolean mIsDestroyed;
 
-    public NativeResponse(final Context context,
-            final DownloadResponse downloadResponse,
-            final String adUnitId,
-            final NativeAdInterface nativeAd,
-            final MoPubNativeEventListener moPubNativeEventListener) {
+    public NativeResponse(@NonNull final Context context,
+            @NonNull final String impressionUrl,
+            @NonNull final String clickUrl,
+            @NonNull final String adUnitId,
+            @NonNull final NativeAdInterface nativeAd,
+            @NonNull final MoPubNativeEventListener moPubNativeEventListener) {
         mContext = context.getApplicationContext();
         mAdUnitId = adUnitId;
         mMoPubNativeEventListener = moPubNativeEventListener;
@@ -118,8 +119,9 @@ public void onAdClicked() {
         });
 
         mMoPubImpressionTrackers = new HashSet<String>();
-        mMoPubImpressionTrackers.add(downloadResponse.getFirstHeader(ResponseHeader.IMPRESSION_URL));
-        mMoPubClickTracker = downloadResponse.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL);
+        mMoPubImpressionTrackers.add(impressionUrl);
+        mMoPubClickTracker = clickUrl;
+        mImageLoader = Networking.getImageLoader(context);
     }
 
     @Override
@@ -141,36 +143,44 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+   @NonNull
    public String getAdUnitId() {
        return mAdUnitId;
    }
 
     // Interface Methods
     // Getters
+    @Nullable
     public String getMainImageUrl() {
         return mNativeAd.getMainImageUrl();
     }
 
+    @Nullable
     public String getIconImageUrl() {
         return mNativeAd.getIconImageUrl();
     }
 
+    @Nullable
     public String getClickDestinationUrl() {
         return mNativeAd.getClickDestinationUrl();
     }
 
+    @Nullable
     public String getCallToAction() {
         return mNativeAd.getCallToAction();
     }
 
+    @Nullable
     public String getTitle() {
         return mNativeAd.getTitle();
     }
 
+    @Nullable
     public String getText() {
         return mNativeAd.getText();
     }
 
+    @NonNull
     public List<String> getImpressionTrackers() {
         final Set<String> allImpressionTrackers = new HashSet<String>();
         allImpressionTrackers.addAll(mMoPubImpressionTrackers);
@@ -178,10 +188,12 @@ public String getText() {
         return new ArrayList<String>(allImpressionTrackers);
     }
 
+    @NonNull
     public String getClickTracker() {
         return mMoPubClickTracker;
     }
 
+    @Nullable
     public Double getStarRating() {
         return mNativeAd.getStarRating();
     }
@@ -195,10 +207,12 @@ public int getImpressionMinPercentageViewed() {
     }
 
     // Extras Getters
+    @Nullable
     public Object getExtra(final String key) {
         return mNativeAd.getExtra(key);
     }
 
+    @NonNull
     public Map<String, Object> getExtras() {
         return mNativeAd.getExtras();
     }
@@ -212,7 +226,7 @@ public boolean isOverridingClickTracker() {
     }
 
     // Event Handlers
-    public void prepare(final View view) {
+    public void prepare(@NonNull final View view) {
         if (isDestroyed()) {
             return;
         }
@@ -224,13 +238,14 @@ public void prepare(final View view) {
         mNativeAd.prepare(view);
     }
 
-    public void recordImpression(final View view) {
+    public void recordImpression(@Nullable final View view) {
         if (getRecordedImpression() || isDestroyed()) {
             return;
         }
 
         for (final String impressionTracker : getImpressionTrackers()) {
-            HttpClient.makeTrackingHttpRequest(impressionTracker, mContext);
+            TrackingRequest.makeTrackingHttpRequest(
+                    impressionTracker, mContext, BaseEvent.Name.IMPRESSION_REQUEST);
         }
 
         mNativeAd.recordImpression();
@@ -239,13 +254,14 @@ public void recordImpression(final View view) {
         mMoPubNativeEventListener.onNativeImpression(view);
     }
 
-    public void handleClick(final View view) {
+    public void handleClick(@Nullable final View view) {
         if (isDestroyed()) {
             return;
         }
 
         if (!isClicked()) {
-            HttpClient.makeTrackingHttpRequest(mMoPubClickTracker, mContext);
+            TrackingRequest.makeTrackingHttpRequest(
+                    mMoPubClickTracker, mContext, BaseEvent.Name.CLICK_REQUEST);
         }
 
         openClickDestinationUrl(view);
@@ -255,7 +271,7 @@ public void handleClick(final View view) {
         mMoPubNativeEventListener.onNativeClick(view);
     }
 
-    public void clear(final View view) {
+    public void clear(@NonNull final View view) {
         setOnClickListener(view, null);
 
         mNativeAd.clear(view);
@@ -273,11 +289,11 @@ public void destroy() {
     }
 
     // Non Interface Public Methods
-    public void loadMainImage(final ImageView imageView) {
+    public void loadMainImage(@Nullable final ImageView imageView) {
         loadImageView(getMainImageUrl(), imageView);
     }
 
-    public void loadIconImage(final ImageView imageView) {
+    public void loadIconImage(@Nullable final ImageView imageView) {
         loadImageView(getIconImageUrl(), imageView);
     }
 
@@ -301,11 +317,34 @@ public boolean isDestroyed() {
     }
 
     // Helpers
-    private void loadImageView(final String url, final ImageView imageView) {
-        ImageViewService.loadImageView(url, imageView);
+    private void loadImageView(@Nullable final String url, @Nullable final ImageView imageView) {
+        if (imageView == null) {
+            return;
+        }
+
+        if (url == null) {
+            imageView.setImageDrawable(null);
+        } else {
+            mImageLoader.get(url, new ImageLoader.ImageListener() {
+                @Override
+                public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                        final boolean isImmediate) {
+                    if (!isImmediate) {
+                        MoPubLog.d("Image was not loaded immediately into your ad view. You should call preCacheImages as part of your custom event loading process.");
+                    }
+                    imageView.setImageBitmap(imageContainer.getBitmap());
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) {
+                    MoPubLog.d("Failed to load image.", volleyError);
+                    imageView.setImageDrawable(null);
+                }
+            });
+        }
     }
 
-    private void openClickDestinationUrl(final View view) {
+    private void openClickDestinationUrl(@Nullable final View view) {
         if (getClickDestinationUrl() == null) {
             return;
         }
@@ -317,16 +356,13 @@ private void openClickDestinationUrl(final View view) {
         }
 
         final Iterator<String> urlIterator = Arrays.asList(getClickDestinationUrl()).iterator();
-        final ClickDestinationUrlResolutionListener urlResolutionListener = new ClickDestinationUrlResolutionListener(
-                mContext,
-                urlIterator,
-                spinningProgressView
-        );
-
-        getResolvedUrl(urlIterator.next(), urlResolutionListener);
+        final ClickDestinationResolutionListener urlResolutionListener =
+                new ClickDestinationResolutionListener(mContext, urlIterator, spinningProgressView);
+        UrlResolutionTask.getResolvedUrl(urlIterator.next(), urlResolutionListener);
     }
 
-    private void setOnClickListener(final View view, final OnClickListener onClickListener) {
+    private void setOnClickListener(@NonNull final View view,
+            @Nullable final OnClickListener onClickListener) {
         view.setOnClickListener(onClickListener);
         if ((view instanceof ViewGroup)) {
             ViewGroup viewGroup = (ViewGroup)view;
@@ -335,68 +371,21 @@ private void setOnClickListener(final View view, final OnClickListener onClickLi
         }
     }
 
-    private static class ClickDestinationUrlResolutionListener implements UrlResolutionListener {
-        private final Context mContext;
-        private final Iterator<String> mUrlIterator;
-        private final SoftReference<SpinningProgressView> mSpinningProgressView;
-
-        public ClickDestinationUrlResolutionListener(final Context context,
-                final Iterator<String> urlIterator,
-                final SpinningProgressView spinningProgressView) {
-            mContext = context.getApplicationContext();
-            mUrlIterator = urlIterator;
-            mSpinningProgressView = new SoftReference<SpinningProgressView>(spinningProgressView);
-        }
-
-        @Override
-        public void onSuccess(final String resolvedUrl) {
-            final Intent intent = new Intent(Intent.ACTION_VIEW);
-            intent.setData(Uri.parse(resolvedUrl));
-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-            if (IntentUtils.isDeepLink(resolvedUrl) && IntentUtils.deviceCanHandleIntent(mContext, intent)) {
-                // Open another Android app from deep link
-                mContext.startActivity(intent);
-            } else if (mUrlIterator.hasNext()) {
-                // If we can't handle a deep link then try the fallback url
-                getResolvedUrl(mUrlIterator.next(), this);
-                return;
-            } else {
-                // If we can't open the deep link and there are no backup links
-                // Or the link is a browser link then handle it here
-                MoPubBrowser.open(mContext, resolvedUrl);
-            }
-
-            removeSpinningProgressView();
-        }
-
-        @Override
-        public void onFailure() {
-            MoPubLog.d("Failed to resolve URL for click.");
-            removeSpinningProgressView();
-        }
-
-        private void removeSpinningProgressView() {
-            final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
-            if (spinningProgressView != null) {
-                spinningProgressView.removeFromRoot();
-            }
-        }
-    }
-
     @VisibleForTesting
     class NativeViewClickListener implements OnClickListener {
         @Override
-        public void onClick(final View view) {
+        public void onClick(@NonNull final View view) {
             handleClick(view);
         }
     }
 
+    @Nullable
     @Deprecated
     public String getSubtitle() {
         return mNativeAd.getText();
     }
 
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeEventListener getMoPubNativeEventListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
index 3957024a..bb9e97b1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
@@ -1,30 +1,31 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.location.Location;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
+
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-import com.mopub.common.util.Strings;
+import com.mopub.common.Constants;
 
 class NativeUrlGenerator extends AdUrlGenerator {
-    private String mDesiredAssets;
-    private String mSequenceNumber;
+    @Nullable private String mDesiredAssets;
+    @Nullable private String mSequenceNumber;
 
     NativeUrlGenerator(Context context) {
         super(context);
     }
 
+    @NonNull
     @Override
     public NativeUrlGenerator withAdUnitId(final String adUnitId) {
         mAdUnitId = adUnitId;
         return this;
     }
 
-    NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
+    @NonNull
+    NativeUrlGenerator withRequest(@Nullable final RequestParameters requestParameters) {
         if (requestParameters != null) {
             mKeywords = requestParameters.getKeywords();
             mLocation = requestParameters.getLocation();
@@ -33,6 +34,7 @@ NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
         return this;
     }
 
+    @NonNull
     NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
         mSequenceNumber = String.valueOf(sequenceNumber);
         return this;
@@ -40,49 +42,10 @@ NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
 
     @Override
     public String generateUrlString(final String serverHostname) {
-        initUrlString(serverHostname, Constants.NATIVE_HANDLER);
-
-        setAdUnitId(mAdUnitId);
-
-        setKeywords(mKeywords);
-
-        Location location = mLocation;
-        if (location == null) {
-            location = LocationService.getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-        setLocation(location);
+        initUrlString(serverHostname, Constants.AD_HANDLER);
 
         ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setUdid(clientMetadata.getAdvertisingId());
-
-        setDoNotTrack(clientMetadata.isDoNotTrackSet());
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        String networkOperator = clientMetadata.getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
-
-        setTwitterAppInstalledFlag();
+        addBaseParams(clientMetadata);
 
         setDesiredAssets();
 
@@ -98,7 +61,7 @@ private void setSequenceNumber() {
     }
 
     private void setDesiredAssets() {
-        if (mDesiredAssets != null && !Strings.isEmpty(mDesiredAssets)) {
+        if (!TextUtils.isEmpty(mDesiredAssets)) {
             addParam("assets", mDesiredAssets);
         }
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
index 0ca2dc4a..a7b99ef0 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
@@ -1,22 +1,29 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 class NativeViewHolder {
-    TextView titleView;
-    TextView textView;
-    TextView callToActionView;
-    ImageView mainImageView;
-    ImageView iconImageView;
+    @Nullable TextView titleView;
+    @Nullable TextView textView;
+    @Nullable TextView callToActionView;
+    @Nullable ImageView mainImageView;
+    @Nullable ImageView iconImageView;
+
+    @VisibleForTesting
+    static final NativeViewHolder EMPTY_VIEW_HOLDER = new NativeViewHolder();
 
     // Use fromViewBinder instead of a constructor
     private NativeViewHolder() {}
 
-    static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBinder) {
+    @NonNull
+    static NativeViewHolder fromViewBinder(@NonNull final View view, @NonNull final ViewBinder viewBinder) {
         final NativeViewHolder nativeViewHolder = new NativeViewHolder();
 
         try {
@@ -25,26 +32,24 @@ static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBin
             nativeViewHolder.callToActionView = (TextView) view.findViewById(viewBinder.callToActionId);
             nativeViewHolder.mainImageView = (ImageView) view.findViewById(viewBinder.mainImageId);
             nativeViewHolder.iconImageView = (ImageView) view.findViewById(viewBinder.iconImageId);
-        } catch (ClassCastException e) {
-            MoPubLog.d("Could not cast View from id in ViewBinder to expected View type", e);
-            return null;
+            return nativeViewHolder;
+        } catch (ClassCastException exception) {
+            MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
+            return EMPTY_VIEW_HOLDER;
         }
-
-        return nativeViewHolder;
     }
 
-    void update(final NativeResponse nativeResponse) {
+    void update(@NonNull final NativeResponse nativeResponse) {
         addTextView(titleView, nativeResponse.getTitle());
         addTextView(textView, nativeResponse.getText());
         addTextView(callToActionView, nativeResponse.getCallToAction());
-
         nativeResponse.loadMainImage(mainImageView);
         nativeResponse.loadIconImage(iconImageView);
     }
 
-    void updateExtras(final View outerView,
-                      final NativeResponse nativeResponse,
-                      final ViewBinder viewBinder) {
+    void updateExtras(@NonNull final View outerView,
+                      @NonNull final NativeResponse nativeResponse,
+                      @NonNull final ViewBinder viewBinder) {
         for (final String key : viewBinder.extras.keySet()) {
             final int resourceId = viewBinder.extras.get(key);
             final View view = outerView.findViewById(resourceId);
@@ -66,7 +71,7 @@ void updateExtras(final View outerView,
         }
     }
 
-    private void addTextView(final TextView textView, final String contents) {
+    private void addTextView(@Nullable final TextView textView, @Nullable final String contents) {
         if (textView == null) {
             MoPubLog.d("Attempted to add text (" + contents + ") to null TextView.");
             return;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
index cb4e21df..bba220d6 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
@@ -1,5 +1,8 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
@@ -127,24 +130,25 @@
 
     // Initialize all of these to their max capacity. This prevents garbage collection when
     // reallocating the list, which causes noticeable stuttering when scrolling on some devices.
-    private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
-    private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
     private int mDesiredCount = 0;
-    private final int[] mOriginalAdPositions = new int[MAX_ADS];
-    private final int[] mAdjustedAdPositions = new int[MAX_ADS];
-    private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
+    @NonNull private final int[] mOriginalAdPositions = new int[MAX_ADS];
+    @NonNull private final int[] mAdjustedAdPositions = new int[MAX_ADS];
+    @NonNull private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
     private int mPlacedCount = 0;
 
     /**
      * @param desiredInsertionPositions Insertion positions, expressed as original positions
      */
-    private PlacementData(final int[] desiredInsertionPositions) {
+    private PlacementData(@NonNull final int[] desiredInsertionPositions) {
         mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
         System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
         System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
     }
 
-    static PlacementData fromAdPositioning(final MoPubClientPositioning adPositioning) {
+    @NonNull
+    static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
         final List<Integer> fixed = adPositioning.getFixedPositions();
         final int interval = adPositioning.getRepeatingInterval();
 
@@ -168,6 +172,7 @@ static PlacementData fromAdPositioning(final MoPubClientPositioning adPositionin
         return new PlacementData(desiredInsertionPositions);
     }
 
+    @NonNull
     static PlacementData empty() {
         return new PlacementData(new int[] {});
     }
@@ -265,6 +270,7 @@ boolean isPlacedAd(final int position) {
      * Returns the ad data associated with the given ad position, or {@code null} if there is
      * no ad at this position.
      */
+    @Nullable
     NativeAdData getPlacedAd(final int position) {
         final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
         if (index < 0) {
@@ -277,6 +283,7 @@ NativeAdData getPlacedAd(final int position) {
      * Returns all placed ad positions. This method allocates new memory on every invocation. Do
      * not call it from performance critical code.
      */
+    @NonNull
     int[] getPlacedAdPositions() {
         int[] positions = new int[mPlacedCount];
         System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java
new file mode 100644
index 00000000..9446d7a5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java
@@ -0,0 +1,127 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+import com.mopub.volley.toolbox.JsonRequest;
+
+import org.apache.http.HttpStatus;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+
+import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+
+public class PositioningRequest extends JsonRequest<MoPubClientPositioning> {
+    private static final String FIXED_KEY = "fixed";
+    private static final String SECTION_KEY = "section";
+    private static final String POSITION_KEY = "position";
+    private static final String REPEATING_KEY = "repeating";
+    private static final String INTERVAL_KEY = "interval";
+
+    // Max value to avoid bad integer math calculations. This is 2 ^ 16.
+    private static final int MAX_VALUE = 1 << 16;
+
+    public PositioningRequest(final String url,
+            final Response.Listener<MoPubClientPositioning> listener,
+            final Response.ErrorListener errorListener) {
+        super(Method.GET, url, null, listener, errorListener);
+    }
+
+    // This is done just for unit testing visibolity.
+    @Override
+    protected void deliverResponse(final MoPubClientPositioning response) {
+        super.deliverResponse(response);
+    }
+
+    @Override
+    protected Response<MoPubClientPositioning> parseNetworkResponse(final NetworkResponse response) {
+        if (response.statusCode != HttpStatus.SC_OK) {
+            return Response.error(new VolleyError(response));
+        }
+
+        if (response.data.length == 0) {
+            return Response.error(new VolleyError("Empty positioning response", new JSONException("Empty response")));
+        }
+
+        try {
+            String jsonString = new String(response.data,
+                    HttpHeaderParser.parseCharset(response.headers));
+
+            return Response.success(parseJson(jsonString), HttpHeaderParser.parseCacheHeaders(response));
+        } catch (UnsupportedEncodingException e) {
+            return Response.error(new VolleyError("Couldn't parse JSON from Charset", e));
+        } catch (JSONException e) {
+            return Response.error(new VolleyError("JSON Parsing Error", e));
+        } catch (MoPubNetworkError e) {
+            return Response.error(e);
+        }
+    }
+
+    @NonNull
+    @VisibleForTesting
+    MoPubClientPositioning parseJson(@NonNull String jsonString) throws  JSONException, MoPubNetworkError {
+        JSONObject jsonObject = new JSONObject(jsonString);
+
+        // If the server returns an error explicitly, throw an exception with the message.
+        String error = jsonObject.optString("error", null);
+        if (error != null) {
+            if (error.equalsIgnoreCase("WARMING_UP")) {
+                throw new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP);
+            }
+            throw new JSONException(error);
+        }
+
+        // Parse fixed and repeating rules.
+        JSONArray fixed = jsonObject.optJSONArray(FIXED_KEY);
+        JSONObject repeating = jsonObject.optJSONObject(REPEATING_KEY);
+        if (fixed == null && repeating == null) {
+            throw new JSONException("Must contain fixed or repeating positions");
+        }
+
+        MoPubClientPositioning positioning = new MoPubClientPositioning();
+        if (fixed != null) {
+            parseFixedJson(fixed, positioning);
+        }
+        if (repeating != null) {
+            parseRepeatingJson(repeating, positioning);
+        }
+        return positioning;
+    }
+
+    private void parseFixedJson(@NonNull final JSONArray fixed,
+            @NonNull final MoPubClientPositioning positioning) throws JSONException {
+        for (int i = 0; i < fixed.length(); ++i) {
+            JSONObject positionObject = fixed.getJSONObject(i);
+            int section = positionObject.optInt(SECTION_KEY, 0);
+            if (section < 0) {
+                throw new JSONException("Invalid section " + section + " in JSON response");
+            }
+            if (section > 0) {
+                // Ignore sections > 0.
+                continue;
+            }
+            int position = positionObject.getInt(POSITION_KEY);
+            if (position < 0 || position > MAX_VALUE) {
+                throw new JSONException("Invalid position " + position + " in JSON response");
+            }
+            positioning.addFixedPosition(position);
+        }
+    }
+
+    private void parseRepeatingJson(@NonNull final JSONObject repeatingObject,
+            @NonNull final MoPubClientPositioning positioning) throws JSONException {
+        int interval = repeatingObject.getInt(INTERVAL_KEY);
+        if (interval < 2 || interval > MAX_VALUE) {
+            throw new JSONException("Invalid interval " + interval + " in JSON response");
+        }
+        positioning.enableRepeatingPositions(interval);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
index 354ea6df..c26b1e33 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
@@ -1,8 +1,7 @@
 package com.mopub.nativeads;
 
-import android.os.Handler;
+import android.support.annotation.NonNull;
 
-import com.mopub.common.VisibleForTesting;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
 /**
@@ -11,11 +10,11 @@
 interface PositioningSource {
 
     interface PositioningListener {
-        void onLoad(MoPubClientPositioning positioning);
+        void onLoad(@NonNull MoPubClientPositioning positioning);
 
         void onFailed();
     }
 
-    void loadPositions(String adUnitId, PositioningListener listener);
+    void loadPositions(@NonNull String adUnitId, @NonNull PositioningListener listener);
 
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
index e1a1ad6e..f9b0fafb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
@@ -1,27 +1,30 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
 
 class PositioningUrlGenerator extends BaseUrlGenerator {
     private static final String POSITIONING_API_VERSION = "1";
 
-    private final Context mContext;
-    private String mAdUnitId;
+    @NonNull private final Context mContext;
+    @NonNull private String mAdUnitId;
 
-    public PositioningUrlGenerator(Context context) {
+    public PositioningUrlGenerator(@NonNull Context context) {
         mContext = context;
     }
 
-    public PositioningUrlGenerator withAdUnitId(final String adUnitId) {
+    @NonNull
+    public PositioningUrlGenerator withAdUnitId(@NonNull final String adUnitId) {
         mAdUnitId = adUnitId;
         return this;
     }
 
     @Override
-    public String generateUrlString(final String serverHostname) {
+    public String generateUrlString(@NonNull final String serverHostname) {
         initUrlString(serverHostname, Constants.POSITIONING_HANDLER);
 
         setAdUnitId(mAdUnitId);
@@ -36,18 +39,18 @@ public String generateUrlString(final String serverHostname) {
                 clientMetadata.getDeviceModel(),
                 clientMetadata.getDeviceProduct());
 
-        setUdid(clientMetadata.getAdvertisingId());
-
         setAppVersion(clientMetadata.getAppVersion());
 
+        appendAdvertisingInfoTemplates();
+
         return getFinalUrlString();
     }
 
-    private void setAdUnitId(String adUnitId) {
+    private void setAdUnitId(@NonNull String adUnitId) {
         addParam("id", adUnitId);
     }
 
-    private void setSdkVersion(String sdkVersion) {
+    private void setSdkVersion(@NonNull String sdkVersion) {
         addParam("nsv", sdkVersion);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
index fea4fb4c..d6edb69c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
@@ -1,11 +1,13 @@
 package com.mopub.nativeads;
 
 import android.location.Location;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
 import java.util.EnumSet;
 
-public final class RequestParameters {
+public class RequestParameters {
 
     public enum NativeAdAsset {
         TITLE("title"),
@@ -17,56 +19,63 @@
 
         private final String mAssetName;
 
-        private NativeAdAsset(String assetName) {
+        private NativeAdAsset(@NonNull String assetName) {
             mAssetName = assetName;
         }
 
+        @NonNull
         @Override
         public String toString() {
             return mAssetName;
         }
     }
 
-    private final String mKeywords;
-    private final Location mLocation;
-    private final EnumSet<NativeAdAsset> mDesiredAssets;
+    @Nullable private final String mKeywords;
+    @Nullable private final Location mLocation;
+    @Nullable private final EnumSet<NativeAdAsset> mDesiredAssets;
 
     public final static class Builder {
         private String keywords;
         private Location location;
         private EnumSet<NativeAdAsset> desiredAssets;
 
+        @NonNull
         public final Builder keywords(String keywords) {
             this.keywords = keywords;
             return this;
         }
 
+        @NonNull
         public final Builder location(Location location) {
             this.location = location;
             return this;
         }
 
         // Specify set of assets used by this ad request. If not set, this defaults to all assets
+        @NonNull
         public final Builder desiredAssets(final EnumSet<NativeAdAsset> desiredAssets) {
             this.desiredAssets = EnumSet.copyOf(desiredAssets);
             return this;
         }
 
+        @NonNull
         public final RequestParameters build() {
             return new RequestParameters(this);
         }
     }
 
-    private RequestParameters(Builder builder) {
+    private RequestParameters(@NonNull Builder builder) {
         mKeywords = builder.keywords;
         mLocation = builder.location;
         mDesiredAssets = builder.desiredAssets;
     }
 
+    @Nullable
     public final String getKeywords() {
         return mKeywords;
     }
 
+    @Nullable
     public final Location getLocation() {
         return mLocation;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
index 55049bd4..4d4658cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
@@ -2,23 +2,20 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.DownloadTask.DownloadTaskListener;
-import com.mopub.common.HttpClient;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.Preconditions;
+import com.mopub.common.Constants;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
-
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
 
 /**
  * Requests positioning information from the MoPub ad server.
@@ -55,39 +52,22 @@
     @VisibleForTesting
     static int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
 
-    private static final String FIXED_KEY = "fixed";
-    private static final String SECTION_KEY = "section";
-    private static final String POSITION_KEY = "position";
-    private static final String REPEATING_KEY = "repeating";
-    private static final String INTERVAL_KEY = "interval";
-
-    // Max value to avoid bad integer math calculations. This is 2 ^ 16.
-    private static final int MAX_VALUE = 1 << 16;
-
-    private final Context mContext;
-
-    private final DownloadTaskProvider mDownloadTaskProvider;
+    @NonNull private final Context mContext;
 
     // Handler and runnable for retrying after a failed response.
-    private final Handler mRetryHandler;
-    private final Runnable mRetryRunnable;
+    @NonNull private final Handler mRetryHandler;
+    @NonNull private final Runnable mRetryRunnable;
+    private final Response.Listener<MoPubClientPositioning> mPositioningListener;
+    private final Response.ErrorListener mErrorListener;
 
-    // Only exists while a request is in flight.
-    private DownloadTask mDownloadTask;
-
-    private PositioningListener mListener;
+    @Nullable private PositioningListener mListener;
     private int mRetryCount;
-    private String mRetryUrl;
-
-    ServerPositioningSource(final Context context) {
-        this(context, new DownloadTaskProvider());
-    }
+    @Nullable private String mRetryUrl;
+    @Nullable private PositioningRequest mRequest;
 
-    @VisibleForTesting
-    ServerPositioningSource(final Context context,
-            final DownloadTaskProvider downloadTaskProvider) {
+    ServerPositioningSource(@NonNull final Context context) {
         mContext = context.getApplicationContext();
-        mDownloadTaskProvider = downloadTaskProvider;
+
         mRetryHandler = new Handler();
         mRetryRunnable = new Runnable() {
             @Override
@@ -95,14 +75,37 @@ public void run() {
                 requestPositioningInternal();
             }
         };
+
+        mPositioningListener = new Response.Listener<MoPubClientPositioning>() {
+            @Override
+            public void onResponse(final MoPubClientPositioning clientPositioning) {
+                handleSuccess(clientPositioning);
+            }
+        };
+
+        mErrorListener = new Response.ErrorListener() {
+            @Override
+            public void onErrorResponse(final VolleyError error) {
+                // Don't log a stack trace when we're just warming up.
+                if (!(error instanceof MoPubNetworkError) ||
+                        ((MoPubNetworkError) error).getReason().equals(MoPubNetworkError.Reason.WARMING_UP)) {
+                    MoPubLog.e("Failed to load positioning data", error);
+                    if (error.networkResponse == null && !DeviceUtils.isNetworkAvailable(mContext)) {
+                        MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                    }
+                }
+
+                handleFailure();
+            }
+        };
     }
 
     @Override
-    public void loadPositions(String adUnitId, PositioningListener listener) {
+    public void loadPositions(@NonNull String adUnitId, @NonNull PositioningListener listener) {
         // If a request is in flight, remove it.
-        if (mDownloadTask != null) {
-            mDownloadTask.cancel(true);
-            mDownloadTask = null;
+        if (mRequest != null) {
+            mRequest.cancel();
+            mRequest = null;
         }
 
         // If a retry is pending remove it.
@@ -114,55 +117,22 @@ public void loadPositions(String adUnitId, PositioningListener listener) {
         mListener = listener;
         mRetryUrl = new PositioningUrlGenerator(mContext)
                 .withAdUnitId(adUnitId)
-                .generateUrlString(Constants.POSITIONING_HOST);
+                .generateUrlString(Constants.HOST);
         requestPositioningInternal();
     }
 
     private void requestPositioningInternal() {
         MoPubLog.d("Loading positioning from: " + mRetryUrl);
-        mDownloadTask = mDownloadTaskProvider.get(mTaskListener);
-        final HttpGet httpGet = HttpClient.initializeHttpGet(mRetryUrl, mContext);
-        AsyncTasks.safeExecuteOnExecutor(mDownloadTask, httpGet);
-    }
 
-    private DownloadTaskListener mTaskListener = new DownloadTask.DownloadTaskListener() {
-        @Override
-        public void onComplete(final String url, final DownloadResponse downloadResponse) {
-            // Will be null only if cancelled.
-            if (downloadResponse == null) {
-                return;
-            }
-
-            mDownloadTask = null;
-            if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.e("Invalid positioning download response ");
-                handleFailure();
-                return;
-            }
-
-            String responseText = HttpResponses.asResponseString(downloadResponse);
-            MoPubClientPositioning positioning;
-            try {
-                positioning = parseJsonResponse(responseText);
-            } catch (JSONException exception) {
-                MoPubLog.e("Error parsing JSON: ", exception);
-                handleFailure();
-                return;
-            }
-
-            handleSuccess(positioning);
-        }
-    };
-
-    @VisibleForTesting
-    static class DownloadTaskProvider {
-        DownloadTask get(DownloadTaskListener listener) {
-            return new DownloadTask(listener);
-        }
+        mRequest = new PositioningRequest(mRetryUrl, mPositioningListener, mErrorListener);
+        final RequestQueue requestQueue = Networking.getRequestQueue(mContext);
+        requestQueue.add(mRequest);
     }
 
-    private void handleSuccess(MoPubClientPositioning positioning) {
-        mListener.onLoad(positioning);
+    private void handleSuccess(@NonNull MoPubClientPositioning positioning) {
+        if (mListener != null) {
+            mListener.onLoad(positioning);
+        }
         mListener = null;
         mRetryCount = 0;
     }
@@ -172,7 +142,9 @@ private void handleFailure() {
         int delay = (int) (DEFAULT_RETRY_TIME_MILLISECONDS * multiplier);
         if (delay >= MAXIMUM_RETRY_TIME_MILLISECONDS) {
             MoPubLog.d("Error downloading positioning information");
-            mListener.onFailed();
+            if (mListener != null) {
+                mListener.onFailed();
+            }
             mListener = null;
             return;
         }
@@ -180,62 +152,4 @@ private void handleFailure() {
         mRetryCount++;
         mRetryHandler.postDelayed(mRetryRunnable, delay);
     }
-
-    @VisibleForTesting
-    MoPubClientPositioning parseJsonResponse(String json) throws JSONException {
-        if (json == null || json.equals("")) {
-            throw new JSONException("Empty response");
-        }
-
-        // If the server returns an error explicitly, throw an error with the message.
-        JSONObject jsonObject = new JSONObject(json);
-        String error = jsonObject.optString("error", null);
-        if (error != null) {
-            throw new JSONException(error);
-        }
-
-        // Parse fixed and repeating rules.
-        JSONArray fixed = jsonObject.optJSONArray(FIXED_KEY);
-        JSONObject repeating = jsonObject.optJSONObject(REPEATING_KEY);
-        MoPubClientPositioning positioning = new MoPubClientPositioning();
-        if (fixed == null && repeating == null) {
-            throw new JSONException("Must contain fixed or repeating positions");
-        }
-        if (fixed != null) {
-            parseFixedJson(fixed, positioning);
-        }
-        if (repeating != null) {
-            parseRepeatingJson(repeating, positioning);
-        }
-        return positioning;
-    }
-
-    private void parseFixedJson(final JSONArray fixed,
-            final MoPubClientPositioning positioning) throws JSONException {
-        for (int i = 0; i < fixed.length(); ++i) {
-            JSONObject positionObject = fixed.getJSONObject(i);
-            int section = positionObject.optInt(SECTION_KEY, 0);
-            if (section < 0) {
-                throw new JSONException("Invalid section " + section + " in JSON response");
-            }
-            if (section > 0) {
-                // Ignore sections > 0.
-                continue;
-            }
-            int position = positionObject.getInt(POSITION_KEY);
-            if (position < 0 || position > MAX_VALUE) {
-                throw new JSONException("Invalid position " + position + " in JSON response");
-            }
-            positioning.addFixedPosition(position);
-        }
-    }
-
-    private void parseRepeatingJson(final JSONObject repeatingObject,
-            final MoPubClientPositioning positioning) throws JSONException {
-        int interval = repeatingObject.getInt(INTERVAL_KEY);
-        if (interval < 2 || interval > MAX_VALUE) {
-            throw new JSONException("Invalid interval " + interval + " in JSON response");
-        }
-        positioning.enableRepeatingPositions(interval);
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
index 2b442392..9fa5d9ff 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
@@ -2,22 +2,25 @@
 
 import android.content.Context;
 import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.Gravity;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.LinearLayout;
 import android.widget.ProgressBar;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Views;
 
 import static android.widget.RelativeLayout.LayoutParams.MATCH_PARENT;
 
 class SpinningProgressView extends ViewGroup {
-    private final ProgressBar mProgressBar;
+    @NonNull private final ProgressBar mProgressBar;
     private int mProgressIndicatorRadius;
 
-    SpinningProgressView(final Context context) {
+    SpinningProgressView(@NonNull final Context context) {
         super(context);
 
         final LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
@@ -49,10 +52,8 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
 
     }
 
-    boolean addToRoot(final View view) {
-        if (view == null) {
-            return false;
-        }
+    boolean addToRoot(@NonNull final View view) {
+        Preconditions.checkNotNull(view);
 
         final View rootView = view.getRootView();
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
index 443a9875..a13163c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
@@ -1,5 +1,11 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
+
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -8,27 +14,24 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 abstract class TaskManager<T> {
-    protected final TaskManagerListener<T> mImageTaskManagerListener;
+    @NonNull protected final TaskManagerListener<T> mImageTaskManagerListener;
     protected final int mSize;
-    protected final Map<String, T> mResults;
+    @NonNull protected final Map<String, T> mResults;
 
-    protected final AtomicInteger mCompletedCount;
-    protected final AtomicBoolean mFailed;
+    @NonNull protected final AtomicInteger mCompletedCount;
+    @NonNull protected final AtomicBoolean mFailed;
 
     interface TaskManagerListener<T> {
-        void onSuccess(final Map<String, T> images);
+        void onSuccess(@NonNull final Map<String, T> images);
         void onFail();
     }
 
-    TaskManager(final List<String> urls, final TaskManagerListener<T> imageTaskManagerListener)
+    TaskManager(@NonNull final List<String> urls,
+            @NonNull final TaskManagerListener<T> imageTaskManagerListener)
             throws IllegalArgumentException {
-        if (urls == null) {
-            throw new IllegalArgumentException("Urls list cannot be null");
-        } else if (urls.contains(null)) {
-            throw new IllegalArgumentException("Urls list cannot contain null");
-        } else if (imageTaskManagerListener == null) {
-            throw new IllegalArgumentException("ImageTaskManagerListener cannot be null");
-        }
+        Preconditions.checkNotNull(urls, "Urls list cannot be null");
+        Preconditions.checkNotNull(imageTaskManagerListener, "ImageTaskManagerListener cannot be null");
+        Preconditions.checkState(!urls.contains(null), "Urls list cannot contain null");
 
         mSize = urls.size();
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
index 3bed271a..9d4d588b 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 
 class TimestampWrapper<T> {
-    final T mInstance;
+    @NonNull final T mInstance;
     long mCreatedTimestamp;
 
-    TimestampWrapper(final T instance) {
+    TimestampWrapper(@NonNull final T instance) {
         mInstance = instance;
         mCreatedTimestamp = SystemClock.uptimeMillis();
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
index 119b4ed8..369653a8 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
@@ -1,10 +1,13 @@
 package com.mopub.nativeads;
 
+import android.net.Uri;
 import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -14,13 +17,14 @@
     private static final int REDIRECT_LIMIT = 10;
 
     interface UrlResolutionListener {
-        void onSuccess(String resolvedUrl);
+        void onSuccess(@NonNull String resolvedUrl);
         void onFailure();
     }
 
-    private final UrlResolutionListener mListener;
+    @NonNull private final UrlResolutionListener mListener;
 
-    public static void getResolvedUrl(final String urlString, final UrlResolutionListener listener) {
+    public static void getResolvedUrl(@NonNull final String urlString,
+            @NonNull final UrlResolutionListener listener) {
         final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
 
         try {
@@ -32,12 +36,13 @@ public static void getResolvedUrl(final String urlString, final UrlResolutionLis
         }
     }
 
-    UrlResolutionTask(UrlResolutionListener listener) {
+    UrlResolutionTask(@NonNull UrlResolutionListener listener) {
         mListener = listener;
     }
 
+    @Nullable
     @Override
-    protected String doInBackground(String... urls) {
+    protected String doInBackground(@Nullable String... urls) {
         if (urls == null || urls.length == 0) {
             return null;
         }
@@ -50,7 +55,7 @@ protected String doInBackground(String... urls) {
             while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
                 // if location url is not http(s), assume it's an Android deep link
                 // this scheme will fail URL validation so we have to check early
-                if (!IntentUtils.isHttpUrl(locationUrl)) {
+                if (!UrlAction.OPEN_IN_APP_BROWSER.shouldTryHandlingUrl(Uri.parse(locationUrl))) {
                     return locationUrl;
                 }
 
@@ -66,7 +71,8 @@ protected String doInBackground(String... urls) {
         return previousUrl;
     }
 
-    private String getRedirectLocation(final String urlString) throws IOException {
+    @Nullable
+    private String getRedirectLocation(@NonNull final String urlString) throws IOException {
         final URL url = new URL(urlString);
 
         HttpURLConnection httpUrlConnection = null;
@@ -89,7 +95,7 @@ private String getRedirectLocation(final String urlString) throws IOException {
     }
 
     @Override
-    protected void onPostExecute(final String resolvedUrl) {
+    protected void onPostExecute(@Nullable final String resolvedUrl) {
         super.onPostExecute(resolvedUrl);
 
         if (isCancelled() || resolvedUrl == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
index e8309c70..0fe30f84 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
@@ -1,9 +1,12 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
-public final class ViewBinder {
+public class ViewBinder {
     public final static class Builder {
         private final int layoutId;
         private int titleId;
@@ -11,48 +14,56 @@
         private int callToActionId;
         private int mainImageId;
         private int iconImageId;
-        private Map<String, Integer> extras;
+        @NonNull private Map<String, Integer> extras = Collections.emptyMap();
 
         public Builder(final int layoutId) {
             this.layoutId = layoutId;
             this.extras = new HashMap<String, Integer>();
         }
 
+        @NonNull
         public final Builder titleId(final int titleId) {
             this.titleId = titleId;
             return this;
         }
 
+        @NonNull
         public final Builder textId(final int textId) {
             this.textId = textId;
             return this;
         }
 
+        @NonNull
         public final Builder callToActionId(final int callToActionId) {
             this.callToActionId = callToActionId;
             return this;
         }
 
+        @NonNull
         public final Builder mainImageId(final int mainImageId) {
             this.mainImageId = mainImageId;
             return this;
         }
 
+        @NonNull
         public final Builder iconImageId(final int iconImageId) {
             this.iconImageId = iconImageId;
             return this;
         }
 
+        @NonNull
         public final Builder addExtras(final Map<String, Integer> resourceIds) {
             this.extras = new HashMap<String, Integer>(resourceIds);
             return this;
         }
 
+        @NonNull
         public final Builder addExtra(final String key, final int resourceId) {
             this.extras.put(key, resourceId);
             return this;
         }
 
+        @NonNull
         public final ViewBinder build() {
             return new ViewBinder(this);
         }
@@ -64,9 +75,9 @@ public final ViewBinder build() {
     final int callToActionId;
     final int mainImageId;
     final int iconImageId;
-    final Map<String, Integer> extras;
+    @NonNull final Map<String, Integer> extras;
 
-    private ViewBinder(final Builder builder) {
+    private ViewBinder(@NonNull final Builder builder) {
         this.layoutId = builder.layoutId;
         this.titleId = builder.titleId;
         this.textId = builder.textId;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
index 7ff0842a..b98a4481 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
@@ -5,6 +5,8 @@
 import android.graphics.Rect;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewTreeObserver;
 
@@ -33,7 +35,7 @@
     @VisibleForTesting static final int NUM_ACCESSES_BEFORE_TRIMMING = 50;
 
     // Temporary array of trimmed views so that we don't allocate this on every trim.
-    private final ArrayList<View> mTrimmedViews;
+    @NonNull private final ArrayList<View> mTrimmedViews;
 
     // Incrementing access counter. Use a long to support very long-lived apps.
     private long mAccessCounter = 0;
@@ -43,8 +45,8 @@
         void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews);
     }
 
-    @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
-    @VisibleForTesting final WeakReference<View> mRootView;
+    @Nullable @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
+    @NonNull @VisibleForTesting final WeakReference<View> mRootView;
 
     static class TrackingInfo {
         int mMinViewablePercent;
@@ -52,24 +54,24 @@
     }
 
     // Views that are being tracked, mapped to the min viewable percentage
-    private final Map<View, TrackingInfo> mTrackedViews;
+    @NonNull private final Map<View, TrackingInfo> mTrackedViews;
 
     // Object to check actual visibility
-    private final VisibilityChecker mVisibilityChecker;
+    @NonNull private final VisibilityChecker mVisibilityChecker;
 
     // Callback listener
-    private VisibilityTrackerListener mVisibilityTrackerListener;
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
     // Runnable to run on each visibility loop
-    private final VisibilityRunnable mVisibilityRunnable;
+    @NonNull private final VisibilityRunnable mVisibilityRunnable;
 
     // Handler for visibility
-    private final Handler mVisibilityHandler;
+    @NonNull private final Handler mVisibilityHandler;
 
     // Whether the visibility runnable is scheduled
     private boolean mIsVisibilityScheduled;
 
-    public VisibilityTracker(final Context context) {
+    public VisibilityTracker(@NonNull final Context context) {
         this(context,
                 new WeakHashMap<View, TrackingInfo>(10),
                 new VisibilityChecker(),
@@ -77,10 +79,10 @@ public VisibilityTracker(final Context context) {
     }
 
     @VisibleForTesting
-    VisibilityTracker(final Context context,
-            final Map<View, TrackingInfo> trackedViews,
-            final VisibilityChecker visibilityChecker,
-            final Handler visibilityHandler) {
+    VisibilityTracker(@NonNull final Context context,
+            @NonNull final Map<View, TrackingInfo> trackedViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final Handler visibilityHandler) {
         mTrackedViews = trackedViews;
         mVisibilityChecker = visibilityChecker;
         mVisibilityHandler = visibilityHandler;
@@ -105,14 +107,15 @@ public boolean onPreDraw() {
         }
     }
 
-    void setVisibilityTrackerListener(final VisibilityTrackerListener visibilityTrackerListener) {
+    void setVisibilityTrackerListener(
+            @Nullable final VisibilityTrackerListener visibilityTrackerListener) {
         mVisibilityTrackerListener = visibilityTrackerListener;
     }
 
     /**
      * Tracks the given view for visibility.
      */
-    void addView(final View view, final int minPercentageViewed) {
+    void addView(@NonNull final View view, final int minPercentageViewed) {
         // Find the view if already tracked
         TrackingInfo trackingInfo = mTrackedViews.get(view);
         if (trackingInfo == null) {
@@ -147,7 +150,7 @@ private void trimTrackedViews(long minAccessOrder) {
     /**
      * Stops tracking a view, cleaning any pending tracking
      */
-    void removeView(final View view) {
+    void removeView(@NonNull final View view) {
         mTrackedViews.remove(view);
     }
 
@@ -190,8 +193,8 @@ void scheduleVisibilityCheck() {
     class VisibilityRunnable implements Runnable {
         // Set of views that are visible or invisible. We create these once to avoid excessive
         // garbage collection observed when calculating these on each pass.
-        private final ArrayList<View> mVisibleViews;
-        private final ArrayList<View> mInvisibleViews;
+        @NonNull private final ArrayList<View> mVisibleViews;
+        @NonNull private final ArrayList<View> mInvisibleViews;
 
         VisibilityRunnable() {
             mInvisibleViews = new ArrayList<View>();
@@ -236,7 +239,7 @@ boolean hasRequiredTimeElapsed(final long startTimeMillis, final int minTimeView
         /**
          * Whether the view is at least certain % visible
          */
-        boolean isVisible(final View view, final int minPercentageViewed) {
+        boolean isVisible(@Nullable final View view, final int minPercentageViewed) {
             // ListView & GridView both call detachFromParent() for views that can be recycled for
             // new data. This is one of the rare instances where a view will have a null parent for
             // an extended period of time and will not be the main window.
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java b/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
index 019b5338..92fec2e1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
@@ -1,5 +1,9 @@
 package com.mopub.nativeads.factories;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
 import com.mopub.nativeads.CustomEventNative;
 import com.mopub.nativeads.MoPubCustomEventNative;
 
@@ -8,7 +12,7 @@
 public class CustomEventNativeFactory {
     protected static CustomEventNativeFactory instance = new CustomEventNativeFactory();
 
-    public static CustomEventNative create(final String className) throws Exception {
+    public static CustomEventNative create(@Nullable final String className) throws Exception {
         if (className != null) {
             final Class<? extends CustomEventNative> nativeClass = Class.forName(className)
                     .asSubclass(CustomEventNative.class);
@@ -19,11 +23,18 @@ public static CustomEventNative create(final String className) throws Exception
     }
 
     @Deprecated // for testing
-    public static void setInstance(final CustomEventNativeFactory customEventNativeFactory) {
+    public static void setInstance(
+            @NonNull final CustomEventNativeFactory customEventNativeFactory) {
+        Preconditions.checkNotNull(customEventNativeFactory);
+
         instance = customEventNativeFactory;
     }
 
-    protected CustomEventNative internalCreate(final Class<? extends CustomEventNative> nativeClass) throws Exception {
+    @NonNull
+    protected CustomEventNative internalCreate(
+            @NonNull final Class<? extends CustomEventNative> nativeClass) throws Exception {
+        Preconditions.checkNotNull(nativeClass);
+
         final Constructor<?> nativeConstructor = nativeClass.getDeclaredConstructor((Class[]) null);
         nativeConstructor.setAccessible(true);
         return (CustomEventNative) nativeConstructor.newInstance();
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
new file mode 100644
index 00000000..53fdbc30
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
@@ -0,0 +1,296 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.location.Location;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MoPub;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.AdTypeTranslator;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static com.mopub.network.HeaderUtils.extractBooleanHeader;
+import static com.mopub.network.HeaderUtils.extractHeader;
+import static com.mopub.network.HeaderUtils.extractIntegerHeader;
+
+public class AdRequest extends Request<AdResponse> {
+
+    @NonNull private final AdRequest.Listener mListener;
+    @NonNull private final AdFormat mAdFormat;
+    @Nullable private final String mAdUnitId;
+    @NonNull private final Context mContext;
+
+    public interface Listener extends Response.ErrorListener {
+        public void onSuccess(AdResponse response);
+    }
+
+    public AdRequest(@NonNull final String url,
+            @NonNull final AdFormat adFormat,
+            @Nullable final String adUnitId,
+            @NonNull Context context,
+            @NonNull final Listener listener) {
+        super(Method.GET, url, listener);
+        Preconditions.checkNotNull(adFormat);
+        Preconditions.checkNotNull(listener);
+        mAdUnitId = adUnitId;
+        mListener = listener;
+        mAdFormat = adFormat;
+        mContext = context.getApplicationContext();
+        DefaultRetryPolicy retryPolicy = new DefaultRetryPolicy(
+                DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
+                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
+                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
+        setRetryPolicy(retryPolicy);
+        setShouldCache(false);
+    }
+
+    @NonNull
+    public Listener getListener() {
+        return mListener;
+    }
+
+    @Override
+    public Map<String, String> getHeaders() {
+        TreeMap<String, String> headers = new TreeMap<String, String>();
+
+        // Use default locale first for language code
+        String languageCode = Locale.getDefault().getLanguage();
+
+        // If user's preferred locale is different from default locale, override language code
+        Locale userLocale = mContext.getResources().getConfiguration().locale;
+        if (userLocale != null) {
+            if (! userLocale.getLanguage().trim().isEmpty()) {
+                languageCode = userLocale.getLanguage().trim();
+            }
+        }
+
+        // Do not add header if language is empty
+        if (! languageCode.isEmpty()) {
+            headers.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), languageCode);
+        }
+
+        return headers;
+    }
+
+    @Override
+    protected Response<AdResponse> parseNetworkResponse(final NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+
+        Map<String, String> headers = networkResponse.headers;
+        if (extractBooleanHeader(headers, ResponseHeader.WARMUP, false)) {
+            return Response.error(new MoPubNetworkError("Ad Unit is warming up.", MoPubNetworkError.Reason.WARMING_UP));
+        }
+
+
+        Location location = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
+
+        AdResponse.Builder builder = new AdResponse.Builder();
+        builder.setAdUnitId(mAdUnitId);
+
+        String adTypeString = extractHeader(headers, ResponseHeader.AD_TYPE);
+        String fullAdTypeString = extractHeader(headers, ResponseHeader.FULL_AD_TYPE);
+        builder.setAdType(adTypeString);
+        builder.setFullAdType(fullAdTypeString);
+
+        // In the case of a CLEAR response, the REFRESH_TIME header must still be respected. Ensure
+        // that it is parsed and passed along to the MoPubNetworkError.
+        final Integer refreshTimeSeconds = extractIntegerHeader(headers, ResponseHeader.REFRESH_TIME);
+        final Integer refreshTimeMilliseconds = refreshTimeSeconds == null
+                ? null
+                : refreshTimeSeconds * 1000;
+        builder.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+
+        if (AdType.CLEAR.equals(adTypeString)) {
+            final AdResponse adResponse = builder.build();
+            logScribeEvent(adResponse, networkResponse, location);
+            return Response.error(
+                    new MoPubNetworkError(
+                            "No ads found for ad unit.",
+                            MoPubNetworkError.Reason.NO_FILL,
+                            refreshTimeMilliseconds
+                    )
+            );
+        }
+
+        builder.setNetworkType(extractHeader(headers, ResponseHeader.NETWORK_TYPE));
+
+        String redirectUrl = extractHeader(headers, ResponseHeader.REDIRECT_URL);
+        builder.setRedirectUrl(redirectUrl);
+
+        String clickTrackingUrl = extractHeader(headers, ResponseHeader.CLICK_TRACKING_URL);
+        builder.setClickTrackingUrl(clickTrackingUrl);
+
+        builder.setImpressionTrackingUrl(extractHeader(headers, ResponseHeader.IMPRESSION_URL));
+
+        String failUrl = extractHeader(headers, ResponseHeader.FAIL_URL);
+        builder.setFailoverUrl(failUrl);
+
+        String requestId = getRequestId(failUrl);
+        builder.setRequestId(requestId);
+
+        boolean isScrollable = extractBooleanHeader(headers, ResponseHeader.SCROLLABLE, false);
+        builder.setScrollable(isScrollable);
+
+        builder.setDimensions(extractIntegerHeader(headers, ResponseHeader.WIDTH),
+                extractIntegerHeader(headers, ResponseHeader.HEIGHT));
+
+        Integer adTimeoutDelaySeconds = extractIntegerHeader(headers, ResponseHeader.AD_TIMEOUT);
+        builder.setAdTimeoutDelayMilliseconds(
+                adTimeoutDelaySeconds == null
+                        ? null
+                        : adTimeoutDelaySeconds * 1000);
+
+        // Response Body encoding / decoding
+        String responseBody = parseStringBody(networkResponse);
+        builder.setResponseBody(responseBody);
+        if (AdType.NATIVE.equals(adTypeString)) {
+            try {
+                builder.setJsonBody(new JSONObject(responseBody));
+            } catch (JSONException e) {
+                return Response.error(
+                        new MoPubNetworkError("Failed to decode body JSON for native ad format",
+                                e, MoPubNetworkError.Reason.BAD_BODY));
+            }
+        }
+
+        // Derive custom event fields
+        String customEventClassName = AdTypeTranslator.getCustomEventName(mAdFormat, adTypeString,
+                fullAdTypeString, headers);
+        builder.setCustomEventClassName(customEventClassName);
+
+        // Process server extras if they are present:
+        String customEventData = extractHeader(headers, ResponseHeader.CUSTOM_EVENT_DATA);
+
+        // Some server-supported custom events (like Millennial banners) use a different header field
+        if (TextUtils.isEmpty(customEventData)) {
+            customEventData = extractHeader(headers, ResponseHeader.NATIVE_PARAMS);
+        }
+        try {
+            builder.setServerExtras(Json.jsonStringToMap(customEventData));
+        } catch (JSONException e) {
+            return Response.error(
+                    new MoPubNetworkError("Failed to decode server extras for custom event data.",
+                            e, MoPubNetworkError.Reason.BAD_HEADER_DATA));
+        }
+
+        // Some MoPub-specific custom events get their serverExtras from the response itself:
+        if (eventDataIsInResponseBody(adTypeString, fullAdTypeString)) {
+            Map<String, String> eventDataMap = new TreeMap<String, String>();
+            eventDataMap.put(DataKeys.HTML_RESPONSE_BODY_KEY, responseBody);
+            eventDataMap.put(DataKeys.SCROLLABLE_KEY, Boolean.toString(isScrollable));
+            eventDataMap.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
+            if (redirectUrl != null) {
+                eventDataMap.put(DataKeys.REDIRECT_URL_KEY, redirectUrl);
+            }
+            if (clickTrackingUrl != null) {
+                eventDataMap.put(DataKeys.CLICKTHROUGH_URL_KEY, clickTrackingUrl);
+            }
+            builder.setServerExtras(eventDataMap);
+        }
+
+        AdResponse adResponse = builder.build();
+        logScribeEvent(adResponse, networkResponse, location);
+
+        return Response.success(builder.build(),  // Cast needed for Response generic.
+                HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    private boolean eventDataIsInResponseBody(@Nullable String adType,
+            @Nullable String fullAdType) {
+        return "mraid".equals(adType) || "html".equals(adType) ||
+                ("interstitial".equals(adType) && "vast".equals(fullAdType));
+    }
+
+    // Based on Volley's StringResponse class.
+    protected String parseStringBody(NetworkResponse response) {
+        String parsed;
+        try {
+            parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));
+        } catch (UnsupportedEncodingException e) {
+            parsed = new String(response.data);
+        }
+        return parsed;
+    }
+
+    @Override
+    protected void deliverResponse(final AdResponse adResponse) {
+        mListener.onSuccess(adResponse);
+    }
+
+    @Nullable
+    @VisibleForTesting
+    String getRequestId(@Nullable String failUrl) {
+        if (failUrl == null) {
+            return null;
+        }
+
+        String requestId = null;
+        Uri uri = Uri.parse(failUrl);
+        try {
+            requestId = uri.getQueryParameter("request_id");
+        } catch (UnsupportedOperationException e) {
+            MoPubLog.d("Unable to obtain request id from fail url.");
+        }
+
+        return requestId;
+    }
+
+    @VisibleForTesting
+    void logScribeEvent(@NonNull AdResponse adResponse, @NonNull NetworkResponse networkResponse,
+            @Nullable Location location) {
+        Preconditions.checkNotNull(adResponse);
+        Preconditions.checkNotNull(networkResponse);
+
+        MoPubEvents.log(
+                new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS,
+                        BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate())
+                        .withAdUnitId(mAdUnitId)
+                        .withAdCreativeId(adResponse.getDspCreativeId())
+                        .withAdType(adResponse.getAdType())
+                        .withAdNetworkType(adResponse.getNetworkType())
+                        .withAdWidthPx(adResponse.getWidth() != null
+                                ? adResponse.getWidth().doubleValue()
+                                : null)
+                        .withAdHeightPx(adResponse.getHeight() != null
+                                ? adResponse.getHeight().doubleValue()
+                                : null)
+                        .withGeoLat(location != null ? location.getLatitude() : null)
+                        .withGeoLon(location != null ? location.getLongitude() : null)
+                        .withGeoAccuracy(location != null ? (double) location.getAccuracy() : null)
+                        .withPerformanceDurationMs((double) networkResponse.networkTimeMs)
+                        .withRequestId(adResponse.getRequestId())
+                        .withRequestStatusCode(networkResponse.statusCode)
+                        .withRequestUri(getUrl())
+                        .build()
+        );
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
new file mode 100644
index 00000000..8c7bc330
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
@@ -0,0 +1,336 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.DateAndTime;
+
+import org.json.JSONObject;
+
+import java.io.Serializable;
+import java.util.Map;
+import java.util.TreeMap;
+
+public class AdResponse implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    @Nullable
+    private final String mAdType;
+
+    @Nullable
+    private final String mAdUnitId;
+
+    @Nullable
+    private final String mFullAdType;
+    @Nullable
+    private final String mNetworkType;
+
+    @Nullable
+    private final String mRedirectUrl;
+    @Nullable
+    private final String mClickTrackingUrl;
+    @Nullable
+    private final String mImpressionTrackingUrl;
+    @Nullable
+    private final String mFailoverUrl;
+    @Nullable
+    private final String mRequestId;
+
+    @Nullable
+    private final Integer mWidth;
+    @Nullable
+    private final Integer mHeight;
+    @Nullable
+    private final Integer mAdTimeoutDelayMillis;
+    @Nullable
+    private final Integer mRefreshTimeMillis;
+    @Nullable
+    private final String mDspCreativeId;
+
+    private final boolean mScrollable;
+
+    @Nullable
+    private final String mResponseBody;
+    @Nullable
+    private final JSONObject mJsonBody;
+
+    @Nullable
+    private final String mCustomEventClassName;
+    @NonNull
+    private final Map<String, String> mServerExtras;
+
+    private final long mTimestamp;
+
+    private AdResponse(@NonNull Builder builder) {
+
+        mAdType = builder.adType;
+        mAdUnitId = builder.adUnitId;
+        mFullAdType = builder.fullAdType;
+        mNetworkType = builder.networkType;
+        mRedirectUrl = builder.redirectUrl;
+        mClickTrackingUrl = builder.clickTrackingUrl;
+        mImpressionTrackingUrl = builder.impressionTrackingUrl;
+        mFailoverUrl = builder.failoverUrl;
+        mRequestId = builder.requestId;
+        mWidth = builder.width;
+        mHeight = builder.height;
+        mAdTimeoutDelayMillis = builder.adTimeoutDelayMillis;
+        mRefreshTimeMillis = builder.refreshTimeMillis;
+        mDspCreativeId = builder.dspCreativeId;
+        mScrollable = builder.scrollable;
+        mResponseBody = builder.responseBody;
+        mJsonBody = builder.jsonBody;
+        mCustomEventClassName = builder.customEventClassName;
+        mServerExtras = builder.serverExtras;
+        mTimestamp = DateAndTime.now().getTime();
+    }
+
+    public boolean hasJson() {
+        return mJsonBody != null;
+    }
+
+    @Nullable
+    public JSONObject getJsonBody() {
+        return mJsonBody;
+    }
+
+    @Nullable
+    public String getStringBody() {
+        return mResponseBody;
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mAdType;
+    }
+
+    @Nullable
+    public String getFullAdType() {
+        return mFullAdType;
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    @Nullable
+    public String getNetworkType() {
+        return mNetworkType;
+    }
+
+    @Nullable
+    public String getRedirectUrl() {
+        return mRedirectUrl;
+    }
+
+    @Nullable
+    public String getClickTrackingUrl() {
+        return mClickTrackingUrl;
+    }
+
+    @Nullable
+    public String getImpressionTrackingUrl() {
+        return mImpressionTrackingUrl;
+    }
+
+    @Nullable
+    public String getFailoverUrl() {
+        return mFailoverUrl;
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
+    public boolean isScrollable() {
+        return mScrollable;
+    }
+
+    @Nullable
+    public Integer getWidth() {
+        return mWidth;
+    }
+
+    @Nullable
+    public Integer getHeight() {
+        return mHeight;
+    }
+
+    @Nullable
+    public Integer getAdTimeoutMillis() {
+        return mAdTimeoutDelayMillis;
+    }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+
+    @Nullable
+    public String getDspCreativeId() {
+        return mDspCreativeId;
+    }
+
+    @Nullable
+    public String getCustomEventClassName() {
+        return mCustomEventClassName;
+    }
+
+    @NonNull
+    public Map<String, String> getServerExtras() {
+        // Strings are immutable, so this works as a "deep" copy.
+        return new TreeMap<String, String>(mServerExtras);
+    }
+
+    public long getTimestamp() {
+        return mTimestamp;
+    }
+
+    public Builder toBuilder() {
+        return new Builder()
+                .setAdType(mAdType)
+                .setNetworkType(mNetworkType)
+                .setRedirectUrl(mRedirectUrl)
+                .setClickTrackingUrl(mClickTrackingUrl)
+                .setImpressionTrackingUrl(mImpressionTrackingUrl)
+                .setFailoverUrl(mFailoverUrl)
+                .setDimensions(mWidth, mHeight)
+                .setAdTimeoutDelayMilliseconds(mAdTimeoutDelayMillis)
+                .setRefreshTimeMilliseconds(mRefreshTimeMillis)
+                .setDspCreativeId(mDspCreativeId)
+                .setScrollable(mScrollable)
+                .setResponseBody(mResponseBody)
+                .setJsonBody(mJsonBody)
+                .setCustomEventClassName(mCustomEventClassName)
+                .setServerExtras(mServerExtras);
+    }
+
+    public static class Builder {
+        private String adType;
+        private String adUnitId;
+        private String fullAdType;
+        private String networkType;
+
+        private String redirectUrl;
+        private String clickTrackingUrl;
+        private String impressionTrackingUrl;
+        private String failoverUrl;
+        private String requestId;
+
+        private Integer width;
+        private Integer height;
+        private Integer adTimeoutDelayMillis;
+        private Integer refreshTimeMillis;
+        private String dspCreativeId;
+
+        private boolean scrollable = false;
+
+        private String responseBody;
+        private JSONObject jsonBody;
+
+        private String customEventClassName;
+        private Map<String, String> serverExtras = new TreeMap<String, String>();
+
+        public Builder setAdType(@Nullable final String adType) {
+            this.adType = adType;
+            return this;
+        }
+
+        public Builder setAdUnitId(@Nullable final String adUnitId) {
+            this.adUnitId = adUnitId;
+            return this;
+        }
+
+        public Builder setFullAdType(@Nullable final String fullAdType) {
+            this.fullAdType = fullAdType;
+            return this;
+        }
+
+        public Builder setNetworkType(@Nullable final String networkType) {
+            this.networkType = networkType;
+            return this;
+        }
+
+        public Builder setRedirectUrl(@Nullable final String redirectUrl) {
+            this.redirectUrl = redirectUrl;
+            return this;
+        }
+
+        public Builder setClickTrackingUrl(@Nullable final String clickTrackingUrl) {
+            this.clickTrackingUrl = clickTrackingUrl;
+            return this;
+        }
+
+        public Builder setImpressionTrackingUrl(@Nullable final String impressionTrackingUrl) {
+            this.impressionTrackingUrl = impressionTrackingUrl;
+            return this;
+        }
+
+        public Builder setFailoverUrl(@Nullable final String failoverUrl) {
+            this.failoverUrl = failoverUrl;
+            return this;
+        }
+
+        public Builder setRequestId(@Nullable final String requestId) {
+            this.requestId = requestId;
+            return this;
+        }
+
+        public Builder setDimensions(@Nullable final Integer width,
+                @Nullable final Integer height) {
+            this.width = width;
+            this.height = height;
+            return this;
+        }
+
+        public Builder setAdTimeoutDelayMilliseconds(@Nullable final Integer adTimeoutDelayMilliseconds) {
+            this.adTimeoutDelayMillis = adTimeoutDelayMilliseconds;
+            return this;
+        }
+
+        public Builder setRefreshTimeMilliseconds(@Nullable final Integer refreshTimeMilliseconds) {
+            this.refreshTimeMillis = refreshTimeMilliseconds;
+            return this;
+        }
+
+        public Builder setScrollable(@Nullable final Boolean scrollable) {
+            this.scrollable = scrollable == null ? this.scrollable : scrollable;
+            return this;
+        }
+
+        public Builder setDspCreativeId(@Nullable final String dspCreativeId) {
+            this.dspCreativeId = dspCreativeId;
+            return this;
+        }
+
+        public Builder setResponseBody(@Nullable final String responseBody) {
+            this.responseBody = responseBody;
+            return this;
+        }
+
+        public Builder setJsonBody(@Nullable final JSONObject jsonBody) {
+            this.jsonBody = jsonBody;
+            return this;
+        }
+
+        public Builder setCustomEventClassName(@Nullable final String customEventClassName) {
+            this.customEventClassName = customEventClassName;
+            return this;
+        }
+
+        public Builder setServerExtras(@Nullable final Map<String, String> serverExtras) {
+            if (serverExtras == null) {
+                this.serverExtras = new TreeMap<String, String>();
+            } else {
+                this.serverExtras = new TreeMap<String, String>(serverExtras);
+            }
+            return this;
+        }
+
+        public AdResponse build() {
+            return new AdResponse(this);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
new file mode 100644
index 00000000..fa17fee8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
@@ -0,0 +1,43 @@
+package com.mopub.network;
+
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for a request.
+ */
+public abstract class BackoffPolicy {
+    protected int mBackoffMs;
+    protected int mBackoffMultiplier;
+    protected int mDefaultBackoffTimeMs;
+    protected int mMaxBackoffTimeMs;
+    protected int mRetryCount;
+    protected int mMaxRetries;
+
+    /**
+     * Prepares for the next request attempt by updating the backoff time.
+     *
+     * @param volleyError The error code of the last request attempt.
+     */
+    public abstract void backoff(VolleyError volleyError) throws VolleyError;
+
+    /**
+     * Returns the current backoff time in ms.
+     */
+    public int getBackoffMs() {
+        return mBackoffMs;
+    }
+
+    /**
+     * Returns the current retry count.
+     */
+    public int getRetryCount() {
+        return mRetryCount;
+    }
+
+    /**
+     * Returns true if this policy has attempts remaining, false otherwise.
+     */
+    public boolean hasAttemptRemaining() {
+        return mRetryCount < mMaxRetries;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
new file mode 100644
index 00000000..21c48ac1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
@@ -0,0 +1,95 @@
+package com.mopub.network;
+
+import android.net.SSLCertificateSocketFactory;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An {@link javax.net.ssl.SSLSocketFactory} that supports TLS settings for the MoPub ad servers.
+ */
+public class CustomSSLSocketFactory extends SSLSocketFactory {
+
+    private SSLSocketFactory mCertificateSocketFactory;
+
+    private CustomSSLSocketFactory() {}
+
+    public static CustomSSLSocketFactory getDefault(final int handshakeTimeoutMillis) {
+        CustomSSLSocketFactory factory = new CustomSSLSocketFactory();
+        factory.mCertificateSocketFactory = SSLCertificateSocketFactory.getDefault(handshakeTimeoutMillis, null);
+
+        return factory;
+    }
+
+    // Forward all methods. Enable TLS 1.1 and 1.2 before returning.
+
+    // SocketFactory overrides
+    @Override
+    public Socket createSocket() throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket();
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int i) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, i);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int port, final InetAddress localhost, final int localPort) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port, final InetAddress localhost, final int localPort) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    // SSLSocketFactory overrides
+
+    @Override
+    public String[] getDefaultCipherSuites() {
+        return mCertificateSocketFactory.getDefaultCipherSuites();
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return mCertificateSocketFactory.getSupportedCipherSuites();
+    }
+
+    @Override
+    public Socket createSocket(final Socket socketParam, final String host, final int port, final boolean autoClose) throws IOException {
+        Socket socket = mCertificateSocketFactory.createSocket(socketParam, host, port, autoClose);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    private void enableTlsIfAvailable(Socket socket) {
+        if (socket instanceof SSLSocket) {
+            SSLSocket sslSocket = (SSLSocket) socket;
+            String[] supportedProtocols = sslSocket.getSupportedProtocols();
+            // Make sure all supported protocols are enabled. Android does not enable TLSv1.1 or
+            // TLSv1.2 by default.
+            sslSocket.setEnabledProtocols(supportedProtocols);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
new file mode 100644
index 00000000..27eb863f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
@@ -0,0 +1,69 @@
+package com.mopub.network;
+
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.ResponseHeader;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+
+import java.text.NumberFormat;
+import java.util.Locale;
+import java.util.Map;
+
+public class HeaderUtils {
+    @Nullable
+    public static String extractHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return headers.get(responseHeader.getKey());
+    }
+
+    public static Integer extractIntegerHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return formatIntHeader(extractHeader(headers, responseHeader));
+    }
+
+    public static boolean extractBooleanHeader(Map<String, String> headers, ResponseHeader responseHeader, boolean defaultValue) {
+        return formatBooleanHeader(extractHeader(headers, responseHeader), defaultValue);
+    }
+
+    public static String extractHeader(HttpResponse response, ResponseHeader responseHeader) {
+        Header header = response.getFirstHeader(responseHeader.getKey());
+        return header != null ? header.getValue() : null;
+    }
+
+    public static boolean extractBooleanHeader(HttpResponse response, ResponseHeader responseHeader, boolean defaultValue) {
+        return formatBooleanHeader(extractHeader(response, responseHeader), defaultValue);
+    }
+
+    public static Integer extractIntegerHeader(HttpResponse response, ResponseHeader responseHeader) {
+        String headerValue = extractHeader(response, responseHeader);
+        return formatIntHeader(headerValue);
+    }
+
+    public static int extractIntHeader(HttpResponse response, ResponseHeader responseHeader, int defaultValue) {
+        Integer headerValue = extractIntegerHeader(response, responseHeader);
+        if (headerValue == null) {
+            return defaultValue;
+        }
+
+        return headerValue;
+    }
+
+    private static boolean formatBooleanHeader(@Nullable String headerValue, boolean defaultValue) {
+        if (headerValue == null) {
+            return defaultValue;
+        }
+        return headerValue.equals("1");
+    }
+
+    private static Integer formatIntHeader(String headerValue) {
+        NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
+        numberFormat.setParseIntegerOnly(true);
+
+        try {
+            Number value = numberFormat.parse(headerValue.trim());
+            return value.intValue();
+        } catch (Exception e) {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java b/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java
new file mode 100644
index 00000000..6927dd96
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java
@@ -0,0 +1,38 @@
+package com.mopub.network;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Point;
+import android.os.Build;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.volley.RequestQueue;
+
+public class MaxWidthImageLoader extends com.mopub.volley.toolbox.ImageLoader {
+    private final int mMaxImageWidth;
+
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    public MaxWidthImageLoader(final RequestQueue queue, final Context context, final ImageCache imageCache) {
+        super(queue, imageCache);
+
+        // Get Display Options
+        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        Point size = new Point();
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB_MR2) {
+            size.set(display.getWidth(), display.getHeight());
+        } else {
+            display.getSize(size);
+        }
+
+        // Make our images no wider than the skinny side of the display.
+        mMaxImageWidth = Math.min(size.x, size.y);
+    }
+
+    @Override
+    public ImageContainer get(final String requestUrl, final ImageListener listener) {
+        return super.get(requestUrl, listener, mMaxImageWidth, 0 /* no height limit */);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
new file mode 100644
index 00000000..43becf67
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
@@ -0,0 +1,66 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.VolleyError;
+
+public class MoPubNetworkError extends VolleyError {
+    public enum Reason {
+        WARMING_UP,
+        NO_FILL,
+        BAD_HEADER_DATA,
+        BAD_BODY,
+        TRACKING_FAILURE,
+        UNSPECIFIED
+    }
+
+    @NonNull private final Reason mReason;
+    @Nullable private final Integer mRefreshTimeMillis;
+
+    public MoPubNetworkError(@NonNull Reason reason) {
+        super();
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull NetworkResponse networkResponse, @NonNull Reason reason) {
+        super(networkResponse);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull Throwable cause, @NonNull Reason reason) {
+        super(cause);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason) {
+        this(message, reason, null);
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Throwable cause, @NonNull Reason reason) {
+        super(message, cause);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason,
+            @Nullable Integer refreshTimeMillis) {
+        super(message);
+        mReason = reason;
+        mRefreshTimeMillis = refreshTimeMillis;
+    }
+
+    @NonNull
+    public Reason getReason() {
+        return mReason;
+    }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
new file mode 100644
index 00000000..9b5d4592
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
@@ -0,0 +1,166 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.ResponseDelivery;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * MoPub's custom implementation of the Google Volley RequestQueue.
+ * This subclass provides convenience methods for adding a delayed request to run at a time in
+ * the future. This is useful for our backoff policy architecture.
+ *
+ * We've overridden certain implementation methods but have kept the contract of the
+ * original method consistent.
+ */
+public class MoPubRequestQueue extends RequestQueue {
+
+    private static final int CAPACITY = 10;
+
+    @NonNull
+    private final Map<Request<?>, DelayedRequestHelper> mDelayedRequests;
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) {
+        super(cache, network, threadPoolSize, delivery);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize) {
+        super(cache, network, threadPoolSize);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network) {
+        super(cache, network);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    /**
+     * Convenience method for adding a request with a time delay to the request queue.
+     *
+     * @param request The request.
+     * @param delayMs The delay in ms for adding the request to the request queue.
+     */
+    public void addDelayedRequest(@NonNull Request<?> request, int delayMs) {
+        Preconditions.checkNotNull(request);
+        addDelayedRequest(request, new DelayedRequestHelper(request, delayMs));
+    }
+
+    @VisibleForTesting
+    void addDelayedRequest(@NonNull Request<?> request, @NonNull DelayedRequestHelper delayedRequestHelper) {
+        Preconditions.checkNotNull(delayedRequestHelper);
+
+        if (mDelayedRequests.containsKey(request)) {
+            cancel(request);
+        }
+
+        delayedRequestHelper.start();
+        mDelayedRequests.put(request, delayedRequestHelper);
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull RequestFilter filter) {
+        Preconditions.checkNotNull(filter);
+
+        super.cancelAll(filter);
+
+        Iterator<Map.Entry<Request<?>, DelayedRequestHelper>> iterator = mDelayedRequests.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<Request<?>, DelayedRequestHelper> entry = iterator.next();
+            if (filter.apply(entry.getKey())) {
+                // Here we cancel both the request and the handler from posting the delayed runnable
+                entry.getKey().cancel();
+                entry.getValue().cancel();
+                iterator.remove();
+            }
+        }
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull final Object tag) {
+        Preconditions.checkNotNull(tag);
+
+        super.cancelAll(tag);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request.getTag() == tag;
+            }
+        });
+    }
+
+    /**
+     * Convenience method to cancel a single request.
+     *
+     * @param request The request to cancel.
+     */
+    public void cancel(@NonNull final Request<?> request) {
+        Preconditions.checkNotNull(request);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> _request) {
+                return request == _request;
+            }
+        });
+    }
+
+    /**
+     * This helper class is used to package the supporting objects a request needs to
+     * run at a delayed time and cancel if needed.
+     */
+    class DelayedRequestHelper {
+        final int mDelayMs;
+        @NonNull final Handler mHandler;
+        @NonNull final Runnable mDelayedRunnable;
+
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs) {
+            this(request, delayMs, new Handler());
+        }
+
+        @VisibleForTesting
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs, @NonNull Handler handler) {
+            mDelayMs = delayMs;
+            mHandler = handler;
+            mDelayedRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    mDelayedRequests.remove(request);
+                    MoPubRequestQueue.this.add(request);
+                }
+            };
+        }
+
+        void start() {
+            mHandler.postDelayed(mDelayedRunnable, mDelayMs);
+        }
+
+        void cancel() {
+            mHandler.removeCallbacks(mDelayedRunnable);
+        }
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    Map<Request<?>, DelayedRequestHelper> getDelayedRequests() {
+        return mDelayedRequests;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/Networking.java b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
new file mode 100644
index 00000000..ed087c69
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
@@ -0,0 +1,178 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.util.LruCache;
+import android.webkit.WebView;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.BasicNetwork;
+import com.mopub.volley.toolbox.DiskBasedCache;
+import com.mopub.volley.toolbox.HttpStack;
+import com.mopub.volley.toolbox.HurlStack;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import java.io.File;
+
+import javax.net.ssl.SSLSocketFactory;
+
+public class Networking {
+    @VisibleForTesting
+    static final String CACHE_DIRECTORY_NAME = "mopub-volley-cache";
+
+
+    // These are volatile so that double-checked locking works.
+    // See http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
+    // for more information.
+    private volatile static MoPubRequestQueue sRequestQueue;
+    private volatile static String sUserAgent;
+    private volatile static MaxWidthImageLoader sMaxWidthImageLoader;
+    public static boolean sUseHttps = false;
+
+    @Nullable
+    public static MoPubRequestQueue getRequestQueue() {
+        return sRequestQueue;
+    }
+
+    @NonNull
+    public static MoPubRequestQueue getRequestQueue(@NonNull Context context) {
+        MoPubRequestQueue requestQueue = sRequestQueue;
+        // Double-check locking to initialize.
+        if (requestQueue == null) {
+            synchronized (Networking.class) {
+                requestQueue = sRequestQueue;
+                if (requestQueue == null) {
+
+                    // Guarantee ClientMetadata is set up.
+                    final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+                    final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), context);
+                    final SSLSocketFactory socketFactory = CustomSSLSocketFactory.getDefault(Constants.TEN_SECONDS_MILLIS);
+
+                    final String userAgent = Networking.getUserAgent(context.getApplicationContext());
+                    HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter, socketFactory);
+
+                    Network network = new BasicNetwork(httpStack);
+                    File volleyCacheDir = new File(context.getCacheDir().getPath() + File.separator
+                            + CACHE_DIRECTORY_NAME);
+                    Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+                    requestQueue = new MoPubRequestQueue(cache, network);
+                    sRequestQueue = requestQueue;
+                    requestQueue.start();
+                }
+            }
+        }
+
+        return requestQueue;
+    }
+
+    @NonNull
+    public static ImageLoader getImageLoader(@NonNull Context context) {
+        MaxWidthImageLoader imageLoader = sMaxWidthImageLoader;
+        // Double-check locking to initialize.
+        if (imageLoader == null) {
+            synchronized (Networking.class) {
+                imageLoader = sMaxWidthImageLoader;
+                if (imageLoader == null) {
+                    RequestQueue queue = getRequestQueue(context);
+                    int cacheSize = DeviceUtils.memoryCacheSizeBytes(context);
+                    final LruCache<String, Bitmap> imageCache = new LruCache<String, Bitmap>(cacheSize) {
+                        @Override
+                        protected int sizeOf(String key, Bitmap value) {
+                            if (value != null) {
+                                return value.getRowBytes() * value.getHeight();
+                            }
+
+                            return super.sizeOf(key, value);
+                        }
+                    };
+                    imageLoader = new MaxWidthImageLoader(queue, context, new MaxWidthImageLoader.ImageCache() {
+                        @Override
+                        public Bitmap getBitmap(final String key) {
+                            return imageCache.get(key);
+                        }
+
+                        @Override
+                        public void putBitmap(final String key, final Bitmap bitmap) {
+                            imageCache.put(key, bitmap);
+                        }
+                    });
+                    sMaxWidthImageLoader = imageLoader;
+                }
+            }
+        }
+        return imageLoader;
+    }
+
+    /**
+     * Caches and returns the WebView user agent to be used across all SDK requests. This is
+     * important because advertisers expect the same user agent across all request, impression, and
+     * click events.
+     */
+    @NonNull
+    public static String getUserAgent(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        String userAgent = sUserAgent;
+        if (userAgent == null) {
+            synchronized (Networking.class) {
+                userAgent = sUserAgent;
+                if (userAgent == null) {
+                    // As of Android 4.4, WebViews may only be instantiated on the UI thread
+                    if (Looper.myLooper() == Looper.getMainLooper()) {
+                        userAgent = new WebView(context).getSettings().getUserAgentString();
+                    } else {
+                        // In the exceptional case where we can't access the WebView user agent,
+                        // fall back to the System-specific user agent.
+                        userAgent = System.getProperty("http.agent");
+                    }
+                    sUserAgent = userAgent;
+                }
+            }
+        }
+
+        return userAgent;
+    }
+
+    @VisibleForTesting
+    public static synchronized void clearForTesting() {
+        sRequestQueue = null;
+        sMaxWidthImageLoader = null;
+        sUserAgent = null;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setRequestQueueForTesting(MoPubRequestQueue queue) {
+        sRequestQueue = queue;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setImageLoaderForTesting(MaxWidthImageLoader imageLoader) {
+        sMaxWidthImageLoader = imageLoader;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setUserAgentForTesting(String userAgent) {
+        sUserAgent = userAgent;
+    }
+
+    /**
+     * Set whether to use HTTPS for communication with MoPub ad servers.
+     */
+    public static void useHttps(boolean useHttps) {
+        sUseHttps = useHttps;
+    }
+
+    public static boolean useHttps() {
+        return sUseHttps;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java b/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java
new file mode 100644
index 00000000..42438bbd
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java
@@ -0,0 +1,51 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.volley.toolbox.HurlStack;
+
+/**
+ * Url Rewriter that replaces MoPub templates for Google Advertising ID and Do Not Track settings
+ * when a request is queued for dispatch by the HurlStack in Volley.
+ */
+public class PlayServicesUrlRewriter implements HurlStack.UrlRewriter {
+    private static final String IFA_PREFIX = "ifa:";
+
+    public static final String UDID_TEMPLATE = "mp_tmpl_advertising_id";
+    public static final String DO_NOT_TRACK_TEMPLATE = "mp_tmpl_do_not_track";
+
+    private final String deviceIdentifier;
+    private final Context applicationContext;
+
+    public PlayServicesUrlRewriter(String deviceId, Context context) {
+        deviceIdentifier = deviceId;
+        applicationContext = context.getApplicationContext();
+    }
+
+    @Override
+    public String rewriteUrl(final String url) {
+        if (!url.contains(UDID_TEMPLATE) && !url.contains(DO_NOT_TRACK_TEMPLATE)) {
+            return url;
+        }
+
+        String prefix = "";
+        GpsHelper.AdvertisingInfo advertisingInfo = new GpsHelper.AdvertisingInfo(deviceIdentifier, false);
+
+        // Attempt to fetch the Google Play Services fields
+        if (GpsHelper.isPlayServicesAvailable(applicationContext)) {
+            // We can do this synchronously because urlRewrite happens in a background thread.
+            GpsHelper.AdvertisingInfo playServicesAdInfo = GpsHelper.fetchAdvertisingInfoSync(applicationContext);
+            if (playServicesAdInfo != null) {
+                prefix = IFA_PREFIX;
+                advertisingInfo = playServicesAdInfo;
+            }
+        }
+
+        // Fill in the templates
+        String toReturn = url.replace(UDID_TEMPLATE, Uri.encode(prefix + advertisingInfo.advertisingId));
+        toReturn = toReturn.replace(DO_NOT_TRACK_TEMPLATE, advertisingInfo.limitAdTracking ? "1" : "0");
+        return toReturn;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
new file mode 100644
index 00000000..ba535bf8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
@@ -0,0 +1,104 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+
+/**
+ * This class is responsible for managing the lifecycle of a request with a backoff policy. This
+ * class currently manages a single request at a time. The API allows for it to support multiple
+ * simultaneous requests in the future.
+ *
+ * Subclasses are responsible for implementing the createRequest method that will create a new
+ * instance of subclass's specific request type.
+ * The subclass is also responsible for listening to success and error responses from its specific
+ * request type.
+ *
+ * @param <T> The type of request factory to generate new requests for each retry.
+ */
+public abstract class RequestManager<T extends RequestManager.RequestFactory> {
+
+    // This interface is used to bound type T of the RequestManager
+    public interface RequestFactory{}
+
+    @Nullable protected Request<?> mCurrentRequest;
+    @Nullable protected T mRequestFactory;
+    @Nullable protected BackoffPolicy mBackoffPolicy;
+    @NonNull protected Handler mHandler;
+
+    public RequestManager(@NonNull Looper looper) {
+        mHandler = new Handler(looper);
+    }
+
+    @NonNull
+    abstract Request<?> createRequest();
+
+    public boolean isAtCapacity() {
+        return mCurrentRequest != null;
+    }
+
+    /**
+     * This method first cancels existing requests in flight and then begins the request
+     * lifecycle for the new request.
+     *
+     * @param requestFactory Factory that constructs a new request for each request retry from the
+     *                       backoff policy.
+     * @param backoffPolicy The request to cancel.
+     */
+    public void makeRequest(@NonNull T requestFactory, @NonNull BackoffPolicy backoffPolicy) {
+        Preconditions.checkNotNull(requestFactory);
+        Preconditions.checkNotNull(backoffPolicy);
+
+        cancelRequest();
+        mRequestFactory = requestFactory;
+        mBackoffPolicy = backoffPolicy;
+        makeRequestInternal();
+    }
+
+    /**
+     * Cancels the request in flight.
+     */
+    public void cancelRequest() {
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue != null && mCurrentRequest != null) {
+            requestQueue.cancel(mCurrentRequest);
+        }
+        clearRequest();
+    }
+
+    @VisibleForTesting
+    void makeRequestInternal() {
+        mCurrentRequest = createRequest();
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue == null) {
+            MoPubLog.d("MoPubRequest queue is null. Clearing request.");
+            clearRequest();
+            return;
+        }
+
+        if (mBackoffPolicy.getRetryCount() == 0) {
+            requestQueue.add(mCurrentRequest);
+        } else {
+            requestQueue.addDelayedRequest(mCurrentRequest, mBackoffPolicy.getBackoffMs());
+        }
+    }
+
+    @VisibleForTesting
+    void clearRequest() {
+        mCurrentRequest = null;
+        mRequestFactory = null;
+        mBackoffPolicy = null;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    Request<?> getCurrentRequest() {
+        return mCurrentRequest;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java b/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java
new file mode 100644
index 00000000..f2df816c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.volley.AuthFailureError;
+import com.mopub.volley.Request;
+import com.mopub.volley.toolbox.HurlStack;
+
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.TreeMap;
+
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * Modified Volley HurlStack with explicitly specified User-Agent.
+ *
+ * Used by Networking's singleton RequestQueue to ensure all network requests use WebView's
+ * User-Agent.
+ */
+public class RequestQueueHttpStack extends HurlStack {
+    @NonNull private final String mUserAgent;
+
+    public RequestQueueHttpStack(@NonNull final String userAgent) {
+        this(userAgent, null);
+    }
+
+    public RequestQueueHttpStack(@NonNull final String userAgent, @Nullable final UrlRewriter urlRewriter) {
+        this(userAgent, urlRewriter, null);
+    }
+
+    public RequestQueueHttpStack(@NonNull final String userAgent, @Nullable final UrlRewriter urlRewriter,
+                                 @Nullable final SSLSocketFactory sslSocketFactory) {
+        super(urlRewriter, sslSocketFactory);
+
+        mUserAgent = userAgent;
+    }
+
+    @Override
+    public HttpResponse performRequest(@NonNull final Request<?> request,
+            @Nullable Map<String, String> additionalHeaders) throws IOException, AuthFailureError {
+        if (additionalHeaders == null) {
+            additionalHeaders = new TreeMap<String, String>();
+        }
+
+        additionalHeaders.put(ResponseHeader.USER_AGENT.getKey(), mUserAgent);
+
+        return super.performRequest(request, additionalHeaders);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
new file mode 100644
index 00000000..5b5b3732
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for making requests to the Scribe service.
+ */
+public class ScribeBackoffPolicy extends BackoffPolicy {
+    private static final int DEFAULT_BACKOFF_TIME_MS = 60 * 1000;
+    private static final int MAX_RETRIES = 5;
+    private static final int BACKOFF_MULTIPLIER = 2;
+
+    public ScribeBackoffPolicy() {
+        this(DEFAULT_BACKOFF_TIME_MS, MAX_RETRIES, BACKOFF_MULTIPLIER);
+    }
+
+    @VisibleForTesting
+    ScribeBackoffPolicy(int defaultBackoffTimeMs, int maxRetries, int backoffMultiplier) {
+        mDefaultBackoffTimeMs = defaultBackoffTimeMs;
+        mMaxRetries = maxRetries;
+        mBackoffMultiplier = backoffMultiplier;
+    }
+
+    @Override
+    public void backoff(VolleyError volleyError) throws VolleyError {
+        if (!hasAttemptRemaining()) {
+            throw volleyError;
+        }
+
+        if (volleyError instanceof NoConnectionError) {
+            updateBackoffTime();
+            return;
+        }
+
+        NetworkResponse networkResponse = volleyError.networkResponse;
+        if (networkResponse != null &&
+                (networkResponse.statusCode == 503  || networkResponse.statusCode == 504)) {
+            updateBackoffTime();
+            return;
+        }
+
+        throw volleyError;
+    }
+
+    private void updateBackoffTime() {
+        double multiplier = Math.pow(mBackoffMultiplier, mRetryCount);
+        mBackoffMs = (int) (mDefaultBackoffTimeMs * multiplier);
+        mRetryCount++;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
new file mode 100644
index 00000000..f04bcdf0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONArray;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A POST request for logging custom events to the Scribe service.
+ */
+public class ScribeRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse();
+    }
+
+    public interface ScribeRequestFactory extends RequestManager.RequestFactory {
+        public ScribeRequest createRequest(ScribeRequest.Listener listener);
+    }
+
+    @NonNull private final List<BaseEvent> mEvents;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequest.Listener mListener;
+
+    public ScribeRequest(@NonNull String url,
+            @NonNull List<BaseEvent> events,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull Listener listener) {
+        super(Method.POST, url, listener);
+
+        mEvents = events;
+        mEventSerializer = eventSerializer;
+        mListener = listener;
+
+        setShouldCache(false);
+
+        // This retry policy applies to socket timeouts only
+        setRetryPolicy(new DefaultRetryPolicy());
+    }
+
+    /**
+     * This is method runs on the background thread
+     */
+    @Override
+    protected Map<String,String> getParams() {
+        JSONArray jsonArray = mEventSerializer.serializeAsJson(mEvents);
+        Map<String,String> params = new HashMap<String, String>();
+        params.put("log", jsonArray.toString());
+        return params;
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    protected void deliverResponse(Void aVoid) {
+        mListener.onResponse();
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    public List<BaseEvent> getEvents() {
+        return mEvents;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
new file mode 100644
index 00000000..e1b3fc45
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
@@ -0,0 +1,59 @@
+package com.mopub.network;
+
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import static com.mopub.network.ScribeRequest.ScribeRequestFactory;
+
+/**
+ * Request manager to manage scribe requests. This class implements the specific Scribe
+ * request listener.
+ */
+public class ScribeRequestManager extends RequestManager<ScribeRequestFactory> implements ScribeRequest.Listener {
+
+    public ScribeRequestManager(final Looper looper) {
+        super(looper);
+    }
+
+    // RequestManager
+    @NonNull
+    @Override
+    Request<?> createRequest() {
+        return mRequestFactory.createRequest(this);
+    }
+
+    // ScribeRequest.Listener
+    @Override
+    public void onResponse() {
+        MoPubLog.d("Successfully scribed events");
+        // Get back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                clearRequest();
+            }
+        });
+    }
+
+    @Override
+    public void onErrorResponse(final VolleyError volleyError) {
+        // Post back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    mBackoffPolicy.backoff(volleyError);
+                    makeRequestInternal();
+                } catch (VolleyError e) {
+                    MoPubLog.d("Failed to Scribe events: " + volleyError);
+                    clearRequest();
+                }
+            }
+        });
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
new file mode 100644
index 00000000..4570a183
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
@@ -0,0 +1,129 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import java.util.Arrays;
+
+public class TrackingRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse(@NonNull String url);
+    }
+
+    @Nullable private final TrackingRequest.Listener mListener;
+
+    private TrackingRequest(@NonNull final String url, @Nullable final Listener listener) {
+        super(Method.GET, url, listener);
+        mListener = listener;
+        setShouldCache(false);
+        setRetryPolicy(new DefaultRetryPolicy(
+                DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
+                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
+                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(final NetworkResponse networkResponse) {
+        if (networkResponse.statusCode != 200) {
+            return Response.error(
+                    new MoPubNetworkError("Failed to log tracking request. Response code: "
+                            + networkResponse.statusCode + " for url: " + getUrl(),
+                            MoPubNetworkError.Reason.TRACKING_FAILURE));
+        }
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    public void deliverResponse(final Void aVoid) {
+        if (mListener != null) {
+            mListener.onResponse(getUrl());
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////
+    // Static helper methods that can be used as utilities:
+    //////////////////////////////////////////////////////////////
+
+    public static void makeTrackingHttpRequest(final Iterable<String> urls, final Context context) {
+        makeTrackingHttpRequest(urls, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(final Iterable<String> urls,
+            final Context context,
+            final BaseEvent.Name name) {
+        makeTrackingHttpRequest(urls, context, null, name);
+    }
+
+    public static void makeTrackingHttpRequest(final Iterable<String> urls,
+            final Context context,
+            @Nullable final Listener listener,
+            final BaseEvent.Name name) {
+        if (urls == null || context == null) {
+            return;
+        }
+
+        final RequestQueue requestQueue = Networking.getRequestQueue(context);
+        for (final String url : urls) {
+            if (TextUtils.isEmpty(url)) {
+                continue;
+            }
+
+            final TrackingRequest.Listener internalListener = new TrackingRequest.Listener() {
+                @Override
+                public void onResponse(@NonNull String url) {
+                    MoPubLog.d("Successfully hit tracking endpoint: " + url);
+                    if (listener != null) {
+                        listener.onResponse(url);
+                    }
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) {
+                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
+                    if (listener != null) {
+                        listener.onErrorResponse(volleyError);
+                    }
+                }
+            };
+            final TrackingRequest trackingRequest = new TrackingRequest(url, internalListener);
+            requestQueue.add(trackingRequest);
+        }
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context) {
+        makeTrackingHttpRequest(url, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context, @Nullable Listener listener) {
+        makeTrackingHttpRequest(url, context, listener, null);
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context, final BaseEvent.Name name) {
+        makeTrackingHttpRequest(url, context, null, name);
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context,
+            @Nullable Listener listener,
+            final BaseEvent.Name name) {
+        if (url != null) {
+            makeTrackingHttpRequest(Arrays.asList(url), context, listener, name);
+        }
+    }
+}
