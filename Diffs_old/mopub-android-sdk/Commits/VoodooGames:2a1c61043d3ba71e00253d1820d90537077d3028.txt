diff --git a/.gitignore b/.gitignore
index b4a84980..1a2d1ea8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,3 @@
-*.aar
 *.apk
 *.iml
 *.orig
diff --git a/.gitmodules b/.gitmodules
deleted file mode 100644
index e69de29b..00000000
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7d69bbf3..c57cbf89 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,92 @@
-## Version 3.2.2 (October 29, 2014)
+## Version 3.11.0 (August 20, 2015)
+
+- Updated Millennial Media support to 6.0.0, including updates to the `MillennialBanner.java` and `MillennialInterstitial.java` custom events.
+- Added mediation for Millennial Media native ads: `MillennialNative.java`, located in the native extras directory of the SDK (`/extras/src/com/mopub/nativeads`).
+
+## Version 3.10.0 (August 3, 2015)
+
+- VAST UI improvements and bug fixes.
+  - Pause trackers no longer fire when the ad is skipped.
+  - Improved retrieval of blurred video frame when there is no companion ad.
+- Added com.mopub:mopub-sdk AAR to [jCenter](https://bintray.com/mopub/mopub-android-sdk/mopub-android-sdk/view).
+- Bug Fixes:
+  - Fixed a NullPointerException in CacheService on devices with low storage space.
+  - Improved redirect loading for in-app browser.
+
+## Version 3.9.0 (July 1, 2015)
+
+- Added **VAST 3.0** standard support for video ads.
+- Improved **video player UX**.
+- Added **RecyclerView** support for native ads. See the [integration guide](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-with-Recycler-View).
+- Improved **deep link** handling.
+- Bug Fixes:
+  - MRAID video interstitials now play automatically when displayed on Jellybean MR1 and newer.
+  - MRAID relative assets are correctly rendered.
+  - MoPubLog no longer duplicates some messages.
+  - Fixed erroneous output of DeviceUtils.getScreenOrientationFromRotationAndOrientation().
+
+## Version 3.8.0 (June 1, 2015)
+
+- Updated Chartboost support to 5.3.0. This introduces a new shared class called ChartboostShared. If you are using Chartboost Custom Native Networks you will need to include this class in your build along with ChartboostInterstitial.
+
+## Version 3.7.0 (April 30, 2015)
+
+- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
+- Vungle support updated to SDK 3.3.3.
+- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
+  - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
+  - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
+
+- Added toasts to the MoPub Sample App for ad load failures due to no connection.
+- Fixed a bug in processing VAST progress trackers in a VAST wrapper tag.
+- Fixed a bug where ad refresh times could be incorrect when an ad request was not filled.
+
+- Updated the following dependencies:
+	- support-v4 AAR to 22.0.0
+	- support-annotations JAR to 22.0.0
+	- Android Maven Plugin to 4.2.0
+
+#### Version 3.6.1 (April 6, 2015)
+
+ - **Bug Fix** Fixed a compile error in FacebookBanner.java
+
+## Version 3.6.0 (April 3, 2015)
+
+ - **Facebook Update** Updated supported Facebook Audience Network version to 3.23.1
+ - **Bug fix** Fixed a bug where interstitials could leak memory; Fixes [issue #153](https://github.com/mopub/mopub-android-sdk/issues/153)
+ - **VAST Video** Updated the VAST video player to support Progress events.
+ - Updated **Volley** version to 1.1.0.
+
+## Version 3.5.0 (March 10, 2015)
+
+ - Dependency changes in Maven and Gradle. No new dependencies have been added, but your build script will need to change slightly to include JCenter. See our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project) for complete instructions.
+ - Security Improvement: removed the @JavascriptInterface annotation for WebViews.
+ - Fixed a bug where video playback would sometimes fail to stop when an ad was dismissed.
+ - Fixed a bug where it was not possible to disable ad refresh; Fixes [issue #148](https://github.com/mopub/mopub-android-sdk/issues/148)
+ - Fixed a null pointer exception in AdViewController; Fixes [issue #150](https://github.com/mopub/mopub-android-sdk/issues/150)
+
+## Version 3.4.0 (January 30, 2015)
+
+  - **Volley networking stack** MoPub for Android now uses Google's Volley library for HTTP requests. You will need to add our bundled Volley JAR (available at `mopub-sdk/libs/mopub-volley-1.0.0.jar`) as a compile-time dependency. See instructions in our [integration page](https://dev.twitter.com/mopub/android/getting-started).
+  - **Updated Vungle Support** Certified the `VungleInterstitial` custom event against Vungle SDK 3.2.2
+  - **VAST Video Bug Fixes**
+    - Fixed inability to parse VAST tags referencing URLs that contain 3rd party macros
+    - VAST videos no longer fire completion trackers upon video playback error
+  - Added support for the `mopubnativebrowser://` click-destination scheme for Native, MRAID, and VAST ads (it was already supported for HTML ads). Links of this type (e.g. `mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com`) will open the specified URL in the device's default browser, rather than in MoPub's in-app browser.
+
+## Version 3.3.0 (December 8, 2014)
+
+  - **MRAID 2.0 Support** - The MoPub SDK is now compliant with the MRAID 2.0 specification to enable rich media ads in banners and interstitial ad units. Learn more about MRAID from the [IAB](http://www.iab.net/MRAID#MRAID).
+  - **Location Polling Updates** - Changed the interaction between application- and device-provided location data: more recent location data is now always used (in the past, application-provided location data was always preferred).
+
+    As before, you may still disable MoPub SDK's location polling by calling `MoPub.setLocationAwareness(LocationAwareness.DISABLED)`.
+  - **Updated Chartboost SDK** Updated the `ChartboostInterstitial` custom event to support Chartboost SDK 5.0.4
+  - **Android Support Annotations** Introduced a dependency on android-support-annotations.jar to support code analysis of `@Nullable` and `@NonNull` annotations.
+
+#### Version 3.2.2 (October 29, 2014)
   - **Bug Fix** Fixes a bug in fetching the Google Advertising ID from Google Play Services.
 
-## Version 3.2.1 (October 21, 2014)
+#### Version 3.2.1 (October 21, 2014)
   - **Bug Fix** Fixes a bug in processing certain HTTP headers for Native Ads.
 
 ## Version 3.2.0 (October 17, 2014)
@@ -31,8 +116,7 @@
   - **Build target SDK is now API Level 19.** If you are building the MoPub SDK from source,
   modify your dependencies to reference Android 4.4.2, API Level 19. This does not affect the
   minimum device API level, which remains at API Level 9.
-  - **Source-level support for Gradle projects.** The SDK source now includes a build.gradle file
-   you can use to build source as part of your Gradle project.
+  - **Source-level support for Gradle projects.** The SDK source now includes a build.gradle file you can use to build source as part of your Gradle project.
   - **The SDK now uses Play Services 5.0.89**
   - **Bug fixes:**
     - Millennial Interstitial caching now properly handles request failures
@@ -75,6 +159,11 @@
     - Added support for companion banners (shown upon video completion)
   - Added Logcat warnings (and Toasts for debug builds) in cases where all necessary Activity permissions haven't been added to the `AndroidManifest`
 
+#### Version 2.0.1 (April 30, 2014)
+
+  - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
+  - Simplified click tracking logic for HTML ads
+
 ## Version 2.0 (April 22, 2014)
 
   - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
@@ -82,8 +171,8 @@
   - Added support for Google Play Services advertising identifier
   - Renamed the `com.mopub.mobileads.MraidBrowser` Activity to `com.mopub.common.MoPubBrowser`.
       - **Important Note:** This change requires a modification to the `AndroidManifest`. The updated set of requisite activity permissions are as follows:
-      
-      	```      	      	
+
+      	```
     <activity android:name="com.mopub.common.MoPubBrowser"
 				android:configChanges="keyboardHidden|orientation"/>
     <activity android:name="com.mopub.mobileads.MoPubActivity"
@@ -92,58 +181,53 @@
                 android:configChanges="keyboardHidden|orientation"/>
 	<activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
                 android:configChanges="keyboardHidden|orientation"/>
-		```  
+		```
   - Upgraded the bundled `android-support-v4` library to r19.1.
       - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
-      
-###### Version 2.0.1 (April 30, 2014)
 
-  - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
-  - Simplified click tracking logic for HTML ads
+#### Version 1.17.3.1 (March 24, 2014)
 
-## Version 1.17 (Nov 20, 2013)
+  - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
 
-  - Support for VAST 2.0 video playback via MoPub Marketplace
-    - Short videos (less than 15 seconds) autoplay and and are unskippable
-    - Longer videos autoplay and are skippable after 5 seconds
-    - **Note:** The video cache can use up to 100 MB of internal storage. For developers sensitive to storage constraints, this value may be changed in `VastVideoInterstitial.CACHE_MAX_SIZE`.
-  - Updated InMobi custom event support to 4.0.0
-  - Added custom events for video ad network mediation, which can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads/`)
-    - Added the `AdColonyInterstitial` custom event
-    - Added the `VungleInterstitial` custom event
-    - **Note:** Virtual currency callbacks (v4vc) are not supported for the above ad networks
-  - Enabled deeplinking via custom URIs in ad creatives
-  - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
-  - Removed previously-deprecated `HTML5AdView`
-  
-### Version 1.17.3 (March 19, 2014)
+## Version 1.17.3 (March 19, 2014)
 
   - Added safeguards to prevent two different `MoPubInterstitial` objects from listening in on one other's lifecycle callbacks
   - Disabled Javascript loading into `destroy()`ed `WebView`s; fixes [GitHub issue #62](https://github.com/mopub/mopub-android-sdk/issues/62)
   - Fixed an `IllegalArgumentException` resulting from VAST videos with malformed redirect tags
   - MRAID ads that utilize `mraid.open()` now correctly record a click event
   - Added missing `FLAG_ACTIVITY_NEW_TASK` to `VastVideoView`'s intent creation; fixes part of [GitHub issue #56](https://github.com/mopub/mopub-android-sdk/issues/56)
-  
-###### Version 1.17.3.1 (March 24, 2014)
 
-  - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
-  
-### Version 1.17.2 (February 20, 2014)
+## Version 1.17.2 (February 20, 2014)
 
   - Updated InMobi custom events to support InMobi SDK 4.0.3+ only
   - MRAID viewable property now correctly updates on viewability change
   - `MraidView` properly handles null schemes; fixes [GitHub issue #63](https://github.com/mopub/mopub-android-sdk/pull/63)
   - Internal disk LRU cache correctly hashes keys when checking for existing files
-  
-### Version 1.17.1 (January 23, 2014)
+
+#### Version 1.17.1.1 (February 5, 2014)
+  - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
+
+## Version 1.17.1 (January 23, 2014)
 
   - Added custom events for Google Play Services. `GooglePlayServicesBanner` and `GooglePlayServicesInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`)
   - Resolved issues with missing annotations on `addJavascriptInterface` when `targetSdkVersion` is set to API level 17 or above
   - Updated MoPub sample application to allow in-app text entry of ad unit IDs
-    
-###### Version 1.17.1.1 (February 5, 2014)
-  - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
-  
+
+## Version 1.17 (Nov 20, 2013)
+
+  - Support for VAST 2.0 video playback via MoPub Marketplace
+    - Short videos (less than 15 seconds) autoplay and and are unskippable
+    - Longer videos autoplay and are skippable after 5 seconds
+    - **Note:** The video cache can use up to 100 MB of internal storage. For developers sensitive to storage constraints, this value may be changed in `VastVideoInterstitial.CACHE_MAX_SIZE`.
+  - Updated InMobi custom event support to 4.0.0
+  - Added custom events for video ad network mediation, which can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads/`)
+    - Added the `AdColonyInterstitial` custom event
+    - Added the `VungleInterstitial` custom event
+    - **Note:** Virtual currency callbacks (v4vc) are not supported for the above ad networks
+  - Enabled deeplinking via custom URIs in ad creatives
+  - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
+  - Removed previously-deprecated `HTML5AdView`
+
 ## Version 1.16 (October 16, 2013)
 
   - Improved creative controls
@@ -158,50 +242,57 @@
   - Simplified internal construction and handling of `WebView`s by removing `WebViewPool` and its subclasses
   - Updated mraid.getVersion() to return 2.0
 
+#### Version 1.15.2.2 (September 20, 2013)
+  - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
+  - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
+  - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
+
+#### Version 1.15.2.1 (September 13, 2013)
+  - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
+
+## Version 1.15.2 (September 11, 2013)
+  - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`:
+  	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials
+  	- Use `MoPubView.setFacebookSupported(false);` for banners
+  	- Note: the `setFacebookSupported(false)` method call must come __before__ `loadAd()`
+  	- Note: facebook support is on by default
+  - Changed banner refresh default to be 60 seconds when requests timed out
+  - Fixed edge case in Millennial Media ad fetch failure when there is no inventory; fixes [GitHub issue #18](https://github.com/mopub/mopub-android-sdk/issues/18)
+  - Fixed a bug where redirect URLs were malformed, causing the native browser to not render ads
+  - Updated Millennial Media jar to 5.1.0
+  - Updated Greystripe custom event support to 2.3.0
+  - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device
+  - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity
+
+#### Version 1.15.1.1 (September 4, 2013)
+  - Made the SDK more resilient to unexpected Flash creatives
+
+## Version 1.15.1 (August 27, 2013)
+  - Updated documentation to remove the requirement for certain AndroidManifest permissions
+  - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
+
 ## Version 1.15 (August 21, 2013)
 
 Includes support for ads in the MRAID 2.0 format. MRAID 2.0 allows advertisers to create ads with rich media functionality, including adding calendar events, storing pictures and playing videos in the native video player. To learn more about MRAID 2.0, read our [help article](http://j.mp/16MKSci).
 
   - Added the following MRAID 2.0 features: `createCalendarEvent` (Android 4.0 and above), `playVideo`, `storePicture`, and `supports`
-  - Hardware Acceleration is now enabled by default for `MraidInterstitial`s on Android 4.0 and above  
-  - Ensured that Cursors in `FacebookKeywordProvider` are always closed properly; fixes [GitHub issue #8](https://github.com/mopub/mopub-android-sdk/issues/8)  
-  - Added tracking parameter to InMobi ad requests; fixes [GitHub issue #15](https://github.com/mopub/mopub-android-sdk/issues/15)  
-  - Banner WebViews are now removed from the view hierarchy before they are destroyed; fixes [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)  
+  - Hardware Acceleration is now enabled by default for `MraidInterstitial`s on Android 4.0 and above
+  - Ensured that Cursors in `FacebookKeywordProvider` are always closed properly; fixes [GitHub issue #8](https://github.com/mopub/mopub-android-sdk/issues/8)
+  - Added tracking parameter to InMobi ad requests; fixes [GitHub issue #15](https://github.com/mopub/mopub-android-sdk/issues/15)
+  - Banner WebViews are now removed from the view hierarchy before they are destroyed; fixes [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
 
-To correctly display ads that ask the user to save a picture (storePicture ads), you need to make the following change to AndroidManifest.xml:  
-* Add the`WRITE_EXTERNAL_STORAGE` permission. Note: **Adding the permission is optional**. If the permission is not added, we will not deliver any store picture ads to the users' devices. All other features will remain functional without the new permission. 
+To correctly display ads that ask the user to save a picture (storePicture ads), you need to make the following change to AndroidManifest.xml:
+* Add the`WRITE_EXTERNAL_STORAGE` permission. Note: **Adding the permission is optional**. If the permission is not added, we will not deliver any store picture ads to the users' devices. All other features will remain functional without the new permission.
 
-To allow users to play videos using the native video player:  
+To allow users to play videos using the native video player:
 * Declare activity `com.mopub.mobileads.MraidVideoPlayerActivity`. This activity is required to support playing videos in the native player and we strongly recommend adding it.
- 
-### Version 1.15.2 (September 11, 2013) 
-  - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`: 
-  	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials 
-  	- Use `MoPubView.setFacebookSupported(false);` for banners 
-  	- Note: the `setFacebookSupported(false)` method call must come __before__ `loadAd()` 
-  	- Note: facebook support is on by default 
-  - Changed banner refresh default to be 60 seconds when requests timed out  
-  - Fixed edge case in Millennial Media ad fetch failure when there is no inventory; fixes [GitHub issue #18](https://github.com/mopub/mopub-android-sdk/issues/18)
-  - Fixed a bug where redirect URLs were malformed, causing the native browser to not render ads    
-  - Updated Millennial Media jar to 5.1.0
-  - Updated Greystripe custom event support to 2.3.0
-  - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device 
-  - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity  
 
-###### Version 1.15.2.1 (September 13, 2013)
-  - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
-   
-###### Version 1.15.2.2 (September 20, 2013)
-  - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
-  - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
-  - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
- 
-### Version 1.15.1 (August 27, 2013)
-  - Updated documentation to remove the requirement for certain AndroidManifest permissions
-  - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
-  
-###### Version 1.15.1.1 (September 4, 2013)
-  - Made the SDK more resilient to unexpected Flash creatives
+## Version 1.14.1 (June 21, 2013)
+  - Wait until after loaded interstitials are shown to report an impression
+  - Remove phantom impression tracking from interstitials
+  - Remove extra whitespace from Millennial banner ads
+  - Added `onInterstitialClicked()` notification to `InterstitialAdListener`
+  - Provide default implementations for `BannerAdListener` and `InterstitialAdListener`
 
 ## Version 1.14 (May 28, 2013)
 
@@ -209,14 +300,20 @@ To allow users to play videos using the native video player:
   - Removed reference to TYPE_DUMMY in AdUrlGenerator because it is not available in earlier versions of Android; fixes [GitHub issue #3](https://github.com/mopub/mopub-android-sdk/issues/3)
   - Fixed NPE in AdUrlGenerator when WiFi is off and Airplane mode is on; fixes [GitHub issue #5](https://github.com/mopub/mopub-android-sdk/issues/5)
   - `MraidInterstitial`s now properly notify `InterstitialAdListener` when they are shown and dismissed
-  
-### Version 1.14.1 (June 21, 2013)
-  - Wait until after loaded interstitials are shown to report an impression
-  - Remove phantom impression tracking from interstitials
-  - Remove extra whitespace from Millennial banner ads
-  - Added `onInterstitialClicked()` notification to `InterstitialAdListener`
-  - Provide default implementations for `BannerAdListener` and `InterstitialAdListener`
-  
+
+## Version 1.13.1 (May 21, 2013)
+  - Updated Millennial support to Millennial Media SDK version 5.0.1
+
+#### Version 1.13.0.2 (May 17, 2013)
+
+  - Relaxed access modifiers for `CustomEventBanner` and `CustomEventInterstitial`
+
+#### Version 1.13.0.1 (May 15, 2013)
+
+  - Removed extraneous display call in `MillennialInterstitial` custom event
+  - Fixed potential NPE in `AdView`'s loadUrl()
+  - Deprecated `HTML5AdView` after fixing some compilation issues
+
 ## Version 1.13 (May 9, 2013)
   - Moved all Android code and documentation to its own repository: [mopub-android-sdk](https://github.com/mopub/mopub-android-sdk)
   - Updated Millennial support to Millennial Media SDK version 5.0
@@ -225,19 +322,6 @@ To allow users to play videos using the native video player:
   - Removed obsolete native network adapters
   - Added timeout for third-party networks (10 seconds for banners and 30 seconds for interstitials)
   - Added more data signals (application version, connection type, and location accuracy)
-  
-### Version 1.13.1 (May 21, 2013)
-  - Updated Millennial support to Millennial Media SDK version 5.0.1
-
-###### Version 1.13.0.1 (May 15, 2013)
-
-  - Removed extraneous display call in `MillennialInterstitial` custom event
-  - Fixed potential NPE in `AdView`'s loadUrl()
-  - Deprecated `HTML5AdView` after fixing some compilation issues
-  
-###### Version 1.13.0.2 (May 17, 2013)
-
-  - Relaxed access modifiers for `CustomEventBanner` and `CustomEventInterstitial`
 
 ## Version 1.12 (April 26, 2013)
   - Chartboost custom event now automatically parses server data
@@ -286,7 +370,7 @@ To allow users to play videos using the native video player:
 ## Version 1.5 (May 10, 2012)
   - Added support for Millennial Media SDK 4.5.5
   - Fixed ANR relating to synchronization in `LoadUrlTask`
-  - Fixed IllegalArgumentExceptions when creating HttpGet objects with malformed URLs 
+  - Fixed IllegalArgumentExceptions when creating HttpGet objects with malformed URLs
 
 ## Version 1.4 (March 28, 2012)
   - Fixed some NullPointerExceptions in the AdMob and Millennial native adapters
diff --git a/README.md b/README.md
index 64b44d52..db933386 100644
--- a/README.md
+++ b/README.md
@@ -4,34 +4,79 @@ Thanks for taking a look at MoPub! We take pride in having an easy-to-use, flexi
 
 Sign up for an account at [http://app.mopub.com/](http://app.mopub.com/).
 
-Help is available on the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+## Need Help?
 
-## Download
-
-The MoPub SDK is distributed as source code that you can include in your application.  MoPub provides two prepackaged archives of source code:
-
-- **[MoPub Android Full SDK.zip](http://bit.ly/YUdU9v)**
-
-  Includes everything you need to serve HTML and MRAID MoPub advertisiments *and* built-in support for Millennial Media third party ad network - [Millennial Media](http://www.millennialmedia.com/) - including the required third party binaries.
+You can find integration documentation on our [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started) and additional help documentation on our [developer help site](http://dev.twitter.com/mopub).
 
-- **[MoPub Android Base SDK.zip](http://bit.ly/YUdWhH)**
+To file an issue with our team visit the [MoPub Forum](https://twittercommunity.com/c/fabric/mopub) or email [support@mopub.com](mailto:support@mopub.com).
 
-  Includes everything you need to serve HTML and MRAID MoPub advertisements.  No third party ad networks are included.
+**Please Note: We no longer accept GitHub Issues.**
 
-## Integrate
-
-Integration instructions are available on the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+## Download
 
+The MoPub SDK is available via:
+
+1. **jCenter AAR**
+    
+    [ ![Download](https://api.bintray.com/packages/mopub/mopub-android-sdk/mopub-android-sdk/images/download.svg)](https://bintray.com/mopub/mopub-android-sdk/mopub-android-sdk/_latestVersion)  
+    The MoPub SDK is available as an AAR via jCenter; to use it, add the following to your `build.gradle`.
+    
+    ```
+    repositories {
+        jcenter()
+    }
+
+    dependencies {
+        compile('com.mopub:mopub-sdk:3.11.0@aar') {
+            transitive = true
+        }
+    }
+    ```
+
+    **To continue integration using the mopub-sdk AAR, please see the [Getting Started guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#updating-your-android-manifest).**
+
+2. **Zipped Source**
+
+    The MoPub SDK is also distributed as zipped source code that you can include in your application.  MoPub provides two prepackaged archives of source code:
+
+    **[MoPub Android Full SDK.zip](http://bit.ly/YUdU9v)**  
+    _Includes everything you need to serve MoPub ads *and* built-in support for Millennial Media third party ad network - [Millennial Media](http://www.millennialmedia.com/) - including the required third party binaries._
+    
+    _**Note:** Millennial Media has updated their minimum supported version of Android to 4.1 (API level 16+). The MoPub Android Full SDK manifest and build.gradle files have been updated accordingly._
+    
+    _**Note:** Millennial Media has deprecated support for Ant/Eclipse; migrating users should use the MoPub Android base SDK and follow [Millennial's Ant/Eclipse Integration Guide](http://docs.millennialmedia.com/android-ad-sdk/ant-eclipse-integration-guide.html)._
+    
+    **[MoPub Android Base SDK.zip](http://bit.ly/YUdWhH)**  
+    _Includes everything you need to serve MoPub ads.  No third party ad networks are included._
+    
+    **For additional integration instructions, please see the [Getting Started guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#requirements-and-dependencies).**
+
+3. **Cloned GitHub repository**
+    
+    Alternatively, you can obtain the MoPub SDK source by cloning the git repository:
+    
+    `git clone git://github.com/mopub/mopub-android-sdk.git`
+    
+    **For additional integration instructions, please see the [Getting Started guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#requirements-and-dependencies).**
 
 ## New in this Version
 
-Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
+Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the lastest release..
 
-  - **Bug Fixes**
+- Updated Millennial Media support to 6.0.0, including updates to the `MillennialBanner.java` and `MillennialInterstitial.java` custom events.
+- Added mediation for Millennial Media native ads: `MillennialNative.java`, located in the native extras directory of the SDK (`/extras/src/com/mopub/nativeads`).
 
 ## Requirements
 
-Android 2.3.1 (API Version 9) and up
+- Android 2.3.1 (API Version 9) and up
+- android-support-v4.jar, r22 (**Updated in 3.7.0**)
+- android-support-annotations.jar, r22 (**Updated in 3.7.0**)
+- android-support-v7-recyclerview.jar, r22 (**Updated in 3.9.0**)
+- MoPub Volley Library (mopub-volley-1.1.0.jar - available on JCenter) (**Updated in 3.6.0**)
+- **Recommended** Google Play Services 7.0.0
+
+## Upgrading from 3.2.0 and Prior
+In 3.3.0 a dependency on android-support-annotations.jar was added. If you are using Maven or Gradle to include the MoPub SDK, this dependency is included in the build scripts. For instructions on adding dependencies for Eclipse projects, see our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project)
 
 ## License
 
diff --git a/build.gradle b/build.gradle
index a61d8f91..c62b6341 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,14 +1,14 @@
 buildscript {
-    repositories {   
+    repositories {
         mavenCentral()
+        jcenter()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.12.1+'
-        classpath 'org.robolectric:robolectric-gradle-plugin:0.12.+'
+        classpath 'com.android.tools.build:gradle:1.2.3'
     }
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '1.12'
+    gradleVersion = '2.5'
 }
diff --git a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
index 6b542709..6e42be9c 100644
--- a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
+++ b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
@@ -15,8 +15,6 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-
 /*
  * Tested with AdColony SDK 2.0.3.
  */
@@ -36,10 +34,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String CLIENT_OPTIONS_KEY = "clientOptions";
-    private static final String APP_ID_KEY = "appId";
-    private static final String ALL_ZONE_IDS_KEY = "allZoneIds";
-    private static final String ZONE_ID_KEY = "zoneId";
+    public static final String CLIENT_OPTIONS_KEY = "clientOptions";
+    public static final String APP_ID_KEY = "appId";
+    public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
+    public static final String ZONE_ID_KEY = "zoneId";
 
     private static boolean isAdColonyConfigured = false;
 
@@ -50,7 +48,7 @@
     private boolean mIsLoading;
 
     public AdColonyInterstitial() {
-        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
+        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
         mHandler = new Handler();
     }
 
@@ -60,7 +58,7 @@ protected void loadInterstitial(Context context,
                                     Map<String, Object> localExtras,
                                     Map<String, String> serverExtras) {
         if (!(context instanceof Activity)) {
-            customEventInterstitialListener.onInterstitialFailed(ADAPTER_CONFIGURATION_ERROR);
+            customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
diff --git a/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
new file mode 100644
index 00000000..4d9baac4
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
@@ -0,0 +1,333 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.jirbo.adcolony.AdColony;
+import com.jirbo.adcolony.AdColonyAd;
+import com.jirbo.adcolony.AdColonyAdListener;
+import com.jirbo.adcolony.AdColonyV4VCAd;
+import com.jirbo.adcolony.AdColonyV4VCListener;
+import com.jirbo.adcolony.AdColonyV4VCReward;
+import com.mopub.common.BaseLifecycleListener;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
+
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A custom event for showing AdColony rewarded videos.
+ *
+ * Certified with AdColony 2.0.3
+ */
+public class AdColonyRewardedVideo extends CustomEventRewardedVideo {
+    /*
+     * We recommend passing the AdColony client options, app ID, all zone IDs, and current zone ID
+     * in the serverExtras Map by specifying Custom Event Data in MoPub's web interface.
+     *
+     * Please see AdColony's documentation for more information:
+     * https://github.com/AdColony/AdColony-Android-SDK/wiki/API-Details#configure-activity-activity-string-client_options-string-app_id-string-zone_ids-
+     */
+    private static final String DEFAULT_CLIENT_OPTIONS = "version=YOUR_APP_VERSION_HERE,store:google";
+    private static final String DEFAULT_APP_ID = "YOUR_AD_COLONY_APP_ID_HERE";
+    private static final String[] DEFAULT_ALL_ZONE_IDS = {"ZONE_ID_1", "ZONE_ID_2", "..."};
+    private static final String DEFAULT_ZONE_ID = "YOUR_CURRENT_ZONE_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String CLIENT_OPTIONS_KEY = "clientOptions";
+    public static final String APP_ID_KEY = "appId";
+    public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
+    public static final String ZONE_ID_KEY = "zoneId";
+
+    private static boolean sInitialized = false;
+    private static LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
+        @Override
+        public void onPause(@NonNull final Activity activity) {
+            super.onPause(activity);
+            AdColony.pause();
+        }
+
+        @Override
+        public void onResume(@NonNull final Activity activity) {
+            super.onResume(activity);
+            AdColony.resume(activity);
+        }
+    };
+    private static AdColonyListener sAdColonyListener = new AdColonyListener();
+    private static WeakHashMap<AdColonyAd, String> sAdToZoneIdMap = new WeakHashMap<AdColonyAd, String>();
+
+    private AdColonyV4VCAd mAd;
+    private String mZoneId;
+    @Nullable private String mAdUnitId;
+    private boolean mIsLoading = false;
+
+    // For waiting and notifying the SDK:
+    private final Handler mHandler;
+    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
+    private ScheduledFuture<?> mFuture;
+
+    public AdColonyRewardedVideo() {
+        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
+        mHandler = new Handler();
+    }
+
+    @Nullable
+    @Override
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return sAdColonyListener;
+    }
+
+    @Nullable
+    @Override
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @NonNull
+    @Override
+    public String getAdNetworkId() {
+        return mZoneId;
+    }
+
+    @Override
+    protected void onInvalidate() {
+        mScheduledThreadPoolExecutor.shutdownNow();
+    }
+
+    @Override
+    public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+        synchronized (AdColonyRewardedVideo.class) {
+            if (sInitialized) {
+                return false;
+            }
+
+            String adColonyClientOptions = DEFAULT_CLIENT_OPTIONS;
+            String adColonyAppId = DEFAULT_APP_ID;
+            String[] adColonyAllZoneIds = DEFAULT_ALL_ZONE_IDS;
+
+            // Set up serverExtras
+            if (extrasAreValid(serverExtras)) {
+                adColonyClientOptions = serverExtras.get(CLIENT_OPTIONS_KEY);
+                adColonyAppId = serverExtras.get(APP_ID_KEY);
+                adColonyAllZoneIds = extractAllZoneIds(serverExtras);
+            }
+
+            setUpGlobalSettings();
+            AdColony.configure(launcherActivity, adColonyClientOptions, adColonyAppId, adColonyAllZoneIds);
+            AdColony.addV4VCListener(sAdColonyListener);
+            sInitialized = true;
+            return true;
+        }
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull final Activity activity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+
+        mZoneId = DEFAULT_ZONE_ID;
+        if (extrasAreValid(serverExtras)) {
+            mZoneId = serverExtras.get(ZONE_ID_KEY);
+        }
+        Object adUnitObject = localExtras.get(DataKeys.AD_UNIT_ID_KEY);
+        if (adUnitObject != null && adUnitObject instanceof String) {
+            mAdUnitId = (String) adUnitObject;
+        }
+
+        mAd = new AdColonyV4VCAd(mZoneId).withListener(sAdColonyListener);
+        sAdToZoneIdMap.put(mAd, mZoneId);
+        scheduleOnVideoReady();
+    }
+
+    @Override
+    public boolean hasVideoAvailable() {
+        return mAd != null && mAd.isReady() && mAd.getAvailableViews() != 0;
+    }
+
+    @Override
+    public void showVideo() {
+        if (this.hasVideoAvailable()) {
+            boolean withConfirmationDialog = getConfirmationDialogFromSettings();
+            boolean withResultsDialog = getResultsDialogFromSettings();
+            mAd.withConfirmationDialog(withConfirmationDialog).withResultsDialog(withResultsDialog).show();
+        } else {
+            MoPubRewardedVideoManager.onRewardedVideoPlaybackError(AdColonyRewardedVideo.class, mZoneId, MoPubErrorCode.VIDEO_PLAYBACK_ERROR);
+        }
+    }
+
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(CLIENT_OPTIONS_KEY)
+                && extras.containsKey(APP_ID_KEY)
+                && extras.containsKey(ALL_ZONE_IDS_KEY)
+                && extras.containsKey(ZONE_ID_KEY);
+    }
+
+    private String[] extractAllZoneIds(Map<String, String> serverExtras) {
+        String[] result = Json.jsonArrayToStringArray(serverExtras.get(ALL_ZONE_IDS_KEY));
+
+        // AdColony requires at least one valid String in the allZoneIds array.
+        if (result.length == 0) {
+            result = new String[]{""};
+        }
+
+        return result;
+    }
+
+    private void setUpGlobalSettings() {
+        final AdColonyGlobalMediationSettings globalMediationSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(AdColonyGlobalMediationSettings.class);
+        if (globalMediationSettings != null) {
+            if (globalMediationSettings.getCustomId() != null) {
+                AdColony.setCustomID(globalMediationSettings.getCustomId());
+            }
+            if (globalMediationSettings.getDeviceId() != null) {
+                AdColony.setDeviceID(globalMediationSettings.getDeviceId());
+            }
+        }
+    }
+
+    private boolean getConfirmationDialogFromSettings() {
+        final AdColonyInstanceMediationSettings settings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(AdColonyInstanceMediationSettings.class, mAdUnitId);
+        return settings != null && settings.withConfirmationDialog();
+    }
+
+    private boolean getResultsDialogFromSettings() {
+        final AdColonyInstanceMediationSettings settings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(AdColonyInstanceMediationSettings.class, mAdUnitId);
+        return settings != null && settings.withResultsDialog();
+    }
+
+    private void scheduleOnVideoReady() {
+        Runnable runnable = new Runnable() {
+            @Override
+            public void run() {
+                if (mAd.isReady()) {
+                    mIsLoading = false;
+                    mScheduledThreadPoolExecutor.shutdownNow();
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (mAd.getAvailableViews() > 0) {
+                                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(
+                                        AdColonyRewardedVideo.class,
+                                        mZoneId);
+                            } else {
+                                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                                        AdColonyRewardedVideo.class,
+                                        mZoneId,
+                                        MoPubErrorCode.NETWORK_NO_FILL);
+                            }
+                        }
+                    });
+                }
+            }
+        };
+
+        if (!mIsLoading) {
+            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
+            mIsLoading = true;
+        }
+    }
+
+    private static class AdColonyListener implements AdColonyAdListener,
+            AdColonyV4VCListener, CustomEventRewardedVideoListener {
+
+        @Override
+        public void onAdColonyAdAttemptFinished(final AdColonyAd adColonyAd) {
+            String zoneId = sAdToZoneIdMap.get(adColonyAd);
+            MoPubRewardedVideoManager.onRewardedVideoClosed(AdColonyRewardedVideo.class, zoneId);
+            if (adColonyAd.notShown()) {
+                if (adColonyAd.canceled() || adColonyAd.skipped()) {
+                    MoPubLog.d("User canceled ad playback");
+                    return;
+                }
+
+                MoPubErrorCode reason = MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+                if (adColonyAd.noFill()) {
+                    reason = MoPubErrorCode.NETWORK_NO_FILL;
+                }
+
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                        AdColonyRewardedVideo.class,
+                        zoneId,
+                        reason);
+            }
+        }
+
+        @Override
+        public void onAdColonyAdStarted(final com.jirbo.adcolony.AdColonyAd adColonyAd) {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(
+                    AdColonyRewardedVideo.class,
+                    sAdToZoneIdMap.get(adColonyAd));
+        }
+
+        @Override
+        public void onAdColonyV4VCReward(final AdColonyV4VCReward adColonyV4VCReward) {
+            MoPubReward reward;
+            if (adColonyV4VCReward.success()) {
+                reward = MoPubReward.success(adColonyV4VCReward.name(), adColonyV4VCReward.amount());
+            } else {
+                reward = MoPubReward.failure();
+            }
+            MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                    AdColonyRewardedVideo.class,
+                    null, // Can't deduce the zoneId from this object.
+                    reward);
+        }
+    }
+
+    public static final class AdColonyGlobalMediationSettings implements MediationSettings {
+
+        @Nullable private final String mCustomId;
+        @Nullable private final String mDeviceId;
+
+        public AdColonyGlobalMediationSettings(@Nullable String customId, @Nullable String deviceId) {
+            mCustomId = customId;
+            mDeviceId = deviceId;
+        }
+
+        @Nullable
+        public String getCustomId() {
+            return mCustomId;
+        }
+
+        @Nullable
+        public String getDeviceId() {
+            return mDeviceId;
+        }
+    }
+
+    public static final class AdColonyInstanceMediationSettings implements MediationSettings {
+        private final boolean mWithConfirmationDialog;
+        private final boolean mWithResultsDialog;
+
+        public AdColonyInstanceMediationSettings(
+                boolean withConfirmationDialog, boolean withResultsDialog) {
+            mWithConfirmationDialog = withConfirmationDialog;
+            mWithResultsDialog = withResultsDialog;
+        }
+
+        public boolean withConfirmationDialog() {
+            return mWithConfirmationDialog;
+        }
+
+        public boolean withResultsDialog() {
+            return mWithResultsDialog;
+        }
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
index 3127790d..2862ebcf 100644
--- a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
+++ b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
@@ -2,26 +2,24 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 import android.util.Log;
+
 import com.chartboost.sdk.Chartboost;
-import com.chartboost.sdk.ChartboostDelegate;
+import com.mopub.common.Preconditions;
 
-import java.util.*;
+import java.util.Map;
 
-/*
- * Tested with Chartboost SDK 3.1.5.
+/**
+ * A custom event for showing Chartboost interstitial ads.
+ *
+ * Certified with Chartboost 5.3.0
  */
 class ChartboostInterstitial extends CustomEventInterstitial {
-    /*
-     * These keys are intended for MoPub internal use. Do not modify.
-     */
-    public static final String APP_ID_KEY = "appId";
-    public static final String APP_SIGNATURE_KEY = "appSignature";
-    public static final String LOCATION_KEY = "location";
-    public static final String LOCATION_DEFAULT = "Default";
-    private String appId;
-    private String appSignature;
-    private String location;
+
+    @NonNull
+    private String mLocation = ChartboostShared.LOCATION_DEFAULT;
 
     /*
      * Note: Chartboost recommends implementing their specific Activity lifecycle callbacks in your
@@ -29,208 +27,65 @@
      * documentation for more information.
      */
 
-    ChartboostInterstitial() {
-        location = LOCATION_DEFAULT;
-    }
-
-    static SingletonChartboostDelegate getDelegate() {
-        return SingletonChartboostDelegate.instance;
-    }
-
-    @Deprecated // for test only
-    public static void resetDelegate() {
-        SingletonChartboostDelegate.instance = new SingletonChartboostDelegate();
-    }
-
     /*
      * Abstract methods from CustomEventInterstitial
      */
     @Override
-    protected void loadInterstitial(Context context, CustomEventInterstitialListener interstitialListener,
-                                    Map<String, Object> localExtras, Map<String, String> serverExtras) {
+    protected void loadInterstitial(@NonNull Context context,
+            @NonNull CustomEventInterstitialListener interstitialListener,
+            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(interstitialListener);
+        Preconditions.checkNotNull(localExtras);
+        Preconditions.checkNotNull(serverExtras);
+
         if (!(context instanceof Activity)) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        Activity activity = (Activity) context;
-        Chartboost chartboost = Chartboost.sharedChartboost();
+        if (serverExtras.containsKey(ChartboostShared.LOCATION_KEY)) {
+            String location = serverExtras.get(ChartboostShared.LOCATION_KEY);
+            mLocation = TextUtils.isEmpty(location) ? mLocation : location;
+        }
 
-        if (extrasAreValid(serverExtras)) {
-            setAppId(serverExtras.get(APP_ID_KEY));
-            setAppSignature(serverExtras.get(APP_SIGNATURE_KEY));
-            setLocation(
-                    serverExtras.containsKey(LOCATION_KEY)
-                            ? serverExtras.get(LOCATION_KEY)
-                            : LOCATION_DEFAULT);
-        } else {
+        // If there's already a listener for this location, then another instance of
+        // CustomEventInterstitial is still active and we should fail.
+        if (ChartboostShared.getDelegate().hasInterstitialLocation(mLocation) &&
+                ChartboostShared.getDelegate().getInterstitialListener(mLocation) != interstitialListener) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        if (getDelegate().hasLocation(location) &&
-                getDelegate().getListener(location) != interstitialListener) {
+        Activity activity = (Activity) context;
+        try {
+            ChartboostShared.initializeSdk(activity, serverExtras);
+            ChartboostShared.getDelegate().registerInterstitialListener(mLocation, interstitialListener);
+        } catch (NullPointerException e) {
+            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        } catch (IllegalStateException e) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        getDelegate().registerListener(location, interstitialListener);
-        chartboost.onCreate(activity, appId, appSignature, getDelegate());
-        chartboost.onStart(activity);
-
-        chartboost.cacheInterstitial(location);
+        Chartboost.onCreate(activity);
+        Chartboost.onStart(activity);
+        if (Chartboost.hasInterstitial(mLocation)) {
+            ChartboostShared.getDelegate().didCacheInterstitial(mLocation);
+        } else {
+            Chartboost.cacheInterstitial(mLocation);
+        }
     }
 
     @Override
     protected void showInterstitial() {
         Log.d("MoPub", "Showing Chartboost interstitial ad.");
-        Chartboost.sharedChartboost().showInterstitial(location);
+        Chartboost.showInterstitial(mLocation);
     }
 
     @Override
     protected void onInvalidate() {
-        getDelegate().unregisterListener(location);
-    }
-
-    private void setAppId(String appId) {
-        this.appId = appId;
-    }
-
-    private void setAppSignature(String appSignature) {
-        this.appSignature = appSignature;
-    }
-
-    private void setLocation(String location) {
-        this.location = location;
-    }
-
-    private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(APP_ID_KEY) && serverExtras.containsKey(APP_SIGNATURE_KEY);
-    }
-
-    private static class SingletonChartboostDelegate implements ChartboostDelegate {
-        private static final CustomEventInterstitialListener NULL_LISTENER = new CustomEventInterstitialListener() {
-            @Override public void onInterstitialLoaded() { }
-            @Override public void onInterstitialFailed(MoPubErrorCode errorCode) { }
-            @Override public void onInterstitialShown() { }
-            @Override public void onInterstitialClicked() { }
-            @Override public void onLeaveApplication() { }
-            @Override public void onInterstitialDismissed() { }
-        };
-        static SingletonChartboostDelegate instance = new SingletonChartboostDelegate();
-        private Map<String, CustomEventInterstitialListener> listenerForLocation =
-                new HashMap<String, CustomEventInterstitialListener>();
-
-        public void registerListener(String location, CustomEventInterstitialListener interstitialListener) {
-            listenerForLocation.put(location, interstitialListener);
-        }
-
-        public void unregisterListener(String location) {
-            listenerForLocation.remove(location);
-        }
-
-        public boolean hasLocation(String location) {
-            return listenerForLocation.containsKey(location);
-        }
-
-        /*
-         * Interstitial delegate methods
-         */
-        @Override
-        public boolean shouldDisplayInterstitial(String location) {
-            return true;
-        }
-
-        @Override
-        public boolean shouldRequestInterstitial(String location) {
-            return true;
-        }
-
-        @Override
-        public boolean shouldRequestInterstitialsInFirstSession() {
-            return true;
-        }
-
-        @Override
-        public void didCacheInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial loaded successfully.");
-            getListener(location).onInterstitialLoaded();
-        }
-
-        @Override
-        public void didFailToLoadInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad failed to load.");
-            getListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
-        }
-
-        @Override
-        public void didDismissInterstitial(String location) {
-            // Note that this method is fired before didCloseInterstitial and didClickInterstitial.
-            Log.d("MoPub", "Chartboost interstitial ad dismissed.");
-            getListener(location).onInterstitialDismissed();
-        }
-
-        @Override
-        public void didCloseInterstitial(String location) {
-        }
-
-        @Override
-        public void didClickInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad clicked.");
-            getListener(location).onInterstitialClicked();
-        }
-
-        @Override
-        public void didShowInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad shown.");
-            getListener(location).onInterstitialShown();
-        }
-
-        /*
-         * More Apps delegate methods
-         */
-        @Override
-        public boolean shouldDisplayLoadingViewForMoreApps() {
-            return false;
-        }
-
-        @Override
-        public boolean shouldRequestMoreApps() {
-            return false;
-        }
-
-        @Override
-        public boolean shouldDisplayMoreApps() {
-            return false;
-        }
-
-        @Override
-        public void didFailToLoadMoreApps() {
-        }
-
-        @Override
-        public void didCacheMoreApps() {
-        }
-
-        @Override
-        public void didDismissMoreApps() {
-        }
-
-        @Override
-        public void didCloseMoreApps() {
-        }
-
-        @Override
-        public void didClickMoreApps() {
-        }
-
-        @Override
-        public void didShowMoreApps() {
-        }
-
-        CustomEventInterstitialListener getListener(String location) {
-            CustomEventInterstitialListener listener = listenerForLocation.get(location);
-            return listener != null ? listener : NULL_LISTENER;
-        }
+        ChartboostShared.getDelegate().unregisterInterstitialListener(mLocation);
     }
 }
diff --git a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
new file mode 100644
index 00000000..619271b8
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
@@ -0,0 +1,176 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import com.chartboost.sdk.Chartboost;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ * A custom event for showing Chartboost rewarded videos.
+ *
+ * Certified with Chartboost 5.3.0
+ */
+public class ChartboostRewardedVideo extends CustomEventRewardedVideo {
+    @NonNull private static final LifecycleListener sLifecycleListener =
+            new ChartboostLifecycleListener();
+
+    @NonNull private String mLocation = ChartboostShared.LOCATION_DEFAULT;
+    @NonNull private final Handler mHandler;
+
+    public ChartboostRewardedVideo() {
+        mHandler = new Handler();
+    }
+
+    @Override
+    @NonNull
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return ChartboostShared.getDelegate();
+    }
+
+    @Override
+    @NonNull
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @Override
+    @NonNull
+    public String getAdNetworkId() {
+        return mLocation;
+    }
+
+    @Override
+    public boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) throws Exception {
+        // We need to attempt to reinitialize Chartboost on each request, in case an interstitial has been
+        // loaded and used since then.
+        ChartboostShared.initializeSdk(launcherActivity, serverExtras);  // throws IllegalStateException
+
+        // Always return true so that the lifecycle listener is registered even if an interstitial
+        // did the initialization.
+        return true;
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras)
+            throws Exception {
+
+        if (serverExtras.containsKey(ChartboostShared.LOCATION_KEY)) {
+            String location = serverExtras.get(ChartboostShared.LOCATION_KEY);
+            mLocation = TextUtils.isEmpty(location) ? mLocation : location;
+        }
+
+        ChartboostShared.getDelegate().registerRewardedVideoLocation(mLocation);
+        setUpMediationSettingsForRequest((String) localExtras.get(DataKeys.AD_UNIT_ID_KEY));
+
+        // We do this to ensure that the custom event manager has a chance to get the listener
+        // and ad unit ID before any delegate callbacks are made.
+        mHandler.post(new Runnable() {
+            public void run() {
+                if (Chartboost.hasRewardedVideo(mLocation)) {
+                    ChartboostShared.getDelegate().didCacheRewardedVideo(mLocation);
+                } else {
+                    Chartboost.cacheRewardedVideo(mLocation);
+                }
+            }
+        });
+    }
+
+    private void setUpMediationSettingsForRequest(String moPubId) {
+        final ChartboostMediationSettings globalSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(ChartboostMediationSettings.class);
+        final ChartboostMediationSettings instanceSettings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(ChartboostMediationSettings.class, moPubId);
+
+        // Instance settings override global settings.
+        if (instanceSettings != null) {
+            Chartboost.setCustomId(instanceSettings.getCustomId());
+        } else if (globalSettings != null) {
+            Chartboost.setCustomId(globalSettings.getCustomId());
+        }
+    }
+
+    @Override
+    public boolean hasVideoAvailable() {
+        return Chartboost.hasRewardedVideo(mLocation);
+    }
+
+    @Override
+    public void showVideo() {
+        if (hasVideoAvailable()) {
+            Chartboost.showRewardedVideo(mLocation);
+        } else {
+            MoPubLog.d("Attempted to show Chartboost rewarded video before it was available.");
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        // This prevents sending didCache or didFailToCache callbacks.
+        ChartboostShared.getDelegate().unregisterRewardedVideoLocation(mLocation);
+    }
+
+    private static final class ChartboostLifecycleListener implements LifecycleListener {
+        @Override
+        public void onCreate(@NonNull Activity activity) {
+            Chartboost.onCreate(activity);
+        }
+
+        @Override
+        public void onStart(@NonNull Activity activity) {
+            Chartboost.onStart(activity);
+        }
+
+        @Override
+        public void onPause(@NonNull Activity activity) {
+            Chartboost.onPause(activity);
+        }
+
+        @Override
+        public void onResume(@NonNull Activity activity) {
+            Chartboost.onResume(activity);
+        }
+
+        @Override
+        public void onRestart(@NonNull Activity activity) {
+        }
+
+        @Override
+        public void onStop(@NonNull Activity activity) {
+            Chartboost.onStop(activity);
+        }
+
+        @Override
+        public void onDestroy(@NonNull Activity activity) {
+            Chartboost.onDestroy(activity);
+        }
+
+        @Override
+        public void onBackPressed(@NonNull Activity activity) {
+            Chartboost.onBackPressed();
+        }
+    }
+
+    public static final class ChartboostMediationSettings implements MediationSettings {
+        @NonNull private final String mCustomId;
+
+        public ChartboostMediationSettings(@NonNull final String customId) {
+            mCustomId = customId;
+        }
+
+        @NonNull
+        public String getCustomId() {
+            return mCustomId;
+        }
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/ChartboostShared.java b/extras/src/com/mopub/mobileads/ChartboostShared.java
new file mode 100644
index 00000000..e146f15a
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/ChartboostShared.java
@@ -0,0 +1,296 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.chartboost.sdk.Chartboost;
+import com.chartboost.sdk.ChartboostDelegate;
+import com.chartboost.sdk.Model.CBError;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+import static com.mopub.mobileads.MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+
+/**
+ * Shared infrastructure for initializing the Chartboost SDK when mediated by MoPub
+ *
+ * Certified with Chartboost 5.3.0
+ */
+public class ChartboostShared {
+    private static volatile ChartboostSingletonDelegate sDelegate = new ChartboostSingletonDelegate();
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "appId";
+    public static final String APP_SIGNATURE_KEY = "appSignature";
+    public static final String LOCATION_KEY = "location";
+    public static final String LOCATION_DEFAULT = "Default";
+
+    @Nullable private static String mAppId;
+    @Nullable private static String mAppSignature;
+
+    /**
+     * Initialize the Chartboost SDK for the provided application id and app signature.
+     */
+    public static synchronized boolean initializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, String> serverExtras) {
+        Preconditions.checkNotNull(launcherActivity);
+        Preconditions.checkNotNull(serverExtras);
+
+        // Validate Chartboost args
+        if (!serverExtras.containsKey(APP_ID_KEY)) {
+            throw new IllegalStateException("Chartboost rewarded video initialization" +
+                    " failed due to missing application ID.");
+        }
+
+        if (!serverExtras.containsKey(APP_SIGNATURE_KEY)) {
+            throw new IllegalStateException("Chartboost rewarded video initialization" +
+                    " failed due to missing application signature.");
+        }
+
+        final String appId = serverExtras.get(APP_ID_KEY);
+        final String appSignature = serverExtras.get(APP_SIGNATURE_KEY);
+
+        if (appId.equals(mAppId) && appSignature.equals(mAppSignature)) {
+            // We don't need to reinitialize.
+            return false;
+        }
+
+        mAppId = appId;
+        mAppSignature = appSignature;
+
+        // Perform all the common SDK initialization steps including startAppWithId
+        Chartboost.startWithAppId(launcherActivity, mAppId, mAppSignature);
+        Chartboost.setImpressionsUseActivities(false);
+        Chartboost.setFramework(Chartboost.CBFramework.CBFrameworkMoPub);
+        Chartboost.setDelegate(sDelegate);
+        Chartboost.setShouldRequestInterstitialsInFirstSession(true);
+        Chartboost.setAutoCacheAds(false);
+        Chartboost.setShouldDisplayLoadingViewForMoreApps(false);
+
+        // Callers of this method need to call onCreate & onStart themselves.
+        return true;
+    }
+
+    @NonNull
+    public static ChartboostSingletonDelegate getDelegate() {
+        return sDelegate;
+    }
+
+    /**
+     * A {@link ChartboostDelegate} that can forward events for Chartboost interstitials
+     * and rewarded videos to the appropriate listener based on the Chartboost location used.
+     */
+    public static class ChartboostSingletonDelegate extends ChartboostDelegate
+            implements CustomEventRewardedVideo.CustomEventRewardedVideoListener {
+        private static final CustomEventInterstitialListener NULL_LISTENER =
+                new CustomEventInterstitialListener() {
+                    @Override
+                    public void onInterstitialLoaded() { }
+
+                    @Override
+                    public void onInterstitialFailed(MoPubErrorCode errorCode) { }
+
+                    @Override
+                    public void onInterstitialShown() { }
+
+                    @Override
+                    public void onInterstitialClicked() { }
+
+                    @Override
+                    public void onLeaveApplication() { }
+
+                    @Override
+                    public void onInterstitialDismissed() { }
+                };
+
+        //***************
+        // Chartboost Location Management for interstitials and rewarded videos
+        //***************
+
+        private Map<String, CustomEventInterstitialListener> mInterstitialListenersForLocation
+                = Collections.synchronizedMap(new TreeMap<String, CustomEventInterstitialListener>());
+
+        private Set<String> mRewardedVideoLocationsToLoad = Collections.synchronizedSet(new TreeSet<String>());
+
+        public void registerInterstitialListener(@NonNull String location,
+                @NonNull CustomEventInterstitialListener interstitialListener) {
+            Preconditions.checkNotNull(location);
+            Preconditions.checkNotNull(interstitialListener);
+            mInterstitialListenersForLocation.put(location, interstitialListener);
+        }
+
+        public void unregisterInterstitialListener(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mInterstitialListenersForLocation.remove(location);
+        }
+
+        public void registerRewardedVideoLocation(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mRewardedVideoLocationsToLoad.add(location);
+        }
+
+        public void unregisterRewardedVideoLocation(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mRewardedVideoLocationsToLoad.remove(location);
+        }
+
+        @NonNull
+        public CustomEventInterstitialListener getInterstitialListener(@NonNull String location) {
+            final CustomEventInterstitialListener listener = mInterstitialListenersForLocation.get(location);
+            return listener != null ? listener : NULL_LISTENER;
+        }
+
+        public boolean hasInterstitialLocation(@NonNull String location) {
+            return mInterstitialListenersForLocation.containsKey(location);
+        }
+
+        //******************
+        // Chartboost Delegate methods.
+        //******************
+
+        //******************
+        // Interstitials
+        //******************
+        @Override
+        public void didCacheInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial loaded successfully.");
+            getInterstitialListener(location).onInterstitialLoaded();
+        }
+
+        @Override
+        public void didFailToLoadInterstitial(String location, CBError.CBImpressionError error) {
+            String suffix = error != null ? "Error: " + error.name() : "";
+            Log.d("MoPub", "Chartboost interstitial ad failed to load." + suffix);
+            getInterstitialListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
+        }
+
+        @Override
+        public void didDismissInterstitial(String location) {
+            // Note that this method is fired before didCloseInterstitial and didClickInterstitial.
+            MoPubLog.d("Chartboost interstitial ad dismissed.");
+            getInterstitialListener(location).onInterstitialDismissed();
+        }
+
+        @Override
+        public void didCloseInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad closed.");
+        }
+
+        @Override
+        public void didClickInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad clicked.");
+            getInterstitialListener(location).onInterstitialClicked();
+        }
+
+        @Override
+        public void didDisplayInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad shown.");
+            getInterstitialListener(location).onInterstitialShown();
+        }
+
+        //******************
+        // Rewarded Videos
+        //******************
+        @Override
+        public void didCacheRewardedVideo(String location) {
+            super.didCacheRewardedVideo(location);
+
+            if (mRewardedVideoLocationsToLoad.contains(location)) {
+                MoPubLog.d("Chartboost rewarded video cached for location " + location + ".");
+                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(ChartboostRewardedVideo.class, location);
+                mRewardedVideoLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didFailToLoadRewardedVideo(String location, CBError.CBImpressionError error) {
+            super.didFailToLoadRewardedVideo(location, error);
+            String suffix = error != null ? " with error: " + error.name() : "";
+            if (mRewardedVideoLocationsToLoad.contains(location)) {
+                MoPubErrorCode errorCode = VIDEO_DOWNLOAD_ERROR;
+                MoPubLog.d("Chartboost rewarded video cache failed for location " + location + suffix);
+                if (CBError.CBImpressionError.INVALID_LOCATION.equals(error)) {
+                    errorCode = ADAPTER_CONFIGURATION_ERROR;
+                }
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(ChartboostRewardedVideo.class, location, errorCode);
+                mRewardedVideoLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didDismissRewardedVideo(String location) {
+            // This is called before didCloseRewardedVideo and didClickRewardedVideo
+            super.didDismissRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClosed(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video dismissed for location " + location + ".");
+        }
+
+        @Override
+        public void didCloseRewardedVideo(String location) {
+            super.didCloseRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video closed for location " + location + ".");
+        }
+
+        @Override
+        public void didClickRewardedVideo(String location) {
+            super.didClickRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClicked(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video clicked for location " + location + ".");
+        }
+
+        @Override
+        public void didCompleteRewardedVideo(String location, int reward) {
+            super.didCompleteRewardedVideo(location, reward);
+            MoPubLog.d("Chartboost rewarded video completed for location " + location + " with "
+                    + "reward amount " + reward);
+            MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                    ChartboostRewardedVideo.class,
+                    location,
+                    MoPubReward.success(MoPubReward.NO_REWARD_LABEL, reward));
+        }
+
+        @Override
+        public void didDisplayRewardedVideo(String location) {
+            super.didDisplayRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video displayed for location " + location + ".");
+            MoPubRewardedVideoManager.onRewardedVideoStarted(ChartboostRewardedVideo.class, location);
+        }
+
+        //******************
+        // More Apps
+        //******************
+        @Override
+        public boolean shouldRequestMoreApps(String location) {
+            return false;
+        }
+
+        @Override
+        public boolean shouldDisplayMoreApps(final String location) {
+            return false;
+        }
+    }
+
+
+    @VisibleForTesting
+    @Deprecated
+    static void reset() {
+        // Clears all the locations to load and other state.
+        sDelegate = new ChartboostSingletonDelegate();
+        mAppId = null;
+        mAppSignature = null;
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/FacebookBanner.java b/extras/src/com/mopub/mobileads/FacebookBanner.java
index d58000f6..f0513a57 100644
--- a/extras/src/com/mopub/mobileads/FacebookBanner.java
+++ b/extras/src/com/mopub/mobileads/FacebookBanner.java
@@ -1,6 +1,8 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.facebook.ads.Ad;
@@ -8,15 +10,16 @@
 import com.facebook.ads.AdListener;
 import com.facebook.ads.AdSize;
 import com.facebook.ads.AdView;
+import com.mopub.common.DataKeys;
 import com.mopub.common.util.Views;
 
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 3.18.1.
+ * Tested with Facebook SDK 3.23.1.
  */
 public class FacebookBanner extends CustomEventBanner implements AdListener {
-    private static final String PLACEMENT_ID_KEY = "placement_id";
+    public static final String PLACEMENT_ID_KEY = "placement_id";
 
     private AdView mFacebookBanner;
     private CustomEventBannerListener mBannerListener;
@@ -33,15 +36,32 @@ protected void loadBanner(final Context context,
         mBannerListener = customEventBannerListener;
 
         final String placementId;
-        if (extrasAreValid(serverExtras)) {
+        if (serverExtrasAreValid(serverExtras)) {
             placementId = serverExtras.get(PLACEMENT_ID_KEY);
         } else {
             mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        mFacebookBanner = new AdView(context, placementId, AdSize.BANNER_320_50);
+        int width;
+        int height;
+        if (localExtrasAreValid(localExtras)) {
+            width = (Integer) localExtras.get(DataKeys.AD_WIDTH);
+            height = (Integer) localExtras.get(DataKeys.AD_HEIGHT);
+        } else {
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        AdSize adSize = calculateAdSize(width, height);
+        if (adSize == null) {
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        mFacebookBanner = new AdView(context, placementId, adSize);
         mFacebookBanner.setAdListener(this);
+        mFacebookBanner.disableAutoRefresh();
         mFacebookBanner.loadAd();
     }
 
@@ -82,11 +102,30 @@ public void onAdClicked(Ad ad) {
         mBannerListener.onBannerClicked();
     }
 
-    private boolean extrasAreValid(final Map<String, String> serverExtras) {
+    private boolean serverExtrasAreValid(final Map<String, String> serverExtras) {
         final String placementId = serverExtras.get(PLACEMENT_ID_KEY);
         return (placementId != null && placementId.length() > 0);
     }
 
+    private boolean localExtrasAreValid(@NonNull final Map<String, Object> localExtras) {
+        return localExtras.get(DataKeys.AD_WIDTH) instanceof Integer
+                && localExtras.get(DataKeys.AD_HEIGHT) instanceof Integer;
+    }
+
+    @Nullable
+    private AdSize calculateAdSize(int width, int height) {
+        // Use the smallest AdSize that will properly contain the adView
+        if (height <= AdSize.BANNER_320_50.getHeight()) {
+            return AdSize.BANNER_320_50;
+        } else if (height <= AdSize.BANNER_HEIGHT_90.getHeight()) {
+            return AdSize.BANNER_HEIGHT_90;
+        } else if (height <= AdSize.RECTANGLE_HEIGHT_250.getHeight()) {
+            return AdSize.RECTANGLE_HEIGHT_250;
+        } else {
+            return null;
+        }
+    }
+
     @Deprecated // for testing
     AdView getAdView() {
         return mFacebookBanner;
diff --git a/extras/src/com/mopub/mobileads/FacebookInterstitial.java b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
index d6dde364..3ff45d1b 100644
--- a/extras/src/com/mopub/mobileads/FacebookInterstitial.java
+++ b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
@@ -10,16 +10,11 @@
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-
 /**
- * Tested with Facebook SDK 3.18.1.
+ * Tested with Facebook SDK 3.23.1.
  */
 public class FacebookInterstitial extends CustomEventInterstitial implements InterstitialAdListener {
-    private static final String PLACEMENT_ID_KEY = "placement_id";
+    public static final String PLACEMENT_ID_KEY = "placement_id";
 
     private InterstitialAd mFacebookInterstitial;
     private CustomEventInterstitialListener mInterstitialListener;
@@ -39,7 +34,7 @@ protected void loadInterstitial(final Context context,
         if (extrasAreValid(serverExtras)) {
             placementId = serverExtras.get(PLACEMENT_ID_KEY);
         } else {
-            mInterstitialListener.onInterstitialFailed(ADAPTER_CONFIGURATION_ERROR);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
@@ -79,11 +74,11 @@ public void onAdLoaded(final Ad ad) {
     public void onError(final Ad ad, final AdError error) {
         Log.d("MoPub", "Facebook interstitial ad failed to load.");
         if (error == AdError.NO_FILL) {
-            mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
         } else if (error == AdError.INTERNAL_ERROR) {
-            mInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
         } else {
-            mInterstitialListener.onInterstitialFailed(UNSPECIFIED);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.UNSPECIFIED);
         }
     }
 
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
index a71e120c..17273749 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
@@ -15,11 +15,9 @@
 import static com.google.android.gms.ads.AdSize.FULL_BANNER;
 import static com.google.android.gms.ads.AdSize.LEADERBOARD;
 import static com.google.android.gms.ads.AdSize.MEDIUM_RECTANGLE;
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
 
 /*
- * Compatible with version 5.0.89 of the Google Play Services SDK.
+ * Compatible with version 7.0.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
@@ -28,10 +26,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String AD_UNIT_ID_KEY = "adUnitID";
-    private static final String AD_WIDTH_KEY = "adWidth";
-    private static final String AD_HEIGHT_KEY = "adHeight";
-    private static final String LOCATION_KEY = "location";
+    public static final String AD_UNIT_ID_KEY = "adUnitID";
+    public static final String AD_WIDTH_KEY = "adWidth";
+    public static final String AD_HEIGHT_KEY = "adHeight";
+    public static final String LOCATION_KEY = "location";
 
     private CustomEventBannerListener mBannerListener;
     private AdView mGoogleAdView;
@@ -52,7 +50,7 @@ protected void loadBanner(
             adWidth = Integer.parseInt(serverExtras.get(AD_WIDTH_KEY));
             adHeight = Integer.parseInt(serverExtras.get(AD_HEIGHT_KEY));
         } else {
-            mBannerListener.onBannerFailed(ADAPTER_CONFIGURATION_ERROR);
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
@@ -62,19 +60,21 @@ protected void loadBanner(
 
         final AdSize adSize = calculateAdSize(adWidth, adHeight);
         if (adSize == null) {
-            mBannerListener.onBannerFailed(ADAPTER_CONFIGURATION_ERROR);
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
         mGoogleAdView.setAdSize(adSize);
 
-        final AdRequest adRequest = new AdRequest.Builder().build();
+        final AdRequest adRequest = new AdRequest.Builder()
+                .setRequestAgent("MoPub")
+                .build();
 
         try {
             mGoogleAdView.loadAd(adRequest);
         } catch (NoClassDefFoundError e) {
             // This can be thrown by Play Services on Honeycomb.
-            mBannerListener.onBannerFailed(NETWORK_NO_FILL);
+            mBannerListener.onBannerFailed(MoPubErrorCode.NETWORK_NO_FILL);
         }
     }
 
@@ -126,7 +126,7 @@ public void onAdClosed() {
         public void onAdFailedToLoad(int errorCode) {
             Log.d("MoPub", "Google Play Services banner ad failed to load.");
             if (mBannerListener != null) {
-                mBannerListener.onBannerFailed(NETWORK_NO_FILL);
+                mBannerListener.onBannerFailed(MoPubErrorCode.NETWORK_NO_FILL);
             }
         }
 
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
index 24146033..9aab1650 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
@@ -9,11 +9,8 @@
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-
 /*
- * Compatible with version 5.0.89 of the Google Play Services SDK.
+ * Compatible with version 7.0.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
@@ -22,8 +19,8 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String AD_UNIT_ID_KEY = "adUnitID";
-    private static final String LOCATION_KEY = "location";
+    public static final String AD_UNIT_ID_KEY = "adUnitID";
+    public static final String LOCATION_KEY = "location";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private InterstitialAd mGoogleInterstitialAd;
@@ -40,7 +37,7 @@ protected void loadInterstitial(
         if (extrasAreValid(serverExtras)) {
             adUnitId = serverExtras.get(AD_UNIT_ID_KEY);
         } else {
-            mInterstitialListener.onInterstitialFailed(ADAPTER_CONFIGURATION_ERROR);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
@@ -48,13 +45,15 @@ protected void loadInterstitial(
         mGoogleInterstitialAd.setAdListener(new InterstitialAdListener());
         mGoogleInterstitialAd.setAdUnitId(adUnitId);
 
-        final AdRequest adRequest = new AdRequest.Builder().build();
+        final AdRequest adRequest = new AdRequest.Builder()
+                .setRequestAgent("MoPub")
+                .build();
 
         try {
             mGoogleInterstitialAd.loadAd(adRequest);
         } catch (NoClassDefFoundError e) {
             // This can be thrown by Play Services on Honeycomb.
-            mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
         }
     }
 
@@ -94,7 +93,7 @@ public void onAdClosed() {
         public void onAdFailedToLoad(int errorCode) {
             Log.d("MoPub", "Google Play Services interstitial ad failed to load.");
             if (mInterstitialListener != null) {
-                mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+                mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
             }
         }
 
diff --git a/extras/src/com/mopub/mobileads/MillennialBanner.java b/extras/src/com/mopub/mobileads/MillennialBanner.java
index ac1c4fe6..d09dcf6e 100644
--- a/extras/src/com/mopub/mobileads/MillennialBanner.java
+++ b/extras/src/com/mopub/mobileads/MillennialBanner.java
@@ -1,125 +1,264 @@
 package com.mopub.mobileads;
 
+import android.app.Activity;
 import android.content.Context;
-import android.location.Location;
+import android.os.Handler;
+import android.os.Looper;
 import android.util.Log;
+import android.view.Gravity;
+import android.widget.LinearLayout;
+import android.widget.LinearLayout.LayoutParams;
 
-import com.millennialmedia.android.MMAd;
-import com.millennialmedia.android.MMAdView;
-import com.millennialmedia.android.MMException;
-import com.millennialmedia.android.MMRequest;
-import com.millennialmedia.android.MMSDK;
-import com.millennialmedia.android.RequestListener;
+import com.millennialmedia.AppInfo;
+import com.millennialmedia.InlineAd;
+import com.millennialmedia.InlineAd.AdSize;
+import com.millennialmedia.InlineAd.InlineAdMetadata;
+import com.millennialmedia.InlineAd.InlineErrorStatus;
+import com.millennialmedia.MMException;
+import com.millennialmedia.MMSDK;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-
 /**
- * Compatible with version 5.3.0 of the Millennial Media SDK.
+ * Compatible with version 6.0 of the Millennial Media SDK.
  */
 
 class MillennialBanner extends CustomEventBanner {
-    private MMAdView mMillennialAdView;
-    private CustomEventBannerListener mBannerListener;
+
+    public static final String LOGCAT_TAG = "MP->MM Inline";
+    public static final String DCN_KEY = "dcn";
     public static final String APID_KEY = "adUnitID";
     public static final String AD_WIDTH_KEY = "adWidth";
     public static final String AD_HEIGHT_KEY = "adHeight";
 
+    private InlineAd mInlineAd;
+    private CustomEventBannerListener mBannerListener;
+    private LinearLayout mInternalView;
+    private static final Handler UI_THREAD_HANDLER = new Handler(Looper.getMainLooper());
+
+
     @Override
     protected void loadBanner(final Context context, final CustomEventBannerListener customEventBannerListener,
-                              final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
+            final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
+
+        LayoutParams lp;
+        String apid = null;
+        String dcn = null;
+        int width;
+        int height;
         mBannerListener = customEventBannerListener;
 
+        if ( !MMSDK.isInitialized() ) {
+            try {
+                MMSDK.initialize((Activity) context);
+            } catch ( Exception e ) {
+                Log.e(LOGCAT_TAG, "Unable to initialize the Millennial SDK-- " + e.getMessage());
+                e.printStackTrace();
+                UI_THREAD_HANDLER.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        mBannerListener.onBannerFailed(MoPubErrorCode.INTERNAL_ERROR);
+                    }
+                });
+                return;
+            }
+        }
 
-        final String apid;
-        final int width;
-        final int height;
         if (extrasAreValid(serverExtras)) {
+            dcn = serverExtras.get(DCN_KEY);
             apid = serverExtras.get(APID_KEY);
             width = Integer.parseInt(serverExtras.get(AD_WIDTH_KEY));
             height = Integer.parseInt(serverExtras.get(AD_HEIGHT_KEY));
         } else {
-            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            Log.e(LOGCAT_TAG, "We were given invalid extras! Make sure placement ID, width, and height are specified.");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+                }
+            });
             return;
         }
 
-        MMSDK.initialize(context);
+        // Add DCN's for Nexage folks
+        try {
+            AppInfo ai = new AppInfo().setMediator("mopubsdk");
+            if ( dcn != null && dcn.length() > 0 ) {
+                ai = ai.setSiteId(dcn);
+            } else {
+                ai = ai.setSiteId(null);
+            }
+            MMSDK.setAppInfo(ai);
+        } catch ( IllegalStateException e ) {
+            Log.i(LOGCAT_TAG, "Caught exception " + e.getMessage());
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerFailed(MoPubErrorCode.INTERNAL_ERROR);
+                }
+            });
+            return;
+        }
+
+        mInternalView = new LinearLayout(context);
 
-        mMillennialAdView = new MMAdView(context);
-        mMillennialAdView.setListener(new MillennialBannerRequestListener());
+        lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+        lp.gravity = Gravity.CENTER_HORIZONTAL;
+        mInternalView.setLayoutParams(lp);
 
-        mMillennialAdView.setApid(apid);
-        mMillennialAdView.setWidth(width);
-        mMillennialAdView.setHeight(height);
+        InlineAdMetadata mInlineAdMetadata = null;
 
-        final Location location = (Location) localExtras.get("location");
-        if (location != null) {
-            MMRequest.setUserLocation(location);
+        try {
+            mInlineAd = InlineAd.createInstance(apid, mInternalView);
+            mInlineAdMetadata = new InlineAdMetadata().setAdSize(new AdSize(width, height));
+        } catch ( MMException e ) {
+            e.printStackTrace();
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerFailed(MoPubErrorCode.INTERNAL_ERROR);
+                }
+            });
+            return;
         }
 
-        mMillennialAdView.setMMRequest(new MMRequest());
-        mMillennialAdView.setId(MMSDK.getDefaultAdId());
-        AdViewController.setShouldHonorServerDimensions(mMillennialAdView);
-        mMillennialAdView.getAd();
+        mInlineAd.setListener(new MillennialInlineListener());
+        
+        /* If MoPub gets location, so do we. */
+        MMSDK.setLocationEnabled( (localExtras.get("location") != null) );
+
+        AdViewController.setShouldHonorServerDimensions(mInternalView);
+
+        mInlineAd.request(mInlineAdMetadata);
     }
 
     @Override
     protected void onInvalidate() {
-        // mMillennialAdView can be null if loadBanner terminated prematurely (i.e. the associated
-        // serverExtras are invalid).
-        if (mMillennialAdView != null) {
-            mMillennialAdView.setListener(null);
+        // Destroy any hanging references.
+        if (mInlineAd != null) {
+            mInlineAd.setListener(null);
+            mInlineAd = null;
         }
     }
 
     private boolean extrasAreValid(final Map<String, String> serverExtras) {
         try {
-            Integer.parseInt(serverExtras.get(AD_WIDTH_KEY));
-            Integer.parseInt(serverExtras.get(AD_HEIGHT_KEY));
-        } catch (NumberFormatException e) {
+            // Add pos / non-null and APIDs.
+            int w = Integer.parseInt(serverExtras.get(AD_WIDTH_KEY));
+            int h = Integer.parseInt(serverExtras.get(AD_HEIGHT_KEY));
+            if ( h < 0 || w < 0 ) {
+                throw new NumberFormatException();
+            }
+        } catch (Exception e) {
+            Log.e(LOGCAT_TAG, "Width and height must exist and contain positive integers!");
+            e.printStackTrace();
             return false;
         }
 
         return serverExtras.containsKey(APID_KEY);
     }
 
-    class MillennialBannerRequestListener implements RequestListener {
+    class MillennialInlineListener implements InlineAd.InlineListener {
+
         @Override
-        public void MMAdOverlayLaunched(final MMAd mmAd) {
-            Log.d("MoPub", "Millennial banner ad Launched.");
-            mBannerListener.onBannerExpanded();
+        public void onAdLeftApplication(InlineAd arg0) {
+            // Intentionally not calling MoPub's onLeaveApplication to avoid double-count
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Leaving application");
         }
 
         @Override
-        public void MMAdOverlayClosed(final MMAd mmAd) {
-            Log.d("MoPub", "Millennial banner ad closed.");
-            mBannerListener.onBannerCollapsed();
+        public void onClicked(InlineAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Ad clicked");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerClicked();
+                }
+            });
         }
 
         @Override
-        public void MMAdRequestIsCaching(final MMAd mmAd) {}
+        public void onCollapsed(InlineAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Banner collapsed");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerCollapsed();
+                }
+            });
+
+        }
 
         @Override
-        public void requestCompleted(final MMAd mmAd) {
-            Log.d("MoPub", "Millennial banner ad loaded successfully. Showing ad...");
-            mBannerListener.onBannerLoaded(mMillennialAdView);
+        public void onExpanded(InlineAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Banner expanded");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerExpanded();
+                }
+            });
         }
 
         @Override
-        public void requestFailed(final MMAd mmAd, final MMException e) {
-            Log.d("MoPub", "Millennial banner ad failed to load.");
-            mBannerListener.onBannerFailed(NETWORK_NO_FILL);
+        public void onRequestFailed(InlineAd arg0, InlineErrorStatus err) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Banner failed (" + err.getErrorCode() + "): " + err.getDescription() );
+            MoPubErrorCode mopubErrorCode;
+
+            switch ( err.getErrorCode() ) {
+                case InlineErrorStatus.ADAPTER_NOT_FOUND:
+                    mopubErrorCode = MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+                    break;
+                case InlineErrorStatus.DISPLAY_FAILED:
+                    mopubErrorCode = MoPubErrorCode.INTERNAL_ERROR;
+                    break;
+                case InlineErrorStatus.INIT_FAILED:
+                    mopubErrorCode = MoPubErrorCode.WARMUP;
+                    break;
+                case InlineErrorStatus.NO_NETWORK:
+                    mopubErrorCode = MoPubErrorCode.NO_CONNECTION;
+                    break;
+                case InlineErrorStatus.UNKNOWN:
+                    mopubErrorCode = MoPubErrorCode.UNSPECIFIED;
+                    break;
+                case InlineErrorStatus.LOAD_FAILED:
+                default:
+                    mopubErrorCode = MoPubErrorCode.NETWORK_NO_FILL;
+            }
+
+            final MoPubErrorCode fErrorCode = mopubErrorCode;
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerFailed(fErrorCode);
+                }
+            });
+
         }
 
         @Override
-        public void onSingleTap(final MMAd mmAd) {
-            mBannerListener.onBannerClicked();
+        public void onRequestSucceeded(InlineAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Banner request succeeded");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mBannerListener.onBannerLoaded(mInternalView);
+                }
+            });
+        }
+
+        @Override
+        public void onResize(InlineAd arg0, int w, int h) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Banner about to resize (width: " + w + ", height: " + h + ")");
+        }
+
+        @Override
+        public void onResized(InlineAd arg0, int w, int h, boolean isClosed) {
+            Log.d(LOGCAT_TAG, "Millennial Inline Ad - Banner resized (width: " + w + ", height: " + h + "). "
+                    + (isClosed ? "Returned to original placement." : "Got a fresh, new place.") );
+
         }
-    }
 
-    @Deprecated
-    MMAdView getMMAdView() {
-        return mMillennialAdView;
     }
+
 }
diff --git a/extras/src/com/mopub/mobileads/MillennialInterstitial.java b/extras/src/com/mopub/mobileads/MillennialInterstitial.java
index 474d2203..25eba9b4 100644
--- a/extras/src/com/mopub/mobileads/MillennialInterstitial.java
+++ b/extras/src/com/mopub/mobileads/MillennialInterstitial.java
@@ -1,72 +1,132 @@
 package com.mopub.mobileads;
 
+import android.app.Activity;
 import android.content.Context;
-import android.location.Location;
+import android.os.Handler;
+import android.os.Looper;
 import android.util.Log;
 
-import com.millennialmedia.android.MMAd;
-import com.millennialmedia.android.MMException;
-import com.millennialmedia.android.MMInterstitial;
-import com.millennialmedia.android.MMRequest;
-import com.millennialmedia.android.MMSDK;
-import com.millennialmedia.android.RequestListener;
-
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
+import com.millennialmedia.AppInfo;
+import com.millennialmedia.InterstitialAd;
+import com.millennialmedia.InterstitialAd.InterstitialErrorStatus;
+import com.millennialmedia.InterstitialAd.InterstitialListener;
+import com.millennialmedia.MMException;
+import com.millennialmedia.MMSDK;
 
 /**
- * Compatible with version 5.3.0 of the Millennial Media SDK.
+ * Compatible with version 6.0 of the Millennial Media SDK.
  */
 
 class MillennialInterstitial extends CustomEventInterstitial {
-    private MMInterstitial mMillennialInterstitial;
-    private CustomEventInterstitialListener mInterstitialListener;
+
+    public static final String LOGCAT_TAG = "MP->MM Int.";
+    public static final String DCN_KEY = "dcn";
     public static final String APID_KEY = "adUnitID";
 
+    private InterstitialAd mMillennialInterstitial;
+    private Context mContext;
+    private CustomEventInterstitialListener mInterstitialListener;
+    private static final Handler UI_THREAD_HANDLER = new Handler(Looper.getMainLooper());
+
     @Override
     protected void loadInterstitial(final Context context, final CustomEventInterstitialListener customEventInterstitialListener,
-                                    final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
+            final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
+        String dcn = null;
         mInterstitialListener = customEventInterstitialListener;
+        mContext = context;
 
         final String apid;
+
+        if ( !MMSDK.isInitialized() ) {
+            try {
+                MMSDK.initialize((Activity) context);
+            } catch ( Exception e ) {
+                Log.e(LOGCAT_TAG, "Unable to initialize the Millennial SDK-- " + e.getMessage());
+                e.printStackTrace();
+                UI_THREAD_HANDLER.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        mInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                    }
+                });
+                return;
+            }
+        }
+
         if (extrasAreValid(serverExtras)) {
+            dcn = serverExtras.get(DCN_KEY);
             apid = serverExtras.get(APID_KEY);
         } else {
-            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            Log.e(LOGCAT_TAG, "Invalid extras-- Be sure you have an placement ID specified.");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+                }
+            });
             return;
         }
 
-        MMSDK.initialize(context);
-
-        final Location location = (Location) localExtras.get("location");
-        if (location != null) {
-            MMRequest.setUserLocation(location);
+        // Add DCN support
+        try {
+            AppInfo ai = new AppInfo().setMediator("mopubsdk");
+            if ( dcn != null && dcn.length() > 0 ) {
+                ai = ai.setSiteId(dcn);
+            } else {
+                ai.setSiteId(null);
+            }
+            MMSDK.setAppInfo(ai);
+        } catch ( IllegalStateException e ) {
+            Log.i(LOGCAT_TAG, "SDK not finished initializing-- " + e.getMessage());
+        }
+        
+        /* If MoPub gets location, so do we. */
+        MMSDK.setLocationEnabled( (localExtras.get("location") != null) );
+
+        try {
+            mMillennialInterstitial = InterstitialAd.createInstance(apid);
+        } catch (MMException e) {
+            e.printStackTrace();
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                }
+            });
+            return;
         }
 
-        mMillennialInterstitial = new MMInterstitial(context);
-        mMillennialInterstitial.setListener(new MillennialInterstitialRequestListener());
-        mMillennialInterstitial.setMMRequest(new MMRequest());
-        mMillennialInterstitial.setApid(apid);
-        mMillennialInterstitial.fetch();
+        mMillennialInterstitial.setListener(new MillennialInterstitialListener());
+        mMillennialInterstitial.load(context, null);
     }
 
     @Override
     protected void showInterstitial() {
-        if (mMillennialInterstitial.isAdAvailable()) {
-            mMillennialInterstitial.display();
+        if (mMillennialInterstitial.isReady()) {
+            try {
+                mMillennialInterstitial.show(mContext);
+            } catch ( MMException e ) {
+                e.printStackTrace();
+                UI_THREAD_HANDLER.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        mInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                    }
+                });
+                return;
+            }
         } else {
-            Log.d("MoPub", "Tried to show a Millennial interstitial ad before it finished loading. Please try again.");
+            Log.w(LOGCAT_TAG, "showInterstitial called before Millennial's ad was loaded.");
         }
     }
 
     @Override
     protected void onInvalidate() {
-        // mMillennialInterstitial can be null if loadInterstitial terminated prematurely (i.e.
-        // the associated serverExtras are invalid).
         if (mMillennialInterstitial != null) {
             mMillennialInterstitial.setListener(null);
+            mMillennialInterstitial = null;
         }
     }
 
@@ -74,51 +134,117 @@ private boolean extrasAreValid(Map<String, String> serverExtras) {
         return serverExtras.containsKey(APID_KEY);
     }
 
-    class MillennialInterstitialRequestListener implements RequestListener {
+    class MillennialInterstitialListener implements InterstitialListener {
+
         @Override
-        public void MMAdOverlayLaunched(final MMAd mmAd) {
-            Log.d("MoPub", "Showing Millennial interstitial ad.");
-            mInterstitialListener.onInterstitialShown();
+        public void onAdLeftApplication(InterstitialAd arg0) {
+            // Intentionally not calling MoPub's onLeaveApplication to avoid double-count
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - Leaving application");
         }
 
         @Override
-        public void MMAdOverlayClosed(final MMAd mmAd) {
-            Log.d("MoPub", "Millennial interstitial ad dismissed.");
-            mInterstitialListener.onInterstitialDismissed();
+        public void onClicked(InterstitialAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - Ad was clicked");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialClicked();
+                }
+            });
         }
 
-        @Override public void MMAdRequestIsCaching(final MMAd mmAd) {}
+        @Override
+        public void onClosed(InterstitialAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - Ad was closed");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialDismissed();
+                }
+            });
+        }
 
         @Override
-        public void requestCompleted(final MMAd mmAd) {
-            if (mMillennialInterstitial.isAdAvailable()) {
-                Log.d("MoPub", "Millennial interstitial ad loaded successfully.");
-                mInterstitialListener.onInterstitialLoaded();
-            } else {
-                Log.d("MoPub", "Millennial interstitial request completed, but no ad was available.");
-                mInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
-            }
+        public void onExpired(InterstitialAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - Ad expired");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NO_FILL);
+                }
+            });
         }
 
         @Override
-        public void requestFailed(final MMAd mmAd, final MMException e) {
-            if (mMillennialInterstitial == null || e == null) {
-                mInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
-            } else if (e.getCode() == MMException.CACHE_NOT_EMPTY && mMillennialInterstitial.isAdAvailable()) {
-                // requestFailed can be due to an ad already loaded or an ad failed to load.
-                Log.d("MoPub", "Millennial interstitial loaded successfully from cache.");
-                mInterstitialListener.onInterstitialLoaded();
-            } else {
-                Log.d("MoPub", "Millennial interstitial ad failed to load.");
-                mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+        public void onLoadFailed(InterstitialAd arg0,
+                InterstitialErrorStatus err) {
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - load failed (" + err.getErrorCode() + "): " + err.getDescription() );
+            final MoPubErrorCode moPubErrorCode;
+
+            switch (err.getErrorCode() ) {
+                case InterstitialErrorStatus.ALREADY_LOADED:
+                    // This will generate discrepancies, as requests will NOT be sent to Millennial.
+                    mInterstitialListener.onInterstitialLoaded();
+                    Log.w(LOGCAT_TAG, "Millennial Interstitial Ad - Attempted to load ads when ads are already loaded." );
+                    return;
+                case InterstitialErrorStatus.EXPIRED:
+                case InterstitialErrorStatus.DISPLAY_FAILED:
+                case InterstitialErrorStatus.INIT_FAILED:
+                case InterstitialErrorStatus.ADAPTER_NOT_FOUND:
+                    moPubErrorCode = MoPubErrorCode.INTERNAL_ERROR;
+                    break;
+                case InterstitialErrorStatus.NO_NETWORK:
+                    moPubErrorCode = MoPubErrorCode.NO_CONNECTION;
+                    break;
+                case InterstitialErrorStatus.UNKNOWN:
+                    moPubErrorCode = MoPubErrorCode.UNSPECIFIED;
+                    break;
+                case InterstitialErrorStatus.NOT_LOADED:
+                case InterstitialErrorStatus.LOAD_FAILED:
+                default:
+                    moPubErrorCode = MoPubErrorCode.NETWORK_NO_FILL;
             }
+
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialFailed(moPubErrorCode);
+                }
+            });
+        }
+
+        @Override
+        public void onLoaded(InterstitialAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - Ad loaded splendidly");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialLoaded();
+                }
+            });
         }
 
         @Override
-        public void onSingleTap(final MMAd mmAd) {
-            Log.d("MoPub", "Millennial interstitial clicked.");
-            mInterstitialListener.onInterstitialClicked();
+        public void onShowFailed(InterstitialAd arg0,
+                InterstitialErrorStatus arg1) {
+            Log.e(LOGCAT_TAG, "Millennial Interstitial Ad - Show failed (" + arg1.getErrorCode() + "): " + arg1.getDescription());
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                }
+            });
         }
 
+        @Override
+        public void onShown(InterstitialAd arg0) {
+            Log.d(LOGCAT_TAG, "Millennial Interstitial Ad - Ad shown");
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    mInterstitialListener.onInterstitialShown();
+                }
+            });
+        }
     }
 }
diff --git a/extras/src/com/mopub/mobileads/VungleInterstitial.java b/extras/src/com/mopub/mobileads/VungleInterstitial.java
index b662a2b7..1e2ea4b8 100644
--- a/extras/src/com/mopub/mobileads/VungleInterstitial.java
+++ b/extras/src/com/mopub/mobileads/VungleInterstitial.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.os.Looper;
 import android.util.Log;
 
 import com.vungle.publisher.EventListener;
@@ -11,19 +12,17 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-
 /*
- * Tested with Vungle SDK 3.1.0.
+ * Tested with Vungle SDK 3.3.0
  */
 public class VungleInterstitial extends CustomEventInterstitial implements EventListener {
 
-    public static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
+    private static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
 
     /*
      * APP_ID_KEY is intended for MoPub internal use. Do not modify.
      */
-    private static final String APP_ID_KEY = "appId";
+    public static final String APP_ID_KEY = "appId";
 
     private final VunglePub mVunglePub;
     private final Handler mHandler;
@@ -32,7 +31,7 @@
     private boolean mIsLoading;
 
     public VungleInterstitial() {
-        mHandler = new Handler();
+        mHandler = new Handler(Looper.getMainLooper());
         mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
         mVunglePub = VunglePub.getInstance();
     }
@@ -45,7 +44,7 @@ protected void loadInterstitial(Context context,
         mCustomEventInterstitialListener = customEventInterstitialListener;
 
         if (context == null) {
-            mCustomEventInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
+            mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             return;
         }
 
@@ -60,14 +59,15 @@ protected void loadInterstitial(Context context,
             appId = DEFAULT_VUNGLE_APP_ID;
         }
 
-        mVunglePub.setEventListener(this);
+        // init clears the event listener.
         mVunglePub.init(context, appId);
+        mVunglePub.setEventListeners(this);
         scheduleOnInterstitialLoaded();
     }
 
     @Override
     protected void showInterstitial() {
-        if (mVunglePub.isCachedAdAvailable()) {
+        if (mVunglePub.isAdPlayable()) {
             mVunglePub.playAd();
         } else {
             Log.d("MoPub", "Tried to show a Vungle interstitial ad before it finished loading. Please try again.");
@@ -76,7 +76,7 @@ protected void showInterstitial() {
 
     @Override
     protected void onInvalidate() {
-        mVunglePub.setEventListener(null);
+        mVunglePub.clearEventListeners();
         mScheduledThreadPoolExecutor.shutdownNow();
         mIsLoading = false;
     }
@@ -89,7 +89,7 @@ private void scheduleOnInterstitialLoaded() {
         Runnable runnable = new Runnable() {
             @Override
             public void run() {
-            if (mVunglePub.isCachedAdAvailable()) {
+            if (mVunglePub.isAdPlayable()) {
                 Log.d("MoPub", "Vungle interstitial ad successfully loaded.");
                 mScheduledThreadPoolExecutor.shutdownNow();
                 mHandler.post(new Runnable() {
@@ -131,12 +131,15 @@ public void run() {
     }
 
     @Override
-    public void onAdEnd() {
+    public void onAdEnd(final boolean wasCallToActionClicked) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
                 Log.d("MoPub", "Vungle interstitial ad dismissed.");
                 mCustomEventInterstitialListener.onInterstitialDismissed();
+                if (wasCallToActionClicked) {
+                    mCustomEventInterstitialListener.onInterstitialClicked();
+                }
             }
         });
     }
@@ -147,8 +150,9 @@ public void onAdUnavailable(final String s) {
     }
 
     @Override
-    public void onCachedAdAvailable() {
-        // Due to the inconsistent behavior of this method, we rely on scheduleOnInterstitialLoaded instead.
+    public void onAdPlayableChanged(final boolean playable) {
+        // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
+        // we have a playable ad or we timeout.
     }
 
     @Deprecated // for testing
diff --git a/extras/src/com/mopub/mobileads/VungleRewardedVideo.java b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
new file mode 100644
index 00000000..9d020b40
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
@@ -0,0 +1,284 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import com.mopub.common.BaseLifecycleListener;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.logging.MoPubLog;
+import com.vungle.publisher.AdConfig;
+import com.vungle.publisher.EventListener;
+import com.vungle.publisher.VunglePub;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+/**
+ * A custom event for showing Vungle rewarded videos.
+ *
+ * Certified with Vungle 3.3.0
+ */
+public class VungleRewardedVideo extends CustomEventRewardedVideo {
+
+    private static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
+
+    /*
+     * These constants are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "appId";
+    public static final String VUNGLE_AD_NETWORK_CONSTANT = "vngl_id";
+
+    // This has to be reinitialized every time the CE loads to avoid conflict with the interstitials.
+    private static VunglePub sVunglePub;
+    private static VungleRewardedVideoListener sVungleListener = new VungleRewardedVideoListener();
+    private static boolean sInitialized;
+    private static final LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
+        @Override
+        public void onPause(@NonNull final Activity activity) {
+            super.onPause(activity);
+            sVunglePub.onPause();
+        }
+
+        @Override
+        public void onResume(@NonNull final Activity activity) {
+            super.onResume(activity);
+            sVunglePub.onResume();
+        }
+    };
+
+    private final Handler mHandler;
+    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
+    private boolean mIsLoading;
+    private String mAdUnitId;
+
+
+    public VungleRewardedVideo() {
+        mHandler = new Handler(Looper.getMainLooper());
+        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
+        mIsLoading = false;
+    }
+
+    @Nullable
+    @Override
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return sVungleListener;
+    }
+
+    @Nullable
+    @Override
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @NonNull
+    @Override
+    protected String getAdNetworkId() {
+        return VUNGLE_AD_NETWORK_CONSTANT;
+    }
+
+    @Override
+    protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+        synchronized (VungleRewardedVideo.class) {
+            if (!sInitialized) {
+                sVunglePub = VunglePub.getInstance();
+                sInitialized = true;
+                return true;
+            }
+            return false;
+        }
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull final Activity activity, @NonNull final Map<String, Object> localExtras, @NonNull final Map<String, String> serverExtras) throws Exception {
+        String appId = serverExtras.containsKey(APP_ID_KEY) ? serverExtras.get(APP_ID_KEY) : DEFAULT_VUNGLE_APP_ID;
+        sVunglePub.init(activity, appId);
+        sVunglePub.setEventListeners(sVungleListener);
+        Object adUnitObject = localExtras.get(DataKeys.AD_UNIT_ID_KEY);
+        if (adUnitObject instanceof String) {
+            mAdUnitId = (String) adUnitObject;
+        }
+        scheduleOnVideoLoaded();
+    }
+
+    @Override
+    protected boolean hasVideoAvailable() {
+        return sVunglePub.isAdPlayable();
+    }
+
+    @Override
+    protected void showVideo() {
+        final AdConfig adConfig = new AdConfig();
+        adConfig.setIncentivized(true);
+        setUpMediationSettingsForRequest(adConfig);
+        sVunglePub.playAd(adConfig);
+    }
+
+    private void setUpMediationSettingsForRequest(AdConfig adConfig) {
+        final VungleMediationSettings globalMediationSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(VungleMediationSettings.class);
+        final VungleMediationSettings instanceMediationSettings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(VungleMediationSettings.class, mAdUnitId);
+
+        // Local options override global options.
+        // The two objects are not merged.
+        if (instanceMediationSettings != null) {
+            modifyAdConfig(adConfig, instanceMediationSettings);
+        } else if (globalMediationSettings != null) {
+            modifyAdConfig(adConfig, globalMediationSettings);
+        }
+    }
+
+    private void modifyAdConfig(AdConfig adConfig, VungleMediationSettings mediationSettings) {
+        if (!TextUtils.isEmpty(mediationSettings.body)) {
+            adConfig.setIncentivizedCancelDialogBodyText(mediationSettings.body);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.closeButtonText)) {
+            adConfig.setIncentivizedCancelDialogCloseButtonText(mediationSettings.closeButtonText);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.keepWatchingButtonText)) {
+            adConfig.setIncentivizedCancelDialogKeepWatchingButtonText(mediationSettings.keepWatchingButtonText);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.title)) {
+            adConfig.setIncentivizedCancelDialogTitle(mediationSettings.title);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.userId)) {
+            adConfig.setIncentivizedUserId(mediationSettings.userId);
+        }
+    }
+
+    private void scheduleOnVideoLoaded() {
+        Runnable runnable = new Runnable() {
+            @Override
+            public void run() {
+                if (sVunglePub.isAdPlayable()) {
+                    MoPubLog.d("Vungle interstitial ad successfully loaded.");
+                    mScheduledThreadPoolExecutor.shutdownNow();
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(VungleRewardedVideo.class, VUNGLE_AD_NETWORK_CONSTANT);
+                        }
+                    });
+                    mIsLoading = false;
+                }
+            }
+        };
+
+        if (!mIsLoading) {
+            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
+            mIsLoading = true;
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        mScheduledThreadPoolExecutor.shutdownNow();
+    }
+
+    private static class VungleRewardedVideoListener implements EventListener,
+            CustomEventRewardedVideoListener {
+
+        @Override
+        public void onAdEnd(final boolean wasCallToActionClicked) {
+            if (wasCallToActionClicked) {
+                MoPubRewardedVideoManager.onRewardedVideoClicked(VungleRewardedVideo.class,
+                        VUNGLE_AD_NETWORK_CONSTANT);
+            }
+            MoPubRewardedVideoManager.onRewardedVideoClosed(VungleRewardedVideo.class,
+                    VUNGLE_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onAdStart() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(VungleRewardedVideo.class,
+                    VUNGLE_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onAdUnavailable(final String s) {
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(VungleRewardedVideo.class,
+                    VUNGLE_AD_NETWORK_CONSTANT, MoPubErrorCode.NETWORK_NO_FILL);
+        }
+
+        @Override
+        public void onAdPlayableChanged(final boolean playable) {
+            // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
+            // we have a playable ad or we timeout.
+        }
+
+        @Override
+        public void onVideoView(final boolean isCompletedView, final int watchedMillis, final int videoMillis) {
+            MoPubLog.d(String.format(Locale.US, "%.1f%% of Vungle video watched.",
+                    (double) watchedMillis / videoMillis * 100));
+            if (isCompletedView) {
+                // Vungle does not provide a callback when a user should be rewarded.
+                // You will need to provide your own reward logic if you receive a reward with
+                // "NO_REWARD_LABEL" && "NO_REWARD_AMOUNT"
+                MoPubRewardedVideoManager.onRewardedVideoCompleted(VungleRewardedVideo.class,
+                        VUNGLE_AD_NETWORK_CONSTANT,
+                        MoPubReward.success(MoPubReward.NO_REWARD_LABEL, MoPubReward.NO_REWARD_AMOUNT));
+            }
+        }
+    }
+
+    public static class VungleMediationSettings implements MediationSettings {
+        @Nullable private final String userId;
+        @Nullable private final String title;
+        @Nullable private final String body;
+        @Nullable private final String closeButtonText;
+        @Nullable private final String keepWatchingButtonText;
+
+        public static class Builder {
+            @Nullable private String userId;
+            @Nullable private String title;
+            @Nullable private String body;
+            @Nullable private String closeButtonText;
+            @Nullable private String keepWatchingButtonText;
+
+            public Builder withUserId(@NonNull final String userId) {
+                this.userId = userId;
+                return this;
+            }
+
+            public Builder withCancelDialogTitle(@NonNull final String title) {
+                this.title = title;
+                return this;
+            }
+
+            public Builder withCancelDialogBody(@NonNull final String body) {
+                this.body = body;
+                return this;
+            }
+
+            public Builder withCancelDialogCloseButton(@NonNull final String buttonText) {
+                this.closeButtonText = buttonText;
+                return this;
+            }
+
+            public Builder withCancelDialogKeepWatchingButton(@NonNull final String buttonText) {
+                this.keepWatchingButtonText = buttonText;
+                return this;
+            }
+
+            public VungleMediationSettings build() {
+                return new VungleMediationSettings(this);
+            }
+        }
+
+        private VungleMediationSettings(@NonNull final Builder builder) {
+            this.userId = builder.userId;
+            this.title = builder.title;
+            this.body = builder.body;
+            this.closeButtonText = builder.closeButtonText;
+            this.keepWatchingButtonText = builder.keepWatchingButtonText;
+        }
+    }
+}
diff --git a/extras/src/com/mopub/nativeads/FacebookNative.java b/extras/src/com/mopub/nativeads/FacebookNative.java
index 868610b5..76985261 100644
--- a/extras/src/com/mopub/nativeads/FacebookNative.java
+++ b/extras/src/com/mopub/nativeads/FacebookNative.java
@@ -15,7 +15,7 @@
 import java.util.Map;
 
 /*
- * Tested with Facebook SDK 3.18.1
+ * Tested with Facebook SDK 3.23.1
  */
 public class FacebookNative extends CustomEventNative {
     private static final String PLACEMENT_ID_KEY = "placement_id";
diff --git a/extras/src/com/mopub/nativeads/MillennialNative.java b/extras/src/com/mopub/nativeads/MillennialNative.java
new file mode 100644
index 00000000..26efa0a8
--- /dev/null
+++ b/extras/src/com/mopub/nativeads/MillennialNative.java
@@ -0,0 +1,262 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+import android.view.View;
+
+import com.millennialmedia.AppInfo;
+import com.millennialmedia.MMException;
+import com.millennialmedia.MMSDK;
+import com.millennialmedia.NativeAd;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class MillennialNative extends CustomEventNative {
+    public static final String DCN_KEY = "dcn";
+    public static final String APID_KEY = "adUnitID";
+    private final static String LOGCAT_TAG = "MoPub->MM-Native";
+    private static final Handler UI_THREAD_HANDLER = new Handler(Looper.getMainLooper());
+
+    @Override
+    protected void loadNativeAd(final Context context,
+            final CustomEventNativeListener listener,
+            final Map<String, Object> localExtras,
+            final Map<String, String> serverExtras) {
+
+        String placementId;
+        String siteId;
+
+        if ( !MMSDK.isInitialized() ) {
+            try {
+                MMSDK.initialize((Activity) context);
+            } catch ( Exception e ) {
+                Log.e(LOGCAT_TAG, "Unable to initialize the Millennial SDK-- " + e.getMessage());
+                e.printStackTrace();
+                UI_THREAD_HANDLER.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        listener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                    }
+                });
+                return;
+            }
+        }
+
+        if ( extrasAreValid( serverExtras )) {
+            placementId = serverExtras.get(APID_KEY);
+            siteId = serverExtras.get(DCN_KEY);
+        } else {
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    listener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                }
+            });
+            return;
+        }
+
+        try {
+            AppInfo ai = new AppInfo().setMediator("mopubsdk");
+            if ( siteId != null && siteId.length() > 0 ) {
+                ai = ai.setSiteId(siteId);
+            } else {
+                ai = ai.setSiteId(null);
+            }
+
+            MMSDK.setAppInfo(ai);
+        } catch ( IllegalStateException e ) {
+            Log.w(LOGCAT_TAG, "Caught exception: " + e.getMessage());
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    listener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                }
+            });
+            return;
+        }
+
+        try {
+            NativeAd n = NativeAd.createInstance(placementId, NativeAd.NATIVE_TYPE_INLINE);
+            final MillennialForwardingNativeAd mmForwardingNativeAd = new MillennialForwardingNativeAd(context, n, listener);
+            mmForwardingNativeAd.loadAd();
+        } catch ( MMException e ) {
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    listener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                }
+            });
+        }
+    }
+
+    private boolean extrasAreValid(final Map<String, String> serverExtras) {
+        String placementId = serverExtras.get(APID_KEY);
+        return (serverExtras.containsKey(APID_KEY) &&
+                placementId != null & placementId.length() > 0 );
+    }
+
+
+    static class MillennialForwardingNativeAd extends BaseForwardingNativeAd implements NativeAd.NativeListener {
+        private Context context;
+        private NativeAd nativeAd;
+        private CustomEventNativeListener listener;
+        private MillennialForwardingNativeAd millennialForwardingNativeAd;
+
+        public MillennialForwardingNativeAd(final Context context, final NativeAd nativeAd, final CustomEventNativeListener customEventNativeListener) {
+            this.context = context.getApplicationContext();
+            this.nativeAd = nativeAd;
+            this.listener = customEventNativeListener;
+            this.millennialForwardingNativeAd = this;
+
+            nativeAd.setListener(this);
+        }
+
+        void loadAd() {
+            Log.i(LOGCAT_TAG, "Loading native ad...");
+            try {
+                nativeAd.load(this.context, null);
+            } catch (MMException e) {
+                Log.w(MillennialNative.LOGCAT_TAG, "Caught configuration error Exception.");
+                e.printStackTrace();
+                UI_THREAD_HANDLER.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        listener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                    }
+                });
+            }
+        }
+
+        // BaseForwardingNativeAd
+        @Override
+        public void destroy() {
+            nativeAd.setListener(null);
+            nativeAd = null;
+        }
+
+        @Override
+        public void prepare(final View view) {
+            // Must access these methods directly to get impressions to fire.
+            nativeAd.getIconImage();
+            nativeAd.getDisclaimer();
+        }
+
+        @Override
+        public void handleClick(final View view) {
+            nativeAd.fireClicked();
+            Log.i(LOGCAT_TAG, "Millennial native ad clicked!");
+        }
+
+        @Override
+        public void recordImpression() {
+            super.recordImpression();
+            try {
+                nativeAd.fireImpression();
+                Log.i(LOGCAT_TAG, "Millennial native impression recorded.");
+            } catch ( MMException m ) {
+                Log.e(LOGCAT_TAG, "Millennial native impression NOT tracked: " + m.getMessage() );
+            }
+        }
+
+        // MM'S Native listener
+        @Override
+        public void onLoaded(NativeAd nativeAd) {
+            // Set assets
+            String iconImageUrl = nativeAd.getImageUrl(NativeAd.ComponentName.ICON_IMAGE, 1);
+            String mainImageUrl = nativeAd.getImageUrl(NativeAd.ComponentName.MAIN_IMAGE, 1);
+
+            this.setTitle(nativeAd.getTitle().getText().toString());
+            this.setText(nativeAd.getBody().getText().toString());
+            this.setCallToAction(nativeAd.getCallToActionButton().getText().toString());
+            this.setClickDestinationUrl(nativeAd.getCallToActionUrl());
+            this.setIconImageUrl(iconImageUrl);
+            this.setMainImageUrl(mainImageUrl);
+
+            final List<String> urls = new ArrayList<String>();
+            if ( iconImageUrl != null ) { urls.add(iconImageUrl); }
+            if ( mainImageUrl != null ) { urls.add(mainImageUrl); }
+
+            // Use MoPub's click/impression trackers
+            this.setOverridingImpressionTracker(false);
+            this.setOverridingClickTracker(false);
+
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    // This has to be run on the main thread:
+                    preCacheImages(context, urls, new ImageListener() {
+                        @Override
+                        public void onImagesCached() {
+                            listener.onNativeAdLoaded(millennialForwardingNativeAd);
+                            Log.i(LOGCAT_TAG, "Millennial native ad loaded");
+                        }
+
+                        @Override
+                        public void onImagesFailedToCache(NativeErrorCode errorCode) {
+                            listener.onNativeAdFailed(errorCode);
+                        }
+                    });
+
+                }
+            });
+        }
+
+        @Override
+        public void onLoadFailed(NativeAd nativeAd, NativeAd.NativeErrorStatus nativeErrorStatus) {
+            final NativeErrorCode error;
+            switch ( nativeErrorStatus.getErrorCode() ) {
+                case NativeAd.NativeErrorStatus.LOAD_TIMED_OUT:
+                    error = NativeErrorCode.NETWORK_TIMEOUT;
+                    break;
+                case NativeAd.NativeErrorStatus.NO_NETWORK:
+                    error = NativeErrorCode.CONNECTION_ERROR;
+                    break;
+                case NativeAd.NativeErrorStatus.UNKNOWN:
+                    error = NativeErrorCode.UNSPECIFIED;
+                    break;
+                case NativeAd.NativeErrorStatus.LOAD_FAILED:
+                case NativeAd.NativeErrorStatus.INIT_FAILED:
+                    error = NativeErrorCode.UNEXPECTED_RESPONSE_CODE;
+                    break;
+                case NativeAd.NativeErrorStatus.ADAPTER_NOT_FOUND:
+                    error = NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR;
+                    break;
+                case NativeAd.NativeErrorStatus.DISPLAY_FAILED:
+                case NativeAd.NativeErrorStatus.EXPIRED:
+                    error = NativeErrorCode.UNSPECIFIED;
+                    break;
+                default:
+                    error = NativeErrorCode.NETWORK_NO_FILL;
+            }
+            UI_THREAD_HANDLER.post(new Runnable() {
+                @Override
+                public void run() {
+                    listener.onNativeAdFailed(error);
+                }
+            });
+            Log.i(LOGCAT_TAG, "Millennial native ad failed: " + nativeErrorStatus.getDescription() );
+        }
+
+        @Override
+        public void onClicked(NativeAd nativeAd, NativeAd.ComponentName componentName, int i) {
+            Log.i(LOGCAT_TAG, "Millennial native SDK's click tracker fired.");
+        }
+
+        @Override
+        public void onAdLeftApplication(NativeAd nativeAd) {
+            Log.i(LOGCAT_TAG, "Millennial native SDK has left the application.");
+
+        }
+
+        @Override
+        public void onExpired(NativeAd nativeAd) {
+            Log.i(LOGCAT_TAG, "Millennial native ad has expired!");
+        }
+
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/GreystripeBanner.java b/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
similarity index 85%
rename from extras/src/com/mopub/mobileads/GreystripeBanner.java
rename to extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
index 8497f2e6..07311691 100644
--- a/extras/src/com/mopub/mobileads/GreystripeBanner.java
+++ b/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
@@ -11,13 +11,19 @@
 import com.mopub.mobileads.CustomEventBanner;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.Map;
 
 /*
  * Tested with Greystripe SDK 2.4.0.
  */
 class GreystripeBanner extends CustomEventBanner implements GSAdListener {
-    public static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    private static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "GUID";
 
     private CustomEventBannerListener mBannerListener;
     private GSMobileBannerAdView mGreystripeAd;
@@ -32,17 +38,21 @@ protected void loadBanner(final Context context,
                               final Map<String, String> serverExtras) {
         mBannerListener = bannerListener;
 
-        /*
-         * You may also pass this String down in the serverExtras Map by specifying Custom Event Data
-         * in MoPub's web interface.
-         */
         String greystripeAppId = DEFAULT_GREYSTRIPE_APP_ID;
+        if (extrasAreValid(serverExtras)) {
+            greystripeAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         mGreystripeAd = new GSMobileBannerAdView(context, greystripeAppId);
         mGreystripeAd.addListener(this);
 
         mGreystripeAd.refresh();
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     @Override
     protected void onInvalidate() {
         mGreystripeAd.removeListener(this);
diff --git a/extras/src/com/mopub/mobileads/GreystripeInterstitial.java b/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
similarity index 87%
rename from extras/src/com/mopub/mobileads/GreystripeInterstitial.java
rename to extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
index 57dc89ab..6540db04 100644
--- a/extras/src/com/mopub/mobileads/GreystripeInterstitial.java
+++ b/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
@@ -11,17 +11,23 @@
 import com.mopub.mobileads.CustomEventInterstitial;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.Map;
 
 /*
  * Tested with Greystripe SDK 2.4.0.
  */
 class GreystripeInterstitial extends CustomEventInterstitial implements GSAdListener {
-    public static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    private static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "GUID";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private GSFullscreenAd mGreystripeAd;
-    
+
     /*
      * Abstract methods from CustomEventInterstitial
      */
@@ -32,30 +38,33 @@ protected void loadInterstitial(final Context context,
                                     final Map<String, String> serverExtras) {
         mInterstitialListener = interstitialListener;
 
-        /*
-         * You may also pass this String down in the serverExtras Map by specifying Custom Event Data
-         * in MoPub's web interface.
-         */
         String greystripeAppId = DEFAULT_GREYSTRIPE_APP_ID;
-        
+        if (extrasAreValid(serverExtras)) {
+            greystripeAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         mGreystripeAd = new GSFullscreenAd(context, greystripeAppId);
         mGreystripeAd.addListener(this);
-        
+
         mGreystripeAd.fetch();
     }
 
+    private static boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     @Override
     protected void showInterstitial() {
         if (!mGreystripeAd.isAdReady()) {
             mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             return;
         }
-        
+
         Log.d("MoPub", "Showing Greystripe interstitial ad.");
         mGreystripeAd.display();
         mInterstitialListener.onInterstitialShown();
     }
-    
+
     @Override
     protected void onInvalidate() {
         mGreystripeAd.removeListener(this);
diff --git a/extras/src/com/mopub/mobileads/InMobiBanner.java b/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
similarity index 82%
rename from extras/src/com/mopub/mobileads/InMobiBanner.java
rename to extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
index ac22d974..b51fb04c 100644
--- a/extras/src/com/mopub/mobileads/InMobiBanner.java
+++ b/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+
 import com.inmobi.commons.InMobi;
 import com.inmobi.commons.InMobi.LOG_LEVEL;
 import com.inmobi.monetization.IMBanner;
@@ -12,19 +13,27 @@
 import com.mopub.mobileads.CustomEventBanner;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 /*
  * Tested with InMobi SDK 4.4.1
  */
 public class InMobiBanner extends CustomEventBanner implements IMBannerListener {
 
+    private static final String DEFAULT_APP_ID = "YOUR_INMOBI_APP_ID_HERE";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "app_id";
+
     @Override
     protected void loadBanner(Context context,
-                              CustomEventBannerListener bannerListener,
-                              Map<String, Object> localExtras, Map<String, String> serverExtras) {
+            CustomEventBannerListener bannerListener,
+            Map<String, Object> localExtras, Map<String, String> serverExtras) {
         mBannerListener = bannerListener;
-        String inMobiAppId = "YOUR_INMOBI_APP_ID";
+        String inMobiAppId = DEFAULT_APP_ID;
 
         Activity activity = null;
         if (context instanceof Activity) {
@@ -37,15 +46,16 @@ protected void loadBanner(Context context,
             mBannerListener.onBannerFailed(null);
             return;
         }
+
+        if (extrasAreValid(serverExtras)) {
+            inMobiAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         if (!isAppInitialized) {
             InMobi.initialize(activity, inMobiAppId);
             isAppInitialized = true;
         }
 
-		/*
-		 * You may also pass this String down in the serverExtras Map by
-		 * specifying Custom Event Data in MoPub's web interface.
-		 */
         iMBanner = new IMBanner(activity, inMobiAppId,
                 IMBanner.INMOBI_AD_UNIT_320X50);
 
@@ -60,13 +70,17 @@ protected void loadBanner(Context context,
 
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     private CustomEventBannerListener mBannerListener;
     private IMBanner iMBanner;
     private static boolean isAppInitialized = false;
 
-	/*
-	 * Abstract methods from CustomEventBanner
-	 */
+    /*
+     * Abstract methods from CustomEventBanner
+     */
 
     @Override
     public void onInvalidate() {
diff --git a/extras/src/com/mopub/mobileads/InMobiInterstitial.java b/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
similarity index 86%
rename from extras/src/com/mopub/mobileads/InMobiInterstitial.java
rename to extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
index 80f222d7..ad45e7d8 100644
--- a/extras/src/com/mopub/mobileads/InMobiInterstitial.java
+++ b/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+
 import com.inmobi.commons.InMobi;
 import com.inmobi.monetization.IMErrorCode;
 import com.inmobi.monetization.IMInterstitial;
@@ -10,19 +11,26 @@
 import com.mopub.mobileads.CustomEventInterstitial;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 /*
  * Tested with InMobi SDK  4.4.1
  */
 public class InMobiInterstitial extends CustomEventInterstitial implements IMInterstitialListener {
 
+    private static final String DEFAULT_APP_ID = "YOUR_INMOBI_APP_ID_HERE";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "app_id";
+
     @Override
     protected void loadInterstitial(Context context,
                                     CustomEventInterstitialListener interstitialListener,
                                     Map<String, Object> localExtras, Map<String, String> serverExtras) {
         mInterstitialListener = interstitialListener;
-        String inMobiAppId = "YOUR_INMOBI_APP_ID";
 
         Activity activity = null;
         if (context instanceof Activity) {
@@ -37,10 +45,11 @@ protected void loadInterstitial(Context context,
             return;
         }
 
-		/*
-		 * You may also pass this String down in the serverExtras Map by
-		 * specifying Custom Event Data in MoPub's web interface.
-		 */
+        String inMobiAppId = DEFAULT_APP_ID;
+        if (extrasAreValid(serverExtras)) {
+            inMobiAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         if (!isAppInitialized) {
             InMobi.initialize(activity, inMobiAppId);
             isAppInitialized = true;
@@ -55,13 +64,17 @@ protected void loadInterstitial(Context context,
         iMInterstitial.loadInterstitial();
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     private CustomEventInterstitialListener mInterstitialListener;
     private IMInterstitial iMInterstitial;
     private static boolean isAppInitialized = false;
 
-	/*
-	 * Abstract methods from CustomEventInterstitial
-	 */
+    /*
+     * Abstract methods from CustomEventInterstitial
+     */
 
     @Override
     public void showInterstitial() {
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..2cef46c6
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,2 @@
+org.gradle.jvmargs=-Xmx8192m -XX:MaxPermSize=2048m
+org.gradle.daemon=false
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 0087cd3b..30d399d8 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 51905da1..57375a65 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Aug 05 14:58:07 PDT 2014
+#Wed Jul 15 14:33:43 PDT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-bin.zip
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index 4d4616a1..b7942bc5 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,39 +1,39 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="18"
-      android:versionName="3.2.2">
+      android:versionCode="28"
+      android:versionName="3.11.0">
     <uses-sdk android:minSdkVersion="9"
-              android:targetSdkVersion="19"/>
+              android:targetSdkVersion="22"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
+
     <!-- For MRAID 2 -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application android:icon="@drawable/icon" android:label="@string/app_name">
 	    <activity android:name="com.mopub.simpleadsdemo.MoPubSampleActivity"
 	            android:label="@string/app_name"
-                android:configChanges="orientation">
+                android:configChanges="orientation|screenSize">
 	        <intent-filter>
 	            <action android:name="android.intent.action.MAIN" />
 	            <category android:name="android.intent.category.LAUNCHER" />
 	        </intent-filter>
 	    </activity>
         <activity android:name="com.mopub.mobileads.MoPubActivity"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.mobileads.MraidActivity"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.common.MoPubBrowser"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
 
         <meta-data android:name="com.google.android.gms.version"
                    android:value="@integer/google_play_services_version" />
-
     </application>
 
 </manifest>
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index 50be0c68..beca4a0b 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -1,25 +1,43 @@
+repositories {
+    jcenter()
+    flatDir {
+        dirs '../libs'
+    }
+}
+
 apply plugin: 'com.android.application'
 
 group = 'com.mopub'
-
-description = '''MoPub SDK'''
+description = '''MoPub Sample App'''
+version = '3.11.0'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
     defaultConfig {
-        versionCode 1
-        versionName "3.2.1"
+        versionCode 28
+        versionName version
         minSdkVersion 9
-        targetSdkVersion 19
+        targetSdkVersion 22
+    }
+
+    buildTypes {
+      release {
+        minifyEnabled true
+        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg'
+      }
+      debug {
+        minifyEnabled false
+        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg'
+      }
     }
 
     sourceSets {
         main {
             manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src/main']
-            resources.srcDirs = ['src/main']
+            java.srcDirs = ['src/main/java']
+            resources.srcDirs = ['src/main/java']
             aidl.srcDirs = ['src/main']
             renderscript.srcDirs = ['src/main']
             res.srcDirs = ['res']
@@ -36,7 +54,8 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:19.1.+'
-    compile 'com.google.android.gms:play-services:5.0.89'
+    compile 'com.android.support:support-v4:22.0.0'
+    compile 'com.google.android.gms:play-services-ads:7.0.0'
+    compile 'com.android.support:recyclerview-v7:22.0.0'
     compile project(':mopub-sdk')
 }
diff --git a/mopub-sample/pom.xml b/mopub-sample/pom.xml
index a1d02f01..3c112660 100644
--- a/mopub-sample/pom.xml
+++ b/mopub-sample/pom.xml
@@ -27,66 +27,28 @@
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
             <version>1.0.0-SNAPSHOT</version>
-            <type>jar</type>
+            <type>aar</type>
         </dependency>
 
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>support-v4</artifactId>
-            <version>19.1.0</version>
-            <type>jar</type>
-        </dependency>
-
-        <dependency>
-            <groupId>com.google.android.gms</groupId>
-            <artifactId>play-services</artifactId>
-            <version>5.0.89</version>
+            <version>22.0.0</version>
             <type>aar</type>
         </dependency>
 
-        <!--test-->
-
-        <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>fest-android</artifactId>
-            <version>1.0.1</version>
-            <scope>test</scope>
-        </dependency>
-
-        <!-- this needs to come above fest-reflect or we pick up the wrong org.fest.util.Strings -->
         <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-assert-core</artifactId>
-            <version>2.0M9</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-reflect</artifactId>
-            <version>1.4</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.8.2</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.mockito</groupId>
-            <artifactId>mockito-core</artifactId>
-            <version>1.9.5</version>
-            <scope>test</scope>
+            <groupId>com.android.support</groupId>
+            <artifactId>recyclerview-v7</artifactId>
+            <version>22.0.0</version>
+            <type>aar</type>
         </dependency>
-
+        
         <dependency>
-            <groupId>org.robolectric</groupId>
-            <artifactId>robolectric</artifactId>
-            <version>${robolectric.version}</version>
-            <scope>test</scope>
+            <groupId>com.google.android.gms</groupId>
+            <artifactId>play-services-ads</artifactId>
+            <version>7.0.0</version>
+            <type>aar</type>
         </dependency>
 
         <dependency> <groupId>com.google.android</groupId>
@@ -103,34 +65,39 @@
             <plugin>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>2.3.2</version>
+                <!-- Skip tests. We use Gradle to build and run tests. -->
+                <executions>
+                    <execution>
+                        <id>default-testCompile</id>
+                        <phase>test-compile</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                        <configuration>
+                            <skip>true</skip>
+                        </configuration>
+                    </execution>
+                </executions>
                 <configuration>
-                    <source>1.6</source>
-                    <target>1.6</target>
+                    <source>7</source>
+                    <target>7</target>
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
                 <extensions>true</extensions>
             </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.6</version>
-                <configuration>
-                    <excludes>
-                        <exclude>**/Test*.java</exclude>
-                    </excludes>
-                </configuration>
-            </plugin>
         </plugins>
     </build>
 </project>
diff --git a/mopub-sample/proguard.cfg b/mopub-sample/proguard.cfg
index c1f97c67..9b84b5cf 100644
--- a/mopub-sample/proguard.cfg
+++ b/mopub-sample/proguard.cfg
@@ -15,4 +15,23 @@
 # Support for Android Advertiser ID.
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
+-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
 
+# Support for Google Play Services
+# http://developer.android.com/google/play-services/setup.html
+-keep class * extends java.util.ListResourceBundle {
+    protected Object[][] getContents();
+}
+
+-keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable {
+    public static final *** NULL;
+}
+
+-keepnames @com.google.android.gms.common.annotation.KeepName class *
+-keepclassmembernames class * {
+    @com.google.android.gms.common.annotation.KeepName *;
+}
+
+-keepnames class * implements android.os.Parcelable {
+    public static final ** CREATOR;
+}
diff --git a/mopub-sample/res/layout/recycler_view_fragment.xml b/mopub-sample/res/layout/recycler_view_fragment.xml
new file mode 100644
index 00000000..0d04e5a9
--- /dev/null
+++ b/mopub-sample/res/layout/recycler_view_fragment.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical" android:layout_width="match_parent"
+              android:layout_height="match_parent">
+    <TextView
+        android:id="@+id/description"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:paddingTop="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorPrimary"
+        android:textSize="16sp"
+        android:textStyle="bold"/>
+
+    <TextView
+        android:id="@+id/ad_unit_id"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorSecondary"
+        android:textSize="14sp"
+        android:textStyle="normal"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+
+        <EditText
+            android:id="@+id/keywords_field"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="3"
+            android:hint="@string/keywords"
+            android:imeOptions="actionDone"
+            android:inputType="text|textFilter|textShortMessage"
+            android:singleLine="true"/>
+
+        <Button
+            android:id="@+id/load_button"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/load_ad"/>
+
+        <Button
+            android:id="@+id/switch_button"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/switch_layout"/>
+    </LinearLayout>
+
+    <android.support.v7.widget.RecyclerView
+        android:id="@+id/native_recycler_view"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="5dp" />
+
+</LinearLayout>
diff --git a/mopub-sample/res/values/strings.xml b/mopub-sample/res/values/strings.xml
index 6d5db0d9..4824d0b9 100644
--- a/mopub-sample/res/values/strings.xml
+++ b/mopub-sample/res/values/strings.xml
@@ -3,6 +3,8 @@
     <string name="app_name">MoPub Sample App</string>
     <string name="keywords">Keywords (optional)</string>
     <string name="load_ad">Load Ad</string>
+    <string name="refresh_ad">Refresh Ad</string>
+    <string name="switch_layout">Switch Layout</string>
     <string name="show_ad">Show Ad</string>
     <string name="native_icon_image">native_icon_image</string>
     <string name="native_main_image">native_main_image</string>
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
index 2314e718..10a1cd82 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
@@ -33,9 +33,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         views.mLoadButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
+                if (mMoPubInterstitial == null) {
+                    mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
+                    mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
+                }
                 final String keywords = views.mKeywordsField.getText().toString();
-                mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
-                mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
                 mMoPubInterstitial.setKeywords(keywords);
                 mMoPubInterstitial.load();
                 mShowButton.setEnabled(false);
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
new file mode 100644
index 00000000..22aa7e69
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
@@ -0,0 +1,85 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.MoPubErrorCode;
+
+import java.util.logging.Handler;
+import java.util.logging.LogManager;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+
+/**
+ * Used to intercept logs so that we can view logs at a lower level
+ * than Verbose (ie. Level.FINEST). This will show a toast when we
+ * receive a matching error from the mopub sdk.
+ */
+public class LoggingUtils {
+    private LoggingUtils() {
+    }
+
+    private static boolean sEnabled;
+
+    /**
+     * Makes it so that this app can intercept Level.FINEST log messages.
+     * This is not thread safe.
+     *
+     * @param context Needs a context to send toasts.
+     */
+    static void enableCanaryLogging(@NonNull final Context context) {
+        if (sEnabled) {
+            return;
+        }
+
+        // This makes sure the static block in MoPubLog is executed before
+        // LogManager#getLogManager is called.
+        MoPubLog.c("Canary level logging enabled");
+
+        final Handler handler = new SampleAppLogHandler(context.getApplicationContext());
+        final Logger logger = getLogger();
+        logger.addHandler(handler);
+
+        sEnabled = true;
+    }
+
+    private static Logger getLogger() {
+        return LogManager.getLogManager().getLogger(MoPubLog.LOGGER_NAMESPACE);
+    }
+
+    private static class SampleAppLogHandler extends Handler {
+
+        @NonNull
+        private final Context mContext;
+
+        protected SampleAppLogHandler(@NonNull final Context context) {
+            super();
+            mContext = context;
+        }
+
+        @Override
+        public void publish(final LogRecord logRecord) {
+            if (logRecord == null) {
+                return;
+            }
+            // Toasts the warmup message if X-Warmup flag is set to 1
+            if (MoPubErrorCode.WARMUP.toString().equals(logRecord.getMessage())) {
+                Utils.logToast(mContext, MoPubErrorCode.WARMUP.toString());
+            }
+            // Toasts the no connection message if a native response failed due to no internet
+            if (MoPubErrorCode.NO_CONNECTION.toString().equals(logRecord.getMessage())) {
+                Utils.logToast(mContext, MoPubErrorCode.NO_CONNECTION.toString());
+            }
+        }
+
+        @Override
+        public void flush() {
+        }
+
+        @Override
+        public void close() throws SecurityException {
+        }
+    }
+}
+
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
index 35f1862b..af774f91 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
@@ -13,6 +13,7 @@
 import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.CUSTOM_NATIVE;
 import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.INTERSTITIAL;
 import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.LIST_VIEW;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.RECYCLER_VIEW;
 import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.MRECT;
 
 class MoPubSQLiteHelper extends SQLiteOpenHelper {
@@ -24,7 +25,7 @@
     public static final String COLUMN_AD_TYPE = "adType";
 
     private static final String DATABASE_NAME = "savedConfigurations.db";
-    private static final int DATABASE_VERSION = 1;
+    private static final int DATABASE_VERSION = 3;
 
     private static final String DATABASE_CREATE = "create table " + TABLE_AD_CONFIGURATIONS
             + " ("
@@ -69,6 +70,11 @@ public void onCreate(SQLiteDatabase sqLiteDatabase) {
                         .Builder(mContext.getString(R.string.ad_unit_id_native), LIST_VIEW)
                         .description("MoPub Ad Placer Sample")
                         .build());
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_native), RECYCLER_VIEW)
+                        .description("MoPub Recycler View Sample")
+                        .build());
         adUnitList.add(
                 new MoPubSampleAdUnit
                         .Builder(mContext.getString(R.string.ad_unit_id_native), CUSTOM_NATIVE)
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
index f2ba89bc..8322b4ac 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
@@ -1,13 +1,29 @@
 package com.mopub.simpleadsdemo;
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.webkit.WebView;
 
 import com.mopub.common.MoPub;
 
 
 public class MoPubSampleActivity extends FragmentActivity {
+
+    // Sample app web views are debuggable.
+    static {
+        setWebDebugging();
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private static void setWebDebugging() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            WebView.setWebContentsDebuggingEnabled(true);
+        }
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -29,5 +45,9 @@ protected void onCreate(Bundle savedInstanceState) {
                     .add(R.id.fragment_container, listFragment)
                     .commit();
         }
+
+        // Intercepts all logs including Level.FINEST so we can show a toast
+        // that is not normally user-facing. This is only used for native ads.
+        LoggingUtils.enableCanaryLogging(this);
     }
 }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
index dfeacd95..724656ff 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
@@ -1,6 +1,7 @@
 package com.mopub.simpleadsdemo;
 
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 
 import java.util.Comparator;
@@ -18,7 +19,9 @@
         BANNER("Banner", BannerDetailFragment.class),
         MRECT("Mrect", MrectDetailFragment.class),
         INTERSTITIAL("Interstitial", InterstitialDetailFragment.class),
+        REWARDED_VIDEO("Rewarded Video", RewardedVideoDetailFragment.class),
         LIST_VIEW("Native List View", NativeListViewFragment.class),
+        RECYCLER_VIEW("Native Recycler View", NativeRecyclerViewFragment.class),
         CUSTOM_NATIVE("Native Gallery (Custom Stream)", NativeGalleryFragment.class);
 
         String getName() {
@@ -158,7 +161,7 @@ static MoPubSampleAdUnit fromBundle(final Bundle bundle) {
     }
 
     @Override
-    public int compareTo(MoPubSampleAdUnit that) {
+    public int compareTo(@NonNull MoPubSampleAdUnit that) {
         if (mAdType != that.mAdType) {
             return mAdType.ordinal() - that.mAdType.ordinal();
         }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
index ede4745c..42b2ba38 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
@@ -13,7 +13,6 @@
 import android.widget.TextView;
 
 import com.mopub.nativeads.MoPubNativeAdLoadedListener;
-import com.mopub.nativeads.MoPubNativeAdPositioning;
 import com.mopub.nativeads.MoPubNativeAdRenderer;
 import com.mopub.nativeads.MoPubStreamAdPlacer;
 import com.mopub.nativeads.RequestParameters;
@@ -69,12 +68,9 @@ public void onClick(View view) {
         views.mDescriptionView.setText(mAdConfiguration.getDescription());
         views.mAdUnitIdView.setText(adUnitId);
         mViewPager = (ViewPager) view.findViewById(R.id.gallery_pager);
-        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity(),
-                MoPubNativeAdPositioning.clientPositioning()
-                        .addFixedPosition(4)
-                        .addFixedPosition(1)
-                        .enableRepeatingPositions(3)
-        );
+
+        // This ad placer is used to automatically insert ads into the ViewPager.
+        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity());
         final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
                 new ViewBinder.Builder(R.layout.native_ad_list_item)
                         .titleId(R.id.native_title)
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
index ba042047..5c48fe32 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
@@ -10,7 +10,6 @@
 import android.widget.ListView;
 
 import com.mopub.nativeads.MoPubAdAdapter;
-import com.mopub.nativeads.MoPubNativeAdPositioning;
 import com.mopub.nativeads.MoPubNativeAdRenderer;
 import com.mopub.nativeads.RequestParameters;
 import com.mopub.nativeads.ViewBinder;
@@ -69,12 +68,9 @@ public void onClick(View view) {
             adapter.add("Item " + i);
         }
 
-        // Create an ad adapter with ads in positions 0, 4, and every 10 places thereafter.
+        // Create an ad adapter that gets its positioning information from the MoPub Ad Server.
         // This adapter will be used in place of the original adapter for the ListView.
-        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter, MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(0)
-                .addFixedPosition(4)
-                .enableRepeatingPositions(10));
+        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter);
 
         // Set up an renderer that knows how to put ad data in an ad view.
         final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java
new file mode 100644
index 00000000..29feeac4
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java
@@ -0,0 +1,154 @@
+package com.mopub.simpleadsdemo;
+
+
+import android.location.Location;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.Fragment;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.TextView;
+
+import com.mopub.nativeads.MoPubNativeAdPositioning;
+import com.mopub.nativeads.MoPubRecyclerAdapter;
+import com.mopub.nativeads.RequestParameters;
+import com.mopub.nativeads.ViewBinder;
+
+import java.util.EnumSet;
+import java.util.Locale;
+
+public class NativeRecyclerViewFragment extends Fragment {
+    private MoPubRecyclerAdapter mRecyclerAdapter;
+    private MoPubSampleAdUnit mAdConfiguration;
+    private RequestParameters mRequestParameters;
+    private enum LayoutType { LINEAR, GRID };
+    private LayoutType mLayoutType;
+    private RecyclerView mRecyclerView;
+
+    @Override
+    public View onCreateView(final LayoutInflater inflater, @Nullable final ViewGroup container,
+            @Nullable final Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+
+        mAdConfiguration = MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.recycler_view_fragment, container, false);
+        mRecyclerView = (RecyclerView) view.findViewById(R.id.native_recycler_view);
+        final DetailFragmentViewHolder viewHolder = DetailFragmentViewHolder.fromView(view);
+        final Button switchButton = (Button) view.findViewById(R.id.switch_button);
+        switchButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(final View v) {
+                toggleRecyclerLayout();
+            }
+        });
+
+        viewHolder.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(final View v) {
+                // If your app already has location access, include it here.
+                final Location location = null;
+                final String keywords = viewHolder.mKeywordsField.getText().toString();
+
+                // Setting desired assets on your request helps native ad networks and bidders
+                // provide higher-quality ads.
+                final EnumSet<RequestParameters.NativeAdAsset> desiredAssets = EnumSet.of(
+                        RequestParameters.NativeAdAsset.TITLE,
+                        RequestParameters.NativeAdAsset.TEXT,
+                        RequestParameters.NativeAdAsset.ICON_IMAGE,
+                        RequestParameters.NativeAdAsset.MAIN_IMAGE,
+                        RequestParameters.NativeAdAsset.CALL_TO_ACTION_TEXT);
+
+                mRequestParameters = new RequestParameters.Builder()
+                        .location(location)
+                        .keywords(keywords)
+                        .desiredAssets(desiredAssets)
+                        .build();
+
+                if (mRecyclerAdapter != null) {
+                    mRecyclerAdapter.refreshAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
+                }
+            }
+        });
+        final String adUnitId = mAdConfiguration.getAdUnitId();
+        viewHolder.mDescriptionView.setText(mAdConfiguration.getDescription());
+        viewHolder.mAdUnitIdView.setText(adUnitId);
+
+        final RecyclerView.Adapter originalAdapter = new DemoRecyclerAdapter();
+
+        mRecyclerAdapter = new MoPubRecyclerAdapter(getActivity(), originalAdapter,
+                new MoPubNativeAdPositioning.MoPubServerPositioning());
+        mRecyclerAdapter.registerViewBinder(new ViewBinder.Builder(R.layout.native_ad_list_item)
+                .titleId(R.id.native_title)
+                .textId(R.id.native_text)
+                .mainImageId(R.id.native_main_image)
+                .iconImageId(R.id.native_icon_image)
+                .callToActionId(R.id.native_cta)
+                .build());
+
+        mRecyclerView.setAdapter(mRecyclerAdapter);
+        mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
+        mLayoutType = LayoutType.LINEAR;
+        mRecyclerAdapter.loadAds(mAdConfiguration.getAdUnitId());
+        return view;
+    }
+
+    void toggleRecyclerLayout() {
+        if (mLayoutType == LayoutType.LINEAR) {
+            mLayoutType = LayoutType.GRID;
+            mRecyclerView.setLayoutManager(new GridLayoutManager(getActivity(), 2));
+        } else {
+            mLayoutType = LayoutType.LINEAR;
+            mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
+        }
+    }
+
+    @Override
+    public void onDestroyView() {
+        // You must call this or the ad adapter may cause a memory leak.
+        mRecyclerAdapter.destroy();
+        super.onDestroyView();
+    }
+
+    private static class DemoRecyclerAdapter extends RecyclerView.Adapter<DemoViewHolder> {
+        private static final int ITEM_COUNT = 150;
+        @Override
+        public DemoViewHolder onCreateViewHolder(final ViewGroup parent,
+                final int viewType) {
+            final View itemView = LayoutInflater.from(parent.getContext())
+                    .inflate(android.R.layout.simple_list_item_1, parent, false);
+            return new DemoViewHolder(itemView);
+        }
+
+        @Override
+        public void onBindViewHolder(final DemoViewHolder holder, final int position) {
+            holder.textView.setText(String.format(Locale.US, "Content Item #%d", position));
+        }
+
+        @Override
+        public long getItemId(final int position) {
+            return (long) position;
+        }
+
+        @Override
+        public int getItemCount() {
+            return ITEM_COUNT;
+        }
+    }
+
+    /**
+     * A view holder for R.layout.simple_list_item_1
+     */
+    private static class DemoViewHolder extends RecyclerView.ViewHolder {
+        public final TextView textView;
+
+        public DemoViewHolder(final View itemView) {
+            super(itemView);
+            textView = (TextView) itemView.findViewById(android.R.id.text1);
+        }
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
new file mode 100644
index 00000000..16eaed98
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
@@ -0,0 +1,107 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+
+import java.util.Locale;
+import java.util.Set;
+
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public class RewardedVideoDetailFragment extends Fragment implements MoPubRewardedVideoListener {
+
+    private Button mShowButton;
+    private static boolean rewardedVideoInitialized;
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        final MoPubSampleAdUnit adConfiguration =
+                MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.interstitial_detail_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        hideSoftKeyboard(views.mKeywordsField);
+
+        if (!rewardedVideoInitialized) {
+            MoPub.initializeRewardedVideo(getActivity());
+            rewardedVideoInitialized = true;
+        }
+        MoPub.setRewardedVideoListener(this);
+
+        final String adUnitId = adConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(adConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                MoPub.loadRewardedVideo(adUnitId);
+                mShowButton.setEnabled(false);
+            }
+        });
+        mShowButton = (Button) view.findViewById(R.id.interstitial_show_button);
+        mShowButton.setEnabled(false);
+        mShowButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                MoPub.showRewardedVideo(adUnitId);
+            }
+        });
+
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+
+    // MoPubRewardedVideoListener implementation
+    @Override
+    public void onRewardedVideoLoadSuccess(@NonNull final String adUnitId) {
+        mShowButton.setEnabled(true);
+        logToast(getActivity(), "Rewarded video loaded.");
+    }
+
+    @Override
+    public void onRewardedVideoLoadFailure(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        mShowButton.setEnabled(false);
+        logToast(getActivity(), String.format(Locale.US, "Rewarded video failed to load: %s", errorCode.toString()));
+    }
+
+    @Override
+    public void onRewardedVideoStarted(@NonNull final String adUnitId) {
+        logToast(getActivity(), "Rewarded video started.");
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoPlaybackError(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        logToast(getActivity(), String.format(Locale.US, "Rewarded video playback error: %s", errorCode.toString()));
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoClosed(@NonNull final String adUnitId) {
+        logToast(getActivity(), "Rewarded video closed.");
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoCompleted(@NonNull final Set<String> adUnitIds, @NonNull final MoPubReward reward) {
+        logToast(getActivity(),
+                String.format(Locale.US,
+                        "Rewarded video completed with reward  \"%d %s\"",
+                        reward.getAmount(),
+                        reward.getLabel()));
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
index f63af8fe..734e777b 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
@@ -35,6 +35,9 @@ static boolean isAlphaNumeric(final String input) {
 
     static void logToast(Context context, String message) {
         Log.d(LOGTAG, message);
-        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
+
+        if (context != null) {
+            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
+        }
     }
 }
diff --git a/mopub-sample/src/test/java/com/mopub/mobileads/test/support/SimpleAdsDemoTestRunner.java b/mopub-sample/src/test/java/com/mopub/mobileads/test/support/SimpleAdsDemoTestRunner.java
deleted file mode 100644
index 2bcaee0e..00000000
--- a/mopub-sample/src/test/java/com/mopub/mobileads/test/support/SimpleAdsDemoTestRunner.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import org.junit.runners.model.InitializationError;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.DefaultTestLifecycle;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.TestLifecycle;
-
-public class SimpleAdsDemoTestRunner extends RobolectricTestRunner {
-
-    public SimpleAdsDemoTestRunner(Class<?> testClass) throws InitializationError {
-        super(testClass);
-    }
-
-    @Override
-    protected Class<? extends TestLifecycle> getTestLifecycleClass() {
-        return TestLifeCycleWithInjection.class;
-    }
-
-    public static class TestLifeCycleWithInjection extends DefaultTestLifecycle {
-        @Override
-        public void prepareTest(Object test) {
-            MockitoAnnotations.initMocks(test);
-        }
-    }
-}
diff --git a/mopub-sample/src/test/resources/org.robolectric.Config.properties b/mopub-sample/src/test/resources/org.robolectric.Config.properties
new file mode 100644
index 00000000..ce97d608
--- /dev/null
+++ b/mopub-sample/src/test/resources/org.robolectric.Config.properties
@@ -0,0 +1 @@
+shadows=com.mopub.nativeads.test.support.MoPubShadowDisplay,com.mopub.nativeads.test.support.MoPubShadowBitmap
diff --git a/mopub-sdk/.classpath b/mopub-sdk/.classpath
index 3b278178..96ffc045 100644
--- a/mopub-sdk/.classpath
+++ b/mopub-sdk/.classpath
@@ -5,6 +5,8 @@
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="lib" path="C:/Users/Stagiaire/Documents/adt-bundle-windows-x86-20140624/adt-bundle-windows-x86-20140624/sdk/extras/android/support/v4/android-support-v4.jar"/>
+	<classpathentry kind="lib" path="D:/SDK/Android/adt-bundle-windows-x86-20140624/sdk/extras/android/support/v4/android-support-v4.jar"/>
+	<classpathentry kind="lib" path="_ExternalLibs_/mopub-volley-1.1.0.jar"/>
+	<classpathentry kind="lib" path="D:/SDK/Android/adt-bundle-windows-x86-20140624/sdk/extras/android/support/v7/recyclerview/libs/android-support-v7-recyclerview.jar"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/mopub-sdk/AndroidManifest.xml b/mopub-sdk/AndroidManifest.xml
index 22ac7cb1..42216cc5 100644
--- a/mopub-sdk/AndroidManifest.xml
+++ b/mopub-sdk/AndroidManifest.xml
@@ -1,9 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-		package="com.mopub.mobileads"
-		android:versionCode="1"
-		android:versionName="1.0">
-	<uses-sdk
+    package="com.mopub.mobileads"
+    android:versionCode="1"
+    android:versionName="1.0">
+    <uses-sdk
         android:minSdkVersion="9"
-        android:targetSdkVersion="19"/>
-</manifest>
\ No newline at end of file
+        android:targetSdkVersion="22"/>
+    <application/>
+</manifest>
+
diff --git a/mopub-sdk/_ExternalLibs_/mopub-volley-1.1.0.jar b/mopub-sdk/_ExternalLibs_/mopub-volley-1.1.0.jar
new file mode 100644
index 00000000..329e5a65
Binary files /dev/null and b/mopub-sdk/_ExternalLibs_/mopub-volley-1.1.0.jar differ
diff --git a/mopub-sdk/bin/mopub-sdk.jar b/mopub-sdk/bin/mopub-sdk.jar
index cd10d246..1211d301 100644
Binary files a/mopub-sdk/bin/mopub-sdk.jar and b/mopub-sdk/bin/mopub-sdk.jar differ
diff --git a/mopub-sdk/build.gradle b/mopub-sdk/build.gradle
index b0fea303..e5da0ca6 100644
--- a/mopub-sdk/build.gradle
+++ b/mopub-sdk/build.gradle
@@ -1,24 +1,51 @@
 // This buildscript will assemble the MoPub SDK into an AAR.
 
+buildscript {
+    repositories {
+        mavenCentral()
+        jcenter()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.2.3'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
+        classpath 'org.robolectric:robolectric-gradle-plugin:1.1.0'
+    }
+}
+
+plugins {
+    id "com.jfrog.bintray" version "1.2"
+}
+
 repositories {
     mavenCentral()
+    jcenter()
+    flatDir {
+         dirs '../libs'
+    }
 }
 
 apply plugin: 'com.android.library'
+apply plugin: 'com.github.dcendents.android-maven'
+apply plugin: 'org.robolectric'
 
-group = 'com.mopub'
+task wrapper(type: Wrapper) {
+    gradleVersion = '2.5'
+}
 
-description = '''MoPub SDK'''
+group = 'com.mopub'
+description = '''MoPub Android SDK'''
+version = '3.11.0'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
     defaultConfig {
-        versionCode 1
-        versionName "3.2.2"
+        versionCode 28
+        versionName version
         minSdkVersion 9
-        targetSdkVersion 19
+        targetSdkVersion 22
         consumerProguardFiles 'proguard.txt'
     }
 
@@ -34,11 +61,33 @@ android {
         }
     }
 
+    testOptions {
+        unitTests {
+            // This causes android platform methods from the test JAR
+            // to return null, false, etc instead of throwing an exception.
+            // We should periodically disable this and tackle the broken tests
+            // as it exposes when we are hitting platform APIs in our tests.
+            // If these tests *require* platform APIs we may want to make them
+            // connected tests instead.
+            returnDefaultValues = true
+
+            // Test JVM settings since we have a lot of classes loaded.
+            all {
+                jvmArgs '-XX:MaxPermSize=4096m', '-Xmx8192m'
+                forkEvery 200
+            }
+        }
+    }
+
     buildTypes {
         release {
-            runProguard false
+            minifyEnabled false
             proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
         }
+      
+        debug {
+            minifyEnabled false
+        }
     }
 
     // Note: You will also need a local.properties file to set the location of the SDK in the same 
@@ -47,11 +96,121 @@ android {
     // difference between the two methods, you can use the one you prefer.
 }
 
+
 dependencies {
-    compile 'com.android.support:support-v4:19.1.+'
+    compile 'com.android.support:support-v4:22.0.0'
+    compile 'com.android.support:support-annotations:22.0.0'
+    compile 'com.android.support:recyclerview-v7:22.0.0'
+    compile 'com.mopub.volley:mopub-volley:1.1.0'
+    // anchor: additional dependencies
+
+    testCompile 'junit:junit:4.10'
+    testCompile 'org.robolectric:robolectric:2.4'
+    testCompile 'com.squareup:fest-android:1.0.7'
+    testCompile 'org.mockito:mockito-core:1.9.5'
 }
 
-// Don't run the Robolectric Unit Tests. They don't build properly in Gradle or Android Studio in this version.
-check.dependsOn.remove("test")
-check.dependsOn.remove("testDebug")
+def siteUrl = 'https://github.com/mopub/mopub-android-sdk'
+def gitUrl = 'https://github.com/mopub/mopub-android-sdk.git'
+// Put your credentials (bintray.user, bintray.apikey) in ~/.gradle/gradle.properties
+bintray {
+    user = project.hasProperty("bintray.user") ? project.getProperty("bintray.user") : ""
+    key = project.hasProperty("bintray.apikey") ? project.getProperty("bintray.apikey") : ""
+
+    configurations = ['archives']
+    publish = true
+
+    pkg {
+        repo = 'mopub-android-sdk'
+        name = 'mopub-android-sdk'
 
+        userOrg = 'mopub'
+        desc = description
+
+        websiteUrl = siteUrl
+        vcsUrl = gitUrl
+        licenses = ['Apache-2.0']
+
+        version {
+            name = project.version
+        }
+    }
+}
+
+install {
+    repositories.mavenInstaller {
+        pom {
+            project {
+                packaging 'aar'
+
+                name 'MoPub Android SDK'
+                url siteUrl
+
+                licenses {
+                    license {
+                        name 'MoPub SDK License'
+                        url 'http://www.mopub.com/legal/sdk-license-agreement/'
+                    }
+                }
+                developers {
+                    // ID corresponds to GitHub user name
+                    developer {
+                        id 'nathanshayefar'
+                        name 'Nathan Shayefar'
+                        email 'nshayefar@twitter.com'
+                    }
+                    developer {
+                        id 'joeblubaugh'
+                        name 'Joe Blubaugh'
+                        email 'joeblubaugh@twitter.com'
+                    }
+                    developer {
+                        id 'steffanc'
+                        name 'Steffan Chartrand'
+                        email 'schartrand@twitter.com'
+                    }
+                    developer {
+                        id 'aornelas'
+                        name 'Andrs Ornelas'
+                        email 'andres@twitter.com'
+                    }
+                    developer {
+                        id 'bichenwang'
+                        name 'Bichen Wang'
+                        email 'bwang@twitter.com'
+                    }
+                    developer {
+                        id 'nathank33'
+                        name 'Nathan Braun'
+                        email 'nbraun@twitter.com'
+                    }
+                }
+                scm {
+                    connection gitUrl
+                    developerConnection gitUrl
+                    url siteUrl
+                }
+            }
+        }
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+task javadoc(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+
+artifacts {
+    archives javadocJar
+    archives sourcesJar
+}
diff --git a/mopub-sdk/etc/mraid.js b/mopub-sdk/etc/mraid.js
index 1dff72b6..7ce13b28 100644
--- a/mopub-sdk/etc/mraid.js
+++ b/mopub-sdk/etc/mraid.js
@@ -13,63 +13,48 @@
   }
 }());
 
-(function() {
-  // Establish the root mraidbridge object.
-  var mraidbridge = window.mraidbridge = {};
-
-  // native SDK is ready to process mraid commands.
-  var nativeSDKFiredReady = false;
-
-  // Listeners for bridge events.
-  var listeners = {};
-
-  // Queue to track pending calls to the native SDK.
-  var nativeCallQueue = [];
 
-  // Whether a native call is currently in progress.
-  var nativeCallInFlight = false;
+(function() {
+  var mraid = window.mraid = {};
 
   //////////////////////////////////////////////////////////////////////////////////////////////////
 
-  mraidbridge.fireReadyEvent = function() {
-    nativeSDKFiredReady = true;
-    mraidbridge.fireEvent('ready');
-  };
+  // Bridge interface to SDK
 
-  mraidbridge.fireChangeEvent = function(properties) {
-    mraidbridge.fireEvent('change', properties);
+  var bridge = window.mraidbridge = {
+    nativeSDKFiredReady: false,
+    nativeCallQueue: [],
+    nativeCallInFlight: false,
+    lastSizeChangeProperties: null
   };
 
-  mraidbridge.fireErrorEvent = function(message, action) {
-    mraidbridge.fireEvent('error', message, action);
-  };
 
-  mraidbridge.fireEvent = function(type) {
-    var ls = listeners[type];
-    if (ls) {
-      var args = Array.prototype.slice.call(arguments);
-      args.shift();
-      var l = ls.length;
-      for (var i = 0; i < l; i++) {
-        ls[i].apply(null, args);
+  bridge.fireChangeEvent = function(properties) {
+    for (var p in properties) {
+      if (properties.hasOwnProperty(p)) {
+        // Change handlers defined by MRAID below
+        var handler = changeHandlers[p];
+        handler(properties[p]);
       }
     }
   };
 
-  mraidbridge.nativeCallComplete = function(command) {
-    if (nativeCallQueue.length === 0) {
-      nativeCallInFlight = false;
+  bridge.nativeCallComplete = function(command) {
+    if (this.nativeCallQueue.length === 0) {
+      this.nativeCallInFlight = false;
       return;
     }
 
-    var nextCall = nativeCallQueue.pop();
+    var nextCall = this.nativeCallQueue.pop();
     window.location = nextCall;
   };
 
-  mraidbridge.executeNativeCall = function(command) {
-    if (!nativeSDKFiredReady) {
+  bridge.executeNativeCall = function(args) {
+    var command = args.shift();
+
+    if (!this.nativeSDKFiredReady) {
         console.log('rejecting ' + command + ' because mraid is not ready');
-        mraidbridge.fireErrorEvent('mraid is not ready', command);
+        bridge.notifyErrorEvent('mraid is not ready', command);
         return;
     }
 
@@ -78,9 +63,9 @@
     var key, value;
     var isFirstArgument = true;
 
-    for (var i = 1; i < arguments.length; i += 2) {
-      key = arguments[i];
-      value = arguments[i + 1];
+    for (var i = 0; i < args.length; i += 2) {
+      key = args[i];
+      value = args[i + 1];
 
       if (value === null) continue;
 
@@ -94,55 +79,133 @@
       call += encodeURIComponent(key) + '=' + encodeURIComponent(value);
     }
 
-    if (nativeCallInFlight) {
-      nativeCallQueue.push(call);
+    if (this.nativeCallInFlight) {
+      this.nativeCallQueue.push(call);
     } else {
-      nativeCallInFlight = true;
+      this.nativeCallInFlight = true;
       window.location = call;
     }
   };
 
-  //////////////////////////////////////////////////////////////////////////////////////////////////
 
-  mraidbridge.addEventListener = function(event, listener) {
-    var eventListeners;
-    listeners[event] = listeners[event] || [];
-    eventListeners = listeners[event];
+  bridge.setCurrentPosition = function(x, y, width, height) {
+    currentPosition = {
+      x: x,
+      y: y,
+      width: width,
+      height: height
+    };
+    broadcastEvent(EVENTS.INFO, 'Set current position to ' + stringify(currentPosition));
+  };
+
+  bridge.setDefaultPosition = function(x, y, width, height) {
+    defaultPosition = {
+      x: x,
+      y: y,
+      width: width,
+      height: height
+    };
+    broadcastEvent(EVENTS.INFO, 'Set default position to ' + stringify(defaultPosition));
+  };
+  
+  bridge.setMaxSize = function(width, height) {
+    maxSize = {
+      width: width,
+      height: height
+    };
+
+    expandProperties.width = width;
+    expandProperties.height = height;
+
+    broadcastEvent(EVENTS.INFO, 'Set max size to ' + stringify(maxSize));
+  };
 
-    for (var l in eventListeners) {
-      // Listener already registered, so no need to add it.
-      if (listener === l) return;
+  bridge.setPlacementType = function(_placementType) {
+    placementType = _placementType;
+    broadcastEvent(EVENTS.INFO, 'Set placement type to ' + stringify(placementType));
+  };
+
+  bridge.setScreenSize = function(width, height) {
+    screenSize = {
+      width: width,
+      height: height
+    };
+    broadcastEvent(EVENTS.INFO, 'Set screen size to ' + stringify(screenSize));
+  };
+
+  bridge.setState = function(_state) {
+    state = _state;
+    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));
+    broadcastEvent(EVENTS.STATECHANGE, state);
+  };
+
+  bridge.setIsViewable = function(_isViewable) {
+    isViewable = _isViewable;
+    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));
+    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);
+  };
+
+  bridge.setSupports = function(sms, tel, calendar, storePicture, inlineVideo) {
+    supportProperties = {
+      sms: sms,
+      tel: tel,
+      calendar: calendar,
+      storePicture: storePicture,
+      inlineVideo: inlineVideo
+    };
+  };
+
+  bridge.notifyReadyEvent = function() {
+    this.nativeSDKFiredReady = true;
+    broadcastEvent(EVENTS.READY);
+  };
+
+  bridge.notifyErrorEvent = function(message, action) {
+    broadcastEvent(EVENTS.ERROR, message, action);
+  };
+
+  // Temporary aliases while we migrate to the new API
+  bridge.fireReadyEvent = bridge.notifyReadyEvent;
+  bridge.fireErrorEvent = bridge.notifyErrorEvent;
+
+  bridge.notifySizeChangeEvent = function(width, height) {
+    if (this.lastSizeChangeProperties &&
+          width == this.lastSizeChangeProperties.width && height == this.lastSizeChangeProperties.height) {
+      return;
     }
 
-    eventListeners.push(listener);
+    this.lastSizeChangeProperties = {
+        width: width,
+        height: height
+    };
+    broadcastEvent(EVENTS.SIZECHANGE, width, height);
   };
 
-  mraidbridge.removeEventListener = function(event, listener) {
-    if (listeners.hasOwnProperty(event)) {
-      var eventListeners = listeners[event];
-      if (eventListeners) {
-        var idx = eventListeners.indexOf(listener);
-        if (idx !== -1) {
-          eventListeners.splice(idx, 1);
-        }
-      }
+  bridge.notifyStateChangeEvent = function() {
+    if (state === STATES.LOADING) {
+      broadcastEvent(EVENTS.INFO, 'Native SDK initialized.');
     }
+
+    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));
+    broadcastEvent(EVENTS.STATECHANGE, state);
+  };
+
+  bridge.notifyViewableChangeEvent = function() {
+    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));
+    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);
   };
-}());
 
-(function() {
-  var mraid = window.mraid = {};
-  var bridge = window.mraidbridge;
 
   // Constants. ////////////////////////////////////////////////////////////////////////////////////
 
-  var VERSION = mraid.VERSION = '1.0';
+  var VERSION = mraid.VERSION = '2.0';
 
   var STATES = mraid.STATES = {
-    LOADING: 'loading',     // Initial state.
+    LOADING: 'loading',
     DEFAULT: 'default',
     EXPANDED: 'expanded',
-    HIDDEN: 'hidden'
+    HIDDEN: 'hidden',
+    RESIZED: 'resized'
   };
 
   var EVENTS = mraid.EVENTS = {
@@ -150,7 +213,8 @@
     INFO: 'info',
     READY: 'ready',
     STATECHANGE: 'stateChange',
-    VIEWABLECHANGE: 'viewableChange'
+    VIEWABLECHANGE: 'viewableChange',
+    SIZECHANGE: 'sizeChange'
   };
 
   var PLACEMENT_TYPES = mraid.PLACEMENT_TYPES = {
@@ -163,14 +227,44 @@
 
   // Properties which define the behavior of an expandable ad.
   var expandProperties = {
-    width: -1,
-    height: -1,
+    width: false,
+    height: false,
     useCustomClose: false,
-    isModal: true,
-    lockOrientation: false
+    isModal: true
   };
 
-  var hasSetCustomSize = false;
+  var resizeProperties = {
+    width: false, 
+    height: false,
+    offsetX: false, 
+    offsetY: false,
+    customClosePosition: 'top-right',
+    allowOffscreen: true
+  };
+
+  var orientationProperties = {
+    allowOrientationChange: true,
+    forceOrientation: "none"
+  };
+
+  var supportProperties = {
+    sms: false,
+    tel: false,
+    calendar: false,
+    storePicture: false,
+    inlineVideo: false
+  };
+
+  // default is undefined so that notifySizeChangeEvent can track changes
+  var lastSizeChangeProperties;
+
+  var maxSize = {};
+
+  var currentPosition = {};
+
+  var defaultPosition = {};
+
+  var screenSize = {};
 
   var hasSetCustomClose = false;
 
@@ -182,18 +276,8 @@
 
   var isViewable = false;
 
-  var screenSize = { width: -1, height: -1 };
-
   var placementType = PLACEMENT_TYPES.UNKNOWN;
 
-  var supports = {
-    sms: false,
-    tel: false,
-    calendar: false,
-    storePicture: false,
-    inlineVideo: false
-  };
-
   //////////////////////////////////////////////////////////////////////////////////////////////////
 
   var EventListeners = function(event) {
@@ -229,7 +313,7 @@
 
     this.broadcast = function(args) {
       for (var id in listeners) {
-        if (listeners.hasOwnProperty(id)) listeners[id].apply({}, args);
+        if (listeners.hasOwnProperty(id)) listeners[id].apply(mraid, args);
       }
     };
 
@@ -305,29 +389,17 @@
       placementType = val;
     },
 
-    screenSize: function(val) {
+    sizeChange: function(val) {
       broadcastEvent(EVENTS.INFO, 'Set screenSize to ' + stringify(val));
       for (var key in val) {
         if (val.hasOwnProperty(key)) screenSize[key] = val[key];
       }
-
-      if (!hasSetCustomSize) {
-        expandProperties['width'] = screenSize['width'];
-        expandProperties['height'] = screenSize['height'];
-      }
-    },
-
-    expandProperties: function(val) {
-      broadcastEvent(EVENTS.INFO, 'Merging expandProperties with ' + stringify(val));
-      for (var key in val) {
-        if (val.hasOwnProperty(key)) expandProperties[key] = val[key];
-      }
     },
 
     supports: function(val) {
       broadcastEvent(EVENTS.INFO, 'Set supports to ' + stringify(val));
-        supports = val;
-    },
+        supportProperties = val;
+    }
   };
 
   var validate = function(obj, validators, action, merge) {
@@ -339,7 +411,7 @@
       } else {
         for (var i in validators) {
           if (validators.hasOwnProperty(i) && obj[i] === undefined) {
-            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i + '.', action);
+            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i, action);
             return false;
           }
         }
@@ -351,8 +423,7 @@
       var value = obj[prop];
       if (validator && !validator(value)) {
         // Failed validation.
-        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid.',
-          action);
+        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid: ' + value, action);
         return false;
       }
     }
@@ -360,40 +431,20 @@
   };
 
   var expandPropertyValidators = {
-    width: function(v) { return !isNaN(v) && v >= 0; },
-    height: function(v) { return !isNaN(v) && v >= 0; },
     useCustomClose: function(v) { return (typeof v === 'boolean'); },
-    lockOrientation: function(v) { return (typeof v === 'boolean'); }
   };
 
   //////////////////////////////////////////////////////////////////////////////////////////////////
 
-  bridge.addEventListener('change', function(properties) {
-    for (var p in properties) {
-      if (properties.hasOwnProperty(p)) {
-        var handler = changeHandlers[p];
-        handler(properties[p]);
-      }
-    }
-  });
-
-  bridge.addEventListener('error', function(message, action) {
-    broadcastEvent(EVENTS.ERROR, message, action);
-  });
-
-  bridge.addEventListener('ready', function() {
-    broadcastEvent(EVENTS.READY);
-  });
-
-  //////////////////////////////////////////////////////////////////////////////////////////////////
-
   mraid.addEventListener = function(event, listener) {
     if (!event || !listener) {
       broadcastEvent(EVENTS.ERROR, 'Both event and listener are required.', 'addEventListener');
     } else if (!contains(event, EVENTS)) {
       broadcastEvent(EVENTS.ERROR, 'Unknown MRAID event: ' + event, 'addEventListener');
     } else {
-      if (!listeners[event]) listeners[event] = new EventListeners(event);
+      if (!listeners[event]) {
+        listeners[event] = new EventListeners(event);
+      }
       listeners[event].add(listener);
     }
   };
@@ -402,45 +453,25 @@
     if (state === STATES.HIDDEN) {
       broadcastEvent(EVENTS.ERROR, 'Ad cannot be closed when it is already hidden.',
         'close');
-    } else bridge.executeNativeCall('close');
+    } else bridge.executeNativeCall(['close']);
   };
 
   mraid.expand = function(URL) {
-    if (this.getState() !== STATES.DEFAULT) {
-      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default state.', 'expand');
+    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {
+      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default or resized state.', 'expand');
     } else {
-      var args = ['expand'];
-
-      if (this.getHasSetCustomClose()) {
-        args = args.concat(['shouldUseCustomClose', expandProperties.useCustomClose ? 'true' : 'false']);
-      }
-
-      if (this.getHasSetCustomSize()) {
-        if (expandProperties.width >= 0 && expandProperties.height >= 0) {
-          args = args.concat(['w', expandProperties.width, 'h', expandProperties.height]);
-        }
-      }
-
-      if (typeof expandProperties.lockOrientation !== 'undefined') {
-        args = args.concat(['lockOrientation', expandProperties.lockOrientation]);
-      }
+      var args = ['expand',
+        'shouldUseCustomClose', expandProperties.useCustomClose
+      ];
 
       if (URL) {
         args = args.concat(['url', URL]);
       }
 
-      bridge.executeNativeCall.apply(this, args);
+      bridge.executeNativeCall(args);
     }
   };
 
-  mraid.getHasSetCustomClose = function() {
-      return hasSetCustomClose;
-  };
-
-  mraid.getHasSetCustomSize = function() {
-      return hasSetCustomSize;
-  };
-
   mraid.getExpandProperties = function() {
     var properties = {
       width: expandProperties.width,
@@ -451,56 +482,93 @@
     return properties;
   };
 
+
+  mraid.getCurrentPosition = function() {
+    return {
+      x: currentPosition.x,
+      y: currentPosition.y,
+      width: currentPosition.width,
+      height: currentPosition.height
+    };
+  };
+
+  mraid.getDefaultPosition = function() {
+    return {
+      x: defaultPosition.x,
+      y: defaultPosition.y,
+      width: defaultPosition.width,
+      height: defaultPosition.height
+    };
+  };
+
+  mraid.getMaxSize = function() {
+    return {
+      width: maxSize.width,
+      height: maxSize.height
+    };
+  };
+
   mraid.getPlacementType = function() {
     return placementType;
   };
 
-  mraid.getState = function() {
-    return state;
+  mraid.getScreenSize = function() {
+    return {
+      width: screenSize.width,
+      height: screenSize.height
+    };
   };
 
-  mraid.getVersion = function() {
-    return mraid.VERSION;
+  mraid.getState = function() {
+    return state;
   };
 
   mraid.isViewable = function() {
     return isViewable;
   };
 
+  mraid.getVersion = function() {
+    return mraid.VERSION;
+  };
+
   mraid.open = function(URL) {
     if (!URL) broadcastEvent(EVENTS.ERROR, 'URL is required.', 'open');
-    else bridge.executeNativeCall('open', 'url', URL);
+    else bridge.executeNativeCall(['open', 'url', URL]);
   };
 
   mraid.removeEventListener = function(event, listener) {
-    if (!event) broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');
-    else {
-      if (listener && (!listeners[event] || !listeners[event].remove(listener))) {
-        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.',
-          'removeEventListener');
-        return;
-      } else if (listeners[event]) listeners[event].removeAll();
+    if (!event) {
+      broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');
+      return;
+    }
 
-      if (listeners[event] && listeners[event].count === 0) {
-        listeners[event] = null;
-        delete listeners[event];
+    if (listener) {
+      // If we have a valid event, we'll try to remove the listener from it.
+      var success = false;
+      if (listeners[event]) {
+        success = listeners[event].remove(listener);
+      }
+
+      // If we didn't have a valid event or couldn't remove the listener from the event, broadcast an error and return early.
+      if (!success) {
+        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.', 'removeEventListener');
+        return;
       }
+
+    } else if (!listener && listeners[event]) {
+      listeners[event].removeAll();
+    }
+
+    if (listeners[event] && listeners[event].count === 0) {
+      listeners[event] = null;
+      delete listeners[event];
     }
   };
 
   mraid.setExpandProperties = function(properties) {
     if (validate(properties, expandPropertyValidators, 'setExpandProperties', true)) {
-      if (properties.hasOwnProperty('width') || properties.hasOwnProperty('height')) {
-        hasSetCustomSize = true;
-      }
-
-      if (properties.hasOwnProperty('useCustomClose')) hasSetCustomClose = true;
-
-      var desiredProperties = ['width', 'height', 'useCustomClose', 'lockOrientation'];
-      var length = desiredProperties.length;
-      for (var i = 0; i < length; i++) {
-        var propname = desiredProperties[i];
-        if (properties.hasOwnProperty(propname)) expandProperties[propname] = properties[propname];
+      if (properties.hasOwnProperty('useCustomClose')) {
+        expandProperties.useCustomClose = properties.useCustomClose;
       }
     }
   };
@@ -508,7 +576,7 @@
   mraid.useCustomClose = function(shouldUseCustomClose) {
     expandProperties.useCustomClose = shouldUseCustomClose;
     hasSetCustomClose = true;
-    bridge.executeNativeCall('usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose);
+    bridge.executeNativeCall(['usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose]);
   };
 
   // MRAID 2.0 APIs ////////////////////////////////////////////////////////////////////////////////
@@ -516,14 +584,14 @@
   mraid.createCalendarEvent = function(parameters) {
     CalendarEventParser.initialize(parameters);
     if (CalendarEventParser.parse()) {
-      bridge.executeNativeCall.apply(this, CalendarEventParser.arguments);
+      bridge.executeNativeCall(CalendarEventParser.arguments);
     } else {
       broadcastEvent(EVENTS.ERROR, CalendarEventParser.errors[0], 'createCalendarEvent');
     }
   };
 
   mraid.supports = function(feature) {
-    return supports[feature];
+    return supportProperties[feature];
   };
 
   mraid.playVideo = function(uri) {
@@ -535,7 +603,7 @@
     if (!uri) {
       broadcastEvent(EVENTS.ERROR, 'playVideo must be called with a valid URI', 'playVideo');
     } else {
-      bridge.executeNativeCall.apply(this, ['playVideo', 'uri', uri]);
+      bridge.executeNativeCall(['playVideo', 'uri', uri]);
     }
   };
 
@@ -548,36 +616,102 @@
     if (!uri) {
       broadcastEvent(EVENTS.ERROR, 'storePicture must be called with a valid URI', 'storePicture');
     } else {
-      bridge.executeNativeCall.apply(this, ['storePicture', 'uri', uri]);
+      bridge.executeNativeCall(['storePicture', 'uri', uri]);
     }
   };
 
-  mraid.resize = function() {
-    bridge.executeNativeCall('resize');
-  };
 
-  mraid.getResizeProperties = function() {
-    bridge.executeNativeCall('getResizeProperties');
+  var resizePropertyValidators = {
+    width: function(v) {
+      return !isNaN(v) && v > 0; 
+    },
+    height: function(v) {
+      return !isNaN(v) && v > 0; 
+    },
+    offsetX: function(v) {
+      return !isNaN(v);
+    },
+    offsetY: function(v) {
+      return !isNaN(v);
+    },
+    customClosePosition: function(v) {
+      return (typeof v === 'string' && 
+        ['top-right', 'bottom-right', 'top-left', 'bottom-left', 'center', 'top-center', 'bottom-center'].indexOf(v) > -1);
+    },
+    allowOffscreen: function(v) {
+      return (typeof v === 'boolean');
+    }
   };
 
-  mraid.setResizeProperties = function(resizeProperties) {
-    bridge.executeNativeCall('setResizeProperties', 'resizeProperties', resizeProperties);
+  mraid.setOrientationProperties = function(properties) {
+
+    if (properties.hasOwnProperty('allowOrientationChange')) {
+      orientationProperties.allowOrientationChange = properties.allowOrientationChange;
+    }
+
+    if (properties.hasOwnProperty('forceOrientation')) {
+      orientationProperties.forceOrientation = properties.forceOrientation;
+    }
+
+    var args = ['setOrientationProperties',
+      'allowOrientationChange', orientationProperties.allowOrientationChange,
+      'forceOrientation', orientationProperties.forceOrientation
+    ];
+    bridge.executeNativeCall(args);
   };
 
-  mraid.getCurrentPosition = function() {
-    bridge.executeNativeCall('getCurrentPosition');
+  mraid.getOrientationProperties = function() {
+    return {
+      allowOrientationChange: orientationProperties.allowOrientationChange,
+      forceOrientation: orientationProperties.forceOrientation
+    };
   };
 
-  mraid.getDefaultPosition = function() {
-    bridge.executeNativeCall('getDefaultPosition');
+  mraid.resize = function() {
+    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {
+      broadcastEvent(EVENTS.ERROR, 'Ad can only be resized from the default or resized state.', 'resize');
+    } else if (!resizeProperties.width || !resizeProperties.height) {
+      broadcastEvent(EVENTS.ERROR, 'Must set resize properties before calling resize()', 'resize');
+    } else {
+      var args = ['resize',
+        'width', resizeProperties.width,
+        'height', resizeProperties.height,
+        'offsetX', resizeProperties.offsetX || 0,
+        'offsetY', resizeProperties.offsetY || 0,
+        'customClosePosition', resizeProperties.customClosePosition,
+        'allowOffscreen', !!resizeProperties.allowOffscreen
+        ];
+
+      bridge.executeNativeCall(args);
+    } 
   };
 
-  mraid.getMaxSize = function() {
-    bridge.executeNativeCall('getMaxSize');
+  mraid.getResizeProperties = function() {
+    var properties = {
+      width: resizeProperties.width,
+      height: resizeProperties.height,
+      offsetX: resizeProperties.offsetX,
+      offsetY: resizeProperties.offsetY,
+      customClosePosition: resizeProperties.customClosePosition,
+      allowOffscreen: resizeProperties.allowOffscreen
+    };
+    return properties;
   };
 
-  mraid.getScreenSize = function() {
-    bridge.executeNativeCall('getScreenSize');
+  mraid.setResizeProperties = function(properties) {
+    if (validate(properties, resizePropertyValidators, 'setResizeProperties', true)) {
+
+      var desiredProperties = ['width', 'height', 'offsetX', 'offsetY', 'customClosePosition', 'allowOffscreen'];
+
+      var length = desiredProperties.length;
+
+      for (var i = 0; i < length; i++) {
+        var propname = desiredProperties[i];
+        if (properties.hasOwnProperty(propname)) {
+          resizeProperties[propname] = properties[propname];
+        }
+      }
+    }
   };
 
   var CalendarEventParser = {
@@ -659,7 +793,7 @@
       var validValues = ['opaque', 'transparent'];
 
       if (this.parameters.hasOwnProperty('transparency')) {
-        var transparency = this.parameters['transparency'];
+        var transparency = this.parameters.transparency;
         if (contains(transparency, validValues)) {
           this.arguments.push('transparency');
           this.arguments.push(transparency);
@@ -684,7 +818,7 @@
 
     parseRecurrenceInterval: function(recurrenceDict) {
       if (recurrenceDict.hasOwnProperty('interval')) {
-        var interval = recurrenceDict['interval'];
+        var interval = recurrenceDict.interval;
         if (!interval) {
           this.errors.push('Recurrence interval cannot be null.');
         } else {
@@ -700,7 +834,7 @@
 
     parseRecurrenceFrequency: function(recurrenceDict) {
       if (recurrenceDict.hasOwnProperty('frequency')) {
-        var frequency = recurrenceDict['frequency'];
+        var frequency = recurrenceDict.frequency;
         var validFrequencies = ['daily', 'weekly', 'monthly', 'yearly'];
         if (contains(frequency, validFrequencies)) {
           this.arguments.push('frequency');
@@ -712,7 +846,7 @@
     },
 
     parseRecurrenceEndDate: function(recurrenceDict) {
-      var expires = recurrenceDict['expires'];
+      var expires = recurrenceDict.expires;
 
       if (!expires) {
         return;
@@ -744,6 +878,6 @@
         this.arguments.push(kind);
         this.arguments.push(dateString);
       }
-    },
+    }
   };
 }());
\ No newline at end of file
diff --git a/mopub-sdk/gradle/wrapper/gradle-wrapper.jar b/mopub-sdk/gradle/wrapper/gradle-wrapper.jar
index 3c7abdf1..30d399d8 100644
Binary files a/mopub-sdk/gradle/wrapper/gradle-wrapper.jar and b/mopub-sdk/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/mopub-sdk/gradle/wrapper/gradle-wrapper.properties b/mopub-sdk/gradle/wrapper/gradle-wrapper.properties
index d27e87ae..75f1f3fd 100644
--- a/mopub-sdk/gradle/wrapper/gradle-wrapper.properties
+++ b/mopub-sdk/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Mar 20 15:07:53 PDT 2014
+#Fri Jul 24 16:59:31 PDT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.11-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-bin.zip
diff --git a/mopub-sdk/pom.xml b/mopub-sdk/pom.xml
index 6b8156e6..caee1e26 100644
--- a/mopub-sdk/pom.xml
+++ b/mopub-sdk/pom.xml
@@ -11,60 +11,40 @@
 
     <artifactId>mopub-sdk</artifactId>
     <version>1.0.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
+    <packaging>aar</packaging>
     <name>MoPub SDK</name>
     <description>The SDK for MoPub developers.</description>
 
-    <properties>
-        <robolectric.version>2.1</robolectric.version>
-    </properties>
-
     <dependencies>
 
         <!--main-->
         <dependency>
             <groupId>com.android.support</groupId>
-            <artifactId>support-v4</artifactId>
-            <version>19.1.0</version>
-        </dependency>
-
-        <!--test-->
-        <dependency>
-            <groupId>org.apache.httpcomponents</groupId>
-            <artifactId>httpclient</artifactId>
-            <version>4.0.3</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>fest-android</artifactId>
-            <version>1.0.7</version>
-            <scope>test</scope>
+            <artifactId>support-annotations</artifactId>
+            <version>22.0.0</version>
         </dependency>
 
         <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit-dep</artifactId>
-            <version>4.10</version>
-            <scope>test</scope>
+            <groupId>com.android.support</groupId>
+            <artifactId>support-v4</artifactId>
+            <version>22.0.0</version>
+            <type>aar</type>
         </dependency>
 
         <dependency>
-            <groupId>org.mockito</groupId>
-            <artifactId>mockito-core</artifactId>
-            <version>1.9.5</version>
-            <scope>test</scope>
+            <groupId>com.android.support</groupId>
+            <artifactId>recyclerview-v7</artifactId>
+            <version>22.0.0</version>
+            <type>aar</type>
         </dependency>
-
-        <!--android & robolectric-->
+        
         <dependency>
-            <groupId>org.robolectric</groupId>
-            <artifactId>robolectric</artifactId>
-            <version>${robolectric.version}</version>
-            <scope>test</scope>
+            <groupId>com.mopub.volley</groupId>
+            <artifactId>mopub-volley</artifactId>
+            <version>1.1.0</version>
         </dependency>
 
+        <!--android & oobolectric-->
         <dependency>
             <groupId>com.google.android</groupId>
             <artifactId>android</artifactId>
@@ -80,36 +60,39 @@
             <plugin>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>2.3.2</version>
+                <!-- Skip tests. We use Gradle to build and run tests. -->
+                <executions>
+                    <execution>
+                        <id>default-testCompile</id>
+                        <phase>test-compile</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                        <configuration>
+                            <skip>true</skip>
+                        </configuration>
+                    </execution>
+                </executions>
                 <configuration>
-                    <source>1.6</source>
-                    <target>1.6</target>
+                    <source>7</source>
+                    <target>7</target>
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
                 <extensions>true</extensions>
             </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.6</version>
-                <configuration>
-                    <argLine>-Xms512m -Xmx1024m -XX:MaxPermSize=256m</argLine>
-                    <excludes>
-                        <exclude>**/Test*.java</exclude>
-                    </excludes>
-                    <parallel>classesAndMethods</parallel>
-                </configuration>
-            </plugin>
         </plugins>
     </build>
 </project>
diff --git a/mopub-sdk/proguard.txt b/mopub-sdk/proguard.txt
index 17b5b82f..0a2e3c08 100644
--- a/mopub-sdk/proguard.txt
+++ b/mopub-sdk/proguard.txt
@@ -10,7 +10,9 @@
 -keep class * extends com.mopub.mobileads.CustomEventBanner {}
 -keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
 -keep class * extends com.mopub.nativeads.CustomEventNative {}
+-keep class * extends com.mopub.mobileads.CustomEventRewardedVideo {}
 
 # Support for Android Advertiser ID.
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
+-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java b/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java
new file mode 100644
index 00000000..630c180e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java
@@ -0,0 +1,8 @@
+package com.mopub.common;
+
+public enum AdFormat {
+    BANNER,
+    INTERSTITIAL,
+    NATIVE,
+    REWARDED_VIDEO,
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdReport.java b/mopub-sdk/src/main/java/com/mopub/common/AdReport.java
new file mode 100644
index 00000000..0415b271
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdReport.java
@@ -0,0 +1,81 @@
+package com.mopub.common;
+
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import com.mopub.network.AdResponse;
+
+import java.io.Serializable;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * A value class used for generating reports to send data back to MoPub
+ */
+public class AdReport implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    private static final String DATE_FORMAT_PATTERN = "M/d/yy hh:mm:ss a z";
+    private final AdResponse mAdResponse;
+    private final String mAdUnitId;
+    private final String mSdkVersion;
+    private final String mDeviceModel;
+    private final Locale mDeviceLocale;
+    private final String mUdid;
+
+    public AdReport(@NonNull String adUnitId, @NonNull ClientMetadata clientMetadata, @NonNull AdResponse adResponse) {
+        mAdUnitId = adUnitId;
+        mSdkVersion = clientMetadata.getSdkVersion();
+        mDeviceModel = clientMetadata.getDeviceModel();
+        mDeviceLocale = clientMetadata.getDeviceLocale();
+        mUdid = clientMetadata.getDeviceId();
+        mAdResponse = adResponse;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder parameters = new StringBuilder();
+        appendKeyValue(parameters, "sdk_version", mSdkVersion);
+        appendKeyValue(parameters, "creative_id", mAdResponse.getDspCreativeId());
+        appendKeyValue(parameters, "platform_version", Integer.toString(Build.VERSION.SDK_INT));
+        appendKeyValue(parameters, "device_model", mDeviceModel);
+        appendKeyValue(parameters, "ad_unit_id", mAdUnitId);
+        appendKeyValue(parameters, "device_locale",
+                mDeviceLocale == null ? null : mDeviceLocale.toString());
+        appendKeyValue(parameters, "device_id", mUdid);
+        appendKeyValue(parameters, "network_type", mAdResponse.getNetworkType());
+        appendKeyValue(parameters, "platform", "android");
+        appendKeyValue(parameters, "timestamp", getFormattedTimeStamp(mAdResponse.getTimestamp()));
+        appendKeyValue(parameters, "ad_type", mAdResponse.getAdType());
+        Integer width = mAdResponse.getWidth();
+        Integer height = mAdResponse.getHeight();
+        appendKeyValue(parameters, "ad_size", "{"
+                + (width == null ? "0" : width)
+                + ", "
+                + (height == null ? "0" : height)
+                + "}");
+
+        return parameters.toString();
+    }
+
+    public String getResponseString() {
+        return mAdResponse.getStringBody();
+    }
+
+    private void appendKeyValue(StringBuilder parameters, String key, String value) {
+        parameters.append(key);
+        parameters.append(" : ");
+        parameters.append(value);
+        parameters.append("\n");
+    }
+
+    private String getFormattedTimeStamp(long timeStamp) {
+        if (timeStamp != -1) {
+            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
+            return dateFormat.format(new Date(timeStamp));
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdType.java b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
new file mode 100644
index 00000000..86543d5a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
@@ -0,0 +1,14 @@
+package com.mopub.common;
+
+/**
+ * Valid values for the "X-Adtype" header from the MoPub ad server. The value of this header
+ * controls the custom event loading behavior.
+ */
+public class AdType {
+    public static final String HTML = "html";
+    public static final String MRAID = "mraid";
+    public static final String INTERSTITIAL = "interstitial";
+    public static final String NATIVE = "json";
+    public static final String CUSTOM = "custom";
+    public static final String CLEAR = "clear";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
index 2a012bed..397a0d04 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -2,25 +2,110 @@
 
 import android.content.Context;
 import android.location.Location;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.DateAndTime;
 
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class AdUrlGenerator extends BaseUrlGenerator {
-    private static TwitterAppInstalledStatus sTwitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
+
+    /**
+     * The ad unit id which identifies a spot for an ad to be placed.
+     */
+    private static final String AD_UNIT_ID_KEY = "id";
+
+    /**
+     * nv = native version. This is the version of MoPub.
+     */
+    private static final String SDK_VERSION_KEY = "nv";
+
+    /**
+     * q = query. This is for big publishers to send up certain
+     * keywords that better match ads.
+     */
+    private static final String KEYWORDS_KEY = "q";
+
+    /**
+     * Location represented in latitude and longitude.
+     * e.g. "47.638,-122.321"
+     */
+    private static final String LAT_LONG_KEY = "ll";
+
+    /**
+     * Estimated accuracy of this location, in meters.
+     * See {@link android.location.Location#getAccuracy()}
+     * for more information.
+     */
+    private static final String LAT_LONG_ACCURACY_KEY = "lla";
+
+    /**
+     * Milliseconds since location was updated.
+     */
+    private static final String LAT_LONG_FRESHNESS_KEY = "llf";
+
+    /**
+     * Whether or not the location came from the MoPub SDK
+     * and not the developer. 1 = from MoPub.
+     */
+    private static final String LAT_LONG_FROM_SDK_KEY = "llsdk";
+
+    /**
+     * Timezone offset. e.g. Pacific Standard Time = -0800.
+     */
+    private static final String TIMEZONE_OFFSET_KEY = "z";
+
+    /**
+     * "p" for portrait, "l" for landscape
+     */
+    private static final String ORIENTATION_KEY = "o";
+
+    /**
+     * Density as represented by a float. See
+     * http://developer.android.com/guide/practices/screens_support.html
+     * for details on values this can be.
+     */
+    private static final String SCREEN_SCALE_KEY = "sc_a";
+
+    /**
+     * Whether or not this is using mraid. 1 = yes.
+     */
+    private static final String IS_MRAID_KEY = "mr";
+
+    /**
+     * mcc, the mobile country code, paired with the mobile network code,
+     * uniquely identifies a carrier in a country.
+     */
+    private static final String MOBILE_COUNTRY_CODE_KEY = "mcc";
+    private static final String MOBILE_NETWORK_CODE_KEY = "mnc";
+
+    /**
+     * The International Organization for Standardization's 2-character country code
+     */
+    private static final String COUNTRY_CODE_KEY = "iso";
+
+    /**
+     * String name of the carrier. e.g. "Verizon%20Wireless"
+     */
+    private static final String CARRIER_NAME_KEY = "cn";
+
+    /**
+     * Carrier type as in what kind of network this device is on.
+     * See {@link android.net.ConnectivityManager} for constants.
+     */
+    private static final String CARRIER_TYPE_KEY = "ct";
+
+    /**
+     * Bundle ID, as in package name.
+     */
+    private static final String BUNDLE_ID_KEY = "bundle";
 
     protected Context mContext;
     protected String mAdUnitId;
     protected String mKeywords;
     protected Location mLocation;
 
-    public static enum TwitterAppInstalledStatus {
-        UNKNOWN,
-        NOT_INSTALLED,
-        INSTALLED,
-    }
-
     public AdUrlGenerator(Context context) {
         mContext = context;
     }
@@ -41,87 +126,132 @@ public AdUrlGenerator withLocation(Location location) {
     }
 
     protected void setAdUnitId(String adUnitId) {
-        addParam("id", adUnitId);
+        addParam(AD_UNIT_ID_KEY, adUnitId);
     }
 
     protected void setSdkVersion(String sdkVersion) {
-        addParam("nv", sdkVersion);
+        addParam(SDK_VERSION_KEY, sdkVersion);
     }
 
     protected void setKeywords(String keywords) {
-        addParam("q", keywords);
+        addParam(KEYWORDS_KEY, keywords);
     }
 
-    protected void setLocation(Location location) {
-        if (location != null) {
-            addParam("ll", location.getLatitude() + "," + location.getLongitude());
-            addParam("lla", "" + (int) location.getAccuracy());
+    protected void setLocation(@Nullable Location location) {
+        Location bestLocation = location;
+        Location locationFromLocationService = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
+
+        if (locationFromLocationService != null &&
+                (location == null || locationFromLocationService.getTime() >= location.getTime())) {
+            bestLocation = locationFromLocationService;
+        }
+
+        if (bestLocation != null) {
+            addParam(LAT_LONG_KEY, bestLocation.getLatitude() + "," + bestLocation.getLongitude());
+            addParam(LAT_LONG_ACCURACY_KEY, String.valueOf((int) bestLocation.getAccuracy()));
+            addParam(LAT_LONG_FRESHNESS_KEY,
+                    String.valueOf(calculateLocationStalenessInMilliseconds(bestLocation)));
+
+            if (bestLocation == locationFromLocationService) {
+                addParam(LAT_LONG_FROM_SDK_KEY, "1");
+            }
         }
     }
 
     protected void setTimezone(String timeZoneOffsetString) {
-        addParam("z", timeZoneOffsetString);
+        addParam(TIMEZONE_OFFSET_KEY, timeZoneOffsetString);
     }
 
     protected void setOrientation(String orientation) {
-        addParam("o", orientation);
+        addParam(ORIENTATION_KEY, orientation);
     }
 
     protected void setDensity(float density) {
-        addParam("sc_a", "" + density);
+        addParam(SCREEN_SCALE_KEY, "" + density);
     }
 
     protected void setMraidFlag(boolean mraid) {
-        if (mraid) addParam("mr", "1");
+        if (mraid) {
+            addParam(IS_MRAID_KEY, "1");
+        }
     }
 
     protected void setMccCode(String networkOperator) {
         String mcc = networkOperator == null ? "" : networkOperator.substring(0, mncPortionLength(networkOperator));
-        addParam("mcc", mcc);
+        addParam(MOBILE_COUNTRY_CODE_KEY, mcc);
     }
 
     protected void setMncCode(String networkOperator) {
         String mnc = networkOperator == null ? "" : networkOperator.substring(mncPortionLength(networkOperator));
-        addParam("mnc", mnc);
+        addParam(MOBILE_NETWORK_CODE_KEY, mnc);
     }
 
     protected void setIsoCountryCode(String networkCountryIso) {
-        addParam("iso", networkCountryIso);
+        addParam(COUNTRY_CODE_KEY, networkCountryIso);
     }
 
     protected void setCarrierName(String networkOperatorName) {
-        addParam("cn", networkOperatorName);
+        addParam(CARRIER_NAME_KEY, networkOperatorName);
     }
 
     protected void setNetworkType(MoPubNetworkType networkType) {
-        addParam("ct", networkType);
+        addParam(CARRIER_TYPE_KEY, networkType);
     }
 
-    private void addParam(String key, MoPubNetworkType value) {
-        addParam(key, value.toString());
+    protected void setBundleId(String bundleId) {
+        if (!TextUtils.isEmpty(bundleId)) {
+            addParam(BUNDLE_ID_KEY, bundleId);
+        }
     }
 
-    private int mncPortionLength(String networkOperator) {
-        return Math.min(3, networkOperator.length());
-    }
+    protected void addBaseParams(final ClientMetadata clientMetadata) {
+        setAdUnitId(mAdUnitId);
 
-    protected void setTwitterAppInstalledFlag() {
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.UNKNOWN) {
-            sTwitterAppInstalledStatus = getTwitterAppInstallStatus();
-        }
+        setSdkVersion(clientMetadata.getSdkVersion());
+        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
+                clientMetadata.getDeviceModel(),
+                clientMetadata.getDeviceProduct());
+        setBundleId(clientMetadata.getAppPackageName());
 
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) {
-            addParam("ts", "1");
-        }
+        setKeywords(mKeywords);
+
+        setLocation(mLocation);
+
+        setTimezone(DateAndTime.getTimeZoneOffsetString());
+
+        setOrientation(clientMetadata.getOrientationString());
+        setDeviceDimensions(clientMetadata.getDeviceDimensions());
+        setDensity(clientMetadata.getDensity());
+
+        final String networkOperator = clientMetadata.getNetworkOperatorForUrl();
+        setMccCode(networkOperator);
+        setMncCode(networkOperator);
+
+        setIsoCountryCode(clientMetadata.getIsoCountryCode());
+        setCarrierName(clientMetadata.getNetworkOperatorName());
+
+        setNetworkType(clientMetadata.getActiveNetworkType());
+
+        setAppVersion(clientMetadata.getAppVersion());
+
+        appendAdvertisingInfoTemplates();
     }
 
-    public TwitterAppInstalledStatus getTwitterAppInstallStatus() {
-        return IntentUtils.canHandleTwitterUrl(mContext) ? TwitterAppInstalledStatus.INSTALLED : TwitterAppInstalledStatus.NOT_INSTALLED;
+    private void addParam(String key, MoPubNetworkType value) {
+        addParam(key, value.toString());
+    }
+
+    private int mncPortionLength(String networkOperator) {
+        return Math.min(3, networkOperator.length());
     }
 
-    @Deprecated // for testing
-    public static void setTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
-        sTwitterAppInstalledStatus = status;
+    private static int calculateLocationStalenessInMilliseconds(final Location location) {
+        Preconditions.checkNotNull(location);
+        final long locationLastUpdatedInMillis = location.getTime();
+        final long nowInMillis = System.currentTimeMillis();
+        return (int) (nowInMillis - locationLastUpdatedInMillis);
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java b/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java
new file mode 100644
index 00000000..994f01db
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java
@@ -0,0 +1,36 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * This empty implementation of {@link com.mopub.common.LifecycleListener} is convenient for writing
+ * your own adapters for an SDK that MoPub can mediate. You can override only the lifecycle callbacks
+ * that the SDK requires.
+ */
+public class BaseLifecycleListener implements LifecycleListener {
+
+    @Override
+    public void onCreate(@NonNull final Activity activity) {}
+
+    @Override
+    public void onStart(@NonNull final Activity activity) {}
+
+    @Override
+    public void onPause(@NonNull final Activity activity) {}
+
+    @Override
+    public void onResume(@NonNull final Activity activity) {}
+
+    @Override
+    public void onRestart(@NonNull final Activity activity) {}
+
+    @Override
+    public void onStop(@NonNull final Activity activity) {}
+
+    @Override
+    public void onDestroy(@NonNull final Activity activity) {}
+
+    @Override
+    public void onBackPressed(@NonNull final Activity activity) {}
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
index 2b7eb021..68d88289 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
@@ -1,12 +1,17 @@
 package com.mopub.common;
 
+import android.graphics.Point;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 
-import static com.mopub.common.util.Strings.isEmpty;
+import com.mopub.network.Networking;
+import com.mopub.network.PlayServicesUrlRewriter;
 
 public abstract class BaseUrlGenerator {
-    private static final String IFA_PREFIX = "ifa:";
-    private static final String SHA_PREFIX = "sha:";
+
+    private static final String WIDTH_KEY = "w";
+    private static final String HEIGHT_KEY = "h";
 
     private StringBuilder mStringBuilder;
     private boolean mFirstParam;
@@ -14,7 +19,8 @@
     public abstract String generateUrlString(String serverHostname);
 
     protected void initUrlString(String serverHostname, String handlerType) {
-        mStringBuilder = new StringBuilder("http://" + serverHostname + handlerType);
+        String scheme = Networking.useHttps() ? Constants.HTTPS : Constants.HTTP;
+        mStringBuilder = new StringBuilder(scheme).append("://").append(serverHostname).append(handlerType);
         mFirstParam = true;
     }
 
@@ -23,7 +29,7 @@ protected String getFinalUrlString() {
     }
 
     protected void addParam(String key, String value) {
-        if (value == null || isEmpty(value)) {
+        if (TextUtils.isEmpty(value)) {
             return;
         }
 
@@ -76,4 +82,23 @@ protected void setDoNotTrack(boolean dnt) {
     protected void setUdid(String udid) {
         addParam("udid", udid);
     }
+
+    /**
+     * Appends special keys/values for advertising id and do-not-track. PlayServicesUrlRewriter will
+     * replace these templates with the correct values when the request is processed.
+     */
+    protected void appendAdvertisingInfoTemplates() {
+        addParam("udid", PlayServicesUrlRewriter.UDID_TEMPLATE);
+        addParam("dnt", PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE);
+    }
+
+    /**
+     * Adds the width and height.
+     *
+     * @param dimensions The width and height of the screen
+     */
+    protected void setDeviceDimensions(@NonNull final Point dimensions) {
+        addParam(WIDTH_KEY, "" + dimensions.x);
+        addParam(HEIGHT_KEY, "" + dimensions.y);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BrowserWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/common/BrowserWebViewClient.java
new file mode 100644
index 00000000..33d94acb
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/BrowserWebViewClient.java
@@ -0,0 +1,99 @@
+package com.mopub.common;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.util.EnumSet;
+
+import static com.mopub.common.util.Drawables.LEFT_ARROW;
+import static com.mopub.common.util.Drawables.RIGHT_ARROW;
+import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
+import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
+
+class BrowserWebViewClient extends WebViewClient {
+
+    private static final EnumSet<UrlAction> SUPPORTED_URL_ACTIONS = EnumSet.of(
+            UrlAction.HANDLE_PHONE_SCHEME,
+            UrlAction.OPEN_APP_MARKET,
+            UrlAction.OPEN_IN_APP_BROWSER,
+            UrlAction.HANDLE_SHARE_TWEET,
+            UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+            UrlAction.FOLLOW_DEEP_LINK
+    );
+
+    @NonNull
+    private MoPubBrowser mMoPubBrowser;
+
+    public BrowserWebViewClient(@NonNull final MoPubBrowser moPubBrowser) {
+        mMoPubBrowser = moPubBrowser;
+    }
+
+    @Override
+    public void onReceivedError(WebView view, int errorCode, String description,
+            String failingUrl) {
+        MoPubLog.d("MoPubBrowser error: " + description);
+    }
+
+    @Override
+    public boolean shouldOverrideUrlLoading(WebView view, String url) {
+        if (TextUtils.isEmpty(url)) {
+            return false;
+        }
+
+        UrlHandler urlHandler = new UrlHandler.Builder()
+                .withSupportedUrlActions(SUPPORTED_URL_ACTIONS)
+                .withoutMoPubBrowser()
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction.equals(UrlAction.OPEN_IN_APP_BROWSER)) {
+                            mMoPubBrowser.getWebView().loadUrl(url);
+                        } else {
+                            // UrlAction opened in external app, so close MoPubBrowser
+                            mMoPubBrowser.finish();
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .build();
+
+        return urlHandler.handleResolvedUrl(mMoPubBrowser.getApplicationContext(), url,
+                true, // = fromUserInteraction
+                null // = trackingUrls
+        );
+    }
+
+    @Override
+    public void onPageStarted(WebView view, String url, Bitmap favicon) {
+        super.onPageStarted(view, url, favicon);
+        mMoPubBrowser.getForwardButton()
+                .setImageDrawable(UNRIGHT_ARROW.createDrawable(mMoPubBrowser));
+    }
+
+    @Override
+    public void onPageFinished(WebView view, String url) {
+        super.onPageFinished(view, url);
+
+        Drawable backImageDrawable = view.canGoBack()
+                ? LEFT_ARROW.createDrawable(mMoPubBrowser)
+                : UNLEFT_ARROW.createDrawable(mMoPubBrowser);
+        mMoPubBrowser.getBackButton().setImageDrawable(backImageDrawable);
+
+        Drawable forwardImageDrawable = view.canGoForward()
+                ? RIGHT_ARROW.createDrawable(mMoPubBrowser)
+                : UNRIGHT_ARROW.createDrawable(mMoPubBrowser);
+        mMoPubBrowser.getForwardButton().setImageDrawable(forwardImageDrawable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
index fcc5fad2..58cd1cf5 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
@@ -1,12 +1,12 @@
 package com.mopub.common;
 
 import android.content.Context;
-import android.graphics.Bitmap;
 import android.os.AsyncTask;
-import android.support.v4.util.LruCache;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Streams;
 import com.mopub.common.util.Utils;
 
@@ -32,19 +32,6 @@
     private static final int DISK_CACHE_INDEX = 0;
 
     private static DiskLruCache sDiskLruCache;
-    private static BitmapLruCache sBitmapLruCache;
-
-    public static boolean initializeBitmapCache(final Context context) {
-        if (context == null) {
-            return false;
-        }
-
-        if (sBitmapLruCache == null) {
-            final int memoryCacheSizeBytes = DeviceUtils.memoryCacheSizeBytes(context);
-            sBitmapLruCache = new BitmapLruCache(memoryCacheSizeBytes);
-        }
-        return true;
-    }
 
     public static boolean initializeDiskCache(final Context context) {
         if (context == null) {
@@ -53,6 +40,10 @@ public static boolean initializeDiskCache(final Context context) {
 
         if (sDiskLruCache == null) {
             final File cacheDirectory = getDiskCacheDirectory(context);
+            if (cacheDirectory == null) {
+                return false;
+            }
+
             final long diskCacheSizeBytes = DeviceUtils.diskCacheSizeBytes(cacheDirectory);
             try {
                 sDiskLruCache = open(
@@ -63,13 +54,13 @@ public static boolean initializeDiskCache(final Context context) {
                 );
             } catch (IOException e) {
                 MoPubLog.d("Unable to create DiskLruCache", e);
+                return false;
             }
         }
         return true;
     }
 
     public static void initialize(final Context context) {
-        initializeBitmapCache(context);
         initializeDiskCache(context);
     }
 
@@ -77,8 +68,14 @@ public static String createValidDiskCacheKey(final String key) {
         return Utils.sha1(key);
     }
 
-    public static File getDiskCacheDirectory(final Context context) {
-        final String cachePath = context.getCacheDir().getPath();
+    @Nullable
+    public static File getDiskCacheDirectory(@NonNull final Context context) {
+        final File cacheDir = context.getCacheDir();
+        if (cacheDir == null) {
+            return null;
+        }
+
+        final String cachePath = cacheDir.getPath();
         return new File(cachePath + File.separator + UNIQUE_CACHE_NAME);
     }
 
@@ -110,14 +107,6 @@ public static String getFilePathDiskCache(final String key) {
                 + DISK_CACHE_INDEX;
     }
 
-    public static Bitmap getFromBitmapCache(final String key) {
-        if (sBitmapLruCache == null) {
-            return null;
-        }
-
-        return sBitmapLruCache.get(key);
-    }
-
     public static byte[] getFromDiskCache(final String key) {
         if (sDiskLruCache == null) {
             return null;
@@ -156,14 +145,6 @@ public static void getFromDiskCacheAsync(final String key, final DiskLruCacheGet
         new DiskLruCacheGetTask(key, diskLruCacheGetListener).execute();
     }
 
-    public static void putToBitmapCache(final String key, final Bitmap bitmap) {
-        if (sBitmapLruCache == null) {
-            return;
-        }
-
-        sBitmapLruCache.put(key, bitmap);
-    }
-
     public static boolean putToDiskCache(final String key, final byte[] content) {
         return putToDiskCache(key, new ByteArrayInputStream(content));
     }
@@ -208,21 +189,6 @@ public static void putToDiskCacheAsync(final String key, final byte[] content) {
         new DiskLruCachePutTask(key, content).execute();
     }
 
-    private static class BitmapLruCache extends LruCache<String, Bitmap> {
-        public BitmapLruCache(final int maxSize) {
-            super(maxSize);
-        }
-
-        @Override
-        protected int sizeOf(final String key, final Bitmap bitmap) {
-            if (bitmap != null) {
-                return bitmap.getRowBytes() * bitmap.getHeight();
-            }
-
-            return super.sizeOf(key, bitmap);
-        }
-    }
-
     private static class DiskLruCacheGetTask extends AsyncTask<Void, Void, byte[]> {
         private final DiskLruCacheGetListener mDiskLruCacheGetListener;
         private final String mKey;
@@ -285,17 +251,6 @@ public static void clearAndNullCaches() {
                 sDiskLruCache = null;
             }
         }
-        if (sBitmapLruCache != null) {
-            sBitmapLruCache.evictAll();
-            sBitmapLruCache = null;
-        }
-    }
-
-    // Testing
-    @Deprecated
-    @VisibleForTesting
-    public static LruCache<String, Bitmap> getBitmapLruCache() {
-        return sBitmapLruCache;
     }
 
     // Testing
diff --git a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
index 6589c171..412f47be 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
@@ -1,8 +1,11 @@
 package com.mopub.common;
 
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Build;
@@ -10,9 +13,14 @@
 import android.telephony.TelephonyManager;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 
+import java.util.Locale;
+
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.content.pm.PackageManager.NameNotFoundException;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 
 /**
@@ -30,50 +38,17 @@
     private static final String SHA_PREFIX = "sha:";
     private static final int UNKNOWN_NETWORK = -1;
 
-    private static volatile ClientMetadata sInstance;
-
-    private String mNetworkOperator;
-    private String mIsoCountryCode;
+    private String mNetworkOperatorForUrl;
+    private final String mNetworkOperator;
+    private String mSimOperator;
+    private final String mIsoCountryCode;
+    private final String mSimIsoCountryCode;
     private String mNetworkOperatorName;
+    private String mSimOperatorName;
     private String mUdid;
     private boolean mDoNotTrack = false;
     private boolean mAdvertisingInfoSet = false;
 
-    /**
-     * Returns the singleton ClientMetadata object, using the context to obtain data if necessary.
-     */
-    public static ClientMetadata getInstance(Context context) {
-        // Use a local variable so we can reduce accesses of the volatile field.
-        ClientMetadata result = sInstance;
-        if (result == null) {
-            synchronized (ClientMetadata.class) {
-                result = sInstance;
-                if (result == null) {
-                    result = new ClientMetadata(context);
-                    sInstance = result;
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Can be used by background threads and other objects without a context to attempt to get
-     * ClientMetadata. If the object has never been referenced from a thread with a context,
-     * this will return null.
-     */
-    public static ClientMetadata getInstance() {
-        ClientMetadata result = sInstance;
-        if (result == null) {
-            // If it's being initialized in another thread, wait for the lock.
-            synchronized (ClientMetadata.class) {
-                result = sInstance;
-            }
-        }
-
-        return result;
-    }
-
     public static enum MoPubNetworkType {
         UNKNOWN(0),
         ETHERNET(1),
@@ -81,7 +56,6 @@ public static ClientMetadata getInstance() {
         MOBILE(3);
 
         private final int mId;
-
         private MoPubNetworkType(int id) {
             mId = id;
         }
@@ -107,44 +81,108 @@ private static MoPubNetworkType fromAndroidNetworkType(int type) {
                     return UNKNOWN;
             }
         }
+
+        public int getId() {
+            return mId;
+        }
     }
 
+    private static volatile ClientMetadata sInstance;
+
     // Cached client metadata used for generating URLs and events.
     private final String mDeviceManufacturer;
     private final String mDeviceModel;
     private final String mDeviceProduct;
+    private final String mDeviceOsVersion;
     private final String mSdkVersion;
     private final String mAppVersion;
+    private final String mAppPackageName;
+    private String mAppName;
     private final Context mContext;
     private final ConnectivityManager mConnectivityManager;
 
-    private ClientMetadata(Context context) {
+    /**
+     * Returns the singleton ClientMetadata object, using the context to obtain data if necessary.
+     */
+    public static ClientMetadata getInstance(Context context) {
+        // Use a local variable so we can reduce accesses of the volatile field.
+        ClientMetadata result = sInstance;
+        if (result == null) {
+            synchronized (ClientMetadata.class) {
+                result = sInstance;
+                if (result == null) {
+                    result = new ClientMetadata(context);
+                    sInstance = result;
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Can be used by background threads and other objects without a context to attempt to get
+     * ClientMetadata. If the object has never been referenced from a thread with a context,
+     * this will return null.
+     */
+    public static ClientMetadata getInstance() {
+        ClientMetadata result = sInstance;
+        if (result == null) {
+            // If it's being initialized in another thread, wait for the lock.
+            synchronized (ClientMetadata.class) {
+                result = sInstance;
+            }
+        }
+
+        return result;
+    }
+
+    // NEVER CALL THIS AS A USER. Get it from the Singletons class.
+    public ClientMetadata(Context context) {
         mContext = context.getApplicationContext();
         mConnectivityManager =
                 (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
         mDeviceManufacturer = Build.MANUFACTURER;
         mDeviceModel = Build.MODEL;
         mDeviceProduct = Build.PRODUCT;
+        mDeviceOsVersion = Build.VERSION.RELEASE;
+
         mSdkVersion = MoPub.SDK_VERSION;
 
         // Cache context items that don't change:
         mAppVersion = getAppVersionFromContext(mContext);
+        PackageManager packageManager = mContext.getPackageManager();
+        ApplicationInfo applicationInfo = null;
+        mAppPackageName = context.getPackageName();
+        try {
+            applicationInfo = packageManager.getApplicationInfo(mAppPackageName, 0);
+        } catch (final NameNotFoundException e) {
+            // swallow
+        }
+        if (applicationInfo != null) {
+            mAppName = (String) packageManager.getApplicationLabel(applicationInfo);
+        }
 
         final TelephonyManager telephonyManager =
                 (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
-
+        mNetworkOperatorForUrl = telephonyManager.getNetworkOperator();
         mNetworkOperator = telephonyManager.getNetworkOperator();
         if (telephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA &&
                 telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
-            mNetworkOperator = telephonyManager.getSimOperator();
+            mNetworkOperatorForUrl = telephonyManager.getSimOperator();
+            mSimOperator = telephonyManager.getSimOperator();
         }
 
         mIsoCountryCode = telephonyManager.getNetworkCountryIso();
+        mSimIsoCountryCode = telephonyManager.getSimCountryIso();
         try {
             // Some Lenovo devices require READ_PHONE_STATE here.
             mNetworkOperatorName = telephonyManager.getNetworkOperatorName();
+            if (telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
+                mSimOperatorName = telephonyManager.getSimOperatorName();
+            }
         } catch (SecurityException e) {
             mNetworkOperatorName = null;
+            mSimOperatorName = null;
         }
 
         // Get the device ID. This will be replaced later when the Play Services callbacks complete.
@@ -205,6 +243,13 @@ public float getDensity() {
         return mContext.getResources().getDisplayMetrics().density;
     }
 
+    /**
+     * @return the network operator for URL generators.
+     */
+    public String getNetworkOperatorForUrl() {
+        return mNetworkOperatorForUrl;
+    }
+
     /**
      * @return the network operator.
      */
@@ -212,6 +257,17 @@ public String getNetworkOperator() {
         return mNetworkOperator;
     }
 
+    public Locale getDeviceLocale() {
+        return mContext.getResources().getConfiguration().locale;
+    }
+
+    /**
+     * @return the sim operator.
+     */
+    public String getSimOperator() {
+        return mSimOperator;
+    }
+
     /**
      * @return the country code of the device.
      */
@@ -219,6 +275,13 @@ public String getIsoCountryCode() {
         return mIsoCountryCode;
     }
 
+    /**
+     * @return the sim provider's country code.
+     */
+    public String getSimIsoCountryCode() {
+        return mSimIsoCountryCode;
+    }
+
     /**
      * @return the network operator name.
      */
@@ -226,10 +289,17 @@ public String getNetworkOperatorName() {
         return mNetworkOperatorName;
     }
 
+    /**
+     * @return the sim operator name.
+     */
+    public String getSimOperatorName() {
+        return mSimOperatorName;
+    }
+
     /**
      * @return the stored device ID.
      */
-    public synchronized String getAdvertisingId() {
+    public synchronized String getDeviceId() {
         return mUdid;
     }
 
@@ -272,6 +342,41 @@ public String getDeviceProduct() {
         return mDeviceProduct;
     }
 
+    /**
+     * @return the device os version.
+     */
+    public String getDeviceOsVersion() {
+        return mDeviceOsVersion;
+    }
+
+    /**
+     * @return the device screen width in dips according to current orientation.
+     */
+    public int getDeviceScreenWidthDip() {
+        return Dips.screenWidthAsIntDips(mContext);
+    }
+
+    /**
+     * @return the device screen height in dips according to current orientation.
+     */
+    public int getDeviceScreenHeightDip() {
+        return Dips.screenHeightAsIntDips(mContext);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons. This method only works after
+     * mContext is initialized.
+     *
+     * @return Width and height of the device. This is 0 by 0 if there is no context.
+     */
+    public Point getDeviceDimensions() {
+        if (Preconditions.NoThrow.checkNotNull(mContext)) {
+            return DeviceUtils.getDeviceDimensions(mContext);
+        }
+        return new Point(0, 0);
+    }
+
     /**
      * @return the MoPub SDK Version.
      */
@@ -286,8 +391,30 @@ public String getAppVersion() {
         return mAppVersion;
     }
 
+    /**
+     * @return the package of the application the SDK is included in.
+     */
+    public String getAppPackageName() {
+        return mAppPackageName;
+    }
+
+    /**
+     * @return the name of the application the SDK is included in.
+     */
+    public String getAppName() {
+        return mAppName;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static void setInstance(ClientMetadata clientMetadata) {
+        synchronized (ClientMetadata.class) {
+            sInstance = clientMetadata;
+        }
+    }
+
     @VisibleForTesting
-    public static synchronized void clearForTesting() {
+    public static void clearForTesting() {
         sInstance = null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java b/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java
new file mode 100644
index 00000000..a38f4b52
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java
@@ -0,0 +1,295 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.StateListDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
+import android.view.ViewConfiguration;
+import android.widget.FrameLayout;
+
+import com.mopub.common.util.Dips;
+
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
+
+/**
+ * CloseableLayout provides a layout class that shows a close button, and allows setting a
+ * {@link OnCloseListener}. Otherwise CloseableLayout behaves identically to
+ * {@link FrameLayout}.
+ *
+ * Rather than adding a button to the view tree, CloseableLayout is designed to draw the close
+ * button directly on the canvas and to track MotionEvents on its close region. While
+ * marginally more efficient, the main benefit to this is that CloseableLayout can function
+ * exactly as a regular FrameLayout without needing to override addView, removeView,
+ * removeAllViews, and a host of other methods.
+ *
+ * You can hide the close button using {@link #setCloseVisible} and change its position
+ * using {@link #setClosePosition}.
+ */
+public class CloseableLayout extends FrameLayout {
+    public interface OnCloseListener {
+        void onClose();
+    }
+
+    @VisibleForTesting
+    static final float CLOSE_BUTTON_SIZE_DP = 30.0f;
+    static final float CLOSE_REGION_SIZE_DP = 50.0f;
+
+    @VisibleForTesting
+    static final float CLOSE_BUTTON_PADDING_DP = 8.0f;
+
+    /**
+     * Defines a subset of supported gravity combinations for the CloseableLayout. These values
+     * include the possible values for customClosePosition as defined in the
+     * <a href="http://www.iab.net/media/file/IAB_MRAID_v2_FINAL.pdf">MRAID 2.0
+     * specification</a>.
+     */
+    public static enum ClosePosition {
+        TOP_LEFT(Gravity.TOP | Gravity.LEFT),
+        TOP_CENTER(Gravity.TOP | Gravity.CENTER_HORIZONTAL),
+        TOP_RIGHT(Gravity.TOP | Gravity.RIGHT),
+        CENTER(Gravity.CENTER),
+        BOTTOM_LEFT(Gravity.BOTTOM | Gravity.LEFT),
+        BOTTOM_CENTER(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL),
+        BOTTOM_RIGHT(Gravity.BOTTOM | Gravity.RIGHT);
+
+        private final int mGravity;
+
+        ClosePosition(final int mGravity) {
+            this.mGravity = mGravity;
+        }
+
+        int getGravity() {
+            return mGravity;
+        }
+    }
+
+    // Used in onTouchEvent to be lenient about moving outside the close button bounds. This is the
+    // same pattern used in the Android framework to handle click events.
+    private final int mTouchSlop;
+
+    @Nullable
+    private OnCloseListener mOnCloseListener;
+
+    @NonNull
+    private final StateListDrawable mCloseDrawable;
+    @NonNull
+    private ClosePosition mClosePosition;
+    private final int mCloseRegionSize;  // Size of the touchable close region.
+    private final int mCloseButtonSize;  // Size of the drawn close button.
+    private final int mCloseButtonPadding;
+
+    // Whether we need to recalculate the close bounds on the next draw pass
+    private boolean mCloseBoundChanged;
+
+    // Hang on to our bounds Rects so we don't allocate memory in the draw() method.
+    private final Rect mClosableLayoutRect = new Rect();
+    private final Rect mCloseRegionBounds = new Rect();
+    private final Rect mCloseButtonBounds = new Rect();
+    private final Rect mInsetCloseRegionBounds = new Rect();
+
+    @Nullable
+    private UnsetPressedState mUnsetPressedState;
+
+    public CloseableLayout(@NonNull Context context) {
+        super(context);
+
+        mCloseDrawable = new StateListDrawable();
+        mClosePosition = ClosePosition.TOP_RIGHT;
+
+        mCloseDrawable.addState(SELECTED_STATE_SET,
+                INTERSTITIAL_CLOSE_BUTTON_PRESSED.createDrawable(context));
+        mCloseDrawable.addState(EMPTY_STATE_SET,
+                INTERSTITIAL_CLOSE_BUTTON_NORMAL.createDrawable(context));
+
+        mCloseDrawable.setState(EMPTY_STATE_SET);
+        mCloseDrawable.setCallback(this);
+
+        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
+
+        mCloseRegionSize = Dips.asIntPixels(CLOSE_REGION_SIZE_DP, context);
+        mCloseButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE_DP, context);
+        mCloseButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING_DP, context);
+
+        setWillNotDraw(false);
+    }
+
+    public void setOnCloseListener(@Nullable OnCloseListener onCloseListener) {
+        mOnCloseListener = onCloseListener;
+    }
+
+    public void setClosePosition(@NonNull ClosePosition closePosition) {
+        Preconditions.checkNotNull(closePosition);
+
+        mClosePosition = closePosition;
+        mCloseBoundChanged = true;
+        invalidate();
+    }
+
+    public void setCloseVisible(boolean visible) {
+        if (mCloseDrawable.setVisible(visible, false)) {
+            invalidate(mCloseRegionBounds);
+        }
+    }
+
+    @Override
+    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
+        super.onSizeChanged(width, height, oldWidth, oldHeight);
+        mCloseBoundChanged = true;
+    }
+
+    @Override
+    public void draw(@NonNull final Canvas canvas) {
+        super.draw(canvas);
+
+        // Only recalculate the close bounds if they are dirty
+        if (mCloseBoundChanged) {
+            mCloseBoundChanged = false;
+
+            mClosableLayoutRect.set(0, 0, getWidth(), getHeight());
+            // Create the bounds for our close regions.
+            applyCloseRegionBounds(mClosePosition, mClosableLayoutRect, mCloseRegionBounds);
+
+            // The inset rect applies padding around the visible closeButton.
+            mInsetCloseRegionBounds.set(mCloseRegionBounds);
+            mInsetCloseRegionBounds.inset(mCloseButtonPadding, mCloseButtonPadding);
+            // The close button sits inside the close region with padding and gravity
+            // in the same way the close region sits inside the whole ClosableLayout
+            applyCloseButtonBounds(mClosePosition, mInsetCloseRegionBounds, mCloseButtonBounds);
+            mCloseDrawable.setBounds(mCloseButtonBounds);
+        }
+
+        // Draw last so that this gets drawn as the top layer. This is also why we override
+        // draw instead of onDraw.
+        if (mCloseDrawable.isVisible()) {
+            mCloseDrawable.draw(canvas);
+        }
+    }
+
+    public void applyCloseRegionBounds(ClosePosition closePosition, Rect bounds, Rect closeBounds) {
+        applyCloseBoundsWithSize(closePosition, mCloseRegionSize, bounds, closeBounds);
+    }
+
+    private void applyCloseButtonBounds(ClosePosition closePosition, Rect bounds, Rect outBounds) {
+        applyCloseBoundsWithSize(closePosition, mCloseButtonSize, bounds, outBounds);
+    }
+
+    private void applyCloseBoundsWithSize(ClosePosition closePosition, final int size, Rect bounds, Rect outBounds) {
+        Gravity.apply(closePosition.getGravity(), size, size, bounds, outBounds);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(@NonNull final MotionEvent event) {
+        // See http://developer.android.com/training/gestures/viewgroup.html for details on
+        // capturing motion events
+
+        // Start intercepting touch events only when we see a down event
+        if (event.getAction() != MotionEvent.ACTION_DOWN) {
+            return false;
+        }
+
+        // Start intercepting if the down event is in the close bounds. Returning true
+        // here causes onTouchEvent to get called for all events up until ACTION_CANCEL gets called.
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        return pointInCloseBounds(x, y, 0);
+    }
+
+    @Override
+    public boolean onTouchEvent(@NonNull MotionEvent event) {
+        // Stop receiving touch events if we aren't within the bounds, including some slop.
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        if (!pointInCloseBounds(x, y, mTouchSlop)) {
+            setClosePressed(false);
+            super.onTouchEvent(event);
+            return false;
+        }
+
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                setClosePressed(true);
+                break;
+            case MotionEvent.ACTION_CANCEL:
+                // Cancelled by a parent
+                setClosePressed(false);
+                break;
+            case MotionEvent.ACTION_UP:
+                if (isClosePressed()) {
+                    // Delay setting the unpressed state so that the button remains pressed
+                    // at least long enough to respond to the close event.
+                    if (mUnsetPressedState == null) {
+                        mUnsetPressedState = new UnsetPressedState();
+                    }
+                    postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
+                    performClose();
+                }
+                break;
+        }
+        return true;
+    }
+
+    private void setClosePressed(boolean pressed) {
+        if (pressed == isClosePressed()) {
+            return;
+        }
+
+        mCloseDrawable.setState(pressed ? SELECTED_STATE_SET : EMPTY_STATE_SET);
+        invalidate(mCloseRegionBounds);
+    }
+
+    @VisibleForTesting
+    boolean isClosePressed() {
+        return mCloseDrawable.getState() == SELECTED_STATE_SET;
+    }
+
+    @VisibleForTesting
+    boolean pointInCloseBounds(int x, int y, int slop) {
+        return x >= mCloseRegionBounds.left - slop
+                && y >= mCloseRegionBounds.top - slop
+                && x < mCloseRegionBounds.right + slop
+                && y < mCloseRegionBounds.bottom + slop;
+    }
+
+    private void performClose() {
+        playSoundEffect(SoundEffectConstants.CLICK);
+        if (mOnCloseListener != null) {
+            mOnCloseListener.onClose();
+        }
+    }
+
+    /**
+     * This is a copy of the UnsetPressedState pattern from Android's View.java, which is used
+     * to unset the pressed state of a button after a delay.
+     */
+    private final class UnsetPressedState implements Runnable {
+        public void run() {
+            setClosePressed(false);
+        }
+    }
+
+    @VisibleForTesting
+    void setCloseBounds(Rect closeBounds) {
+        mCloseRegionBounds.set(closeBounds);
+    }
+
+    @VisibleForTesting
+    Rect getCloseBounds() {
+        return mCloseRegionBounds;
+    }
+
+    @VisibleForTesting
+    void setCloseBoundChanged(boolean changed) {
+        mCloseBoundChanged = changed;
+    }
+
+    @VisibleForTesting
+    public boolean isCloseVisible() {
+        return mCloseDrawable.isVisible();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/Constants.java b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
new file mode 100644
index 00000000..0ca157fe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
@@ -0,0 +1,20 @@
+package com.mopub.common;
+
+public class Constants {
+    private Constants() {}
+
+    public static final String HTTP = "http";
+    public static final String HTTPS = "https";
+
+    public static final String HOST = "ads.mopub.com";
+
+    public static final String AD_HANDLER = "/m/ad";
+    public static final String CONVERSION_TRACKING_HANDLER = "/m/open";
+    public static final String POSITIONING_HANDLER = "/m/pos";
+
+
+    public static final int TEN_SECONDS_MILLIS = 10 * 1000;
+    public static final int THIRTY_SECONDS_MILLIS = 30 * 1000;
+
+    public static final int TEN_MB = 10 * 1024 * 1024;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
new file mode 100644
index 00000000..f6fec437
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
@@ -0,0 +1,24 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * Represents the orientation returned for MoPub ads from the MoPub ad server.
+ */
+public enum CreativeOrientation {
+    PORTRAIT, LANDSCAPE, UNDEFINED;
+
+    @NonNull
+    public static CreativeOrientation fromHeader(@Nullable String orientation) {
+        if ("l".equalsIgnoreCase(orientation)) {
+            return LANDSCAPE;
+        }
+
+        if ("p".equalsIgnoreCase(orientation)) {
+            return PORTRAIT;
+        }
+
+        return UNDEFINED;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
new file mode 100644
index 00000000..3adb73e3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
@@ -0,0 +1,18 @@
+package com.mopub.common;
+
+/**
+ * Keys used in localExtras and serverExtras maps for MoPub custom events.
+ */
+public class DataKeys {
+    public static final String AD_REPORT_KEY = "mopub-intent-ad-report";
+    public static final String HTML_RESPONSE_BODY_KEY = "Html-Response-Body";
+    public static final String REDIRECT_URL_KEY = "Redirect-Url";
+    public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
+    public static final String SCROLLABLE_KEY = "Scrollable";
+    public static final String CREATIVE_ORIENTATION_KEY = "com_mopub_orientation";
+    public static final String JSON_BODY_KEY = "com_mopub_native_json";
+    public static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
+    public static final String AD_UNIT_ID_KEY = "com_mopub_ad_unit_id";
+    public static final String AD_WIDTH = "com_mopub_ad_width";
+    public static final String AD_HEIGHT = "com_mopub_ad_height";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java b/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
index 0c603e66..c62d6594 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
@@ -16,6 +16,8 @@
 
 package com.mopub.common;
 
+import android.support.annotation.NonNull;
+
 import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -846,7 +848,7 @@ private FaultHidingOutputStream(OutputStream out) {
         }
       }
 
-      @Override public void write(byte[] buffer, int offset, int length) {
+      @Override public void write(@NonNull byte[] buffer, int offset, int length) {
         try {
           out.write(buffer, offset, length);
         } catch (IOException e) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
index 6b396539..6ce126e8 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
@@ -4,6 +4,7 @@
 import com.mopub.common.util.Streams;
 
 import org.apache.http.Header;
+import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 
 import java.io.BufferedInputStream;
@@ -19,9 +20,12 @@ public DownloadResponse(final HttpResponse httpResponse) throws Exception {
         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         BufferedInputStream inputStream = null;
         try {
-            inputStream = new BufferedInputStream(httpResponse.getEntity().getContent());
-            Streams.copyContent(inputStream, outputStream);
-            mBytes = outputStream.toByteArray();
+            HttpEntity httpEntity = httpResponse.getEntity();
+            if (httpEntity != null) {
+                inputStream = new BufferedInputStream(httpEntity.getContent());
+                Streams.copyContent(inputStream, outputStream);
+                mBytes = outputStream.toByteArray();
+            }
         } finally {
             Streams.closeStream(inputStream);
             Streams.closeStream(outputStream);
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
index fc31c97c..7230a2ae 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
@@ -2,7 +2,9 @@
 
 import android.net.http.AndroidHttpClient;
 import android.os.AsyncTask;
+
 import com.mopub.common.logging.MoPubLog;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
 
@@ -39,7 +41,6 @@ protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequest
             return new DownloadResponse(httpResponse);
         } catch (Exception e) {
             MoPubLog.d("Download task threw an internal exception", e);
-            cancel(true);
             return null;
         } finally {
             if (httpClient != null) {
@@ -60,6 +61,6 @@ protected void onPostExecute(final DownloadResponse downloadResponse) {
 
     @Override
     protected void onCancelled() {
-        mDownloadTaskListener.onComplete(mUrl, null);
+        MoPubLog.d("DownloadTask was cancelled.");
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
index 75b9bdf7..e26371b0 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.os.AsyncTask;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
@@ -18,11 +20,21 @@
     private static String sPlayServicesUtilClassName = "com.google.android.gms.common.GooglePlayServicesUtil";
     private static String sAdvertisingIdClientClassName = "com.google.android.gms.ads.identifier.AdvertisingIdClient";
 
+    public static class AdvertisingInfo {
+        public final String advertisingId;
+        public final boolean limitAdTracking;
+
+        public AdvertisingInfo(String adId, boolean limitAdTrackingEnabled) {
+            advertisingId = adId;
+            limitAdTracking = limitAdTrackingEnabled;
+        }
+    }
+
     public interface GpsHelperListener {
         public void onFetchAdInfoCompleted();
     }
 
-    static boolean isPlayServicesAvailable(final Context context) {
+    public static boolean isPlayServicesAvailable(final Context context) {
         try {
             MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "isGooglePlayServicesAvailable")
                     .setStatic(Class.forName(sPlayServicesUtilClassName))
@@ -68,6 +80,29 @@ static public void fetchAdvertisingInfoAsync(final Context context, final GpsHel
         }
     }
 
+    @Nullable
+    static public AdvertisingInfo fetchAdvertisingInfoSync(final Context context) {
+        if (context == null) {
+            return null;
+        }
+        Object adInfo = null;
+        try {
+            MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "getAdvertisingIdInfo")
+                    .setStatic(Class.forName(sAdvertisingIdClientClassName))
+                    .addParam(Context.class, context);
+
+            adInfo = methodBuilder.execute();
+        } catch (Exception e) {
+            MoPubLog.d("Unable to obtain Google AdvertisingIdClient.Info via reflection.");
+            return null;
+        }
+
+        String advertisingId = reflectedGetAdvertisingId(adInfo, null);
+        boolean isLimitAdTrackingEnabled = reflectedIsLimitAdTrackingEnabled(adInfo, false);
+
+        return new AdvertisingInfo(advertisingId, isLimitAdTrackingEnabled);
+    }
+
     static private void internalFetchAdvertisingInfoAsync(final Context context, final GpsHelperListener gpsHelperListener) {
         if (!classFound(sAdvertisingIdClientClassName)) {
             if (gpsHelperListener != null) {
@@ -114,7 +149,7 @@ protected Void doInBackground(Void... voids) {
                     updateClientMetadata(context, adInfo);
                 }
             } catch (Exception exception) {
-                MoPubLog.d("Unable to obtain AdvertisingIdClient.getAdvertisingIdInfo()");
+                MoPubLog.d("Unable to obtain Google AdvertisingIdClient.Info via reflection.");
             }
 
             return null;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java b/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
index 88e4f7bd..09c16730 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
@@ -2,31 +2,31 @@
 
 import android.content.Context;
 import android.net.http.AndroidHttpClient;
-import android.os.Handler;
-import android.os.Looper;
-import android.webkit.WebView;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.Networking;
 
-import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.params.HttpClientParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 
-import java.util.Arrays;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLDecoder;
 
 import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 
 public class HttpClient {
     private static final int CONNECTION_TIMEOUT = 10000;
     private static final int SOCKET_TIMEOUT = 10000;
-    private static String sWebViewUserAgent;
 
     public static AndroidHttpClient getHttpClient() {
-        String userAgent = DeviceUtils.getUserAgent();
+        final String userAgent = Networking.getCachedUserAgent();
 
         AndroidHttpClient httpClient = AndroidHttpClient.newInstance(userAgent);
 
@@ -38,16 +38,30 @@ public static AndroidHttpClient getHttpClient() {
         return httpClient;
     }
 
-    public static HttpGet initializeHttpGet(final String url, final Context context) {
-        final HttpGet httpGet = new HttpGet(url);
+    public static HttpGet initializeHttpGet(@NonNull final String url) {
+        return initializeHttpGet(url, null);
+    }
+
+    public static HttpGet initializeHttpGet(@NonNull String url, @Nullable final Context context) {
+        Preconditions.checkNotNull(url);
 
-        if (getWebViewUserAgent() == null && context != null) {
-            // Memoize the user agent since creating WebViews is expensive
-            setWebViewUserAgent(new WebView(context).getSettings().getUserAgentString());
+        // Try to encode url. If this fails, then fallback on the original url
+        String getUrl;
+        try {
+            getUrl = urlEncode(url);
+        } catch (Exception e) {
+            getUrl = url;
         }
 
+        final HttpGet httpGet = new HttpGet(getUrl);
+
+        final String webViewUserAgent;
+        if (context != null) {
+            webViewUserAgent = Networking.getUserAgent(context);
+        } else {
+            webViewUserAgent = Networking.getCachedUserAgent();
+        }
 
-        final String webViewUserAgent = getWebViewUserAgent();
         if (webViewUserAgent != null) {
             httpGet.addHeader(USER_AGENT.getKey(), webViewUserAgent);
         }
@@ -55,57 +69,69 @@ public static HttpGet initializeHttpGet(final String url, final Context context)
         return httpGet;
     }
 
-    public static void makeTrackingHttpRequest(final Iterable<String> urls, final Context context) {
-        if (urls == null || context == null) {
-            return;
+    /**
+     * This method constructs a properly encoded and valid URI adhering to legal characters for
+     * each component. See Android docs on these classes for reference.
+     */
+    public static String urlEncode(@NonNull final String url) throws Exception {
+        Preconditions.checkNotNull(url);
+
+        // If the URL is improperly encoded, then fail
+        if (isUrlImproperlyEncoded(url)) {
+            throw new UnsupportedEncodingException("URL is improperly encoded: " + url);
         }
 
-        final DownloadTask.DownloadTaskListener downloadTaskListener = new DownloadTask.DownloadTaskListener() {
-            @Override
-            public void onComplete(final String url, final DownloadResponse downloadResponse) {
-                if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                    return;
-                }
-
-                String result = HttpResponses.asResponseString(downloadResponse);
-
-                if (result != null) {
-                    MoPubLog.d("Successfully hit tracking endpoint: " + url);
-                } else {
-                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                }
-            }
-        };
-
-        // Hold onto the application context in closure instead of activity context
-        final Context appContext = context.getApplicationContext();
-        final Runnable trackingHttpRequestRunnable = new Runnable() {
-            @Override
-            public void run() {
-                for (final String url : urls) {
-                    try {
-                        final HttpGet httpGet = initializeHttpGet(url, appContext);
-                        AsyncTasks.safeExecuteOnExecutor(new DownloadTask(downloadTaskListener), httpGet);
-                    } catch (Exception e) {
-                        MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                    }
-                }
-            }
-        };
-
-        new Handler(Looper.getMainLooper()).post(trackingHttpRequestRunnable);
+        // If the url is unencoded, then encode it. Otherwise it is already properly encoded
+        // and leave it as is.
+        URI uri;
+        if (isUrlUnencoded(url)) {
+            uri = encodeUrl(url);
+        } else {
+            uri = new URI(url);
+        }
+
+        return uri.toURL().toString();
     }
 
-    public static void makeTrackingHttpRequest(final String url, final Context context) {
-        makeTrackingHttpRequest(Arrays.asList(url), context);
+    /**
+     * This method tries to decode the URL and returns false if it can't due to improper encoding.
+     */
+    static boolean isUrlImproperlyEncoded(@NonNull String url) {
+        try {
+            URLDecoder.decode(url, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            MoPubLog.w("Url is improperly encoded: " + url);
+            return true;
+        }
+        return false;
     }
 
-    public synchronized static String getWebViewUserAgent() {
-        return sWebViewUserAgent;
+    /**
+     * This method tries to construct a URI and returns true if it can't due to illegal characters
+     * in the url.
+     */
+    static boolean isUrlUnencoded(@NonNull String url) {
+        try {
+            new URI(url);
+        } catch (URISyntaxException e) {
+            return true;
+        }
+        return false;
     }
 
-    public synchronized static void setWebViewUserAgent(final String userAgent) {
-        sWebViewUserAgent = userAgent;
+    /**
+     * This method encodes each component of the URL into a valid URI.
+     */
+    static URI encodeUrl(@NonNull String urlString) throws Exception {
+        URI uri;
+        try {
+            URL url = new URL(urlString);
+            uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(),
+                    url.getPath(), url.getQuery(), url.getRef());
+        } catch (Exception e) {
+            MoPubLog.w("Failed to encode url: " + urlString);
+            throw e;
+        }
+        return uri;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java b/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java
new file mode 100644
index 00000000..d92f8d5d
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java
@@ -0,0 +1,21 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * This is a uniform interface to 3rd party SDKs that need to know when Activity lifecycle events
+ * occur.
+ */
+public interface LifecycleListener {
+
+    public void onCreate(@NonNull Activity activity);
+    public void onStart(@NonNull Activity activity);
+    public void onPause(@NonNull Activity activity);
+    public void onResume(@NonNull Activity activity);
+
+    public void onRestart(@NonNull Activity activity);
+    public void onStop(@NonNull Activity activity);
+    public void onDestroy(@NonNull Activity activity);
+    public void onBackPressed(@NonNull Activity activity);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
index 52b2c67b..6602db66 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.logging.MoPubLog;
 
@@ -48,6 +49,7 @@
      * - The location providers don't exist
      * - Location awareness is disabled in the parent MoPubView
      */
+    @Nullable
     public static Location getLastKnownLocation(final Context context,
             final int locationPrecision,
             final MoPub.LocationAwareness locationLocationAwareness) {
@@ -65,6 +67,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve GPS location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
+        } catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
         }
 
         Location networkLocation = null;
@@ -74,6 +78,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve network location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve network location: device has no network provider.");
+        }  catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no network provider.");
         }
 
         if (gpsLocation == null && networkLocation == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java b/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java
new file mode 100644
index 00000000..42e7b7a6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java
@@ -0,0 +1,6 @@
+package com.mopub.common;
+
+/**
+ * A marker interface for 3rd party SDK options.
+ */
+public interface MediationSettings {}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 808400cf..ef57b146 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -1,7 +1,14 @@
 package com.mopub.common;
 
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+import com.mopub.mobileads.MoPubRewardedVideoManager;
+
 public class MoPub {
-    public static final String SDK_VERSION = "3.2.2";
+    public static final String SDK_VERSION = "3.11.0";
 
     public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
@@ -28,4 +35,68 @@ public static int getLocationPrecision() {
     public static void setLocationPrecision(int precision) {
         sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
     }
+
+
+    //////// MoPub LifecycleListener messages ////////
+
+    public static void onCreate(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onCreate(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onPause(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onPause(activity);
+    }
+
+    public static void onResume(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onResume(activity);
+        updateActivity(activity);
+    }
+
+    public static void onRestart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onRestart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStop(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStop(activity);
+    }
+
+    public static void onDestroy(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onDestroy(activity);
+    }
+
+    public static void onBackPressed(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onBackPressed(activity);
+    }
+
+    ////////// MoPub RewardedVideoControl methods //////////
+    public static void initializeRewardedVideo(@NonNull Activity activity, MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.init(activity, mediationSettings);
+    }
+
+    private static void updateActivity(@NonNull Activity activity) {
+        MoPubRewardedVideoManager.updateActivity(activity);
+    }
+
+    public static void setRewardedVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        MoPubRewardedVideoManager.setVideoListener(listener);
+    }
+
+    public static void loadRewardedVideo(@NonNull String adUnitId, @Nullable MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.loadVideo(adUnitId, mediationSettings);
+    }
+
+    public static boolean hasRewardedVideo(@NonNull String adUnitId) {
+        return MoPubRewardedVideoManager.hasVideo(adUnitId);
+    }
+
+    public static void showRewardedVideo(@NonNull String adUnitId) {
+        MoPubRewardedVideoManager.showVideo(adUnitId);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
index 4e55f583..8433719f 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -3,25 +3,27 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.Drawable;
-import android.net.Uri;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.view.Gravity;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.Window;
 import android.webkit.CookieSyncManager;
 import android.webkit.WebChromeClient;
 import android.webkit.WebSettings;
 import android.webkit.WebView;
-import android.webkit.WebViewClient;
 import android.widget.ImageButton;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
-import android.widget.Toast;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.util.WebViews;
+
+import java.util.EnumSet;
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
@@ -30,10 +32,6 @@
 import static com.mopub.common.util.Drawables.LEFT_ARROW;
 import static com.mopub.common.util.Drawables.REFRESH;
 import static com.mopub.common.util.Drawables.RIGHT_ARROW;
-import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
-import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
-import static com.mopub.common.util.IntentUtils.deviceCanHandleIntent;
-import static com.mopub.common.util.IntentUtils.isDeepLink;
 
 public class MoPubBrowser extends Activity {
     public static final String DESTINATION_URL_KEY = "URL";
@@ -45,6 +43,31 @@
     private ImageButton mRefreshButton;
     private ImageButton mCloseButton;
 
+    @NonNull
+    public ImageButton getBackButton() {
+        return mBackButton;
+    }
+
+    @NonNull
+    public ImageButton getCloseButton() {
+        return mCloseButton;
+    }
+
+    @NonNull
+    public ImageButton getForwardButton() {
+        return mForwardButton;
+    }
+
+    @NonNull
+    public ImageButton getRefreshButton() {
+        return mRefreshButton;
+    }
+
+    @NonNull
+    public WebView getWebView() {
+        return mWebView;
+    }
+
     public static void open(final Context context, final String url) {
         MoPubLog.d("Opening url in MoPubBrowser: " + url);
         final Intent intent = new Intent(context, MoPubBrowser.class);
@@ -84,50 +107,8 @@ private void initializeWebView() {
         webSettings.setUseWideViewPort(true);
 
         mWebView.loadUrl(getIntent().getStringExtra(DESTINATION_URL_KEY));
-        mWebView.setWebViewClient(new WebViewClient() {
-            @Override
-            public void onReceivedError(WebView view, int errorCode, String description,
-                    String failingUrl) {
-                Toast.makeText(MoPubBrowser.this, "MoPubBrowser error: " + description, Toast.LENGTH_SHORT).show();
-            }
 
-            @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                if (url == null) {
-                    return false;
-                }
-
-                final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-                if (isDeepLink(url) && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
-                    startActivity(intent);
-                    finish();
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-
-            @Override
-            public void onPageStarted(WebView view, String url, Bitmap favicon) {
-                super.onPageStarted(view, url, favicon);
-                mForwardButton.setImageDrawable(UNRIGHT_ARROW.decodeImage(MoPubBrowser.this));
-            }
-
-            @Override
-            public void onPageFinished(WebView view, String url) {
-                super.onPageFinished(view, url);
-
-                Drawable backImageDrawable = view.canGoBack()
-                        ? LEFT_ARROW.decodeImage(MoPubBrowser.this)
-                        : UNLEFT_ARROW.decodeImage(MoPubBrowser.this);
-                mBackButton.setImageDrawable(backImageDrawable);
-
-                Drawable forwardImageDrawable = view.canGoForward()
-                        ? RIGHT_ARROW.decodeImage(MoPubBrowser.this)
-                        : UNRIGHT_ARROW.decodeImage(MoPubBrowser.this);
-                mForwardButton.setImageDrawable(forwardImageDrawable);
-            }
-        });
+        mWebView.setWebViewClient(new BrowserWebViewClient(this));
 
         mWebView.setWebChromeClient(new WebChromeClient() {
             public void onProgressChanged(WebView webView, int progress) {
@@ -183,12 +164,30 @@ private void enableCookies() {
     protected void onPause() {
         super.onPause();
         CookieSyncManager.getInstance().stopSync();
+        WebViews.onPause(mWebView, isFinishing());
     }
 
     @Override
     protected void onResume() {
         super.onResume();
         CookieSyncManager.getInstance().startSync();
+        WebViews.onResume(mWebView);
+    }
+
+    @Override
+    public void finish() {
+        // ZoomButtonController adds buttons to the window's decorview. If they're still visible
+        // when finish() is called, they need to be removed or a Window object will be leaked.
+        ViewGroup decorView = (ViewGroup) getWindow().getDecorView();
+        decorView.removeAllViews();
+        super.finish();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mWebView.destroy();
+        mWebView = null;
     }
 
     private View getMoPubBrowserView() {
@@ -207,20 +206,20 @@ private View getMoPubBrowserView() {
         RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
         innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
         innerLayout.setLayoutParams(innerLayoutParams);
-        innerLayout.setBackgroundDrawable(BACKGROUND.decodeImage(this));
+        innerLayout.setBackgroundDrawable(BACKGROUND.createDrawable(this));
         outerLayout.addView(innerLayout);
 
-        mBackButton = getButton(LEFT_ARROW.decodeImage(this));
-        mForwardButton = getButton(RIGHT_ARROW.decodeImage(this));
-        mRefreshButton = getButton(REFRESH.decodeImage(this));
-        mCloseButton = getButton(CLOSE.decodeImage(this));
+        mBackButton = getButton(LEFT_ARROW.createDrawable(this));
+        mForwardButton = getButton(RIGHT_ARROW.createDrawable(this));
+        mRefreshButton = getButton(REFRESH.createDrawable(this));
+        mCloseButton = getButton(CLOSE.createDrawable(this));
 
         innerLayout.addView(mBackButton);
         innerLayout.addView(mForwardButton);
         innerLayout.addView(mRefreshButton);
         innerLayout.addView(mCloseButton);
 
-        mWebView = new WebView(this);
+        mWebView = new BaseWebView(this);
         RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
         layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
         mWebView.setLayoutParams(layoutParams);
@@ -240,4 +239,10 @@ private ImageButton getButton(final Drawable drawable) {
 
         return imageButton;
     }
+
+    @Deprecated
+    @VisibleForTesting
+    void setWebView(WebView webView) {
+        mWebView = webView;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java
new file mode 100644
index 00000000..41394805
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java
@@ -0,0 +1,107 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.lang.ref.WeakReference;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * This class handles delegating lifecycle callback events to ads SDKs that require them.
+ */
+public class MoPubLifecycleManager implements LifecycleListener {
+    private static MoPubLifecycleManager sInstance;
+
+    @NonNull private final Set<LifecycleListener> mLifecycleListeners;
+    @NonNull private final WeakReference<Activity> mMainActivity;
+
+    private MoPubLifecycleManager(Activity mainActivity) {
+        mLifecycleListeners = new HashSet<LifecycleListener>();
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+    }
+
+    @NonNull public static synchronized MoPubLifecycleManager getInstance(Activity mainActivity) {
+        if (sInstance == null) {
+            sInstance = new MoPubLifecycleManager(mainActivity);
+        }
+
+        return sInstance;
+    }
+
+    /**
+     * Adds a lifecycle listener to the manager. The manager takes ownership with a strong reference.
+     *
+     * @param listener the listener to add to the lifecycle manager.
+     */
+    public void addLifecycleListener(@Nullable LifecycleListener listener) {
+        // Get the instance or bail if not initialized.
+        if (listener == null) {
+            return;
+        }
+        if (mLifecycleListeners.add(listener)) {
+            Activity activity = mMainActivity.get();
+            if (activity != null) {
+                listener.onCreate(activity);
+                listener.onStart(activity);
+            }
+        }
+    }
+
+    @Override
+    public void onCreate(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onCreate(activity);
+        }
+    }
+
+    @Override
+    public void onStart(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onStart(activity);
+        }
+    }
+
+    @Override
+    public void onPause(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onPause(activity);
+        }
+    }
+
+    @Override
+    public void onResume(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onResume(activity);
+        }
+    }
+
+    @Override
+    public void onRestart(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onStop(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onDestroy(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onBackPressed(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onBackPressed(activity);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java
new file mode 100644
index 00000000..85f0f3c2
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java
@@ -0,0 +1,43 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+
+/**
+ * Represents a reward to the user for completing a rewarded task like watching a video.
+ */
+public final class MoPubReward {
+    public static final String NO_REWARD_LABEL = "";
+    public static final int NO_REWARD_AMOUNT = -123;
+    private final boolean mSuccess;
+    private final @NonNull String mLabel;
+    private final int mAmount;
+
+    private MoPubReward(boolean success, @NonNull String label, int amount) {
+        mSuccess = success;
+        mLabel = label;
+        mAmount = amount;
+    }
+
+    @NonNull
+    public static MoPubReward failure() {
+        return new MoPubReward(false, NO_REWARD_LABEL, 0);
+    }
+
+    @NonNull
+    public static MoPubReward success(@NonNull final String rewardLabel, final int amount) {
+        return new MoPubReward(true, rewardLabel, amount);
+    }
+
+    public final boolean isSuccessful() {
+        return mSuccess;
+    }
+
+    @NonNull
+    public final String getLabel() {
+        return mLabel;
+    }
+
+    public final int getAmount() {
+        return mAmount;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/Preconditions.java b/mopub-sdk/src/main/java/com/mopub/common/Preconditions.java
index 126ff4b4..ca5a52ec 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/Preconditions.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/Preconditions.java
@@ -184,6 +184,8 @@ public static boolean checkState(boolean expression,
 
         /**
          * Ensures that an object reference is not null.
+         *
+         * @returns true if
          */
         public static boolean checkNotNull(Object reference) {
             return checkNotNullInternal(reference, sStrictMode, "Object can not be null.",
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
new file mode 100644
index 00000000..d2b5a438
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
@@ -0,0 +1,319 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import java.util.List;
+
+import static com.mopub.common.Constants.HTTP;
+import static com.mopub.common.Constants.HTTPS;
+import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
+
+/**
+ * {@code UrlAction} describes the different kinds of actions for URLs that {@link UrlHandler} can
+ * potentially perform and how to match against each URL.
+ */
+public enum UrlAction {
+    /**
+     * NOTE: The order in which these are defined determines the priority when matching URLs!
+     * If a URL matches multiple Url Actions, it will be handled by the one that appears first in
+     * this enum (see {@link UrlHandler#handleUrl(Context, String)}).
+     *
+     * Each UrlAction includes its ordinal in a comment as a reminder of this fact.
+     */
+
+    /* 0 */ HANDLE_MOPUB_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopub".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            final String host = uri.getHost();
+            final UrlHandler.MoPubSchemeListener moPubSchemeListener =
+                    urlHandler.getMoPubSchemeListener();
+
+            if ("finishLoad".equals(host)) {
+                moPubSchemeListener.onFinishLoad();
+            } else if ("close".equals(host)) {
+                moPubSchemeListener.onClose();
+            } else if ("failLoad".equals(host)) {
+                moPubSchemeListener.onFailLoad();
+            } else {
+                throw new IntentNotResolvableException("Could not handle MoPub Scheme url: " + uri);
+            }
+        }
+    },
+
+    /* 1 */ IGNORE_ABOUT_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "about".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            MoPubLog.d("Link to about page ignored.");
+        }
+    },
+
+    /* 2 */ HANDLE_PHONE_SCHEME(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return "tel".equals(scheme) || "voicemail".equals(scheme)
+                    || "sms".equals(scheme) || "mailto".equals(scheme)
+                    || "geo".equals(scheme)
+                    || "google.streetview".equals(scheme);
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Could not handle intent with URI: " + uri + "\n\tIs " +
+                    "this intent supported on your phone?";
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        }
+    },
+
+    /* 3 */ OPEN_NATIVE_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopubnativebrowser".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Unable to load mopub native browser url: " + uri;
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(uri);
+                Intents.launchIntentForUserClick(context, intent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 4 */ OPEN_APP_MARKET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+
+            return "play.google.com".equals(host) || "market.android.com".equals(host)
+                    || "market".equals(scheme)
+                    || uri.toString().startsWith("play.google.com/")
+                    || uri.toString().startsWith("market.android.com/");
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* 5 */ OPEN_IN_APP_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return (HTTP.equals(scheme) || HTTPS.equals(scheme));
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            if (!urlHandler.shouldSkipShowMoPubBrowser()) {
+                Intents.showMoPubBrowserForUrl(context, uri);
+            }
+        }
+    },
+
+    /**
+     * This handles tweet sharing via the chooser dialog.
+     * See {@link Intents#intentForShareTweet(Uri)} for more details.
+     */
+    /* 6 */ HANDLE_SHARE_TWEET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            Preconditions.checkNotNull(uri);
+            return "mopubshare".equals(uri.getScheme()) && "tweet".equals(uri.getHost());
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(uri);
+
+            final String chooserText = "Share via";
+            final String errorMessage = "Could not handle share tweet intent with URI " + uri;
+            try {
+                final Intent shareTweetIntent = Intents.intentForShareTweet(uri);
+                final Intent chooserIntent = Intent.createChooser(shareTweetIntent, chooserText);
+                Intents.launchIntentForUserClick(context, chooserIntent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 7 */ FOLLOW_DEEP_LINK_WITH_FALLBACK(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "deeplink+".equalsIgnoreCase(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+
+            // 1. Parse the URL as a valid deeplink+
+            if (!"navigate".equalsIgnoreCase(uri.getHost())) {
+                throw new IntentNotResolvableException("Deeplink+ URL did not have 'navigate' as" +
+                        " the host.");
+            }
+
+            final String primaryUrl;
+            final List<String> primaryTrackingUrls;
+            final String fallbackUrl;
+            final List<String> fallbackTrackingUrls;
+            try {
+                primaryUrl = uri.getQueryParameter("primaryUrl");
+                primaryTrackingUrls = uri.getQueryParameters("primaryTrackingUrl");
+                fallbackUrl = uri.getQueryParameter("fallbackUrl");
+                fallbackTrackingUrls = uri.getQueryParameters("fallbackTrackingUrl");
+            } catch (UnsupportedOperationException e) {
+                // If the URL is not hierarchical, getQueryParameter[s] will throw
+                // UnsupportedOperationException (see http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+                throw new IntentNotResolvableException("Deeplink+ URL was not a hierarchical" +
+                        " URI.");
+            }
+
+            if (primaryUrl == null) {
+                throw new IntentNotResolvableException("Deeplink+ did not have 'primaryUrl' query" +
+                        " param.");
+            }
+
+            final Uri primaryUri = Uri.parse(primaryUrl);
+            if (shouldTryHandlingUrl(primaryUri)) {
+                // Nested Deeplink+ URLs are not allowed
+                throw new IntentNotResolvableException("Deeplink+ had another Deeplink+ as the " +
+                        "'primaryUrl'.");
+            }
+
+            // 2. Attempt to handle the primary URL
+            try {
+                Intents.launchApplicationUrl(context, primaryUri);
+                makeTrackingHttpRequest(primaryTrackingUrls, context, BaseEvent.Name.CLICK_REQUEST);
+                return;
+            } catch (IntentNotResolvableException e) {
+                // Primary URL failed; proceed to attempt fallback URL
+            }
+
+            // 3. Attempt to handle the fallback URL
+            if (fallbackUrl == null) {
+                throw new IntentNotResolvableException("Unable to handle 'primaryUrl' for " +
+                        "Deeplink+ and 'fallbackUrl' was missing.");
+            }
+
+            if (shouldTryHandlingUrl(Uri.parse(fallbackUrl))) {
+                // Nested Deeplink+ URLs are not allowed
+                throw new IntentNotResolvableException("Deeplink+ URL had another Deeplink+ " +
+                        "URL as the 'fallbackUrl'.");
+            }
+
+            // UrlAction.handleUrl already verified this comes from a user interaction
+            final boolean fromUserInteraction = true;
+            urlHandler.handleUrl(context, fallbackUrl, true, fallbackTrackingUrls);
+        }
+    },
+
+    /* 8 */ FOLLOW_DEEP_LINK(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+            return !TextUtils.isEmpty(scheme) && !TextUtils.isEmpty(host);
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* This is essentially an "unspecified" value for UrlAction. */
+    NOOP(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return false;
+        }
+
+        @Override
+        protected void performAction(
+                @NonNull final Context context, @NonNull final Uri uri,
+                @NonNull final UrlHandler urlHandler)
+                throws IntentNotResolvableException { }
+    };
+
+    public void handleUrl(
+            UrlHandler urlHandler,
+            @NonNull final Context context,
+            @NonNull final Uri destinationUri,
+            final boolean fromUserInteraction)
+            throws IntentNotResolvableException {
+        MoPubLog.d("Ad event URL: " + destinationUri);
+        if (mRequiresUserInteraction && !fromUserInteraction) {
+            throw new IntentNotResolvableException("Attempted to handle action without user " +
+                    "interaction.");
+        } else {
+            performAction(context, destinationUri, urlHandler);
+        }
+    }
+
+    private final boolean mRequiresUserInteraction;
+
+    UrlAction(boolean requiresUserInteraction) {
+        mRequiresUserInteraction = requiresUserInteraction;
+    }
+
+    public abstract boolean shouldTryHandlingUrl(@NonNull final Uri uri);
+
+    protected abstract void performAction(
+            @NonNull final Context context, @NonNull final Uri uri,
+            @NonNull final UrlHandler urlHandler)
+            throws IntentNotResolvableException;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
new file mode 100644
index 00000000..74abd946
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
@@ -0,0 +1,332 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.util.EnumSet;
+
+import static com.mopub.common.UrlResolutionTask.UrlResolutionListener;
+import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
+
+/**
+ * {@code UrlHandler} facilitates handling user clicks on different URLs, allowing configuration
+ * for which kinds of URLs to handle and then responding accordingly for a given URL.
+ *
+ * This class is designed to be instantiated for a single use by immediately calling its {@link
+ * #handleUrl(Context, String)} method upon constructing it.
+ */
+public class UrlHandler {
+
+    /**
+     * {@code ClickListener} defines the methods that {@link UrlHandler} calls when handling a
+     * certain click succeeds or fails.
+     */
+    public interface ResultActions {
+        /**
+         * Called if the URL matched a supported {@link UrlAction} and was resolvable. Will be
+         * called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingFailed(String, UrlAction)}.
+         */
+        void urlHandlingSucceeded(@NonNull final String url, @NonNull final UrlAction urlAction);
+
+        /**
+         * Called with {@link UrlAction#NOOP} if the URL did not match any supported
+         * {@link UrlAction}s; or, called with the last matching {@link UrlAction} if URL was
+         * unresolvable. Will be called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingSucceeded(String, UrlAction)}.
+         */
+        void urlHandlingFailed(@NonNull final String url,
+                @NonNull final UrlAction lastFailedUrlAction);
+    }
+
+    /**
+     * {@code MoPubSchemeListener} defines the methods that {@link UrlHandler} calls when handling
+     * {@code HANDLE_MOPUB_SCHEME} URLs.
+     */
+    public interface MoPubSchemeListener {
+        void onFinishLoad();
+        void onClose();
+        void onFailLoad();
+    }
+
+    /**
+     * {@code Builder} provides an API to configure an immutable {@link UrlHandler} and create it.
+     */
+    public static class Builder {
+        @NonNull
+        private EnumSet<UrlAction> supportedUrlActions = EnumSet.of(UrlAction.NOOP);
+        @NonNull
+        private ResultActions resultActions = EMPTY_CLICK_LISTENER;
+        @NonNull
+        private MoPubSchemeListener moPubSchemeListener = EMPTY_MOPUB_SCHEME_LISTENER;
+        private boolean skipShowMoPubBrowser = false;
+
+        /**
+         * Sets the {@link UrlAction}s to support in the {@code UrlHandler} to build.
+         *
+         * @param first A {@code UrlAction} for the {@code UrlHandler} to support.
+         * @param others An arbitrary number of {@code UrlAction}s for the {@code UrlHandler} to
+         * support.
+         * @return A {@link Builder} with the desired supported {@code UrlAction}s added.
+         */
+        public Builder withSupportedUrlActions(@NonNull final UrlAction first,
+                @Nullable final UrlAction... others) {
+            this.supportedUrlActions = EnumSet.of(first, others);
+            return this;
+        }
+
+        /**
+         * Sets the {@link UrlAction}s to support in the {@code UrlHandler} to build.
+         *
+         * @param supportedUrlActions An {@code EnumSet} of {@code UrlAction}s for the
+         * {@code UrlHandler} to support.
+         * @return A {@link Builder} with the desired supported {@code UrlAction}s added.
+         */
+        public Builder withSupportedUrlActions(
+                @NonNull final EnumSet<UrlAction> supportedUrlActions) {
+            this.supportedUrlActions = EnumSet.copyOf(supportedUrlActions);
+            return this;
+        }
+        
+        /**
+         * Sets the {@link ResultActions} for the {@code UrlHandler} to
+         * build.
+         *
+         * @param resultActions A {@code ClickListener} for the {@code UrlHandler}.
+         * @return A {@link Builder} with the desired {@code ClickListener} added.
+         */
+        public Builder withResultActions(@NonNull final ResultActions resultActions) {
+            this.resultActions = resultActions;
+            return this;
+        }
+
+        /**
+         * Sets the {@link MoPubSchemeListener} for the {@code UrlHandler} to build.
+         *
+         * @param moPubSchemeListener A {@code MoPubSchemeListener} for the {@code UrlHandler}.
+         * @return A {@link Builder} with the desired {@code MoPubSchemeListener} added.
+         */
+        public Builder withMoPubSchemeListener(
+                @NonNull final MoPubSchemeListener moPubSchemeListener) {
+            this.moPubSchemeListener = moPubSchemeListener;
+            return this;
+        }
+
+        /**
+         * If called, will avoid starting a {@link MoPubBrowser} activity where applicable.
+         * (see {@link Intents#showMoPubBrowserForUrl(Context, Uri)})
+         *
+         * @return A {@link Builder} that will skip starting a {@code MoPubBrowser}.
+         */
+        public Builder withoutMoPubBrowser() {
+            this.skipShowMoPubBrowser = true;
+            return this;
+        }
+
+        /**
+         * Creates an immutable {@link UrlHandler} with the desired configuration, according to the
+         * other {@link Builder} methods called before.
+         *
+         * @return An immutable {@code UrlHandler} with the desired configuration.
+         */
+        public UrlHandler build() {
+            return new UrlHandler(supportedUrlActions, resultActions, moPubSchemeListener,
+                    skipShowMoPubBrowser);
+        }
+    }
+
+    private static final ResultActions EMPTY_CLICK_LISTENER = new ResultActions() {
+        @Override
+        public void urlHandlingSucceeded(@NonNull String url, @NonNull UrlAction urlAction) { }
+        @Override
+        public void urlHandlingFailed(@NonNull String url, @NonNull UrlAction lastFailedUrlAction) { }
+    };
+
+    private static final MoPubSchemeListener EMPTY_MOPUB_SCHEME_LISTENER =
+            new MoPubSchemeListener() {
+        @Override public void onFinishLoad() { }
+
+        @Override public void onClose() { }
+
+        @Override public void onFailLoad() { }
+    };
+
+    @NonNull
+    private EnumSet<UrlAction> mSupportedUrlActions;
+    @NonNull
+    private ResultActions mResultActions;
+    @NonNull
+    private MoPubSchemeListener mMoPubSchemeListener;
+    private boolean mSkipShowMoPubBrowser;
+    private boolean mAlreadySucceeded;
+    private boolean mTaskPending;
+
+    /**
+     * Do not instantiate UrlHandler directly; use {@link Builder} instead.
+     */
+    private UrlHandler(
+            @NonNull final EnumSet<UrlAction> supportedUrlActions,
+            @NonNull final ResultActions resultActions,
+            @NonNull final MoPubSchemeListener moPubSchemeListener,
+            final boolean skipShowMoPubBrowser) {
+        mSupportedUrlActions = EnumSet.copyOf(supportedUrlActions);
+        mResultActions = resultActions;
+        mMoPubSchemeListener = moPubSchemeListener;
+        mSkipShowMoPubBrowser = skipShowMoPubBrowser;
+        mAlreadySucceeded = false;
+        mTaskPending = false;
+    }
+
+    @NonNull
+    EnumSet<UrlAction> getSupportedUrlActions() {
+        return EnumSet.copyOf(mSupportedUrlActions);
+    }
+
+    @NonNull
+    ResultActions getResultActions() {
+        return mResultActions;
+    }
+
+    @NonNull
+    MoPubSchemeListener getMoPubSchemeListener() {
+        return mMoPubSchemeListener;
+    }
+
+    boolean shouldSkipShowMoPubBrowser() {
+        return mSkipShowMoPubBrowser;
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl) {
+        Preconditions.checkNotNull(context);
+
+        handleUrl(context, destinationUrl, true);
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     * @param fromUserInteraction Whether this handling was triggered from a user interaction.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl,
+            final boolean fromUserInteraction) {
+        Preconditions.checkNotNull(context);
+
+        handleUrl(context, destinationUrl, fromUserInteraction, null);
+    }
+
+    /**
+     * Follows any redirects from {@code destinationUrl} and then handles the URL accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     * @param fromUserInteraction Whether this handling was triggered from a user interaction.
+     * @param trackingUrls Optional tracking URLs to trigger on success
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl,
+            final boolean fromUserInteraction, @Nullable final Iterable<String> trackingUrls) {
+        Preconditions.checkNotNull(context);
+
+        if (TextUtils.isEmpty(destinationUrl)) {
+            failUrlHandling(destinationUrl, null, "Attempted to handle empty url.", null);
+            return;
+        }
+
+        final UrlResolutionListener urlResolutionListener = new UrlResolutionListener() {
+            @Override
+            public void onSuccess(@NonNull final String resolvedUrl) {
+                mTaskPending = false;
+                handleResolvedUrl(context, resolvedUrl, fromUserInteraction, trackingUrls);
+            }
+
+            @Override
+            public void onFailure(@NonNull final String message,
+                    @Nullable final Throwable throwable) {
+                mTaskPending = false;
+                failUrlHandling(destinationUrl, null, message, throwable);
+
+            }
+
+        };
+
+        UrlResolutionTask.getResolvedUrl(destinationUrl, urlResolutionListener);
+        mTaskPending = true;
+    }
+
+    /**
+     * Performs the actual url handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param url The URL to handle.
+     * @param fromUserInteraction Whether this handling was triggered from a user interaction.
+     * @param trackingUrls Optional tracking URLs to trigger on success
+     * @return true if the given URL was successfully handled; false otherwise
+     */
+    public boolean handleResolvedUrl(@NonNull final Context context,
+            @NonNull final String url, final boolean fromUserInteraction,
+            @Nullable Iterable<String> trackingUrls) {
+        if (TextUtils.isEmpty(url)) {
+            failUrlHandling(url, null, "Attempted to handle empty url.", null);
+            return false;
+        }
+
+        UrlAction lastFailedUrlAction = UrlAction.NOOP;
+        final Uri destinationUri = Uri.parse(url);
+
+        for (final UrlAction urlAction : mSupportedUrlActions) {
+            if (urlAction.shouldTryHandlingUrl(destinationUri)) {
+                try {
+                    urlAction.handleUrl(UrlHandler.this, context, destinationUri,
+                            fromUserInteraction);
+                    if (!mAlreadySucceeded && !mTaskPending
+                            && !UrlAction.IGNORE_ABOUT_SCHEME.equals(urlAction)
+                            && !UrlAction.HANDLE_MOPUB_SCHEME.equals(urlAction)) {
+                        makeTrackingHttpRequest(trackingUrls, context,
+                                BaseEvent.Name.CLICK_REQUEST);
+                        mResultActions.urlHandlingSucceeded(destinationUri.toString(),
+                                urlAction);
+                        mAlreadySucceeded = true;
+                    }
+                    return true;
+                } catch (IntentNotResolvableException e) {
+                    MoPubLog.d(e.getMessage(), e);
+                    lastFailedUrlAction = urlAction;
+                    // continue trying to match...
+                }
+            }
+        }
+        failUrlHandling(url, lastFailedUrlAction, "Link ignored. Unable to handle url: " + url, null);
+        return false;
+    }
+
+    private void failUrlHandling(@Nullable final String url, @Nullable UrlAction urlAction,
+            @NonNull final String message, @Nullable final Throwable throwable) {
+        Preconditions.checkNotNull(message);
+
+        if (urlAction == null) {
+            urlAction = UrlAction.NOOP;
+        }
+
+        MoPubLog.d(message, throwable);
+        mResultActions.urlHandlingFailed(url, urlAction);
+    }
+
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java b/mopub-sdk/src/main/java/com/mopub/common/UrlResolutionTask.java
similarity index 66%
rename from mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
rename to mopub-sdk/src/main/java/com/mopub/common/UrlResolutionTask.java
index 119b4ed8..823f39c2 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlResolutionTask.java
@@ -1,43 +1,45 @@
-package com.mopub.nativeads;
+package com.mopub.common;
 
+import android.net.Uri;
 import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.common.logging.MoPubLog;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
 
-class UrlResolutionTask extends AsyncTask<String, Void, String> {
+@VisibleForTesting
+public class UrlResolutionTask extends AsyncTask<String, Void, String> {
     private static final int REDIRECT_LIMIT = 10;
 
     interface UrlResolutionListener {
-        void onSuccess(String resolvedUrl);
-        void onFailure();
+        void onSuccess(@NonNull final String resolvedUrl);
+        void onFailure(@NonNull final String message, @Nullable final Throwable throwable);
     }
 
-    private final UrlResolutionListener mListener;
+    @NonNull private final UrlResolutionListener mListener;
 
-    public static void getResolvedUrl(final String urlString, final UrlResolutionListener listener) {
+    public static void getResolvedUrl(@NonNull final String urlString,
+            @NonNull final UrlResolutionListener listener) {
         final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
 
         try {
             AsyncTasks.safeExecuteOnExecutor(urlResolutionTask, urlString);
         } catch (Exception e) {
-            MoPubLog.d("Failed to resolve url", e);
-
-            listener.onFailure();
+            listener.onFailure("Failed to resolve url", e);
         }
     }
 
-    UrlResolutionTask(UrlResolutionListener listener) {
+    UrlResolutionTask(@NonNull UrlResolutionListener listener) {
         mListener = listener;
     }
 
+    @Nullable
     @Override
-    protected String doInBackground(String... urls) {
+    protected String doInBackground(@Nullable String... urls) {
         if (urls == null || urls.length == 0) {
             return null;
         }
@@ -50,7 +52,7 @@ protected String doInBackground(String... urls) {
             while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
                 // if location url is not http(s), assume it's an Android deep link
                 // this scheme will fail URL validation so we have to check early
-                if (!IntentUtils.isHttpUrl(locationUrl)) {
+                if (!UrlAction.OPEN_IN_APP_BROWSER.shouldTryHandlingUrl(Uri.parse(locationUrl))) {
                     return locationUrl;
                 }
 
@@ -66,7 +68,8 @@ protected String doInBackground(String... urls) {
         return previousUrl;
     }
 
-    private String getRedirectLocation(final String urlString) throws IOException {
+    @Nullable
+    private String getRedirectLocation(@NonNull final String urlString) throws IOException {
         final URL url = new URL(urlString);
 
         HttpURLConnection httpUrlConnection = null;
@@ -89,7 +92,7 @@ private String getRedirectLocation(final String urlString) throws IOException {
     }
 
     @Override
-    protected void onPostExecute(final String resolvedUrl) {
+    protected void onPostExecute(@Nullable final String resolvedUrl) {
         super.onPostExecute(resolvedUrl);
 
         if (isCancelled() || resolvedUrl == null) {
@@ -103,7 +106,7 @@ protected void onPostExecute(final String resolvedUrl) {
     protected void onCancelled() {
         super.onCancelled();
 
-        mListener.onFailure();
+        mListener.onFailure("Task for resolving url was cancelled", null);
     }
 }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
index 4e053528..db599026 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
@@ -1,43 +1,572 @@
 package com.mopub.common.event;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class BaseEvent {
-    public enum Type {
-        NETWORK_REQUEST("request"),
-        DATA_ERROR("invalid_data");
 
-        public final String mName;
-        Type(String name) {
+    public static enum ScribeCategory {
+        EXCHANGE_CLIENT_EVENT("exchange_client_event"),
+        EXCHANGE_CLIENT_ERROR("exchange_client_error");
+
+        @NonNull private final String mScribeCategory;
+        private ScribeCategory(@NonNull String scribeCategory) {
+            mScribeCategory = scribeCategory;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mScribeCategory;
+        }
+    }
+
+    public static enum SdkProduct {
+        NONE(0),
+        WEB_VIEW(1),
+        NATIVE(2);
+
+        private final int mType;
+        private SdkProduct(int type) {
+            mType = type;
+        }
+
+        public int getType() {
+            return mType;
+        }
+    }
+
+    public static enum AppPlatform {
+        NONE(0),
+        IOS(1),
+        ANDROID(2),
+        MOBILE_WEB(3);
+
+        private final int mType;
+        private AppPlatform(int type) {
+            mType = type;
+        }
+
+        public int getType() {
+            return mType;
+        }
+    }
+
+    public enum Name {
+        AD_REQUEST("ad_request"),
+        IMPRESSION_REQUEST("impression_request"),
+        CLICK_REQUEST("click_request");
+
+        @NonNull private final String mName;
+        private Name(@NonNull String name) {
             mName = name;
         }
+
+        @NonNull
+        public String getName() {
+            return mName;
+        }
+    }
+
+    public enum Category {
+        REQUESTS("requests");
+
+        @NonNull private final String mCategory;
+        private Category(@NonNull String category) {
+            mCategory = category;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mCategory;
+        }
+    }
+
+    public enum SamplingRate {
+        AD_REQUEST(0.1);
+
+        private final double mSamplingRate;
+        private SamplingRate(double samplingRate) {
+            mSamplingRate = samplingRate;
+        }
+
+        public double getSamplingRate() {
+            return mSamplingRate;
+        }
+    }
+
+    @NonNull private final ScribeCategory mScribeCategory;
+    @NonNull private final Name mName;
+    @NonNull private final Category mCategory;
+    @Nullable private final SdkProduct mSdkProduct;
+    @Nullable private final String mAdUnitId;
+    @Nullable private final String mAdCreativeId;
+    @Nullable private final String mAdType;
+    @Nullable private final String mAdNetworkType;
+    @Nullable private final Double mAdWidthPx;
+    @Nullable private final Double mAdHeightPx;
+    @Nullable private final Integer mDeviceScreenWidthDip;
+    @Nullable private final Integer mDeviceScreenHeightDip;
+    @Nullable private final Double mGeoLat;
+    @Nullable private final Double mGeoLon;
+    @Nullable private final Double mGeoAccuracy;
+    @Nullable private final MoPubNetworkType mNetworkType;
+    @Nullable private final String mNetworkOperator;
+    @Nullable private final String mNetworkOperatorName;
+    @Nullable private final String mIsoCountryCode;
+    @Nullable private final String mSimOperator;
+    @Nullable private final String mSimOperatorName;
+    @Nullable private final String mSimIsoCountryCode;
+    @Nullable private final Double mPerformanceDurationMs;
+    @Nullable private final String mRequestId;
+    @Nullable private final Integer mRequestStatusCode;
+    @Nullable private final String mRequestUri;
+    @Nullable private final Integer mRequestRetries;
+    private final long mTimestampUtcMs;
+    @Nullable private ClientMetadata mClientMetaData;
+
+     /**
+     * The percentage of events, in range 0 - 1.0, to be logged.
+     */
+    private final double mSamplingRate;
+
+    public BaseEvent(@NonNull final Builder builder) {
+        Preconditions.checkNotNull(builder);
+
+        mScribeCategory = builder.mScribeCategory;
+        mName = builder.mName;
+        mCategory = builder.mCategory;
+        mSdkProduct = builder.mSdkProduct;
+        mAdUnitId = builder.mAdUnitId;
+        mAdCreativeId = builder.mAdCreativeId;
+        mAdType = builder.mAdType;
+        mAdNetworkType = builder.mAdNetworkType;
+        mAdWidthPx = builder.mAdWidthPx;
+        mAdHeightPx = builder.mAdHeightPx;
+        mGeoLat = builder.mGeoLat;
+        mGeoLon = builder.mGeoLon;
+        mGeoAccuracy = builder.mGeoAccuracy;
+        mPerformanceDurationMs = builder.mPerformanceDurationMs;
+        mRequestId = builder.mRequestId;
+        mRequestStatusCode = builder.mRequestStatusCode;
+        mRequestUri = builder.mRequestUri;
+        mRequestRetries = builder.mRequestRetries;
+        mSamplingRate = builder.mSamplingRate;
+        mTimestampUtcMs = System.currentTimeMillis();
+
+        mClientMetaData = ClientMetadata.getInstance();
+        if (mClientMetaData != null) {
+            mDeviceScreenWidthDip = mClientMetaData.getDeviceScreenWidthDip();
+            mDeviceScreenHeightDip = mClientMetaData.getDeviceScreenHeightDip();
+            mNetworkType = mClientMetaData.getActiveNetworkType();
+            mNetworkOperator = mClientMetaData.getNetworkOperator();
+            mNetworkOperatorName = mClientMetaData.getNetworkOperatorName();
+            mIsoCountryCode = mClientMetaData.getIsoCountryCode();
+            mSimOperator = mClientMetaData.getSimOperator();
+            mSimOperatorName = mClientMetaData.getSimOperatorName();
+            mSimIsoCountryCode = mClientMetaData.getSimIsoCountryCode();
+        } else {
+            // Need to silence warnings about variables not being initialized
+            mDeviceScreenWidthDip = null;
+            mDeviceScreenHeightDip = null;
+            mNetworkType = null;
+            mNetworkOperator = null;
+            mNetworkOperatorName = null;
+            mIsoCountryCode = null;
+            mSimOperator = null;
+            mSimOperatorName = null;
+            mSimIsoCountryCode = null;
+        }
+    }
+
+    @NonNull
+    public ScribeCategory getScribeCategory() {
+        return mScribeCategory;
+    }
+
+    @NonNull
+    public Name getName() {
+        return mName;
+    }
+
+    @NonNull
+    public Category getCategory() {
+        return mCategory;
+    }
+
+    @Nullable
+    public SdkProduct getSdkProduct() {
+        return mSdkProduct;
+    }
+
+    @Nullable
+    public String getSdkVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getSdkVersion();
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    @Nullable
+    public String getAdCreativeId() {
+        return mAdCreativeId;
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mAdType;
+    }
+
+    @Nullable
+    public String getAdNetworkType() {
+        return mAdNetworkType;
+    }
+
+    @Nullable
+    public Double getAdWidthPx() {
+        return mAdWidthPx;
+    }
+
+    @Nullable
+    public Double getAdHeightPx() {
+        return mAdHeightPx;
+    }
+
+    @Nullable
+    public AppPlatform getAppPlatform() {
+        return AppPlatform.ANDROID;
+    }
+
+    @Nullable
+    public String getAppName() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppName();
+    }
+
+    @Nullable
+    public String getAppPackageName() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppPackageName();
+    }
+
+    @Nullable
+    public String getAppVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppVersion();
+    }
+
+    @Nullable
+    public String getClientAdvertisingId() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceId();
+    }
+
+    @NonNull
+    public String getObfuscatedClientAdvertisingId() {
+        // This is a placeholder for the advertising id until we approve a plan to use the
+        // real value
+        return "ifa:XXXX";
     }
 
-    private final ClientMetadata mMetadata;
-    private final String mEventName;
-    private final String mRequestUrl;
-    private final long mEventTimeUtcMillis;
+    @NonNull
+    public Boolean getClientDoNotTrack() {
+        // Default to true if we don't have access to the client meta data
+        return mClientMetaData == null || mClientMetaData.isDoNotTrackSet();
+    }
+
+    @Nullable
+    public String getDeviceManufacturer() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceManufacturer();
+    }
+
+    @Nullable
+    public String getDeviceModel() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceModel();
+    }
+
+    @Nullable
+    public String getDeviceProduct() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceProduct();
+    }
+
+    @Nullable
+    public String getDeviceOsVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceOsVersion();
+    }
+
+    @Nullable
+    public Integer getDeviceScreenWidthDip() {
+        return mDeviceScreenWidthDip;
+    }
+
+    @Nullable
+    public Integer getDeviceScreenHeightDip() {
+        return mDeviceScreenHeightDip;
+    }
+
+    @Nullable
+    public Double getGeoLat() {
+        return mGeoLat;
+    }
+
+    @Nullable
+    public Double getGeoLon() {
+        return mGeoLon;
+    }
+
+    @Nullable
+    public Double getGeoAccuracy() {
+        return mGeoAccuracy;
+    }
+
+    @Nullable
+    public Double getPerformanceDurationMs() {
+        return mPerformanceDurationMs;
+    }
+
+    @Nullable
+    public MoPubNetworkType getNetworkType() {
+        return mNetworkType;
+    }
+
+    @Nullable
+    public String getNetworkOperatorCode() {
+        return mNetworkOperator;
+    }
+
+    @Nullable
+    public String getNetworkOperatorName() {
+        return mNetworkOperatorName;
+    }
+
+    @Nullable
+    public String getNetworkIsoCountryCode() {
+        return mIsoCountryCode;
+    }
+
+    @Nullable
+    public String getNetworkSimCode() {
+        return mSimOperator;
+    }
+
+    @Nullable
+    public String getNetworkSimOperatorName() {
+        return mSimOperatorName;
+    }
+
+    @Nullable
+    public String getNetworkSimIsoCountryCode() {
+        return mSimIsoCountryCode;
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
+    @Nullable
+    public Integer getRequestStatusCode() {
+        return mRequestStatusCode;
+    }
 
-    BaseEvent(Type eventType, String requestUrl, ClientMetadata metadata) {
-        mEventTimeUtcMillis = System.currentTimeMillis();
-        mEventName = eventType.mName;
-        mRequestUrl = requestUrl;
-        mMetadata = metadata;
+    @Nullable
+    public String getRequestUri() {
+        return mRequestUri;
     }
 
-    public long getEventTimeUtcMillis() {
-        return mEventTimeUtcMillis;
+    @Nullable
+    public Integer getRequestRetries() {
+        return mRequestRetries;
     }
 
-    public String getRequestUrl() {
-        return mRequestUrl;
+    public double getSamplingRate() {
+        return mSamplingRate;
     }
 
-    public String getEventName() {
-        return mEventName;
+    @NonNull
+    public Long getTimestampUtcMs() {
+        return mTimestampUtcMs;
     }
 
-    public ClientMetadata getMetadata() {
-        return mMetadata;
+    @Override
+    public String toString() {
+        return  "BaseEvent\n" +
+                "ScribeCategory: " + getScribeCategory() + "\n" +
+                "Name: " + getName() + "\n" +
+                "Category: " + getCategory() + "\n" +
+                "SdkProduct: " + getSdkProduct() + "\n" +
+                "SdkVersion: " + getSdkVersion() + "\n" +
+                "AdUnitId: " + getAdUnitId() + "\n" +
+                "AdCreativeId: " + getAdCreativeId() + "\n" +
+                "AdType: " + getAdType() + "\n" +
+                "AdNetworkType: " + getAdNetworkType() + "\n" +
+                "AdWidthPx: " + getAdWidthPx() + "\n" +
+                "AdHeightPx: " + getAdHeightPx() + "\n" +
+                "AppPlatform: " + getAppPlatform() + "\n" +
+                "AppName: " + getAppName() + "\n" +
+                "AppPackageName: " + getAppPackageName() + "\n" +
+                "AppVersion: " + getAppVersion() + "\n" +
+                "DeviceManufacturer: " + getDeviceManufacturer() + "\n" +
+                "DeviceModel: " + getDeviceModel() + "\n" +
+                "DeviceProduct: " + getDeviceProduct() + "\n" +
+                "DeviceOsVersion: " + getDeviceOsVersion() + "\n" +
+                "DeviceScreenWidth: " + getDeviceScreenWidthDip() + "\n" +
+                "DeviceScreenHeight: " + getDeviceScreenHeightDip() + "\n" +
+                "GeoLat: " + getGeoLat() + "\n" +
+                "GeoLon: " + getGeoLon() + "\n" +
+                "GeoAccuracy: " + getGeoAccuracy() + "\n" +
+                "PerformanceDurationMs: " + getPerformanceDurationMs() + "\n" +
+                "NetworkType: " + getNetworkType() + "\n" +
+                "NetworkOperatorCode: " + getNetworkOperatorCode() + "\n" +
+                "NetworkOperatorName: " + getNetworkOperatorName() + "\n" +
+                "NetworkIsoCountryCode: " + getNetworkIsoCountryCode() + "\n" +
+                "NetworkSimCode: " + getNetworkSimCode() + "\n" +
+                "NetworkSimOperatorName: " + getNetworkSimOperatorName() + "\n" +
+                "NetworkSimIsoCountryCode: " + getNetworkSimIsoCountryCode() + "\n" +
+                "RequestId: " + getRequestId() + "\n" +
+                "RequestStatusCode: " + getRequestStatusCode() + "\n" +
+                "RequestUri: " + getRequestUri() + "\n" +
+                "RequestRetries: " + getRequestRetries() + "\n" +
+                "SamplingRate: " + getSamplingRate() + "\n" +
+                "TimestampUtcMs: " + new SimpleDateFormat().format(new Date(getTimestampUtcMs())) + "\n";
+    }
+
+    public static abstract class Builder {
+        @NonNull private ScribeCategory mScribeCategory;
+        @NonNull private Name mName;
+        @NonNull private Category mCategory;
+        @Nullable private SdkProduct mSdkProduct;
+        @Nullable private String mAdUnitId;
+        @Nullable private String mAdCreativeId;
+        @Nullable private String mAdType;
+        @Nullable private String mAdNetworkType;
+        @Nullable private Double mAdWidthPx;
+        @Nullable private Double mAdHeightPx;
+        @Nullable private Double mGeoLat;
+        @Nullable private Double mGeoLon;
+        @Nullable private Double mGeoAccuracy;
+        @Nullable private Double mPerformanceDurationMs;
+        @Nullable private String mRequestId;
+        @Nullable private Integer mRequestStatusCode;
+        @Nullable private String mRequestUri;
+        @Nullable private Integer mRequestRetries;
+
+        /**
+         * The percentage of events, in range 0 - 1.0, to be logged.
+         */
+        private double mSamplingRate;
+
+        public Builder(@NonNull ScribeCategory scribeCategory,
+                @NonNull Name name,
+                @NonNull Category category,
+                double samplingRate) {
+            Preconditions.checkNotNull(scribeCategory);
+            Preconditions.checkNotNull(name);
+            Preconditions.checkNotNull(category);
+            Preconditions.checkArgument(samplingRate >= 0 && samplingRate <= 1.0);
+
+            mScribeCategory = scribeCategory;
+            mName = name;
+            mCategory = category;
+            mSamplingRate = samplingRate;
+        }
+
+        @NonNull
+        public Builder withSdkProduct(@Nullable SdkProduct sdkProduct) {
+            mSdkProduct = sdkProduct;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdUnitId(@Nullable String adUnitId) {
+            mAdUnitId = adUnitId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdCreativeId(@Nullable String adCreativeId) {
+            mAdCreativeId = adCreativeId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdType(@Nullable String adType) {
+            mAdType = adType;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdNetworkType(@Nullable String adNetworkType) {
+            mAdNetworkType = adNetworkType;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdWidthPx(@Nullable Double adWidthPx) {
+            mAdWidthPx = adWidthPx;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdHeightPx(@Nullable Double adHeightPx) {
+            mAdHeightPx = adHeightPx;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoLat(@Nullable Double geoLat) {
+            mGeoLat = geoLat;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoLon(@Nullable Double geoLon) {
+            mGeoLon = geoLon;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoAccuracy(@Nullable Double geoAccuracy) {
+            mGeoAccuracy = geoAccuracy;
+            return this;
+        }
+
+        @NonNull
+        public Builder withPerformanceDurationMs(@Nullable Double performanceDurationMs) {
+            mPerformanceDurationMs = performanceDurationMs;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestId(@Nullable String requestId) {
+            mRequestId = requestId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestStatusCode(@Nullable Integer requestStatusCode) {
+            mRequestStatusCode = requestStatusCode;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestUri(@Nullable String requestUri) {
+            mRequestUri = requestUri;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestRetries(@Nullable Integer requestRetries) {
+            mRequestRetries = requestRetries;
+            return this;
+        }
+
+        public abstract BaseEvent build();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
new file mode 100644
index 00000000..05a3d93f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
@@ -0,0 +1,160 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+/**
+ * Immutable data class with error event data.
+ */
+public class ErrorEvent extends BaseEvent {
+    @Nullable private final String mErrorExceptionClassName;
+    @Nullable private final String mErrorMessage;
+    @Nullable private final String mErrorStackTrace;
+    @Nullable private final String mErrorFileName;
+    @Nullable private final String mErrorClassName;
+    @Nullable private final String mErrorMethodName;
+    @Nullable private final Integer mErrorLineNumber;
+
+    private ErrorEvent(@NonNull Builder builder) {
+        super(builder);
+        mErrorExceptionClassName = builder.mErrorExceptionClassName;
+        mErrorMessage = builder.mErrorMessage;
+        mErrorStackTrace = builder.mErrorStackTrace;
+        mErrorFileName = builder.mErrorFileName;
+        mErrorClassName = builder.mErrorClassName;
+        mErrorMethodName = builder.mErrorMethodName;
+        mErrorLineNumber = builder.mErrorLineNumber;
+    }
+
+    @Nullable
+    public String getErrorExceptionClassName() {
+        return mErrorExceptionClassName;
+    }
+
+    @Nullable
+    public String getErrorMessage() {
+        return mErrorMessage;
+    }
+
+    @Nullable
+    public String getErrorStackTrace() {
+        return mErrorStackTrace;
+    }
+
+    @Nullable
+    public String getErrorFileName() {
+        return mErrorFileName;
+    }
+
+    @Nullable
+    public String getErrorClassName() {
+        return mErrorClassName;
+    }
+
+    @Nullable
+    public String getErrorMethodName() {
+        return mErrorMethodName;
+    }
+
+    @Nullable
+    public Integer getErrorLineNumber() {
+        return mErrorLineNumber;
+    }
+
+    @Override
+    public String toString() {
+        final String string = super.toString();
+        return string +
+                "ErrorEvent\n" +
+                "ErrorExceptionClassName: " + getErrorExceptionClassName() + "\n" +
+                "ErrorMessage: " + getErrorMessage() + "\n" +
+                "ErrorStackTrace: " + getErrorStackTrace() + "\n" +
+                "ErrorFileName: " + getErrorFileName() + "\n" +
+                "ErrorClassName: " + getErrorClassName() + "\n" +
+                "ErrorMethodName: " + getErrorMethodName() + "\n" +
+                "ErrorLineNumber: " + getErrorLineNumber() + "\n";
+    }
+
+    public static class Builder extends BaseEvent.Builder {
+        @Nullable private String mErrorExceptionClassName;
+        @Nullable private String mErrorMessage;
+        @Nullable private String mErrorStackTrace;
+        @Nullable private String mErrorFileName;
+        @Nullable private String mErrorClassName;
+        @Nullable private String mErrorMethodName;
+        @Nullable private Integer mErrorLineNumber;
+
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_ERROR, name, category, samplingRate);
+        }
+
+        @NonNull
+        public Builder withErrorExceptionClassName(@Nullable String errorExceptionClassName) {
+            mErrorExceptionClassName = errorExceptionClassName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorMessage(@Nullable String errorMessage) {
+            mErrorMessage = errorMessage;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorStackTrace(@Nullable String errorStackTrace) {
+            mErrorStackTrace = errorStackTrace;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorFileName(@Nullable String errorFileName) {
+            mErrorFileName = errorFileName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorClassName(@Nullable String errorClassName) {
+            mErrorClassName = errorClassName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorMethodName(@Nullable String errorMethodName) {
+            mErrorMethodName = errorMethodName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorLineNumber(@Nullable Integer errorLineNumber) {
+            mErrorLineNumber = errorLineNumber;
+            return this;
+        }
+
+        @NonNull
+        public Builder withException(@Nullable Exception exception) {
+            mErrorExceptionClassName = exception.getClass().getName();
+            mErrorMessage = exception.getMessage();
+
+            StringWriter stringWriter = new StringWriter();
+            exception.printStackTrace(new PrintWriter(stringWriter));
+            mErrorStackTrace = stringWriter.toString();
+
+            if (exception.getStackTrace().length > 0) {
+                mErrorFileName = exception.getStackTrace()[0].getFileName();
+                mErrorClassName = exception.getStackTrace()[0].getClassName();
+                mErrorMethodName = exception.getStackTrace()[0].getMethodName();
+                mErrorLineNumber = exception.getStackTrace()[0].getLineNumber();
+            }
+            return this;
+        }
+
+        @NonNull
+        @Override
+        public ErrorEvent build() {
+            return new ErrorEvent(this);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
index fee902fd..4228ab35 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
@@ -1,12 +1,24 @@
 package com.mopub.common.event;
 
-import com.mopub.common.ClientMetadata;
+import android.support.annotation.NonNull;
 
 /**
  * Immutable data class with client event data.
  */
 public class Event extends BaseEvent {
-    Event(final Type eventType, final String requestUrl, final ClientMetadata metadata) {
-        super(eventType, requestUrl, metadata);
+    private Event(@NonNull Builder builder) {
+        super(builder);
+    }
+
+    public static class Builder extends BaseEvent.Builder {
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_EVENT, name, category, samplingRate);
+        }
+
+        @NonNull
+        @Override
+        public Event build() {
+            return new Event(this);
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
new file mode 100644
index 00000000..f5ca5dbc
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
@@ -0,0 +1,49 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+public class EventDispatcher {
+    private final Iterable<EventRecorder> mEventRecorders;
+    private final Looper mLooper;
+    private final Handler mMessageHandler;
+    private final Handler.Callback mHandlerCallback;
+
+    @VisibleForTesting
+    EventDispatcher(Iterable<EventRecorder> recorders, Looper looper) {
+        mEventRecorders = recorders;
+        mLooper = looper;
+        mHandlerCallback = new Handler.Callback() {
+            @Override
+            public boolean handleMessage(final Message msg) {
+                if (msg.obj instanceof BaseEvent) {
+                    for (final EventRecorder recorder : mEventRecorders) {
+                        recorder.record((BaseEvent) msg.obj);
+                    }
+                } else {
+                    MoPubLog.d("EventDispatcher received non-BaseEvent message type.");
+                }
+                return true;
+            }
+        };
+        mMessageHandler = new Handler(mLooper, mHandlerCallback);
+    }
+
+    public void dispatch(BaseEvent event) {
+        Message.obtain(mMessageHandler, 0, event).sendToTarget();
+    }
+
+    @VisibleForTesting
+    Iterable<EventRecorder> getEventRecorders() {
+        return mEventRecorders;
+    }
+
+    @VisibleForTesting
+    Handler.Callback getHandlerCallback() {
+        return mHandlerCallback;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
index 13ed5518..efaa5515 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
@@ -4,6 +4,5 @@
  * This interface represents a backend to which MoPub client events are logged.
  */
 public interface EventRecorder {
-    public void recordEvent(Event event);
-    public void recordTimedEvent(TimedEvent event);
+    public void record(BaseEvent baseEvent);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
new file mode 100644
index 00000000..607d28d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
@@ -0,0 +1,39 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.Random;
+
+/**
+ * Samples events based on rules defined in the sample method.
+ */
+public class EventSampler {
+
+    @NonNull private Random mRandom;
+
+    public EventSampler() {
+        this(new Random());
+    }
+
+    @VisibleForTesting
+    public EventSampler(@NonNull Random random) {
+        mRandom = random;
+    }
+
+    /**
+     * Samples events based on custom rules.
+     *
+     * @param baseEvent The event to be sampled.
+     *
+     * @return Will return {@code true} if the event passed sampling and {@code false}
+     * if it is to be discarded.
+     */
+    boolean sample(@NonNull BaseEvent baseEvent) {
+        Preconditions.checkNotNull(baseEvent);
+
+        return mRandom.nextDouble() < baseEvent.getSamplingRate();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
new file mode 100644
index 00000000..94cf7c31
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.List;
+
+/**
+ * Serializes events to the data format expected by the Scribe service.
+ */
+public class EventSerializer {
+
+    /**
+     * Serializes a list of events as a JSON array of flattened JSON objects.
+     *
+     * @param events The events to be serialized.
+     *
+     * @return Will return a {@code JSONArray} of serialized {@code JSONObject}s.
+     */
+    @NonNull
+    public JSONArray serializeAsJson(@NonNull List<BaseEvent> events) {
+        Preconditions.checkNotNull(events);
+
+        JSONArray jsonArray = new JSONArray();
+        for (BaseEvent event : events) {
+            try {
+                jsonArray.put(serializeAsJson(event));
+            } catch (JSONException e) {
+                MoPubLog.d("Failed to serialize event \"" + event.getName() + "\" to JSON: ", e);
+            }
+        }
+        return jsonArray;
+    }
+
+    /**
+     * Serializes a single event as a flattened JSON object. Key values are expected by the Scribe
+     * service.
+     *
+     * @param event The event to be serialized.
+     *
+     * @return Will return a single serialized {@code JSONObject}.
+     */
+    @NonNull
+    public JSONObject serializeAsJson(@NonNull BaseEvent event) throws JSONException {
+        Preconditions.checkNotNull(event);
+
+        // Note: adding null values to the JSONObject will remove the key value pair
+        JSONObject jsonObject = new JSONObject();
+
+        // Required Scribe Request Keys
+        jsonObject.put("_category_", event.getScribeCategory().getCategory());
+        jsonObject.put("ts", event.getTimestampUtcMs());
+
+        // Name Details
+        jsonObject.put("name",  event.getName().getName());
+        jsonObject.put("name_category", event.getCategory().getCategory());
+
+        // SDK Details
+        BaseEvent.SdkProduct sdkProduct = event.getSdkProduct();
+        jsonObject.put("sdk_product", sdkProduct == null ? null : sdkProduct.getType());
+        jsonObject.put("sdk_version", event.getSdkVersion());
+
+        // Ad Details
+        jsonObject.put("ad_unit_id", event.getAdUnitId());
+        jsonObject.put("ad_creative_id", event.getAdCreativeId());
+        jsonObject.put("ad_type", event.getAdType());
+        jsonObject.put("ad_network_type", event.getAdNetworkType());
+        jsonObject.put("ad_width_px", event.getAdWidthPx());
+        jsonObject.put("ad_height_px", event.getAdHeightPx());
+
+        // App Details
+        BaseEvent.AppPlatform appPlatform = event.getAppPlatform();
+        jsonObject.put("app_platform", appPlatform == null ? null : appPlatform.getType());
+        jsonObject.put("app_name", event.getAppName());
+        jsonObject.put("app_package_name", event.getAppPackageName());
+        jsonObject.put("app_version", event.getAppVersion());
+
+        // Client Details
+        // Server side requires these values to be populated to satisfy thrift union
+        jsonObject.put("client_advertising_id", event.getObfuscatedClientAdvertisingId());
+        jsonObject.put("client_do_not_track", event.getClientDoNotTrack());
+
+        // Device Details
+        jsonObject.put("device_manufacturer", event.getDeviceManufacturer());
+        jsonObject.put("device_model", event.getDeviceModel());
+        jsonObject.put("device_product", event.getDeviceProduct());
+        jsonObject.put("device_os_version", event.getDeviceOsVersion());
+
+        // These fields will actually be the dip value until deprecated and new fields
+        // added for future releases
+        jsonObject.put("device_screen_width_px", event.getDeviceScreenWidthDip());
+        jsonObject.put("device_screen_height_px", event.getDeviceScreenHeightDip());
+
+        // Geo Details
+        jsonObject.put("geo_lat", event.getGeoLat());
+        jsonObject.put("geo_lon", event.getGeoLon());
+        jsonObject.put("geo_accuracy_radius_meters", event.getGeoAccuracy());
+
+        // Performance Details
+        jsonObject.put("perf_duration_ms", event.getPerformanceDurationMs());
+
+        // Network Details
+        ClientMetadata.MoPubNetworkType moPubNetworkType = event.getNetworkType();
+        jsonObject.put("network_type", moPubNetworkType == null ? null : moPubNetworkType.getId());
+        jsonObject.put("network_operator_code", event.getNetworkOperatorCode());
+        jsonObject.put("network_operator_name", event.getNetworkOperatorName());
+        jsonObject.put("network_iso_country_code", event.getNetworkIsoCountryCode());
+        jsonObject.put("network_sim_code", event.getNetworkSimCode());
+        jsonObject.put("network_sim_operator_name", event.getNetworkSimOperatorName());
+        jsonObject.put("network_sim_iso_country_code", event.getNetworkSimIsoCountryCode());
+
+        // Request Details
+        jsonObject.put("req_id", event.getRequestId());
+        jsonObject.put("req_status_code", event.getRequestStatusCode());
+        jsonObject.put("req_uri", event.getRequestUri());
+        jsonObject.put("req_retries", event.getRequestRetries());
+
+        // Timestamp Details
+        jsonObject.put("timestamp_client", event.getTimestampUtcMs());
+
+        if (event instanceof ErrorEvent) {
+            ErrorEvent errorEvent = (ErrorEvent) event;
+            // Error Details
+            jsonObject.put("error_exception_class_name", errorEvent.getErrorExceptionClassName());
+            jsonObject.put("error_message", errorEvent.getErrorMessage());
+            jsonObject.put("error_stack_trace", errorEvent.getErrorStackTrace());
+            jsonObject.put("error_file_name", errorEvent.getErrorFileName());
+            jsonObject.put("error_class_name", errorEvent.getErrorClassName());
+            jsonObject.put("error_method_name", errorEvent.getErrorMethodName());
+            jsonObject.put("error_line_number", errorEvent.getErrorLineNumber());
+        }
+
+        return jsonObject;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java
new file mode 100644
index 00000000..f983de70
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java
@@ -0,0 +1,11 @@
+package com.mopub.common.event;
+
+import com.mopub.common.logging.MoPubLog;
+
+class LogCatEventRecorder implements EventRecorder {
+    @Override
+    public void record(final BaseEvent baseEvent) {
+        MoPubLog.d(baseEvent.toString());
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
index a36c4f9f..3e76abff 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
@@ -1,36 +1,24 @@
 package com.mopub.common.event;
 
-import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.Message;
 
-import com.mopub.common.ClientMetadata;
 import com.mopub.common.VisibleForTesting;
 
 import java.util.ArrayList;
 
 /**
- * Records both untimed and timed events. This class maintains a queue of events to be recorded and
- * launches a background thread to handler their recording.
+ * Public interface used to record client events.
  */
 public class MoPubEvents {
 
     private static volatile EventDispatcher sEventDispatcher;
 
-    private static EventDispatcher getDispatcher() {
-        EventDispatcher result = sEventDispatcher;
-        if (result == null) {
-            synchronized (MoPubEvents.class) {
-                result = sEventDispatcher;
-                if (result == null) {
-                    ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
-                    recorders.add(new NoopEventRecorder());
-                    HandlerThread handlerThread = new HandlerThread("mopub_event_queue");
-                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread);
-                }
-            }
-        }
-        return result;
+    /**
+     * Log a BaseEvent. MoPub uses logged events to analyze and improve performance.
+     * This method should not be called by app developers.
+     */
+    public static void log(BaseEvent baseEvent) {
+        MoPubEvents.getDispatcher().dispatch(baseEvent);
     }
 
     @VisibleForTesting
@@ -39,87 +27,29 @@ public static void setEventDispatcher(EventDispatcher dispatcher) {
     }
 
     /**
-     * Log a ClientEvent. MoPub uses logged events to analyze and improve performance.
-     * This method should not be called by app developers.
+     * Returns a singleton event dispatcher constructed with a single background thread meant to be
+     * used for all event logging operations. Operations that end up on the main thread, such as
+     * the result of a network request, should post to this background thread when interacting
+     * with shared resources in order to avoid concurrency issues.
+     *
+     * This design is meant to emulate an {@code IntentService} which we can't use due to
+     * the requirement of the publisher having to update their manifest file.
      */
-    public static void event(Event.Type eventType, String requestUrl) {
-        final EventDispatcher dispatcher = MoPubEvents.getDispatcher();
-        final Event event = new Event(eventType, requestUrl, ClientMetadata.getInstance());
-        dispatcher.sendEventToHandlerThread(event);
-    }
-
-
-    /**
-     * Create and start a TimedEvent. A TimedEvent isn't recored until
-     * {@link com.mopub.common.event.TimedEvent#stop(int)} is called.
-     */
-    public static TimedEvent timedEvent(Event.Type eventType, String requestUrl) {
-        final EventDispatcher events = getDispatcher();
-        final TimedEvent event =
-                new TimedEvent(eventType, requestUrl, ClientMetadata.getInstance(), events);
-        return event;
-    }
-
-    private static class NoopEventRecorder implements EventRecorder {
-
-        @Override
-        public void recordEvent(final Event event) {
-
-        }
-
-        @Override
-        public void recordTimedEvent(final TimedEvent event) {
-
-        }
-    }
-
     @VisibleForTesting
-    public static class EventDispatcher implements TimedEvent.Listener {
-        private final Iterable<EventRecorder> mEventRecorders;
-        private final HandlerThread mHandlerThread;
-        private final Handler mMessageHandler;
-
-        @VisibleForTesting Handler.Callback mHandlerCallback;
-
-        @VisibleForTesting
-        EventDispatcher(Iterable<EventRecorder> recorders, HandlerThread handlerThread) {
-            mEventRecorders = recorders;
-            mHandlerCallback = new Handler.Callback() {
-                @Override
-                public boolean handleMessage(final Message msg) {
-                    if (msg.obj instanceof TimedEvent) {
-                        final TimedEvent event = (TimedEvent) msg.obj;
-                        for (final EventRecorder recorder : mEventRecorders) {
-                            recorder.recordTimedEvent(event);
-                        }
-
-                    } else if (msg.obj instanceof Event) {
-                        final Event event = (Event) msg.obj;
-                        for (final EventRecorder recorder : mEventRecorders) {
-                            recorder.recordEvent(event);
-                        }
-                    }
-                    return true; // Even if it's not an event, swallow the message.
+    static EventDispatcher getDispatcher() {
+        EventDispatcher result = sEventDispatcher;
+        if (result == null) {
+            synchronized (MoPubEvents.class) {
+                result = sEventDispatcher;
+                if (result == null) {
+                    ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
+                    HandlerThread handlerThread = new HandlerThread("mopub_event_logging");
+                    handlerThread.start();
+                    recorders.add(new ScribeEventRecorder(handlerThread.getLooper()));
+                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread.getLooper());
                 }
-            };
-            mHandlerThread = handlerThread;
-            mHandlerThread.start();
-            mMessageHandler = new Handler(mHandlerThread.getLooper(), mHandlerCallback);
-        }
-
-        private void sendEventToHandlerThread(BaseEvent event) {
-            final Message message = Message.obtain(mMessageHandler, 0, event);
-            message.sendToTarget();
-        }
-
-        @Override
-        public void onStopped(final TimedEvent event) {
-            this.sendEventToHandlerThread(event);
-        }
-
-        @Override
-        public void onCancelled(final TimedEvent event) {
-            // Nothing to do for now.
+            }
         }
+        return result;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java
new file mode 100644
index 00000000..5459ffbe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java
@@ -0,0 +1,8 @@
+package com.mopub.common.event;
+
+class NoopEventRecorder implements EventRecorder {
+    @Override
+    public void record(final BaseEvent baseEvent) {
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
new file mode 100644
index 00000000..96a63ae9
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+/**
+ * The ScribeEventRecorder manages events being sent to the Scribe service. It is responsible for
+ * sampling, batching and kicking off network requests. It is also responsible for ensuring batched
+ * events don't grow unbounded.
+ */
+public class ScribeEventRecorder implements EventRecorder {
+    private static final String SCRIBE_URL = "https://analytics.mopub.com/i/jot/exchange_client_event";
+    private static final int QUEUE_MAX_SIZE = 500;
+
+    /**
+     * As of SDK 3.6.0, events are roughly 1200 bytes in size. 1200 * 100 = 0.114441 MiB
+     * This threshhold must always be < 1 MiB
+     */
+    private static final int EVENT_COUNT_SEND_THRESHHOLD = 100;
+
+    /**
+     * 2 minute polling time to check for send up events
+     */
+    private static final int POLLING_PERIOD_MS = 2 * 60 * 1000;
+
+    @NonNull private final EventSampler mEventSampler;
+    @NonNull private final Queue<BaseEvent> mEventQueue;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequestManager mScribeRequestManager;
+
+    @NonNull private final Handler mPollHandler;
+    @NonNull private final PollingRunnable mPollingRunnable;
+
+    ScribeEventRecorder(@NonNull Looper looper) {
+        this(new EventSampler(),
+                new LinkedList<BaseEvent>(),
+                new EventSerializer(),
+                new ScribeRequestManager(looper),
+                new Handler(looper));
+    }
+
+    @VisibleForTesting
+    ScribeEventRecorder(@NonNull EventSampler eventSampler,
+            @NonNull Queue<BaseEvent> eventQueue,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull ScribeRequestManager scribeRequestManager,
+            @NonNull Handler handler) {
+        mEventSampler = eventSampler;
+        mEventQueue = eventQueue;
+        mEventSerializer = eventSerializer;
+        mScribeRequestManager = scribeRequestManager;
+        mPollHandler = handler;
+        mPollingRunnable = new PollingRunnable();
+    }
+
+    @Override
+    public void record(@NonNull BaseEvent baseEvent) {
+        if (!mEventSampler.sample(baseEvent)) {
+            return;
+        }
+
+        if (mEventQueue.size() >= QUEUE_MAX_SIZE) {
+            MoPubLog.d("EventQueue is at max capacity. " +
+                    "Event \"" + baseEvent.getName() + "\" is being dropped.");
+            return;
+        }
+
+        mEventQueue.add(baseEvent);
+        if (mEventQueue.size() >= EVENT_COUNT_SEND_THRESHHOLD) {
+            sendEvents();
+        }
+
+        scheduleNextPoll();
+    }
+
+    @VisibleForTesting
+    void sendEvents() {
+        if (mScribeRequestManager.isAtCapacity()) {
+            return;
+        }
+
+        final List<BaseEvent> events = dequeueEvents();
+        if (events.isEmpty()) {
+            return;
+        }
+
+        mScribeRequestManager.makeRequest(
+                new ScribeRequest.ScribeRequestFactory() {
+                    @Override
+                    public ScribeRequest createRequest(ScribeRequest.Listener listener) {
+                        return new ScribeRequest(SCRIBE_URL, events, mEventSerializer, listener);
+                    }
+                },
+                new ScribeBackoffPolicy()
+        );
+    }
+
+    @VisibleForTesting
+    @NonNull
+    List<BaseEvent> dequeueEvents() {
+        ArrayList<BaseEvent> baseEvents = new ArrayList<BaseEvent>();
+
+        // Note: Some queues do not have constant time O(1) performance for its #size()
+        // method, so we're peeking and polling instead
+        while (mEventQueue.peek() != null && baseEvents.size() < EVENT_COUNT_SEND_THRESHHOLD) {
+            baseEvents.add(mEventQueue.poll());
+        }
+        return baseEvents;
+    }
+
+    @VisibleForTesting
+    void scheduleNextPoll() {
+        // Only schedule if there are no messages already scheduled.
+        // The user defined message code, the 'what' param in Handler#hasMessages, defaults to
+        // 0 for posting a delayed runnable
+        if (mPollHandler.hasMessages(0) || mEventQueue.isEmpty()) {
+            return;
+        }
+
+        mPollHandler.postDelayed(mPollingRunnable, POLLING_PERIOD_MS);
+    }
+
+    class PollingRunnable implements Runnable {
+        @Override
+        public void run() {
+            sendEvents();
+            scheduleNextPoll();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/TimedEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/TimedEvent.java
deleted file mode 100644
index c2aa7dc9..00000000
--- a/mopub-sdk/src/main/java/com/mopub/common/event/TimedEvent.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.common.event;
-
-import com.mopub.common.ClientMetadata;
-
-import java.util.concurrent.TimeUnit;
-
-/**
- * Immutable data class with client event data, including a duration.
- */
-public class TimedEvent extends BaseEvent {
-    interface Listener {
-        public void onStopped(TimedEvent event);
-
-        public void onCancelled(TimedEvent event);
-    }
-
-    /**
-     * Use this status code when stopping an event where an HTTP Status Code isn't relevant.
-     */
-    public static final int SC_NOT_RELEVANT = 0;
-
-    /**
-     * Use this status code when the timed event has no response.
-     */
-    public static final int SC_NO_RESPONSE = -1;
-
-    private final long mStartTimeNanos;
-    private enum State {
-        WAITING, STOPPED, CANCELLED
-    }
-    private State mState;
-    private final Listener mListener;
-
-
-    private long mDurationMillis;
-    private int mHttpStatusCode;
-
-    TimedEvent(final Type eventType, final String requestUrl,
-            final ClientMetadata clientMetadata, Listener listener) {
-        super(eventType, requestUrl, clientMetadata);
-        // System.nanoTime isn't affected by changing the system time, so we use it here.
-        mState = State.WAITING;
-        mStartTimeNanos = System.nanoTime();
-        mListener = listener;
-    }
-
-    public synchronized void stop(int httpStatusCode) {
-        if (mState == State.WAITING) {
-            mState = State.STOPPED;
-            mHttpStatusCode = httpStatusCode;
-            long stopTimeNanos = System.nanoTime();
-            mDurationMillis = TimeUnit.MILLISECONDS.convert(stopTimeNanos - mStartTimeNanos,
-                    TimeUnit.NANOSECONDS);
-            if (mListener != null) {
-                mListener.onStopped(this);
-            }
-        }
-    }
-
-    public synchronized void cancel() {
-        if (mState == State.WAITING) {
-            mState = State.CANCELLED;
-            if (mListener != null) {
-                mListener.onCancelled(this);
-            }
-        }
-    }
-
-    public final synchronized long getDurationMillis() {
-        return mDurationMillis;
-    }
-
-    public final synchronized int getHttpStatusCode() {
-        return mHttpStatusCode;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java b/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
index 70ac4e7b..fa140548 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
@@ -1,12 +1,12 @@
 package com.mopub.common.logging;
 
+import android.annotation.SuppressLint;
+import android.support.annotation.NonNull;
 import android.util.Log;
-import android.util.SparseArray;
 
-import java.util.ArrayList;
-import java.util.EnumMap;
+import com.mopub.common.VisibleForTesting;
+
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.logging.Handler;
 import java.util.logging.Level;
@@ -15,14 +15,23 @@
 import java.util.logging.Logger;
 
 public class MoPubLog {
+    public static final String LOGGER_NAMESPACE = "com.mopub";
+
     private static final String LOGTAG = "MoPub";
-    private static final Logger LOGGER = Logger.getLogger("com.mopub");
+    private static final Logger LOGGER = Logger.getLogger(LOGGER_NAMESPACE);
     private static final MoPubLogHandler LOG_HANDLER = new MoPubLogHandler();
 
+    /**
+     * Sets up the {@link Logger}, {@link Handler}, and prevents any parent Handlers from being
+     * notified to avoid duplicated log messages.
+     */
     static {
+        LOGGER.setUseParentHandlers(false);
+        LOGGER.setLevel(Level.ALL);
+        LOG_HANDLER.setLevel(Level.FINE);
+
         LogManager.getLogManager().addLogger(LOGGER);
-        LOGGER.addHandler(LOG_HANDLER);
-        LOGGER.setLevel(Level.FINE);
+        addHandler(LOGGER, LOG_HANDLER);
     }
 
     private MoPubLog() {}
@@ -75,6 +84,25 @@ public static void e(final String message, final Throwable throwable) {
         LOGGER.log(Level.SEVERE, message, throwable);
     }
 
+    @VisibleForTesting
+    public static void setSdkHandlerLevel(@NonNull final Level level) {
+        LOG_HANDLER.setLevel(level);
+    }
+
+    /**
+     * Adds a {@link Handler} to a {@link Logger} if they are not already associated.
+     */
+    private static void addHandler(@NonNull final Logger logger,
+            @NonNull final Handler handler) {
+        final Handler[] currentHandlers = logger.getHandlers();
+        for (final Handler currentHandler : currentHandlers) {
+            if (currentHandler.equals(handler)) {
+                return;
+            }
+        }
+        logger.addHandler(handler);
+    }
+
     private static final class MoPubLogHandler extends Handler {
         private static final Map<Level, Integer> LEVEL_TO_LOG = new HashMap<Level, Integer>(7);
 
@@ -99,6 +127,7 @@ public static void e(final String message, final Throwable throwable) {
         }
 
         @Override
+        @SuppressLint("LogTagMismatch")
         public void publish(final LogRecord logRecord) {
             if (isLoggable(logRecord)) {
                 final int priority;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
index 01e6edb3..27f49bc5 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
@@ -2,6 +2,7 @@
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Locale;
 import java.util.TimeZone;
 
 public class DateAndTime {
@@ -23,7 +24,7 @@ public static Date now() {
     public static String getTimeZoneOffsetString() {
         // A new instance is created with each call because DateFormat objects have
         // internal state and are not thread safe.
-        SimpleDateFormat format = new SimpleDateFormat("Z");
+        SimpleDateFormat format = new SimpleDateFormat("Z", Locale.US);
         format.setTimeZone(localTimeZone());
         return format.format(now());
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
index 3ac25c61..47406b98 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
@@ -1,14 +1,28 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
+import android.app.Activity;
 import android.app.ActivityManager;
 import android.content.Context;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.os.Build;
 import android.os.StatFs;
 import android.provider.Settings;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
 
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
 
 import org.apache.http.conn.util.InetAddressUtils;
@@ -17,11 +31,11 @@
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
+import java.util.Locale;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
 import static com.mopub.common.util.Reflection.MethodBuilder;
-
 import static com.mopub.common.util.VersionCode.HONEYCOMB;
 import static com.mopub.common.util.VersionCode.currentApiLevel;
 import static java.util.Collections.list;
@@ -33,6 +47,30 @@
 
     private DeviceUtils() {}
 
+    public static enum ForceOrientation {
+        FORCE_PORTRAIT("portrait"),
+        FORCE_LANDSCAPE("landscape"),
+        DEVICE_ORIENTATION("device"),
+        UNDEFINED("");
+
+        @NonNull private final String mKey;
+
+        private ForceOrientation(@NonNull final String key) {
+            mKey = key;
+        }
+
+        @NonNull
+        public static ForceOrientation getForceOrientation(@Nullable String key) {
+            for (final ForceOrientation orientation : ForceOrientation.values()) {
+                if (orientation.mKey.equalsIgnoreCase(key)) {
+                    return orientation;
+                }
+            }
+
+            return UNDEFINED;
+        }
+    }
+
     public static enum IP {
         IPv4,
         IPv6;
@@ -64,7 +102,7 @@ public static String getIpAddress(IP ip) throws SocketException {
         for (final NetworkInterface networkInterface : list(NetworkInterface.getNetworkInterfaces())) {
             for (final InetAddress address : list(networkInterface.getInetAddresses())) {
                 if (!address.isLoopbackAddress()) {
-                    String hostAddress = address.getHostAddress().toUpperCase();
+                    String hostAddress = address.getHostAddress().toUpperCase(Locale.US);
                     if (ip.matches(hostAddress)) {
                         return ip.toString(hostAddress);
                     }
@@ -84,11 +122,7 @@ public static String getHashedUdid(final Context context) {
         return Utils.sha1(udid);
     }
 
-    public static String getUserAgent() {
-        return System.getProperty("http.agent");
-    }
-
-    public static boolean isNetworkAvailable(final Context context) {
+    public static boolean isNetworkAvailable(@Nullable final Context context) {
         if (context == null) {
             return false;
         }
@@ -138,9 +172,8 @@ public static int memoryCacheSizeBytes(final Context context) {
         return (int) result;
     }
 
-    public static long diskCacheSizeBytes(File dir) {
-        long size = MIN_DISK_CACHE_SIZE;
-
+    public static long diskCacheSizeBytes(File dir, long minSize) {
+        long size = minSize;
         try {
             StatFs statFs = new StatFs(dir.getAbsolutePath());
             long availableBytes = ((long) statFs.getBlockCount()) * statFs.getBlockSize();
@@ -152,4 +185,126 @@ public static long diskCacheSizeBytes(File dir) {
         // Bound inside min/max size for disk cache.
         return Math.max(Math.min(size, MAX_DISK_CACHE_SIZE), MIN_DISK_CACHE_SIZE);
     }
+
+    public static long diskCacheSizeBytes(File dir) {
+        return diskCacheSizeBytes(dir, MIN_DISK_CACHE_SIZE);
+    }
+
+    public static int getScreenOrientation(@NonNull final Activity activity) {
+        final int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        return getScreenOrientationFromRotationAndOrientation(rotation, deviceOrientation);
+    }
+
+    static int getScreenOrientationFromRotationAndOrientation(int rotation, int orientation) {
+        if (Configuration.ORIENTATION_PORTRAIT == orientation) {
+            switch (rotation) {
+                case Surface.ROTATION_90:
+                case Surface.ROTATION_180:
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_270:
+                default:
+                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (Configuration.ORIENTATION_LANDSCAPE == orientation) {
+            switch (rotation) {
+                case Surface.ROTATION_180:
+                case Surface.ROTATION_270:
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
+                default:
+                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            MoPubLog.d("Unknown screen orientation. Defaulting to portrait.");
+            return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+        }
+    }
+
+    /**
+     * Lock this activity in the requested orientation, rotating the display if necessary.
+     *
+     * @param creativeOrientation the orientation of the screen needed by the ad creative.
+     */
+    public static void lockOrientation(@NonNull Activity activity, @NonNull CreativeOrientation creativeOrientation) {
+        if (!Preconditions.NoThrow.checkNotNull(creativeOrientation) || !Preconditions.NoThrow.checkNotNull(activity)) {
+            return;
+        }
+
+        Display display = ((WindowManager) activity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        final int currentRotation = display.getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        final int currentOrientation = getScreenOrientationFromRotationAndOrientation(currentRotation, deviceOrientation);
+        int requestedOrientation;
+
+        // Choose a requested orientation that will result in the smallest change from the existing orientation.
+        if (CreativeOrientation.PORTRAIT == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (CreativeOrientation.LANDSCAPE == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            // Don't lock screen orientation if the creative doesn't care.
+            return;
+        }
+
+        activity.setRequestedOrientation(requestedOrientation);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons.
+     *
+     * @param context Needs a context (application is fine) to determine width/height.
+     * @return Width and height of the device
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    public static Point getDeviceDimensions(@NonNull final Context context) {
+        Integer bestWidthPixels = null;
+        Integer bestHeightPixels = null;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final WindowManager windowManager = (WindowManager) context.getSystemService(
+                    Context.WINDOW_SERVICE);
+            final Display display = windowManager.getDefaultDisplay();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+                final Point screenSize = new Point();
+                display.getRealSize(screenSize);
+                bestWidthPixels = screenSize.x;
+                bestHeightPixels = screenSize.y;
+            } else {
+                try {
+                    bestWidthPixels = (Integer) new MethodBuilder(display,
+                            "getRawWidth").execute();
+                    bestHeightPixels = (Integer) new MethodBuilder(display,
+                            "getRawHeight").execute();
+                } catch (Exception e) {
+                    // Best effort. If this fails, just get the height and width normally,
+                    // which may not capture the pixels used in the notification bar.
+                    MoPubLog.v("Display#getRawWidth/Height failed.", e);
+                }
+            }
+        }
+
+        if (bestWidthPixels == null || bestHeightPixels == null) {
+            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+            bestWidthPixels = displayMetrics.widthPixels;
+            bestHeightPixels = displayMetrics.heightPixels;
+        }
+
+        return new Point(bestWidthPixels, bestHeightPixels);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
index 71e2f464..bde599fa 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
@@ -1,9 +1,12 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.util.DisplayMetrics;
 import android.util.TypedValue;
 
+import com.mopub.common.Preconditions;
+
 public class Dips {
     public static float pixelsToFloatDips(final float pixels, final Context context) {
         return pixels / getDensity(context);
@@ -33,4 +36,16 @@ public static float asFloatPixels(float dips, Context context) {
     public static int asIntPixels(float dips, Context context) {
         return (int) (asFloatPixels(dips, context) + 0.5f);
     }
+
+    public static int screenWidthAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().widthPixels, context);
+    }
+
+    public static int screenHeightAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().heightPixels, context);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
index 63d32fa3..5e1b1a68 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
@@ -1,13 +1,13 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.util.Base64;
 import android.util.DisplayMetrics;
 
-import java.io.ByteArrayInputStream;
-
 public enum Drawables {
     BACKGROUND("iVBORw0KGgoAAAANSUhEUgAAAAEAAAAsCAIAAAArRUU2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEFJREFUeNpicPP0Zvr3/z/T/3//gDQQg+i//5j+gum/QBqIQXwg+x+YjckH6fkL0/f3NwMPHz8jKxsbAw0AQIABAGYHPKslk98oAAAAAElFTkSuQmCC"),
     DEFAULT_VIDEO_POSTER("iVBORw0KGgoAAAANSUhEUgAAAEsAAAA8CAYAAAAuaUeTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAADU1JREFUeNrUW2+kXdkVP/vkCI8QQikllFfv3cu0Q8bwmA8VwpB+CUNG52M/lTChOkKjdExN9VupGUbzqcKEahgThpG0MSFf8jSduvdliFbLMAyPMDzC27tr77vXOr+1zj5/7ptW0/vct8/ZZ/9b66z1W3/2vu769etV/Cz3ljuucs9V+RPoj+4r/GAdXd+Zz+aP042nb50b/R9cE61zouOlAdos7bvz+Xy3iQMsP1v+mh7+lBv1lWbgQ5r0tfnW/AYvxNNfHVfzDF/Tmn9Ea//dCG2qTMK0XF6t9z7bOxZCuBQrXHBp0FQGKJnjIcTR0j3VH6Pnl4ILqQ8PGss0RuWeufp4TTS8nmitDI2W9khzWPEk030pCugJ4viGTzJaJe6nt+BqeRuxc557JUTBc7uTPPGYVD4LZX7nJxU9VCe0BkOzq5AXG7UQ73MDX60G4tK1ZerkVoNyfeQ6MzrA30ozn7H6zKTEFNcyB2mVZ5FWr8s6+Cyuri2TiLos0t6LyMa2zmcx962osegy82KJIv7M1COAo9rF0q1olWeZ7tQ/9iF6G9HtkN9AMINVZlAAPSo39vb2zgTU0f/RB9c11IY+x5keppelDmllCZV29GkEf0C9IuMip1PJeu+cDCa67epNKh+gWsLKWjWuzLW22botll1qu32YqLi+SKRrMVWNA/WKnrBSMaZVaMQ6l9spIHcAfBYAGRQNEaL3UdSdX13nhUl9xhAeo1Nf+XKdy9euHRMxieeS9WnjI+Nxe8twYWrVgrx6IWjQ6HmTuAfmMmFXyNgVtFiK+jndR6QxiyyrcWwXVitWplxUHcx3aslzZ5zo4Aq3dxpLUUpYCpJmVMrVaVU108dlwmJ0j6qqy4fE2Mx9Fj8cXHXOxOIzi2fIDOuz8Bw4VudZMPNUvlhiO5kveMUUlmKeE+nDF9YZq6q64+RnDTIjvRWWpCwtUoIp7iNexoA3qybGPiUJBnzga5QEbKckvIepYpByu741iqTbuYPWpMaqFenwre3Z9g86gLuKH6+T7v6QJc6CJIN/xxBUZcNRAlg0OMknYkAOLfBKGwbsvH4BYm7DZdC4HO9lTOf/9vz3nv9uyXo+/OvDd6jPj3ne5Dqw78STCUczAQj6yPmEG5lh4q8BZlnXA8fkOoU/TuOTqLNzXTXLbZOEejNvHz6hlPJzP+BrAJzEPrXCH4iJBLBDUGpY0v0OhpVwBrEKcQ4xI3RxUYF0we9TOGdekAV3NBLWUS3zStPbKCY5cE7pc0h/bFrZE7a6TQP9g8rfU/m5xRwlFdkPUgS7ghVmCYF+IoVVt7/CU8Qwp+jaoHbnqe6cspiV025FQbJwLQ2acWQU+ius6wjY+dk+lS8Qxu0XHcy+umrEYe1zVKue/mN9Vte/Icx9n9Z7ESW1lmRXWbLiH+NwYxE/pzHKmBM6Vuzu1mxrP+IVMhxLxClVV7XzqX7mHsOvToIumOyCwUUUhOxQ3yRaLqKFHJMslOJGMMKLVTq5XC7P2H752SlUBxrswPphGJ/ZWHKsrtf0r9lfuTJYH8JXkY5EsxfrurG7u3umxCuSum+wJYzkJslK5pRNdEy3uuqBEu+IX2GFX4xjSt/hDaJ4j9UtHy1PU+9v0/f+fDZ/Ku4B4+QRxhTYsOO4NrpAd4W+m9TvQUmFmVamvUYzn9yGPFhiIt8X3hhaEvFlMH6ELz7nkhh1gZ7+ncb4M5X/JDy5KPkkM06pPz4fq0uBPr9X4xZx7Mh5OeSBZEkzzXVUv6Sb3rV5HC591nu/8ke4Lg2Uy9Q/W84ppYRFPrxOYxzLY36Tvu8vFovbi73FnNvxi+Kyb9xSW3wubTIdlh7xzZAHflWm2NozTGXrxtxF79zmslMdOoPwJiU/DzntUj37T/Q5xaneROAq2XiW6v+yt7f3Nn1PoM+HiT2ss2Vn/yA46YPpHCzRLVKuTDZ83LZGZuAfpjzkTWcHFZ9LnprTIvCx9WKmwZ/CpGNud5y+V6huQap5Qe0LFOaY8ozTPNb5LaZ8gFZsE+9rFjUOVyT08VocxWT7oEpW4wiCY6XCQhyHVYKNxkr0TxNxf1wsFx/Sd5Mli/sXxzSlWoNRv1XqytBaAc2V132qrIYicj6oWEj8L85P+6BiQsarIbXrUxur7mqhUQrcKmalv/PU9FNSy1/QdwPDlSHVs6UYd1QvYAzuN0i86YJiaB25zpMmUMxvInE0XvtDYWJsF+9lVye/RV4UMgQXi/XsSLJ0yXhghWXeOF9IQL1BdT+n55/uLffO2z0/O76yZLwe78tSaCy8zMlryBAR6xpMeeR+9+j6sjhjOs38Fq3zZcYX7mN9m6GSU9GCaZDawbWoVEyb5tmkug8Jy25S98vkm/0LfTPrd6l61+KlCnFC9ZievyrPwbekuis03yvcvhHVaoPWJ7Ot2W7JoyU12FepXogX2YFDI2Hr1W5xVB+bnvE6ZSMw4J2U2ahcoP7nKNJ4YzabvYvz9JViUTkA97Keg52dnSK99+/f/xLTQXUH+bNflVQv45R87UZmbouGAH0ZrLfP2BLaVDRbR7SWyllsr0/Q9x2SsnNJ/cAg4TyyLkgS4BzVYDpLW+y6BJjsDqCHy5OU2g7FdZIuxtyW02PZ/L3Na2FWVWLTFpees/FhJ3cG/lpp83WIWbiOhnUY07Aqm4mJO27r2rQuc30ogO0wLFtIwZNQd/Alecz5T3AM2mcqDmicD+x6hzY61H6iG9m59dpfrMUfycGyHB8yLj9vbbP6SduqUu1sKFGsg9MtxRAmlEMZ0+4javcCYdbjvvlQNTn1nMbM0sRWb0iycI1NYfPh5OLRoj9FkwGPD1BgLmtKSjm19kFJb3FDAzc2nEo4Lqn8yfZs+yOJWw3GlOZO+4PRC7ebFs5tfHLvk/4UDbRtZDfWS0rjpbquH0jkkCWen4sa1JXaPFVnoCbkquwblReQtslXWYJYpnlXardPc16lNby3tbV1aNV/VA2D6+62r1R5k8Z/ILR6QzO4MI2cHAGzjnVsYq1IJqsjrnhV9m16ck0o4lJ6GJ+cQZj7KdX/lqrfJCY9wW13y6zSHFwvAbvNYvjD9mAJhHxCD8BPw/4Opnx7D2ZgIi3ovP3aFtEcIrFp41x/k6reIJV7jDvYQ0akpI6882Npks1XgACEJcWT6JQWT81wCYOhm4CHRkrJ/6HMpWWIyre38zyk8vJse3a3JElTs6RqQ8J1T/eUXpDigcHPxp7LUlhjDobg5qX4Z667E2RTNDZtklXiEBea5/mCyqvz7fk1yZIOMcCkaPrSNuLmFM5jqTMXhf1FLOtSRqB0MFVF+eDk2eC1VNoAO1vDG+AQx42PX1L5HZKmawm/BgLkvrFtEK/6Z2lRB14KtNrUs6hwUsPQtQLpTXivrVENTpprdzx4wD6L2FcSU35FseYuzXWa+t0if+kLDEWm7vJM3RlKbgOcJbPWT6TQ1y3dueTgv8HzU3hOQOWtKghyK50Dwg1ZaxEH8YuYTQz7WB0uWwOHpljATlRQeXVeFhOQ6gV518HuhFnKsqyIvkcdLstpmKD8q7eo7cuwmOO9GDGGX8wcCHWmYtPYHKW+GZOPIxNyu2hpX7XMzdJ0ha5f4TU2jPawL/hkPpvvlrbEKcLfj28opT1WXu3OYrk4QYD81ZRNzt4zXYVnQ/2mqJ8NrLNFO5vW7tq9wEN3eHD2+2eLKZo7f7rzpRxpitv3Ys1y8kuCVPvmg06eZY/7W/Ts9vLR8lrvAdxqpG78GPJwH3jeORerpXIez1rZA7pCV28s3fKgsXl1tnAskpi8w+QZ4NaL9O/F9AIxmvdwzsBV3cO7Tnv+qs51z4UpR7L0jNNKXjm1K3qcPr/K42BcOXQcXFwH9D1wUX1bTHiQHh05dVwJD4zhQTKXNwzg6CXzSakl7gQH/aMGdZDftfuO8jJc68Gzm6PW6yrlbA6dz+IxGVrqEoZgQ9n+7juoahy4zo8M7Enj0o+nqv7DsKW9PjVHjyPZSQTiwWJzyHgs+cdjNwUrcpKA/ExP/1N9m6jrWrCxs1FT+/TVr2E5N27fuX2mNL+cosn9m8LCXqLyAQ5euh5bOLoDU5lQ6juFESX3ZI15Nql5h97SeHXnp3MD2+FjC+/dOp+49b7u3EP4elQpLI0n9V+XiKEF28VNHWfofojYsXUM9elrp2HliEQU/ZGBhQ5JcKkdjjs03zpt+9ZYmrdEQzM22AjAfk73bw6pSAnv+phaesvrrGeK4aDP29ZQDWkDrruZYnkGwHefQqP3rHM4eBp5/FTxeqeep/ar5FciP6O1n5oaX6pyDK+GxNMGxcWfyYWBn8/1tasm9Avr9Sv9/G8MpzuuxNhhsEEmVVVfHHZUtf6PtCuVuPYhfB02CFV1QA8Pj2K66f7g67gGY6cFj+pKlOaHnfSDMS3qWcPTenu2Hbeabq51ZKgd/EaK3CcQ99+SpKnuC/zq9g99gD5C+wdNnuc1+t6iyp2J+hyl8WNi9C11VmsN12KsfiyZdxTLGO/JIF0lkI/p7LMxeWmZ1LOWu3R/498CDACoBOJw5WW+ZwAAAABJRU5ErkJggg=="),
@@ -19,32 +19,40 @@
     REFRESH("iVBORw0KGgoAAAANSUhEUgAAABMAAAAUCAYAAABvVQZ0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2NJREFUeNqMVF1Ik1EYPm7TpsIca84pGs6VrboYaeRPpFgXKUzBH4S8sLoIMVCpRERCAgfSZXpR2ZVJCEIgaIQm+MdCIkXRTTTnQG0qorCFm21zp+f9+IQ5NHvh4eP7vnOe877Ped5Xyv4dEYAMSK2rq/tkt9tlXq83Cu9BwC8+zyQ4B5wHLgAG4M7IyAgfHR31FhcXv8F7EXAZUADSo43SMCLKQimS0GKDTqfLys7OvlldXZ2Vnp4uy8nJuZGWlmacnp52ejyeANZ4AB/AQ4kigSQgT6/XPzebzd8pk4WFBb6+vs6xkVP4/X6+s7PDx8bGPJWVlWasTxGTOJZRInC3oaHh88zMjLDh4OCA+3w+4RkIBPhRHB4e8u3tbd7f38+rqqpM2CcJ1YhKu4Vsvq2urnKIzN1uN3c4HHxqaso1Pj7+Y3d3VyAicqfTyaHhenNzc1Eo0VF5F2traz+srKwIRFtbW3xoaMjW1tZ2X9Q12WazcZfLxefn53lXV9fbiooKjZjIsVAkJSXdIw1IFyqvt7d3pLy8PCFksXJgYIAPDg5aGxsbs8OzCY2E+vr692tra4LIFovld15eXmrYqbKmpiZzuNAnRXJ3d7eVStjc3OQo7ZXos7OC5ImjZAA1EE0nSbRarUYulzNoxeCfb/gW+A+yGEAvuoC8ZieyoFKpVEulUgYPMVy3Qyzn8IwuiYWNXl5FQB4/9r0gIf+gxG34iEVFRbH8/HwSOPakmwovMTMz81JZWZm+oKDAkJiYGENk3o2NjSVYgsXFxbHc3NxCMXX5KYRkFRU2XzEajQZUxSQSCdvb2/tJZAfLy8uDyI4pFApmMpkKNRpNJr7rxEaWiaS0NhrQAuk1NTVPoDWDiRmS2RweHrYK9aO0FPjMvb+/z3EC7+vr+6VWqx/j321xauhEsa8DJjR9NxIQDI6xxFtbW58emx4tLS0PFhcXhT4kwomJCS/67qNKparH/4fAo4yMDHNHR8c8EdDB1J8w+NRJVors7Ox8t7S0JCwkIH1utVr57Owsn5ub49RudBAdSC2HG7SVlJRoT7ssaXt7e+3k5KSLiIiQJgRFMBgUmpzIqE97enq+lJaWhrbciYwRKE+NW32GIVgcHx9/TSaTMfAxkLsx2ywge40J8zV8bP8VYACAQuluULZPjQAAAABJRU5ErkJggg=="),
     CLOSE("iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAg9JREFUeNp8kk1rWkEUhodc5aJUEbVqJQRcqCUgERottIKYQhdZSEh1pcWFSFd2HdzFhfobpOJCFLEbddONEUUQEUSDxi4KtWIq+LGQanOLFqdnJAO3peTAe+98PXPmvDMMQkgE0ikUilcajca2WCx+Q58DbUAYJARpQccmk+l8Op1CE/0inycqlcqdTCZvi8XincViCcHYEUgKYkH7oNfhcLhRKpWw1+v9AH0zMhgMh6lU6utkMsGQDddqNQo/Az0lUCQSaQyHQ7xcLnGn08GBQOCSsdlsKtB7nU7HSqVSJJfLhWaz+UWv15uPx2M2Go1eeDye51qtFgkEAgQwgvEv5Kh7wWDwZb1e/wGBt9stJv9Wq8Wl0+mb0WiEN5vNTiRrIpHI3deN/guv12vMcdyDEA3W5XKdtdvtnwTix3w+x/F4/BOsUZAkfEhI3ctms9ckEz+gJmy32/lu7/0FgRENWhM/VqsV320Ko8egE2o5rYkcj2QiEDWMwFar9QLWHxLwIBaLlfkQaWcymVwoFLL/63alUrlzOBxvGTDkyOl0Xur1+t09QRYEL+Sjz+fzQIZvYrG4qlar3TKZjBWJRLvSYPNHTL/fvzUajTOlUnlKLrdareb8fr+XvtVms/mdwDDvhqxst9v9nM/nzxgyWS6XW7DreDAYDOE+391DNHawRCK5ms1mmkKh8AY0/SPAAEsFgVbY4GziAAAAAElFTkSuQmCC"),
 
-    INTERSTITIAL_CLOSE_BUTTON_NORMAL("iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAKfGlDQ1BJQ0MgUHJvZmlsZQAAeAHVlndUU8kex+fe9AaBQOgQeu8dpNdQBKmCqIQkhBpCqGJDRFzBtSAiAuqKrogouBbaWhBRLCwCCnY3yCKgrIsFUVF5N/BgPee9/e/98+ac+c3n/uY3v5k75ZwvAOROlkCQAlMBSOVnCkN83BnLo6IZuMeAAFQBFcgDOoudIXALDg4A/1g+DAJI3HnXWJzrH8P+e4cUh5vBBgAKRrrjOBnsVITPIfyNLRBmAgCLuTcnU4AwqhBhGSGyQIQrxMyb55Nijpvn9rmYsBAPJOYeAHgyiyXkAUASIX5GNpuH5CEjCMz4nEQ+wmYIO7MTWByEBQgbpaamibkaYb247/LwvmMWK24xJ4vFW+T5f0FGIhN7JmYIUlhr5j7+lyY1JQvZr7kijVgyP2VpANLSkTrGYXn6L7AgZe7M5vxcfnjogp8ftzRogeOF3iELLMh0/46Dwxb8eQkeSxeYm+G1mCeJ5Sc+s7n8wqyQ8AXOyA71WuC8hLDIBeZwPRf98YnezAV/YiZzca7kNP/FNYAwkACyAB9wABcIQRxIAykAOb1Mbi5iAfBIE6wRJvISMhluyK3jGjGYfLaJEcPCzNxc3P1/U8TvbX6x7+hz7wii3/rbl94OgH0x8ibEV/3fcSxNAFpfAED78LdP8y1yFXYBcLGXnSXMns+HFjcYQASSQAYoIO9ZE+gBY2ABbIAjcAVewA8EIbscBVYBNrLXqcgu54B1YBMoAiVgF9gLKsEhcAQcB6fAGdAMLoAr4Dq4DXrBAHgMRGAEvAKT4AOYgSAIB1EgGqQAqUHakCFkAdlBzpAXFACFQFFQLMSD+FAWtA7aDJVApVAldBiqg36BWqEr0E2oD3oIDUHj0FvoM4yCybAMrALrwKawHewG+8Nh8EqYB6fDeXAhvAOugGvgk3ATfAW+DQ/AIvgVPIUCKBKKjlJHGaPsUB6oIFQ0Kh4lRG1AFaPKUTWoBlQbqgt1FyVCTaA+obFoGpqBNkY7on3R4Wg2Oh29Ab0dXYk+jm5Cd6LvoofQk+hvGApGGWOIccAwMcsxPEwOpghTjjmGOY+5hhnAjGA+YLFYOlYXa4v1xUZhk7BrsduxB7CN2HZsH3YYO4XD4RRwhjgnXBCOhcvEFeH2407iLuP6cSO4j3gSXg1vgffGR+P5+AJ8Of4E/hK+Hz+KnyFQCdoEB0IQgUNYQ9hJOEpoI9whjBBmiFJEXaITMYyYRNxErCA2EK8RnxDfkUgkDZI9aRkpkZRPqiCdJt0gDZE+kaXJBmQPcgw5i7yDXEtuJz8kv6NQKDoUV0o0JZOyg1JHuUp5RvkoQZMwkWBKcCQ2SlRJNEn0S7yWJEhqS7pJrpLMkyyXPCt5R3KCSqDqUD2oLOoGahW1lXqfOiVFkzKXCpJKldoudULqptSYNE5aR9pLmiNdKH1E+qr0MA1F06R50Ni0zbSjtGu0ERmsjK4MUyZJpkTmlEyPzKSstKyVbIRsrmyV7EVZER1F16Ez6Sn0nfQz9EH6ZzkVOTc5rtw2uQa5frlpeSV5V3mufLF8o/yA/GcFhoKXQrLCboVmhaeKaEUDxWWKOYoHFa8pTijJKDkqsZWKlc4oPVKGlQ2UQ5TXKh9R7laeUlFV8VERqOxXuaoyoUpXdVVNUi1TvaQ6rkZTc1ZLVCtTu6z2kiHLcGOkMCoYnYxJdWV1X/Us9cPqPeozGroa4RoFGo0aTzWJmnaa8Zplmh2ak1pqWoFa67TqtR5pE7TttBO092l3aU/r6OpE6mzVadYZ05XXZerm6dbrPtGj6LnopevV6N3Tx+rb6SfrH9DvNYANrA0SDKoM7hjChjaGiYYHDPuMMEb2RnyjGqP7xmRjN+Ns43rjIRO6SYBJgUmzyWtTLdNo092mXabfzKzNUsyOmj02lzb3My8wbzN/a2FgwbaosrhnSbH0ttxo2WL5xsrQimt10OqBNc060HqrdYf1VxtbG6FNg824rZZtrG217X07Gbtgu+12N+wx9u72G+0v2H9ysHHIdDjj8JejsWOy4wnHsSW6S7hLji4ZdtJwYjkddhI5M5xjnX9yFrmou7Bcalyeu2q6clyPuY666bsluZ10e+1u5i50P+8+7eHgsd6j3RPl6eNZ7NnjJe0V7lXp9cxbw5vnXe896WPts9an3Rfj6++72/c+U4XJZtYxJ/1s/db7dfqT/UP9K/2fBxgECAPaAuFAv8A9gU+Wai/lL20OAkHMoD1BT4N1g9ODf12GXRa8rGrZixDzkHUhXaG00NWhJ0I/hLmH7Qx7HK4XnhXeESEZERNRFzEd6RlZGilabrp8/fLbUYpRiVEt0bjoiOhj0VMrvFbsXTESYx1TFDO4Undl7sqbqxRXpay6uFpyNWv12VhMbGTsidgvrCBWDWsqjhlXHTfJ9mDvY7/iuHLKOONcJ24pdzTeKb40foznxNvDG09wSShPmEj0SKxMfJPkm3QoaTo5KLk2eTYlMqUxFZ8am9rKl+Yn8zvTVNNy0/oEhoIigSjdIX1v+qTQX3gsA8pYmdGSKYMIm+4svawtWUPZztlV2R9zInLO5krl8nO71xis2bZmNM877+e16LXstR3r1NdtWje03m394Q3QhrgNHRs1NxZuHMn3yT++ibgpedNvBWYFpQXvN0dubitUKcwvHN7is6W+SKJIWHR/q+PWQz+gf0j8oWeb5bb9274Vc4pvlZiVlJd82c7efutH8x8rfpzdEb+jZ6fNzoO7sLv4uwZ3u+w+XipVmlc6vCdwT1MZo6y47P3e1XtvlluVH9pH3Je1T1QRUNGyX2v/rv1fKhMqB6rcqxqrlau3VU8f4BzoP+h6sOGQyqGSQ59/SvzpwWGfw001OjXlR7BHso+8OBpxtOtnu5/rjikeKzn2tZZfKzoecryzzrau7oTyiZ31cH1W/fjJmJO9pzxPtTQYNxxupDeWnAans06//CX2l8Ez/mc6ztqdbTinfa76PO18cRPUtKZpsjmhWdQS1dLX6tfa0ebYdv5Xk19rL6hfqLooe3HnJeKlwkuzl/MuT7UL2ieu8K4Md6zueHx1+dV7ncs6e675X7tx3fv61S63rss3nG5cuOlws/WW3a3m2za3m7qtu8//Zv3b+R6bnqY7tndaeu172/qW9F3qd+m/ctfz7vV7zHu3B5YO9A2GDz64H3Nf9IDzYOxhysM3j7IfzTzOf4J5UvyU+rT8mfKzmt/1f28U2YguDnkOdT8Pff54mD386o+MP76MFL6gvCgfVRutG7MYuzDuPd77csXLkVeCVzMTRX9K/Vn9Wu/1ub9c/+qeXD458kb4Zvbt9ncK72rfW73vmAqeevYh9cPMdPFHhY/HP9l96voc+Xl0JucL7kvFV/2vbd/8vz2ZTZ2dFbCErDktgEIsHB8PwNtaAChRiHboBYAoMa+H5yKgeQ2PsFjLz+n5/+R5zTwXbwNArSsA4fkABLQDcBCp2giTkVYsC8NcAWxpuVgRj7hkxFtazAFEFiLS5OPs7DsVAHBtAHwVzs7OHJid/XoU0e0PAWhPn9fh4mgsFYBSXVktWe6trar5c+O/M/8CArPqa05dv3oAAAAJcEhZcwAACxMAAAsTAQCanBgAAAekSURBVFgJpZhJiJRXEMff9Kgz4zaijg4q7orgQclBFL0k5KIGFI0bJIyec/CkEA+jhoSIBw+iiBCUUXDFfUHBgAaiePOgYQZBXHBfcJvM2l/n/6vuenzdduNIHrx+e9X/VdWrqq+rcrlcqFSqVLRepfXE9+zfv3/ymjVrJiRJUtvZ2TmopqambsCAAf1Y7+7u7lXp1LF/Nd919uzZJytWrPjHz6rNbN26NWzZskVkKzBmvkI1MIVz1ZcvX2569uzZHy9fvmzVXJ/K8+fPnz58+PDQhQsXfhKYeh2qxCvOx07J5oyPDxw48M39+/f/bm9vT4PI9vT09EpC2XKVNW2mWuno6Mi1trW27tmz59eFCxfW7Nixo+7YsWPVSEzSyqjl8obFOppIFzaYim7cuNE8c+bMn4cOHVqrOYj3vnjxolq3rjp37ly4e/duEDNUZeelulBXVxdmzJgRFi1aFMaPH58bPXp0VovQrO7q6gr37t1rv3Xr1g9S++mrV6/WXrt2rXvz5s3YTd52HFmhjZJ58uTJXhAUSo9AZA8ePJjMnj0bsH2qs2bNSjgjCSei06Oahd6jR4/+Wr58+Up1uWXkyTitsrjw7t27Fi1SMNJeGWcyf/78CKKxsTEZMWJEMnLkyLKVNUkm7p8zZ05y+vTpRKoEWBeEb9++/UEX+0rdgPpoqQ4o6jAlGbOR3bt3R8ITJkxIBg0alOgVxbly0mKdyt6JEyfGvTt37kxkcxFUW1vbnzpfAxBsyQBpAjAG6Pr1683qUwzM9u3bjdioUaNMEtxcdhIZlAOTnuvfv7+da2hoSKDB2rZt2xLZnaswJzv9TfwQDO6lio4h4zVJVR0am5527dplBCZNmpRAGKIQ5OYDBw78LCgZd1JdXW37OMtFXFpISuozexLP9kOHDs0TW8NiKhOjap42YFR60DfMx4wZY2CGDBliYzm5CMTn2FdaBw8eHOdWrVplffZzMZcUPOAFwwcPHlxRk8dCB6dX8DOJFrNz5841Ihx2yaxfvz7Rk08wcADIFVgtBwbVMn/ixInk9evXyYYNGz6hh6HDC0Dv37/PXblyZRVYDBUemAWVrpaWFjs8ZcoUe0kQ5pavXr3iRlZPnjxpe7g1wBwUkhk+fLiNjx49GvdLLUlTU5PNc0FXHbzgCeMChhD27ds3WeGgjcmnT59mp0+fbgdhhIgzmYyNz58/Hxloq90eIMOGDUsAxovCDTB35MiRor3SgM2zVltbG21w2rRpyTPxhLcw3JXPmoqn/ZoJlezNmzftoDxsNMi0ARf0Hpm5pPA5Y8eOtbNpyYhmcvHixQjGbYuH4X4KntpnYUYu4dsg21kIGuLPpk2b7DDEOeSqSKvm1KlTERAMGfs+ObiiNQVVW+OF1dfXx33sdzuDZyH25d68efNdkNF9DyCC5LJly+zQuHHjig5DABUCjH6ppI4fP54cPny4CIxLpl+/fqZWB+2tPxZ4whsMwrIyfPz48UcHtHjx4oqAHBQ2Q//MmTNFAEQjjh2McqKyYDjvgODpgPTamjISpyVX2hQkOpogdVlb+qMDIZvNBuk/LFmyJMiGbIvAuD8LZAFEer22IAMOb9++LSVTNFaojGPtz5AWfFFRphikBjvjaQcDQFF8ThcN7P3SkiHt9EN65tZ14j7vrV6J5TuPHz8mQofVq1fbEhKVe7C+0oogQw/yK0GhI8j2/HjZ1i/HIlgySpo6fKd07t1PWhl04NZykEFPOyiMxD2oCRBeli5daupEXVyuLKi8QEOap2Hpy7PHf/gzLXV6/rQF5hNDJ3Qwz0PgldL36vTSzx4sFR2je2iithMpdXoOBuIkbewrdQnuPFnDm9Pi4xpH5/cXHKM9e5z0p6FjWj50cJjQgR+BCLeV+GMllDCPJ8fp4aPcJZQ6Tw/I7McVuPcndBCuRJfQ0UoYKwquehXdyouMEdmhi5XgStR2QC4ZPLCDgFkl5/nhw4dk7dq1RpcMIh1c4QmgGFzVL0o/SOYXLFhgh3Fe7sA2btyYELUvXbpkawTJNBgAOSgPE0gRMM3NzRGM00ulHwmpDykQWNx/FCVoejUREFLwoOgpBIydqQNJt2kDdslAA1rlEjSSQ523RB9AZVNY0kyYIF4I+c2Yc4BpEKV9N2DmAQENVxW0+ZoR7xxpM+kz0gGL9ldO8knInaCrD6Nkri/VJNKQzzpdMtAsxC4DVPiwAExM8m1QQIiH3as+xb48XFIA4Ia8kHRqUgkYe9jrUmEftNJgCp9c8I8YfEBrqmNRQbRFLQXJ9uJbMEJnTnLFC/QPxYaRMn5VH7PmCRhn/EMRWtCEsFQFD+cfefuEt3Eh9cHI+R4ScnLgqVOnRmAOsFLLXs4Uknn7woBYiWQiTy3l/3UQwXTBsGAayv3ZoL9Y7M8G5UOhtbU18AeCLm7nCZTEJv5sID3xPxukPtKDKkm+886dO7/PmzfvFzuQ/xPCeBXG8VPaJeRtRP0//o4xD4xE8DM87dRrgk/kgWS8xo5PpFo+r6mAT/9hZV8omv9s4WsGD4zTg4YOwC/SLYyLMDjDKLF0R6K2w5qLYv3cX3qkEPLi7QrOncqzH6xbt+5eimYmTzJ/y9R87P4HkQsq2faR5dQAAAAASUVORK5CYII="),
-    INTERSTITIAL_CLOSE_BUTTON_PRESSED("iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAKfGlDQ1BJQ0MgUHJvZmlsZQAAeAHVlndUU8kex+fe9AaBQOgQeu8dpNdQBKmCqIQkhBpCqGJDRFzBtSAiAuqKrogouBbaWhBRLCwCCnY3yCKgrIsFUVF5N/BgPee9/e/98+ac+c3n/uY3v5k75ZwvAOROlkCQAlMBSOVnCkN83BnLo6IZuMeAAFQBFcgDOoudIXALDg4A/1g+DAJI3HnXWJzrH8P+e4cUh5vBBgAKRrrjOBnsVITPIfyNLRBmAgCLuTcnU4AwqhBhGSGyQIQrxMyb55Nijpvn9rmYsBAPJOYeAHgyiyXkAUASIX5GNpuH5CEjCMz4nEQ+wmYIO7MTWByEBQgbpaamibkaYb247/LwvmMWK24xJ4vFW+T5f0FGIhN7JmYIUlhr5j7+lyY1JQvZr7kijVgyP2VpANLSkTrGYXn6L7AgZe7M5vxcfnjogp8ftzRogeOF3iELLMh0/46Dwxb8eQkeSxeYm+G1mCeJ5Sc+s7n8wqyQ8AXOyA71WuC8hLDIBeZwPRf98YnezAV/YiZzca7kNP/FNYAwkACyAB9wABcIQRxIAykAOb1Mbi5iAfBIE6wRJvISMhluyK3jGjGYfLaJEcPCzNxc3P1/U8TvbX6x7+hz7wii3/rbl94OgH0x8ibEV/3fcSxNAFpfAED78LdP8y1yFXYBcLGXnSXMns+HFjcYQASSQAYoIO9ZE+gBY2ABbIAjcAVewA8EIbscBVYBNrLXqcgu54B1YBMoAiVgF9gLKsEhcAQcB6fAGdAMLoAr4Dq4DXrBAHgMRGAEvAKT4AOYgSAIB1EgGqQAqUHakCFkAdlBzpAXFACFQFFQLMSD+FAWtA7aDJVApVAldBiqg36BWqEr0E2oD3oIDUHj0FvoM4yCybAMrALrwKawHewG+8Nh8EqYB6fDeXAhvAOugGvgk3ATfAW+DQ/AIvgVPIUCKBKKjlJHGaPsUB6oIFQ0Kh4lRG1AFaPKUTWoBlQbqgt1FyVCTaA+obFoGpqBNkY7on3R4Wg2Oh29Ab0dXYk+jm5Cd6LvoofQk+hvGApGGWOIccAwMcsxPEwOpghTjjmGOY+5hhnAjGA+YLFYOlYXa4v1xUZhk7BrsduxB7CN2HZsH3YYO4XD4RRwhjgnXBCOhcvEFeH2407iLuP6cSO4j3gSXg1vgffGR+P5+AJ8Of4E/hK+Hz+KnyFQCdoEB0IQgUNYQ9hJOEpoI9whjBBmiFJEXaITMYyYRNxErCA2EK8RnxDfkUgkDZI9aRkpkZRPqiCdJt0gDZE+kaXJBmQPcgw5i7yDXEtuJz8kv6NQKDoUV0o0JZOyg1JHuUp5RvkoQZMwkWBKcCQ2SlRJNEn0S7yWJEhqS7pJrpLMkyyXPCt5R3KCSqDqUD2oLOoGahW1lXqfOiVFkzKXCpJKldoudULqptSYNE5aR9pLmiNdKH1E+qr0MA1F06R50Ni0zbSjtGu0ERmsjK4MUyZJpkTmlEyPzKSstKyVbIRsrmyV7EVZER1F16Ez6Sn0nfQz9EH6ZzkVOTc5rtw2uQa5frlpeSV5V3mufLF8o/yA/GcFhoKXQrLCboVmhaeKaEUDxWWKOYoHFa8pTijJKDkqsZWKlc4oPVKGlQ2UQ5TXKh9R7laeUlFV8VERqOxXuaoyoUpXdVVNUi1TvaQ6rkZTc1ZLVCtTu6z2kiHLcGOkMCoYnYxJdWV1X/Us9cPqPeozGroa4RoFGo0aTzWJmnaa8Zplmh2ak1pqWoFa67TqtR5pE7TttBO092l3aU/r6OpE6mzVadYZ05XXZerm6dbrPtGj6LnopevV6N3Tx+rb6SfrH9DvNYANrA0SDKoM7hjChjaGiYYHDPuMMEb2RnyjGqP7xmRjN+Ns43rjIRO6SYBJgUmzyWtTLdNo092mXabfzKzNUsyOmj02lzb3My8wbzN/a2FgwbaosrhnSbH0ttxo2WL5xsrQimt10OqBNc060HqrdYf1VxtbG6FNg824rZZtrG217X07Gbtgu+12N+wx9u72G+0v2H9ysHHIdDjj8JejsWOy4wnHsSW6S7hLji4ZdtJwYjkddhI5M5xjnX9yFrmou7Bcalyeu2q6clyPuY666bsluZ10e+1u5i50P+8+7eHgsd6j3RPl6eNZ7NnjJe0V7lXp9cxbw5vnXe896WPts9an3Rfj6++72/c+U4XJZtYxJ/1s/db7dfqT/UP9K/2fBxgECAPaAuFAv8A9gU+Wai/lL20OAkHMoD1BT4N1g9ODf12GXRa8rGrZixDzkHUhXaG00NWhJ0I/hLmH7Qx7HK4XnhXeESEZERNRFzEd6RlZGilabrp8/fLbUYpRiVEt0bjoiOhj0VMrvFbsXTESYx1TFDO4Undl7sqbqxRXpay6uFpyNWv12VhMbGTsidgvrCBWDWsqjhlXHTfJ9mDvY7/iuHLKOONcJ24pdzTeKb40foznxNvDG09wSShPmEj0SKxMfJPkm3QoaTo5KLk2eTYlMqUxFZ8am9rKl+Yn8zvTVNNy0/oEhoIigSjdIX1v+qTQX3gsA8pYmdGSKYMIm+4svawtWUPZztlV2R9zInLO5krl8nO71xis2bZmNM877+e16LXstR3r1NdtWje03m394Q3QhrgNHRs1NxZuHMn3yT++ibgpedNvBWYFpQXvN0dubitUKcwvHN7is6W+SKJIWHR/q+PWQz+gf0j8oWeb5bb9274Vc4pvlZiVlJd82c7efutH8x8rfpzdEb+jZ6fNzoO7sLv4uwZ3u+w+XipVmlc6vCdwT1MZo6y47P3e1XtvlluVH9pH3Je1T1QRUNGyX2v/rv1fKhMqB6rcqxqrlau3VU8f4BzoP+h6sOGQyqGSQ59/SvzpwWGfw001OjXlR7BHso+8OBpxtOtnu5/rjikeKzn2tZZfKzoecryzzrau7oTyiZ31cH1W/fjJmJO9pzxPtTQYNxxupDeWnAans06//CX2l8Ez/mc6ztqdbTinfa76PO18cRPUtKZpsjmhWdQS1dLX6tfa0ebYdv5Xk19rL6hfqLooe3HnJeKlwkuzl/MuT7UL2ieu8K4Md6zueHx1+dV7ncs6e675X7tx3fv61S63rss3nG5cuOlws/WW3a3m2za3m7qtu8//Zv3b+R6bnqY7tndaeu172/qW9F3qd+m/ctfz7vV7zHu3B5YO9A2GDz64H3Nf9IDzYOxhysM3j7IfzTzOf4J5UvyU+rT8mfKzmt/1f28U2YguDnkOdT8Pff54mD386o+MP76MFL6gvCgfVRutG7MYuzDuPd77csXLkVeCVzMTRX9K/Vn9Wu/1ub9c/+qeXD458kb4Zvbt9ncK72rfW73vmAqeevYh9cPMdPFHhY/HP9l96voc+Xl0JucL7kvFV/2vbd/8vz2ZTZ2dFbCErDktgEIsHB8PwNtaAChRiHboBYAoMa+H5yKgeQ2PsFjLz+n5/+R5zTwXbwNArSsA4fkABLQDcBCp2giTkVYsC8NcAWxpuVgRj7hkxFtazAFEFiLS5OPs7DsVAHBtAHwVzs7OHJid/XoU0e0PAWhPn9fh4mgsFYBSXVktWe6trar5c+O/M/8CArPqa05dv3oAAAAJcEhZcwAACxMAAAsTAQCanBgAAAkNSURBVFgJjZhbaFXZGcfX3vtEExMVL9E0NdZEvEQTH+oVGi+1oDNlsMVrKaVgH2zL0NJKUaiJxtTrQ7UwfajzUCkMXqEIRapTUh3RkMZL6ZjEeJkIE6OiTjQm5nrO2f3/1jnrGOJJMgv22Xuv9V3+3//71mUfLwxDM0Lz9u7d6+3Zsyfu5PReFI/Hv6UrS/rZvu9na8w3gekLo2Gn+ruDIGjr7OysP3LkSDd6mzdvDs6cOYONYR16wwGSY98B2blzZ/7o0aN/Imdz5Gy5nmd5nmfS6Qug6e7u7pXsvzT+n1gsduLgwYPNAJPNSGVlZUz9aYGlBSRHnpQsK9u3b8/Kycn5ULZ+mZmZWZSRkWF6e3u55C+OUQ9HrgFSVxiJRALJG4ExPT09rQriRwruqpMbGKzr454OEA4s+t27d5fK+McyvkwGARF98+ZN+OrVK//+/fv+ixcvTH9/v4lGo9am5MyoUaPMpEmTzOzZs8Px48fHs7OzjdiM9PX1GQXwWVZW1i6N123btq0/HajBgFJgFM0WefmzjE2W07hAxB8+fBjU1dWZJ0+eWAAj/UydmmeWLVtqCgsLYxMmTIhgPDsnx3R1df6xvHz379AfDCoFSExY6sltVVXVh4r6qKLNECv9Dx48CGqu1XhftnxpMQgk0aatHyugH8zBHi0/P98sX748FGtx1ZdtcqOY91Qxjm/88hyoVrjT6V+6dCkU4s3K+8eqFcBEb926FTl37pzX/rrdiG4LhBQBaKSLNKPT1tZmGhoaPD37eXl5IYik+90rV648WbVq1U18624BWYYcbbt27SqRkX+LmVwVYrS2tjaorq42FLJrgEkG47qGvMuRoa5o6KC7evVqpXFZXAUfiMEOAXtv3759NQ4DgGzdqGOUBqslWNbV1dV/48aNyIULFwxFqXdr2KVAAVp2hkSigYEyBMRsI9VaDszatWvN4sWLY1mZmZGe3t7bHR0dK44ePfpKap4vILZ2pLBN7JRpNsQ1gwLAMG0BQ6SAmTt3rsVAqkjHUI0xZGjouEBUAjawixcvmnv37gViLKZslI4bN84VuBdQN1r0xoraYwKQq6kcExhfqG2UREp0isisWbPGFBQUUA8WJGOD0+eA0r9x40azdOlSC66lpcWCITjAvnz50sycOTOuNc4X4ILz58///cCBA+0+UQjIT0XrPNEZY2q3trYaobaKjpmVK1favuLiYrNp0yY7NpgpB4YANmzYYObNm2fGjh1rVqxYYUpKSlJMUeiPHz82zc3NARNH74Vjxoz5MVgsIBleQnq098Rramps9OQaw7Smpibz6NGjFIj58+dbULDABRAuokdn/fr1BhlaqMWcAO/cuWPfGe/r7bPPV69eNSy0yUlTQmcgIzz8QYLZz549865du+aJRrs94Mylpb6+3kyZMsVMnTLVGuM5NzfXpo+ZBCDYBAxsoMfVdLfJnDhxIgUcVrHLii4CYBF/TK4JWgb+6auwpomdKSrmmJiwBY5HlGguLRjXbm0aGlU/yX5Y0C5ugVCwpAkwNNiClZMnT9p3QDvG6XD28YlvzcACYcn3NTApOeixN6VrGMLBW1CNJhBAGnVC8bo0IQNbpPnUqVNWBjCsQekaPgmapnsWVr8JIC43Pe3ooJ90oACJMVhZsGCB1aAPMAOZGQoMCkmfNjPSHeML/fgkQ0NG4bA5UBQh6bt9+7aYCmwqGIOZxsZGC4bn4ZgZaNM9y24GDCX4cr1f4w4LNECI25QGgdFHI3Uu0JTACA9i24tIqc05IKLhGlEjy9mGAqaoSZnTA4ybYTDo6smBTGcbmwNajy/hxzjhSq4HA8bfPjpF6sGBcQ5JE8uCk6HQh1o831pMPCV9hviX7a6IHr5KAgonT57s3b17d7BOyhGRutmEEHoU8OnTp60O7/MFJibW3MJ49uxZmzrApmNKPmHSY0wyXb7m/0MdNb7QQhVoI0ycSWQY4zRYQJjLrTOOGbfO4IxIE+vU2yUBUI4p9NFzzdmXz7gwsJ99rnuzX15e/oWEq9lfdAaOgZgVFGWUqBEaa42Lmn7A2HVGuJ0cOg4UOuiis2ULp+HEO7IEQB1OnDgRn5yNCLhW57EWC1kCdYDQ2SdSVlamOk8s7a5YOUIUFhba4sVpCoycRILEoieDFpgDRV3xzIVuaWmpBQWTbBs0+cKnrwwBsp4+C0isfKJo/qcd15sxY0Z8+vTp9iBFNBigTpIbIeeYIVfgwaDQ4zyl/dGuWckCtrbzv5FvioqKYspMILaadH0CIDZXf8eOHdHLly+HAvWBBDj7hpo1GkqkjDvnmdevXxudn2yRDrXowS6scGfmtbe3m+vXr6f6cEoq3//++5ytKFQK+qP9+/df5BibOsJu3bo1c9q0aZ8pn0s4o+hzJ+BkR22xcZJ3t7XwDBvDNUDhmAYzyKtoU0fYJTrCjtYRVszUy37ZoUOH2iXqkTK+NPzjx4/3SGkHYOQwsnDhwvhqHcg5F2GchmGeRwKDLGBglnrhjh62sIntSEZGRL56tfb8GjBgkFpovzqkYOc41ayBKhmpEPK4rvDmzZs+TNFgS31fCxDyMAkggNA43C9atCimwNyW8Ft9m/1JQxYC/i0gK61O3e06JFB/kdLPWZV1RVXIvg5PnvtixYl0k2rpb8QIeJr7UJw1axaH+gwYFoMV+iDdl9RO+U7kItFrU8ejUP9CbP5eWN6opiI6R/taS2Lr1q0LWTtwRD0NdyGDrHQ4xMVkw9MszpDOVwrmZw6MS1US2Lt/NiAgQLYatVB9W7TvV7TvkS6o13rVr5kTaIvxnj9/bkG5miJF1BmL65w5c4y+56MC4eviMA8rVxTkrzSjPk8CSDEzJCAnKGD27xiSW1lZ+QMZ+43GvqOviAjA5IBp5mrP3iXqth7+jvEVBMdTGG3Q2EdPnz7967Fjx+y/HrJJybyT94E15ECm7sl/vVLzu6KiYqNsfE9M/FDO8hStrSVmFE1O7WyCKVZfMfcPza5PBf5vhw8f7kBmYAZ4H9yGBZQU9hxbTlnf4sVyOFtAisXEEgHhZM+neKtA1KpO/qsviWb13VD6bWUngcDIO6w4u9z/D0aZ6sEzTu2gAAAAAElFTkSuQmCC"),
+    INTERSTITIAL_CLOSE_BUTTON_NORMAL("iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAUVBMVEUAAAD///////////////////////////////////////////////8AAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICfn5+/v7/Pz8/v7+////9QtCtmAAAADXRSTlMAECBQYHCAj5+/z9/v87rZqQAAAfxJREFUeAHslc2SgyAQhHeJ8UcZVBIJ+P4PuoWZA26t7ehySZV9DKn+GLoz+bp06dKlD5IqqqabWV1TFiqn+61m71Rdfct090rPG9KV+r99PUPVKpu9d9PImpzPg7hrNgnOGlrJWBf4UN/PXr9lh5elP2Vf/IVWnaoOX9/1tKne8RAnClXy7UeCGnmK8qj/O93wpF09wzvrM/5+IIEGDwnA3xkSyThAAO/vSCx3LIcb8IcEYZeUBv6QoJUI0CJ/TGhF+2Hpj6GDMkuX7sIHCgMd1hAkj8QNTX5fDwQbwiP5xYm6qpb9kPijceKlE8KyNZRkgDH1Z8KGf0oYBSOoXw0K8zZh4EOzbhIeoYpf6dcmawI66uMHFQRoTgDZgIOYgt5dEhYboY8tLwwYccBXxYOFnZg7jhgQgD/H3O10yOI4cfQW96iIxwYXBlfLxIMCltQTQQLwj/Lwj6fhCCAB+HMIDcx4IkzA/jTBlHkPQQL05320A8AE5C8HYALwxwCFAUyA/hjwnQ+Q4Yk+L+QsNf1pzw4NAIBhEAi6iqruP21lTCTnYIcEePih8VfBnx1/19xwuGVy0/exhQcvHx15+OXx3RcQXKF8CfQ11hdxjxI8DPE4xwMpj9Q8FPRY04NZj5Y9HN/x/kvifT9Q+InFj0Qzc52ZuW505vKqqqr6JLIRlkedBesAAAAASUVORK5CYII="),
+    INTERSTITIAL_CLOSE_BUTTON_PRESSED("iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAY1BMVEUAAAAjHyD///93cXH///9bVlZ3cXF3cXFxbGx3cXFybGx3cXF3cXFzbW13cXF3cXF0bm53cXF3cXETEhIZGBggHh4mJCQsKioyMDA5NjY/PDxFQkJSTU1eWVlkX19xa2t3cXE1H1L7AAAAE3RSTlMACBAgIDBQYHiAiI+fp7/P19/vm4QQ3gAAAg9JREFUeAHsld1ygyAUhNumahKNjoBIIhHf/ylb8cwEO2XBn5vMuJcysx/HXY8fhw4dOvRGOmV5WQ+kurxmpz3d04K8XdVFutPdczZ4xPLtcyS3AeqWbLt98bLqddeSOt2/nhcbpjgzMjFaCT6TUNrQITuvvX5FDk/F/5V6DpOqVUOkdH3dcK8aTUOsKNSFbt9yqJamuCz1n9I1Dx7Uw0xZr/HvJY+Q7AEB+mvBoyQ0IID3r3m09LIcUugPCGlk/xn0BwQW9z1U2B8Rqqj9YPsjlgKE7dI58gUZyRdLmtlLwg11vq87gklzd764qK4mdj84/mAce2mHYLdGEgDY/0vr+hPB4+8SWvsHCiTwp0Fm8BMkHYp5k3AK+fCrZm4yI8CjZnyQQwCzCQAbcEApsOCSUMgIP1ZwYVBHDb4qHswEmlpTxIAA/CnmOtAhhePE0Svco2w8FrgwuFpiPMhgSXtUeYn8rcaVd/UCSooAEKA/hVDCjDuOCdifdzBl2kOQAP1pHwUAmAD8YwGYgP0x4JsAiED+GPDpAXztCNj+it4v5F1q+tOeHVoBAMIwEBUI3kOx/7TILsB3lx3aJBd+aPpV+GfH3zU3HG6Z3vR5bOHBy0dHHn55fPcFRFcoXwJ9jfVF3KMEDkM8zvFAyiM1DwU91vRg1qNlD8c93vcDhZ9Y+Eg0WvvMzHW/zlxeKaX0AEs5cjxqSuS5AAAAAElFTkSuQmCC"),
 
     THATCHED_BACKGROUND("iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAAAAADRE4smAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGGlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBFTAyMHy7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BSMDVQYqg4jIKAUICxE+CDEESC4tKoMHJQODAIMCgwGDA0MAQyJDPcMChqMMbxjFGV0YSxlXMN5jEmMKYprAdIFZmDmSeSHzGxZLlg6WW6x6rK2s99gs2aaxfWMPZ9/NocTRxfGFM5HzApcj1xZuTe4FPFI8U3mFeCfxCfNN45fhXyygI7BD0FXwilCq0A/hXhEVkb2i4aJfxCaJG4lfkaiQlJM8JpUvLS19QqZMVl32llyfvIv8H4WtioVKekpvldeqFKiaqP5UO6jepRGqqaT5QeuA9iSdVF0rPUG9V/pHDBYY1hrFGNuayJsym740u2C+02KJ5QSrOutcmzjbQDtXe2sHY0cdJzVnJRcFV3k3BXdlD3VPXS8Tbxsfd99gvwT//ID6wIlBS4N3hVwMfRnOFCEXaRUVEV0RMzN2T9yDBLZE3aSw5IaUNak30zkyLDIzs+ZmX8xlz7PPryjYVPiuWLskq3RV2ZsK/cqSql01jLVedVPrHzbqNdU0n22VaytsP9op3VXUfbpXta+x/+5Em0mzJ/+dGj/t8AyNmf2zvs9JmHt6vvmCpYtEFrcu+bYsc/m9lSGrTq9xWbtvveWGbZtMNm/ZarJt+w6rnft3u+45uy9s/4ODOYd+Hmk/Jn58xUnrU+fOJJ/9dX7SRe1LR68kXv13fc5Nm1t379TfU75/4mHeY7En+59lvhB5efB1/lv5dxc+NH0y/fzq64Lv4T8Ffp360/rP8f9/AA0ADzT6lvFdAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAIDwSURBVHja7L1rthu7jjQYAFOu6p5Tz39I37pWkugfiUeAqds9AFO16txzbO+9JVkEgUA8rv8HNwYmAIEBWFAIFi5MAAbBwIRBYBB8sDDxPAyAAhBMCCYu3AAA9e8kMFxQ/B/8wcIHf3FhwgAA4n9O8cUAcAP+uwLFDQEw/LlM/64LwBcXBMP/hABYEEwMXFiYEAgEC4Bi+p8xLCgMmt8ZGPl86yfsjwHDAnDhxoRC8MFf/47Pe6L+Dj2Pif8b//H35cKNP1hY/qdvf0+Q78s3vy5em9AzFv8+goHlv/v87QzA/5ZuXACAv7ig/rdx4S+AP/jr391wAbgx8pk8r/WDr/+cC+fxTz+uOEnw82z+iTQA5p+4OrXPybj9E/qcf/Hzqv5nJSuE+Vcu/++ZpwD+3dXPsORXCtT/e+V3ef7LAMz8mfBnIP684d8h/n/leUN+jfqfH/46FgQKQGEY+RVR/eB1Y2Bi+PcZ/vo1n5/kqebTrFB/N+NdsNdb/5zwBcHKKhXvarwbw5/FU7MEI8/xyNO7cPlz0nyeklVd8tmZv7vLK8hTV04F+NcrQH06LW+Z6Z9v8U9jnX3F9NsE9Mme/iu3n2nkSXzubfFPqvinD3knxZmeECyo/9fC8K+3fG6SPcXzuf6LkT/fvA5J/huoc6nztLzSxOtbVItuf+bL/1v87C2vUJZVaWU9qhNf5/t5L76AV5HnNa4861E7pteheGVPdZHtOa/8Hsi/E4NgYuGGQb3zWV6t9UedkfwJz5+Kn+gfgHMGTg/weqhPAMiT/tw8dWaQXXz0pcj/7Z204oOP/17dwOL97fBP5vAqoX5/mv+a+nl9fpJ4v6vZKcRN9r5dZ57jONHq1cOofsWJ5YrWb83nO1lWjriTo28ZfudX7YlnazkNab4/6lNKvFcfDL+vBYrht/vz/8vfDWBiQv3eFnqV5n9Py7/DUwkmBLf/r/mrXtlxqXdi61SA88gPQNwS5idr5H2n2WObd8CgSR3gGYL74brLnrt+5mde/CaMsxPn+DnZM89goAlKHWudVK5O8G7asoNWRxXq+yyvGs/3W3Rvxx0uNOssmiSMsAXLd6lO0E19RK+Qz/njOcD8VUZnASzcgGMrmv3Q8l8xOuczX1/8PWmecPW/FUvM4PlbNEcXzP8N+b+Sr/tUgDMFoHXbyzvL6GlrPph0fp6vGK+bNz734jfQ8tsR1M+aIwJfGAw3Lj898Htz+a/Zj+/+IJOFPqifffVKgexwv9kLPK/jysqCPP+W57pqA17IAldC2ZCN+m/dqqHmnVy9QUxIw7+rZE0EvTtre92Lfm0mJrLye32pFj9o6sDChW++ioE7f9pqHcDpAU4F6Ge3brO67XjKDQSwPvf7tLDajd+3Bqshfs/n94+fI81TYXSzP/8eJ3b51Pt0C6PN44uqWNztkrhE4QWKO7tp8a5jUKWrSXrRmRdHJwohlfyK5RPNJCyyXmugfZYThOQcgVfHwHXFCBHR7INi/3AlmvInuyhA8XHkP+arj79CZMWYDak5FeBfrwAxQZrvz6Qh1XGL1s036R4Z2Q2Yf5aMcPyVCIJ43yBZU9RvoUmdNqP38aeU7j/J+Z97WlBHsNerp+4EJvgUPCH8oKbzZyb/+nkD1QjLnz3zFE/C7JW6Ee4BCkmsd2/4Ozgd05e2ReCuh29qc9zQ6HeAL27/iq+/J8/r+gvDX58b7kQrFs16vNsZpwIcJNDvJJ4CeHfNdz9aLzAwfBJ4uoKP/1fcqk99GDmn8glZuSuw3BOYY2TVT8zt51revpb3c9Sa5xbWxLziVlevWc+MffufmNt5je6lMPrYO6L1RWiYPr8zi/73qWzcJ4EmC2yVjjcujPPNvPm5T9NtcuH3Vv2Mj6xfyA5r5b5kJnawoKcC/PMV4Jv38MpzsIiTgpyM9/s7UHrAcPvdtrbZ9Zn0+5maPsmjba3F92Efx+3N+1zQeZu+8bp9y7Dyvr3yDlavQ9ruvY+fpst7dmmoOnKDiHzl0u7zuM01XzNP/rF9lHxlw5/V8i4E2Yf0KX85KjIdOxm00Ry046wpwQihqJ9vtDuMzUPf5/B89UxTE0hW0Xn8uxXgcoZJ8eaA934NbYfMp8aylx7+T4Phgy8uLCxcMHz8zxRPT7NOMAIWCGSg6s85vcEbr2ABauLpgXBNuqWritVOA8mcq0lA2hnpyEch/5Jo6Z34flSB5X3L9FM1G+ZRnIBFSGQhlCurat3Zi3AEtL0Hn30jxMNoWgi21ndjS8yN+ajOdzwV4F+vAM8neCQqfDkLrvPqjGrC2qbJheLRwDm2kpvqBfNJdRLeZl41lp/nYOd+vcf+OHp95UQcu+/41I/Wj9TMLXRT178/J1Ubqlgdej0L0E0d05FSvZOGfUpiFdiQfSPkAn4qlfgCgzA/aV974XZesWXvFX8rhSUWQ6O2Dk+38Sd5A4UNVAc2cjaKanIqwNkF1F22aC/H+/24fSY+fosafY7jsxsTMN/q9uooLFH86u6H36yBytXJKubdbPXH8Df5reL3/0pdgyUnB4S6S3YyxfDV7Jyfn1/bc20z/s550Paqet9QZ/vO9y2mj6eKjWTlMA/x6Wxm22j0aUFyWwD6W+oMhdm2CyAMRLKHqp98KsCpAF+fQw1fZ5N9EhMDfZqnd7XLT8lKzBzg/Xj9cyUKx732Is6vJmul+PTFax8w/HEFjiQvSHMjXretovZ1QvyXft8VPj+IaxTI3kqkEYngWdtPcD2pe96oJgYaYIlygKqg/ZjkgyMtuZmTHxsTRg0X9V6am4XQVszGHI6ZP2ak4EYIgmd4cIBTAS7fGQVrThNjU6ApZp5J/4+fqNvxtb95Bkf2n9Y+tdpUcJo6gdpMo/UIpSKYzo8zn7R5oxVnq25W9c//aLh7cX1DjxD/Pol5oHlDwhlRg9BQI5WDpBKiuhXuFhaphhirlMaKVGfzS75z1irNpB1E5wIr9UXq3/X5OR/c2dlMYmaCdhHM4H5+71SAf70C3H7bmXeaf/GHegDW8w1X/9SZWw3LG/jm3km3aZing9qPd54gCNWTVkf6yTeaClY+w+prbz+ht9ckeGfDvTHz9VkbJdmTGzEjQZMF/NyEds/oxldi4ZlvN25cztUTYjjrq4vhfWNXLz7vt+L7qq/xPu06yOHbkQngQ/grWl18nsepAP96BRit27TtTDBTcO+u9/t7Ao0DL/R10thBIJ5+/Ixg0CuQ2h84Y3i4emjlGVtNxxi4QbGClXi4Qv4H2m5XVjMVqy76oUEYX/Fq0HYi5rd+zeAz2Y1o28JA7EbuDrH1KcVSjg5sJt/Cmha54w/xbn9bVb19Upu5FVRiRklOQqcCHCSwJuSnlxx0py6I80qfTX2w0LXttY1m89odhOpX6B5XGP4H6tj2F6BTL40Ht1wDuxw5iM15nMtFDGVrGJgmmlcdiLZzNAm1W8lCiso3CI3rfYdQdzTxIVygXoP6q+x3NXLG+BIeIjmXh+L3aijsvhu0DY+sd7+wyJXs6pnvIu9mJPXK5k4w5/FvV4DpKN/MT/bzmXq6V3OkaaJYb3UPX83bIyZQSQ1c3Wqa6r2VPD6eIYw2d4Xa94e6085qvcrMytHdR0Dnb2Q/ECz55eygC39T3dC3m6N9L03dgZA2qabyYuqtZDEhsX2jTmjkba75vgWPafiNX9wHzW2jJSuBmX62vV7mOV4+sVmyMycpLkO1dCrAmQJm9rzx+Y4NtDZ3q9r4L7/DbqoYD9585+dz5jnofS4rg7j35b1WaeTu/LTHuSwHn1Iwz8ZXYs0PvIrVM4xeWfAf1zcKncfV7tdFqGPH9IX0kiv1g6Uq5J49eFLlNmT4+DZTaOp/GHqLEI3qz4b/75UoQmF7E6yjUFJ0VNVAbjiQHdFTQ04F+NcrQJ2bkd2mAqRrta3bn+nnMclDjHf28sOzwzb+3XQfPvH+F96rKuHpk7CyYiYbzdmdt78cmeufevFzEQgDI/AjlcWgDqDrIMrBS14bC23MiY6OGKarpdgd6fn+f7FcGc3OAtO5hc/9Pfy/h9fab+qtgx9w+f/H8/lmDeN+KFCUYAF+W/U9FeBfrwArN051zz3d69VmZBDiFT37RZ80baeOUfX6av49cUeMcLn45Oc1nsUHl/OVR+MDaD7T2Ziz0jiH5StS7prrpXCoZ19YRUw6lhVhOFeImUXFhq594MNgvNo8o/8Ffpmt34p3/ZNeSOV29ij9P/k8zRmTlvtXA1qngG1ymMQtDvV2oAunApwKYMmICbTocbd97p4HS7oJ+bZky2jyU436fdnwcmwanNqfC03QhmLHGzlxSTtFStzcQX+WPUsZewwM7nESZvxPs1JwZ3Kj/BKZtVs6J/41Idzu9n//S1iipDfA2qb1mXzGwAKnv6fl2LL3MrWz4PlgVxTunZeRDhOpi5y+JTg9wKkASlOA+X1sfgspPqTGx7azt0SYufP9b56Ck5TBSvdvoV7hfVPoeX2GhbyLjfg20jwvJFlN33QcfbYbMeGoMxWl6WV5zoYjBaPd96XQE2BzSCsVUkz7mtvO4TtN9fljP80gRH53QistwXAsVfzWv1Lbq+ncvGsONec6pCYY9D1jM3kqwMEB0HZePD8vQggedw24Yme4f/7l/LnbHavF59aPfz7n5jaoyQVezUcoeIUzZ/W+ESuMYiavr7vpsrPQTbeupJIgPIEv+ppyA71ax9I1kuJo3sxtYnUbmjMUHDctruH0d2e2u7gnB/D3kWQHXcR4UnxhuLOfWcn4ZYeWtTkMlYJZXZPAE1pV7VMBzhQg21ysqaHXZAKwK4+R2tUcrXr23F9HtCcWvo56I3vPyz+pazsH1S9jcyu0xrgF/URWxHZUMNyxlHDNYiUKLu9rOie5OIZK04AQ/jEJ7+BXdieiVlq9kaynkex9a/vDfbO/6w8WWG3VK2J5ofOWZVANt8RUJZ3K7/wTK90E5OwCzuP6X/8kC648XR8/3+q+OjzFBz4oyRPYvafEv5emm/2DbGt6BKPtthftB5ihPNrun3GE6d9dSB8YfJz5o38fpLzvTKHAHdmZuDiFfZvHjGbm5j8sg2cveKXLgbjLT0ca+iwxm0rx9mnkJv/wwjuUOFOhLxqvvYtsE0pkuShtBmKnuvxv6jz+9R6gNvI33R6LtmRzY+uV4iym5+/mAgZC47HdVkZTcMe2BnEFRurs+LsOqhErecT6A3M04tgyZ3A5H26RVjaQ0JEVh51/0F4DbwGDnTizd38YFBft/YSyxYL1xE7DksjrJLxkJhIiPtVwvskkxHA11tWk59i3G+HQMhqX+PgEngowwS7W87UXk0TAg+XLbn/skWeEtNUdO7edgGXdqIoy6XwqueZqnonL61JtHYV+CmieB5hjtNJZozt9W3bvd/Y1ce5umk2WswdnVr7K39FW9SLVMNRTT5W4tyQDpAda8CxL52A+SwmQu1FrKSeBOQz/6uf3vg1ReeONMUHM5rES24hTAf71ClCnh7uBmo3tdbsKnZCOa++fPGnfQXMHjo2vg/TQLh8NBXNg46ab2SmwBxh39jVr6+YFeKGnCAYm+eR41tlhTNDcXZBxdPboE3TvgBt31tDKJFp0Mw90599KTPrttzBbomFxlKsH6X8XixTBQhiDNf/36nVOBfjXK8AnT1lp71bj8Zgject73OW412z3Pzv3Fi5QzNfezwu6ItHaFNv9gUF4udF/Fw/mbkr4ztUvrUJo+he9LkbIu3YX7bnFuewbDM4xiK5lJDpgnm9SnB1O7BFCKYVyxvDqEIIVVfP/yufTfRC6xyNrNi5HTxndeKrpqQD/egWwtpES4tMM95B5VHA9dy9UJ+UNzg78tZ+fG4aHhhMwHyiyscTxCL7VJH0Lrbl28RQcf3Zs/qPXD/yOd3nPM/6++Pw1z9SEXb4HmkhdsSYlkQRx5Q27ewh1INM3+5Lbgkhk09ZzfQDSMPP7qa0vkFfVlM2JCIk+lAphncSQ8wCuSc5TK2+X4uJMLPzNnfrMz1PP9Rn0OQ+PiuWf8uDfrB+uH8iTOPLX2Vk4PrNCPliXI9lGiYPdpY+rzqRMXlDlGHlnTkzcyTSWZNIKpQDNzR1BSCOIdBSuajQbB6Gc2MUrnPp+bibyio09WNjIhW/u8Cp1LZBL3jxcbS+zNs0wo4+VZnwqwNkFiG+GJs2Jgaqtxu8tN11W83Ukobw7je5s1tj2O7n+VPlol5cvKEW8UPhnPr+zd4jbbILV8tq8vIqDoImwjbxhr9ZRd3ct9gfkfLXY9lVfX71BTdvDJywjFCFyPSXzhJUU1oHKaqqNr/zOK7ebixDBvcfaOdfBLGJGdLzXpwIcJNAob+KLP1tHqbTV083XE+icHEv12gLnc1bymHh3ezsOh/aJh2NTX4TSdSbmLk25PzKDS9D9BLSlcoZecNBJWIS0XYQeIBOUy020O2txRbCmQjDwhnBktdMNSQ1Hkwm09xSpdZrZl0Q/9sGXqpK1tAFL5o819BLEeTZ6ZUgVSPjAnArwr1eAgfLUBy58/E5F+3Xu3a1N0iM/TZyONSjpunCzSfuFlTs9xZ3M90e/OpvfnuXUPKgbWc13V2jm1daR8AwOcgEQ8kZc221v5KOHjdPf3RIkO/JF7IPwN7bUWFsyei7c+Dhn6q2hLo//8WMPYy+/P3llnij1KCv1DuFZGFrJyjM6FeBfrwDlD1x96yDUqJA1Te1KKYEXOWCt5tzDU3nxCSoR8/be9obi69P6cDZusOPK838mq5Udf349zHHE8jVclPVbSWKBQQ7y8O6MIKUNhyLYBayTsubT2WsHa3J/eRnJlsnYPQZWZiZachGqvk7KaV7NkfHXZmUlolg1wvJv4lSAgwROZ7wADxuGt2icRMf35cLA7dM+a/5Wu3Etd/vaUOhgHimh7tE5hAOAtDse7TMcn921sV8k0T+uCPu5qO+g2+ntToXmmWeWviLFcbgIYbOc9q0lBYTD0sDA/fJPqFpj22uLKcfIRWzku4OspbUpDLxgpMdw7QhWe/9CV1V/V6cCnCkA5PnDTD7Nu09SXfNw/Dmlc+XUW075hY/NHxO0EEfI0p+3NuWavybNfVRzK1gZ5v3mtDaRG7EaAbzuXKWOJrxN79TpcuaB5HPSZDiwU5LmtkMzAS1q2SQUH69NxXr5kGu+wn1KqPeyuFOVS2TpUFBI7WiOSEicBJkUd5RBpwI8u6Q7OSort4PlBRI5f+ZegCP79+mfVc2OVTbWHE/iA5y5W8l2yyeCysHl82xt4yDErlttTh/+0wO71KYr2N2NuZOW5OROGG4/05LOpEaoRaEhi1yL68629CIJtCIyD5Genc97/vUKWXu90bYQ3REYdPNLw/ZKTx1Tz/Qd4Zd8n2duG5XynE5y6KkAhed3jqn6vqqYeHF+NRkqw/H0r9+KRnf53Kbj+vdg6I3cmq901Z15W638NA/ajT9f982uuPQz0+flkXM/+2Tte/rCM5XqyZX9dngE/EluXnUVM/cE9X8X1Ya4yY2Uwtb8Dos3ocQ3ttwL9u3DzJOtP3qomKnMv/4C3Mf8SvTvSvykXAVid3gqwL9eARad1jdrT1ra7kqOkPrpnAglzcybMnIzjBI3bHP8XHRWBB/KCtVk1kYi+ZN/89c/x0r8/uLojVQPaebvDFQCgOYpMH/mmlszEH6553XelDYWPcvI3kUS5wcufx+6T5mRn6HQuxzzt6Yecvf7GqT5675MXe9g+c4/+SJ/KQdx5gZ10t+jkhfzqQCnApQ/TZ9+e4KfUb7VjXKhGnmrI9PwBuF7K28o5gOt5oSnuPEhTcHMjX0leUy67zk5F80Hj2sV+25M4iYZ8RNn+gkUGsCcH+RUPYGmrAkOz8j9f2AY9+a41HO9uEIIPUNseMnM77OaO2uxCpAdh9L7X8/9eT++pEmopOWV+MOpAKcCaO7bOydOszfg26x2XKUW6vp/e2XllKegbCxCztLtrpdCz6Snc8MnA9A9tsg3rG8lIxF0JPKnPjFojkFCKX68vyzfvpVVorBJzuVZrpTaZ58FTijcdXx77toCCE2obV95goxWSTTdnEa+NqRfw8AfFPexNjrmCaMPovs5FeCfrwCGTyJVzDtbmb1Zvn2TWKbM96mNQTEHqnuduCilOpKKP7m7gqtv4RPAaneitRxwTc9MdZcgcb/tmaza4t9qYm+LeELyYz9RtcMIJ1jUZyzSKXAPspK9z+4IK1+HtWoi9P52bFIy1wCZnT6SX7hX4pWoSfi6VF1EcpLmtg0B2FH5efanApwpANmpDmKTDz+ZtfdT8sxVwvEV4cXfefw1z34B9xA0wtNKHX83v7zOvlMU35a9/Ep7s3JeNuIvrJYApKQLeE86o3H8q8cv7aA2rh2yXsV3vqguxDu26MyVv0flqs3MYJZ2vqvDevgUt2/xlZLPKw/RiCklPoWMVB4qKb1L2/DbIfU8/tVdAM/Msk2MaJPlnh3MXKDQvKwNy5p00uJ8a2IHV2KJz8/9vnCulbN1+Q0sTzYsNsHwTcTIWYP1w3znA2+/skU7PmuTRzluIivcTWoC7iJAjAihW99awlhNMt/cpk7fPSITzmIHG46l5QsW3gOTPBxjZxnphsOxTuYZz9eWUbzKn8e/PgXM3GaDNmmaHtea6H509Up9sOT8Otrp2h+S5xWJqQMXBoA/vmm8vCbw7f/2FLHXVqx7Fa2mZkD7PaP+nPsAzjxeVIPYHSQ4SiO5UIv28PUdeXaxbeMwEkH84/4Ln/Ri/49ntQJPTnN4Mf4P/npletKDJDP/2EWpTzqc5M5/J0b5xwvfwwc4j0szpw6EJ+0css6Mk/w8M4++tMGayYCgGvJ8lzv3B+rnvlSB8lP1wshc+Ape6WdiyZ03csIGMQAsT2Ix7L+JPbD7bvTVMXEMwvCKGS2E2FXisWxMxFId9VSVQBq+uN1nJbqkG8iUX3Pn0Oe5lq4R6TrSOVIgjqOBddvRzWnbZBQX4lSAMwWAMLByteGsuZ5AK/TZWp4dYs1LNxiAkszikclAzM8zOlWsy0Pj5ws4i0z9JEvjG5Sr9jPdSusJQN4Cgxy0g1+sLZvMtp9qW10C0KZ8e+V3MbeR2RaRXC7N17TjipYdfr2Cue1HujOwtVQyI9+22o2+XdeD73EqwEEC+61QutzZ7jXQHNrzetZLBb8as6U8w5AIW0/bFHQVi237BmmJwYvy9oqZi8ze66jXyg7ANl/CtfkMcypJ1UWlvASjnqb/hMIjqzeId3DkVCP4AK42Km9AazOHOTuioydcJUrRqAjPpHIzCFbUnSjhN72QekUBpZaex789BRjdaoyi7Tff+jFdS3PhCobNIr7r+sFzXY6IS86l4htDdgGV3Dawf5+Q92jNLdEJT+y5pYvmie6lF/ezNo6CUTWY6ZTUkQFND/CVswb/76LJBs25q3DFqLhXzv6CgRuf1GhYPjt5bSKZpVwooaXGs+ctdl2iJnZ7lEGnAiD9gVlTijZTDs/E0s2JCgAxVhbhY5P8PKz1489n/QbIIetu+zD23g6+68xTGF2ytHkhvAcmsKXvKumMxlbRsD1DA7Znotv5l2QuSE5NnPsb3ODgWs+Wkmbk2F/551/KDQSd3EUZakKdUPdatNcr6PtFofq8Nk7h4QSex5MevtI/EtTfLtSe3/AXn7yzR+sBmAFTGXbPhDl9m8Z53JWi1zH5Qd7iSI/r6bVnUaI4cu5f6eu1Ws9Q1Uk3L+G9zkje9sPfA+YoLnIslU3jLw2J/DgvIPwCJFkMw/U5Iz0EOX9c0lN1pXeHbjge91HVPxWisFINuZIFNInPNHNS+TSe0uEDnAeu3uFrKkiV7rzS0Ekm6PV9u7SkgJWoH39y0ZI+Zu4ACt0aG+rWtXRrw+5X28TzuV5gdnw9lwt73knk9k1n4YG4fPC5XV9uXpzzWwze0DRERfxSv14pa4rOQez+ZfxO105010zPLZWk8FCh/x3t97DNOVGPTwX41yvATTi20eZqtXM+kx8fn3dmApufIaN0jEH4/KQszFKoxV1eqpy5cViNsDVGJwIxeOeaVGo2CItEniXZ0Pe4LbEloIAY0NqYhmg7R95WWnM1qk28pPOfJSoYz+ymP9HRFWv7hpGsqQHFp3VLnZO03O1hwihvaJLKM3qmycug8/hnK8BFiNWfTMjQ5K7EZzXcuCV17e+N9KQ92Gp+XB3N1jxt7N7HuWXW5tV9cr9QmkDNlOLuVbqz7o3S0GvzsXKqny0NVHMCWLS/APkTM74A7I5cnKS8WubRoCr7VmUXj2htqihpfxtwD9Bnv/D1rcAfTPID0KwA4X30VIaLOMonM+hUgDqpI1Esox5SyFsSyfZZlAUu/k/Bh9g9Sp42fdvQb2SjPKAdn5PsPeLuCreQK/9MeRUaPduR7L+uB+DkHtD5/7X7UJRGB9sz481ifT9tiSQ1+9yJa2LbKQilBLOusbJYQX8nPcmxkI7pd/wXhm97L1iPPT39yVJfIQcHOI9LmvtEJWrMximJ8664U1tfLDzJzOvyrav08UWf4n7W5uYlVpVgJoeNkwsCY0ND54SYt/UKNDuEQsOFUsFBOrzVNPar5futtrO35Bb0KbzPR8s7qEg+ehz/P+558Dz3T2b33t7b39T5K3kih0OJprZobQqnkThuII0juZCS3qOBeEStetDKUwH+9QrA3h/22ppLY90JMfv2k4t2MkotEHfTh9CD+irOGLXsswelmXauEXOReMO12mtYhF4ITeQ3YZW8I1gNFwg2byWfLBTrYGTdKqze2r8bpZLE7mNR4nnd+nf+miWTAdlvTaqbj9vHn9zNdDxjUmdye1c2qfuZqcWsvcJyr9NTAU4P0LNxNB22OBk7XHLLK4N7fJ7Al7Pdy1dwkTtY76S5ygj56U9Xzsb0IYQqzNQWVIfc87H1hYGzu6egEo3ZLYvvU2SmV2h4R2p6Qd1G19oLpS/J9krZF3x5XgLrFiT/axLnkreflprft+ppkL9ZpbFjy3bs73jsMk8FODiANEVsoHHatPCTcjBWqlUfz86ZbJvpulRrPKFnBh7EoF9NvcIpA0o4o5D31UjW0vPJ/lAWuP1QAYRj/8zs0MgHgX+9ZkI3VzpmQFg6AFV+UPQnvM97axS5PsnLN3mgnNbhGWmxwbs25FO2DANmMUjOGUg9Z3AHIxt8dyjt3MejCziPhxWsOS0a7QLu5ohhDUUrXc6erseplYJIJp6prdWc4tcL6+LdWZ3omjDKVz+cMLWx+0d7DpGrO+j37+YyKJmLgNcr6JhloKRKqDxPQ5rZHquh/ZX6A/Lzv4mnXJ6Gz0/4S+f2duQuzvZI94CZm8f18nItBYW1PkRcn2XkmHIqwKkAwXqprK/OXu2b7dlydqQ57cjmw8WuXR//XEeHrnlD812/aGNXbt41hdd+/M6puXOOxsZ5QdYCyfleadaOPly3jDP+Hqv10Gu77+tnGPX80vyEjbqH56bfPYR27+7wIGfmpKU/u1B+0Hj1UUJMZaQr0cdxx0Gzw2EEnceTGgbv3ovfJ+0+Bfnq950Zc96x/f4k/9HuryWUGsCnlrPwin8EqivxbPbM3+qH92xNS3wOjaeAhmf2f+MsYmve30JKv9Xqj1DV4g4+kPkr/cFX4y2/XQur/hl6irPm+2XuqLg7IA1idICciSxd2h71giWb+1SAMwXwjBlYmrYuFq+bvqt9ukdO16/Yxu2NXn74jmom1lU8wyuVQJoJO2g38N1cfXg+li1vSLY5ZjStDOjOtYYQYrvrbZsMuA68/zSjcjV3fxMv6S4mlvhGJaQidUdVhxa9B0b+rpFrWgrJYmtq/hq7udTrPxXgIIHWcmvC3VeSNVYdQaVa8n99/faJ8zOa7w5n5vDnFY33jsTQizvDHTnQEcuLzvm+zbhya175h+WZOzPlk91DF/UItn2/8QMtWC+0QGhjgY0JYS0jxegeX9sWQTdfYGxVbHdM+e2ujkxzMd87aL5fK9/NB908FeBfrwAf+qTD87gWTeszd1f8CaqTMLJfZzXryORddtmLyVrTB7c+tbE9qDM/s3oYbeJqwy2EBAglhvW8guAHhf7h8tcq/gye3WflarGTiDjfDq/bn/d1AGjHiMYf1uypRqYUxTag1Dux/7hzIoLz/59dwZ4lqOQDZIS8aua4XyinM6SqO1DE4f6reirAeVxGmnfQ7QRK+EQmT6KhfTOn9hvhuX0nCqCkByy920iGWuUE1CaCuTZvpT7Iu9QITePEvrpTS227XjjFaoh55W5F1tavzr/fzd0/jDcMtUMsf+DoIiZ9pzq/l283jLqf8jYsRWZsP5k1VSlg7Aiy0l955U60OxDUNvI8/u0KcPu5vzHwdXWrpcKsVPkznbasIYFGet+VCXpGKpt3anhhCEKconC4H7mlqy3BoETxx13Yknm/6Pyztj82/nw/7+eZtQJCuh9sJ7vvRdk17Z141GuTtiTvkR1G1/3U7mLm6xq0uVhNS/R95ZErvugpRR3Hrb8Fpeynkx18HrhqKz0JmZJMsg217Ui/cKH5lHlD7N+luNKBeJAGLj6vN/F7wz1neUbRzLQiUDrAdH890GzfHe+44vD+TjZdMHvnsDqx/E1mSw/srBrO6WN9k3nt2rHRvqGfxG4wYihbuo1oY2E9mOcXf5pyWZuKejV/xSu7fn53WKdpbaN5KsC/XgEu3woPV50/veonu9mLfK5GS+dD4waM/DMDyPsOL8S8HDJYBYzs1DmbpGeIzcavtcbn7VMA5593B47V3LV2j86V20LJmlZndtLEHxrpke/DJIWCOIJSnsm1yws+j6aDZ83isyELpUy+/Pt9vP5dvjEo5mV1KjNTVWo26h3BIO+Qwwc4FSA+1zeu1MGsnGdrHq1bP7B6a0ng+zwu6SSu5Ba8wE4d2rRCY2PZAZwvIu10yM8+N2rGzGl35RzeOQvsahDYPDJva20IvFBKh5GmedL0rW2Cn5R7HFnroHs8vp63AB0j0OzKxHG7cvuaziCsub/URjP/lhY5jnUlUemsjz/AqQCcvL2SeTrTD2DR/Ck0mSJ1quWs0bPvWN1mlPLHKdeS3JXLNxHPtPHFx5EHIR/i8MYT8gm0xByez/9Ne/C5+Q115BB0umM7wQwjEHIf2YjapgyQM2m4iij5eoJ8u9QVwJEwXvtB9k/HlgZSyd87y6F0z0rvaWWNTppr7NUrLa/vxx/gVADZEH+kEzYygw55m/WtX3lPYVPYSdtgVdcvvvOaiSDcqY8V3FjeX8Q9fPlO4UEYF80RdbvVp39sXL9gKKwXEqi5zxhZp57HnXN+ryCTMlVkm28CSxibgkdJ8xff4/YuIzpxJVcBTl4oDdJqe9b+bzF3jNQYjvbu195l76CC5XAqwL9eAbDtz/ssun58iTX33/02xXbX1t17uUIAKN3gyDt3EEZQypXZbj40h12hdA5W0jLyb+S4V6oioayB0kPXSS2l1CJOcXXRVYcsv98ipO4iF7Tg/BUmJ63isIuPtT9lm6MRgI1DUUjG7rCkbae57z6Kj3HUwacCzKZl2526VnMMRWb+mut9Qbm6e3KQbeh7+W+OxANu3xhY+tdJ0+8Uhw4NsytMsDuD7l7DQtPIvflngTr62j9Wwu/IPmM11j/v1EotpOSktPIcypaDJNsUMpKLUH2WkNviPrOs/CqlWmSuMcbGp+ipbNU9LOrcTgU4UwA2fYxSR6Ab5lbTgrStQKFms2XWF9O2K9cKNa+TvLakHTQ3H0W59CqxCAf5iQp5lK90Gtv18fsufdfxLnIxXS3fAz6NTJ+k+ZwNR/1X8+VlPyTNXh+k0C3XVfO0MKHaIS/v4drqDao/f7Orimc16R1kp1FrzmlnG3gqgNJn8d3vl9ZGSDE0Um9uxMfRnEnrduy3YqhZFNiSxHrOrWTfrInwPz/lenHx8TrLlphYbONmqh3u7PFBXppC3odPFRvEn9FEF6dnp8Q7oel5Hjz8jil0d4XVdM/W8BVkgpAlCtB5Rn2OfxTGAyu9P7uG80pv53IkmWDtFI4y6Dx8FxCclPKrXU3bh3abBPu+d/0PNr+cad9VLDyTa5tkeWOtTUEP+uw/7hzTfy4awmWbZ2aftS3zePBiDDKSHjXp4720tsSz0iYo+XSZ70EmoY/1bCXTR4zYvZN6Gkn0wLKiwusKTxj9vai6MpNl/Jzw25EUbYmud1Nq9ung9ADnwUhgnVh53TmrseB/qdunf+7mxo1Vz7Yt3G6/9e2lsiu2wGz6eSFO4ZeywtD48ez3yypmaTy6nU2IHwnhXJ9kS08K5+Tw/x2kZ+Izttr8FDuL6Gzq7Aupm0HZYoW+VLYbu4Up9fwrk4uQ/gp7P1eoQPwdnQpwcIBgxI9NFRv97aCzoOnr8WtmqH8ulDfH3Rw6igUb6vc7nfRD31demSMzBrtv4XDfMaXZoTr/td136v0C6wSU0LVQGwxHDOO13jknhH+KJeo+8XVU7cbEoMTAub2L/02PYG3X0t0EK+HMqBe68k4XZ1tV/aqpqWMimh2BtQT3mibO40wBizgAu8eFNCdcULc6/QZjR9DanhUK3xm2ozF6BPBJVsiJID6Z5UEaDEEllP5K5+JA4mobiOw6QM9q/kwuCYziYeBre/XdeZQzBCXZN4Nuct3OOBp3QMhluScbvfugvpuR5l1Qyn9WKDH+WBV3EnLaq6OdKeA8gKvw6RvTfWx4U6aUPFs6NfbgjE/2gDjbzRLJHr6DU9Li9tndnIU80s8q2EFKHFghH+K4g7Ul47EeboFd9DkxAMCmlynVHbN8qz/oswLauR7Eb5xZK2bzUvq10YvJpnzIB/20ylKM/KOZzuuBTc7MJAk8ZL2Sl/fdoFAGeVWYUwH+9QpQWTJKGdo1VyvdbNb6c22zArNyVjtzkvf317O0kUlk16YUwI/s4O4wuFrPrI1F1LMMi4n0t3XE/XblBB7NpB3m52jmj4WzSOnxlzOpzZ0LHw8+daRwUD5X3eXqvkqLMLvZeNeWToqVWDLxqILD1bE8iRc5Bk7iXyptY5hlINTfHBzgVACl0y5+11x5Hupeww+uCZpm9c4blTOAv8SOm4mXl06mdnNKrh570oc25f7MDeMivFBa7k5N/ko8nq5ikuahJz/3CVEjVuMFcB5HOYivhtS/1flA10Tye1gcwUEegtZuadlA3JkJZZH3Pjx9YLhWoOaUSme/ED4jZwo4D1yVKMXcnkjVLmRun0trszeaNgU0m4dSZeXmjlN00XQ/8vLDi9MnqXdfqVyo71EMo0ozqtfzpG0Znb23s8/uHyRUkyRfmTRPj/D1YqzOmr4P1JswvqKbE8mgeWrl98SWRsTdi9I0U69otcoyE4EFvt5VfFsKK45H0Hn4LiD4N7tejVOt6zQK3ZCT7rXaAs6tUxB0xv/zqf2Q3t5IQSfkZlU7hUHse2x7rpUc2Sv3Zuqzcjn/8OzP2uD/ttWwTXmP9uzr/egaHp6Y0FzQLXmKzCH4XYmwbQg6Z+pO3PabPUBlHhghCaDsck0kQEkrfaaAUwH2LtRoXxy+k4s4sou2e/2EBFo9aBuw+3baps8dqf4JzF79p1UdWlQ/gO5LAnDWmGy9imQ10vyeu2sY9+gL5Vt0pyZg/UTzghEUX/VJtCN6lq7erV1GeZLtyH95EJciWTPDsPb36u/zQKirvqlk6qkGRjuRSawFO27h5+EVoNK2hTg2oE5Uc4JEfhL7lD6Im2b+ibxI5VI4m2DPIBr0vaoDHogMrpg3Ppk/ooRRIE//alzjx7N05iSymqOQvTSPkaJ5ZxfyIWZgnPhFHGLBxzm5kn33c0Pfucm8HMNbdA6t7Q2qg6oaoC0HbPrX35t/qSLyh8uTWYivUEqMYgyvNgfY2QWchzOCjDy0yt+nI9icGBideanf2edrpv8NUDyBPe92NeZPdxQt59HK3L4dX5vbNqs8fm9K9uXUzMr9u/DdOu/oQK7sFhZ5/S98kiuxyAFUs8bAOwEhtjP7HxnploqLU9uQ8D4diW8Y8Q45xajPYz37Vyk7GC9WdWQajsT+7nwmxx/gVAAjf4u6rdFw/8KshD5/mjf7SI482ud00py/UgF8+6fWEtHuuEFoZAa6Or5YLdwzhOseWoahgpn65UH8B7cz6xZ6yumiaWEQXmivmSF+5pNutDaUgdl+y326V05T3C/gpYLoCED8GU1/dODtXlqzv1CqQu8nIvdBiS00Pb3oVIDTAyBZpsi90vL9/RsfC9b9c25GTqqFUj88oMu5KyN76eW/9iEGrGzMNnYNtOQWCGHofRuxf9bLg0BR6R+frUO+AMo7ZGVAzfcrVU2cO4iWV2LNTZyTDNk9SPOn3qmsXFTr9uSP8j8QYh2UO1FPCvq1cWSvVPh0w/lsrPM+FeAggZY5PHFHKxa+ebtJ0wat7Pk194jWbin4ff9MsF9y5oktVp21kRyWmFTjVM+Wrsva2dobrkTqBJXDrfn9nw7/S57joW6c211755nsambxc9P5uKyw5Y0GqJINcg8tb1EQqyCmFd6woDGdAxPpmqxF6eEx5X8p/V2J/7vabmO0HNKoyudxpgCk50RNsqM5TYHcuVe6YCBV74tcstlPtCYHJYS/FHeDtvxIFJ35OZxNwK6Ett2HoO9um0+gbtrCYt8ucNpX3Io3OfKL9zKr6WxXUwwuP4PL1Q+W+T+3JyntysjiS66sKJqan54GoJtzy8hkgknsp+otGN1TMPvZfnQKpwKcHqDvonhfxcpbuHr+wk2zO3L7xb58QmrccsUz4uZ1Bl7pWWZz2i/VkjQHMWa+XJlTsFA8uZXK/EVdB9IhhH1KJG9U1i+uRNvLLwmUgAbqzzlzUJzHf+X0UW7Is3kX6I8bH+1Xy8kwdIH1rsSMEpNE9yjlucQo0cW2P3MqwKkA1X2vZLUUu3ckM6Az9HkzfyWCvTKdM7QsTxZJzAhGGJsmb0Watpfne/XdotC5uaGO7DO/TXzG/ubpKPV9KZ9r6h2IJDRJ5GIlB6K7Dc48a5ZdOPdKMzft02/zlapJtE2fbbsVdmIo99Ur94MzOX2S05QClNVmm7M5byMYLV2eqFzdlfEH4Dz+8QoAuvd3P67RTifaZ3nl53b3s4hpOnbfpR1gNxz+xErTttX8XxlDnVkXCmPO0V3EiwPNGR/K64npnetMfL+Rk0uc/NH0CqC9hhB3uvDIkejD218FLa9IfJ8qVEsWMSB2bxHNDJauYWBf4a5rKExxbYgJV45TAc4ugCuAZvrGJE+cyu8rBiHjU2Nz5140+zKbfVH2UP9eMQvIy61YEtkvh/HO6JG2dd+3asuxy5t6/ODvVobnTfg+2laNs8d2VY+0DUjfQXLSUOkYORt4tBMb7IGea4R0IrPNg7DXFM4rNWI9hrPB5dgBtj3FqQCnAihCv/NFKd5X8vYZJwg2y2pb7K6bKdfsfk7W/8eTuFufvCiRR/x3H2fxyyf5SQxYa0ngoM8+64CiY7BEARn7W57fPVJX23nH7OwH4t7PVAJeeeZHywYGKYl5U1K1EJTO1LVR2jp1IWyA/dKNsElrCsTCGrlWiruyTMcSTwX41ytA7POiW+dcvPLIZG/A2W4eELIVfcNIBh37C2pjpAeKra0Ljt3jyIzcwrk/yaIbiUtIYvX9frXND7PQMyO0Q3JWn4nlm3t6Fq9/Nd+BSTimpK6h6sVqXbrQqxfyHhByN1kb13JlkpKlN0Flo93pUwjSXa+N1xXvYG0Avs5OUtyZrKiHFXweF16TYb8vGE+uMzXbtq7vDNHSAcJBODbks/lU8hZigtl0lmcr7rCvq2+QeWGr9dDdT1udsafJvP36eR3URYR+XhOnrFvRtrye6t1B9UDy1yw9vicun6PuVON0t9XZ9EI8Myh5/4jrf75A8ykbhADohjAscHq65js+aN9YuqzTA5wKsEhTt6fTWNvfA6yS3dMoHlXMlV3943BzJTPn2ZgLofdCnrmFfo28y7uLRuXtKqkTa7t+t65XyDm3u+QsyiZfNPXv2VpoHD9GQoMBsNrzG3mXi2/sK5lXc7MX+Ufsy1KegT2dyba/i3pWnOq8cqZ5ap5kzzYyBRLZby3sGudTAQ4OgKYIlMYf3TcFyI4/9nY8E3wQnlozZwBJFFvSO6g8fpXu7NACdqQv3G0qRaSw+JiqA9HvKGBk98zs9b80nU9w4hlP/Z3nv3yXWTu71bKP7QcCv3KTYtj5gjtO+auXR9uuhBcLe4yYb0TReIeBqhaPeDQm0kr2VXVQpwKcKUC2W4E/naA7H7SFXs57WQ0TZ9caZBbu888v8WQLx1p0UoU4xtVZ3PQ79awE+DHpK3H8NCcQIXW+uoLQHCGfQGP096QuTV1OVQojPbMRBrKoYo7kDXVVsBH+b5TW3LH/8jVnbyOjbQj7LPSqosmPkuw2CjeRpgHnLuU8/uUK8EsvX6579Wk1+r/I5pP8LME9M7venfM5CreXtvnvXAIjZ3sBiMtuhPCDPP7ntm8QQtzr1xSRgzqbRzD3JHWSbUtDj1ngaluOcicSfNp0UcrcuKsFv1JJQI4IjCGqew9MAB/iHitxo42ywMxRj69XNVYmM1ZZzu76YhCfx7/dA1Qirrbuf2QqLVrmduyzhabnkfyzSuZYidR/qFsebSetzUNw5O5e0iU3ZgMhh+zw3rB0xeQqIuTFa/SpV3Ik7/ob+CQykuv3Jxm/wREyf5UrdwWxu/xLUzqyDi7a9TFHStpZB9ilKaaG0DCz50htMB5MkxPUH20X6x3tB77L+5CjCziPRxtYd3o5csSnvhJuw5kW6Yf9pFav3CqFshjEnzXaUN3NiZ9nZNvw9oVSwagjDB/PH0Pj3ZkzjzW9QfesLDT8e/+9uN9jzrgdtVRPTlDyK5DmJWBZOa9N31RnLTg5s/EPjJSGzzO+s1bCf336O2++oVTq82VLBpDXFNBZhXz+2c39+ASeR2gD5zZT8oa6Juya00uhN/3E35muOemenZ6rJZsj755zL+1UWN7VwdRfvu9nDrKQPuZO1H0RbqG40nMv0EhtnppRjQZhZdOf+XSXIiE0vW8AJniG+j1JRT3seuRCJm4IBH8wAO+2Pqn9C93FIrcUyaoavUU4/rL7V5/eqrOovijeg1MB/vUKMEkvtgjBq/QM1pqt3Hk9J2KgFOyWvbGQMx0IQZjtdEzKILStHuiWhDdyxq65d1H/PLwLty3xY2Y1QZ5ny7yftemLQcwkpGeK5b70RqnyNLuC6nzqGWoikZpeiAMgXHFtddBe+uEJZh1KcwkYLYd0AbTvx2vvIJToBspWnGcKOI/roo4/knBn9qpK8yr307FHn9kDPCfySs1s3dN3cmaN0D2hNFueDSQzv9EQ+UKx4ms0NwCRQlhTe7kPSWZ6hvJpJlcRm0uQ0X6vmIRovVGhAtZOV2WFVNbClzhQxf6b+GYVEPSMwcIw7cfMUrrrrp7Q5l1Qk75mPV3U+/SvPBXg4ACcLN155oXlYfPnAqnyNROGy9l6UiUB/mTWFXcP+za9dyPacv3uRLRrVghegpLSqLx36kzaf0kGYOeBON3dEUFyh3ejXLfYp1Ne/GNpeefhT6BtSlDiQY3GErJ0EN17+aqBVSe0sS9LC8S+hpw9zG6C4Qt3KsDBATi1j5mqE8WwY87Q2tx9u2NlTxnkaVg3htFwNy1t6SRKzn7VmQf3f7XzidY99AzROt2W2kVNDpMCpDtmnKycxyNdu+8Yq7aUauHZmIS7ouXcwAwE5B6P+QC8iZ2p+w9lwACaKxGotglpg5TcCJDcIWv8DQW7i6xkUJ0K8K9XAG0nqrBmfbkBWHpdVgrY2lzzQM7Ca1P8W0OmKutypt/w4+g9E+PTvOc4L3uRGxka+h736qSUY1A3v+j2r05eNyZunfLpW77O90Ge3PITKoXi8uRjyd+9fZNZU4zQ+awEgq72jb+XXaFpiQVqPq/uEzpSB1CuieVQ3rNcTwU4FYAV6pFBY1vSV+2yJfV5cY+DNtLWdLPWNLW6aQvQas7wjkBRFYl1hzXPSvMmKEUCp5nx1F5JnnVvWvP4XpvL79tvazVMIirYpBSe6pS0ZSBJw98WOKdAyGe9Xo019HSkr9rMyozGq3ze37ulj4BcCuOnPc/nwsTt7/J9tIHnAVwgjG813EkB2i0v9Cy83VEfrywxbV+z8m6WF47FfsT1lb1SWPr4PL6cH9Llq/PmCm0rFtBKzJ65S6u5cU5IMvc6hg6wS8pq20bmJCr+kjOHknZAweq/RbiqohKPajfCzj94IfuMARZmyd4f5gqMj2sph9epQVsdpY7jVIDTA7DvRM/FsEToroYRWna64fatLcfHXv3ybF25tmSNPQWkOKt4ncryBsNrvrCWNljKpccPY/gNqA1PE9+BKLkZI29+zjLT5NP0nV306Ve6+YDuc9C0URVWtwS14k4tqngdn7TNlaF+Buetg/IN6m/vJt+m5fueeF9PBTgVgJnjzADYuXp8H410mi/3rOHKgEmf+0cp/wdX9ps1YSixednzBj+cwniG/ZWxC/pOQn754bVZ27mV7FpGJgb+41Xt3t6HYvZqq0flXMqTdU/mfb8O26af6O4l1cVGKgDQXpBZUkI+Re9MVXXdvzlrcyZeKV7JB339qQD/egUoRxzdfKbZHW+2+XQ6P2a4HthSDz8guKD4myzhK7kBjCsa6fjXhuxbngzbvg7khCMNV+jTfahzpWEI0TGvdpbFWb1XKgOChbtSB1H4wNz6g1IATaAphxexDkK7zJrHmn80Nx2BhVRK28iN4pV43iDP1FAMTPJWuXzGv2EQfFMLZcmbVkJKTwX41yvAaNPr8GoA8s+oFI3inGtOBoW0D9LeG7GICy2fmZz5K60Q7TxjQ/p5eyfk8j1TCVTe/OuFIdQ2Yb2Sz6uHCDbR8tuxNoiaNTJmhdn2FeuHCidu6wn8yPUMjt7KmhrMoeriq5fpqEnVlcBNGRsdUOcvYENFkcwNS9bxqQD/egVgf4li/kt631cPvpoPNzZ9O9+qaKhhpIqOROwZ3erzBzuM9S66OmPduEpGuTpCXj2z5ZMI5e2gsWetOYNYy+GtXbolix+p15G2OeAuxsg/VZtWaZHjf99GCKH7RlPN/rDW8+h21pmhyLyIkfmq7FF8lEGnAoBUaY8O50oe76JPf+WFa8OglBgo/WQpuW3OxAGLkzK9r10/7kdNL8vZbtT6jI/sMMqNyJobqLS9ReUO3i+Xn2e7IHkaV3Y1i1g0oRuqVALWNA2wPyh/50WnHOkDKLS/rFrK78AvtKP7CIEyErsfayH+kkgmP+8HxxmnBziPqzPjBwxfoKUGP5/5+FXF13vvAcXfdi4L4QNxbi6fq6e7XlTxeWrJvblko7mEcHXYkbRJ+wFx3GtQpSm8bRF77/14UkU+5MVZ7gcjE8GKW1teBaU3XGCnzqiBAsud3NNHzeTsc9bP2voO0Oaf3wPJVCJQ7gpPNYtUhewTaE31cDvueXCAUwFAZ3/lqS31Gk/jkcg30nGqe/6aq3ilaYpt2yPwxnu2adtemYK9vzXqwcPJY+WsDYR+IPI55g8NvWwoIN/xjJoHD2rQCXpO2L3h+dZmFLSM7nD+mLQr6M+CMwi4w5L27llDUTmh7GFxzXQE7LsS+aF10IbMngpwcIBfD07N6WozpBOQbDga82vZSUNSz265+2Ie4UwcEvlpnp4MYpsev3I6lOqVktZwkcN+9ef9fq0E0NlUzZ0P+CACX/+30d4boVOHRBH69IGGP1RqoqVieNGzmzkfLJqfVsNJn2d9+3e5snJHpkhll46t31nJZhT6c+tUgPO4ygVn5C0+27nH6x7tk6fR7Fu3Ne+z1buGPwD53MXeer4wf8usrjql6qjVs7f7Ut9dSP5vx8/VNEDFxp8/akNtEoymenYGsU3f0BkKSglmkpMC0ifk9o5ltr5/wZzBNz150BK1qJrTEVM4Xruzr4wmjL67vAlhrKp3KsCZAuJTXgl9IzXwoOSZN0un34lVDYxcBSU1/9UjVxqnvBIAlbCEkS42lcqtL7asJGd5RwsDM+SO4CJUcdFrY12PNYYN0gMBLVmg9iHsLFpYvG3oXvkC7j3+SNWFkMPX2zXA0jVkkd+PoacdCu5MdqyM0jvTx3vFOBXgVADu50feG312tvZvkXqlzedD6RRyTbgRitXO8rHU/g/C7Y2UMosY7/3244wg83l99wwO5G5k/60wfDIbCOl4zrsyft2LPDVtm+GL9Vf83pVq/0Xov22TftTMT7orK/kyFQ+j+hHN/618ospPZu3iyD0OMwBmIpgLIP/gows4D1yfnDyxuWgX+nVRAvbKGfOZSJVwvcDPFmEBccdd1AcMwsj+JtKupCYEKgNDSFdXs4qRZwlw4S/+J3ODlJxCLD/rUYtmm1Divr7TfzhOyGj3djybiQv/wR8/f08XPRyFVEz8Idek6K6+/t59vfOefto/riQQfJzF+Mk683CSvqknMmcrTddD/U+yDEemC4vvNWMLMNMf0fCf3BvM9GBeZwo4j+vrmPloSFnX5y3vv5FTJDYk8LnLQ38ymwp+paNonLwPdfDFuOnetiPzg6T5aivKTaT3B6Wj7dNKzezBXA5k7oMvrnQ3+2Rlm+RZUmnDK50D69c5oYwTuiIxUFvFq51r1yZJc1aLxETOWGSsQdoeQinvQNNJ6Mo9wVNJbvxJTKQmh+MUeh64YvMd/PJyBeN5f2wbOtu2a8/nzJInsDYvCiMfLKFNt5KHBc/R8uIEc4f/MPlH7tbLW+9h7ExCAlnjX2k70QUzV/jruOMkTA2ZwgVCEcMFWZx9e6XbSTzDm3yElTKFr3T258lGiDVkQMso3NMDg31g2XfUtDC9448t5iKPUKXXXe/1YQSdCmCZB84+8pOm/ZjVB7Dx1NcLS+f+nTsK9h2rbUFgeMx9seaJy/vwtbkAIvN9JD3wLlLWSOJs3A8sOoHskLxzD2Jfx8npkqdLU+NYWzZz1lPlioeGYm5diyZib/lu9coASgpknuAiTKDciYtNIaTekI0xrM0zSQgZPY9/uwdAukZG9rW0zI7pd1dwgEcy9rR1voXldQ398vM+6T6M8yiUpAH61Qv3yy9XaUL5i0/eu2/2PP9UPi3vfUVtPxf1DJZYeuf1M7qgpHL64zevEDdBgObEMYgXIK0PielF2ysVdzOoimCuvCwvc/O/mZH7/pj6y5FsUNIwmkeznPTw80hW8CJNXu+gIy8IxCvvCcD16dKtYwdYiVI3qebOQImFt7OCOxrPnsULf9InX9MH4KbZQ72m3TB83MEn0PK1qZzQOHwxT39Jo9uZAoyYrtzuz/zeXQcdU/ek82w0HdRssrLzmW0zuXddkzQRyxHM2BI+e38ADeVUcoG27W/nVICzC2BVreape3uGSSLJdU7RPu3lDhhsvEkambqZCkMbmYg1U0vb00MKS1Ny6P0/+EOzd20cmAnQFcFRp4a7+K9EIIpThJYEYLSxsFff3jPM9+SP5YznSXxDeWWD181tjaUc0/rdUpNAd/3MaY0TRQDWTq9UHHVMx9q281SAswuIm0ebkq2nTbFvZe/54/Tu+nilZJ5dQzxyhl8+gVzb15UP9pe62kmfemz6n1IO90zufcKfhPJZcwsyehWSnoPSPPr5JEn+7uWbxjrnF8Q3/kiM73YHFZDTzy/GxfM6ivPLaitOBYhuZaST+vP6tOWG8mxlG3YrZwo4jwv0eX8+/V+Y5/z+Stno8zp390ZJ3935r+drrKZGvGl6rs9tZRSNzO1SVDrOx3/W2hIOV5tM9NWl9OQTy5ufHYeen/0/UN84fIGW9CnEfoos4NXSSUIHMYln+WghmVfdcYOOM2jykBZA3IfuagzsWSBPiqqRs3vVR3vhqocRdB64Ps4WHQBN22PD+f+7Wu/hnKn38pXbHdoapd0AI+ErVXVKSbf7wzaMIfZkX//32zHK9epyNbfwF2kY47TMPH212w8OsxFXaOXp1pZ5Li1VpE/poNzwYvRJ7j/XS+VfDsfly1TpYyCEJvYzqzmbz9a/FNu5ppvyeNn/Pk8F+NcrwGyZdjVbsxId9ClkdHvlPo55O8F4KQbNyM/55ViBOVp3J9NA0f165itPsPQ9w286+PZv73qNsLDlTMDqASalC1QuUr1C9joR7PpcpfoW788NTgJH1ree2stsJ0HnKvVcj3h3I49htsQ2SU8wy6S2qjG27TsjFXq1vqHeqVMBzhRQm6uZiVXa7mB5cXYqZ7t8Kvh0KKlfJt2Q/SQsmqi/7RSGhy5afzxphkZL4NHk/vcuGyjVY5zgSXPM3nHYtgWZeb6CKbicRWP5388z/R9MfMhdSbeJpPKJPvmuVbbwpD9tqQ9Y/pPXixcl7RVUnVLiHc5tH3Enw9poj3MqwL9eAXjDFTfQx7fO2s7ozL69M2AX9eecqLG2nQFj1cExWs0pB685A8Sur0+1IhyOJ2mAvw1fq4n52vBJeyED3beff0/8hEp2N5PqGwB8cKVf6ddxjeAFhkPaykoU+47gBsS8NRFeTIu8xtndrDqJmZUBuReo2//NLSouFjOvomqcCvCvV4DKAR903qf3yDNVQeU6ZYlBz1TZmjvUo93ujJnPhsNJcoy6GuCNB7B3ebECb1f03e2nYqs5SipCTuTqer1flac2ADUNFK9Y2t5CaHfKysnlTAiljGXmANz5TL7J7enPo+rMyq3oaBWza4k5ddjS1zSQSfZnslRZnwrwr1eAmsK1KVfM1X+aKFlgfJIbfctP6Wq3uPpEP1vq/WqdNs+sfYu46J6v/6puWvIZip8ayW65+mjGzsqvW9pzGOjMZiW2w6KkgHAZEPIVUHJE5+0iiMEklAKy0hG8dx2SbKtFnICqJrM5lMiGuwSqMAkNrfyRyHtdyZYQynM86uDzQGYHA6EfifN5I/Ksy31jorZYixR+1u4k9ssrfPDeHEXLy2Y1351i2qv33ZZZuIOw8bqt1zZDKD6+CRs+d1+ubrxxuWf50/F8UpW/8gaNZxcI22jdNAhx6+mG1t4FdVZi+QjalpJe33WkFrCjB0q9xswtwt2y2Wa6hq32jkSeQfCuds4XCJs9j38dB0B+NgwzdfJ35m9FuvfI1JBFbpXcSXY0S163Oqv/zTtlvvHqhlqZql1322znUxMr161LMPcJ6PuzZ17++rT+qPcWvulOwrOMkS9BaaVWJhxN3wuu5rTekwVZC8RZbLwF2LNXlWaP4kYpuY1JIpnqWxG0LENpLmHxPe5kESq+ub/FmQLOw13CpPnjqONnxYVTchKzdKnRxnDhZMvKrFFy2HpP+NJQ7d/Z4uI+F4Ly4Hm2gJ+sEka+WaAM3+G3/Wx3d/28K2vJdDVSKZsHsJ1TbXN38IAG6Y0HYSCBykU9u3ODcuWuRWj/+HyPm2plnOW5VUjuRIDiDV55/pW2EZHcFtNIeSQcp9Dz4A9AsGEGPsmajxN2eU7wF0h9upBPP1JNOAgfiM8qb7btdTNi2xMgTzUjDUYnUdyFJG5hVvQIsWNLgRBM3e+2J6g8Tn4O1uYM3TBG86ThSAoYyS5a3vcXDjmg+Hpy8Uhm48en82cuQZ5Mwx/8TdxkZcbSIF51VLPHLfWZHu7Nw23mzqR0gpHzHNuRmZkspwKcClBdZmjYVu68kFodozRMacz0mFGF+tf5cuwsP8+dlyYvF338ZPkhnYY6h9eIK28bdx+EuxWeoXmmasfXdwKWr2c1tEOJtcS9gfpMoZRewO4/kaP8nOd7Y+YWV+kXq5rz2APTnNQbGFWRrmyqZICRmCHcRSGmnFMBTgVY2U0+n7lPTgKsVTWfDIR4taAOtlyzJoqDN+nuZt4wnzVNZSzftX1esJbPzdtuSaZNRx3khxb2nRca+t7OGJLsWRhfrJweaZ5l5ifpfjkpgbQTljppTZRemmsqSIXI+qZ6DYOwl5F1W7ev6CqM+XpPjRLSzxRwKsBK/P6LYKBeyUNlt4/ln/FFd1x130L434Xy+wYlZ638Ewreyct2n8Z3jzyBvlWoDV156pazrpG370iPo9LHCzFniqm3Xtk93I1I+gzazyqCxosufxUjv4LI7NWt75D8E7MlHNQuFWD/MWQ1XZRJXt+plJxA+Qlw3kDvbE4F+NcrQGHQw/v5K7WmhT8v6iIvoKn7WDlbiKKmg6ZRbwDUdhzERi7nf+6vl6t/Bn3Ol28kag5YiIywQhjVZ9zbb97wBlfqeMoXvc8A2k525QHe2aVPQvVk6y+MsjsXncSV3cvVPAxAeMdqzAh2DxvJ7wehK0ZspD0ZTVpHw8zhkxl0HlwB+g1plL0leVN2hv3KX+Vul93tuQsvPmD44o/XXdXVAp0h+LB+ruQoKSq7LxTJ0pQxQjenUUpY+RuU974k1yeUvGvT0Qs5kgdyONKTZFCvPv00FnK5srpovqNCqSTWOieuVYVfgtybGIP4Uu5QdRHTWROW9beQltXmEztTwHkAwPVg1B//pH5p5xen9s5P0WindG0ZPUgfesbfbOs9jRJKkbfRzgaOjZtkjuBTeT4t1Rjtey56DtyXyIbvly/vyvwdo2fcHTXRkkGiF2BH5efrPsQIqJt2NFeE3SmIz7fkDIbkH4Y7gb6mJf5egyrsyHdTiGFQGEU5LhmAv6cCnMe1qKuNfw50h6Dq3bk/KFR6/XDL6v49mnOBputH3bDsC6gNFR/pZLyyh+8ZeiAn8vivtaGCaP6k7DzYK9VsnfLDLNS25Tff5mnm7wSnsBjK6pVUvF+IDkKSn8AMKW1YXVcnrrahfO9I5LX3sFYV4V3BN7mE4WZY/cSpAKcHCCS7fC96Z2veIe/Zf/jpcyUNher3KPvWsi9OqQZ0Sy0udQxrZM2TeaTd+pziC6ovgc11HC8Yxwo0veCiXTlvMmvi7ju3QgiBnkNUnohINkR93WjzUmzyBnVQi96nSk3vk1LPCkdDUdD6NfVuLv6Gb+d4ngrwr1eAm9QmMW2W593YNKW9L+idfM8ZnNg5NsGPG+3GUsLLGE+QltWzKDE0sDHduDv7518bDgdSJ6Ld+dLw/PJJefR7V6rsFj4wLHyd0zd9LlJKJuUKxFsFQ+fxIT3OLB3Lu2NzxzTY4Z/RQ55S3qmglu4G5p2AkM7jexJDziObwPCMu/0Xi5cvDefud/fM3bw1BczcbnD+TpI9NaPkjP8zRqjpRDLbXf3NLV2g3T2XE+lSFPwm1vx17NxyC8IZX7E7KD/Q5c6fHyx6h7Sddf2hdgQ48+zeUlRCjdVxUEkfj/79dr6TkX8akqfMM8X02jISGbxbZvOpAP96Bdh9/wKRql59UQrGUyfqvx6/Ln11n+F705HDvYOwLV1s7yuMbm0+sZWga3RfsxpGaRtvlGFqdK4K6+9dvbUphd2Lv9ThlHOpuKaIb+i+73srfyUTQflnormtC3mrjG3SsVfVQ1av0SqSuNbh49vLUDWFO8upAP96BfgC5J8X6r6bzttsk7hRmk+hBYvmYaFbaefvIl0yYqYelGQNOiXddXC9vG2CA/c7Q3S1bcGi2zKUOhdKkxevVOkOVjqp3Vm8Y52cGSA/EwQAbHwfa5rm4lxoMnWNXL+jEqj3NNwp9NmH/UDYA/rZn8ascqc/8jwV4Dyuj+NQ4frDfXCpyfpjpV+AttM5SUmwNvXrDbStW3e+qn5gtJmZk0dvShuK7eQinCye28j9QDybctwf3vlO4jxpQydX+pDHzFBq3MtvzUV9jXiv/b9eB0e6BWvOQEZMfbRsspFoxdj4EYP4kUY1IqrYaHPVdGTxdr+B8GeVVDgM6khG9gdHF3AqALY+FABp7xnPr7t6pM/HaOkfmni2tDSuYBJ+CQksRnDxYuWFfpV38SR3ouqiOxY40hW0VMOjbQjiFn4cPcOvoJy46l1Q8jSyZAI8XIZJzMHID/3PCwcsH+L+vUC+Z7VJ/XqXMtsMz13RIH+Q6sBCE3GDOUtryxiQH73LwQHOA54d3NHsUujOF75eGn2jGxB+Pi7Hz43SQziVRghvi/trIBQDkWdfG4Plne/HOQiDegbO0MGrO5ct96zvDJTwzf9xjXGkDf4lto96B2GEOvTpItj+7wlBGye41ItC70P0/3dqHAchk4Uh7nkA+5SxqPpI1p7uiWBN77wa0/E8/m0kcCTu9ijo7f/nS4xOs5AT7YWP9+asHNLccCtNA0InYxKqvfxT/PhhPbXoTi7Ol3p3TsbgiWHis3XvPDl33PC5e8Or++kLOKODU9RKL1lzkWZ3vm9IreWcFtNqUm/QXUJKWblvOVd2ALtWi5kC+64jENP5Q+dUfdrhA5wKgBeSptlNr40hX+59PXOqa1qUXLAtXbg0s7h5p8/pRNJwueG+5dO7DkuurLWUT8YHH2+DGwsLX+/a0XaT14+OYLU9ACeLF5L+dv6Xhuex63FPSIoKq/5e3PkcBp32ehU9rYk5mdawjtmYD+yBHA4pi3Yh9iP50A4f4DwoN5AzM2f2k9Y2UM8N883PZJyt20/s9L1Y17KuRA6MJtPuymGk0g2PXPP733KmXS8+MF4ovdKJuID06twnEckpZoF1fcCuDmafkn1zr5uiaudFX6nSAdUHSdxjJeOANxKyafwBdi5/u40GwqiU39K/UlpWInsWngpwcICZmPo3N2acpCsvDy/kLYbECEdu3W5SxoE2AOKMFUPtH1mB0PM8dePwrrxJ58ttt05CsXl462/EeK4TJHR2hNSEkhvFSV6paNhdbQLeTiTyyhhG2wRq9iIjvXuYwWi0Q7WtZ2GtY38HLPFUpV/vmazSMMCTG3geDw5wAa4LKN+YcrQa5OovOUuyiv3pbi/v2bvDdVfjan4eLc+gbkkdQmfj2X59kxeA9C6c9Bm3rWceW19v7X7fE72Yh7ua+vFqeUVoXYhtXCehysEcybmpqCITNJQAxV5gXiTnnIC0xF39UB3+QnVyM7NUihXQ/YO5PzsV4FSAmZ/+6pe/rg24Xym3Bk63qB68O38aoVvit6n6fF7qdyMHEf6ukVb0dBMjv3Z6bZq5A1hbAthK/70F/MwDrRMGcuUD3atGbD3Leb2SyqvurFT3CPUa1nyRNVMHb9TmcSaXQdKVODiWd1P/6ZZ0MigteBLHwQgRrHdBE0msV8YJw4cTeB64PtlfF4I1UDmCvd8ubqpsnW59+t+bL0t/jwlm0Ot2RpF+xd2RL3x4+83NzjmafjfhwzX8pOyvIBCy3ZPENv9zyxrV3ZAquVebiw9QXuKa/xvcaKH945O18vE62VVVlQEYmQN32y2YbwdjkghOT1dNWHqACm1Bes9zMoPOoyOB1X2+7/lFXDZLv0/kr1by7UwU4SJGTt9rPSdhbOh5n+jRbr7SBpUWv/w06nz09LG5pZ8ik/ykORnjhfXLi3WI/zKP20vxt+gZzZeOeAFtVmAF8wKIlxDMAKOJqTaIzIbsuOR4ZaRJ1qbaXAan+riFnwogibmV5j+23pM+L+K/El5WI2/fQR1x8WLVz6di4fJ7qjLCJ25nqC/KB1wtMbzcxYono45MBJpejDuj9AK4IlCA125t7/u15RoqKZWMMr7H5rFnW+JpoXEDnCtSmGn5/SsxllbuXatCxD5T0gds5owW25Ivdfazqat+IYXs9Fb+D08/cirA2QXEZCkoZb6Rdr7P17ah1jMdhp4zOtPRexEWLQ2dC7bald2wULKe5V5c0ouHNTo11y7C12W7n2d2HfVpf7Sx5vx53V7z7nwg5D3MN/ncvEX7n56EONT3lVcWmJB/OFoXZFRp2P+7OhQDmsIC6Ty0Xlg/aAuxWjWaxyn0PDI7+BkIbLstpTF9dt+w3t9Wv6nJrOdtOnuBCf37/NHPWsvt1pw2lPg31pQLtUOLXI/w574IU1ueh/SB4g/g6ptJr4u9iueP/Scanq65CVnpR3ChnASKZSDZBXFSKvOW/5uvEuMskjlCoRREdm9CU8C+MzS8vYTPLuA84gMgryndUudT+j1NR5u7uQGjzQkKUHJv+QCOvH3i03qR7mA0Vo/QHgF0f5UqYJH+p7oMo/6kPEuD23CT3n55ZuhM5H7l9n8lW9+8ZxB8ffKQNo3HM/jm9yyO1POTZ07li9hHIK7FBCjXm92UfzmKYquphW4IbTj2Ocf+i8L5+XmnApwKYO2ksVO/bBkX2rzq9k5A0gd4vu5W2XrnyCFazpoDVRzJyXxu+37Q1xePkCeLUPyVZqhuRyNWwdhSx9QZwIN6gMgQH/hDKts6hYGrfbyWWdtxhCpBqffvCSTy6p4A1jEYuo+ovLyUQDPDWwModPdrbjHQGAqnBzgVYJInx+5R273l5YcK7xfCJm1vXryW0VL9hJJskR25NVUxkiFr7b8kcQYQIrfIC5O7iK4NWIRugvjNQp2AveboODlKyEAwGr+5k4zp5usVr3r6md07azC1cSgKCywe0v4n7Of0Vc5CoSUc1LXBK601zWb8PZwKcHoApNtl7dlXu5sGzZ7F6bfNGw95moy8xc35xg/DJ5LAb0fNjDIDh7NcKiVspYfu2j79A/BNgiI0QeXLv14nRQkxVKpC2pRAlXRULLzyQLuyL9BXGjq7J5fb+qC9CXKrUU7omkrIeCW3c7EsWdbffE511m275aX5uCh1bt2TTZrGK1xPzuNf3wXAZ9bKux+0Z1c6IeuFUdXdMxvfrE7XU0+uvO9DmfPHfyLXj0F+Hexhw9y7mWdW3acQLa37+fcbn5c/r2bXwCj/JCQi7uBF+AJI/9Qdyc1fwYXufMguQCORhsLslVi8MSnUu1VpCtY0lbZlLbLb8J1qiXI9/OJDrMCHWfR1B7JFjmmnApxdQHzuLmergjLCR56cRQmdSp9w9TM4Uleo9PmqLtg29OrOarM2L63SvzHmMAmvN1wwfJvnVvGSIneTtwZCTltCPl/Ml+NM47HliyCfqeU0z9PLohu4PAsUnd3L+ebSELqepizkCbbaDT8IozVKaJwY6QUQXoPsY3DlV1+eDH96gPOIHoBxYt5JCSVz795UK/9r0S1XuXvTp1HkXfpWtfUE0dXQKsOFkfVIE6OLnnrkjB3JoyvVtrtqeFJO5qI5pc76x3/2yh184ZGTPE5qLrJUDK4NqS+0b/3ICDfqU0D8BtYVoOEPa0NZZm4Tka8aDd+7iFscvgmamqGuZTyMoFMBmGG/sO+iS8HT+SzIRNBB+d2Se4AHYpDU8klzuF+0ORi+pwf5AsQ2frkzP9zJa9F2DYkZ9Jl/ZZLBagxdcYeiSPUR+r2VqmPb3LTqrkQ6qpYDWOWhIbGN/jyeZ35Td7NeqR+8ZagEguVzx01ahYEvaamAUlhN9//es4mCRSDkSMr+gmcbeCoAo3eWSpxirj438CcngcjLC858ee2uTdNuDUe3lorHp3O5Ik5SHaPOiJ35Z6ZPskauPDORbENxBAqZk0TiNPGGUOSNl2dO+fgulOuR0vwyvVKJc3snOYqvlj3UFULwKld9QPiE1bzzKy9hee/DGJ+CfUmiO9KcNz5Avps8I0n2O2vDbk8F+NcrwNp86Yzu1UnnIdi/facsyUir248V9CPvVp7uC+8bfkKu5CbX7DqcOXzn/Ds2JR4oY0xzUl8/E8WY96R0Dy7SzkfG+GwVTFpSkvmkUgnCT23SVC1UvnpP/yrMfpIKCC++byGKT07x2lx/WH1UXcDyxFL1bPXp75/QrvCmCnQyg84jKkDhdLFRu5OvFndiqHfWD45vd8j85XKJbU/w/Mokj83bJ4rVnLkM2FBFNCcC2Ri7tu0wqhJpnvN9d4nmDLbnD/Uehv1+YhdhzXVXSVcY3iszc8X7Tw3vQCTfKqaGy/8m/iSnmZlNnDxc70ft/+XHVGSJvir9jjYn5/P4NyvA5Z/k2c4M64D4VvpvD81sOmx9APPa1+b0t7LTkJwI4Ch/Of08EzH/940BwRefZOhYIgbSErTXhs53j21WIKxt4g8s8JNOf5rofvkXRf8x6b4t356VqWvftolcnkj63MdPhu+dz+RuKu1wFpXsv5S6gtD8zpc62ppfuHhFMfINigp1Hv92BVDCiiKPU9O7BtnfzlYJasNnOS0/Z+iLq2VZat7jSjxXziQe/qtjy+qqPxtY5XN+P74N/GDkJoy9DNbmpCm5JZfUGa9E/6VVrMIolXAKzdtUW+2KqXo6d2cQYl94JHcxt3c/5YpeHKZIUlmNpd0rSucjIKtfvdZBO0IQNjIoP7H8CQ4SeCrAIA0Nb7LnxiXr3jkCtPxNTX3KSKediXL5QUOn3//cfeyqb+j6OUudsb2QR3YyWa0/mdmjWGP1RHWqTeYA54UxY882R0J+D1ifBxSbXzbu8VsLYC3Pq1z8S0WgjdkvDQlASxpA7gOK+7sIpXw6jmAGBLZyKsC/XgG+5Jjd2TXwHhXNdWZnvxnNpuUL3NVD1qaLuk/vPAmRYtn//KL7rjKMo+ONz/Kdt51uzr+VPbwo7fzhED8pWzf1K113N/LeVAg++LYELtkcyitf8aL+QYhTXG4pgOLru1KuBSMRh+rpy79x0XddVH/rXtcf2Ii1JFbOFoqt6qkA/3oF2Kfi/vmOW9ISleuTtDQNOvcMkz6VnFtVG4eJYsPM5OiKz9RKmYGxRRj+hNltTGn3hsw5EdIXFLrId/G1ZRn17SUrlCN/yAjvqF0io5bsjG7JGOicqupidEv8iB5l5PZSKEuAc9BGSzba/dZ3l/TeVwXXMLqMUwFOBWD/Hfa7ncmqK68go0+7Ug7maL1tx9q5A5aGwK/mEbhadkal9k1wmkZXtg3yOLZtA/fWLhndtY/C50rnrbfLv5BOT9pzXanQKU4SJygin+0ifLB7rLy11XyKWeNcdfjKruhDXYak61f3CtuzxbFV46cungpwKkB0l4OygYGJP5v/pmSimNFebd/77afvmSSqe0dWk5GOAIHKoaXdBlZujvZN8iwKBf7Ms2KUsVOf6uH3ffiBBmZY6QW1C6y+epKjOcDpBkKO26GcqJ1AP5GlX4o9amdOWEtTLxSznE7qZ9x5np+Kc+fP+PrMtvz3lDYJUccF+37Tsns5FeBfrwD2g3u+2ie0awLYpW/mab5et0+4bD6alUoSjD/xQc/wrT6/fEks/YTCP1foFAipcFfqAqZvE1fDzLtrIO/9Oa+7oxXFuTdy+5vk4BObhY7hL9IhTCDZxuJKQSOF3+/TWSyJgdu1PObuBcXKnrTrQPqjD6q73IutbVaIv4tTAf71CrC7ZRTeJz96Ss7TwJahyxWkXMTL1bt+VTdWy57Bg593FjJnr86wpG9ZnYzVJo/KQ2HHId4BVgfye5KpnZslZ2nmRnHld1FCEBdK0/z1RCYlr27Zun6hfULnT/YdCnMNlbAAI4xBW05DeRZMsDf55b3KqQCnBwiHm+WMfCOWe/cK0vY5rmohtP/qXtma3D+QK3nlfwS77qZ7qZgsu5qI/fuF0IiOqdcGDy1pU2lTUZ79APvyx+a/cng0XU161atc8PAX0jyl4UA60pdUEn8TUjDq669jZpdRnKyqhTed/Ek6fwFz/8oBYaZj6p18q5l7hUdPdCrA6QGKa7r3jdxvc89avvWyaU+QZwjU5b+ze+G6HWuY3n7rcuI9dxeGSSx5EFMPWV0sHThXun5Kcy5RZxtODPz1ihCana+rhuFzjELdZ7zue6OkhModMU8ut0Q5Is1PM0nBEiFgh4DuyyTtBsfGKa7fR+NCDZqnJJ1HFFf2AA/7U1NXfSrAQQI7E4fZLHVHfRJBG9kLGG0OhVLBC5Ue3n1Xvgd7V/YbbmL3st09C+OzPTfOf+z578QHjRI4xE+2kGP+QvkWXMAru1TQmX/Pd7ydNVk+KO/UgIWeHijOO+DnipyEehr5rmZiLZI1lsOvuR7k0h7zw6A5qLygrDkengpwpgD+tPXP8Gr+YA9HXVAq/vqM3i2vktFtxgVWIlqaqn/GA3oO36I9W78Hq4+Q5CMH3seuYKU4kFfPrduEje139/SQkbqafk+D5oxy5tNkDMd9v1qPxBsPEMrxeBiMfNcGeKs/KF9pUP1RykMD+Y0ZzWnxHXTTd5wKcKYApO53bp9vaScTeXvZ1puWi4gSS8g2RV9sBIL1Mr3Dvr0ffvxsZeMmwdN9uAvonN/q76V5YA6/pTmNgBl65dhbDBxOSQKlfqzMACx//8IaNRmJ4RhyU2ULFL8q4qRNoDb09fn+Qg6B6t93ZXdlr16tqm0wpJh7tTYmtbXNxakAZwpQ954Jj4nZ7rqYeNWngXDknLQ3r52Y4ZPzLrtfxZwq3geEA1AoXjhpQ8hbszxIp7ODFiZu/EkF0CKVklBvojlj9HtaUyFf2UWr9SloKYiWXyvkzSFbus8kdeMkz5TRfBQGdTPS+hJpWWGSSsArMwvU/25q7z+yprF78MzfWe1V80zHGQunApwKsPLWCQUvaNM/SX+LvA8Xqfae839vjvcTeHWcsqGCz019Y0/DENTeqr5H7RzHS2FT6oAFEO+2EDqlm5+5eZrnhpN7uvcY1zJrm8OqQZa+iNZ8hXiqWMQblKY1spZsULf3TW4gxbSeVDVX01tIei28E6B+dRwHBzgV4LlZZ6pQbr+HtbnXsV/XoI073+uLFLXFR9Ntqwdiwq3k/YFQr/4w1wCP9AgtNHy83EmU8Ii99uyqQUsV1GjpoJauY4vO96JzyyikgX2+LKeRch5bLedEHRsUykJgDb9s7+4736RPREqvPWryxzeHQDGFxJObNZPRcNLDz8P9AbS5R7M6jr32+TZDu8k6kw10g+//JkBzxSymLDODgV0L35lBAHsQV85AIQeLWIFCtWflfICWG9YRhMhM0HTe7QlcRi6chZTWM5pbuu/ttaq8D6ejFIu4j/wO845TWmXsnOKZiidxr3dmI1pyEKYzollReHCA84Czgm/URvrekGTQyeQu1ZoiTrI33514hHLv5cUMAPrOjxlya+sF6idU/h9S6zZpLt5nCE3f47FVMWxsP6FOpjYK1nyMld6Nd2LaIL8gbH/Ckj1VHKdFnUmhCgY0LhWIWaAolmJsTzghbWVd6ZqkyhULbfZRB58HLvVPS8z1pZy7yZdn5Oft+YxfOefXxq7mYHYPXdQj2KZZG6ll0XZv796DmmjgaqiEphfXp6Fxe+UAIej7TxCqFgreNMZXqOt2P/6nP5mwBNpBTK9D1u5YbWebcZK+41SqVpPwemReMajH+vpPXK+aauROLOQKNLJGF2fjcSI/FeAggdZ4/bNlCf+apNFc9cLhrhw7xDeLTy99EbbOyaGa7sP1k9br5PYdN28hNd3vy/9GmttJddV1+o3OePf1A9CcAPjEcnbHw/FhzMMyxcDIN6W4utK4kUpuhkaYBjZOYK+V2t7hPz7rvzuQ6nLCJ908p1HbK5XkWp4KcCpAuFeyr7Umt04yra948MV/7bz1wqYX9bPBikV2FG99vP64tzu+h4a/8e3N/xYs/vLLZwZdZXLW3fl/USZa5Q5JnpgLk3RAtnGF3ond+7PUxkaefhtbbgfY4dfcHV3z7+Jy1sSi/uQi/9NKO6/aLMS4QiIVjMny8zsV4FSA4YhXdZLP5+qGZd/4IMmSSSHlJaAvbTGwqwslt3S/7ngl7iFv4djDv7iJ7FjyK01bW9rpIqfCQfhjZ+nOnDSAK/H37mTM/uQr++tBNbCf+hvlgByqZ57yg/c0G7rf2ZYrE9GQm8BQCN+5DVn03TV//mj+ImtLK5PjEHIeXgEG+VxJcuOUNmFo587aRr3rgnmbvzYdesz9rOwzOmlcMQoJhzt2P532hzy90NQBlSAsNMVL1rNy0htAS/Xj7KLHqfxdyXgrqI3Rx69ds/dZieCXyxgr9i1R+/f2s6aEX1lCk7C9b0NWNL/byJ+4GnK5PGNopUrJfEo7j3+5AtzpelOfTiOtqbVNXmy/B02hhbTvZxvAtk1nnfEkjZ4kmzXw+OLA249uu7K745nf5LHPU37ljY+W7K1tRzazRoxkB5WT+Z16w+ob7OWfjOalVOmr9XzCE33mlnFHP/oOdlFVCN2x5dZzkA8pV+CZf4eRLb6y+kzc6e/+vLOnAvzrFUAyfVcIleq4+fLuM3TEcWOWfrj37kL/HKkTHHnPdt6AJTJXXjw3MXCQvbLS+ectY93BI7uH8g+TZM6yX2khkPEqyru/Y+zLu48vYZg8s+xJKqzgU2I/WHICbgj1GpxTZpmmzNwkpeqwJ5X3KUxf01YpNn/tJw8r+FSA7oGNNjHzxF2ft54t2J15fjEBJnXizLuprdTIxJyqIsw7WOlW8Nxipa9bGxLW0ww0vcy17SgNu5cuM5omLsrqWa45/uaZZkUze6Qucvdb2Zko4Z/BnbxzY2LUzQSTJ/hIkltHyzor2X8gPQjweuf7DmRlWmp5KI+sracC/OsVwLadsrVP8j7hl4d18Wc6EljOWaPp4fg09Aoyt9Ry7tkL69dE5G9UYml/hjXVj4Z2DZ8rYoaJruTG5bVhkPfP82uffAfW5sjNVXFQqok6tNoVkZrIoJDjMTMmJOuTZPVVwgF4ytfMUpXWryFr98r3K7LNxoabcPLimQJOBfi1Uy6Pzuob1+Y+bzTvKmVgCfELNO+zwrIl0bhFO6w3A8Hy+4WaMJwyJWeSes4jO36AMwNXOnmsdAvk1JKJiemuPiAv4kIPkOnGoJ2FZvXSl7dZPKcbf3w3Wf5qMcH3fUQ4myx65cj7W9IXbLjj4EwkRDb2hiRya/QOcBVfhOycCnAezxTA7H/LLvnCwtc5cYwN7rs0ZA9fCXc1+Uqmh1UW+cg+oyPyO/LVNQHLu4W7+WOF9+i9uX2u1DWC+unVtgUrp5GZTgSLfAYkJ/3ZXHq1eX5weq95xVHyEVyEzFnqnMMxgX0X0JyMK2c99plXpoJJ6hWkpSLIz4mg93XlD3QqwHk8SOAkzx5NfGzhm/fnwHL97w240oUrAjblLRpGbcQNQuLa1nyDiuNfN2q59YdfzgUj1/DopK9052UU/mouOtJQudq2MfrJ3iTl0jdydzfJsbcU1KEklLZ91Fe+wEAogjT/5PRXtRqOF8/tQjC176xZaDvZyAJmNwVkTez+T7sfkrhn8Hn82xVgNS250KejJln1ufLCAJwfXyoYYPps2tN7VnbypZifpDt4tAfaMofK4WrQvbZnYsP9+nRLIw+fT/biinN10a5RskIEO+CiLbo1p+Bn8rhdbWupTirHDaWcZZAaZ71+VYg3jK1a4jXXV6US8v1cNPkYbVCFOMHxvCZNIKxZBuEhpwIcHKCnggxwDsDatgSchrMIrbN2c3dd3uMc9PXvOOjErjY7aOP8FR/JwK5hkmcU7fzLloYDMC9wta4+puj6mbP5BN2EhE7HHqsC7Gl8lXLYN3GcwsTY4O58LLklZV6PNBYvVxPzenwn/xnN0ylcBPWnzqK+xzzZwefh6mDePUsyRjS79s7h74622rb/nGXz3j5jcxeUhsyHC/czC3z8kzwyA0Pbz1f8cgHhpPLKC0dOMjwF8JaNsxA5pReeLni1XcWbyye515tQ/HV/4mdzWZiH5iRUzzU2A4yL9nMbVexRZD66pDvZwdq4/vbSIo6NAcHqpYXrVIB/vgJoemGYn7iZLJrH+0t+pocIuYdb0wko3XHRmYbSIPrnm84gJ3gZFH8TtbszvTy4fSNvV7wQB9u0dOunt7ABxHrWrTatH325OCoqia5bbiiKczg2zC5qh9KvSuvje/4a8wgkOxKuAlExn4mrpinWVjGWC3Te9uUK8PCAmjh8gPN4egC0k6PuoR+5PleevEE4es+6nFtiF8Da+IcDp+1kKenkea8uiZPDM0U0N5GBS5aGvnxwV9MMdK0t45XBABZX9Qgpj6MLYL+y5Yr8u1UL8SnIEgf460x7aRNL9wPXlntujcMMsOZCflQh9U3AO1VJCAmpbuP592/uSSSrmCSqeZRBpwJgcwEdlIYx/YTfWLi9H7B0uuqJAQCo/2de3MxP457+UzecNdzLstZwel5UlEET8shuZWaVCh/gSjZ9p2nbdreOfOWDHEkkEbfLz3uvMCu3ncAnmUzlj6ibX8mk77AyXUygntO8vOaFd3r0KYO0/Hc+q6oQX3dvjh7u6Vo0U8YudLfgQfPCqQCnAqzWm5ZrtTZsK/ZTt3+eHnz9b0P9uoemEodAc5/OjgLadMZG+8Hl+/xBN+Xb+6f6BmsoBacF9hQUEN/3zsy/y+eRZ8tg5CwYvrx3ooPP97y2XduTDzrxpHmXE7qRoqprmNGSy1fuMKuqREYBZ6Igc9SRXqCBPyA3ljMZzQ8z6aY040Hu6HKQwPO4rHnOFZpU7h837fpLMTgyUbM29tI2AnjxZrjC1K3+nuct9+OBxt3Uqa9NNds3k/UrK3dgxc1/EhGq9hTzNhJNhZy+hM5RfHXsP0a730fb5LNySGi3Ii1fwH44qPHksl74qTYfYVA/MhqG2HWdShiEvXxHTwU4SKA27//C5zlFJz5dN+HIy9UyjEBL2wPs/kGVZlM+Ph2/GzntdkeCPcUcpMW35iJSvBnzUz6aakkb/xaJHzz//CYu2t01iwe8iGNcnUVkBN0AuS2t7U8CePn68bsmm/uCNQeF7rUg1E1wBVWfJSYlmSmYBTW2Pcd5/NsVQF74N7a7p+tzIn12z/u1lqP1S6tWt9Mbg9/rSNfDLzrf/bvJj5xz7kFWpmZVtvDMOVhad67p9rdyvhgb07lwhNWSzQa+QPYUvB0VDFzpn/og8ux1aBteWL3Myu/dPVjG1h91n6XQJ6lPUANoaqa+sz09wKkAv722+CQLnaxC2Cd18rK54+4INXNfyrWykiu6/mj6jhzUb0TqdngajjaVCPUi1fEW6lX9b6GMK5n1gViE53hl+A7abT590p1zTSkfxbcdyHNoLZFgNebz3OohiBEdvMZJHAzOdH3QlL/5jHpWULyDD8Pp9mdVf2tCk0rxGk4FODgAJ8zC3WPe86jhxieR/emnyyiT+z2fgj5nd7JaP8QMBEq1Z34un93VB7zBG5Tee+WtqNmFVDbPSOZuMXvKa3Ok4lByfl45MUS+Bz+3SlXtqtryNtKmkVaAtEXvXEBrtaEq7aLE9dHeweF1QRvGUCjq23e13I2ZNzFpltH8Wz8V4F+vAD3xHsngt1dPoOTDU9qZ4SlY3w0DCC8LdsMqB9vlnn+LULHnZ3/JgciIJWsbyvX27zTC4PkeZiYTq3/RvL0r2bQwSnhXcG/6A9De3pr3GF7dFNIZSNI1OfKar9QMdYTj6RU0e5VABD7NH+TXJFU1E/h4LePscSWE89kTnArwr1cAUCfaffx2nm1H9IoH99zQf3Dn/c0KYqUzJYRCgdzBQGni4mfiyhkhNC7lYhyM/UGf/gVsnPpJqplC1tjLYHo6b0cyjbIHR/YW1voidgnQhtHNZALAJx7ZEAPL3X55g8xtnxrzxQRISXn7hh/YUw9AJz/mpj3FEdQv1PM9FeBUAGyqcnmd+vKVltyTP5+sD0A6QOSfkY2bityPa8u6kpx+J93S0vKwQR32ovxu8a8bzv2pe5/dCyWdeTW1B8uZu0/m8Y0/lDq6kgegtP2sfeQi58JIANs9FkCe3089++L9PjNXv/45iTlV+b53YyzG39IAOzYU27n8Gd8abuZ0n8SQ88Clr8kWbVMN4t1KouBPN/rNMxObr9G875892SKUjm/bud2tRh48hTVyus7MM19d70idrJGjEMDp4c9ruKnzD3XNIH2+ojb6V37Hj+MiknzB0kC9e6Sn216pUa7OqnOEgz9YuouZWuWJnr5oxKmIDuRKriCa2mmgvN0VaFyIeM5dy3kqwMEBuO8srwl2kqqTy0wfVvZ1l6/oizV5RtFF3PkVRgh9qYLmppzrG3Btnqb1PKz9mrTTsj8sWQCC7+awwY6GizoQ9jhZxFtE5pdbziwLxSQIje5q+Z1GmUvlvzrStUBaZRyE31U1+ALkB1J9ALOOw5GxtjGzdRHKY+B5/MM9wHKU3donaCafv/bfilLCGeWAPd5d5QXGidac3VUMHLQJF22nUEqfmlhl+2f4EUpmX7A/4cpPtiRiHzcrq3k0T7BSJg8aG8/aViN+rVLVgsM88xnxDkRyy7hPRb3Grpb8OwjhXD/YgQusB+xZ7ELJKezXWukChc4cHOA84gMg+M3NCafbRYyyqACWrnWcPjUA8tMSQtLnS1c/UY4E0nJFA7uejdHC2L85/6a2C88mT9F9y2a73bXxcEZTG3DeR883NLrZH2fRQT0/JxKxexn3IZrOYDvDolTExT9Q6i5qerAtyVUaI0Hy2cCVDiMVSrJ5mjBycSrAv14BBt2ArKgZ2YV3tr+Qnk7xyds17pfZ/LNm3tOg+2hmdxuJv6GQl5b18+suZq4dTx4dKVvNi4ixsElbyap0fDIt6waar+HIn7rnK3U3Xmz/1ZXCkTN+017k673JJCSlPH1DRV2zQ+Ub2eZMtBoDC8SqfirsJ1MRh2u/TgX41yvA3zwVQN8a1elQSqcrpG+lh56121Joijbc7TRJY6UM0hFq493weS4nASHegW16QW27fUnG4e1IfmnxVyL/7Gt8N2xyv22Li4vGiLDmSlQ7gji/t5/cv+kFLH72p+ena/buxROYL+witEdd/TQTjVivJPTKTCqcpf6Wym/8VIAzBSC3TbplfNiLJ8zn2wixG6TnY+zv4bOs/H1tvgCsPtLtxrf8hBbWZvg2p8t+uyP7DMuqshIRt8Qd2VVnkEo+3I7QpmvWMlviCoM4yZyVAHIxUmI7XM6lqunjD7EX6/Wwfg85iUluX5b3Crubcr1fMW8t9w0A+TCuja9spwc4j0s25Ks6bU03Ck7kqk5TCN8W+qSxQm953tYi1xGl/nY0/7rSKEbCJqjjqM96dcOh8Ac+mO7OF1kgf70HGfi0GR+ZTCobuiavioctkyNcPb+by1g4hA3CPpWmlUoWinfpzlv8oszTQTtQrrClylJnNl+O7gFf/9+ZastAJ66W317ZS6woPBXgVICYMcv/QrBaGnDPCLzSvyY+9V8/r+GI/5zBgfDzCeecqyFRCmYQV91Q6ncr8fKdhaH0J0p/G/82HF27wPnFsvnnLlIS34QdaqrqhBzMpSEOjwJvgR27jPqO0uCMhqWgYQ7dv7BOf3cXD1b/nZXr8QW6M+lU0rFt0GsbG87ZMd5TAc7jUQYpadmxba3qBg5NQPiHCGliOANEyJ3bmnef/NC2jzZR2GuLbz/2hYXmF6bwbCMuXIlGSkvdQ/qfaaaSMr/59jl9JP8uHNH7PL7as1t02oy4U/D5RTxdhd8Bae9Az0bXbaoZ+dXDnVLDBawy1epVaMtt0c2ZcTad0uEEnkdUgMjjNZ+5hfDk6H0tUSxNF72VSNSi+byScEE3bv+O5ZKvxN7HhqTXWRiOn5tn3ipVpZm1JFj5aL2LNaRuvTp90N5hbTNOzxmKnf9NfHzuufkxX68X6Llq0xUJzOxnR/N676WxBTRflRG3SrLnGM2NeNArhDsTftNpcR4c4DyuyKbTDcNHnq/qg2t7NDInK25gzZPx8Gwn2P1Gtzlbs1/ek4jZ7QLptik/UMK1eZCxQwHwN3PL1d0Mn81AuPP/x2tKnKX/dTXNdGVynKHqceB+nh9yG/qDL4CPY26FMWp2Kkp4Qk32w7VQShy+ykOQzfnEkpOFjaG0u6XFdlJo9kFLY5nk84qzCziPSxPzU/pkDZR6TRN9Kj16MeeCvbsSiV5NvaJ5kmM3tbbPbOfd1H2rYK4cMlkg7suJhat5goE0ypKnLfYNsRuoPbgQq7dPHqW/ndtEJM0PddEOVKi7VqB5JxYKULnMe+o6n+9d01yZDsuZWOXvyPOJNC9Ha8ipkv/bcAT1uISdCjAop/dDXWwkWU3U/lipx++fPKVsLtu4tMM/c5J8wok/iX1fic7H3l7Ailh2vSzMQpMJbKRRAHXB7HQIyhaI2bnri8q7Y3n2r1L3IsQhqiqxJ6hwtaukYNYrg37O201JSLsszdFT2mnnisn7yKpMu0IitIKa6urqv04F+NcrwMouV6lDtDz7lfYJ7/O7blB+OAJaU59MlHLgyfz85vahulJQzwty5dZN6Qefuz8v58A7d2pCfXMlf2hT4wpllIZi5plr/gAvN+JB3gLWkj/4zl45/zPzUKmGypa23LsObJWhbujgNBWzgbN/eg1cuSOJWz8Qk0VeiFHtTgU4OEBh6oXHr4Zk1dZNE5e7Mic7XLaZdYMXFrXScWs6t96IO2ctg9QIY68zEpXEfCbZtw2jzRb79lB9Q8iegUr5iJb7TBBqVz+7q5QqcZ13dxdtQdT3JuM1RZQHQFTSke+QkG+REcNnEs7K+xrJDPFKU3wrktX5SQ/SuNpW4lSAf70CoGnypp/oRZm2w1WC3Z9ztt09z6CDTvbuclupP4ErTkIIqgqNRAb7fRv6AnY0UML/ynHL2nYgfDZn8oxu58sETm40+Stq96mUkFLdw9w6Fmk7iAm8/EKVWMyFrVgiFUgmQakXw3k4+MTqyYvqFXdkzS0vUCEeJW8B0CaZYhucCnBwgAnFlxQ8Qpi25KdQMsF+5pR5UVcr6UPH+j1rN2o/m4vOXufazNZZd/Vb9c9G0/1ILXHnMdX5UXBylhD/V1t+mKUGB9TZd4TONi1VPad3TjL7ctWWLuomKK1lUeJ3PeeRtS/4y6xT7Nh/IJAj9QJPtfnSdsfS7+R51acCnB7A0qnLiA2jAPnL3N7TKpiFbv8lGWARBseTLbvphqfN/eq5QV0q9wW8PUAmY9ze2Yvv/i7vPwY60+Zv1qtCOjTzQp7X80VPIlkApQywNxgzhJ9MsQ8ivXB35ipkrzDPJzXg4+5hSK8Q0H9H118dmfhzZAxhbghheA7eqeK483e1oYeCkxdwHsEKHtl5d8fQSP5mjjoj7LFJKCfrmET7bquUQpoo3JV5mDeKgRNdft1939YRCND0veYziLVcQmtnRDe3kUW+HIGWDXfvLX4Pp/pWimlHBzkvfTY9M9IZpFR71afM3HqspnKeyRZavvfr3EVOUarprZTZ6tmFtQn84s1Hir8xO7mB53EJcV4knXV406VNk2rNkfPd3yrNyPpfOmHL5Att20akw2755ZSDQG3GH9c/9ROyWl8+c7MuucW4MxHAXqgcmkvP3o+snAs6whnuxYFvXMQMLuQhqtLd0siGK5eFHETYr/xORFDp/ezqbc5bU0IaPvjr8xhvYxahEOW1Fujlefzru4BFWTe7m2ydXmndbe3+J+lZjfzy+qlS6m3Z8X/RWYlJRBJ1ZG9eJc2Abfy/XSsbP/FCcN+Zfa9bUhHaZICX/7+k+1l/X/ZaUkopnn0eLdWHHLuezJPI71O8vbwta4Rhej18at7MZDG4T+sktSVoYmBPZqS7iZI74TyZQecBXCtTuQSCG4YP6fJ5K6fEBYxcjrElUOw5HdNv9N8nJ1DtT2YGFUZe5+WXfwBSuQd0Fkwxa3Rj0AxX1pR3ILZ7VZKtXHneunGbrU3qQrzewEaCXfBt/MXR+L0XemIo18ln9hmukK7XZ7lBCU3VIF4A71Qt/6ZiW/rNmeNu2OWpAKcC9HSAkZy0UtWN3JNL4myxE/i4X39s9XTrrT9+qlerE5ywxT+t53lqY+RWx8sqmrV1J7a5HlfewHTPHhAzKLgFIzttdfRP878Gdm9NSW8CI0Vx1UejKWg2x6E6u9ZedZzynn5siVPw8xXfRmruSkt7fOVG5/nV2+vE0z186G9B0z/0VIBTAdAm+jeqb1uvjMzEAL6OVX9TKyhtljYM/MdVsne7KZGK5Kg77Lb3TO+Mp5eeRXPf3fMGpCEP3A2EFie26pO0N+tHgkd/rQvdN11ytu6O5IP4ONLqkFIKkSbGb7nRWMR7VHptK1WI8X0/WWNH/sSB0ksHf2AQZruIAViJL4EongpwcIDaXI2N6Su030f7TAs4kT7264u27fAp85l64Z9KSw6rbep1tE5AaLo2mjBAeD9yN8/OA7bhA4w6GPUePNcbdetG37F7/K9WXZ76N3I+ktzLx3wynDPx6C042cBSdQX3N1rba4i/hVJsWqvSjLrMzDxFeiZ9SS+N3Jd0tqUet/DzAP7fAQDHEpe2ebdV9QAAAABJRU5ErkJggg==");
 
     private final String encodedString;
-    private BitmapDrawable cachedImage;
+
+    // We cache a bitmap, NOT a drawable. Drawables maintain view specific properties,
+    // such as their bounds, and caching them causes problems when the same drawable is used by
+    // multiple views.
+    private Bitmap cachedBitmap;
 
     private Drawables(final String encodedString) {
         this.encodedString = encodedString;
     }
 
-    public Drawable decodeImage(final Context context) {
-        if (cachedImage == null) {
-            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
-            int scaledDensity = Dips.asIntPixels(displayMetrics.xdpi, context);
+    public Drawable createDrawable(final Context context) {
+        Bitmap bitmap = getBitmap();
+        BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
 
+        final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+        drawable.setTargetDensity(Dips.asIntPixels(displayMetrics.xdpi, context));
+        return drawable;
+    }
+
+    public Bitmap getBitmap() {
+        if (cachedBitmap == null) {
             byte[] rawImageData = Base64.decode(encodedString, Base64.DEFAULT);
-            cachedImage = new BitmapDrawable(new ByteArrayInputStream(rawImageData));
-            cachedImage.setTargetDensity(scaledDensity);
+            cachedBitmap = BitmapFactory.decodeByteArray(rawImageData, 0, rawImageData.length);
         }
-
-        return cachedImage;
+        return cachedBitmap;
     }
 
     public void clear() {
-        cachedImage = null;
+        cachedBitmap = null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ImageUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/ImageUtils.java
new file mode 100644
index 00000000..267a9bbf
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ImageUtils.java
@@ -0,0 +1,61 @@
+package com.mopub.common.util;
+
+import android.graphics.Bitmap;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.widget.ImageView;
+
+
+public class ImageUtils {
+
+    /**
+     * Fast Gaussian blurring algorithm source:
+     * https://github.com/patrickfav/BlurTestAndroid/blob/master/BlurBenchmark/src/main/java/at/favre/app/blurbenchmark/blur/algorithms/GaussianFastBlur.java
+     *
+     */
+    @NonNull
+    public static Bitmap applyFastGaussianBlurToBitmap(@NonNull Bitmap mutableBitmap, int radius) {
+        int w = mutableBitmap.getWidth();
+        int h = mutableBitmap.getHeight();
+        int[] pixels = new int[w * h];
+        mutableBitmap.getPixels(pixels, 0, w, 0, 0, w, h);
+
+        for (int r = radius; r >= 1; r /= 2) {
+            for (int i = r; i < h - r; i++) {
+                for (int j = r; j < w - r; j++) {
+                    int tl = pixels[(i - r) * w + j - r];
+                    int tr = pixels[(i - r) * w + j + r];
+                    int tc = pixels[(i - r) * w + j];
+                    int bl = pixels[(i + r) * w + j - r];
+                    int br = pixels[(i + r) * w + j + r];
+                    int bc = pixels[(i + r) * w + j];
+                    int cl = pixels[i * w + j - r];
+                    int cr = pixels[i * w + j + r];
+
+                    pixels[(i * w) + j] = 0xFF000000 |
+                            (((tl & 0xFF) + (tr & 0xFF) + (tc & 0xFF) + (bl & 0xFF) + (br & 0xFF) + (bc & 0xFF) + (cl & 0xFF) + (cr & 0xFF)) >> 3) & 0xFF |
+                            (((tl & 0xFF00) + (tr & 0xFF00) + (tc & 0xFF00) + (bl & 0xFF00) + (br & 0xFF00) + (bc & 0xFF00) + (cl & 0xFF00) + (cr & 0xFF00)) >> 3) & 0xFF00 |
+                            (((tl & 0xFF0000) + (tr & 0xFF0000) + (tc & 0xFF0000) + (bl & 0xFF0000) + (br & 0xFF0000) + (bc & 0xFF0000) + (cl & 0xFF0000) + (cr & 0xFF0000)) >> 3) & 0xFF0000;
+                }
+            }
+        }
+
+        mutableBitmap.setPixels(pixels, 0, w, 0, 0, w, h);
+        return mutableBitmap;
+    }
+
+    /**
+     * Sets the alpha value of the ImageView.
+     * API Level < 16: http://developer.android.com/reference/android/widget/ImageView.html#setAlpha(int)
+     * API Level >= 16: http://developer.android.com/reference/android/widget/ImageView.html#setImageAlpha(int)
+     * @param imageView the ImageView
+     * @param alpha the alpha value being applied to the ImageView
+     */
+    public static void setImageViewAlpha(@NonNull ImageView imageView, int alpha) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            imageView.setImageAlpha(alpha);
+        } else {
+            imageView.setAlpha(alpha);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
deleted file mode 100644
index ac1a3d71..00000000
--- a/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.os.Bundle;
-
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.List;
-
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-
-public class IntentUtils {
-    private static final String TWITTER_APPLICATION_DEEPLINK_URL = "twitter://timeline";
-    private static final String PLAY_GOOGLE_COM = "play.google.com";
-    private static final String MARKET_ANDROID_COM = "market.android.com";
-    private static final String MARKET = "market";
-    private static final String HTTP = "http";
-    private static final String HTTPS = "https";
-
-    private IntentUtils() {}
-
-    /**
-     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
-     * RESULT_CANCELED, so don't use it for Activity contexts.
-     */
-    public static Intent getStartActivityIntent(final Context context, final Class clazz, final Bundle extras) {
-        final Intent intent = new Intent(context, clazz);
-
-        if (!(context instanceof Activity)) {
-            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
-        }
-
-        if (extras != null) {
-            intent.putExtras(extras);
-        }
-
-        return intent;
-    }
-
-
-    public static boolean deviceCanHandleIntent(final Context context, final Intent intent) {
-        try {
-            final PackageManager packageManager = context.getPackageManager();
-            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
-            return !activities.isEmpty();
-        } catch (NullPointerException e) {
-            return false;
-        }
-    }
-
-    public static boolean isHttpUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final String scheme = Uri.parse(url).getScheme();
-        return (HTTP.equals(scheme) || HTTPS.equals(scheme));
-    }
-
-    private static boolean isAppStoreUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final Uri uri = Uri.parse(url);
-        final String scheme = uri.getScheme();
-        final String host = uri.getHost();
-
-        if (PLAY_GOOGLE_COM.equals(host) || MARKET_ANDROID_COM.equals(host)) {
-            return true;
-        }
-
-        if (MARKET.equals(scheme)) {
-            return true;
-        }
-
-        return false;
-    }
-
-    public static boolean isDeepLink(final String url) {
-        return isAppStoreUrl(url) || !isHttpUrl(url);
-    }
-
-    public static boolean canHandleTwitterUrl(Context context) {
-        return canHandleApplicationUrl(context, TWITTER_APPLICATION_DEEPLINK_URL, false);
-    }
-
-    public static boolean canHandleApplicationUrl(Context context, String url) {
-        return canHandleApplicationUrl(context, url, true);
-    }
-
-    public static boolean canHandleApplicationUrl(Context context, String url, boolean logError) {
-        // Determine which activities can handle the intent
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-
-        // If there are no relevant activities, don't follow the link
-        if (!IntentUtils.deviceCanHandleIntent(context, intent)) {
-            if (logError) {
-                MoPubLog.w("Could not handle application specific action: " + url + ". " +
-                        "You may be running in the emulator or another device which does not " +
-                        "have the required application.");
-            }
-            return false;
-        }
-
-        return true;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
new file mode 100644
index 00000000..e103ff7f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
@@ -0,0 +1,262 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import java.util.EnumSet;
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+
+public class Intents {
+
+    private Intents() {}
+
+    public static void startActivity(@NonNull final Context context, @NonNull final Intent intent)
+            throws IntentNotResolvableException {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(intent);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        try {
+            context.startActivity(intent);
+        } catch (ActivityNotFoundException e) {
+            throw new IntentNotResolvableException(e);
+        }
+    }
+
+    /**
+     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
+     * RESULT_CANCELED, so don't use it for Activity contexts.
+     */
+    public static Intent getStartActivityIntent(@NonNull final Context context,
+            @NonNull final Class clazz, @Nullable final Bundle extras) {
+        final Intent intent = new Intent(context, clazz);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        if (extras != null) {
+            intent.putExtras(extras);
+        }
+
+        return intent;
+    }
+
+    public static boolean deviceCanHandleIntent(@NonNull final Context context,
+            @NonNull final Intent intent) {
+        try {
+            final PackageManager packageManager = context.getPackageManager();
+            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
+            return !activities.isEmpty();
+        } catch (NullPointerException e) {
+            return false;
+        }
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri) {
+        return canHandleApplicationUrl(context, uri, true);
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri,
+            final boolean logError) {
+        // Determine which activities can handle the intent
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+
+        // If there are no relevant activities, don't follow the link
+        if (!Intents.deviceCanHandleIntent(context, intent)) {
+            if (logError) {
+                MoPubLog.w("Could not handle application specific action: " + uri + ". " +
+                        "You may be running in the emulator or another device which does not " +
+                        "have the required application.");
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Native Browser Scheme URLs provide a means for advertisers to include links that click out to
+     * an external browser, rather than the MoPub in-app browser. Properly formatted native browser
+     * URLs take the form of "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com".
+     *
+     * @param uri The Native Browser Scheme URL to open in the external browser.
+     * @return An Intent that will open an app-external browser taking the user to a page specified
+     * in the query parameter of the passed-in url
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForNativeBrowserScheme(@NonNull final Uri uri)
+            throws UrlParseException {
+        Preconditions.checkNotNull(uri);
+
+        if (!UrlAction.OPEN_NATIVE_BROWSER.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
+        }
+
+        if (!"navigate".equals(uri.getHost())) {
+            throw new UrlParseException("URL missing 'navigate' host parameter.");
+        }
+
+        final String urlToOpenInNativeBrowser;
+        try {
+            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        if (urlToOpenInNativeBrowser == null) {
+            throw new UrlParseException("URL missing 'url' query parameter.");
+        }
+
+        final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
+        return new Intent(Intent.ACTION_VIEW, intentUri);
+    }
+
+    /**
+     * Share Tweet URLs provide a means for advertisers on Twitter to include tweet links
+     * promoting their products that can be shared via supporting apps on the device.  Any
+     * app with a filter that matches ACTION_SEND and MIME type text/plain is capable of sharing
+     * the tweet link.
+     *
+     * Properly formatted share tweet URLs take the form of
+     * "mopubshare://tweet?screen_name=<SCREEN_NAME>&tweet_id=<TWEET_ID>"
+     *
+     * Both screen_name and tweet_id are required query parameters.  This method does not verify
+     * that their values are existent and valid on Twitter, but UrlParseException would be thrown
+     * if either is missing or empty.
+     *
+     * Example user flow:
+     * Upon clicking "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802" in an ad,
+     * a chooser dialog with message "Share via" pops up listing existing apps on the device
+     * capable of sharing this tweet link.  After the user chooses an app to share the tweet,
+     * the message "Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802"
+     * is ready to be shared in the chosen app.
+     *
+     * @param uri The Share Tweet URL indicating the tweet to share
+     * @return An ACTION_SEND intent that will be wrapped in a chooser intent
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForShareTweet(@NonNull final Uri uri)
+            throws UrlParseException {
+        if (!UrlAction.HANDLE_SHARE_TWEET.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubshare://tweet? format.");
+        }
+
+        final String screenName;
+        final String tweetId;
+
+        try {
+            screenName = uri.getQueryParameter("screen_name");
+            tweetId = uri.getQueryParameter("tweet_id");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        // If either query parameter is null or empty, throw UrlParseException
+        if (TextUtils.isEmpty(screenName)) {
+            throw new UrlParseException("URL missing non-empty 'screen_name' query parameter.");
+        }
+        if (TextUtils.isEmpty(tweetId)) {
+            throw new UrlParseException("URL missing non-empty 'tweet_id' query parameter.");
+        }
+
+        // Derive the tweet link on Twitter
+        final String tweetUrl = String.format("https://twitter.com/%s/status/%s", screenName, tweetId);
+
+        // Compose the share message
+        final String shareMessage = String.format("Check out @%s's Tweet: %s", screenName, tweetUrl);
+
+        // Construct share intent with the shareMessage in subject and text
+        Intent shareTweetIntent = new Intent(Intent.ACTION_SEND);
+        shareTweetIntent.setType("text/plain");
+        shareTweetIntent.putExtra(Intent.EXTRA_SUBJECT, shareMessage);
+        shareTweetIntent.putExtra(Intent.EXTRA_TEXT, shareMessage);
+
+        return shareTweetIntent;
+    }
+
+    /**
+     * Launches a {@link MoPubBrowser} activity with the desired URL.
+     * @param context The activity context.
+     * @param uri The URL to load in the started {@link MoPubBrowser} activity.
+     */
+    public static void showMoPubBrowserForUrl(@NonNull final Context context,
+            @NonNull Uri uri)
+            throws IntentNotResolvableException {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(uri);
+
+        MoPubLog.d("Final URI to show in browser: " + uri);
+
+        final Bundle extras = new Bundle();
+        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, uri.toString());
+        Intent intent = getStartActivityIntent(context, MoPubBrowser.class, extras);
+
+        String errorMessage = "Could not show MoPubBrowser for url: " + uri + "\n\tPerhaps you " +
+                "forgot to declare com.mopub.common.MoPubBrowser in your Android manifest file.";
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchActionViewIntent(Context context, @NonNull final Uri uri,
+            @NonNull final String errorMessage) throws IntentNotResolvableException {
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchIntentForUserClick(@NonNull final Context context,
+            @NonNull final Intent intent, @Nullable final String errorMessage)
+            throws IntentNotResolvableException {
+        Preconditions.NoThrow.checkNotNull(context);
+        Preconditions.NoThrow.checkNotNull(intent);
+
+        try {
+            Intents.startActivity(context, intent);
+        } catch (IntentNotResolvableException e) {
+            throw new IntentNotResolvableException(errorMessage + "\n" + e.getMessage());
+        }
+    }
+
+    public static void launchApplicationUrl(@NonNull final Context context,
+            @NonNull final Uri uri) throws IntentNotResolvableException {
+        if (Intents.canHandleApplicationUrl(context, uri)) {
+            final String errorMessage = "Unable to open intent for: " + uri;
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        } else {
+            throw new IntentNotResolvableException("Could not handle application specific " +
+                    "action: " + uri + "\n\tYou may be running in the emulator or another " +
+                    "device which does not have the required application.");
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Json.java b/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
index e33ac0b3..91e0e614 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
@@ -1,5 +1,7 @@
 package com.mopub.common.util;
 
+import android.text.TextUtils;
+
 import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
@@ -12,10 +14,10 @@
 import java.util.Map;
 
 public class Json {
-    public static Map<String, String> jsonStringToMap(String jsonParams) throws Exception {
+    public static Map<String, String> jsonStringToMap(String jsonParams) throws JSONException {
         Map<String, String> jsonMap = new HashMap<String, String>();
 
-        if (jsonParams == null || jsonParams.equals("")) return jsonMap;
+        if (TextUtils.isEmpty(jsonParams)) return jsonMap;
 
         JSONObject jsonObject = (JSONObject) new JSONTokener(jsonParams).nextValue();
         Iterator<?> keys = jsonObject.keys();
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
index aff7bb39..aaf7b4bf 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
@@ -1,21 +1,37 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 import android.view.Gravity;
 import android.widget.Toast;
 
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
+
 public class ManifestUtils {
     private ManifestUtils() {}
 
     private static final List<Class<? extends Activity>> REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
+    private static FlagCheckUtil sFlagCheckUtil = new FlagCheckUtil();
+
+    /**
+     * This class maintains two different lists of required Activity permissions,
+     * for the WebView and Native SDKs.
+     */
     static {
         REQUIRED_WEB_VIEW_SDK_ACTIVITIES = new ArrayList<Class<? extends Activity>>(4);
         // As a convenience, full class paths are provided here, in case the MoPub SDK was imported
@@ -32,90 +48,233 @@ private ManifestUtils() {}
         REQUIRED_NATIVE_SDK_ACTIVITIES.add(com.mopub.common.MoPubBrowser.class);
     }
 
-    public static void checkWebViewActivitiesDeclared(final Context context) {
+    public static void checkWebViewActivitiesDeclared(@NonNull final Context context) {
+        if (!Preconditions.NoThrow.checkNotNull(context, "context is not allowed to be null")) {
+            return;
+        }
+
         displayWarningForMissingActivities(context, REQUIRED_WEB_VIEW_SDK_ACTIVITIES);
+        displayWarningForMisconfiguredActivities(context, REQUIRED_WEB_VIEW_SDK_ACTIVITIES);
     }
 
-    public static void checkNativeActivitiesDeclared(final Context context) {
+    public static void checkNativeActivitiesDeclared(@NonNull final Context context) {
+        if (!Preconditions.NoThrow.checkNotNull(context, "context is not allowed to be null")) {
+            return;
+        }
+
         displayWarningForMissingActivities(context, REQUIRED_NATIVE_SDK_ACTIVITIES);
+        displayWarningForMisconfiguredActivities(context, REQUIRED_NATIVE_SDK_ACTIVITIES);
     }
 
     /**
      * This method is intended to display a warning to developers when they have accidentally
-     * omitted Activity declarations in their application's AndroidManifest. This class maintains
-     * two different lists of required Activity permissions, for the WebView and Native SDKs.
+     * omitted Activity declarations in their application's AndroidManifest.
      * Calling this when there are inadequate permissions will always Log a warning to the
      * developer, and if the the application is debuggable, it will also display a Toast.
      */
-    static void displayWarningForMissingActivities(final Context context,
-            final List<Class<? extends Activity>> requiredActivities) {
-        if (context == null) {
-            return;
-        }
+    @VisibleForTesting
+    static void displayWarningForMissingActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities) {
 
-        final List<String> undeclaredActivities = getUndeclaredActivities(context, requiredActivities);
+        final List<Class<? extends Activity>> undeclaredActivities =
+                filterDeclaredActivities(context, requiredActivities, false);
 
         if (undeclaredActivities.isEmpty()) {
             return;
         }
 
-        // If the application is debuggable, display a loud toast
-        if (isDebuggable(context)) {
-            final String message =  "ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\n" +
-                    "Check logcat and update your AndroidManifest.xml with the correct activities.";
-            final Toast toast = Toast.makeText(context, message, Toast.LENGTH_LONG);
-            toast.setGravity(Gravity.FILL_HORIZONTAL, 0, 0);
-            toast.show();
-        }
+        logWarningToast(context);
 
         // Regardless, log a warning
         logMissingActivities(undeclaredActivities);
     }
 
-    static boolean isDebuggable(final Context context) {
-        if (context == null || context.getApplicationInfo() == null) {
-            return false;
+    /**
+     * This method is intended to display a warning to developers when they have accidentally
+     * omitted configChanges values from Activity declarations in their application's AndroidManifest.
+     * Calling this when there are inadequate permissions will always Log a warning to the
+     * developer, and if the the application is debuggable, it will also display a Toast.
+     */
+    @VisibleForTesting
+    static void displayWarningForMisconfiguredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities) {
+
+        final List<Class<? extends Activity>> declaredActivities =
+                filterDeclaredActivities(context, requiredActivities, true);
+        final List<Class<? extends Activity>> misconfiguredActivities =
+                getMisconfiguredActivities(context, declaredActivities);
+
+        if (misconfiguredActivities.isEmpty()) {
+            return;
         }
 
-        final int applicationFlags = context.getApplicationInfo().flags;
+        logWarningToast(context);
+
+        // Regardless, log a warning
+        logMisconfiguredActivities(context, misconfiguredActivities);
+    }
 
+    public static boolean isDebuggable(@NonNull final Context context) {
+        final int applicationFlags = context.getApplicationInfo().flags;
         return Utils.bitMaskContainsFlag(applicationFlags, ApplicationInfo.FLAG_DEBUGGABLE);
     }
 
-    private static List<String> getUndeclaredActivities(final Context context,
-            List<Class<? extends Activity>> requiredActivities) {
-        final List<String> undeclaredActivities = new ArrayList<String>();
+    /**
+     * Filters in activities to be returned based on matching their declaration state
+     * in the Android Manifest with the isDeclared param.
+     *
+     * @param context
+     * @param requiredActivities activities to filter against
+     * @param isDeclared desired declaration state of activities in Android Manifest to be returned
+     * @return the list of filtered in activities
+     */
+    private static List<Class<? extends Activity>> filterDeclaredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities,
+            final boolean isDeclared) {
+        final List<Class<? extends Activity>> activities =
+                new ArrayList<Class<? extends Activity>>();
 
         for (final Class<? extends Activity> activityClass : requiredActivities) {
             final Intent intent = new Intent(context, activityClass);
 
-            if (!IntentUtils.deviceCanHandleIntent(context, intent)) {
-                undeclaredActivities.add(activityClass.getName());
+            if (Intents.deviceCanHandleIntent(context, intent) == isDeclared) {
+                activities.add(activityClass);
             }
         }
 
-        return undeclaredActivities;
+        return activities;
     }
 
-    private static void logMissingActivities(final List<String> undeclaredActivities) {
+    @TargetApi(13)
+    private static List<Class<? extends Activity>> getMisconfiguredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> activities) {
+        final List<Class<? extends Activity>> misconfiguredActivities =
+                new ArrayList<Class<? extends Activity>>();
+
+        for (final Class<? extends Activity> activity : activities) {
+            ActivityConfigChanges activityConfigChanges;
+            try {
+                activityConfigChanges = getActivityConfigChanges(context, activity);
+            } catch (PackageManager.NameNotFoundException e) {
+                continue;
+            }
+
+            if (!activityConfigChanges.hasKeyboardHidden || !activityConfigChanges.hasOrientation || !activityConfigChanges.hasScreenSize) {
+                misconfiguredActivities.add(activity);
+            }
+        }
+
+        return misconfiguredActivities;
+    }
+
+    private static void logMissingActivities(@NonNull final List<Class<? extends Activity>> undeclaredActivities) {
         final StringBuilder stringBuilder =
                 new StringBuilder("AndroidManifest permissions for the following required MoPub activities are missing:\n");
 
-        for (final String activity : undeclaredActivities) {
-            stringBuilder.append("\n\t").append(activity);
+        for (final Class<? extends Activity> activity : undeclaredActivities) {
+            stringBuilder.append("\n\t").append(activity.getName());
+        }
+        stringBuilder.append("\n\nPlease update your manifest to include them.");
+
+        MoPubLog.w(stringBuilder.toString());
+    }
+
+    private static void logMisconfiguredActivities(@NonNull Context context,
+            @NonNull final List<Class<? extends Activity>> misconfiguredActivities) {
+        final StringBuilder stringBuilder =
+                new StringBuilder("In AndroidManifest, the android:configChanges param is missing values for the following MoPub activities:\n");
+
+        for (final Class<? extends Activity> activity: misconfiguredActivities) {
+
+            ActivityConfigChanges activityConfigChanges;
+            try {
+                activityConfigChanges = getActivityConfigChanges(context, activity);
+            } catch (PackageManager.NameNotFoundException e) {
+                continue;
+            }
+
+            if (!activityConfigChanges.hasKeyboardHidden) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include keyboardHidden.");
+            }
+            if (!activityConfigChanges.hasOrientation) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include orientation.");
+            }
+            if (!activityConfigChanges.hasScreenSize) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include screenSize.");
+            }
         }
+
         stringBuilder.append("\n\nPlease update your manifest to include them.");
 
         MoPubLog.w(stringBuilder.toString());
     }
 
+    private static ActivityConfigChanges getActivityConfigChanges(@NonNull Context context,
+            @NonNull Class<? extends Activity> activity) throws PackageManager.NameNotFoundException {
+        ActivityInfo activityInfo;
+
+        // This line can throw NameNotFoundException but we don't expect it to happen since we
+        // should only be operating on declared activities
+        activityInfo = context.getPackageManager()
+                .getActivityInfo(new ComponentName(context, activity.getName()), 0);
+
+        ActivityConfigChanges activityConfigChanges = new ActivityConfigChanges();
+        activityConfigChanges.hasKeyboardHidden = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_KEYBOARD_HIDDEN);
+        activityConfigChanges.hasOrientation = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_ORIENTATION);
+        activityConfigChanges.hasScreenSize = true;
+
+        // For screenSize, only set to false if the API level and target API are >= 13
+        // If the target API is < 13, then Android will implement its own backwards compatibility
+        if (currentApiLevel().isAtLeast(HONEYCOMB_MR2) &&
+                context.getApplicationInfo().targetSdkVersion >= VersionCode.HONEYCOMB_MR2.getApiLevel()) {
+            activityConfigChanges.hasScreenSize = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_SCREEN_SIZE);
+        }
+
+        return activityConfigChanges;
+    }
+
+    private static void logWarningToast(@NonNull final Context context) {
+        // If the application is debuggable, display a loud toast
+        if (isDebuggable(context)) {
+            final String message = "ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\n" +
+                    "Check logcat and update your AndroidManifest.xml with the correct activities and configuration.";
+            final Toast toast = Toast.makeText(context, message, Toast.LENGTH_LONG);
+            toast.setGravity(Gravity.FILL_HORIZONTAL, 0, 0);
+            toast.show();
+        }
+    }
+
+    private static class ActivityConfigChanges {
+        public boolean hasKeyboardHidden;
+        public boolean hasOrientation;
+        public boolean hasScreenSize;
+    }
+
+    @VisibleForTesting
     @Deprecated // for testing
     static List<Class<? extends Activity>> getRequiredWebViewSdkActivities() {
         return REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
     }
 
+    @VisibleForTesting
     @Deprecated // for testing
     static List<Class<? extends Activity>> getRequiredNativeSdkActivities() {
         return REQUIRED_NATIVE_SDK_ACTIVITIES;
     }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    static void setFlagCheckUtil(final FlagCheckUtil flagCheckUtil) {
+        sFlagCheckUtil = flagCheckUtil;
+    }
+
+    static class FlagCheckUtil {
+        // We're only passing in the Class param here to ease testing and
+        // allow mocks to match on it
+        public boolean hasFlag(@SuppressWarnings("unused") Class clazz,
+                int bitMask,
+                int flag) {
+            return Utils.bitMaskContainsFlag(bitMask, flag);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java b/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java
new file mode 100644
index 00000000..a83bec24
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java
@@ -0,0 +1,15 @@
+package com.mopub.common.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class MoPubCollections {
+    public static <T> void addAllNonNull(@NonNull final Collection<? super T> c,
+            @Nullable final T... a) {
+        Collections.addAll(c, a);
+        c.removeAll(Collections.singleton(null));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Numbers.java b/mopub-sdk/src/main/java/com/mopub/common/util/Numbers.java
index 773d49c3..0c5021b6 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Numbers.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Numbers.java
@@ -3,6 +3,12 @@
 public class Numbers {
     private Numbers() {}
 
+    /**
+     * Tries to parse the double value from a Number or String.
+     * @param value the object to parse.
+     * @return a {@code Double} instance containing the parsed double value.
+     * @throws ClassCastException if {@code value} cannot be parsed as a double value.
+     */
     public static Double parseDouble(final Object value) throws ClassCastException {
         if (value instanceof Number) {
             return ((Number) value).doubleValue();
@@ -16,4 +22,16 @@ public static Double parseDouble(final Object value) throws ClassCastException {
             throw new ClassCastException("Unable to parse " + value + " as double.");
         }
     }
+
+    /**
+     * Rounds up to the nearest full second. Formally, this is the long
+     * closest to negative infinity above or equal to millis, in milliseconds,
+     * converted to seconds.
+     *
+     * @param millis Time in milliseconds
+     * @return Time in seconds, rounded up.
+     */
+    public static long convertMillisecondsToSecondsRoundedUp(final long millis) {
+        return Math.round(Math.ceil(millis / 1000f));
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
index bfb34e9a..3efa8598 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
@@ -1,5 +1,11 @@
 package com.mopub.common.util;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
@@ -88,4 +94,17 @@ public static boolean classFound(final String className) {
             return false;
         }
     }
+
+    public static <T> T instantiateClassWithEmptyConstructor(@NonNull final String className,
+            @NonNull final Class<? extends T> superclass)
+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
+            InvocationTargetException, InstantiationException, NullPointerException {
+        Preconditions.checkNotNull(className);
+
+        final Class<? extends T> clazz = Class.forName(className).asSubclass(superclass);
+        final Constructor<? extends T> constructor = clazz.getDeclaredConstructor((Class[]) null);
+        constructor.setAccessible(true);
+
+        return constructor.newInstance();
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
index 4e0987b7..6e407f85 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -3,7 +3,7 @@
 public enum ResponseHeader {
     AD_TIMEOUT("X-AdTimeout"),
     AD_TYPE("X-Adtype"),
-    CLICKTHROUGH_URL("X-Clickthrough"),
+    CLICK_TRACKING_URL("X-Clickthrough"),
     CUSTOM_EVENT_DATA("X-Custom-Event-Class-Data"),
     CUSTOM_EVENT_NAME("X-Custom-Event-Class-Name"),
     CUSTOM_EVENT_HTML_DATA("X-Custom-Event-Html-Data"),
@@ -15,6 +15,7 @@
     REDIRECT_URL("X-Launchpage"),
     NATIVE_PARAMS("X-Nativeparams"),
     NETWORK_TYPE("X-Networktype"),
+    ORIENTATION("X-Orientation"),
     REFRESH_TIME("X-Refreshtime"),
     SCROLLABLE("X-Scrollable"),
     WARMUP("X-Warmup"),
@@ -22,6 +23,7 @@
 
     LOCATION("Location"),
     USER_AGENT("User-Agent"),
+    ACCEPT_LANGUAGE("Accept-Language"),
 
     @Deprecated CUSTOM_SELECTOR("X-Customselector");
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
index dd20902e..f474c2f1 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
@@ -1,12 +1,20 @@
 package com.mopub.common.util;
 
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.regex.Pattern;
 
 public class Strings {
+    // Regex patterns
+    private static Pattern percentagePattern = Pattern.compile("((\\d{1,2})|(100))%");
+    private static Pattern absolutePattern = Pattern.compile("\\d{2}:\\d{2}:\\d{2}(.\\d{3})?");
+
     public static String fromStream(InputStream inputStream) throws IOException {
         int numberBytesRead = 0;
-        StringBuffer out = new StringBuffer();
+        StringBuilder out = new StringBuilder();
         byte[] bytes = new byte[4096];
 
         while (numberBytesRead != -1) {
@@ -19,11 +27,29 @@ public static String fromStream(InputStream inputStream) throws IOException {
         return out.toString();
     }
 
-    public static boolean isEmpty(String input) {
-        if (input == null) {
-            return false;
-        } else {
-            return input.length() == 0;
+    public static boolean isPercentageTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && percentagePattern.matcher(progressValue).matches();
+    }
+
+    public static boolean isAbsoluteTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && absolutePattern.matcher(progressValue).matches();
+    }
+
+    @Nullable
+    public static Integer parseAbsoluteOffset(@Nullable String progressValue) {
+        if (progressValue == null) {
+            return null;
+        }
+
+        final String[] split = progressValue.split(":");
+        if (split.length != 3) {
+            return null;
         }
+
+        return Integer.parseInt(split[0]) * 60 * 60 * 1000 // Hours
+                + Integer.parseInt(split[1]) * 60 * 1000 // Minutes
+                + (int)(Float.parseFloat(split[2]) * 1000);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java b/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java
new file mode 100644
index 00000000..b53c4de3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java
@@ -0,0 +1,38 @@
+package com.mopub.common.util;
+
+import java.util.concurrent.TimeUnit;
+
+public class Timer {
+    private static enum State { STARTED, STOPPED }
+    private long mStopTimeNanos;
+    private long mStartTimeNanos;
+    private State mState;
+
+    public Timer() {
+        mState = State.STOPPED;
+    }
+
+    public void start() {
+        // System.nanoTime isn't affected by changing the system time
+        mStartTimeNanos = System.nanoTime();
+        mState = State.STARTED;
+    }
+
+    public void stop() {
+        if (mState != State.STARTED) {
+            throw new IllegalStateException("EventTimer was not started.");
+        }
+        mState = State.STOPPED;
+        mStopTimeNanos = System.nanoTime();
+    }
+
+    public long getTime() {
+        long endTime;
+        if (mState == State.STARTED) {
+            endTime = System.nanoTime();
+        } else {
+            endTime = mStopTimeNanos;
+        }
+        return TimeUnit.MILLISECONDS.convert(endTime - mStartTimeNanos, TimeUnit.NANOSECONDS);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
index ae829979..c4b620de 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
@@ -1,6 +1,9 @@
 package com.mopub.common.util;
 
+import com.mopub.common.VisibleForTesting;
+
 import java.security.MessageDigest;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicLong;
 
 public class Utils {
@@ -19,7 +22,7 @@ public static String sha1(String string) {
                 stringBuilder.append(String.format("%02X", b));
             }
 
-            return stringBuilder.toString().toLowerCase();
+            return stringBuilder.toString().toLowerCase(Locale.US);
         } catch (Exception e) {
             return "";
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
new file mode 100644
index 00000000..4eb87f6f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
@@ -0,0 +1,11 @@
+package com.mopub.exceptions;
+
+public class IntentNotResolvableException extends Exception {
+    public IntentNotResolvableException(Throwable throwable) {
+        super(throwable);
+    }
+
+    public IntentNotResolvableException(String message) {
+        super(message);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java
new file mode 100644
index 00000000..cca732da
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java
@@ -0,0 +1,11 @@
+package com.mopub.exceptions;
+
+public class UrlParseException extends Exception {
+    public UrlParseException(final String detailMessage) {
+        super(detailMessage);
+    }
+
+    public UrlParseException(final Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
index 57567c9e..ced94fa6 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
@@ -1,13 +1,17 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+
 public class AdAlertGestureListener extends GestureDetector.SimpleOnGestureListener{
     private static final int MINIMUM_NUMBER_OF_ZIGZAGS_TO_FLAG = 4;
     private static final float MAXIMUM_THRESHOLD_X_IN_DIPS = 100;
-    private static final float MAXIMUM_THRESHOLD_Y_IN_DIPS = 50;
+    private static final float MAXIMUM_THRESHOLD_Y_IN_DIPS = 100;
+    @Nullable private final AdReport mAdReport;
 
     private float mCurrentThresholdInDips = MAXIMUM_THRESHOLD_X_IN_DIPS;
     private float mPreviousPositionX;
@@ -21,15 +25,14 @@
     private ZigZagState mCurrentZigZagState = ZigZagState.UNSET;
 
     private View mView;
-    private AdConfiguration mAdConfiguration;
 
-    AdAlertGestureListener(View view, AdConfiguration adConfiguration) {
+    AdAlertGestureListener(View view, @Nullable AdReport adReport) {
         super();
         if (view != null && view.getWidth() > 0) {
             mCurrentThresholdInDips = Math.min(MAXIMUM_THRESHOLD_X_IN_DIPS, view.getWidth() / 3f);
         }
         mView = view;
-        mAdConfiguration = adConfiguration;
+        mAdReport = adReport;
     }
 
     @Override
@@ -69,7 +72,7 @@ public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float d
 
     void finishGestureDetection() {
         if (mCurrentZigZagState == mCurrentZigZagState.FINISHED) {
-            mAdAlertReporter = new AdAlertReporter(mView.getContext(), mView, mAdConfiguration);
+            mAdAlertReporter = new AdAlertReporter(mView.getContext(), mView, mAdReport);
             mAdAlertReporter.send();
         }
         reset();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index 47ac6f49..ca5087ce 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -4,15 +4,21 @@
 import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.support.annotation.Nullable;
+import android.util.Base64;
 import android.view.View;
+
+import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DateAndTime;
 import com.mopub.common.util.Streams;
-import com.mopub.mobileads.util.Base64;
 
-import java.io.*;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.text.SimpleDateFormat;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Locale;
 
 public class AdAlertReporter {
     private static final String EMAIL_RECIPIENT = "creative-review@mopub.com";
@@ -28,30 +34,32 @@
 
     private final View mView;
     private final Context mContext;
-    private final AdConfiguration mAdConfiguration;
     private Intent mEmailIntent;
     private ArrayList<Uri> mEmailAttachments;
     private String mParameters;
     private String mResponse;
 
-    public AdAlertReporter(final Context context, final View view, final AdConfiguration adConfiguration) {
+    public AdAlertReporter(final Context context, final View view, @Nullable final AdReport adReport) {
         mView = view;
         mContext = context;
-        mAdConfiguration = adConfiguration;
 
         mEmailAttachments = new ArrayList<Uri>();
 
-        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
+        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
         mDateString = dateFormat.format(DateAndTime.now());
 
         initEmailIntent();
         Bitmap screenShot = takeScreenShot();
         String screenShotString = convertBitmapInWEBPToBase64EncodedString(screenShot);
-        mParameters = formParameters();
-        mResponse = getResponseString();
+        mParameters = "";
+        mResponse = "";
+        if (adReport != null) {
+            mParameters = adReport.toString();
+            mResponse = adReport.getResponseString();
+        }
 
         addEmailSubject();
-        addEmailBody( new String[]{ mParameters, mResponse, screenShotString });
+        addEmailBody(mParameters, mResponse, screenShotString);
         addTextAttachment(PARAMETERS_FILENAME, mParameters);
         addTextAttachment(MARKUP_FILENAME, mResponse);
         addImageAttachment(SCREEN_SHOT_FILENAME, screenShot);
@@ -63,13 +71,12 @@ public void send() {
         Intent chooserIntent = Intent.createChooser(mEmailIntent, "Send Email...");
         chooserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         mContext.startActivity(chooserIntent);
-
     }
 
     private void initEmailIntent() {
         Uri emailScheme = Uri.parse(EMAIL_SCHEME);
-        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE, emailScheme);
-        mEmailIntent.setType("plain/text");
+        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE);
+        mEmailIntent.setDataAndType(emailScheme, "plain/text");
         mEmailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{EMAIL_RECIPIENT});
     }
 
@@ -108,38 +115,6 @@ private String convertBitmapInWEBPToBase64EncodedString(Bitmap bitmap) {
         return result;
     }
 
-    private String formParameters() {
-        StringBuilder parameters = new StringBuilder();
-
-        if (mAdConfiguration != null) {
-            appendKeyValue(parameters, "sdk_version", mAdConfiguration.getSdkVersion());
-            appendKeyValue(parameters, "creative_id", mAdConfiguration.getDspCreativeId());
-            appendKeyValue(parameters, "platform_version", Integer.toString(mAdConfiguration.getPlatformVersion()));
-            appendKeyValue(parameters, "device_model", mAdConfiguration.getDeviceModel());
-            appendKeyValue(parameters, "ad_unit_id", mAdConfiguration.getAdUnitId());
-            appendKeyValue(parameters, "device_locale", mAdConfiguration.getDeviceLocale());
-            appendKeyValue(parameters, "device_id", mAdConfiguration.getHashedUdid());
-            appendKeyValue(parameters, "network_type", mAdConfiguration.getNetworkType());
-            appendKeyValue(parameters, "platform", mAdConfiguration.getPlatform());
-            appendKeyValue(parameters, "timestamp", getFormattedTimeStamp(mAdConfiguration.getTimeStamp()));
-            appendKeyValue(parameters, "ad_type", mAdConfiguration.getAdType());
-            appendKeyValue(parameters, "ad_size", "{" + mAdConfiguration.getWidth() + ", " + mAdConfiguration.getHeight() + "}");
-        }
-
-        return parameters.toString();
-    }
-
-    private String getResponseString() {
-        return (mAdConfiguration != null) ? mAdConfiguration.getResponseString() : "";
-    }
-
-    private void appendKeyValue(StringBuilder parameters, String key, String value) {
-        parameters.append(key);
-        parameters.append(" : ");
-        parameters.append(value);
-        parameters.append("\n");
-    }
-
     private void addEmailSubject() {
         mEmailIntent.putExtra(Intent.EXTRA_SUBJECT, "New creative violation report - " + mDateString);
     }
@@ -198,15 +173,6 @@ private void addTextAttachment(String fileName, String body) {
         }
     }
 
-    private String getFormattedTimeStamp(long timeStamp) {
-        if (timeStamp != -1) {
-            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
-            return dateFormat.format(new Date(timeStamp));
-        } else {
-            return null;
-        }
-    }
-
     @Deprecated // for testing
     Intent getEmailIntent() {
         return mEmailIntent;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
deleted file mode 100644
index 236c577b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
+++ /dev/null
@@ -1,287 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.os.Build;
-import android.provider.Settings;
-import android.webkit.WebView;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-import com.mopub.common.util.Utils;
-import com.mopub.common.util.VersionCode;
-import org.apache.http.HttpResponse;
-
-import java.io.Serializable;
-import java.util.Map;
-
-import static com.mopub.common.util.ResponseHeader.AD_TIMEOUT;
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.DSP_CREATIVE_ID;
-import static com.mopub.common.util.ResponseHeader.FAIL_URL;
-import static com.mopub.common.util.ResponseHeader.HEIGHT;
-import static com.mopub.common.util.ResponseHeader.IMPRESSION_URL;
-import static com.mopub.common.util.ResponseHeader.NETWORK_TYPE;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.REFRESH_TIME;
-import static com.mopub.common.util.ResponseHeader.WIDTH;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractIntHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractIntegerHeader;
-
-public class AdConfiguration implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private static final int MINIMUM_REFRESH_TIME_MILLISECONDS = 10000;
-    private static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;
-    private static final String mPlatform = "Android";
-    private final String mSdkVersion;
-
-    private final String mHashedUdid;
-    private final String mUserAgent;
-    private final String mDeviceLocale;
-    private final String mDeviceModel;
-    private final int mPlatformVersion;
-
-    private long mBroadcastIdentifier;
-    private String mResponseString;
-    private String mAdUnitId;
-
-    private String mAdType;
-    private String mNetworkType;
-    private String mRedirectUrl;
-    private String mClickthroughUrl;
-    private String mFailUrl;
-    private String mImpressionUrl;
-    private long mTimeStamp;
-    private int mWidth;
-    private int mHeight;
-    private Integer mAdTimeoutDelay;
-    private int mRefreshTimeMilliseconds;
-    private String mDspCreativeId;
-
-    static AdConfiguration extractFromMap(Map<String,Object> map) {
-        if (map == null) {
-            return null;
-        }
-
-        Object adConfiguration = map.get(AD_CONFIGURATION_KEY);
-
-        if (adConfiguration instanceof AdConfiguration) {
-            return (AdConfiguration) adConfiguration;
-        }
-
-        return null;
-    }
-
-    AdConfiguration(final Context context) {
-        setDefaults();
-
-        if (context != null) {
-            String udid = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
-            mHashedUdid = Utils.sha1((udid != null) ? udid : "");
-
-            mUserAgent = new WebView(context).getSettings().getUserAgentString();
-            mDeviceLocale = context.getResources().getConfiguration().locale.toString();
-        } else {
-            mHashedUdid = null;
-            mUserAgent = null;
-            mDeviceLocale = null;
-        }
-
-        mBroadcastIdentifier = Utils.generateUniqueId();
-        mDeviceModel = Build.MANUFACTURER + " " + Build.MODEL;
-        mPlatformVersion = VersionCode.currentApiLevel().getApiLevel();
-        mSdkVersion = MoPub.SDK_VERSION;
-    }
-
-    void cleanup() {
-        setDefaults();
-    }
-
-    void addHttpResponse(final HttpResponse httpResponse) {
-        mAdType = extractHeader(httpResponse, AD_TYPE);
-
-        // Set the network type of the ad.
-        mNetworkType = extractHeader(httpResponse, NETWORK_TYPE);
-
-        // Set the redirect URL prefix: navigating to any matching URLs will send us to the browser.
-        mRedirectUrl = extractHeader(httpResponse, REDIRECT_URL);
-
-        // Set the URL that is prepended to links for click-tracking purposes.
-        mClickthroughUrl = extractHeader(httpResponse, CLICKTHROUGH_URL);
-
-        // Set the fall-back URL to be used if the current request fails.
-        mFailUrl = extractHeader(httpResponse, FAIL_URL);
-
-        // Set the URL to be used for impression tracking.
-        mImpressionUrl = extractHeader(httpResponse, IMPRESSION_URL);
-
-        // Set the timestamp used for Ad Alert Reporting.
-        mTimeStamp = DateAndTime.now().getTime();
-
-        // Set the width and height.
-        mWidth = extractIntHeader(httpResponse, WIDTH, 0);
-        mHeight = extractIntHeader(httpResponse, HEIGHT, 0);
-
-        // Set the allowable amount of time an ad has before it automatically fails.
-        mAdTimeoutDelay = extractIntegerHeader(httpResponse, AD_TIMEOUT);
-
-        // Set the auto-refresh time. A timer will be scheduled upon ad success or failure.
-        if (!httpResponse.containsHeader(REFRESH_TIME.getKey())) {
-            mRefreshTimeMilliseconds = 0;
-        } else {
-            mRefreshTimeMilliseconds = extractIntHeader(httpResponse, REFRESH_TIME, 0) * 1000;
-            mRefreshTimeMilliseconds = Math.max(
-                    mRefreshTimeMilliseconds,
-                    MINIMUM_REFRESH_TIME_MILLISECONDS);
-        }
-
-        // Set the unique identifier for the creative that was returned.
-        mDspCreativeId = extractHeader(httpResponse, DSP_CREATIVE_ID);
-    }
-
-    /*
-     * MoPubView
-     */
-
-    String getAdUnitId() {
-        return mAdUnitId;
-    }
-
-    void setAdUnitId(String adUnitId) {
-        mAdUnitId = adUnitId;
-    }
-
-    String getResponseString() {
-        return mResponseString;
-    }
-
-    void setResponseString(String responseString) {
-        mResponseString = responseString;
-    }
-
-    long getBroadcastIdentifier() {
-        return mBroadcastIdentifier;
-    }
-
-    /*
-     * HttpResponse
-     */
-
-    String getAdType() {
-        return mAdType;
-    }
-
-    String getNetworkType() {
-        return mNetworkType;
-    }
-
-    String getRedirectUrl() {
-        return mRedirectUrl;
-    }
-
-    String getClickthroughUrl() {
-        return mClickthroughUrl;
-    }
-
-    @Deprecated
-    void setClickthroughUrl(String clickthroughUrl) {
-        mClickthroughUrl = clickthroughUrl;
-    }
-
-    String getFailUrl() {
-        return mFailUrl;
-    }
-
-    void setFailUrl(String failUrl) {
-        mFailUrl = failUrl;
-    }
-
-    String getImpressionUrl() {
-        return mImpressionUrl;
-    }
-
-    long getTimeStamp() {
-        return mTimeStamp;
-    }
-
-    int getWidth() {
-        return mWidth;
-    }
-
-    int getHeight() {
-        return mHeight;
-    }
-
-    Integer getAdTimeoutDelay() {
-        return mAdTimeoutDelay;
-    }
-
-    int getRefreshTimeMilliseconds() {
-        return mRefreshTimeMilliseconds;
-    }
-
-    @Deprecated
-    void setRefreshTimeMilliseconds(int refreshTimeMilliseconds) {
-        mRefreshTimeMilliseconds = refreshTimeMilliseconds;
-    }
-
-    String getDspCreativeId() {
-        return mDspCreativeId;
-    }
-
-    /*
-     * Context
-     */
-
-    String getHashedUdid() {
-        return mHashedUdid;
-    }
-
-    String getUserAgent() {
-        return mUserAgent;
-    }
-
-    String getDeviceLocale() {
-        return mDeviceLocale;
-    }
-
-    String getDeviceModel() {
-        return mDeviceModel;
-    }
-
-    int getPlatformVersion() {
-        return mPlatformVersion;
-    }
-
-    String getPlatform() {
-        return mPlatform;
-    }
-
-    /*
-     * Misc.
-     */
-
-    String getSdkVersion() {
-        return mSdkVersion;
-    }
-
-    private void setDefaults() {
-        mBroadcastIdentifier = 0;
-        mAdUnitId = null;
-        mResponseString = null;
-        mAdType = null;
-        mNetworkType = null;
-        mRedirectUrl = null;
-        mClickthroughUrl = null;
-        mImpressionUrl = null;
-        mTimeStamp = DateAndTime.now().getTime();
-        mWidth = 0;
-        mHeight = 0;
-        mAdTimeoutDelay = null;
-        mRefreshTimeMilliseconds = DEFAULT_REFRESH_TIME_MILLISECONDS;
-        mFailUrl = null;
-        mDspCreativeId = null;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
deleted file mode 100644
index 85875e25..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
+++ /dev/null
@@ -1,250 +0,0 @@
-package com.mopub.mobileads;
-
-import android.os.AsyncTask;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.conn.ClientConnectionManager;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
-import static com.mopub.common.util.ResponseHeader.WARMUP;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-
-public class AdFetchTask extends AsyncTask<String, Void, AdLoadTask> {
-    private TaskTracker mTaskTracker;
-    private AdViewController mAdViewController;
-    private Exception mException;
-    private HttpClient mHttpClient;
-    private long mTaskId;
-    private String mUserAgent;
-
-    private AdFetcher.FetchStatus mFetchStatus = AdFetcher.FetchStatus.NOT_SET;
-    private static final int MAXIMUM_REFRESH_TIME_MILLISECONDS = 600000;
-    private static final double EXPONENTIAL_BACKOFF_FACTOR = 1.5;
-
-    public AdFetchTask(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        mTaskTracker = taskTracker;
-
-        mAdViewController = adViewController;
-        mHttpClient = HttpClientFactory.create(timeoutMilliseconds);
-        mTaskId = mTaskTracker.getCurrentTaskId();
-        mUserAgent = userAgent;
-    }
-
-    @Override
-    protected AdLoadTask doInBackground(String... urls) {
-        AdLoadTask result = null;
-        try {
-            result = fetch(urls[0]);
-        } catch (Exception exception) {
-            mException = exception;
-        } finally {
-            shutdownHttpClient();
-        }
-        return result;
-    }
-
-    private AdLoadTask fetch(String url) throws Exception {
-        HttpGet httpget = new HttpGet(url);
-        httpget.addHeader(USER_AGENT.getKey(), mUserAgent);
-
-        if (!isStateValid()) return null;
-
-        HttpResponse response = mHttpClient.execute(httpget);
-
-        if (!isResponseValid(response)) return null;
-
-        mAdViewController.configureUsingHttpResponse(response);
-
-        if (!responseContainsContent(response)) return null;
-
-        return AdLoadTask.fromHttpResponse(response, mAdViewController);
-    }
-
-    private boolean responseContainsContent(HttpResponse response) {
-        // Ensure that the ad is not warming up.
-        if ("1".equals(extractHeader(response, WARMUP))) {
-            MoPubLog.d("Ad Unit (" + mAdViewController.getAdUnitId() + ") is still warming up. " +
-                    "Please try again in a few minutes.");
-            mFetchStatus = AdFetcher.FetchStatus.AD_WARMING_UP;
-            return false;
-        }
-
-        // Ensure that the ad type header is valid and not "clear".
-        String adType = extractHeader(response, AD_TYPE);
-        if ("clear".equals(adType)) {
-            MoPubLog.d("No ads found for adunit (" + mAdViewController.getAdUnitId() + ").");
-            mFetchStatus = AdFetcher.FetchStatus.CLEAR_AD_TYPE;
-            return false;
-        }
-
-        return true;
-    }
-
-    private boolean isResponseValid(HttpResponse response) {
-        if (response == null || response.getEntity() == null) {
-            MoPubLog.d("MoPub server returned null response.");
-            mFetchStatus = AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_NOBACKOFF;
-            return false;
-        }
-
-        final int statusCode = response.getStatusLine().getStatusCode();
-
-        // Client and Server HTTP errors should result in an exponential backoff
-        if (statusCode >= 400) {
-            MoPubLog.d("Server error: returned HTTP status code " + Integer.toString(statusCode) +
-                    ". Please try again.");
-            mFetchStatus = AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_BACKOFF;
-            return false;
-        }
-        // Other non-200 HTTP status codes should still fail
-        else if (statusCode != HttpStatus.SC_OK) {
-            MoPubLog.d("MoPub server returned invalid response: HTTP status code " +
-                    Integer.toString(statusCode) + ".");
-            mFetchStatus = AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_NOBACKOFF;
-            return false;
-        }
-        return true;
-    }
-
-    private boolean isStateValid() {
-        // We check to see if this AsyncTask was cancelled, as per
-        // http://developer.android.com/reference/android/os/AsyncTask.html
-        if (isCancelled()) {
-            mFetchStatus = AdFetcher.FetchStatus.FETCH_CANCELLED;
-            return false;
-        }
-
-        if (mAdViewController == null || mAdViewController.isDestroyed()) {
-            MoPubLog.d("Error loading ad: AdViewController has already been GCed or destroyed.");
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    protected void onPostExecute(AdLoadTask adLoadTask) {
-        if (!isMostCurrentTask()) {
-            MoPubLog.d("Ad response is stale.");
-            cleanup();
-            return;
-        }
-
-        // If cleanup() has already been called on the AdViewController, don't proceed.
-        if (mAdViewController == null || mAdViewController.isDestroyed()) {
-            if (adLoadTask != null) {
-                adLoadTask.cleanup();
-            }
-            mTaskTracker.markTaskCompleted(mTaskId);
-            cleanup();
-            return;
-        }
-
-        if (adLoadTask == null) {
-            if (mException != null) {
-                MoPubLog.d("Exception caught while loading ad: " + mException);
-            }
-
-            MoPubErrorCode errorCode;
-            switch (mFetchStatus) {
-                case NOT_SET:
-                    errorCode = MoPubErrorCode.UNSPECIFIED;
-                    break;
-                case FETCH_CANCELLED:
-                    errorCode = MoPubErrorCode.CANCELLED;
-                    break;
-                case INVALID_SERVER_RESPONSE_BACKOFF:
-                case INVALID_SERVER_RESPONSE_NOBACKOFF:
-                    errorCode = MoPubErrorCode.SERVER_ERROR;
-                    break;
-                case CLEAR_AD_TYPE:
-                case AD_WARMING_UP:
-                    errorCode = MoPubErrorCode.NO_FILL;
-                    break;
-                default:
-                    errorCode = MoPubErrorCode.UNSPECIFIED;
-                    break;
-            }
-
-            mAdViewController.adDidFail(errorCode);
-
-            /*
-             * There are numerous reasons for the ad fetch to fail, but only in the specific
-             * case of actual server failure should we exponentially back off.
-             *
-             * Note: We place the exponential backoff after AdViewController's adDidFail because we only
-             * want to increase refresh times after the first failure refresh timer is
-             * scheduled, and not before.
-             */
-            if (mFetchStatus == AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_BACKOFF) {
-                exponentialBackoff();
-                mFetchStatus = AdFetcher.FetchStatus.NOT_SET;
-            }
-        } else {
-            adLoadTask.execute();
-            adLoadTask.cleanup();
-        }
-
-        mTaskTracker.markTaskCompleted(mTaskId);
-        cleanup();
-    }
-
-    @Override
-    protected void onCancelled() {
-        if (!isMostCurrentTask()) {
-            MoPubLog.d("Ad response is stale.");
-            cleanup();
-            return;
-        }
-
-        MoPubLog.d("Ad loading was cancelled.");
-        if (mException != null) {
-            MoPubLog.d("Exception caught while loading ad: " + mException);
-        }
-        mTaskTracker.markTaskCompleted(mTaskId);
-        cleanup();
-    }
-
-    /* This helper function is called when a 4XX or 5XX error is received during an ad fetch.
-     * It exponentially increases the parent AdViewController's refreshTime up to a specified cap.
-     */
-    private void exponentialBackoff() {
-        if (mAdViewController == null) {
-            return;
-        }
-
-        int refreshTimeMilliseconds = mAdViewController.getRefreshTimeMilliseconds();
-
-        refreshTimeMilliseconds = (int) (refreshTimeMilliseconds * EXPONENTIAL_BACKOFF_FACTOR);
-        if (refreshTimeMilliseconds > MAXIMUM_REFRESH_TIME_MILLISECONDS) {
-            refreshTimeMilliseconds = MAXIMUM_REFRESH_TIME_MILLISECONDS;
-        }
-
-        mAdViewController.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
-    }
-
-    private void cleanup() {
-        mTaskTracker = null;
-        mException = null;
-        mFetchStatus = AdFetcher.FetchStatus.NOT_SET;
-    }
-
-    private void shutdownHttpClient() {
-        if (mHttpClient != null) {
-            ClientConnectionManager manager = mHttpClient.getConnectionManager();
-            if (manager != null) {
-                manager.shutdown();
-            }
-            mHttpClient = null;
-        }
-    }
-
-    private boolean isMostCurrentTask() {
-        // if we've been cleaned up already, then we're definitely not the current task
-        return (mTaskTracker == null) ? false : mTaskTracker.isMostCurrentTask(mTaskId);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
deleted file mode 100644
index 79486a06..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.mobileads.factories.AdFetchTaskFactory;
-
-/*
- * AdFetcher is a delegate of an AdViewController that handles loading ad data over a
- * network connection. The ad is fetched in a background thread by executing
- * AdFetchTask, which is an AsyncTask subclass. This class gracefully handles
- * the changes to AsyncTask in Android 4.0.1 (we continue to run parallel to
- * the app developer's background tasks). Further, AdFetcher keeps track of
- * the last completed task to prevent out-of-order execution.
- */
-public class AdFetcher {
-    public static final String HTML_RESPONSE_BODY_KEY = "Html-Response-Body";
-    public static final String REDIRECT_URL_KEY = "Redirect-Url";
-    public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
-    public static final String SCROLLABLE_KEY = "Scrollable";
-    public static final String AD_CONFIGURATION_KEY = "Ad-Configuration";
-
-    private int mTimeoutMilliseconds = 10000;
-    private AdViewController mAdViewController;
-
-    private AdFetchTask mCurrentTask;
-    private String mUserAgent;
-    private final TaskTracker mTaskTracker;
-
-    enum FetchStatus {
-        NOT_SET,
-        FETCH_CANCELLED,
-        INVALID_SERVER_RESPONSE_BACKOFF,
-        INVALID_SERVER_RESPONSE_NOBACKOFF,
-        CLEAR_AD_TYPE,
-        AD_WARMING_UP;
-    }
-
-    public AdFetcher(AdViewController adview, String userAgent) {
-        mAdViewController = adview;
-        mUserAgent = userAgent;
-        mTaskTracker = new TaskTracker();
-    }
-
-    public void fetchAdForUrl(String url) {
-        mTaskTracker.newTaskStarted();
-        MoPubLog.i("Fetching ad for task #" + getCurrentTaskId());
-
-        if (mCurrentTask != null) {
-            mCurrentTask.cancel(true);
-        }
-
-        mCurrentTask = AdFetchTaskFactory.create(mTaskTracker, mAdViewController, mUserAgent, mTimeoutMilliseconds);
-
-        try {
-            AsyncTasks.safeExecuteOnExecutor(mCurrentTask, url);
-        } catch (Exception exception) {
-            MoPubLog.d("Error executing AdFetchTask", exception);
-        }
-    }
-
-    public void cancelFetch() {
-        if (mCurrentTask != null) {
-            MoPubLog.i("Canceling fetch ad for task #" + getCurrentTaskId());
-            mCurrentTask.cancel(true);
-        }
-    }
-
-    void cleanup() {
-        cancelFetch();
-
-        mAdViewController = null;
-        mUserAgent = "";
-    }
-
-    protected void setTimeout(int milliseconds) {
-        mTimeoutMilliseconds = milliseconds;
-    }
-
-    private long getCurrentTaskId() {
-        return mTaskTracker.getCurrentTaskId();
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
deleted file mode 100644
index cb379e71..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
+++ /dev/null
@@ -1,240 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.net.Uri;
-
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
-import com.mopub.common.util.Strings;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-
-import java.io.*;
-import java.lang.ref.WeakReference;
-import java.lang.reflect.Method;
-import java.util.*;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_SELECTOR;
-import static com.mopub.common.util.ResponseHeader.FULL_AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.SCROLLABLE;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
-import static com.mopub.mobileads.util.HttpResponses.extractBooleanHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-
-abstract class AdLoadTask {
-    WeakReference<AdViewController> mWeakAdViewController;
-    AdLoadTask(AdViewController adViewController) {
-        mWeakAdViewController = new WeakReference<AdViewController>(adViewController);
-    }
-
-    abstract void execute();
-
-    /*
-     * The AsyncTask thread pool often appears to keep references to these
-     * objects, preventing GC. This method should be used to release
-     * resources to mitigate the GC issue.
-     */
-    abstract void cleanup();
-
-    static AdLoadTask fromHttpResponse(HttpResponse response, AdViewController adViewController) throws IOException {
-        return new TaskExtractor(response, adViewController).extract();
-    }
-
-    private static class TaskExtractor {
-        private final HttpResponse response;
-        private final AdViewController adViewController;
-        private String adType;
-        private String adTypeCustomEventName;
-        private String fullAdType;
-
-        TaskExtractor(HttpResponse response, AdViewController adViewController){
-            this.response = response;
-            this.adViewController = adViewController;
-        }
-
-        AdLoadTask extract() throws IOException {
-            adType = extractHeader(response, AD_TYPE);
-            fullAdType = extractHeader(response, FULL_AD_TYPE);
-
-            MoPubLog.d("Loading ad type: " + AdTypeTranslator.getAdNetworkType(adType, fullAdType));
-
-            adTypeCustomEventName = AdTypeTranslator.getCustomEventNameForAdType(
-                    adViewController.getMoPubView(), adType, fullAdType);
-
-            if ("custom".equals(adType)) {
-                return extractCustomEventAdLoadTask();
-            } else if (eventDataIsInResponseBody(adType)) {
-                return extractCustomEventAdLoadTaskFromResponseBody();
-            } else {
-                return extractCustomEventAdLoadTaskFromNativeParams();
-            }
-        }
-
-        private AdLoadTask extractCustomEventAdLoadTask() {
-            MoPubLog.i("Performing custom event.");
-
-            // If applicable, try to invoke the new custom event system (which uses custom classes)
-            adTypeCustomEventName = extractHeader(response, CUSTOM_EVENT_NAME);
-            if (adTypeCustomEventName != null) {
-                String customEventData = extractHeader(response, CUSTOM_EVENT_DATA);
-                return createCustomEventAdLoadTask(customEventData);
-            }
-
-            // Otherwise, use the (deprecated) legacy custom event system for older clients
-            Header oldCustomEventHeader = response.getFirstHeader(CUSTOM_SELECTOR.getKey());
-            return new AdLoadTask.LegacyCustomEventAdLoadTask(adViewController, oldCustomEventHeader);
-        }
-
-        private AdLoadTask extractCustomEventAdLoadTaskFromResponseBody() throws IOException {
-            HttpEntity entity = response.getEntity();
-            String htmlData = entity != null ? Strings.fromStream(entity.getContent()) : "";
-
-            adViewController.getAdConfiguration().setResponseString(htmlData);
-
-            String redirectUrl = extractHeader(response, REDIRECT_URL);
-            String clickthroughUrl = extractHeader(response, CLICKTHROUGH_URL);
-            boolean scrollingEnabled = extractBooleanHeader(response, SCROLLABLE, false);
-
-            Map<String, String> eventDataMap = new HashMap<String, String>();
-            eventDataMap.put(HTML_RESPONSE_BODY_KEY, Uri.encode(htmlData));
-            eventDataMap.put(SCROLLABLE_KEY, Boolean.toString(scrollingEnabled));
-            if (redirectUrl != null) {
-                eventDataMap.put(REDIRECT_URL_KEY, redirectUrl);
-            }
-            if (clickthroughUrl != null) {
-                eventDataMap.put(CLICKTHROUGH_URL_KEY, clickthroughUrl);
-            }
-
-            String eventData = Json.mapToJsonString(eventDataMap);
-            return createCustomEventAdLoadTask(eventData);
-        }
-
-        private AdLoadTask extractCustomEventAdLoadTaskFromNativeParams() throws IOException {
-            String eventData = extractHeader(response, NATIVE_PARAMS);
-
-            return createCustomEventAdLoadTask(eventData);
-        }
-
-        private AdLoadTask createCustomEventAdLoadTask(String customEventData) {
-            Map<String, String> paramsMap = new HashMap<String, String>();
-            paramsMap.put(CUSTOM_EVENT_NAME.getKey(), adTypeCustomEventName);
-
-            if (customEventData != null) {
-                paramsMap.put(CUSTOM_EVENT_DATA.getKey(), customEventData);
-            }
-
-            return new AdLoadTask.CustomEventAdLoadTask(adViewController, paramsMap);
-        }
-
-        private boolean eventDataIsInResponseBody(String adType) {
-            // XXX Hack
-            return "mraid".equals(adType) || "html".equals(adType) || ("interstitial".equals(adType) && "vast".equals(fullAdType));
-        }
-    }
-
-    /*
-     * This is the new way of performing Custom Events. This will be invoked on new clients when
-     * X-Adtype is "custom" and the X-Custom-Event-Class-Name header is specified.
-     */
-    static class CustomEventAdLoadTask extends AdLoadTask {
-        private Map<String,String> mParamsMap;
-
-        public CustomEventAdLoadTask(AdViewController adViewController, Map<String, String> paramsMap) {
-            super(adViewController);
-            mParamsMap = paramsMap;
-        }
-
-        @Override
-        void execute() {
-            AdViewController adViewController = mWeakAdViewController.get();
-
-            if (adViewController == null || adViewController.isDestroyed()) {
-                return;
-            }
-
-            adViewController.setNotLoading();
-            adViewController.getMoPubView().loadCustomEvent(mParamsMap);
-        }
-
-        @Override
-        void cleanup() {
-            mParamsMap = null;
-        }
-
-        @Deprecated // for testing
-        Map<String, String> getParamsMap() {
-            return mParamsMap;
-        }
-    }
-
-    /*
-     * This is the old way of performing Custom Events, and is now deprecated. This will still be
-     * invoked on old clients when X-Adtype is "custom" and the new X-Custom-Event-Class-Name header
-     * is not specified (legacy custom events parse the X-Customselector header instead).
-     */
-    @Deprecated
-    static class LegacyCustomEventAdLoadTask extends AdLoadTask {
-        private Header mHeader;
-
-        public LegacyCustomEventAdLoadTask(AdViewController adViewController, Header header) {
-            super(adViewController);
-            mHeader = header;
-        }
-
-        @Override
-        void execute() {
-            AdViewController adViewController = mWeakAdViewController.get();
-            if (adViewController == null || adViewController.isDestroyed()) {
-                return;
-            }
-
-            adViewController.setNotLoading();
-            MoPubView mpv = adViewController.getMoPubView();
-
-            if (mHeader == null) {
-                MoPubLog.i("Couldn't call custom method because the server did not specify one.");
-                mpv.loadFailUrl(MoPubErrorCode.ADAPTER_NOT_FOUND);
-                return;
-            }
-
-            String methodName = mHeader.getValue();
-            MoPubLog.i("Trying to call method named " + methodName);
-
-            Class<? extends Activity> c;
-            Method method;
-            Activity userActivity = mpv.getActivity();
-            try {
-                c = userActivity.getClass();
-                method = c.getMethod(methodName, MoPubView.class);
-                method.invoke(userActivity, mpv);
-            } catch (NoSuchMethodException e) {
-                MoPubLog.d("Couldn't perform custom method named " + methodName +
-                        "(MoPubView view) because your activity class has no such method");
-                mpv.loadFailUrl(MoPubErrorCode.ADAPTER_NOT_FOUND);
-            } catch (Exception e) {
-                MoPubLog.d("Couldn't perform custom method named " + methodName);
-                mpv.loadFailUrl(MoPubErrorCode.ADAPTER_NOT_FOUND);
-            }
-        }
-
-        @Override
-        void cleanup() {
-            mHeader = null;
-        }
-
-        @Deprecated // for testing
-        Header getHeader() {
-            return mHeader;
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java
new file mode 100644
index 00000000..3b0e073c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java
@@ -0,0 +1,72 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.AdResponse;
+
+import java.lang.ref.WeakReference;
+import java.util.Map;
+
+abstract class AdLoader {
+
+    WeakReference<AdViewController> mWeakAdViewController;
+    AdLoader(AdViewController adViewController) {
+        mWeakAdViewController = new WeakReference<AdViewController>(adViewController);
+    }
+
+    abstract void load();
+
+    @Nullable
+    static AdLoader fromAdResponse(AdResponse response, AdViewController adViewController) {
+        MoPubLog.i("Performing custom event.");
+
+        // If applicable, try to invoke the new custom event system (which uses custom classes)
+        String adTypeCustomEventName = response.getCustomEventClassName();
+        if (adTypeCustomEventName != null) {
+            Map<String, String> customEventData = response.getServerExtras();
+            return new CustomEventAdLoader(adViewController, adTypeCustomEventName, customEventData);
+        }
+
+        MoPubLog.i("Failed to create custom event.");
+        return null;
+    }
+
+    static class CustomEventAdLoader extends AdLoader {
+        private String mCustomEventClassName;
+        private Map<String,String> mServerExtras;
+
+        public CustomEventAdLoader(AdViewController adViewController,
+                String customEventCLassName,
+                Map<String, String> serverExtras) {
+            super(adViewController);
+            mCustomEventClassName = customEventCLassName;
+            mServerExtras = serverExtras;
+        }
+
+        @Override
+        void load() {
+            AdViewController adViewController = mWeakAdViewController.get();
+            if (adViewController == null
+                    || adViewController.isDestroyed()
+                    || TextUtils.isEmpty(mCustomEventClassName)) {
+                return;
+            }
+            adViewController.setNotLoading();
+
+            final MoPubView moPubView = adViewController.getMoPubView();
+            if (moPubView == null) {
+                MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
+                return;
+            }
+            moPubView.loadCustomEvent(mCustomEventClassName, mServerExtras);
+        }
+
+        @VisibleForTesting
+        Map<String, String> getServerExtras() {
+            return mServerExtras;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java
new file mode 100644
index 00000000..10d6625b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java
@@ -0,0 +1,199 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.AdRequest;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+public class AdRequestStatusMapping {
+    @NonNull
+    private final Map<String, AdRequestStatus> mAdUnitToAdRequestStatus;
+
+    public AdRequestStatusMapping() {
+        mAdUnitToAdRequestStatus = new TreeMap<String, AdRequestStatus>();
+    }
+
+    void markFail(@NonNull final String adUnitId) {
+        mAdUnitToAdRequestStatus.remove(adUnitId);
+    }
+
+    void markLoading(@NonNull final String adUnitId) {
+        mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(LoadingStatus.LOADING));
+    }
+
+    void markLoaded(
+            @NonNull final String adUnitId,
+            @Nullable final String failUrlString,
+            @Nullable final String impressionTrackerUrlString,
+            @Nullable final String clickTrackerUrlString) {
+        mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(
+                LoadingStatus.LOADED,
+                failUrlString,
+                impressionTrackerUrlString,
+                clickTrackerUrlString));
+    }
+
+    void markPlayed(@NonNull final String adUnitId) {
+        // If possible, attempt to keep the URL fields in AdRequestStatus
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            final AdRequestStatus adRequestStatus = mAdUnitToAdRequestStatus.get(adUnitId);
+            adRequestStatus.setStatus(LoadingStatus.PLAYED);
+        } else {
+            mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(LoadingStatus.PLAYED));
+        }
+    }
+
+    boolean canPlay(@NonNull final String adUnitId) {
+        final AdRequestStatus adRequestStatus = mAdUnitToAdRequestStatus.get(adUnitId);
+        return adRequestStatus != null
+            && LoadingStatus.LOADED.equals(adRequestStatus.getStatus());
+    }
+
+    boolean isLoading(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return false;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getStatus() == LoadingStatus.LOADING;
+    }
+
+    @Nullable String getFailoverUrl(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getFailurl();
+    }
+
+    @Nullable String getImpressionTrackerUrlString(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getImpressionUrl();
+    }
+
+    @Nullable String getClickTrackerUrlString(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getClickUrl();
+    }
+
+    void clearImpressionUrl(@NonNull final String adUnitId) {
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            mAdUnitToAdRequestStatus.get(adUnitId).setImpressionUrl(null);
+        }
+    }
+
+    void clearClickUrl(@NonNull final String adUnitId) {
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            mAdUnitToAdRequestStatus.get(adUnitId).setClickUrl(null);
+        }
+    }
+
+    private static enum LoadingStatus { LOADING, LOADED, PLAYED }
+    private static class AdRequestStatus {
+        @NonNull
+        private LoadingStatus mLoadingStatus;
+        @Nullable
+        private String mFailUrl;
+        @Nullable
+        private String mImpressionUrl;
+        @Nullable
+        private String mClickUrl;
+
+        public AdRequestStatus(@NonNull final LoadingStatus loadingStatus) {
+            this(loadingStatus, null, null, null);
+        }
+
+        public AdRequestStatus(
+                @NonNull final LoadingStatus loadingStatus,
+                @Nullable final String failUrl,
+                @Nullable final String impressionUrl,
+                @Nullable final String clickUrl) {
+            Preconditions.checkNotNull(loadingStatus);
+
+            mLoadingStatus = loadingStatus;
+            mFailUrl = failUrl;
+            mImpressionUrl = impressionUrl;
+            mClickUrl = clickUrl;
+        }
+
+        @NonNull
+        private LoadingStatus getStatus() {
+            return mLoadingStatus;
+        }
+
+        private void setStatus(@NonNull final LoadingStatus loadingStatus) {
+            mLoadingStatus = loadingStatus;
+        }
+
+        @Nullable
+        private String getFailurl() {
+            return mFailUrl;
+        }
+
+        @Nullable
+        private String getImpressionUrl() {
+            return mImpressionUrl;
+        }
+
+        private void setImpressionUrl(@Nullable final String impressionUrl) {
+            mImpressionUrl = impressionUrl;
+        }
+
+        @Nullable
+        private String getClickUrl() {
+            return mClickUrl;
+        }
+
+        private void setClickUrl(@Nullable final String clickUrl) {
+            mClickUrl = clickUrl;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o == null) {
+                return false;
+            }
+
+            if (this == o) {
+                return true;
+            }
+
+            if (!(o instanceof AdRequestStatus)) {
+                return false;
+            }
+
+            final AdRequestStatus that = (AdRequestStatus) o;
+
+            return this.mLoadingStatus.equals(that.mLoadingStatus) &&
+                    TextUtils.equals(this.mFailUrl, that.mFailUrl) &&
+                    TextUtils.equals(this.mImpressionUrl, that.mImpressionUrl) &&
+                    TextUtils.equals(this.mClickUrl, that.mClickUrl);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = 29;
+            result = 31 * result + mLoadingStatus.ordinal();
+            result = 31 * result + (mFailUrl != null
+                    ? mFailUrl.hashCode()
+                    : 0);
+            result = 31 * result + (mImpressionUrl != null
+                    ? mImpressionUrl.hashCode()
+                    : 0);
+            result = 31 * result + (mClickUrl != null
+                    ? mClickUrl.hashCode()
+                    : 0);
+            return result;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index 2ac1f294..f2d5e8c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -1,18 +1,31 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.util.ResponseHeader;
+
+import java.util.Map;
+
+import static com.mopub.network.HeaderUtils.extractHeader;
+
 public class AdTypeTranslator {
     public enum CustomEventType {
-        // With the deprecation of a standalone AdMob SDK, these now point to Google Play Services
+        // "Special" custom events that we let people choose in the UI.
         GOOGLE_PLAY_SERVICES_BANNER("admob_native_banner", "com.mopub.mobileads.GooglePlayServicesBanner"),
         GOOGLE_PLAY_SERVICES_INTERSTITIAL("admob_full_interstitial", "com.mopub.mobileads.GooglePlayServicesInterstitial"),
-
         MILLENNIAL_BANNER("millennial_native_banner", "com.mopub.mobileads.MillennialBanner"),
         MILLENNIAL_INTERSTITIAL("millennial_full_interstitial", "com.mopub.mobileads.MillennialInterstitial"),
-        MRAID_BANNER("mraid_banner", "com.mopub.mobileads.MraidBanner"),
-        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mobileads.MraidInterstitial"),
+
+        // MoPub-specific custom events.
+        MRAID_BANNER("mraid_banner", "com.mopub.mraid.MraidBanner"),
+        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mraid.MraidInterstitial"),
         HTML_BANNER("html_banner", "com.mopub.mobileads.HtmlBanner"),
         HTML_INTERSTITIAL("html_interstitial", "com.mopub.mobileads.HtmlInterstitial"),
         VAST_VIDEO_INTERSTITIAL("vast_interstitial", "com.mopub.mobileads.VastVideoInterstitial"),
+        MOPUB_NATIVE("mopub_native", "com.mopub.nativeads.MoPubCustomEventNative"),
 
         UNSPECIFIED("", null);
 
@@ -40,28 +53,30 @@ public String toString() {
         }
     }
 
+    public static final String BANNER_SUFFIX = "_banner";
+    public static final String INTERSTITIAL_SUFFIX = "_interstitial";
+
     static String getAdNetworkType(String adType, String fullAdType) {
-        String adNetworkType = "interstitial".equals(adType) ? fullAdType : adType;
+        String adNetworkType = AdType.INTERSTITIAL.equals(adType) ? fullAdType : adType;
         return adNetworkType != null ? adNetworkType : "unknown";
     }
 
-    static String getCustomEventNameForAdType(MoPubView moPubView, String adType, String fullAdType) {
-        CustomEventType customEventType;
-
-        if ("html".equals(adType) || "mraid".equals(adType)) {
-            customEventType = (isInterstitial(moPubView))
-                    ? CustomEventType.fromString(adType + "_interstitial")
-                    : CustomEventType.fromString(adType + "_banner");
+    public static String getCustomEventName(@NonNull AdFormat adFormat,
+            @NonNull String adType,
+            @Nullable String fullAdType,
+            @NonNull Map<String, String> headers) {
+        if (AdType.CUSTOM.equalsIgnoreCase(adType)) {
+            return extractHeader(headers, ResponseHeader.CUSTOM_EVENT_NAME);
+        } else if (AdType.NATIVE.equalsIgnoreCase(adType)){
+            return CustomEventType.MOPUB_NATIVE.toString();
+        } else if (AdType.HTML.equalsIgnoreCase(adType) || AdType.MRAID.equalsIgnoreCase(adType)) {
+            return (AdFormat.INTERSTITIAL.equals(adFormat)
+                    ? CustomEventType.fromString(adType + INTERSTITIAL_SUFFIX)
+                    : CustomEventType.fromString(adType + BANNER_SUFFIX)).toString();
+        } else if (AdType.INTERSTITIAL.equalsIgnoreCase(adType)) {
+            return CustomEventType.fromString(fullAdType + INTERSTITIAL_SUFFIX).toString();
         } else {
-            customEventType = ("interstitial".equals(adType))
-                    ? CustomEventType.fromString(fullAdType + "_interstitial")
-                    : CustomEventType.fromString(adType + "_banner");
+            return CustomEventType.fromString(adType + BANNER_SUFFIX).toString();
         }
-
-        return customEventType.toString();
-    }
-
-    private static boolean isInterstitial(MoPubView moPubView) {
-        return moPubView instanceof MoPubInterstitial.MoPubInterstitialView;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index e1d33ec6..a049e317 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -6,51 +6,75 @@
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Handler;
-import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Log;
 import android.view.Gravity;
 import android.view.View;
 import android.widget.FrameLayout;
 
-import com.mopub.common.GpsHelper;
-import com.mopub.common.MoPub;
+import com.mopub.common.AdReport;
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Dips;
-import com.mopub.mobileads.factories.AdFetcherFactory;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
-
-import java.util.*;
+import com.mopub.common.util.Utils;
+import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.WeakHashMap;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.common.GpsHelper.GpsHelperListener;
-import static com.mopub.common.LocationService.getLastKnownLocation;
 
 public class AdViewController {
-    static final int MINIMUM_REFRESH_TIME_MILLISECONDS = 10000;
-    static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;
+    static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;  // 1 minute
+    static final int MAX_REFRESH_TIME_MILLISECONDS = 600000; // 10 minutes
+    static final double BACKOFF_FACTOR = 1.5;
     private static final FrameLayout.LayoutParams WRAP_AND_CENTER_LAYOUT_PARAMS =
             new FrameLayout.LayoutParams(
                     FrameLayout.LayoutParams.WRAP_CONTENT,
                     FrameLayout.LayoutParams.WRAP_CONTENT,
                     Gravity.CENTER);
-    private static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();;
+    private final static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();
+
+    private final long mBroadcastIdentifier;
 
-    private final Context mContext;
-    private GpsHelperListener mGpsHelperListener;
+    @Nullable
+    private Context mContext;
+    @Nullable
     private MoPubView mMoPubView;
-    private final WebViewAdUrlGenerator mUrlGenerator;
-    private AdFetcher mAdFetcher;
-    private AdConfiguration mAdConfiguration;
+    @Nullable
+    private WebViewAdUrlGenerator mUrlGenerator;
+
+    @Nullable
+    private AdResponse mAdResponse;
     private final Runnable mRefreshRunnable;
+    @NonNull
+    private final AdRequest.Listener mAdListener;
 
     private boolean mIsDestroyed;
     private Handler mHandler;
     private boolean mIsLoading;
     private String mUrl;
 
+    // This is the power of the exponential term in the exponential backoff calculation.
+    @VisibleForTesting
+    int mBackoffPower = 1;
+
     private Map<String, Object> mLocalExtras = new HashMap<String, Object>();
     private boolean mAutoRefreshEnabled = true;
     private boolean mPreviousAutoRefreshSetting = true;
@@ -58,8 +82,15 @@
     private Location mLocation;
     private boolean mIsTesting;
     private boolean mAdWasLoaded;
-
-    protected static void setShouldHonorServerDimensions(View view) {
+    @Nullable
+    private String mAdUnitId;
+    private int mTimeoutMilliseconds;
+    @Nullable
+    private AdRequest mActiveRequest;
+    @Nullable
+    private Integer mRefreshTimeMillis;
+
+    public static void setShouldHonorServerDimensions(View view) {
         sViewShouldHonorServerDimensions.put(view, true);
     }
 
@@ -67,36 +98,127 @@ private static boolean getShouldHonorServerDimensions(View view) {
         return sViewShouldHonorServerDimensions.get(view) != null;
     }
 
-    public AdViewController(Context context, MoPubView view) {
+    public AdViewController(@NonNull Context context, @NonNull MoPubView view) {
         mContext = context;
         mMoPubView = view;
 
-        mUrlGenerator = new WebViewAdUrlGenerator(context);
-        mAdConfiguration = new AdConfiguration(mContext);
+        // Default timeout means "never refresh"
+        mTimeoutMilliseconds = -1;
+        mBroadcastIdentifier = Utils.generateUniqueId();
 
-        mAdFetcher = AdFetcherFactory.create(this, mAdConfiguration.getUserAgent());
+        mUrlGenerator = new WebViewAdUrlGenerator(mContext.getApplicationContext(),
+                MraidNativeCommandHandler.isStorePictureSupported(mContext));
 
-        mGpsHelperListener = new AdViewControllerGpsHelperListener();
+        mAdListener = new AdRequest.Listener() {
+            @Override
+            public void onSuccess(final AdResponse response) {
+                onAdLoadSuccess(response);
+            }
 
-        GpsHelper.fetchAdvertisingInfoAsync(mContext, null);
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                onAdLoadError(volleyError);
+            }
+        };
 
         mRefreshRunnable = new Runnable() {
             public void run() {
-                loadAd();
+                internalLoadAd();
             }
         };
+        mRefreshTimeMillis = DEFAULT_REFRESH_TIME_MILLISECONDS;
+        mHandler = new Handler();
+    }
+
+    @VisibleForTesting
+    void onAdLoadSuccess(@NonNull final AdResponse adResponse) {
+        mBackoffPower = 1;
+        mAdResponse = adResponse;
+        // Do other ad loading setup. See AdFetcher & AdLoadTask.
+        mTimeoutMilliseconds = mAdResponse.getAdTimeoutMillis() == null
+                ? mTimeoutMilliseconds
+                : mAdResponse.getAdTimeoutMillis();
+        mRefreshTimeMillis = mAdResponse.getRefreshTimeMillis();
+        setNotLoading();
 
-        mHandler = new Handler(Looper.getMainLooper());
+        // Get our custom event from the ad response and load into the view.
+        AdLoader adLoader = AdLoader.fromAdResponse(mAdResponse, this);
+        if (adLoader != null) {
+            adLoader.load();
+        }
+        scheduleRefreshTimerIfEnabled();
     }
 
+    @VisibleForTesting
+    void onAdLoadError(final VolleyError error) {
+        if (error instanceof MoPubNetworkError) {
+            // If provided, the MoPubNetworkError's refresh time takes precedence over the
+            // previously set refresh time.
+            // The only types of NetworkErrors that can possibly modify
+            // an ad's refresh time are CLEAR requests. For CLEAR requests that (erroneously) omit a
+            // refresh time header and for all other non-CLEAR types of NetworkErrors, we simply
+            // maintain the previous refresh time value.
+            final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) error;
+            if (moPubNetworkError.getRefreshTimeMillis() != null) {
+                mRefreshTimeMillis = moPubNetworkError.getRefreshTimeMillis();
+            }
+        }
+
+        final MoPubErrorCode errorCode = getErrorCodeFromVolleyError(error, mContext);
+        if (errorCode == MoPubErrorCode.SERVER_ERROR) {
+            mBackoffPower++;
+        }
+
+        setNotLoading();
+        adDidFail(errorCode);
+    }
+
+    @VisibleForTesting
+    @NonNull
+    static MoPubErrorCode getErrorCodeFromVolleyError(@NonNull final VolleyError error,
+            @Nullable final Context context) {
+        final NetworkResponse networkResponse = error.networkResponse;
+
+        // For MoPubNetworkErrors, networkResponse is null.
+        if (error instanceof MoPubNetworkError) {
+            switch (((MoPubNetworkError) error).getReason()) {
+                case WARMING_UP:
+                    return MoPubErrorCode.WARMUP;
+                case NO_FILL:
+                    return MoPubErrorCode.NO_FILL;
+                default:
+                    return MoPubErrorCode.UNSPECIFIED;
+            }
+        }
+
+        if (networkResponse == null) {
+            if (!DeviceUtils.isNetworkAvailable(context)) {
+                return MoPubErrorCode.NO_CONNECTION;
+            }
+            return MoPubErrorCode.UNSPECIFIED;
+        }
+
+        if (error.networkResponse.statusCode >= 400) {
+            return MoPubErrorCode.SERVER_ERROR;
+        }
+
+        return MoPubErrorCode.UNSPECIFIED;
+    }
+
+    @Nullable
     public MoPubView getMoPubView() {
         return mMoPubView;
     }
 
     public void loadAd() {
+        mBackoffPower = 1;
+        internalLoadAd();
+    }
+
+    private void internalLoadAd() {
         mAdWasLoaded = true;
-        if (mAdConfiguration.getAdUnitId() == null) {
-            MoPubLog.d("Can't load an ad in this ad view because the ad unit ID is null. " +
+        if (TextUtils.isEmpty(mAdUnitId)) {
+            MoPubLog.d("Can't load an ad in this ad view because the ad unit ID is not set. " +
                     "Did you forget to call setAdUnitId()?");
             return;
         }
@@ -107,16 +229,8 @@ public void loadAd() {
             return;
         }
 
-        if (mLocation == null) {
-            mLocation = getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-
-        // If we have access to Google Play Services (GPS) but the advertising info
-        // is not cached then guarantee we get it before building the ad request url
-        // in the callback, this is a requirement from Google
-        GpsHelper.fetchAdvertisingInfoAsync(mContext, mGpsHelperListener);
+        String adUrl = generateAdUrl();
+        loadNonJavascript(adUrl);
     }
 
     void loadNonJavascript(String url) {
@@ -124,14 +238,13 @@ void loadNonJavascript(String url) {
 
         MoPubLog.d("Loading url: " + url);
         if (mIsLoading) {
-            if (mAdConfiguration.getAdUnitId() != null) {
-                MoPubLog.i("Already loading an ad for " + mAdConfiguration.getAdUnitId() + ", wait to finish.");
+            if (!TextUtils.isEmpty(mAdUnitId)) {  // This shouldn't be able to happen?
+                MoPubLog.i("Already loading an ad for " + mAdUnitId + ", wait to finish.");
             }
             return;
         }
 
         mUrl = url;
-        mAdConfiguration.setFailUrl(null);
         mIsLoading = true;
 
         fetchAd(mUrl);
@@ -147,21 +260,29 @@ void loadFailUrl(MoPubErrorCode errorCode) {
 
         Log.v("MoPub", "MoPubErrorCode: " + (errorCode == null ? "" : errorCode.toString()));
 
-        if (mAdConfiguration.getFailUrl() != null) {
-            MoPubLog.d("Loading failover url: " + mAdConfiguration.getFailUrl());
-            loadNonJavascript(mAdConfiguration.getFailUrl());
+        final String failUrl = mAdResponse == null ? "" : mAdResponse.getFailoverUrl();
+        if (!TextUtils.isEmpty(failUrl)) {
+            MoPubLog.d("Loading failover url: " + failUrl);
+            loadNonJavascript(failUrl);
         } else {
             // No other URLs to try, so signal a failure.
             adDidFail(MoPubErrorCode.NO_FILL);
         }
     }
 
+    @Deprecated
     void setFailUrl(String failUrl) {
-        mAdConfiguration.setFailUrl(failUrl);
+        // Does nothing.
     }
 
     void setNotLoading() {
         this.mIsLoading = false;
+        if (mActiveRequest != null) {
+            if (!mActiveRequest.isCanceled()) {
+                mActiveRequest.cancel();
+            }
+            mActiveRequest = null;
+        }
     }
 
     public String getKeywords() {
@@ -181,37 +302,50 @@ public void setLocation(Location location) {
     }
 
     public String getAdUnitId() {
-        return mAdConfiguration.getAdUnitId();
+        return mAdUnitId;
+    }
+
+    public void setAdUnitId(@NonNull String adUnitId) {
+        mAdUnitId = adUnitId;
     }
 
-    public void setAdUnitId(String adUnitId) {
-        mAdConfiguration.setAdUnitId(adUnitId);
+    public long getBroadcastIdentifier() {
+        return mBroadcastIdentifier;
     }
 
     public void setTimeout(int milliseconds) {
-        if (mAdFetcher != null) {
-            mAdFetcher.setTimeout(milliseconds);
-        }
+       mTimeoutMilliseconds = milliseconds;
     }
 
     public int getAdWidth() {
-        return mAdConfiguration.getWidth();
+        if (mAdResponse != null && mAdResponse.getWidth() != null) {
+            return mAdResponse.getWidth();
+        }
+
+        return 0;
     }
 
     public int getAdHeight() {
-        return mAdConfiguration.getHeight();
+        if (mAdResponse != null && mAdResponse.getHeight() != null) {
+            return mAdResponse.getHeight();
+        }
+
+        return 0;
     }
 
-    public String getClickthroughUrl() {
-        return mAdConfiguration.getClickthroughUrl();
+    @Deprecated
+    public String getClickTrackingUrl() {
+        return mAdResponse == null ? null : mAdResponse.getClickTrackingUrl();
     }
 
+    @Deprecated
     public String getRedirectUrl() {
-        return mAdConfiguration.getRedirectUrl();
+        return mAdResponse == null ? null : mAdResponse.getRedirectUrl();
     }
 
+    @Deprecated
     public String getResponseString() {
-        return mAdConfiguration.getResponseString();
+        return mAdResponse == null ? null : mAdResponse.getStringBody();
     }
 
     public boolean getAutorefreshEnabled() {
@@ -236,9 +370,7 @@ private void setAutorefreshEnabled(boolean enabled) {
         final boolean autorefreshChanged = mAdWasLoaded && (mAutoRefreshEnabled != enabled);
         if (autorefreshChanged) {
             final String enabledString = (enabled) ? "enabled" : "disabled";
-            final String adUnitId = (mAdConfiguration != null) ? mAdConfiguration.getAdUnitId() : null;
-
-            MoPubLog.d("Refresh " + enabledString + " for ad unit (" + adUnitId + ").");
+            MoPubLog.d("Refresh " + enabledString + " for ad unit (" + mAdUnitId + ").");
         }
 
         mAutoRefreshEnabled = enabled;
@@ -249,6 +381,14 @@ private void setAutorefreshEnabled(boolean enabled) {
         }
     }
 
+    @Nullable
+    public AdReport getAdReport() {
+        if (mAdUnitId != null && mAdResponse != null) {
+            return new AdReport(mAdUnitId, ClientMetadata.getInstance(mContext), mAdResponse);
+        }
+        return null;
+    }
+
     public boolean getTesting() {
         return mIsTesting;
     }
@@ -257,8 +397,9 @@ public void setTesting(boolean enabled) {
         mIsTesting = enabled;
     }
 
-    AdConfiguration getAdConfiguration() {
-        return mAdConfiguration;
+    @Deprecated
+    Object getAdConfiguration() {
+        return null;
     }
 
     boolean isDestroyed() {
@@ -273,84 +414,60 @@ void cleanup() {
             return;
         }
 
+        if (mActiveRequest != null) {
+            mActiveRequest.cancel();
+            mActiveRequest = null;
+        }
+
         setAutorefreshEnabled(false);
         cancelRefreshTimer();
 
         // WebView subclasses are not garbage-collected in a timely fashion on Froyo and below,
         // thanks to some persistent references in WebViewCore. We manually release some resources
         // to compensate for this "leak".
-
-        mAdFetcher.cleanup();
-        mAdFetcher = null;
-
-        mAdConfiguration.cleanup();
-
         mMoPubView = null;
+        mContext = null;
+        mUrlGenerator = null;
 
         // Flag as destroyed. LoadUrlTask checks this before proceeding in its onPostExecute().
         mIsDestroyed = true;
     }
 
-    void configureUsingHttpResponse(final HttpResponse response) {
-        mAdConfiguration.addHttpResponse(response);
-    }
-
     Integer getAdTimeoutDelay() {
-        return mAdConfiguration.getAdTimeoutDelay();
-    }
-
-    int getRefreshTimeMilliseconds() {
-        return mAdConfiguration.getRefreshTimeMilliseconds();
-    }
-
-    @Deprecated
-    void setRefreshTimeMilliseconds(int refreshTimeMilliseconds) {
-        mAdConfiguration.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+        return mAdResponse == null ? null : mAdResponse.getAdTimeoutMillis();
     }
 
     void trackImpression() {
-        new Thread(new Runnable() {
-            public void run () {
-                if (mAdConfiguration.getImpressionUrl() == null) return;
-
-                DefaultHttpClient httpClient = HttpClientFactory.create();
-                try {
-                    HttpGet httpget = new HttpGet(mAdConfiguration.getImpressionUrl());
-                    httpget.addHeader("User-Agent", mAdConfiguration.getUserAgent());
-                    httpClient.execute(httpget);
-                } catch (Exception e) {
-                    MoPubLog.d("Impression tracking failed : " + mAdConfiguration.getImpressionUrl(), e);
-                } finally {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
+        if (mAdResponse != null) {
+            TrackingRequest.makeTrackingHttpRequest(mAdResponse.getImpressionTrackingUrl(),
+                    mContext, BaseEvent.Name.IMPRESSION_REQUEST);
+        }
     }
 
     void registerClick() {
-        new Thread(new Runnable() {
-            public void run () {
-                if (mAdConfiguration.getClickthroughUrl() == null) return;
-
-                DefaultHttpClient httpClient = HttpClientFactory.create();
-                try {
-                    MoPubLog.d("Tracking click for: " + mAdConfiguration.getClickthroughUrl());
-                    HttpGet httpget = new HttpGet(mAdConfiguration.getClickthroughUrl());
-                    httpget.addHeader("User-Agent", mAdConfiguration.getUserAgent());
-                    httpClient.execute(httpget);
-                } catch (Exception e) {
-                    MoPubLog.d("Click tracking failed: " + mAdConfiguration.getClickthroughUrl(), e);
-                } finally {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
+        if (mAdResponse != null) {
+            TrackingRequest.makeTrackingHttpRequest(mAdResponse.getClickTrackingUrl(),
+                    mContext, BaseEvent.Name.CLICK_REQUEST);
+        }
     }
 
-    void fetchAd(String mUrl) {
-        if (mAdFetcher != null) {
-            mAdFetcher.fetchAdForUrl(mUrl);
+    void fetchAd(String url) {
+        MoPubView moPubView = getMoPubView();
+        if (moPubView == null || mContext == null) {
+            MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
+            setNotLoading();
+            return;
         }
+
+        AdRequest adRequest = new AdRequest(url,
+                moPubView.getAdFormat(),
+                mAdUnitId,
+                mContext,
+                mAdListener
+        );
+        RequestQueue requestQueue = Networking.getRequestQueue(mContext);
+        requestQueue.add(adRequest);
+        mActiveRequest = adRequest;
     }
 
     void forceRefresh() {
@@ -358,50 +475,61 @@ void forceRefresh() {
         loadAd();
     }
 
+    @Nullable
     String generateAdUrl() {
-        return mUrlGenerator
-                .withAdUnitId(mAdConfiguration.getAdUnitId())
+        return mUrlGenerator == null ? null : mUrlGenerator
+                .withAdUnitId(mAdUnitId)
                 .withKeywords(mKeywords)
                 .withLocation(mLocation)
-                .generateUrlString(getServerHostname());
+                .generateUrlString(Constants.HOST);
     }
 
     void adDidFail(MoPubErrorCode errorCode) {
         MoPubLog.i("Ad failed to load.");
         setNotLoading();
+
+        MoPubView moPubView = getMoPubView();
+        if (moPubView == null) {
+            return;
+        }
+
         scheduleRefreshTimerIfEnabled();
-        getMoPubView().adFailed(errorCode);
+        moPubView.adFailed(errorCode);
     }
 
     void scheduleRefreshTimerIfEnabled() {
         cancelRefreshTimer();
-        if (mAutoRefreshEnabled && mAdConfiguration.getRefreshTimeMilliseconds() > 0) {
-            mHandler.postDelayed(mRefreshRunnable, mAdConfiguration.getRefreshTimeMilliseconds());
-        }
+        if (mAutoRefreshEnabled && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
 
+            mHandler.postDelayed(mRefreshRunnable,
+                    Math.min(MAX_REFRESH_TIME_MILLISECONDS,
+                            mRefreshTimeMillis * (long) Math.pow(BACKOFF_FACTOR, mBackoffPower)));
+        }
     }
 
     void setLocalExtras(Map<String, Object> localExtras) {
         mLocalExtras = (localExtras != null)
-                ? new HashMap<String,Object>(localExtras)
-                : new HashMap<String,Object>();
+                ? new TreeMap<String,Object>(localExtras)
+                : new TreeMap<String,Object>();
     }
 
+    /**
+     * Returns a copied map of localExtras
+     */
     Map<String, Object> getLocalExtras() {
         return (mLocalExtras != null)
-                ? new HashMap<String,Object>(mLocalExtras)
-                : new HashMap<String,Object>();
+                ? new TreeMap<String,Object>(mLocalExtras)
+                : new TreeMap<String,Object>();
     }
 
     private void cancelRefreshTimer() {
         mHandler.removeCallbacks(mRefreshRunnable);
     }
 
-    private String getServerHostname() {
-        return mIsTesting ? MoPubView.HOST_FOR_TESTING : MoPubView.HOST;
-    }
-
     private boolean isNetworkAvailable() {
+        if (mContext == null) {
+            return false;
+        }
         // If we don't have network state access, just assume the network is up.
         int result = mContext.checkCallingPermission(ACCESS_NETWORK_STATE);
         if (result == PackageManager.PERMISSION_DENIED) return true;
@@ -420,26 +548,25 @@ void setAdContentView(final View view) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
-            	MoPubView moPubView = getMoPubView();
-            	if (moPubView == null) {
-            		return;
-            	}
-            	try {
-            		moPubView.removeAllViews();
-	                moPubView.addView(view, getAdLayoutParams(view));
-            	}
-            	catch(Exception e) {
-            		moPubView.adFailed(MoPubErrorCode.INTERNAL_ERROR);
-            	}
+                MoPubView moPubView = getMoPubView();
+                if (moPubView == null) {
+                    return;
+                }
+                moPubView.removeAllViews();
+                moPubView.addView(view, getAdLayoutParams(view));
             }
         });
     }
 
     private FrameLayout.LayoutParams getAdLayoutParams(View view) {
-        int width = mAdConfiguration.getWidth();
-        int height = mAdConfiguration.getHeight();
+        Integer width = null;
+        Integer height = null;
+        if (mAdResponse != null) {
+            width = mAdResponse.getWidth();
+            height = mAdResponse.getHeight();
+        }
 
-        if (getShouldHonorServerDimensions(view) && width > 0 && height > 0) {
+        if (width != null && height != null && getShouldHonorServerDimensions(view) && width > 0 && height > 0) {
             int scaledWidth = Dips.asIntPixels(width, mContext);
             int scaledHeight = Dips.asIntPixels(height, mContext);
 
@@ -449,17 +576,16 @@ public void run() {
         }
     }
 
-    class AdViewControllerGpsHelperListener implements GpsHelperListener {
-        @Override
-        public void onFetchAdInfoCompleted() {
-            String adUrl = generateAdUrl();
-            loadNonJavascript(adUrl);
-        }
+    @Deprecated // for testing
+    @VisibleForTesting
+    Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
     }
 
-    @Deprecated
-    void setGpsHelperListener(GpsHelperListener gpsHelperListener) {
-        mGpsHelperListener = gpsHelperListener;
+    @Deprecated // for testing
+    @VisibleForTesting
+    void setRefreshTimeMillis(@Nullable final Integer refreshTimeMillis) {
+        mRefreshTimeMillis = refreshTimeMillis;
     }
 
     @Deprecated
@@ -481,7 +607,7 @@ public void customEventActionWillBegin() {
 
     @Deprecated
     public void setClickthroughUrl(String clickthroughUrl) {
-        mAdConfiguration.setClickthroughUrl(clickthroughUrl);
+        // Does nothing
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
index 6f8cea10..6af45e32 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
@@ -4,6 +4,9 @@
 import android.graphics.Color;
 import android.view.MotionEvent;
 import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
 import com.mopub.common.logging.MoPubLog;
 
 import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
@@ -14,13 +17,13 @@
     private final ViewGestureDetector mViewGestureDetector;
     private boolean mClicked;
 
-    public BaseHtmlWebView(Context context, AdConfiguration adConfiguration) {
+    public BaseHtmlWebView(Context context, AdReport adReport) {
         super(context);
 
         disableScrollingAndZoom();
         getSettings().setJavaScriptEnabled(true);
 
-        mViewGestureDetector = new ViewGestureDetector(context, this, adConfiguration);
+        mViewGestureDetector = new ViewGestureDetector(context, this, adReport);
         mViewGestureDetector.setUserClickListener(this);
 
         if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
@@ -52,7 +55,8 @@ private void disableScrollingAndZoom() {
     }
 
     void loadHtmlResponse(String htmlResponse) {
-        loadDataWithBaseURL("http://ads.mopub.com/", htmlResponse, "text/html", "utf-8", null);
+        loadDataWithBaseURL("http://" + Constants.HOST + "/", htmlResponse, "text/html", "utf-8",
+                null);
     }
 
     void initializeOnTouchListener(final boolean isScrollable) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
index 5fb5f449..1b1ddf21 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
@@ -1,50 +1,46 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.graphics.drawable.StateListDrawable;
+import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
-import android.view.View.OnClickListener;
 import android.view.Window;
 import android.view.WindowManager;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout.LayoutParams;
 
-import com.mopub.common.util.Dips;
-import com.mopub.mobileads.util.Interstitials;
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.DataKeys;
 
-import static android.view.View.INVISIBLE;
-import static android.view.View.VISIBLE;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 
 abstract class BaseInterstitialActivity extends Activity {
-    private OnClickListener mCloseOnClickListener;
+    protected AdReport mAdReport;
 
     enum JavaScriptWebViewCallbacks {
-        WEB_VIEW_DID_APPEAR("javascript:webviewDidAppear();"),
-        WEB_VIEW_DID_CLOSE("javascript:webviewDidClose();");
+        // The ad server appends these functions to the MRAID javascript to help with third party
+        // impression tracking.
+        WEB_VIEW_DID_APPEAR("webviewDidAppear();"),
+        WEB_VIEW_DID_CLOSE("webviewDidClose();");
+
+        private String mJavascript;
+        private JavaScriptWebViewCallbacks(String javascript) {
+            mJavascript = javascript;
+        }
 
-        private String mUrl;
-        private JavaScriptWebViewCallbacks(String url) {
-            mUrl = url;
+        protected String getJavascript() {
+            return mJavascript;
         }
 
         protected String getUrl() {
-            return mUrl;
+            return "javascript:" + mJavascript;
         }
     }
 
-    private static final float CLOSE_BUTTON_SIZE_DP = 50f;
-    private static final float CLOSE_BUTTON_PADDING = 8f;
-
-    private ImageView mCloseButton;
-    private RelativeLayout mLayout;
-    private int mButtonSize;
-    private int mButtonPadding;
-    private long mBroadcastIdentifier;
+    private CloseableLayout mCloseableLayout;
+    private Long mBroadcastIdentifier;
 
     public abstract View getAdView();
 
@@ -52,85 +48,60 @@ protected String getUrl() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        Intent intent = getIntent();
+        mBroadcastIdentifier = getBroadcastIdentifierFromIntent(intent);
+        mAdReport = getAdReportFromIntent(intent);
+
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        mButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE_DP, this);
-        mButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING, this);
-        mCloseOnClickListener = new OnClickListener() {
+        View adView = getAdView();
+
+        mCloseableLayout = new CloseableLayout(this);
+        mCloseableLayout.setOnCloseListener(new OnCloseListener() {
             @Override
-            public void onClick(final View view) {
+            public void onClose() {
                 finish();
             }
-        };
-
-        // The contentView needs to be a RelativeLayout so the close button can be properly aligned
-        mLayout = new RelativeLayout(this);
-        final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
-        mLayout.addView(getAdView(), adViewLayout);
-        setContentView(mLayout);
-
-        final AdConfiguration adConfiguration = getAdConfiguration();
-        if (adConfiguration != null) {
-            mBroadcastIdentifier = adConfiguration.getBroadcastIdentifier();
-        }
+        });
+        mCloseableLayout.addView(adView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        setContentView(mCloseableLayout);
+
 
-        createInterstitialCloseButton();
     }
 
     @Override
     protected void onDestroy() {
-        mLayout.removeAllViews();
+        mCloseableLayout.removeAllViews();
         super.onDestroy();
     }
 
-    long getBroadcastIdentifier() {
+    Long getBroadcastIdentifier() {
         return mBroadcastIdentifier;
     }
 
     protected void showInterstitialCloseButton() {
-        mCloseButton.setVisibility(VISIBLE);
+        mCloseableLayout.setCloseVisible(true);
     }
 
     protected void hideInterstitialCloseButton() {
-        mCloseButton.setVisibility(INVISIBLE);
+        mCloseableLayout.setCloseVisible(false);
     }
 
-    protected AdConfiguration getAdConfiguration() {
-        AdConfiguration adConfiguration;
-        try {
-            adConfiguration = (AdConfiguration) getIntent().getSerializableExtra(AD_CONFIGURATION_KEY);
-        } catch (ClassCastException e) {
-            adConfiguration = null;
+    protected static Long getBroadcastIdentifierFromIntent(Intent intent) {
+        if (intent.hasExtra(BROADCAST_IDENTIFIER_KEY)) {
+            return intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1L);
         }
-        return adConfiguration;
+        return null;
     }
 
-    void addCloseEventRegion() {
-        final int buttonSizePixels = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, this);
-        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(buttonSizePixels, buttonSizePixels);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
-        Interstitials.addCloseEventRegion(mLayout, layoutParams, mCloseOnClickListener);
-    }
-
-    private void createInterstitialCloseButton() {
-        mCloseButton = new ImageButton(this);
-        StateListDrawable states = new StateListDrawable();
-        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(this));
-        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(this));
-        mCloseButton.setImageDrawable(states);
-        mCloseButton.setBackgroundDrawable(null);
-        mCloseButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                finish();
-            }
-        });
-
-        RelativeLayout.LayoutParams buttonLayout = new RelativeLayout.LayoutParams(mButtonSize, mButtonSize);
-        buttonLayout.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
-        buttonLayout.setMargins(mButtonPadding, 0, mButtonPadding, 0);
-        mLayout.addView(mCloseButton, buttonLayout);
+    @Nullable
+    protected static AdReport getAdReportFromIntent(Intent intent) {
+        try {
+            return (AdReport) intent.getSerializableExtra(DataKeys.AD_REPORT_KEY);
+        } catch (ClassCastException e) {
+            return null;
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
index ec9ce51c..226ea8ec 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
@@ -6,18 +6,17 @@
 import android.content.Intent;
 
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIG;
 
-class BaseVideoPlayerActivity extends Activity {
+public class BaseVideoPlayerActivity extends Activity {
     static final String VIDEO_CLASS_EXTRAS_KEY = "video_view_class_name";
-    static final String VIDEO_URL = "video_url";
+    public static final String VIDEO_URL = "video_url";
 
-    static void startMraid(final Context context, final String videoUrl, final AdConfiguration adConfiguration) {
-        final Intent intentVideoPlayerActivity = createIntentMraid(context, videoUrl, adConfiguration);
+    public static void startMraid(final Context context, final String videoUrl) {
+        final Intent intentVideoPlayerActivity = createIntentMraid(context, videoUrl);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -26,20 +25,18 @@ static void startMraid(final Context context, final String videoUrl, final AdCon
     }
 
     static Intent createIntentMraid(final Context context,
-            final String videoUrl,
-            final AdConfiguration adConfiguration) {
+            final String videoUrl) {
         final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
         intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
         intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "mraid");
         intentVideoPlayerActivity.putExtra(VIDEO_URL, videoUrl);
-        intentVideoPlayerActivity.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
         return intentVideoPlayerActivity;
     }
 
     static void startVast(final Context context,
-            final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
-        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfiguration, adConfiguration);
+            final VastVideoConfig vastVideoConfig,
+            final long broadcastIdentifier) {
+        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfig, broadcastIdentifier);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -48,13 +45,13 @@ static void startVast(final Context context,
     }
 
     static Intent createIntentVast(final Context context,
-            final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
+            final VastVideoConfig vastVideoConfig,
+            final long broadcastIdentifier) {
         final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
         intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
         intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "vast");
-        intentVideoPlayerActivity.putExtra(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-        intentVideoPlayerActivity.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intentVideoPlayerActivity.putExtra(VAST_VIDEO_CONFIG, vastVideoConfig);
+        intentVideoPlayerActivity.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         return intentVideoPlayerActivity;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
index 195b1612..6856f4a9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
@@ -3,23 +3,26 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.res.Configuration;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.logging.MoPubLog;
 
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 
-abstract class BaseVideoViewController {
+public abstract class BaseVideoViewController {
     private final Context mContext;
     private final RelativeLayout mLayout;
     private final BaseVideoViewControllerListener mBaseVideoViewControllerListener;
-    private long mBroadcastIdentifier;
+    @Nullable private Long mBroadcastIdentifier;
 
-    interface BaseVideoViewControllerListener {
+    public interface BaseVideoViewControllerListener {
         void onSetContentView(final View view);
         void onSetRequestedOrientation(final int requestedOrientation);
         void onFinish();
@@ -28,14 +31,14 @@ void onStartActivityForResult(final Class<? extends Activity> clazz,
                 final Bundle extras);
     }
 
-    BaseVideoViewController(final Context context, final long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+    protected BaseVideoViewController(final Context context, @Nullable final Long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
         mContext = context.getApplicationContext();
         mBroadcastIdentifier = broadcastIdentifier;
         mBaseVideoViewControllerListener = baseVideoViewControllerListener;
         mLayout = new RelativeLayout(mContext);
     }
 
-     void onCreate() {
+     protected void onCreate() {
         final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
                 RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
         adViewLayout.addRule(RelativeLayout.CENTER_IN_PARENT);
@@ -43,12 +46,14 @@ void onCreate() {
         mBaseVideoViewControllerListener.onSetContentView(mLayout);
     }
 
-    abstract VideoView getVideoView();
-    abstract void onPause();
-    abstract void onResume();
-    abstract void onDestroy();
+    protected abstract VideoView getVideoView();
+    protected abstract void onPause();
+    protected abstract void onResume();
+    protected abstract void onDestroy();
+    protected abstract void onSaveInstanceState(@NonNull Bundle outState);
+    protected abstract void onConfigurationChanged(@Nullable Configuration configuration);
 
-    boolean backButtonEnabled() {
+    public boolean backButtonEnabled() {
         return true;
     }
 
@@ -56,38 +61,37 @@ void onActivityResult(final int requestCode, final int resultCode, final Intent
         // By default, the activity result is ignored
     }
 
-    BaseVideoViewControllerListener getBaseVideoViewControllerListener() {
+    protected BaseVideoViewControllerListener getBaseVideoViewControllerListener() {
         return mBaseVideoViewControllerListener;
     }
 
-    Context getContext() {
+    protected Context getContext() {
         return mContext;
     }
 
-    ViewGroup getLayout() {
+    public ViewGroup getLayout() {
         return mLayout;
     }
 
-
-    void videoError(boolean shouldFinish) {
-        MoPubLog.d("Error: video can not be played.");
+    protected void videoError(boolean shouldFinish) {
+        MoPubLog.e("Video cannot be played.");
         broadcastAction(ACTION_INTERSTITIAL_FAIL);
         if (shouldFinish) {
            mBaseVideoViewControllerListener.onFinish();
         }
     }
 
-    void videoCompleted(boolean shouldFinish) {
+    protected void videoCompleted(boolean shouldFinish) {
         if (shouldFinish) {
             mBaseVideoViewControllerListener.onFinish();
         }
     }
 
-    void videoClicked() {
-        broadcastAction(ACTION_INTERSTITIAL_CLICK);
-    }
-
     void broadcastAction(final String action) {
-        EventForwardingBroadcastReceiver.broadcastAction(mContext, mBroadcastIdentifier, action);
+        if (mBroadcastIdentifier != null) {
+            EventForwardingBroadcastReceiver.broadcastAction(mContext, mBroadcastIdentifier, action);
+        } else {
+            MoPubLog.w("Tried to broadcast a video event without a braodcast identifier to send to.");
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
index c9f633be..a9331a31 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
@@ -1,6 +1,13 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.graphics.Color;
+import android.graphics.PixelFormat;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
+import android.view.Gravity;
+import android.view.WindowManager;
 import android.webkit.WebSettings;
 import android.webkit.WebView;
 
@@ -9,6 +16,7 @@
 import com.mopub.mobileads.util.WebViews;
 
 public class BaseWebView extends WebView {
+    private static boolean sDeadlockCleared = false;
     protected boolean mIsDestroyed;
 
     public BaseWebView(Context context) {
@@ -20,6 +28,11 @@ public BaseWebView(Context context) {
         enablePlugins(false);
 
         WebViews.setDisableJSChromeClient(this);
+
+        if (!sDeadlockCleared) {
+            clearWebViewDeadlock(getContext());
+            sDeadlockCleared = true;
+        }
     }
 
     protected void enablePlugins(final boolean enabled) {
@@ -39,7 +52,13 @@ protected void enablePlugins(final boolean enabled) {
     public void destroy() {
         mIsDestroyed = true;
 
+        // Needed to prevent receiving the following error on Android versions using WebViewClassic
+        // https://code.google.com/p/android/issues/detail?id=65833.
         Views.removeFromParent(this);
+
+        // Even after removing from the parent, WebViewClassic can leak because of a static
+        // reference from HTML5VideoViewProcessor. Removing children fixes this problem.
+        removeAllViews();
         super.destroy();
     }
 
@@ -47,4 +66,43 @@ public void destroy() {
     void setIsDestroyed(boolean isDestroyed) {
         mIsDestroyed = isDestroyed;
     }
+
+    /**
+     * This fixes https://code.google.com/p/android/issues/detail?id=63754,
+     * which occurs on KitKat devices. When a WebView containing an HTML5 video is
+     * is destroyed it can deadlock the WebView thread until another hardware accelerated WebView
+     * is added to the view hierarchy and restores the GL context. Since we need to use WebView
+     * before adding it to the view hierarchy, this method clears the deadlock by adding a
+     * separate invisible WebView.
+     *
+     * This potential deadlock must be cleared anytime you attempt to access a WebView that
+     * is not added to the view hierarchy.
+     */
+    private void clearWebViewDeadlock(@NonNull final Context context) {
+        if (VERSION.SDK_INT == VERSION_CODES.KITKAT) {
+            // Create an invisible webview
+            final WebView webView = new WebView(context.getApplicationContext());
+            webView.setBackgroundColor(Color.TRANSPARENT);
+
+            // For the deadlock to be cleared, we must load content and add to the view hierarchy. Since
+            // we don't have an activity context, we'll use a system window.
+            webView.loadDataWithBaseURL(null, "", "text/html", "UTF-8", null);
+            final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
+            params.width = 1;
+            params.height = 1;
+            // Unlike other system window types TYPE_TOAST doesn't require extra permissions
+            params.type = WindowManager.LayoutParams.TYPE_TOAST;
+            params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                    | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
+                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
+            params.format = PixelFormat.TRANSPARENT;
+            params.gravity = Gravity.START | Gravity.TOP;
+            final WindowManager windowManager =
+                    (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+
+            windowManager.addView(webView, params);
+        }
+    }
+
+
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
index 5cdad507..60f3e6b3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
@@ -2,23 +2,30 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
 import com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.AD_HEIGHT;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.AD_WIDTH;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 public class CustomEventBannerAdapter implements CustomEventBannerListener {
-    public static final int DEFAULT_BANNER_TIMEOUT_DELAY = 10000;
+    public static final int DEFAULT_BANNER_TIMEOUT_DELAY = Constants.TEN_SECONDS_MILLIS;
     private boolean mInvalidated;
     private MoPubView mMoPubView;
     private Context mContext;
@@ -30,12 +37,15 @@
     private final Runnable mTimeout;
     private boolean mStoredAutorefresh;
 
-    public CustomEventBannerAdapter(MoPubView moPubView, String className, String classData) {
+    public CustomEventBannerAdapter(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @Nullable AdReport adReport) {
+        Preconditions.checkNotNull(serverExtras);
         mHandler = new Handler();
         mMoPubView = moPubView;
         mContext = moPubView.getContext();
-        mLocalExtras = new HashMap<String, Object>();
-        mServerExtras = new HashMap<String, String>();
         mTimeout = new Runnable() {
             @Override
             public void run() {
@@ -55,19 +65,16 @@ public void run() {
         }
 
         // Attempt to load the JSON extras into mServerExtras.
-        try {
-            mServerExtras = Json.jsonStringToMap(classData);
-        } catch (Exception exception) {
-            MoPubLog.d("Failed to create Map from JSON: " + classData + exception.toString());
-        }
+        mServerExtras = new TreeMap<String, String>(serverExtras);
 
         mLocalExtras = mMoPubView.getLocalExtras();
         if (mMoPubView.getLocation() != null) {
             mLocalExtras.put("location", mMoPubView.getLocation());
         }
-        if (mMoPubView.getAdViewController() != null) {
-            mLocalExtras.put(AD_CONFIGURATION_KEY, mMoPubView.getAdViewController().getAdConfiguration());
-        }
+        mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        mLocalExtras.put(AD_REPORT_KEY, adReport);
+        mLocalExtras.put(AD_WIDTH, mMoPubView.getAdWidth());
+        mLocalExtras.put(AD_HEIGHT, mMoPubView.getAdHeight());
     }
 
     void loadAd() {
@@ -79,11 +86,26 @@ void loadAd() {
             mHandler.postDelayed(mTimeout, getTimeoutDelayMilliseconds());
         }
 
-        mCustomEventBanner.loadBanner(mContext, this, mLocalExtras, mServerExtras);
+        // Custom event classes can be developed by any third party and may not be tested.
+        // We catch all exceptions here to prevent crashes from untested code.
+        try {
+            mCustomEventBanner.loadBanner(mContext, this, mLocalExtras, mServerExtras);
+        } catch (Exception e) {
+            MoPubLog.d("Loading a custom event banner threw an exception.", e);
+            onBannerFailed(MoPubErrorCode.INTERNAL_ERROR);
+        }
     }
 
     void invalidate() {
-        if (mCustomEventBanner != null) mCustomEventBanner.onInvalidate();
+        if (mCustomEventBanner != null) {
+            // Custom event classes can be developed by any third party and may not be tested.
+            // We catch all exceptions here to prevent crashes from untested code.
+            try {
+                mCustomEventBanner.onInvalidate();
+            } catch (Exception e) {
+                MoPubLog.d("Invalidating a custom event banner threw an exception", e);
+            }
+        }
         mContext = null;
         mCustomEventBanner = null;
         mLocalExtras = null;
@@ -131,8 +153,10 @@ public void onBannerLoaded(View bannerView) {
 
     @Override
     public void onBannerFailed(MoPubErrorCode errorCode) {
-        if (isInvalidated()) return;
-        
+        if (isInvalidated()) {
+            return;
+        }
+
         if (mMoPubView != null) {
             if (errorCode == null) {
                 errorCode = UNSPECIFIED;
@@ -144,7 +168,9 @@ public void onBannerFailed(MoPubErrorCode errorCode) {
 
     @Override
     public void onBannerExpanded() {
-        if (isInvalidated()) return;
+        if (isInvalidated()) {
+            return;
+        }
 
         mStoredAutorefresh = mMoPubView.getAutorefreshEnabled();
         mMoPubView.setAutorefreshEnabled(false);
@@ -153,7 +179,9 @@ public void onBannerExpanded() {
 
     @Override
     public void onBannerCollapsed() {
-        if (isInvalidated()) return;
+        if (isInvalidated()) {
+            return;
+        }
 
         mMoPubView.setAutorefreshEnabled(mStoredAutorefresh);
         mMoPubView.adClosed();
@@ -161,11 +189,15 @@ public void onBannerCollapsed() {
 
     @Override
     public void onBannerClicked() {
-        if (isInvalidated()) return;
-        
-        if (mMoPubView != null) mMoPubView.registerClick();
+        if (isInvalidated()) {
+            return;
+        }
+
+        if (mMoPubView != null) {
+            mMoPubView.registerClick();
+        }
     }
-    
+
     @Override
     public void onLeaveApplication() {
         onBannerClicked();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
index f4a74c41..740ec3c4 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
@@ -2,22 +2,27 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
 import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 public class CustomEventInterstitialAdapter implements CustomEventInterstitialListener {
-    public static final int DEFAULT_INTERSTITIAL_TIMEOUT_DELAY = 30000;
+    public static final int DEFAULT_INTERSTITIAL_TIMEOUT_DELAY = Constants.THIRTY_SECONDS_MILLIS;
 
     private final MoPubInterstitial mMoPubInterstitial;
     private boolean mInvalidated;
@@ -29,11 +34,14 @@
     private final Handler mHandler;
     private final Runnable mTimeout;
 
-    public CustomEventInterstitialAdapter(final MoPubInterstitial moPubInterstitial, final String className, final String jsonParams) {
+    public CustomEventInterstitialAdapter(@NonNull final MoPubInterstitial moPubInterstitial,
+            @NonNull final String className,
+            @NonNull final Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @Nullable AdReport adReport) {
+        Preconditions.checkNotNull(serverExtras);
         mHandler = new Handler();
         mMoPubInterstitial = moPubInterstitial;
-        mServerExtras = new HashMap<String, String>();
-        mLocalExtras = new HashMap<String, Object>();
         mContext = mMoPubInterstitial.getActivity();
         mTimeout = new Runnable() {
             @Override
@@ -53,24 +61,15 @@ public void run() {
             return;
         }
 
-        // Attempt to load the JSON extras into mServerExtras.
-        try {
-            mServerExtras = Json.jsonStringToMap(jsonParams);
-        } catch (Exception exception) {
-            MoPubLog.d("Failed to create Map from JSON: " + jsonParams);
-        }
-
+        mServerExtras = new TreeMap<String, String>(serverExtras);
         mLocalExtras = mMoPubInterstitial.getLocalExtras();
         if (mMoPubInterstitial.getLocation() != null) {
             mLocalExtras.put("location", mMoPubInterstitial.getLocation());
         }
-
-        final AdViewController adViewController = mMoPubInterstitial.getMoPubInterstitialView().getAdViewController();
-        if (adViewController != null) {
-            mLocalExtras.put(AD_CONFIGURATION_KEY, adViewController.getAdConfiguration());
-        }
+        mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        mLocalExtras.put(AD_REPORT_KEY, adReport);
     }
-    
+
     void loadInterstitial() {
         if (isInvalidated() || mCustomEventInterstitial == null) {
             return;
@@ -80,17 +79,42 @@ void loadInterstitial() {
             mHandler.postDelayed(mTimeout, getTimeoutDelayMilliseconds());
         }
 
-        mCustomEventInterstitial.loadInterstitial(mContext, this, mLocalExtras, mServerExtras);
+        // Custom event classes can be developed by any third party and may not be tested.
+        // We catch all exceptions here to prevent crashes from untested code.
+        try {
+            mCustomEventInterstitial.loadInterstitial(mContext, this, mLocalExtras, mServerExtras);
+        } catch (Exception e) {
+            MoPubLog.d("Loading a custom event interstitial threw an exception.", e);
+            onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+        }
     }
-    
+
     void showInterstitial() {
-        if (isInvalidated() || mCustomEventInterstitial == null) return;
-        
-        mCustomEventInterstitial.showInterstitial();
+        if (isInvalidated() || mCustomEventInterstitial == null) {
+            return;
+        }
+
+        // Custom event classes can be developed by any third party and may not be tested.
+        // We catch all exceptions here to prevent crashes from untested code.
+        try {
+            mCustomEventInterstitial.showInterstitial();
+        } catch (Exception e) {
+            MoPubLog.d("Showing a custom event interstitial threw an exception.", e);
+            onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+        }
     }
 
     void invalidate() {
-        if (mCustomEventInterstitial != null) mCustomEventInterstitial.onInvalidate();
+        if (mCustomEventInterstitial != null) {
+
+            // Custom event classes can be developed by any third party and may not be tested.
+            // We catch all exceptions here to prevent crashes from untested code.
+            try {
+                mCustomEventInterstitial.onInvalidate();
+            } catch (Exception e) {
+                MoPubLog.d("Invalidating a custom event interstitial threw an exception.", e);
+            }
+        }
         mCustomEventInterstitial = null;
         mContext = null;
         mServerExtras = null;
@@ -189,9 +213,13 @@ public void onLeaveApplication() {
 
     @Override
     public void onInterstitialDismissed() {
-        if (isInvalidated()) return;
+        if (isInvalidated()) {
+            return;
+        }
 
-        if (mCustomEventInterstitialAdapterListener != null) mCustomEventInterstitialAdapterListener.onCustomEventInterstitialDismissed();
+        if (mCustomEventInterstitialAdapterListener != null) {
+            mCustomEventInterstitialAdapterListener.onCustomEventInterstitialDismissed();
+        }
     }
 
     @Deprecated
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
new file mode 100644
index 00000000..ec9edbb4
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
@@ -0,0 +1,124 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubLifecycleManager;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ *
+ */
+public abstract class CustomEventRewardedVideo {
+    /**
+     * This marker interface is used to indicate that an object is a listener for a 3rd party SDKs
+     * rewarded video system.
+     */
+    @VisibleForTesting
+    protected static interface CustomEventRewardedVideoListener {}
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract CustomEventRewardedVideoListener getVideoListenerForSdk();
+
+    /**
+     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
+     * activity lifecycle events in the application.
+     *
+     * @return a LifecycleListener. May be null.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract LifecycleListener getLifecycleListener();
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     * This should return the "ad unit id", "zone id" or similar identifier for the network.
+     * May be empty if the network does not have anything more specific than an application ID.
+     *
+     * @return the id string for this ad unit with the ad network.
+     */
+    @NonNull
+    protected abstract String getAdNetworkId();
+
+    /**
+     * Called to when the custom event is no longer used. Implementers should cancel any
+     * pending requests. The initialized SDK may be reused by another CustomEvent instance
+     * and should not be shut down or cleaned up.
+     */
+    protected abstract void onInvalidate();
+
+    /**
+     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
+     * be loaded.
+     *
+     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    final void loadCustomEvent(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) {
+        try {
+            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
+                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(getLifecycleListener());
+            }
+            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
+        } catch (Exception e) {
+            MoPubLog.e(e.getMessage());
+        }
+    }
+
+    /**
+     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
+     * to do any static initialization the first time this method is run by any class instance.
+     * From then on, the SDK should be reused without initialization.
+     *
+     * @return true if the SDK performed initialization, false if the SDK was already initialized.
+     */
+    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
+     * contain all the data needed to load an ad.
+     *
+     * Implementers should also use this method (or checkAndInitializeSdk)
+     * to register a listener for their SDK, wrap it in a
+     * {@link com.mopub.mobileads.CustomEventRewardedVideo.CustomEventRewardedVideoListener}
+     *
+     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
+     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
+     *
+     * @param activity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Implementers should query the 3rd party SDK for whether there is a video available for the
+     * 3rd party SDK & ID represented by the custom event.
+     *
+     * @return true iff a video is available to play.
+     */
+    protected abstract boolean hasVideoAvailable();
+
+    /**
+     * Implementers should now play the rewarded video for this custom event.
+     */
+    protected abstract void showVideo();
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java b/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
index 624995f2..d5561d92 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
@@ -6,19 +6,20 @@
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
 
+import com.mopub.common.DataKeys;
+
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
-class EventForwardingBroadcastReceiver extends BroadcastReceiver {
+public class EventForwardingBroadcastReceiver extends BroadcastReceiver {
     private final CustomEventInterstitialListener mCustomEventInterstitialListener;
     private final long mBroadcastIdentifier;
     private Context mContext;
 
-    static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
-    static final String ACTION_INTERSTITIAL_FAIL = "com.mopub.action.interstitial.fail";
-    static final String ACTION_INTERSTITIAL_SHOW = "com.mopub.action.interstitial.show";
-    static final String ACTION_INTERSTITIAL_DISMISS = "com.mopub.action.interstitial.dismiss";
-    static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
+    public static final String ACTION_INTERSTITIAL_FAIL = "com.mopub.action.interstitial.fail";
+    public static final String ACTION_INTERSTITIAL_SHOW = "com.mopub.action.interstitial.show";
+    public static final String ACTION_INTERSTITIAL_DISMISS = "com.mopub.action.interstitial.dismiss";
+    public static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
     private static IntentFilter sIntentFilter;
 
 
@@ -30,11 +31,11 @@ public EventForwardingBroadcastReceiver(CustomEventInterstitialListener customEv
 
     static void broadcastAction(final Context context, final long broadcastIdentifier, final String action) {
         Intent intent = new Intent(action);
-        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(DataKeys.BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         LocalBroadcastManager.getInstance(context.getApplicationContext()).sendBroadcast(intent);
     }
 
-    static IntentFilter getHtmlInterstitialIntentFilter() {
+    public static IntentFilter getHtmlInterstitialIntentFilter() {
         if (sIntentFilter == null) {
             sIntentFilter = new IntentFilter();
             sIntentFilter.addAction(ACTION_INTERSTITIAL_FAIL);
@@ -57,7 +58,7 @@ public void onReceive(Context context, Intent intent) {
          * this here because there is no appropriate IntentFilter condition that can recreate this
          * behavior.
          */
-        final long receivedIdentifier = intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1);
+        final long receivedIdentifier = intent.getLongExtra(DataKeys.BROADCAST_IDENTIFIER_KEY, -1);
         if (mBroadcastIdentifier != receivedIdentifier) {
             return;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
index c6598308..dcdf11bd 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
@@ -1,25 +1,21 @@
 package com.mopub.mobileads;
 
-import android.app.Activity;
 import android.content.Context;
-import android.net.Uri;
-import android.os.Looper;
 
-import com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.HtmlBannerWebViewFactory;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
 public class HtmlBanner extends CustomEventBanner {
 
     private HtmlBannerWebView mHtmlBannerWebView;
-    private Activity mActivity;
 
     @Override
     protected void loadBanner(
@@ -32,58 +28,37 @@ protected void loadBanner(
         String redirectUrl;
         String clickthroughUrl;
         Boolean isScrollable;
+        AdReport adReport;
         if (extrasAreValid(serverExtras)) {
-            htmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-            redirectUrl = serverExtras.get(REDIRECT_URL_KEY);
-            clickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
-            isScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
+            htmlData = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
+            redirectUrl = serverExtras.get(DataKeys.REDIRECT_URL_KEY);
+            clickthroughUrl = serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY);
+            isScrollable = Boolean.valueOf(serverExtras.get(DataKeys.SCROLLABLE_KEY));
+            try {
+                adReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            } catch (ClassCastException e) {
+                MoPubLog.e("LocalExtras contained an incorrect type.");
+                customEventBannerListener.onBannerFailed(INTERNAL_ERROR);
+                return;
+            }
         } else {
             customEventBannerListener.onBannerFailed(NETWORK_INVALID_STATE);
             return;
         }
 
-        AdConfiguration adConfiguration = AdConfiguration.extractFromMap(localExtras);
-        if (Looper.myLooper() == Looper.getMainLooper()) {
-        	mHtmlBannerWebView = HtmlBannerWebViewFactory.create(context, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
-            AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
-            mHtmlBannerWebView.loadHtmlResponse(htmlData);
-        } else {
-        	final Context pContext = context;
-            final CustomEventBannerListener pCustomEventBannerListener = customEventBannerListener;
-            final Boolean pIsScrollable = isScrollable;
-            final String pRedirectUrl = redirectUrl;
-            final String pClickthroughUrl = clickthroughUrl;
-            final AdConfiguration pAdConfiguration = adConfiguration;
-            final String pHtmlData = htmlData;
-            mActivity = (Activity)context; 
-            mActivity.runOnUiThread(new Runnable() {
-    			@Override
-    			public void run() {
-    				mHtmlBannerWebView = HtmlBannerWebViewFactory.create(pContext, pCustomEventBannerListener, pIsScrollable, pRedirectUrl, pClickthroughUrl, pAdConfiguration);
-    		        AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
-    		        mHtmlBannerWebView.loadHtmlResponse(pHtmlData);
-    			}
-    		});
-        }
+        mHtmlBannerWebView = HtmlBannerWebViewFactory.create(context, adReport, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
+        AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
+        mHtmlBannerWebView.loadHtmlResponse(htmlData);
     }
 
     @Override
     protected void onInvalidate() {
         if (mHtmlBannerWebView != null) {
-            if (Looper.myLooper() == Looper.getMainLooper()) {
-        		mHtmlBannerWebView.destroy();
-        	} else {
-        		mActivity.runOnUiThread(new Runnable() {
-    				@Override
-    				public void run() {
-    					mHtmlBannerWebView.destroy();
-    				}
-    			});
-        	}
+            mHtmlBannerWebView.destroy();
         }
     }
 
     private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
+        return serverExtras.containsKey(DataKeys.HTML_RESPONSE_BODY_KEY);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
index b707d66f..358ea16c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
@@ -2,13 +2,15 @@
 
 import android.content.Context;
 
+import com.mopub.common.AdReport;
+
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 
 public class HtmlBannerWebView extends BaseHtmlWebView {
     public static final String EXTRA_AD_CLICK_DATA = "com.mopub.intent.extra.AD_CLICK_DATA";
 
-    public HtmlBannerWebView(Context context, AdConfiguration adConfiguration) {
-        super(context, adConfiguration);
+    public HtmlBannerWebView(Context context, AdReport adReport) {
+        super(context, adReport);
     }
 
     public void init(CustomEventBannerListener customEventBannerListener, boolean isScrollable, String redirectUrl, String clickthroughUrl) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
index d3ddf4a9..f0643055 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
@@ -1,35 +1,43 @@
 package com.mopub.mobileads;
 
-import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.CreativeOrientation;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 
 public class HtmlInterstitial extends ResponseBodyInterstitial {
     private String mHtmlData;
     private boolean mIsScrollable;
     private String mRedirectUrl;
     private String mClickthroughUrl;
+    @NonNull
+    private CreativeOrientation mOrientation;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
-        mHtmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
+        mHtmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
         mIsScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
         mRedirectUrl = serverExtras.get(REDIRECT_URL_KEY);
         mClickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
+        mOrientation = CreativeOrientation.fromHeader(serverExtras.get(CREATIVE_ORIENTATION_KEY));
     }
 
     @Override
     protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener) {
-        MoPubActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
+        MoPubActivity.preRenderHtml(mContext, mAdReport, customEventInterstitialListener, mHtmlData);
     }
 
     @Override
-    protected void showInterstitial() {
-        MoPubActivity.start(mContext, mHtmlData, mIsScrollable, mRedirectUrl, mClickthroughUrl, mAdConfiguration);
+    public void showInterstitial() {
+        MoPubActivity.start(mContext, mHtmlData, mAdReport, mIsScrollable,
+                mRedirectUrl, mClickthroughUrl, mOrientation,
+                mBroadcastIdentifier);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
index 54f10701..78795c1b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
@@ -1,25 +1,17 @@
 package com.mopub.mobileads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Handler;
-import android.webkit.JavascriptInterface;
 
-import static com.mopub.common.util.VersionCode.HONEYCOMB;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
+import com.mopub.common.AdReport;
+
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 
 public class HtmlInterstitialWebView extends BaseHtmlWebView {
     private Handler mHandler;
 
-    protected static final String MOPUB_JS_INTERFACE_NAME = "mopubUriInterface";
-
-    interface MoPubUriJavascriptFireFinishLoadListener {
-        abstract void onInterstitialLoaded();
-    }
-
-    public HtmlInterstitialWebView(Context context, AdConfiguration adConfiguration) {
-        super(context, adConfiguration);
+    public HtmlInterstitialWebView(Context context, AdReport adReport) {
+        super(context, adReport);
 
         mHandler = new Handler();
     }
@@ -30,61 +22,12 @@ public void init(final CustomEventInterstitialListener customEventInterstitialLi
         HtmlInterstitialWebViewListener htmlInterstitialWebViewListener = new HtmlInterstitialWebViewListener(customEventInterstitialListener);
         HtmlWebViewClient htmlWebViewClient = new HtmlWebViewClient(htmlInterstitialWebViewListener, this, clickthroughUrl, redirectUrl);
         setWebViewClient(htmlWebViewClient);
-
-        addMoPubUriJavascriptInterface(new MoPubUriJavascriptFireFinishLoadListener() {
-            @Override
-            public void onInterstitialLoaded() {
-                if (!mIsDestroyed) {
-                    customEventInterstitialListener.onInterstitialLoaded();
-                }
-            }
-        });
     }
 
     private void postHandlerRunnable(Runnable r) {
         mHandler.post(r);
     }
 
-    /*
-     * XXX (2/15/12): This is a workaround for a problem on ICS devices where
-     * WebViews with layout height WRAP_CONTENT can mysteriously render with
-     * zero height. This seems to happen when calling loadData() with HTML that
-     * sets window.location during its "onload" event. We use loadData() when
-     * displaying interstitials, and our creatives use window.location to
-     * communicate ad loading status to AdViews. This results in zero-height
-     * interstitials. We counteract this by using a Javascript interface object
-     * to signal loading status, rather than modifying window.location.
-     */
-    void addMoPubUriJavascriptInterface(final MoPubUriJavascriptFireFinishLoadListener moPubUriJavascriptFireFinishLoadListener) {
-        final class MoPubUriJavascriptInterface {
-            // This method appears to be unused, since it will only be called from JavaScript.
-            @SuppressWarnings("unused")
-            @JavascriptInterface
-            public boolean fireFinishLoad() {
-                HtmlInterstitialWebView.this.postHandlerRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        moPubUriJavascriptFireFinishLoadListener.onInterstitialLoaded();
-                    }
-                });
-
-                return true;
-            }
-        }
-
-        addJavascriptInterface(new MoPubUriJavascriptInterface(), MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @TargetApi(11)
-    @Override
-    public void destroy() {
-        if (currentApiLevel().isAtLeast(HONEYCOMB)) {
-            removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        }
-
-        super.destroy();
-    }
-
     static class HtmlInterstitialWebViewListener implements HtmlWebViewListener {
         private final CustomEventInterstitialListener mCustomEventInterstitialListener;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
index 1b8726d3..35e56469 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
@@ -1,16 +1,19 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
-import com.mopub.common.MoPubBrowser;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.mobileads.util.Utils;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.util.EnumSet;
 
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
@@ -18,6 +21,17 @@
     static final String MOPUB_FINISH_LOAD = "mopub://finishLoad";
     static final String MOPUB_FAIL_LOAD = "mopub://failLoad";
 
+    private final EnumSet<UrlAction> SUPPORTED_URL_ACTIONS = EnumSet.of(
+            UrlAction.HANDLE_MOPUB_SCHEME,
+            UrlAction.IGNORE_ABOUT_SCHEME,
+            UrlAction.HANDLE_PHONE_SCHEME,
+            UrlAction.OPEN_APP_MARKET,
+            UrlAction.OPEN_NATIVE_BROWSER,
+            UrlAction.OPEN_IN_APP_BROWSER,
+            UrlAction.HANDLE_SHARE_TWEET,
+            UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+            UrlAction.FOLLOW_DEEP_LINK);
+
     private final Context mContext;
     private HtmlWebViewListener mHtmlWebViewListener;
     private BaseHtmlWebView mHtmlWebView;
@@ -33,21 +47,41 @@
     }
 
     @Override
-    public boolean shouldOverrideUrlLoading(WebView view, String url) {
-        if (handleSpecialMoPubScheme(url) || handlePhoneScheme(url) || handleNativeBrowserScheme(url)) {
-            return true;
-        }
-
-        MoPubLog.d("Ad clicked. Click URL: " + url);
-
-        // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
-            if (launchApplicationUrl(url)) {
-                return true;
-            }
-        }
-
-        showMoPubBrowserForUrl(url);
+    public boolean shouldOverrideUrlLoading(final WebView view, final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(SUPPORTED_URL_ACTIONS)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (mHtmlWebView.wasClicked()) {
+                            mHtmlWebViewListener.onClicked();
+                            mHtmlWebView.onResetUserClick();
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withMoPubSchemeListener(new UrlHandler.MoPubSchemeListener() {
+                    @Override
+                    public void onFinishLoad() {
+                        mHtmlWebViewListener.onLoaded(mHtmlWebView);
+                    }
+
+                    @Override
+                    public void onClose() {
+                        mHtmlWebViewListener.onCollapsed();
+                    }
+
+                    @Override
+                    public void onFailLoad() {
+                        mHtmlWebViewListener.onFailed(UNSPECIFIED);
+                    }
+                })
+                .build().handleUrl(mContext, url, mHtmlWebView.wasClicked());
         return true;
     }
 
@@ -56,156 +90,16 @@ public void onPageStarted(WebView view, String url, Bitmap favicon) {
         // If the URL being loaded shares the redirectUrl prefix, open it in the browser.
         if (mRedirectUrl != null && url.startsWith(mRedirectUrl)) {
             view.stopLoading();
-            showMoPubBrowserForUrl(url);
-        }
-    }
-
-    private boolean isSpecialMoPubScheme(String url) {
-        return url.startsWith("mopub://");
-    }
-
-    private boolean handleSpecialMoPubScheme(String url) {
-        if (!isSpecialMoPubScheme(url)) {
-            return false;
-        }
-        Uri uri = Uri.parse(url);
-        String host = uri.getHost();
-
-        if ("finishLoad".equals(host)) {
-            mHtmlWebViewListener.onLoaded(mHtmlWebView);
-        } else if ("close".equals(host)) {
-            mHtmlWebViewListener.onCollapsed();
-        } else if ("failLoad".equals(host)) {
-            mHtmlWebViewListener.onFailed(UNSPECIFIED);
-        } else if ("custom".equals(host)) {
-            handleCustomIntentFromUri(uri);
-        }
-
-        return true;
-    }
-
-    private boolean isPhoneScheme(String url) {
-        return url.startsWith("tel:") || url.startsWith("voicemail:") ||
-                url.startsWith("sms:") || url.startsWith("mailto:") ||
-                url.startsWith("geo:") || url.startsWith("google.streetview:");
-    }
-
-    private boolean handlePhoneScheme(String url) {
-        if (!isPhoneScheme(url)) {
-            return false;
-        }
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean isNativeBrowserScheme(String url) {
-        return url.startsWith("mopubnativebrowser://");
-    }
-
-    private boolean handleNativeBrowserScheme(String url) {
-        if (!isNativeBrowserScheme(url)) {
-            return false;
-        }
-
-        Uri uri = Uri.parse(url);
-
-        String urlToOpenInNativeBrowser;
-        try {
-            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle url: " + url);
-            return false;
-        }
-
-        if (!"navigate".equals(uri.getHost()) || urlToOpenInNativeBrowser == null) {
-            return false;
-        }
-
-        Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
-
-        Intent intent = new Intent(Intent.ACTION_VIEW, intentUri);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean isWebSiteUrl(String url) {
-        return url.startsWith("http://") || url.startsWith("https://");
-    }
-
-    private boolean launchApplicationUrl(String url) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Unable to open intent.";
-
-        return launchIntentForUserClick(mContext, intent, errorMessage);
-    }
-
-    private void showMoPubBrowserForUrl(String url) {
-        if (url == null || url.equals("")) url = "about:blank";
-        MoPubLog.d("Final URI to show in browser: " + url);
-        Intent intent = new Intent(mContext, MoPubBrowser.class);
-        intent.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent action. "
-                + ". Perhaps you forgot to declare com.mopub.common.MoPubBrowser"
-                + " in your Android manifest file.";
-
-        boolean handledByMoPubBrowser = launchIntentForUserClick(mContext, intent, errorMessage);
-
-        if (!handledByMoPubBrowser) {
-            intent = new Intent(Intent.ACTION_VIEW, Uri.parse("about:blank"));
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            launchIntentForUserClick(mContext, intent, null);
-        }
-    }
-
-    private void handleCustomIntentFromUri(Uri uri) {
-        String action;
-        String adData;
-        try {
-            action = uri.getQueryParameter("fnc");
-            adData = uri.getQueryParameter("data");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle custom intent with uri: " + uri);
-            return;
+            if (mHtmlWebView.wasClicked()) {
+                try {
+                    Intents.showMoPubBrowserForUrl(mContext, Uri.parse(url));
+                } catch (IntentNotResolvableException e) {
+                    MoPubLog.d(e.getMessage());
+                }
+            } else {
+                MoPubLog.d("Attempted to redirect without user interaction");
+            }
         }
-
-        Intent customIntent = new Intent(action);
-        customIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        customIntent.putExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA, adData);
-
-        String errorMessage = "Could not handle custom intent: " + action
-                + ". Is your intent spelled correctly?";
-
-        launchIntentForUserClick(mContext, customIntent, errorMessage);
     }
 
-    boolean launchIntentForUserClick(Context context, Intent intent, String errorMessage) {
-        if (!mHtmlWebView.wasClicked()) {
-            return false;
-        }
-
-        boolean wasIntentStarted = Utils.executeIntent(context, intent, errorMessage);
-        if (wasIntentStarted) {
-            mHtmlWebViewListener.onClicked();
-            mHtmlWebView.onResetUserClick();
-        }
-
-        return wasIntentStarted;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
index 223c015e..bf0168d3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
@@ -9,13 +9,21 @@
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.DataKeys;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import java.io.Serializable;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -30,8 +38,11 @@
 public class MoPubActivity extends BaseInterstitialActivity {
     private HtmlInterstitialWebView mHtmlInterstitialWebView;
 
-    public static void start(Context context, String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
-        Intent intent = createIntent(context, htmlData, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+    public static void start(Context context, String htmlData, AdReport adReport,
+            boolean isScrollable, String redirectUrl, String clickthroughUrl,
+            CreativeOrientation creativeOrientation, long broadcastIdentifier) {
+        Intent intent = createIntent(context, htmlData, adReport, isScrollable,
+                redirectUrl, clickthroughUrl, creativeOrientation, broadcastIdentifier);
         try {
             context.startActivity(intent);
         } catch (ActivityNotFoundException anfe) {
@@ -39,27 +50,26 @@ public static void start(Context context, String htmlData, boolean isScrollable,
         }
     }
 
-    static Intent createIntent(Context context, String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
+    static Intent createIntent(Context context,
+            String htmlData, AdReport adReport, boolean isScrollable, String redirectUrl,
+            String clickthroughUrl, CreativeOrientation orientation, long broadcastIdentifier) {
         Intent intent = new Intent(context, MoPubActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
         intent.putExtra(SCROLLABLE_KEY, isScrollable);
         intent.putExtra(CLICKTHROUGH_URL_KEY, clickthroughUrl);
         intent.putExtra(REDIRECT_URL_KEY, redirectUrl);
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
+        intent.putExtra(CREATIVE_ORIENTATION_KEY, orientation);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
-    static void preRenderHtml(final Context context, final CustomEventInterstitialListener customEventInterstitialListener, String htmlData) {
-        HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, customEventInterstitialListener, false, null, null, null);
+    static void preRenderHtml(final Context context, final AdReport adReport,
+            final CustomEventInterstitialListener customEventInterstitialListener,
+            String htmlData) {
+        HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, adReport, customEventInterstitialListener, false, null, null);
         dummyWebView.enablePlugins(false);
-
-        dummyWebView.addMoPubUriJavascriptInterface(new HtmlInterstitialWebView.MoPubUriJavascriptFireFinishLoadListener() {
-            @Override
-            public void onInterstitialLoaded() {
-                customEventInterstitialListener.onInterstitialLoaded();
-            }
-        });
         dummyWebView.setWebViewClient(new WebViewClient() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
@@ -83,7 +93,7 @@ public View getAdView() {
         String clickthroughUrl = intent.getStringExtra(CLICKTHROUGH_URL_KEY);
         String htmlResponse = intent.getStringExtra(HTML_RESPONSE_BODY_KEY);
 
-        mHtmlInterstitialWebView = HtmlInterstitialWebViewFactory.create(getApplicationContext(), new BroadcastingInterstitialListener(), isScrollable, redirectUrl, clickthroughUrl, getAdConfiguration());
+        mHtmlInterstitialWebView = HtmlInterstitialWebViewFactory.create(getApplicationContext(), mAdReport, new BroadcastingInterstitialListener(), isScrollable, redirectUrl, clickthroughUrl);
         mHtmlInterstitialWebView.loadHtmlResponse(htmlResponse);
 
         return mHtmlInterstitialWebView;
@@ -93,6 +103,15 @@ public View getAdView() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        // Lock the device orientation
+        Serializable orientationExtra = getIntent().getSerializableExtra(DataKeys.CREATIVE_ORIENTATION_KEY);
+        CreativeOrientation requestedOrientation;
+        if (orientationExtra == null || !(orientationExtra instanceof CreativeOrientation)) {
+            requestedOrientation = CreativeOrientation.UNDEFINED;
+        } else {
+            requestedOrientation = (CreativeOrientation) orientationExtra;
+        }
+        DeviceUtils.lockOrientation(this, requestedOrientation);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
deleted file mode 100644
index ff9a8f49..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.mopub.mobileads;
-
-
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.util.Log;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.mobileads.util.Utils;
-
-class MoPubBrowserController extends MraidAbstractController {
-    private static final String LOGTAG = "MoPubBrowserController";
-    private Context mContext;
-
-    MoPubBrowserController(MraidView view) {
-        super(view);
-        mContext = view.getContext();
-    }
-    
-    protected void open(String url) {
-        Log.d(LOGTAG, "Opening url: " + url);
-        
-        final MraidView mraidView = getMraidView();
-        if (mraidView.getMraidListener() != null) {
-            mraidView.getMraidListener().onOpen(mraidView);
-        }
-
-        // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
-            launchApplicationUrl(url);
-            return;
-        }
-
-        Intent i = new Intent(mContext, MoPubBrowser.class);
-        i.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
-        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        mContext.startActivity(i);
-    }
-
-
-    private boolean launchApplicationUrl(String url) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Unable to open intent.";
-
-        return Utils.executeIntent(getMraidView().getContext(), intent, errorMessage);
-    }
-
-    private boolean isWebSiteUrl(String url) {
-        return url.startsWith("http://") || url.startsWith("https://");
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
index f1f98dc6..edcf4b3f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
@@ -2,31 +2,21 @@
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.GpsHelper;
+import com.mopub.common.Constants;
 import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.VolleyError;
 
 public class MoPubConversionTracker {
-    private static final String TRACK_HOST = "ads.mopub.com";
-    private static final String TRACK_HANDLER = "/m/open";
-
     private Context mContext;
     private String mIsTrackedKey;
     private SharedPreferences mSharedPreferences;
     private String mPackageName;
-    private ConversionTrackerGpsHelperListener mConversionTrackerGpsHelperListener;
-
-    public MoPubConversionTracker() {
-        mConversionTrackerGpsHelperListener = new ConversionTrackerGpsHelperListener();
-    }
 
     public void reportAppOpen(Context context) {
         if (context == null) {
@@ -39,7 +29,19 @@ public void reportAppOpen(Context context) {
         mSharedPreferences = SharedPreferencesHelper.getSharedPreferences(mContext);
 
         if (!isAlreadyTracked()) {
-            GpsHelper.fetchAdvertisingInfoAsync(mContext, mConversionTrackerGpsHelperListener);
+            TrackingRequest.makeTrackingHttpRequest(new ConversionUrlGenerator().generateUrlString(Constants.HOST),
+                    mContext, new TrackingRequest.Listener() {
+                @Override
+                public void onResponse(@NonNull String url) {
+                    mSharedPreferences
+                            .edit()
+                            .putBoolean(mIsTrackedKey, true)
+                            .commit();
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) { }
+            });
         } else {
             MoPubLog.d("Conversion already tracked");
         }
@@ -52,15 +54,12 @@ private boolean isAlreadyTracked() {
     private class ConversionUrlGenerator extends BaseUrlGenerator {
         @Override
         public String generateUrlString(String serverHostname) {
-            initUrlString(serverHostname, TRACK_HANDLER);
-
+            initUrlString(serverHostname, Constants.CONVERSION_TRACKING_HANDLER);
             setApiVersion("6");
             setPackageId(mPackageName);
-
             ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-            setUdid(clientMetadata.getAdvertisingId());
-            setDoNotTrack(clientMetadata.isDoNotTrackSet());
             setAppVersion(clientMetadata.getAppVersion());
+            appendAdvertisingInfoTemplates();
             return getFinalUrlString();
         }
 
@@ -68,46 +67,4 @@ private void setPackageId(String packageName) {
             addParam("id", packageName);
         }
     }
-
-    private class TrackOpen implements Runnable {
-        public void run() {
-            String url = new ConversionUrlGenerator().generateUrlString(TRACK_HOST);
-            MoPubLog.d("Conversion track: " + url);
-
-            DefaultHttpClient httpClient = HttpClientFactory.create();
-            HttpResponse response;
-            try {
-                HttpGet httpget = new HttpGet(url);
-                response = httpClient.execute(httpget);
-            } catch (Exception e) {
-                MoPubLog.d("Conversion track failed [" + e.getClass().getSimpleName() + "]: " + url);
-                return;
-            }
-
-            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.d("Conversion track failed: Status code != 200.");
-                return;
-            }
-
-            HttpEntity entity = response.getEntity();
-            if (entity == null || entity.getContentLength() == 0) {
-                MoPubLog.d("Conversion track failed: Response was empty.");
-                return;
-            }
-
-            // If we made it here, the request has been tracked
-            MoPubLog.d("Conversion track successful.");
-            mSharedPreferences
-                    .edit()
-                    .putBoolean(mIsTrackedKey, true)
-                    .commit();
-        }
-    }
-
-    class ConversionTrackerGpsHelperListener implements GpsHelper.GpsHelperListener {
-        @Override
-        public void onFetchAdInfoCompleted() {
-            new Thread(new TrackOpen()).start();
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index a858a746..d3322c04 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -2,10 +2,12 @@
 
 public enum MoPubErrorCode {
     NO_FILL("No ads found."),
+    WARMUP("Ad unit is warming up. Try again in a few minutes."),
     SERVER_ERROR("Unable to connect to MoPub adserver."),
     INTERNAL_ERROR("Unable to serve ad due to invalid internal state."),
     CANCELLED("Ad request was cancelled."),
-    
+    NO_CONNECTION("No internet connection detected."),
+
     ADAPTER_NOT_FOUND("Unable to find Native Network or Custom Event adapter."),
     ADAPTER_CONFIGURATION_ERROR("Native Network or Custom Event adapter was configured incorrectly."),
     NETWORK_TIMEOUT("Third-party network failed to respond in a timely manner."),
@@ -15,14 +17,17 @@
     VIDEO_CACHE_ERROR("Error creating a cache to store downloaded videos."),
     VIDEO_DOWNLOAD_ERROR("Error downloading video."),
 
+    VIDEO_NOT_AVAILABLE("No video loaded for ad unit."),
+    VIDEO_PLAYBACK_ERROR("Error playing a video."),
+
     UNSPECIFIED("Unspecified error.");
-    
+
     private final String message;
-    
+
     private MoPubErrorCode(String message) {
         this.message = message;
     }
-    
+
     @Override
     public String toString() {
         return this.message;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index be773f6c..5aa4176d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -3,7 +3,9 @@
 import android.app.Activity;
 import android.content.Context;
 import android.location.Location;
+import android.text.TextUtils;
 
+import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
@@ -11,8 +13,6 @@
 import java.util.Map;
 
 import static com.mopub.common.LocationService.LocationAwareness;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubInterstitial implements CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener {
@@ -253,8 +253,17 @@ public MoPubInterstitialView(Context context) {
         }
 
         @Override
-        protected void loadCustomEvent(Map<String, String> paramsMap) {
-            if (paramsMap == null) {
+        public AdFormat getAdFormat() {
+            return AdFormat.INTERSTITIAL;
+        }
+
+        @Override
+        protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+            if (mAdViewController == null) {
+                return;
+            }
+
+            if (TextUtils.isEmpty(customEventClassName)) {
                 MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
                 loadFailUrl(ADAPTER_NOT_FOUND);
                 return;
@@ -268,8 +277,10 @@ protected void loadCustomEvent(Map<String, String> paramsMap) {
 
             mCustomEventInterstitialAdapter = CustomEventInterstitialAdapterFactory.create(
                     MoPubInterstitial.this,
-                    paramsMap.get(CUSTOM_EVENT_NAME.getKey()),
-                    paramsMap.get(CUSTOM_EVENT_DATA.getKey()));
+                    customEventClassName,
+                    serverExtras,
+                    mAdViewController.getBroadcastIdentifier(),
+                    mAdViewController.getAdReport());
             mCustomEventInterstitialAdapter.setAdapterListener(MoPubInterstitial.this);
             mCustomEventInterstitialAdapter.loadInterstitial();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
new file mode 100644
index 00000000..ff9361f1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
@@ -0,0 +1,46 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.MoPubReward;
+
+import java.util.Set;
+
+/**
+ * Listener for rewarded video events. Implementers of this interface will receive events for all
+ * rewarded video ad units in the app.:
+ */
+public interface MoPubRewardedVideoListener {
+
+    /**
+     * Called when the adUnitId has loaded. At this point you should be able to call
+     * {@link com.mopub.common.MoPub#showRewardedVideo(String)} to show the video.
+     */
+    public void onRewardedVideoLoadSuccess(@NonNull String adUnitId);
+
+    /**
+     * Called when a video fails to load for the given ad unit id. The provided error code will
+     * give more insight into the reason for the failure to load.
+     */
+    public void onRewardedVideoLoadFailure(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video starts playing.
+     */
+    public void onRewardedVideoStarted(@NonNull String adUnitId);
+
+    /**
+     * Called when there is an error during video playback.
+     */
+    public void onRewardedVideoPlaybackError(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video is closed. At this point your application should resume.
+     */
+    public void onRewardedVideoClosed(@NonNull String adUnitId);
+
+    /**
+     * Called when a rewarded video is completed and the user should be rewarded.
+     */
+    public void onRewardedVideoCompleted(@NonNull Set<String> adUnitIds, @NonNull MoPubReward reward);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
new file mode 100644
index 00000000..cc285b42
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -0,0 +1,523 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.Constants;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.MoPubCollections;
+import com.mopub.common.util.Reflection;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+/**
+ */
+public class MoPubRewardedVideoManager {
+    private static MoPubRewardedVideoManager sInstance;
+    private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
+
+    @NonNull private final Handler mCallbackHandler;
+    @NonNull private WeakReference<Activity> mMainActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final AdRequestStatusMapping mAdRequestStatus;
+    @NonNull private final RewardedVideoData mRewardedVideoData;
+    @Nullable private MoPubRewardedVideoListener mVideoListener;
+    
+    @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
+    @NonNull private final Map<String, Set<MediationSettings>> mInstanceMediationSettings;
+
+    @NonNull private final Handler mCustomEventTimeoutHandler;
+    @NonNull private final Map<String, Runnable> mTimeoutMap;
+
+    public static class RewardedVideoRequestListener implements AdRequest.Listener {
+        public final String adUnitId;
+        private final MoPubRewardedVideoManager mVideoManager;
+
+        public RewardedVideoRequestListener(MoPubRewardedVideoManager videoManager, String adUnitId) {
+            this.adUnitId = adUnitId;
+            this.mVideoManager = videoManager;
+        }
+
+        @Override
+        public void onSuccess(final AdResponse response) {
+            mVideoManager.onAdSuccess(response, adUnitId);
+        }
+
+        @Override
+        public void onErrorResponse(final VolleyError volleyError) {
+            mVideoManager.onAdError(volleyError, adUnitId);
+        }
+    }
+
+    private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+        mContext = mainActivity.getApplicationContext();
+        mRewardedVideoData = new RewardedVideoData();
+        mCallbackHandler = new Handler(Looper.getMainLooper());
+        mGlobalMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
+        mInstanceMediationSettings = new HashMap<String, Set<MediationSettings>>();
+        mCustomEventTimeoutHandler = new Handler();
+        mTimeoutMap = new HashMap<String, Runnable>();
+        
+        mAdRequestStatus = new AdRequestStatusMapping();
+    }
+
+    public static synchronized void init(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            sInstance = new MoPubRewardedVideoManager(mainActivity, mediationSettings);
+        } else {
+            MoPubLog.e("Tried to call initializeRewardedVideo more than once. Only the first " +
+                    "initialization call has any effect.");
+        }
+    }
+
+    public static void updateActivity(@NonNull Activity activity) {
+        if (sInstance != null) {
+            sInstance.mMainActivity = new WeakReference<Activity>(activity);
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Returns a global {@link MediationSettings} object of the type 'clazz', if one is registered.
+     * This method will only return an object if its type is identical to 'clazz', not if it is a
+     * subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getGlobalMediationSettings(@NonNull final Class<T> clazz) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : sInstance.mGlobalMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns an instance {@link MediationSettings} object of the type 'clazz', if one is
+     * registered. This method will only return an object if its type is identical to 'clazz', not
+     * if it is a subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @param adUnitId String identifier used to obtain the appropriate instance MediationSettings
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getInstanceMediationSettings(
+            @NonNull final Class<T> clazz, @NonNull final String adUnitId) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        final Set<MediationSettings> instanceMediationSettings =
+                sInstance.mInstanceMediationSettings.get(adUnitId);
+        if (instanceMediationSettings == null) {
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : instanceMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Sets the {@link MoPubRewardedVideoListener} that will receive events from the
+     * rewarded video system. Set this to null to stop receiving event callbacks.
+     */
+    public static void setVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        if (sInstance != null) {
+            sInstance.mVideoListener = listener;
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Builds an AdRequest for the given adUnitId and adds it to the singleton RequestQueue. This
+     * method will not make a new request if there is already a video loading for this adUnitId.
+     *
+     * @param adUnitId MoPub adUnitId String
+     * @param mediationSettings Optional instance-level MediationSettings to associate with the
+     *                          above adUnitId.
+     */
+    public static void loadVideo(@NonNull String adUnitId, @Nullable final MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        // If any instance MediationSettings have been specified, update the internal map.
+        // Note: This always clears the MediationSettings for the ad unit, whether or not any
+        // MediationSettings have been provided.
+        final Set<MediationSettings> newInstanceMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(newInstanceMediationSettings, mediationSettings);
+        sInstance.mInstanceMediationSettings.put(adUnitId, newInstanceMediationSettings);
+
+        final AdUrlGenerator urlGenerator = new WebViewAdUrlGenerator(sInstance.mContext, false);
+        final String adUrlString = urlGenerator.withAdUnitId(adUnitId)
+                .withLocation(
+                        LocationService.getLastKnownLocation(
+                                sInstance.mContext,
+                                MoPub.getLocationPrecision(),
+                                MoPub.getLocationAwareness()
+                        )
+                )
+                .generateUrlString(Constants.HOST);
+
+        loadVideo(adUnitId, adUrlString);
+    }
+
+    private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlString) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
+                    "unit %s. A request is already pending.", adUnitId));
+            return;
+        }
+
+        // Issue MoPub request
+        final AdRequest request = new AdRequest(
+                adUrlString,
+                AdFormat.REWARDED_VIDEO,
+                adUnitId,
+                sInstance.mContext,
+                new RewardedVideoRequestListener(sInstance, adUnitId)
+        );
+        final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
+        requestQueue.add(request);
+        sInstance.mAdRequestStatus.markLoading(adUnitId);
+    }
+
+    public static boolean hasVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            return isPlayable(adUnitId, customEvent);
+        } else {
+            logErrorNotInitialized();
+            return false;
+        }
+    }
+
+    public static void showVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            if (isPlayable(adUnitId, customEvent)) {
+                sInstance.mAdRequestStatus.markPlayed(adUnitId);
+                customEvent.showVideo();
+            } else {
+                sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
+            }
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedVideo customEvent) {
+        return (sInstance != null
+                && sInstance.mAdRequestStatus.canPlay(adUnitId)
+                && customEvent != null
+                && customEvent.hasVideoAvailable());
+    }
+
+    ///// Ad Request / Response methods /////
+    private void onAdSuccess(AdResponse adResponse, String adUnitId) {
+        mAdRequestStatus.markLoaded(adUnitId,
+                adResponse.getFailoverUrl(),
+                adResponse.getImpressionTrackingUrl(),
+                adResponse.getClickTrackingUrl());
+
+        Integer timeoutMillis = adResponse.getAdTimeoutMillis();
+        if (timeoutMillis == null || timeoutMillis <= 0) {
+            timeoutMillis = DEFAULT_LOAD_TIMEOUT;
+        }
+
+        final String customEventClassName = adResponse.getCustomEventClassName();
+        if (customEventClassName == null) {
+            MoPubLog.e("Couldn't create custom event, class name was null.");
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        try {
+            // Instantiate a custom event
+            final CustomEventRewardedVideo customEvent =
+                    Reflection.instantiateClassWithEmptyConstructor(
+                            customEventClassName,
+                            CustomEventRewardedVideo.class);
+
+            // Put important data into localExtras...
+            final Map<String, Object> localExtras = new TreeMap<String, Object>();
+            localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
+
+            Activity mainActivity = mMainActivity.get();
+            if (mainActivity == null) {
+                MoPubLog.d("Could not load custom event because Activity reference was null. Call" +
+                        " MoPub#updateActivity before requesting more rewarded videos.");
+
+                // Don't go through the ordinary failover process since we have
+                // no activity for the failover to use.
+                mAdRequestStatus.markFail(adUnitId);
+                return;
+            }
+
+            // Set up timeout calls.
+            Runnable timeout = new Runnable() {
+                @Override
+                public void run() {
+                    MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
+                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(),
+                            MoPubErrorCode.NETWORK_TIMEOUT);
+                    customEvent.onInvalidate();
+                }
+            };
+            mCustomEventTimeoutHandler.postDelayed(timeout, timeoutMillis);
+            mTimeoutMap.put(adUnitId, timeout);
+
+            // Load custom event
+            customEvent.loadCustomEvent(mainActivity, localExtras, adResponse.getServerExtras());
+
+            final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
+                    customEvent.getVideoListenerForSdk();
+            final String adNetworkId = customEvent.getAdNetworkId();
+            mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
+        } catch (Exception e) {
+            MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+        }
+    }
+
+    private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitId) {
+        MoPubErrorCode errorCode = MoPubErrorCode.INTERNAL_ERROR;
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError err = (MoPubNetworkError) volleyError;
+            switch (err.getReason()) {
+                case NO_FILL:
+                case WARMING_UP:
+                    errorCode = MoPubErrorCode.NO_FILL;
+                    break;
+                case BAD_BODY:
+                case BAD_HEADER_DATA:
+                default:
+                    errorCode = MoPubErrorCode.INTERNAL_ERROR;
+            }
+        }
+        if (volleyError instanceof com.mopub.volley.NoConnectionError) {
+            errorCode = MoPubErrorCode.NO_CONNECTION;
+        }
+        failover(adUnitId, errorCode);
+    }
+
+    private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
+        mAdRequestStatus.markFail(adUnitId);
+
+        if (failoverUrl != null) {
+            loadVideo(adUnitId, failoverUrl);
+        } else if (mVideoListener != null) {
+            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
+        }
+    }
+
+    private void cancelTimeouts(@NonNull String moPubId) {
+        final Runnable runnable = mTimeoutMap.remove(moPubId);
+        if (runnable != null) {  // We can't pass null or all callbacks will be removed.
+            mCustomEventTimeoutHandler.removeCallbacks(runnable);
+        }
+    }
+
+    //////// Listener methods that should be called by third-party SDKs. //////////
+
+    /**
+     * Notify the manager that a rewarded video loaded successfully.
+     *
+     * @param customEventClass - the Class of the third-party custom event object.
+     * @param thirdPartyId - the ad id of the third party SDK. This may be an empty String if the
+     *                     SDK does not use ad ids, zone ids, or a analogous concept.
+     * @param <T> - a class that extends {@link CustomEventRewardedVideo}. Only rewarded video
+     *           custom events should use these methods.
+     */
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                sInstance.cancelTimeouts(moPubId);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                   sInstance.cancelTimeouts(moPubId);
+                   sInstance.failover(moPubId, errorCode);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
+                }
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getImpressionTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearImpressionUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
+                }
+            }
+        });
+
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getClickTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearClickUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
+        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
+        postToInstance(new Runnable() {
+            @Override
+            public void run() {
+                final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
+                Set<String> rewarded = new HashSet<String>(moPubIds);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
+                }
+            }
+        });
+    }
+
+    /**
+     * Posts the runnable to the static instance's handler. Does nothing if sInstance is null.
+     * Useful for ensuring that all event callbacks run on the main thread.
+     * The {@link Runnable} can assume that sInstance is non-null.
+     */
+    private static void postToInstance(@NonNull Runnable runnable) {
+        if (sInstance != null) {
+            sInstance.mCallbackHandler.post(runnable);
+        }
+    }
+
+    private static void logErrorNotInitialized() {
+        MoPubLog.e("MoPub rewarded video was not initialized. You must call " +
+                "MoPub.initializeRewardedVideo() before loading or attempting " +
+                "to play video ads.");
+    }
+
+    /**
+     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
+     */
+    private static abstract class ForEachMoPubIdRunnable implements Runnable {
+
+        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
+        @NonNull private final String mThirdPartyId;
+
+        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String thirdPartyId) {
+            Preconditions.checkNotNull(customEventClass);
+            Preconditions.checkNotNull(thirdPartyId);
+            mCustomEventClass = customEventClass;
+            mThirdPartyId = thirdPartyId;
+        }
+
+        protected abstract void forEach(@NonNull final String moPubId);
+
+        @Override
+        public void run() {
+            final Set<String> moPubIds = sInstance.mRewardedVideoData
+                    .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
+            for (String moPubId : moPubIds) {
+                forEach(moPubId);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
index 86aad8f7..ca0f5422 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -6,10 +6,14 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.location.Location;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.View;
 import android.webkit.WebViewDatabase;
 import android.widget.FrameLayout;
+
+import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.ManifestUtils;
@@ -17,11 +21,10 @@
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
-import java.util.*;
+import java.util.Map;
+import java.util.TreeMap;
 
 import static com.mopub.common.LocationService.LocationAwareness;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubView extends FrameLayout {
@@ -33,11 +36,8 @@
         public void onBannerCollapsed(MoPubView banner);
     }
 
-    public static final String HOST = "ads.mopub.com";
-    public static final String HOST_FOR_TESTING = "testing.ads.mopub.com";
-    public static final String AD_HANDLER = "/m/ad";
     public static final int DEFAULT_LOCATION_PRECISION = 6;
-
+    @Nullable
     protected AdViewController mAdViewController;
     protected CustomEventBannerAdapter mCustomEventBannerAdapter;
 
@@ -148,8 +148,11 @@ protected void loadFailUrl(MoPubErrorCode errorCode) {
         if (mAdViewController != null) mAdViewController.loadFailUrl(errorCode);
     }
 
-    protected void loadCustomEvent(Map<String, String> paramsMap) {
-        if (paramsMap == null) {
+    protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+        if (mAdViewController == null) {
+            return;
+        }
+        if (TextUtils.isEmpty(customEventClassName)) {
             MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
             loadFailUrl(ADAPTER_NOT_FOUND);
             return;
@@ -163,8 +166,10 @@ protected void loadCustomEvent(Map<String, String> paramsMap) {
 
         mCustomEventBannerAdapter = CustomEventBannerAdapterFactory.create(
                 this,
-                paramsMap.get(CUSTOM_EVENT_NAME.getKey()),
-                paramsMap.get(CUSTOM_EVENT_DATA.getKey()));
+                customEventClassName,
+                serverExtras,
+                mAdViewController.getBroadcastIdentifier(),
+                mAdViewController.getAdReport());
         mCustomEventBannerAdapter.loadAd();
     }
 
@@ -292,12 +297,18 @@ public String getResponseString() {
         return (mAdViewController != null) ? mAdViewController.getResponseString() : null;
     }
 
+    @Deprecated
     public void setClickthroughUrl(String url) {
-        if (mAdViewController != null) mAdViewController.setClickthroughUrl(url);
+        // Does nothing.
     }
 
+    public String getClickTrackingUrl() {
+        return (mAdViewController != null) ? mAdViewController.getClickTrackingUrl() : null;
+    }
+
+    @Deprecated
     public String getClickthroughUrl() {
-        return (mAdViewController != null) ? mAdViewController.getClickthroughUrl() : null;
+        return getClickTrackingUrl();
     }
 
     public Activity getActivity() {
@@ -317,8 +328,10 @@ public void setLocalExtras(Map<String, Object> localExtras) {
     }
 
     public Map<String, Object> getLocalExtras() {
-        if (mAdViewController != null) return mAdViewController.getLocalExtras();
-        return Collections.emptyMap();
+        if (mAdViewController != null) {
+            return mAdViewController.getLocalExtras();
+        }
+        return new TreeMap<String, Object>();
     }
 
     public void setAutorefreshEnabled(boolean enabled) {
@@ -366,6 +379,10 @@ AdViewController getAdViewController() {
         return mAdViewController;
     }
 
+    public AdFormat getAdFormat() {
+        return AdFormat.BANNER;
+    }
+
     @Deprecated
     public void setLocationAwareness(LocationAwareness locationAwareness) {
         MoPub.setLocationAwareness(locationAwareness.getNewLocationAwareness());
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidAbstractController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidAbstractController.java
deleted file mode 100644
index 7f56c51f..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidAbstractController.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package com.mopub.mobileads;
-
-
-class MraidAbstractController {
-    private final MraidView mMraidView;
-
-    MraidAbstractController(MraidView view) {
-        super();
-        mMraidView = view;
-    }
-    
-    public MraidView getMraidView() {
-        return mMraidView;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
index ac5dedce..2ae82e8d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
@@ -1,163 +1,201 @@
 package com.mopub.mobileads;
 
-import android.annotation.TargetApi;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.View;
 import android.view.WindowManager;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
-import com.mopub.mobileads.MraidView.ExpansionStyle;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.MraidViewFactory;
-import com.mopub.mobileads.util.WebViews;
-
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.MraidController.MraidListener;
+import com.mopub.mraid.MraidController.UseCustomCloseListener;
+import com.mopub.mraid.MraidWebViewDebugListener;
+import com.mopub.mraid.PlacementType;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidActivity extends BaseInterstitialActivity {
-    private MraidView mMraidView;
+    @Nullable private MraidController mMraidController;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
 
-    static void preRenderHtml(final Context context, final CustomEventInterstitial.CustomEventInterstitialListener customEventInterstitialListener, final String htmlData) {
-        MraidView dummyMraidView = MraidViewFactory.create(context, null, ExpansionStyle.DISABLED, NativeCloseButtonStyle.ALWAYS_VISIBLE, PlacementType.INTERSTITIAL);
+    public static void preRenderHtml(@NonNull final Context context,
+            @NonNull final CustomEventInterstitialListener customEventInterstitialListener,
+            @NonNull final String htmlData) {
+        BaseWebView dummyWebView = new BaseWebView(context);
 
-        dummyMraidView.enablePlugins(false);
-        dummyMraidView.setMraidListener(new MraidView.MraidListener() {
+        dummyWebView.enablePlugins(false);
+        dummyWebView.setWebViewClient(new WebViewClient() {
             @Override
-            public void onReady(MraidView view) {
+            public void onPageFinished(final WebView view, final String url) {
                 customEventInterstitialListener.onInterstitialLoaded();
             }
 
-            @Override
-            public void onFailure(MraidView view) {
-                customEventInterstitialListener.onInterstitialFailed(null);
-            }
-
-            @Override
-            public void onExpand(MraidView view) {
-            }
-
-            @Override
-            public void onOpen(MraidView view) {
-            }
-
-            @Override
-            public void onClose(MraidView view, MraidView.ViewState newViewState) {
-            }
-        });
-        dummyMraidView.setWebViewClient(new WebViewClient() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 return true;
             }
 
             @Override
-            public void onPageFinished(WebView view, String url) {
-                customEventInterstitialListener.onInterstitialLoaded();
+            public void onReceivedError(final WebView view, final int errorCode,
+                    final String description,
+                    final String failingUrl) {
+                super.onReceivedError(view, errorCode, description, failingUrl);
+                customEventInterstitialListener.onInterstitialFailed(
+                        MoPubErrorCode.MRAID_LOAD_ERROR);
             }
         });
-        dummyMraidView.loadHtmlData(htmlData);
+
+        dummyWebView.loadDataWithBaseURL("http://" + Constants.HOST + "/",
+                htmlData, "text/html", "UTF-8", null);
     }
 
-    public static void start(Context context, String htmlData, AdConfiguration adConfiguration) {
-        Intent intent = createIntent(context, htmlData, adConfiguration);
+    public static void start(@NonNull Context context, @Nullable AdReport adreport, @NonNull String htmlData, long broadcastIdentifier) {
+        Intent intent = createIntent(context, adreport, htmlData, broadcastIdentifier);
         try {
             context.startActivity(intent);
-        } catch (ActivityNotFoundException anfe) {
+        } catch (ActivityNotFoundException exception) {
             Log.d("MraidInterstitial", "MraidActivity.class not found. Did you declare MraidActivity in your manifest?");
         }
     }
 
-    private static Intent createIntent(Context context, String htmlData, AdConfiguration adConfiguration) {
+    @VisibleForTesting
+    protected static Intent createIntent(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull String htmlData, long broadcastIdentifier) {
         Intent intent = new Intent(context, MraidActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
     @Override
     public View getAdView() {
-        mMraidView = MraidViewFactory.create(this, getAdConfiguration(), ExpansionStyle.DISABLED, NativeCloseButtonStyle.AD_CONTROLLED, PlacementType.INTERSTITIAL);
+        String htmlData = getIntent().getStringExtra(HTML_RESPONSE_BODY_KEY);
+        if (htmlData == null) {
+            MoPubLog.w("MraidActivity received a null HTML body. Finishing the activity.");
+            finish();
+            return new View(this);
+        }
 
-        mMraidView.setMraidListener(new MraidView.BaseMraidListener(){
-            public void onReady(MraidView view) {
-                mMraidView.loadUrl(WEB_VIEW_DID_APPEAR.getUrl());
-                showInterstitialCloseButton();
+        mMraidController = new MraidController(
+                this, mAdReport, PlacementType.INTERSTITIAL);
+
+        mMraidController.setDebugListener(mDebugListener);
+        mMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // This is only done for the interstitial. Banners have a different mechanism
+                // for tracking third party impressions.
+                mMraidController.loadJavascript(WEB_VIEW_DID_APPEAR.getJavascript());
             }
 
             @Override
-            public void onOpen(MraidView view) {
-                broadcastAction(MraidActivity.this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_CLICK);
+            public void onFailedToLoad() {
+                MoPubLog.d("MraidActivity failed to load. Finishing the activity");
+                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_FAIL);
+                finish();
             }
 
-            public void onClose(MraidView view, ViewState newViewState) {
-                mMraidView.loadUrl(WEB_VIEW_DID_CLOSE.getUrl());
+            public void onClose() {
+                mMraidController.loadJavascript(WEB_VIEW_DID_CLOSE.getJavascript());
                 finish();
             }
+
+            @Override
+            public void onExpand() {
+                // No-op. The interstitial is always expanded.
+            }
+
+            @Override
+            public void onOpen() {
+                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_CLICK);
+            }
         });
 
-        mMraidView.setOnCloseButtonStateChange(new MraidView.OnCloseButtonStateChangeListener() {
-            public void onCloseButtonStateChange(MraidView view, boolean enabled) {
-                if (enabled) {
-                    showInterstitialCloseButton();
-                } else {
+        // Needed because the Activity provides the close button, not the controller. This
+        // gets called if the creative calls mraid.useCustomClose.
+        mMraidController.setUseCustomCloseListener(new UseCustomCloseListener() {
+            public void useCustomCloseChanged(boolean useCustomClose) {
+                if (useCustomClose) {
                     hideInterstitialCloseButton();
+                } else {
+                    showInterstitialCloseButton();
                 }
             }
         });
 
-        String source = getIntent().getStringExtra(HTML_RESPONSE_BODY_KEY);
-        mMraidView.loadHtmlData(source);
-
-        return mMraidView;
+        mMraidController.loadContent(htmlData);
+        return mMraidController.getAdContainer();
     }
 
-    @TargetApi(11)
     @Override
-    public void onCreate(Bundle savedInstanceState) {
+    public void onCreate(@Nullable Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
 
-        if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
+        if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
             getWindow().setFlags(
                     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
                     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         }
-
-        addCloseEventRegion();
     }
 
     @Override
     protected void onPause() {
+        if (mMraidController != null) {
+            mMraidController.pause(isFinishing());
+        }
         super.onPause();
-        WebViews.onPause(mMraidView);
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        WebViews.onResume(mMraidView);
+        if (mMraidController != null) {
+            mMraidController.resume();
+        }
     }
 
     @Override
     protected void onDestroy() {
-        mMraidView.destroy();
+        if (mMraidController != null) {
+            mMraidController.destroy();
+        }
+
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_DISMISS);
         super.onDestroy();
     }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mMraidController != null) {
+            mMraidController.setDebugListener(debugListener);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
deleted file mode 100644
index f79a337b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.MraidViewFactory;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
-import static com.mopub.mobileads.MraidView.MraidListener;
-
-class MraidBanner extends CustomEventBanner {
-    private MraidView mMraidView;
-    private CustomEventBannerListener mBannerListener;
-
-    @Override
-    protected void loadBanner(Context context,
-                    CustomEventBannerListener customEventBannerListener,
-                    Map<String, Object> localExtras,
-                    Map<String, String> serverExtras) {
-        mBannerListener = customEventBannerListener;
-
-        String htmlData;
-        if (extrasAreValid(serverExtras)) {
-            htmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-        } else {
-            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
-            return;
-        }
-
-        AdConfiguration adConfiguration = AdConfiguration.extractFromMap(localExtras);
-        mMraidView = MraidViewFactory.create(context, adConfiguration);
-        mMraidView.loadHtmlData(htmlData);
-        initMraidListener();
-    }
-
-    @Override
-    protected void onInvalidate() {
-        if (mMraidView != null) {
-            resetMraidListener();
-            mMraidView.destroy();
-        }
-    }
-
-    private void onReady() {
-        mBannerListener.onBannerLoaded(mMraidView);
-    }
-
-    private void onFail() {
-        mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
-    }
-
-    private void onExpand() {
-        mBannerListener.onBannerExpanded();
-        mBannerListener.onBannerClicked();
-    }
-
-    private void onOpen() {
-        mBannerListener.onBannerClicked();
-    }
-
-    private void onClose() {
-        mBannerListener.onBannerCollapsed();
-    }
-
-    private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
-    }
-
-    private void initMraidListener() {
-        mMraidView.setMraidListener(new MraidListener() {
-            public void onReady(MraidView view) {
-                MraidBanner.this.onReady();
-            }
-            public void onFailure(MraidView view) {
-                onFail();
-            }
-            public void onExpand(MraidView view) {
-                MraidBanner.this.onExpand();
-            }
-            public void onOpen(MraidView view) {
-                MraidBanner.this.onOpen();
-            }
-            public void onClose(MraidView view, ViewState newViewState) {
-                MraidBanner.this.onClose();
-            }
-        });
-    }
-
-    private void resetMraidListener() {
-        mMraidView.setMraidListener(null);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommand.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommand.java
deleted file mode 100644
index c6e64d64..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommand.java
+++ /dev/null
@@ -1,288 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.OPEN;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.PLAY_VIDEO;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.RESIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.SET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidView.PlacementType;
-
-abstract class MraidCommand {
-    protected static final String URI_KEY = "uri";
-    protected Map<String, String> mParams;
-    protected MraidView mView;
-
-    MraidCommand(Map<String, String> params, MraidView view) {
-        mParams = params;
-        mView = view;
-    }
-    
-    abstract void execute();
-    
-    protected int getIntFromParamsForKey(String key) {
-        String s = mParams.get(key);
-        if (s == null) return -1;
-        else {
-            try {
-                return Integer.parseInt(s, 10);
-            } catch (NumberFormatException e) {
-                return -1;
-            }
-        }
-    }
-    
-    protected String getStringFromParamsForKey(String key) {
-        return mParams.get(key);
-    }
-    
-    protected float getFloatFromParamsForKey(String key) {
-        String s = mParams.get(key);
-        if (s == null) return 0.0f;
-        else {
-            try {
-                return Float.parseFloat(key);
-            } catch (NumberFormatException e) {
-                return 0.0f;
-            }
-        }
-    }
-    
-    protected boolean getBooleanFromParamsForKey(String key) {
-        return "true".equals(mParams.get(key));
-    }
-
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return false;
-    }
-}
-
-class MraidCommandPlayVideo extends MraidCommand {
-    public MraidCommandPlayVideo(Map<String,String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        String url = getStringFromParamsForKey(URI_KEY);
-        if (url != null && !url.equals("")){
-            mView.getDisplayController().showVideo(url);
-        } else {
-            mView.fireErrorEvent(PLAY_VIDEO, "Video can't be played with null or empty URL");
-        }
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        switch (placementType) {
-            case INLINE:
-                return true;
-            case INTERSTITIAL:
-                return false;
-            default:
-                return super.isCommandDependentOnUserClick(placementType);
-        }
-    }
-}
-
-class MraidCommandStorePicture extends MraidCommand {
-    public static final String MIME_TYPE_HEADER = "Content-Type";
-
-    public MraidCommandStorePicture(Map<String,String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        String url = getStringFromParamsForKey(URI_KEY);
-
-        if (url != null && !url.equals("")) {
-            mView.getDisplayController().showUserDownloadImageAlert(url);
-        } else {
-            mView.fireErrorEvent(STORE_PICTURE, "Image can't be stored with null or empty URL");
-            MoPubLog.d("Invalid URI for Mraid Store Picture.");
-        }
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return true;
-    }
-}
-
-class MraidCommandClose extends MraidCommand {
-    MraidCommandClose(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().close();
-    }
-}
-
-class MraidCommandExpand extends MraidCommand {
-    MraidCommandExpand(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        int width = getIntFromParamsForKey("w");
-        int height = getIntFromParamsForKey("h");
-        String url = getStringFromParamsForKey("url");
-        boolean shouldUseCustomClose = getBooleanFromParamsForKey("shouldUseCustomClose");
-        boolean shouldLockOrientation = getBooleanFromParamsForKey("lockOrientation");
-        
-        if (width <= 0) width = mView.getDisplayController().mScreenWidth;
-        if (height <= 0) height = mView.getDisplayController().mScreenHeight;
-        
-        mView.getDisplayController().expand(url, width, height, shouldUseCustomClose,
-                shouldLockOrientation);
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        switch (placementType) {
-            case INLINE:
-                return true;
-            case INTERSTITIAL:
-                return false;
-            default:
-                return super.isCommandDependentOnUserClick(placementType);
-        }
-    }
-}
-
-class MraidCommandUseCustomClose extends MraidCommand {
-    MraidCommandUseCustomClose(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        boolean shouldUseCustomClose = getBooleanFromParamsForKey("shouldUseCustomClose");
-        mView.getDisplayController().useCustomClose(shouldUseCustomClose);
-    }
-}
-
-class MraidCommandOpen extends MraidCommand {
-    MraidCommandOpen(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        String url = getStringFromParamsForKey("url");
-        if (url == null) {
-            mView.fireErrorEvent(OPEN, "Url can not be null.");
-            return;
-        }
-        mView.getBrowserController().open(url);
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return true;
-    }
-}
-
-//As of version 1.15, we've decided to stub the resize command. However, this should be implemented in future versions
-class MraidCommandResize extends MraidCommand {
-    MraidCommandResize(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.fireErrorEvent(RESIZE, "Unsupported action resize.");
-    }
-}
-
-class MraidCommandGetResizeProperties extends MraidCommand {
-    MraidCommandGetResizeProperties(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.fireErrorEvent(GET_RESIZE_PROPERTIES, "Unsupported action getResizeProperties.");
-    }
-}
-
-class MraidCommandSetResizeProperties extends MraidCommand {
-    MraidCommandSetResizeProperties(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.fireErrorEvent(SET_RESIZE_PROPERTIES, "Unsupported action setResizeProperties.");
-    }
-}
-
-class MraidCommandGetCurrentPosition extends MraidCommand {
-    MraidCommandGetCurrentPosition(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getCurrentPosition();
-    }
-}
-
-
-class MraidCommandGetDefaultPosition extends MraidCommand {
-    MraidCommandGetDefaultPosition(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getDefaultPosition();
-    }
-}
-
-class MraidCommandGetMaxSize extends MraidCommand {
-    MraidCommandGetMaxSize(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getMaxSize();
-    }
-}
-
-class MraidCommandGetScreenSize extends MraidCommand {
-    MraidCommandGetScreenSize(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getScreenSize();
-    }
-}
-
-class MraidCommandCreateCalendarEvent extends MraidCommand {
-    MraidCommandCreateCalendarEvent(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().createCalendarEvent(mParams);
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return true;
-    }
-}
-
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommandFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommandFactory.java
deleted file mode 100644
index 4145b710..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommandFactory.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package com.mopub.mobileads;
-
-import java.util.Map;
-
-class MraidCommandFactory {
-    protected static MraidCommandFactory instance = new MraidCommandFactory();
-
-    enum MraidJavascriptCommand {
-        CLOSE("close"),
-        EXPAND("expand"),
-        USECUSTOMCLOSE("usecustomclose"),
-        OPEN("open"),
-        RESIZE("resize"),
-        GET_RESIZE_PROPERTIES("getResizeProperties"),
-        SET_RESIZE_PROPERTIES("setResizeProperties"),
-        PLAY_VIDEO("playVideo"),
-        STORE_PICTURE("storePicture"),
-        GET_CURRENT_POSITION("getCurrentPosition"),
-        GET_DEFAULT_POSITION("getDefaultPosition"),
-        GET_MAX_SIZE("getMaxSize"),
-        GET_SCREEN_SIZE("getScreenSize"),
-        CREATE_CALENDAR_EVENT("createCalendarEvent"),
-        UNSPECIFIED("");
-
-        private String mCommand;
-
-        private MraidJavascriptCommand(String command) {
-            mCommand = command;
-        }
-
-        private static MraidJavascriptCommand fromString(String string) {
-            for (MraidJavascriptCommand command : MraidJavascriptCommand.values()) {
-                if (command.mCommand.equals(string)) {
-                    return command;
-                }
-            }
-
-            return UNSPECIFIED;
-        }
-
-        String getCommand() {
-            return mCommand;
-        }
-    }
-
-    @Deprecated // for testing
-    public static void setInstance(MraidCommandFactory factory) {
-        instance = factory;
-    }
-
-    public static MraidCommand create(String command, Map<String, String> params, MraidView view) {
-        return instance.internalCreate(command, params, view);
-    }
-
-    protected MraidCommand internalCreate(String command, Map<String, String> params, MraidView view) {
-        MraidJavascriptCommand mraidJavascriptCommand = MraidJavascriptCommand.fromString(command);
-
-        switch (mraidJavascriptCommand) {
-            case CLOSE:
-                return new MraidCommandClose(params, view);
-            case EXPAND:
-                return new MraidCommandExpand(params, view);
-            case USECUSTOMCLOSE:
-                return new MraidCommandUseCustomClose(params, view);
-            case OPEN:
-                return new MraidCommandOpen(params, view);
-            case RESIZE:
-                return new MraidCommandResize(params, view);
-            case GET_RESIZE_PROPERTIES:
-                return new MraidCommandGetResizeProperties(params, view);
-            case SET_RESIZE_PROPERTIES:
-                return new MraidCommandSetResizeProperties(params, view);
-            case PLAY_VIDEO:
-                return new MraidCommandPlayVideo(params, view);
-            case STORE_PICTURE:
-                return new MraidCommandStorePicture(params, view);
-            case GET_CURRENT_POSITION:
-                return new MraidCommandGetCurrentPosition(params, view);
-            case GET_DEFAULT_POSITION:
-                return new MraidCommandGetDefaultPosition(params, view);
-            case GET_MAX_SIZE:
-                return new MraidCommandGetMaxSize(params, view);
-            case GET_SCREEN_SIZE:
-                return new MraidCommandGetScreenSize(params, view);
-            case CREATE_CALENDAR_EVENT:
-                return new MraidCommandCreateCalendarEvent(params, view);
-            case UNSPECIFIED:
-                return null;
-            default:
-                return null;
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
deleted file mode 100644
index 8c1ac81a..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
+++ /dev/null
@@ -1,867 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.ActivityNotFoundException;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ActivityInfo;
-import android.graphics.Rect;
-import android.graphics.drawable.StateListDrawable;
-import android.media.MediaScannerConnection;
-import android.net.Uri;
-import android.os.Environment;
-import android.os.Handler;
-import android.provider.CalendarContract;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.View.OnTouchListener;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.webkit.URLUtil;
-import android.widget.FrameLayout;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
-import android.widget.Toast;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Streams;
-import com.mopub.mobileads.MraidView.ExpansionStyle;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.util.HttpResponses;
-import com.mopub.mobileads.util.Interstitials;
-import com.mopub.mobileads.util.Mraids;
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-
-import java.io.*;
-import java.net.URI;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-import static android.graphics.Color.TRANSPARENT;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.common.util.ResponseHeader.LOCATION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.EXPAND;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_CURRENT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_DEFAULT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_MAX_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_SCREEN_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidCommandStorePicture.MIME_TYPE_HEADER;
-import static com.mopub.mobileads.MraidView.BaseMraidListener;
-import static com.mopub.mobileads.util.Mraids.ANDROID_CALENDAR_CONTENT_TYPE;
-import static com.mopub.mobileads.util.Mraids.isCalendarAvailable;
-import static com.mopub.mobileads.util.Mraids.isInlineVideoAvailable;
-import static com.mopub.mobileads.util.Mraids.isSmsAvailable;
-import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
-import static com.mopub.mobileads.util.Mraids.isTelAvailable;
-
-class MraidDisplayController extends MraidAbstractController {
-    private static final String LOGTAG = "MraidDisplayController";
-    private static final long VIEWABILITY_TIMER_MILLIS = 3000;
-    private static final int CLOSE_BUTTON_SIZE_DP = 50;
-    private static final String[] DATE_FORMATS = {
-            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
-            "yyyy-MM-dd'T'HH:mmZZZZZ"
-    };
-    private static final int MAX_NUMBER_DAYS_IN_MONTH = 31;
-
-    // The view's current state.
-    private ViewState mViewState = ViewState.HIDDEN;
-
-    // Tracks whether this controller's view responds to expand() calls.
-    private final ExpansionStyle mExpansionStyle;
-
-    // Tracks how this controller's view should display its native close button.
-    private final NativeCloseButtonStyle mNativeCloseButtonStyle;
-
-    // Separate instance of MraidView, for displaying "two-part" creatives via the expand(URL) API.
-    private MraidView mTwoPartExpansionView;
-
-    // A reference to the root view.
-    private FrameLayout mRootView;
-
-    // Handler for scheduling viewability checks.
-    private Handler mHandler = new Handler();
-
-    // Stores the requested orientation for the Activity to which this controller's view belongs.
-    // This is needed to restore the Activity's requested orientation in the event that the view
-    // itself requires an orientation lock.
-    private final int mOriginalRequestedOrientation;
-
-    private OrientationBroadcastReceiver mOrientationBroadcastReceiver = new OrientationBroadcastReceiver();
-
-    // Native close button, used for expanded content.
-    private ImageView mCloseButton;
-
-    // Tracks whether expanded content provides its own, non-native close button.
-    private boolean mAdWantsCustomCloseButton;
-
-    // The scale factor for a dip (relative to a 160 dpi screen).
-    protected float mDensity;
-
-    // The width of the screen in pixels.
-    protected int mScreenWidth = -1;
-
-    // The height of the screen in pixels.
-    protected int mScreenHeight = -1;
-
-    // The view's position within its parent.
-    private int mViewIndexInParent;
-
-    // A view that replaces the MraidView within its parent view when the MraidView is expanded
-    // (i.e. moved to the top of the view hierarchy).
-    private FrameLayout mPlaceholderView;
-    private FrameLayout mAdContainerLayout;
-    private RelativeLayout mExpansionLayout;
-    private final OnClickListener mCloseOnClickListener;
-
-    MraidDisplayController(MraidView view, MraidView.ExpansionStyle expStyle,
-            MraidView.NativeCloseButtonStyle buttonStyle) {
-        super(view);
-        mExpansionStyle = expStyle;
-        mNativeCloseButtonStyle = buttonStyle;
-
-        Context context = getContext();
-        mOriginalRequestedOrientation = (context instanceof Activity) ?
-                ((Activity) context).getRequestedOrientation() :
-                ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
-
-        initialize();
-
-        mCloseOnClickListener = new OnClickListener() {
-            @Override
-            public void onClick(final View view) {
-                MraidDisplayController.this.close();
-            }
-        };
-
-        mAdContainerLayout = createAdContainerLayout();
-        mExpansionLayout = createExpansionLayout();
-        mPlaceholderView = createPlaceholderView();
-    }
-
-    private void initialize() {
-        mViewState = ViewState.LOADING;
-        initializeScreenMetrics();
-        mOrientationBroadcastReceiver.register(getContext());
-    }
-
-    private void initializeScreenMetrics() {
-        Context context = getContext();
-        DisplayMetrics metrics = new DisplayMetrics();
-        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        wm.getDefaultDisplay().getMetrics(metrics);
-        mDensity = metrics.density;
-
-        int statusBarHeight = 0, titleBarHeight = 0;
-        if (context instanceof Activity) {
-            Activity activity = (Activity) context;
-            Window window = activity.getWindow();
-            Rect rect = new Rect();
-            window.getDecorView().getWindowVisibleDisplayFrame(rect);
-            statusBarHeight = rect.top;
-            int contentViewTop = window.findViewById(Window.ID_ANDROID_CONTENT).getTop();
-            titleBarHeight = contentViewTop - statusBarHeight;
-        }
-
-        int widthPixels = metrics.widthPixels;
-        int heightPixels = metrics.heightPixels - statusBarHeight - titleBarHeight;
-        mScreenWidth = (int) (widthPixels * (160.0 / metrics.densityDpi));
-        mScreenHeight = (int) (heightPixels * (160.0 / metrics.densityDpi));
-    }
-
-    private int getDisplayRotation() {
-        WindowManager wm = (WindowManager) getContext()
-                .getSystemService(Context.WINDOW_SERVICE);
-        return wm.getDefaultDisplay().getOrientation();
-    }
-
-    private void onOrientationChanged(int currentRotation) {
-        initializeScreenMetrics();
-        getMraidView().fireChangeEventForProperty(
-                MraidScreenSizeProperty.createWithSize(mScreenWidth, mScreenHeight));
-    }
-
-    public void destroy() {
-        try {
-            mOrientationBroadcastReceiver.unregister();
-        } catch (IllegalArgumentException e) {
-            if (!e.getMessage().contains("Receiver not registered")) {
-                throw e;
-            } // Else ignore this exception.
-        }
-    }
-
-    protected void initializeJavaScriptState() {
-        ArrayList<MraidProperty> properties = new ArrayList<MraidProperty>();
-        properties.add(MraidScreenSizeProperty.createWithSize(mScreenWidth, mScreenHeight));
-        properties.add(MraidViewableProperty.createWithViewable(getMraidView().getIsVisible()));
-        getMraidView().fireChangeEventForProperties(properties);
-
-        mViewState = ViewState.DEFAULT;
-        getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        initializeSupportedFunctionsProperty();
-    }
-
-    protected boolean isExpanded() {
-        return (mViewState == ViewState.EXPANDED);
-    }
-
-    protected void close() {
-        if (mViewState == ViewState.EXPANDED) {
-            resetViewToDefaultState();
-            setOrientationLockEnabled(false);
-            mViewState = ViewState.DEFAULT;
-            getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        } else if (mViewState == ViewState.DEFAULT) {
-            getMraidView().setVisibility(View.INVISIBLE);
-            mViewState = ViewState.HIDDEN;
-            getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        }
-
-        if (getMraidView().getMraidListener() != null) {
-            getMraidView().getMraidListener().onClose(getMraidView(), mViewState);
-        }
-    }
-
-    private void resetViewToDefaultState() {
-        setNativeCloseButtonEnabled(false);
-        mAdContainerLayout.removeAllViewsInLayout();
-
-        mExpansionLayout.removeAllViewsInLayout();
-        mRootView.removeView(mExpansionLayout);
-
-        getMraidView().requestLayout();
-
-        ViewGroup parent = (ViewGroup) mPlaceholderView.getParent();
-        parent.addView(getMraidView(), mViewIndexInParent);
-        parent.removeView(mPlaceholderView);
-        parent.invalidate();
-    }
-
-    protected void expand(String url, int width, int height, boolean shouldUseCustomClose,
-            boolean shouldLockOrientation) {
-        if (mExpansionStyle == MraidView.ExpansionStyle.DISABLED) return;
-
-        if (url != null && !URLUtil.isValidUrl(url)) {
-            getMraidView().fireErrorEvent(EXPAND, "URL passed to expand() was invalid.");
-            return;
-        }
-
-        // Obtain the root content view, since that's where we're going to insert the expanded 
-        // content. We must do this before swapping the MraidView with its place-holder;
-        // otherwise, getRootView() will return the wrong view (or null).
-        mRootView = (FrameLayout) getMraidView().getRootView().findViewById(android.R.id.content);
-
-        useCustomClose(shouldUseCustomClose);
-        setOrientationLockEnabled(shouldLockOrientation);
-        swapViewWithPlaceholderView();
-
-        View expansionContentView = getMraidView();
-        if (url != null) {
-            mTwoPartExpansionView = new MraidView(getContext(), getMraidView().getAdConfiguration(), ExpansionStyle.DISABLED,
-                    NativeCloseButtonStyle.AD_CONTROLLED, PlacementType.INLINE);
-            mTwoPartExpansionView.setMraidListener(new BaseMraidListener() {
-                public void onClose(MraidView view, ViewState newViewState) {
-                    close();
-                }
-            });
-            mTwoPartExpansionView.loadUrl(url);
-            expansionContentView = mTwoPartExpansionView;
-        }
-
-        expandLayouts(expansionContentView, (int) (width * mDensity), (int) (height * mDensity));
-        mRootView.addView(mExpansionLayout, new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));
-
-        if (mNativeCloseButtonStyle == MraidView.NativeCloseButtonStyle.ALWAYS_VISIBLE ||
-                (!mAdWantsCustomCloseButton &&
-                mNativeCloseButtonStyle != MraidView.NativeCloseButtonStyle.ALWAYS_HIDDEN)) {
-            setNativeCloseButtonEnabled(true);
-        }
-
-        mViewState = ViewState.EXPANDED;
-        getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        if (getMraidView().getMraidListener() != null) getMraidView().getMraidListener().onExpand(getMraidView());
-    }
-
-    protected void showUserDownloadImageAlert(String imageUrl) {
-        Context context = getContext();
-        if (!isStorePictureSupported(context)) {
-            getMraidView().fireErrorEvent(STORE_PICTURE, "Error downloading file - the device does not have an SD card mounted, or the Android permission is not granted.");
-            MoPubLog.d("Error downloading file - the device does not have an SD card mounted, or the Android permission is not granted.");
-            return;
-        }
-
-        if (context instanceof Activity) {
-            showUserDialog(imageUrl);
-        } else {
-            showUserToast("Downloading image to Picture gallery...");
-            downloadImage(imageUrl);
-        }
-    }
-
-    private void showUserToast(final String message) {
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();
-            }
-        });
-    }
-
-    private void downloadImage(final String uriString) {
-        final File pictureStoragePath = getPictureStoragePath();
-
-        pictureStoragePath.mkdirs();
-
-        new Thread(new Runnable() {
-            private URI uri;
-            private InputStream pictureInputStream;
-            private OutputStream pictureOutputStream;
-            private MediaScannerConnection mediaScannerConnection;
-
-            @Override
-            public void run() {
-                try {
-                    uri = URI.create(uriString);
-                    HttpClient httpClient = HttpClientFactory.create();
-                    HttpGet httpGet = new HttpGet(uri);
-
-                    HttpResponse httpResponse = httpClient.execute(httpGet);
-                    pictureInputStream = httpResponse.getEntity().getContent();
-
-                    String redirectLocation = HttpResponses.extractHeader(httpResponse, LOCATION);
-                    if (redirectLocation != null) {
-                        uri = URI.create(redirectLocation);
-                    }
-
-                    final String pictureFileName = getFileNameForUriAndHttpResponse(uri, httpResponse);
-                    File pictureFile = new File(pictureStoragePath, pictureFileName);
-                    final String pictureFileFullPath = pictureFile.toString();
-                    pictureOutputStream = new FileOutputStream(pictureFile);
-
-                    Streams.copyContent(pictureInputStream, pictureOutputStream);
-
-                    loadPictureIntoGalleryApp(pictureFileFullPath);
-                } catch (Exception exception) {
-                    mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            showUserToast("Image failed to download.");
-                            getMraidView().fireErrorEvent(STORE_PICTURE, "Error downloading and saving image file.");
-                            MoPubLog.d("Error downloading and saving image file.");
-                        }
-                    });
-                } finally {
-                    Streams.closeStream(pictureInputStream);
-                    Streams.closeStream(pictureOutputStream);
-                }
-            }
-
-            private void loadPictureIntoGalleryApp(final String filename) {
-                MoPubMediaScannerConnectionClient mediaScannerConnectionClient = new MoPubMediaScannerConnectionClient(filename, null);
-                mediaScannerConnection = new MediaScannerConnection(getContext().getApplicationContext(), mediaScannerConnectionClient);
-                mediaScannerConnectionClient.setMediaScannerConnection(mediaScannerConnection);
-                mediaScannerConnection.connect();
-            }
-        }).start();
-    }
-
-    private void showUserDialog(final String imageUrl) {
-        AlertDialog.Builder alertDialogDownloadImage = new AlertDialog.Builder(getContext());
-        alertDialogDownloadImage
-                .setTitle("Save Image")
-                .setMessage("Download image to Picture gallery?")
-                .setNegativeButton("Cancel", null)
-                .setPositiveButton("Okay", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        downloadImage(imageUrl);
-                    }
-                })
-                .setCancelable(true)
-                .show();
-    }
-
-    protected void showVideo(String videoUrl) {
-        MraidVideoPlayerActivity.startMraid(getContext(), videoUrl, getMraidView().getAdConfiguration());
-    }
-
-    protected void getCurrentPosition(){
-        getMraidView().fireErrorEvent(GET_CURRENT_POSITION, "Unsupported action getCurrentPosition");
-    }
-
-    protected void getDefaultPosition(){
-        getMraidView().fireErrorEvent(GET_DEFAULT_POSITION, "Unsupported action getDefaultPosition");
-    }
-
-    protected void getMaxSize(){
-        getMraidView().fireErrorEvent(GET_MAX_SIZE, "Unsupported action getMaxSize");
-    }
-
-    protected void getScreenSize(){
-        getMraidView().fireErrorEvent(GET_SCREEN_SIZE, "Unsupported action getScreenSize");
-    }
-
-    protected void createCalendarEvent(Map<String, String> params) {
-        Context context = getMraidView().getContext();
-        if (Mraids.isCalendarAvailable(context)) {
-            try {
-                Map<String, Object> calendarParams = translateJSParamsToAndroidCalendarEventMapping(params);
-                Intent intent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
-                for (String key : calendarParams.keySet()) {
-                    Object value = calendarParams.get(key);
-                    if (value instanceof Long) {
-                        intent.putExtra(key, ((Long) value).longValue());
-                    } else if (value instanceof Integer) {
-                        intent.putExtra(key, ((Integer) value).intValue());
-                    } else {
-                        intent.putExtra(key, (String) value);
-                    }
-                }
-                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                context.startActivity(intent);
-            } catch (ActivityNotFoundException anfe) {
-                Log.d(LOGTAG, "no calendar app installed");
-                getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, "Action is unsupported on this device - no calendar app installed");
-            } catch (IllegalArgumentException iae) {
-                Log.d(LOGTAG, "create calendar: invalid parameters " + iae.getMessage());
-                getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, iae.getMessage());
-            } catch (Exception exception){
-                Log.d(LOGTAG, "could not create calendar event");
-                getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, "could not create calendar event");
-            }
-        } else {
-            Log.d(LOGTAG, "unsupported action createCalendarEvent for devices pre-ICS");
-            getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, "Action is unsupported on this device (need Android version Ice Cream Sandwich or above)");
-        }
-    }
-
-    private Map<String, Object> translateJSParamsToAndroidCalendarEventMapping(Map<String, String> params) throws Exception {
-        Map<String, Object> validatedParamsMapping = new HashMap<String, Object>();
-        if (!params.containsKey("description") || !params.containsKey("start")) {
-            throw new IllegalArgumentException("Missing start and description fields");
-        }
-
-        validatedParamsMapping.put(CalendarContract.Events.TITLE, params.get("description"));
-
-        if (params.containsKey("start") && params.get("start") != null) {
-            Date startDateTime = parseDate(params.get("start"));
-            if (startDateTime != null) {
-                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_BEGIN_TIME, startDateTime.getTime());
-            } else {
-                throw new IllegalArgumentException("Invalid calendar event: start time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
-            }
-        } else {
-            throw new IllegalArgumentException("Invalid calendar event: start is null.");
-        }
-
-        if (params.containsKey("end") && params.get("end") != null) {
-            Date endDateTime = parseDate(params.get("end"));
-            if (endDateTime != null) {
-                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_END_TIME, endDateTime.getTime());
-            } else {
-                throw new IllegalArgumentException("Invalid calendar event: end time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
-            }
-        }
-
-        if (params.containsKey("location")) {
-            validatedParamsMapping.put(CalendarContract.Events.EVENT_LOCATION, params.get("location"));
-        }
-
-        if (params.containsKey("summary")) {
-            validatedParamsMapping.put(CalendarContract.Events.DESCRIPTION, params.get("summary"));
-        }
-
-        if (params.containsKey("transparency")) {
-            validatedParamsMapping.put(
-                    CalendarContract.Events.AVAILABILITY,
-                    params.get("transparency").equals("transparent") ?
-                            CalendarContract.Events.AVAILABILITY_FREE :
-                            CalendarContract.Events.AVAILABILITY_BUSY
-            );
-        }
-
-        validatedParamsMapping.put(CalendarContract.Events.RRULE, parseRecurrenceRule(params));
-
-        return validatedParamsMapping;
-    }
-
-    private Date parseDate(String dateTime) {
-        Date result = null;
-        for (int i=0; i<DATE_FORMATS.length; i++) {
-            try {
-                result = new SimpleDateFormat(DATE_FORMATS[i]).parse(dateTime);
-                if (result != null) {
-                    break;
-                }
-            } catch (ParseException e) {
-                // an exception is okay, just try the next format and find the first one that works
-            }
-        }
-        return result;
-    }
-
-    private String parseRecurrenceRule(Map<String, String> params) throws IllegalArgumentException {
-        StringBuilder rule = new StringBuilder();
-        if (params.containsKey("frequency")) {
-            String frequency = params.get("frequency");
-            int interval = -1;
-            if (params.containsKey("interval")) {
-                interval = Integer.parseInt(params.get("interval"));
-            }
-            if ("daily".equals(frequency)) {
-                rule.append("FREQ=DAILY;");
-                if (interval != -1) {
-                    rule.append("INTERVAL=" + interval + ";");
-                }
-            } else if("weekly".equals(frequency)) {
-                rule.append("FREQ=WEEKLY;");
-                if (interval != -1) {
-                    rule.append("INTERVAL=" + interval + ";");
-                }
-                if (params.containsKey("daysInWeek")) {
-                    String weekdays = translateWeekIntegersToDays(params.get("daysInWeek"));
-                    if (weekdays == null) {
-                       throw new IllegalArgumentException("invalid ");
-                    }
-                    rule.append("BYDAY=" + weekdays + ";");
-                }
-            } else if("monthly".equals(frequency)) {
-                rule.append("FREQ=MONTHLY;");
-                if (interval != -1) {
-                    rule.append("INTERVAL=" + interval + ";");
-                }
-                if (params.containsKey("daysInMonth")) {
-                    String monthDays = translateMonthIntegersToDays(params.get("daysInMonth"));
-                    if (monthDays == null) {
-                        throw new IllegalArgumentException();
-                    }
-                    rule.append("BYMONTHDAY=" + monthDays + ";");
-                }
-            } else {
-                throw new IllegalArgumentException("frequency is only supported for daily, weekly, and monthly.");
-            }
-        }
-        return rule.toString();
-    }
-
-    private String translateWeekIntegersToDays(String expression) throws IllegalArgumentException{
-        StringBuilder daysResult = new StringBuilder();
-        boolean[] daysAlreadyCounted = new boolean[7];
-        String[] days = expression.split(",");
-        int dayNumber;
-        for (int i=0; i<days.length; i++) {
-            dayNumber = Integer.parseInt(days[i]);
-            dayNumber = dayNumber == 7 ? 0 : dayNumber;
-            if (!daysAlreadyCounted[dayNumber]) {
-                daysResult.append(dayNumberToDayOfWeekString(dayNumber) + ",");
-                daysAlreadyCounted[dayNumber] = true;
-            }
-        }
-        if (days.length == 0) {
-            throw new IllegalArgumentException("must have at least 1 day of the week if specifying repeating weekly");
-        }
-        daysResult.deleteCharAt(daysResult.length()-1);
-        return daysResult.toString();
-    }
-
-    private String translateMonthIntegersToDays(String expression) throws IllegalArgumentException {
-        StringBuilder daysResult = new StringBuilder();
-        boolean[] daysAlreadyCounted = new boolean[2*MAX_NUMBER_DAYS_IN_MONTH +1]; //for -31 to 31
-        String[] days = expression.split(",");
-        int dayNumber;
-        for (int i=0; i<days.length; i++) {
-            dayNumber = Integer.parseInt(days[i]);
-            if (!daysAlreadyCounted[dayNumber+MAX_NUMBER_DAYS_IN_MONTH]) {
-                daysResult.append(dayNumberToDayOfMonthString(dayNumber) + ",");
-                daysAlreadyCounted[dayNumber+MAX_NUMBER_DAYS_IN_MONTH] = true;
-            }
-        }
-        if (days.length == 0) {
-            throw new IllegalArgumentException("must have at least 1 day of the month if specifying repeating weekly");
-        }
-        daysResult.deleteCharAt(daysResult.length() - 1);
-        return daysResult.toString();
-    }
-
-    private String dayNumberToDayOfWeekString(int number) throws IllegalArgumentException {
-        String dayOfWeek;
-        switch(number) {
-            case 0: dayOfWeek="SU"; break;
-            case 1: dayOfWeek="MO"; break;
-            case 2: dayOfWeek="TU"; break;
-            case 3: dayOfWeek="WE"; break;
-            case 4: dayOfWeek="TH"; break;
-            case 5: dayOfWeek="FR"; break;
-            case 6: dayOfWeek="SA"; break;
-            default: throw new IllegalArgumentException("invalid day of week " + number);
-        }
-        return dayOfWeek;
-    }
-
-    private String dayNumberToDayOfMonthString(int number) throws IllegalArgumentException {
-        String dayOfMonth;
-        // https://android.googlesource.com/platform/frameworks/opt/calendar/+/504844526f1b7afec048c6d2976ffb332670d5ba/src/com/android/calendarcommon2/EventRecurrence.java
-        if (number != 0 && number >= -MAX_NUMBER_DAYS_IN_MONTH && number <= MAX_NUMBER_DAYS_IN_MONTH) {
-            dayOfMonth = "" + number;
-        } else {
-            throw new IllegalArgumentException("invalid day of month " + number);
-        }
-        return dayOfMonth;
-    }
-
-    private void swapViewWithPlaceholderView() {
-        ViewGroup parent = (ViewGroup) getMraidView().getParent();
-        if (parent == null) return;
-
-        int index;
-        int count = parent.getChildCount();
-        for (index = 0; index < count; index++) {
-            if (parent.getChildAt(index) == getMraidView()) break;
-        }
-
-        mViewIndexInParent = index;
-        parent.addView(mPlaceholderView, index,
-                new ViewGroup.LayoutParams(getMraidView().getWidth(), getMraidView().getHeight()));
-        parent.removeView(getMraidView());
-    }
-
-    private void expandLayouts(View expansionContentView, int expandWidth, int expandHeight) {
-        int closeButtonSize = (int) (CLOSE_BUTTON_SIZE_DP * mDensity + 0.5f);
-        if (expandWidth < closeButtonSize) expandWidth = closeButtonSize;
-        if (expandHeight < closeButtonSize) expandHeight = closeButtonSize;
-
-        View dimmingView = new View(getContext());
-        dimmingView.setBackgroundColor(TRANSPARENT);
-        dimmingView.setOnTouchListener(new OnTouchListener() {
-            public boolean onTouch(View v, MotionEvent event) {
-                return true;
-            }
-        });
-
-        mExpansionLayout.addView(dimmingView, new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));
-
-        mAdContainerLayout.addView(expansionContentView, new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));
-
-        addCloseEventRegion(mAdContainerLayout);
-
-        RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(expandWidth, expandHeight);
-        lp.addRule(RelativeLayout.CENTER_IN_PARENT);
-        mExpansionLayout.addView(mAdContainerLayout, lp);
-    }
-
-    private void setOrientationLockEnabled(boolean enabled) {
-        Context context = getContext();
-        Activity activity = null;
-        try {
-            activity = (Activity) context;
-            int requestedOrientation = enabled ?
-                    activity.getResources().getConfiguration().orientation :
-                    mOriginalRequestedOrientation;
-            activity.setRequestedOrientation(requestedOrientation);
-        } catch (ClassCastException e) {
-            Log.d(LOGTAG, "Unable to modify device orientation.");
-        }
-    }
-
-    protected void setNativeCloseButtonEnabled(boolean enabled) {
-        if (mRootView == null) {
-            return;
-        }
-
-        if (enabled) {
-            if (mCloseButton == null) {
-                StateListDrawable states = new StateListDrawable();
-                states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(mRootView.getContext()));
-                states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(mRootView.getContext()));
-                mCloseButton = new ImageButton(getContext());
-                mCloseButton.setImageDrawable(states);
-                mCloseButton.setBackgroundDrawable(null);
-                mCloseButton.setOnClickListener(new OnClickListener() {
-                    public void onClick(View v) {
-                        MraidDisplayController.this.close();
-                    }
-                });
-            }
-
-            final int closeButtonSize = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, getContext());
-            FrameLayout.LayoutParams buttonLayout = new FrameLayout.LayoutParams(
-                    closeButtonSize, closeButtonSize, Gravity.RIGHT);
-            mAdContainerLayout.addView(mCloseButton, buttonLayout);
-        } else {
-            mAdContainerLayout.removeView(mCloseButton);
-        }
-
-        MraidView view = getMraidView();
-        if (view.getOnCloseButtonStateChangeListener() != null) {
-            view.getOnCloseButtonStateChangeListener().onCloseButtonStateChange(view, enabled);
-        }
-    }
-
-    protected void useCustomClose(boolean shouldUseCustomCloseButton) {
-        mAdWantsCustomCloseButton = shouldUseCustomCloseButton;
-
-        MraidView view = getMraidView();
-        boolean enabled = !shouldUseCustomCloseButton;
-        if (view.getOnCloseButtonStateChangeListener() != null) {
-            view.getOnCloseButtonStateChangeListener().onCloseButtonStateChange(view, enabled);
-        }
-    }
-
-    FrameLayout createAdContainerLayout() {
-        return new FrameLayout(getContext());
-    }
-
-    void addCloseEventRegion(final FrameLayout frameLayout) {
-        final int buttonSizePixels = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, getContext());
-        final FrameLayout.LayoutParams layoutParams =
-                new FrameLayout.LayoutParams(buttonSizePixels, buttonSizePixels, Gravity.TOP | Gravity.RIGHT);
-        Interstitials.addCloseEventRegion(frameLayout, layoutParams, mCloseOnClickListener);
-    }
-
-    RelativeLayout createExpansionLayout() {
-        return new RelativeLayout(getContext());
-    }
-
-    FrameLayout createPlaceholderView() {
-        return new FrameLayout(getContext());
-    }
-
-    private Context getContext() {
-        return getMraidView().getContext();
-    }
-
-    protected void initializeSupportedFunctionsProperty() {
-        Context context = getContext();
-        getMraidView().fireChangeEventForProperty(
-                new MraidSupportsProperty()
-                        .withTel(isTelAvailable(context))
-                        .withSms(isSmsAvailable(context))
-                        .withCalendar(isCalendarAvailable(context))
-                        .withInlineVideo(isInlineVideoAvailable(context))
-                        .withStorePicture(isStorePictureSupported(context)));
-    }
-
-    private File getPictureStoragePath() {
-        return new File(Environment.getExternalStorageDirectory(), "Pictures");
-    }
-
-    private String getFileNameForUriAndHttpResponse(final URI uri, final HttpResponse response) {
-        final String path = uri.getPath();
-
-        if (path == null) {
-            return null;
-        }
-
-        String filename = new File(path).getName();
-
-        Header header = response.getFirstHeader(MIME_TYPE_HEADER);
-        if (header != null) {
-            String[] fields = header.getValue().split(";");
-            for (final String field : fields) {
-                String extension;
-                if (field.contains("image/")) {
-                    extension = "." + field.split("/")[1];
-                    if (!filename.endsWith(extension)) {
-                        filename += extension;
-                    }
-                    break;
-                }
-            }
-        }
-
-        return filename;
-    }
-
-    private class MoPubMediaScannerConnectionClient implements MediaScannerConnection.MediaScannerConnectionClient {
-        private final String mFilename;
-        private final String mMimeType;
-        private MediaScannerConnection mMediaScannerConnection;
-
-        private MoPubMediaScannerConnectionClient(String filename, String mimeType) {
-            mFilename = filename;
-            mMimeType = mimeType;
-        }
-
-        private void setMediaScannerConnection(MediaScannerConnection connection) {
-            mMediaScannerConnection = connection;
-        }
-
-        @Override
-        public void onMediaScannerConnected() {
-            if (mMediaScannerConnection != null) {
-                mMediaScannerConnection.scanFile(mFilename, mMimeType);
-            }
-        }
-
-        @Override
-        public void onScanCompleted(String path, Uri uri) {
-            if (mMediaScannerConnection != null) {
-                mMediaScannerConnection.disconnect();
-            }
-        }
-    }
-
-    class OrientationBroadcastReceiver extends BroadcastReceiver {
-        private int mLastRotation;
-        private Context mContext;
-
-        public void onReceive(Context context, Intent intent) {
-            if(!isRegistered()) {
-                return;
-            }
-            String action = intent.getAction();
-            if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
-                int orientation = MraidDisplayController.this.getDisplayRotation();
-                if (orientation != mLastRotation) {
-                    mLastRotation = orientation;
-                    MraidDisplayController.this.onOrientationChanged(mLastRotation);
-                }
-            }
-        }
-
-        private boolean isRegistered() {
-            return mContext != null;
-        }
-
-        public void register(Context context) {
-            mContext = context;
-            context.registerReceiver(this,
-                    new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
-        }
-
-        public void unregister() {
-            mContext.unregisterReceiver(this);
-            mContext = null;
-        }
-    }
-
-    // testing
-    @Deprecated
-    public OnClickListener getCloseOnClickListener() {
-        return mCloseOnClickListener;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidInterstitial.java
deleted file mode 100644
index 53ac578e..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidInterstitial.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.mopub.mobileads;
-
-
-import android.net.Uri;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-
-class MraidInterstitial extends ResponseBodyInterstitial {
-    private String mHtmlData;
-
-    @Override
-    protected void extractExtras(Map<String, String> serverExtras) {
-        mHtmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-    }
-
-    @Override
-    protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener) {
-        MraidActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
-    }
-
-    @Override
-    protected void showInterstitial() {
-        MraidActivity.start(mContext, mHtmlData, mAdConfiguration);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidProperty.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidProperty.java
deleted file mode 100644
index bfcfdf56..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidProperty.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-
-abstract class MraidProperty {
-    private String sanitize(String str) {
-        return (str != null) ? str.replaceAll("[^a-zA-Z0-9_,:\\s\\{\\}\\\'\\\"]", "") : "";
-    }
-
-    @Override
-    public String toString() {
-        return sanitize(toJsonPair());
-    }
-
-    public abstract String toJsonPair();
-}
-
-class MraidPlacementTypeProperty extends MraidProperty {
-    private final PlacementType mPlacementType;
-
-    MraidPlacementTypeProperty(PlacementType placementType) {
-        mPlacementType = placementType;
-    }
-
-    public static MraidPlacementTypeProperty createWithType(
-            PlacementType placementType) {
-        return new MraidPlacementTypeProperty(placementType);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "placementType: '" + mPlacementType.toString().toLowerCase() + "'";
-    }
-}
-
-class MraidScreenSizeProperty extends MraidProperty {
-    private final int mScreenWidth;
-    private final int mScreenHeight;
-
-    MraidScreenSizeProperty(int width, int height) {
-        mScreenWidth = width;
-        mScreenHeight = height;
-    }
-
-    public static MraidScreenSizeProperty createWithSize(int width, int height) {
-        return new MraidScreenSizeProperty(width, height);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "screenSize: { width: " + mScreenWidth + ", height: " + mScreenHeight + " }";
-    }
-}
-
-class MraidStateProperty extends MraidProperty {
-    private final ViewState mViewState;
-
-    MraidStateProperty(ViewState viewState) {
-        mViewState = viewState;
-    }
-
-    public static MraidStateProperty createWithViewState(ViewState viewState) {
-        return new MraidStateProperty(viewState);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "state: '" + mViewState.toString().toLowerCase() + "'";
-    }
-}
-
-class MraidViewableProperty extends MraidProperty {
-    private final boolean mViewable;
-
-    MraidViewableProperty(boolean viewable) {
-        mViewable = viewable;
-    }
-
-    public static MraidViewableProperty createWithViewable(boolean viewable) {
-        return new MraidViewableProperty(viewable);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "viewable: " + (mViewable ? "true" : "false");
-    }
-}
-
-class MraidSupportsProperty extends MraidProperty{
-    private boolean sms;
-    private boolean tel;
-    private boolean calendar;
-    private boolean storePicture;
-    private boolean inlineVideo;
-
-    @Override
-    public String toJsonPair() {
-        return "supports: {" +
-                "sms: " + String.valueOf(sms) + ", " +
-                "tel: " + String.valueOf(tel) + ", " +
-                "calendar: " + String.valueOf(calendar) + ", " +
-                "storePicture: " + String.valueOf(storePicture) + ", " +
-                "inlineVideo: " + String.valueOf(inlineVideo) + "}";
-    }
-
-    public MraidSupportsProperty withSms(boolean value) {
-        sms = value;
-        return this;
-    }
-
-
-    public MraidSupportsProperty withTel(boolean value) {
-        tel = value;
-        return this;
-    }
-
-    public MraidSupportsProperty withCalendar(boolean value) {
-        calendar = value;
-        return this;
-    }
-
-    public MraidSupportsProperty withStorePicture(boolean value) {
-        storePicture = value;
-        return this;
-    }
-
-    public MraidSupportsProperty withInlineVideo(boolean value) {
-        inlineVideo = value;
-        return this;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
index 7c9a2202..9f58f6f9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
@@ -3,19 +3,24 @@
 import android.app.Activity;
 import android.content.ActivityNotFoundException;
 import android.content.Intent;
+import android.content.res.Configuration;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
 
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.Intents;
+import com.mopub.mraid.MraidVideoViewController;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidVideoPlayerActivity extends BaseVideoPlayerActivity implements BaseVideoViewController.BaseVideoViewControllerListener {
-    private BaseVideoViewController mBaseVideoController;
+    @Nullable private BaseVideoViewController mBaseVideoController;
     private long mBroadcastIdentifier;
 
     @Override
@@ -25,16 +30,14 @@ protected void onCreate(Bundle savedInstanceState) {
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        final AdConfiguration adConfiguration = getAdConfiguration();
-        if (adConfiguration != null) {
-            mBroadcastIdentifier = adConfiguration.getBroadcastIdentifier();
-        } else {
-            MoPubLog.d("Unable to obtain broadcast identifier. Video interactions cannot be tracked.");
-        }
+        mBroadcastIdentifier = getBroadcastIdentifierFromIntent(getIntent());
 
         try {
-            mBaseVideoController = createVideoViewController();
+            mBaseVideoController = createVideoViewController(savedInstanceState);
         } catch (IllegalStateException e) {
+            // This can happen if the activity was started without valid intent extras. We leave
+            // mBaseVideoController set to null, and finish the activity immediately.
+
             broadcastAction(this, mBroadcastIdentifier, ACTION_INTERSTITIAL_FAIL);
             finish();
             return;
@@ -45,51 +48,65 @@ protected void onCreate(Bundle savedInstanceState) {
 
     @Override
     protected void onPause() {
-        mBaseVideoController.onPause();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onPause();
+        }
         super.onPause();
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        mBaseVideoController.onResume();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onResume();
+        }
     }
 
     @Override
     protected void onDestroy() {
-        mBaseVideoController.onDestroy();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onDestroy();
+        }
         super.onDestroy();
     }
 
+    @Override
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        super.onSaveInstanceState(outState);
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onSaveInstanceState(outState);
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(@Nullable Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onConfigurationChanged(newConfig);
+        }
+    }
+
     @Override
     public void onBackPressed() {
-        if (mBaseVideoController.backButtonEnabled()) {
+        if (mBaseVideoController != null && mBaseVideoController.backButtonEnabled()) {
             super.onBackPressed();
         }
     }
 
     @Override
     protected void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
-        mBaseVideoController.onActivityResult(requestCode, resultCode, data);
-    }
-
-    private AdConfiguration getAdConfiguration() {
-        AdConfiguration adConfiguration;
-        try {
-            adConfiguration = (AdConfiguration) getIntent().getSerializableExtra(AdFetcher.AD_CONFIGURATION_KEY);
-        } catch (ClassCastException e) {
-            adConfiguration = null;
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onActivityResult(requestCode, resultCode, data);
         }
-        return adConfiguration;
     }
 
-    private BaseVideoViewController createVideoViewController() throws IllegalStateException {
+    private BaseVideoViewController createVideoViewController(Bundle savedInstanceState) throws IllegalStateException {
         String clazz = getIntent().getStringExtra(VIDEO_CLASS_EXTRAS_KEY);
 
         if ("vast".equals(clazz)) {
-            return new VastVideoViewController(this, getIntent().getExtras(), mBroadcastIdentifier, this);
+            return new VastVideoViewController(this, getIntent().getExtras(), savedInstanceState, mBroadcastIdentifier, this);
         } else if ("mraid".equals(clazz)) {
-            return new MraidVideoViewController(this, getIntent().getExtras(), mBroadcastIdentifier, this);
+            return new MraidVideoViewController(this, getIntent().getExtras(), savedInstanceState, this);
         } else {
             throw new IllegalStateException("Unsupported video type: " + clazz);
         }
@@ -122,7 +139,7 @@ public void onStartActivityForResult(final Class<? extends Activity> clazz,
             return;
         }
 
-        final Intent intent = IntentUtils.getStartActivityIntent(this, clazz, extras);
+        final Intent intent = Intents.getStartActivityIntent(this, clazz, extras);
 
         try {
             startActivityForResult(intent, requestCode);
@@ -131,6 +148,10 @@ public void onStartActivityForResult(final Class<? extends Activity> clazz,
         }
     }
 
+    protected static long getBroadcastIdentifierFromIntent(Intent intent) {
+        return intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1);
+    }
+
     @Deprecated // for testing
     BaseVideoViewController getBaseVideoViewController() {
         return mBaseVideoController;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
deleted file mode 100644
index 4a5fa6b9..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
+++ /dev/null
@@ -1,411 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Color;
-import android.net.Uri;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.View;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Strings;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.resource.MraidJavascript;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.NameValuePair;
-import org.apache.http.client.ClientProtocolException;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.utils.URLEncodedUtils;
-
-import java.io.*;
-import java.net.URI;
-import java.util.*;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand;
-import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
-
-public class MraidView extends BaseWebView implements UserClickListener {
-    private static final String LOGTAG = "MraidView";
-    
-    private MoPubBrowserController mBrowserController;
-    private MraidDisplayController mDisplayController;
-    
-    private WebViewClient mWebViewClient;
-
-    private boolean mHasFiredReadyEvent;
-    private boolean mClicked;
-    private final PlacementType mPlacementType;
-    private ViewGestureDetector mViewGestureDetector;
-    private AdConfiguration mAdConfiguration;
-    private boolean mIsVisible;
-
-    static class MraidListenerInfo {
-        private MraidListener mMraidListener;
-        private OnCloseButtonStateChangeListener mOnCloseButtonListener;
-    }
-    private MraidListenerInfo mListenerInfo;
-
-    public enum ViewState {
-        LOADING,
-        DEFAULT,
-        EXPANDED,
-        HIDDEN
-    }
-
-    public enum ExpansionStyle {
-        ENABLED,
-        DISABLED
-    }
-
-    public enum NativeCloseButtonStyle {
-        ALWAYS_VISIBLE,
-        ALWAYS_HIDDEN,
-        AD_CONTROLLED
-    }
-
-    public enum PlacementType {
-        INLINE,
-        INTERSTITIAL
-    }
-
-    public MraidView(Context context, AdConfiguration adConfiguration) {
-        this(context, adConfiguration, ExpansionStyle.ENABLED, NativeCloseButtonStyle.AD_CONTROLLED,
-                PlacementType.INLINE);
-    }
-
-    public MraidView(Context context, AdConfiguration adConfiguration, ExpansionStyle expStyle, NativeCloseButtonStyle buttonStyle,
-                     PlacementType placementType) {
-        super(context);
-        mPlacementType = placementType;
-
-        mAdConfiguration = adConfiguration;
-        mViewGestureDetector = new ViewGestureDetector(context, this, adConfiguration);
-        mViewGestureDetector.setUserClickListener(this);
-
-        mIsVisible = (getVisibility() == View.VISIBLE);
-
-        initialize(expStyle, buttonStyle);
-    }
-
-    @Override
-    public void onUserClick() {
-        mClicked = true;
-    }
-
-    @Override
-    public void onResetUserClick() {
-        mClicked = false;
-    }
-
-    @Override
-    public boolean wasClicked() {
-        return mClicked;
-    }
-
-    private void initialize(ExpansionStyle expStyle, NativeCloseButtonStyle buttonStyle) {
-        setScrollContainer(false);
-        setBackgroundColor(Color.TRANSPARENT);
-        
-        setVerticalScrollBarEnabled(false);
-        setHorizontalScrollBarEnabled(false);
-        
-        setOnTouchListener(new View.OnTouchListener() {
-            public boolean onTouch(View v, MotionEvent event) {
-                mViewGestureDetector.sendTouchEvent(event);
-
-                switch (event.getAction()) {
-                    case MotionEvent.ACTION_DOWN:
-                    case MotionEvent.ACTION_UP:
-                        if (!v.hasFocus()) {
-                            v.requestFocus();
-                        }
-                        break;
-                }
-                return false;
-            }
-        });
-        
-        getSettings().setJavaScriptEnabled(true);
-        
-        mBrowserController = new MoPubBrowserController(this);
-        mDisplayController = new MraidDisplayController(this, expStyle, buttonStyle);
-        
-        mWebViewClient = new MraidWebViewClient();
-        setWebViewClient(mWebViewClient);
-
-        mListenerInfo = new MraidListenerInfo();
-    }
-
-    AdConfiguration getAdConfiguration() {
-        return mAdConfiguration;
-    }
-
-    @Override
-    public void destroy() {
-        mDisplayController.destroy();
-        super.destroy();
-    }
-
-    public void loadHtmlData(String data) {
-        if (data == null) {
-            return;
-        }
-
-        // If the string data lacks the HTML boilerplate, add it.
-        if (!data.contains("<html>")) {
-            data = "<html><head></head><body style='margin:0;padding:0;'>" + data +
-                    "</body></html>";
-        }
-        
-        // Inject the MRAID JavaScript bridge.
-        data = data.replace("<head>", "<head><script>" + MraidJavascript.JAVASCRIPT_SOURCE + "</script>");
-
-        loadDataWithBaseURL(null, data, "text/html", "UTF-8", null);
-    }
-
-    @Override
-    public void loadUrl(String url) {
-        if (url == null) {
-            return;
-        }
-
-        if (url.startsWith("javascript:")) {
-            super.loadUrl(url);
-            return;
-        }
-
-        HttpClient httpClient = HttpClientFactory.create();
-        String outString = "";
-        
-        try {
-            HttpGet httpGet = new HttpGet(url);
-            HttpResponse response = httpClient.execute(httpGet);
-            HttpEntity entity = response.getEntity();
-    
-            if (entity != null) {
-                outString = Strings.fromStream(entity.getContent());
-            }
-        } catch (IllegalArgumentException e) {
-            MoPubLog.d("Mraid loadUrl failed (IllegalArgumentException): " + url);
-            notifyOnFailureListener();
-            return;
-        } catch (ClientProtocolException e) {
-            notifyOnFailureListener();
-            return;
-        } catch (IOException e) {
-            notifyOnFailureListener();
-            return;
-        }
-
-        loadHtmlData(outString);
-    }
-    
-    private void notifyOnFailureListener() {
-        if (mListenerInfo.mMraidListener != null) {
-            mListenerInfo.mMraidListener.onFailure(this);
-        }
-    }
-
-    // Controllers /////////////////////////////////////////////////////////////////////////////////
-    
-    protected MoPubBrowserController getBrowserController() {
-        return mBrowserController;
-    }
-    
-    protected MraidDisplayController getDisplayController() {
-        return mDisplayController;
-    }
-    
-    // Listeners ///////////////////////////////////////////////////////////////////////////////////
-
-    public void setMraidListener(MraidListener mraidListener) {
-        mListenerInfo.mMraidListener = mraidListener;
-    }
-
-    public MraidListener getMraidListener() {
-        return mListenerInfo.mMraidListener;
-    }
-
-    public void setOnCloseButtonStateChange(OnCloseButtonStateChangeListener listener) {
-        mListenerInfo.mOnCloseButtonListener = listener;
-    }
-    
-    public OnCloseButtonStateChangeListener getOnCloseButtonStateChangeListener() {
-        return mListenerInfo.mOnCloseButtonListener;
-    }
-    
-    // JavaScript injection ////////////////////////////////////////////////////////////////////////
-    
-    protected void injectJavaScript(String js) {
-        if (js != null) super.loadUrl("javascript:" + js);
-    }
-    
-    protected void fireChangeEventForProperty(MraidProperty property) {
-        String json = "{" + property.toString() + "}";
-        injectJavaScript("window.mraidbridge.fireChangeEvent(" + json + ");");
-        Log.d(LOGTAG, "Fire change: " + json);
-    }
-    
-    protected void fireChangeEventForProperties(ArrayList<MraidProperty> properties) {
-        String props = properties.toString();
-        if (props.length() < 2) return;
-        
-        String json = "{" + props.substring(1, props.length() - 1) + "}";
-        injectJavaScript("window.mraidbridge.fireChangeEvent(" + json + ");");
-        Log.d(LOGTAG, "Fire changes: " + json);
-    }
-    
-    protected void fireErrorEvent(MraidJavascriptCommand mraidJavascriptCommand, String message) {
-        String action = mraidJavascriptCommand.getCommand();
-
-        injectJavaScript("window.mraidbridge.fireErrorEvent('" + action + "', '" + message + "');");
-    }
-    
-    protected void fireReadyEvent() {
-        injectJavaScript("window.mraidbridge.fireReadyEvent();");
-    }
-    
-    protected void fireNativeCommandCompleteEvent(String command) {
-        injectJavaScript("window.mraidbridge.nativeCallComplete('" + command + "');");
-    }
-    
-    private boolean tryCommand(URI uri) {
-        String commandType = uri.getHost();
-        List<NameValuePair> list = URLEncodedUtils.parse(uri, "UTF-8");
-        Map<String, String> params = new HashMap<String, String>();
-        for (NameValuePair pair : list) {
-            params.put(pair.getName(), pair.getValue());
-        }
-
-        MraidCommand command = MraidCommandFactory.create(commandType, params, this);
-
-        if (command == null) {
-            fireNativeCommandCompleteEvent(commandType);
-            return false;
-        } else if (command.isCommandDependentOnUserClick(mPlacementType) && !wasClicked()) {
-            return false;
-        } else {
-            command.execute();
-            fireNativeCommandCompleteEvent(commandType);
-            return true;
-        }
-    }
-
-    private class MraidWebViewClient extends WebViewClient {
-        @Override
-        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
-            Log.d(LOGTAG, "Error: " + description);
-            super.onReceivedError(view, errorCode, description, failingUrl);
-        }
-        
-        @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
-            Uri uri = Uri.parse(url);
-
-            // Note that scheme will be null when we are passed a relative Uri
-            String scheme = uri.getScheme();
-
-            if ("mopub".equals(scheme)) {
-                return true;
-            }
-
-            if ("mraid".equals(scheme)) {
-                tryCommand(URI.create(url)); // java.net.URI, not android.net.Uri
-                return true;
-            }
-
-            if (wasClicked()) {
-                Intent i = new Intent();
-                i.setAction(Intent.ACTION_VIEW);
-                i.setData(Uri.parse(url));
-                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-                try {
-                    getContext().startActivity(i);
-                    return true;
-                } catch (ActivityNotFoundException e) {
-                    return false;
-                }
-            }
-
-            return false;
-        }
-        
-        @Override
-        public void onPageFinished(WebView view, String url) {
-            if (!mHasFiredReadyEvent) {
-                mDisplayController.initializeJavaScriptState();
-                fireChangeEventForProperty(MraidPlacementTypeProperty.createWithType(mPlacementType));
-                fireReadyEvent();
-                if (getMraidListener() != null) {
-                    getMraidListener().onReady(MraidView.this);
-                }
-                mIsVisible = (getVisibility() == View.VISIBLE);
-                fireChangeEventForProperty(MraidViewableProperty.createWithViewable(mIsVisible));
-                mHasFiredReadyEvent = true;
-            }
-        }
-        
-        @Override
-        public void onLoadResource(WebView view, String url) {
-            Log.d(LOGTAG, "Loaded resource: " + url);
-        }
-    }
-
-    public interface MraidListener {
-        public void onReady(MraidView view);
-        public void onFailure(MraidView view);
-        public void onExpand(MraidView view);
-        public void onOpen(MraidView view);
-        public void onClose(MraidView view, ViewState newViewState);
-    }
-
-    public static class BaseMraidListener implements MraidListener {
-        @Override public void onReady(MraidView view) { }
-        @Override public void onFailure(MraidView view) { }
-        @Override public void onExpand(MraidView view) { }
-        @Override public void onOpen(MraidView view) { }
-        @Override public void onClose(MraidView view, ViewState newViewState) { }
-    }
-
-    public interface OnCloseButtonStateChangeListener {
-        public void onCloseButtonStateChange(MraidView view, boolean enabled);
-    }
-
-    public boolean getIsVisible() {
-        return mIsVisible;
-    }
-
-    @Override
-    protected void onVisibilityChanged (View changedView, int visibility) {
-        super.onVisibilityChanged(changedView, visibility);
-
-        boolean newIsVisible = (visibility == View.VISIBLE);
-        if (newIsVisible != mIsVisible) {
-            mIsVisible = newIsVisible;
-            if (mHasFiredReadyEvent) {
-                fireChangeEventForProperty(MraidViewableProperty.createWithViewable(mIsVisible));
-            }
-        }
-    }
-
-    @Deprecated // for testing
-    void setHasFiredReadyEvent(boolean hasFired) {
-        mHasFiredReadyEvent = hasFired;
-    }
-
-    @Deprecated // for testing
-    WebViewClient getMraidWebViewClient() {
-        return mWebViewClient;
-    }
-
-    @Deprecated // for testing
-    void setMraidDisplayController(MraidDisplayController mraidDisplayController) {
-        mDisplayController = mraidDisplayController;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
new file mode 100644
index 00000000..2c26fa69
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
@@ -0,0 +1,57 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * A generic runnable that handles scheduling itself periodically on a Handler and stops when
+ * requested.
+ */
+public abstract class RepeatingHandlerRunnable implements Runnable {
+    @NonNull protected final Handler mHandler;
+    private volatile boolean mIsRunning;
+    private volatile long mUpdateIntervalMillis;
+
+    RepeatingHandlerRunnable(@NonNull final Handler handler) {
+        Preconditions.checkNotNull(handler);
+        mHandler = handler;
+    }
+
+    @Override
+    public void run() {
+        if (mIsRunning) {
+            doWork();
+            mHandler.postDelayed(this, mUpdateIntervalMillis);
+        }
+    }
+
+    public abstract void doWork();
+
+    /**
+     * Start this runnable immediately, repeating at the provided interval.
+     */
+    public void startRepeating(long intervalMillis) {
+        Preconditions.checkArgument(intervalMillis > 0, "intervalMillis must be greater than 0. " +
+                "Saw: %d", intervalMillis);
+        mUpdateIntervalMillis = intervalMillis;
+        if (!mIsRunning) {
+            mIsRunning = true;
+            mHandler.post(this);
+        }
+    }
+
+    /**
+     * Stop this repeating runnable.
+     */
+    public void stop() {
+        mIsRunning = false;
+    }
+
+    @VisibleForTesting
+    boolean shouldBeRunning() {
+        return mIsRunning;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
index 2d73912e..a6b3c625 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
@@ -2,23 +2,28 @@
 
 import android.content.Context;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.logging.MoPubLog;
+
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
-abstract class ResponseBodyInterstitial extends CustomEventInterstitial {
+public abstract class ResponseBodyInterstitial extends CustomEventInterstitial {
     private EventForwardingBroadcastReceiver mBroadcastReceiver;
     protected Context mContext;
-    protected AdConfiguration mAdConfiguration;
-    long mBroadcastIdentifier;
+    protected AdReport mAdReport;
+    protected long mBroadcastIdentifier;
 
     abstract protected void extractExtras(Map<String, String> serverExtras);
     abstract protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener);
-    abstract protected void showInterstitial();
+    public abstract void showInterstitial();
 
     @Override
-    protected void loadInterstitial(
+    public void loadInterstitial(
             Context context,
             CustomEventInterstitialListener customEventInterstitialListener,
             Map<String, Object> localExtras,
@@ -33,19 +38,31 @@ protected void loadInterstitial(
             return;
         }
 
-        mAdConfiguration = AdConfiguration.extractFromMap(localExtras);
-        if (mAdConfiguration != null) {
-            mBroadcastIdentifier = mAdConfiguration.getBroadcastIdentifier();
+
+        try {
+            mAdReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            Long boxedBroadcastId = (Long) localExtras.get(BROADCAST_IDENTIFIER_KEY);
+            if (boxedBroadcastId == null) {
+                MoPubLog.e("Broadcast Identifier was not set in localExtras");
+                customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                return;
+            }
+            mBroadcastIdentifier = boxedBroadcastId;
+        } catch (ClassCastException e) {
+            MoPubLog.e("LocalExtras contained an incorrect type.");
+            customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+            return;
         }
 
-        mBroadcastReceiver = new EventForwardingBroadcastReceiver(customEventInterstitialListener, mBroadcastIdentifier);
+        mBroadcastReceiver = new EventForwardingBroadcastReceiver(customEventInterstitialListener,
+                mBroadcastIdentifier);
         mBroadcastReceiver.register(context);
 
         preRenderHtml(customEventInterstitialListener);
     }
 
     @Override
-    protected void onInvalidate() {
+    public void onInvalidate() {
         if (mBroadcastReceiver != null) {
             mBroadcastReceiver.unregister();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java
new file mode 100644
index 00000000..c3d45cec
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java
@@ -0,0 +1,118 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Pair;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+/**
+ * Used to manage the mapping between MoPub ad unit ids and third-party ad network ids for rewarded videos.
+ */
+class RewardedVideoData {
+    @NonNull
+    private final Map<String, CustomEventRewardedVideo> mAdUnitToCustomEventMap;
+    @NonNull
+    private final Map<TwoPartKey, Set<String>> mCustomEventToMoPubIdMap;
+    @NonNull
+    private final Set<CustomEventRewardedVideo.CustomEventRewardedVideoListener> mAdNetworkListeners;
+
+    RewardedVideoData() {
+        mAdUnitToCustomEventMap = new TreeMap<String, CustomEventRewardedVideo>();
+        mCustomEventToMoPubIdMap = new HashMap<TwoPartKey, Set<String>>();
+        mAdNetworkListeners = new HashSet<CustomEventRewardedVideo.CustomEventRewardedVideoListener>();
+    }
+
+    @Nullable
+    CustomEventRewardedVideo getCustomEvent(@NonNull String moPubId) {
+        return mAdUnitToCustomEventMap.get(moPubId);
+    }
+
+    @NonNull
+    Set<String> getMoPubIdsForAdNetwork(
+            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @Nullable String adNetworkId) {
+        if (adNetworkId == null) {
+            final Set<String> allIds = new HashSet<String>();
+            for (final Map.Entry<TwoPartKey, Set<String>> entry : mCustomEventToMoPubIdMap.entrySet()) {
+                final Class<?> clazz = entry.getKey().customEventClass;
+                if (customEventClass == clazz) {
+                    allIds.addAll(entry.getValue());
+                }
+            }
+            return allIds;
+        } else {
+            final TwoPartKey key = new TwoPartKey(customEventClass, adNetworkId);
+            return mCustomEventToMoPubIdMap.containsKey(key)
+                    ? mCustomEventToMoPubIdMap.get(key)
+                    : Collections.<String>emptySet();
+        }
+    }
+
+    void updateAdUnitCustomEventMapping(
+            @NonNull String moPubId,
+            @NonNull CustomEventRewardedVideo customEvent,
+            @Nullable CustomEventRewardedVideo.CustomEventRewardedVideoListener listener,
+            @NonNull String adNetworkId) {
+        mAdUnitToCustomEventMap.put(moPubId, customEvent);
+        mAdNetworkListeners.add(listener);
+        associateCustomEventWithMoPubId(customEvent.getClass(), adNetworkId, moPubId);
+    }
+
+    void associateCustomEventWithMoPubId(
+            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @NonNull String adNetworkId,
+            @NonNull String moPubId) {
+        final TwoPartKey newCustomEventMapping = new TwoPartKey(customEventClass, adNetworkId);
+
+        // Remove previous mapping for this moPubId
+        final Iterator<Map.Entry<TwoPartKey, Set<String>>> entryIterator =
+                mCustomEventToMoPubIdMap.entrySet().iterator();
+        while (entryIterator.hasNext()) {
+            final Map.Entry<TwoPartKey, Set<String>> entry = entryIterator.next();
+
+            if (!entry.getKey().equals(newCustomEventMapping)) {
+                if (entry.getValue().contains(moPubId)) {
+                    entry.getValue().remove(moPubId);
+                    // Ensure that entries containing empty Sets are completely removed from the Map
+                    if (entry.getValue().isEmpty()) {
+                        entryIterator.remove();
+                    }
+
+                    // moPubIds can exist at most once in the Map values, so break upon finding a match
+                    break;
+                }
+            }
+        }
+
+        // Add a new mapping if necessary.
+        Set<String> moPubIds = mCustomEventToMoPubIdMap.get(newCustomEventMapping);
+        if (moPubIds == null) {
+            moPubIds = new HashSet<String>();
+            mCustomEventToMoPubIdMap.put(newCustomEventMapping, moPubIds);
+        }
+        moPubIds.add(moPubId);
+    }
+
+    private static class TwoPartKey extends Pair<Class<? extends CustomEventRewardedVideo>, String> {
+        @NonNull
+        final Class<? extends CustomEventRewardedVideo> customEventClass;
+        @NonNull
+        final String adNetworkId;
+
+        public TwoPartKey(
+                @NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String adNetworkId) {
+            super(customEventClass, adNetworkId);
+
+            this.customEventClass = customEventClass;
+            this.adNetworkId = adNetworkId;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java
deleted file mode 100644
index ffe0a65b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.mopub.mobileads;
-
-public class TaskTracker {
-    private long mCurrentTaskId = -1l;
-    private long mLastCompletedTaskId;
-
-    public long getCurrentTaskId() {
-        return mCurrentTaskId;
-    }
-
-    public void newTaskStarted() {
-        mCurrentTaskId++;
-    }
-
-    public void markTaskCompleted(long taskId) {
-        if (taskId > mLastCompletedTaskId) {
-            mLastCompletedTaskId = taskId;
-        }
-    }
-
-    public boolean isMostCurrentTask(long taskId) {
-        return taskId >= mLastCompletedTaskId;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
deleted file mode 100644
index 382b0e03..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
+++ /dev/null
@@ -1,200 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.text.TextUtils;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import com.mopub.common.util.Dips;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.resource.TextDrawable;
-
-import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
-
-class ToolbarWidget extends RelativeLayout {
-    static class Builder {
-        private final Context context;
-        private float weight;
-        private int widgetGravity;
-
-        private boolean hasText;
-        private String defaultText;
-
-        private boolean hasDrawable;
-        private Drawable drawable;
-
-        private OnTouchListener onTouchListener;
-        private int visibility;
-        private int textAlign;
-        private int drawableAlign;
-
-        Builder(final Context context) {
-            this.context = context;
-            this.weight = 1f;
-            this.widgetGravity = Gravity.CENTER;
-
-            this.visibility = View.VISIBLE;
-
-            this.textAlign = ALIGN_PARENT_LEFT;
-            this.drawableAlign = ALIGN_PARENT_RIGHT;
-        }
-
-        Builder weight(final float weight) {
-            this.weight = weight;
-            return this;
-        }
-
-        Builder widgetGravity(final int widgetGravity) {
-            this.widgetGravity = widgetGravity;
-            return this;
-        }
-
-        Builder hasText() {
-            this.hasText = true;
-            return this;
-        }
-
-        Builder defaultText(final String defaultText) {
-            this.hasText = true;
-            this.defaultText = defaultText;
-            return this;
-        }
-
-        Builder hasDrawable() {
-            this.hasDrawable = true;
-            return this;
-        }
-
-        Builder drawable(final Drawable drawable) {
-            this.hasDrawable = true;
-            this.drawable = drawable;
-            return this;
-        }
-
-        Builder textAlign(final int rule) {
-            this.textAlign = rule;
-            return this;
-        }
-
-        Builder drawableAlign(final int rule) {
-            this.drawableAlign = rule;
-            return this;
-        }
-
-        Builder visibility(final int visibility) {
-            this.visibility = visibility;
-            return this;
-        }
-
-        Builder onTouchListener(final OnTouchListener onTouchListener) {
-            this.onTouchListener = onTouchListener;
-            return this;
-        }
-
-        ToolbarWidget build() {
-            return new ToolbarWidget(this);
-        }
-    }
-
-    private TextView mTextView;
-    private ImageView mImageView;
-
-    private static final int TEXT_PADDING_DIPS = 5;
-    private static final int IMAGE_PADDING_DIPS = 5;
-    private static final int IMAGE_SIDE_LENGTH_DIPS = 37;
-
-    private final int mTextPadding;
-    private final int mImagePadding;
-    private final int mImageSideLength;
-
-    private ToolbarWidget(Builder builder) {
-        super(builder.context);
-
-        final LinearLayout.LayoutParams toolbarLayoutParams = new LinearLayout.LayoutParams(0, WRAP_CONTENT, builder.weight);
-        toolbarLayoutParams.gravity = builder.widgetGravity;
-        setLayoutParams(toolbarLayoutParams);
-
-        mTextPadding = Dips.dipsToIntPixels(TEXT_PADDING_DIPS, getContext());
-        mImagePadding = Dips.dipsToIntPixels(IMAGE_PADDING_DIPS, getContext());
-        mImageSideLength = Dips.dipsToIntPixels(IMAGE_SIDE_LENGTH_DIPS, getContext());
-
-        setVisibility(builder.visibility);
-
-        if (builder.hasDrawable) {
-            if (builder.drawable != null) {
-                mImageView = new ImageView(getContext());
-                mImageView.setId((int) Utils.generateUniqueId());
-
-                final RelativeLayout.LayoutParams iconLayoutParams = new RelativeLayout.LayoutParams(
-                        mImageSideLength,
-                        mImageSideLength);
-
-                iconLayoutParams.addRule(CENTER_VERTICAL);
-                iconLayoutParams.addRule(builder.drawableAlign);
-
-                mImageView.setPadding(mImagePadding, mImagePadding, mImagePadding, mImagePadding);
-
-                mImageView.setBackgroundColor(Color.BLACK);
-                mImageView.getBackground().setAlpha(0);
-                mImageView.setImageDrawable(builder.drawable);
-                addView(mImageView, iconLayoutParams);
-            }
-        }
-
-        if (builder.hasText) {
-            mTextView = new TextView(getContext());
-            mTextView.setSingleLine();
-            mTextView.setEllipsize(TextUtils.TruncateAt.END);
-            mTextView.setText(builder.defaultText);
-
-            final RelativeLayout.LayoutParams textLayoutParams = new RelativeLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT);
-            textLayoutParams.addRule(CENTER_VERTICAL);
-
-            if (mImageView != null) {
-                textLayoutParams.addRule(LEFT_OF, mImageView.getId());
-            } else {
-                textLayoutParams.addRule(builder.textAlign);
-            }
-
-            mTextView.setPadding(mTextPadding, mTextPadding, mTextPadding, mTextPadding);
-
-            addView(mTextView, textLayoutParams);
-        }
-
-        if (builder.onTouchListener != null) {
-            setOnTouchListener(builder.onTouchListener);
-        }
-    }
-
-    void updateText(final String text) {
-        if (mTextView != null) {
-            mTextView.setText(text);
-        }
-    }
-
-    void updateImageText(final String text) {
-        try {
-            final TextDrawable textDrawable = (TextDrawable) mImageView.getDrawable();
-            textDrawable.updateText(text);
-        } catch (Exception e) {
-            MoPubLog.d("Unable to update ToolbarWidget text.");
-        }
-    }
-
-    @Deprecated // for testing
-    TextDrawable getImageViewDrawable() {
-        return (TextDrawable) mImageView.getDrawable();
-    }
-
-    @Deprecated // for testing
-    void setImageViewDrawable(TextDrawable drawable) {
-        mImageView.setImageDrawable((Drawable) drawable);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
new file mode 100644
index 00000000..63fd8513
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with an "absolute" trigger threshold. The tracker should be triggered
+ * after a fixed number of milliseconds have been played.
+ */
+public class VastAbsoluteProgressTracker extends VastTracker implements Comparable<VastAbsoluteProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final int mTrackingMilliseconds;
+
+    public VastAbsoluteProgressTracker(@NonNull final String trackingUrl, int trackingMilliseconds) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingMilliseconds >= 0);
+        mTrackingMilliseconds = trackingMilliseconds;
+    }
+
+    public int getTrackingMilliseconds() {
+        return mTrackingMilliseconds;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastAbsoluteProgressTracker other) {
+        int you = other.getTrackingMilliseconds();
+        int me = getTrackingMilliseconds();
+
+        return me - you;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%dms: %s", mTrackingMilliseconds, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastAdXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAdXmlManager.java
new file mode 100644
index 00000000..dbbec142
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAdXmlManager.java
@@ -0,0 +1,73 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+/**
+ * This XML manager handles the initial Ad node.
+ * There can be many Ad nodes in a VAST document, and this individually separates each one.
+ * The VAST 3.0 spec for Ad nodes states it can have either <i>one</i> InLine or <i>one</i>
+ * Wrapper as children. However, our implementation handles the case of having both an InLine
+ * and a Wrapper.
+ */
+class VastAdXmlManager {
+
+    // Element names
+    private static final String INLINE = "InLine";
+    private static final String WRAPPER = "Wrapper";
+
+    // Attribute names
+    private static final String SEQUENCE = "sequence";
+
+    @NonNull private final Node mAdNode;
+
+    VastAdXmlManager(@NonNull final Node adNode) {
+        Preconditions.checkNotNull(adNode);
+        mAdNode = adNode;
+    }
+
+    /**
+     * If there is an InLine section, return its XML manager.
+     *
+     * @return The {@link VastInLineXmlManager} or {@code null} if there is no InLine child node.
+     */
+    @Nullable
+    VastInLineXmlManager getInLineXmlManager() {
+        Node inLineNode = XmlUtils.getFirstMatchingChildNode(mAdNode, INLINE);
+        VastInLineXmlManager vastInLineXmlManager = null;
+        if (inLineNode != null) {
+            vastInLineXmlManager = new VastInLineXmlManager(inLineNode);
+        }
+        return vastInLineXmlManager;
+    }
+
+    /**
+     * If there is a Wrapper section, return its XML manager.
+     *
+     * @return The {@link VastWrapperXmlManager} or {@code null} if there is no Wrapper child node.
+     */
+    @Nullable
+    VastWrapperXmlManager getWrapperXmlManager() {
+        Node wrapperNode = XmlUtils.getFirstMatchingChildNode(mAdNode, WRAPPER);
+        VastWrapperXmlManager vastWrapperXmlManager = null;
+        if (wrapperNode != null) {
+            vastWrapperXmlManager = new VastWrapperXmlManager(wrapperNode);
+        }
+        return vastWrapperXmlManager;
+    }
+
+    /**
+     * Gets the attribute for sequence number. This attribute is optional.
+     *
+     * @return The sequence number
+     */
+    @Nullable
+    String getSequence() {
+        return XmlUtils.getAttributeValue(mAdNode, SEQUENCE);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java
new file mode 100644
index 00000000..f1998357
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java
@@ -0,0 +1,143 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+
+abstract class VastBaseInLineWrapperXmlManager {
+
+    // Element Names
+    private static final String IMPRESSION_TRACKER = "Impression";
+    private static final String COMPANION = "Companion";
+    private static final String LINEAR = "Linear";
+    private static final String CREATIVES = "Creatives";
+    private static final String CREATIVE = "Creative";
+    private static final String COMPANION_ADS = "CompanionAds";
+    private static final String ERROR = "Error";
+
+    @NonNull protected final Node mNode;
+
+    VastBaseInLineWrapperXmlManager(@NonNull Node node) {
+        Preconditions.checkNotNull(node);
+        mNode = node;
+    }
+
+    /**
+     * Gets a list of impression trackers for this InLine node. If there are no trackers, return
+     * an empty list.
+     *
+     * @return List of URLs of impression trackers
+     */
+    @NonNull
+    List<VastTracker> getImpressionTrackers() {
+        final List<Node> impressionNodes = XmlUtils.getMatchingChildNodes(mNode, IMPRESSION_TRACKER);
+
+        List<VastTracker> impressionTrackers = new ArrayList<VastTracker>();
+        for (Node impressionNode : impressionNodes) {
+            String uri = XmlUtils.getNodeValue(impressionNode);
+            if (!TextUtils.isEmpty(uri)) {
+                impressionTrackers.add(new VastTracker(uri));
+            }
+        }
+
+        return impressionTrackers;
+    }
+
+    /**
+     * Gets the error tracker associated with this node.
+     *
+     * @return The URL of the error tracker.
+     */
+    @NonNull
+    List<VastTracker> getErrorTrackers() {
+        final List<VastTracker> errorTrackers = new ArrayList<VastTracker>();
+        final List<Node> errorNodes = XmlUtils.getMatchingChildNodes(mNode, ERROR);
+        if (errorNodes == null) {
+            return errorTrackers;
+        }
+
+        for (Node error : errorNodes) {
+            final String tracker = XmlUtils.getNodeValue(error);
+            if (!TextUtils.isEmpty(tracker)) {
+                errorTrackers.add(new VastTracker(tracker, true));
+            }
+        }
+        return errorTrackers;
+    }
+
+    /**
+     * If there is a Linear section with at least one linear creative, return its XML manager.
+     *
+     * @return The {@link VastLinearXmlManager}s or an empty list if there is no Linear child node.
+     */
+    @NonNull
+    List<VastLinearXmlManager> getLinearXmlManagers() {
+        final List<VastLinearXmlManager> linearXmlManagers = new ArrayList<VastLinearXmlManager>();
+        final Node creativesNode = XmlUtils.getFirstMatchingChildNode(mNode, CREATIVES);
+        if (creativesNode == null) {
+            return linearXmlManagers;
+        }
+
+        // NOTE: there can only be one <Linear>, <CompanionAds>, OR <NonLinearAds> element
+        // per creative node
+
+        final List<Node> creativeNodes = XmlUtils.getMatchingChildNodes(creativesNode, CREATIVE);
+        if (creativeNodes == null) {
+            return linearXmlManagers;
+        }
+
+        for (Node creativeNode : creativeNodes) {
+            Node linearNode = XmlUtils.getFirstMatchingChildNode(creativeNode, LINEAR);
+            if (linearNode != null) {
+                linearXmlManagers.add(new VastLinearXmlManager(linearNode));
+            }
+        }
+        return linearXmlManagers;
+    }
+
+    /**
+     * If there is a CompanionAds section with at least one CompanionAd, return its XML manager.
+     *
+     * @return The {@link VastCompanionAdXmlManager}s or an empty list if there are no
+     * CompanionAds or Companion child node.
+     */
+    @NonNull
+    List<VastCompanionAdXmlManager> getCompanionAdXmlManagers() {
+        final List<VastCompanionAdXmlManager> companionAdXmlManagers = new
+                ArrayList<VastCompanionAdXmlManager>();
+        final Node creativesNode = XmlUtils.getFirstMatchingChildNode(mNode, CREATIVES);
+        if (creativesNode == null) {
+            return companionAdXmlManagers;
+        }
+
+        final List<Node> creativeNodes = XmlUtils.getMatchingChildNodes(creativesNode, CREATIVE);
+        if (creativeNodes == null) {
+            return companionAdXmlManagers;
+        }
+
+        for (Node creativeNode : creativeNodes) {
+            final Node companionAds = XmlUtils.getFirstMatchingChildNode(creativeNode, COMPANION_ADS);
+            if (companionAds == null) {
+                continue;
+            }
+
+            List<Node> companionAdsNodes = XmlUtils.getMatchingChildNodes(companionAds, COMPANION);
+            if (companionAdsNodes == null) {
+                continue;
+            }
+
+            for (Node companionNode : companionAdsNodes) {
+                companionAdXmlManagers.add(new VastCompanionAdXmlManager(companionNode));
+            }
+        }
+
+        return companionAdXmlManagers;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdConfig.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdConfig.java
new file mode 100644
index 00000000..6bf820ae
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdConfig.java
@@ -0,0 +1,181 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+
+import java.io.Serializable;
+import java.util.List;
+
+import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
+
+public class VastCompanionAdConfig implements Serializable {
+    private static final long serialVersionUID = 0L;
+
+    private final int mWidth;
+    private final int mHeight;
+    @NonNull private final VastResource mVastResource;
+    @Nullable private final String mClickThroughUrl;
+    @NonNull private final List<VastTracker> mClickTrackers;
+    @NonNull private final List<VastTracker> mCreativeViewTrackers;
+
+    public VastCompanionAdConfig(
+            int width,
+            int height,
+            @NonNull VastResource vastResource,
+            @Nullable String clickThroughUrl,
+            @NonNull List<VastTracker> clickTrackers,
+            @NonNull List<VastTracker> creativeViewTrackers) {
+        Preconditions.checkNotNull(vastResource);
+        Preconditions.checkNotNull(clickTrackers, "clickTrackers cannot be null");
+        Preconditions.checkNotNull(creativeViewTrackers, "creativeViewTrackers cannot be null");
+
+        mWidth = width;
+        mHeight = height;
+        mVastResource = vastResource;
+        mClickThroughUrl = clickThroughUrl;
+        mClickTrackers = clickTrackers;
+        mCreativeViewTrackers = creativeViewTrackers;
+    }
+
+    /**
+     * Add click trackers.
+     *
+     * @param clickTrackers List of URLs to hit
+     */
+    public void addClickTrackers(@NonNull final List<VastTracker> clickTrackers) {
+        Preconditions.checkNotNull(clickTrackers, "clickTrackers cannot be null");
+        mClickTrackers.addAll(clickTrackers);
+    }
+
+    /**
+     * Add creativeView trackers that are supposed to be fired when the companion ad is visible.
+     *
+     * @param creativeViewTrackers List of URLs to hit when this companion is viewed
+     */
+    public void addCreativeViewTrackers(@NonNull final List<VastTracker> creativeViewTrackers) {
+        Preconditions.checkNotNull(creativeViewTrackers, "creativeViewTrackers cannot be null");
+        mCreativeViewTrackers.addAll(creativeViewTrackers);
+    }
+
+    public int getWidth() {
+        return mWidth;
+    }
+
+    public int getHeight() {
+        return mHeight;
+    }
+
+    @NonNull
+    public VastResource getVastResource() {
+        return mVastResource;
+    }
+
+    @Nullable
+    public String getClickThroughUrl() {
+        return mClickThroughUrl;
+    }
+
+    @NonNull
+    public List<VastTracker> getClickTrackers() {
+        return mClickTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getCreativeViewTrackers() {
+        return mCreativeViewTrackers;
+    }
+
+    /**
+     * Called when the companion ad is displayed after the video. Handles firing the impression
+     * trackers.
+     *
+     * @param context         the context.
+     * @param contentPlayHead the time into the video. (should be equal to the duration)
+     */
+    void handleImpression(@NonNull Context context, int contentPlayHead) {
+        Preconditions.checkNotNull(context);
+
+        makeVastTrackingHttpRequest(
+                mCreativeViewTrackers,
+                null,
+                contentPlayHead,
+                null,
+                context
+        );
+    }
+
+    /**
+     * Called when the companion ad is clicked. Handles forwarding the user to the specified click
+     * through uri.
+     *
+     * @param context                the context. Has to be an activity context.
+     * @param requestCode            The code that identifies what kind of activity request is going
+     *                               to be made
+     * @param webViewClickThroughUrl The clickthrough url from the webview that should override the
+     *                               one set in the companion ad if the resource is Javascript,
+     *                               HTML, or an IFrame.
+     */
+    void handleClick(@NonNull final Context context, final int requestCode,
+            @Nullable final String webViewClickThroughUrl) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkArgument(context instanceof Activity, "context must be an activity");
+
+        final String correctClickThroughUrl = mVastResource.getCorrectClickThroughUrl(
+                mClickThroughUrl, webViewClickThroughUrl);
+
+        if (TextUtils.isEmpty(correctClickThroughUrl)) {
+            return;
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction == UrlAction.OPEN_IN_APP_BROWSER) {
+                            Bundle bundle = new Bundle();
+                            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY,
+                                    url);
+
+                            final Class clazz = MoPubBrowser.class;
+                            final Intent intent = Intents.getStartActivityIntent(
+                                    context, clazz, bundle);
+                            try {
+                                ((Activity) context).startActivityForResult(intent, requestCode);
+                            } catch (ActivityNotFoundException e) {
+                                MoPubLog.d("Activity " + clazz.getName() + " not found. Did you " +
+                                        "declare it in your AndroidManifest.xml?");
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withoutMoPubBrowser()
+                .build().handleUrl(context, correctClickThroughUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java
new file mode 100644
index 00000000..abacc76c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java
@@ -0,0 +1,146 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * This XML manager handles companion ads.
+ */
+class VastCompanionAdXmlManager {
+
+    // Element names
+    private static final String VIDEO_TRACKER = "Tracking";
+    private static final String TRACKING_EVENTS = "TrackingEvents";
+    private static final String COMPANION_CLICK_THROUGH = "CompanionClickThrough";
+    private static final String COMPANION_CLICK_TRACKING = "CompanionClickTracking";
+
+    // Attribute names
+    private static final String EVENT = "event";
+    private static final String WIDTH = "width";
+    private static final String HEIGHT = "height";
+
+    // Attribute values
+    private static final String CREATIVE_VIEW = "creativeView";
+
+    @NonNull private final Node mCompanionNode;
+    @NonNull private final VastResourceXmlManager mResourceXmlManager;
+
+    VastCompanionAdXmlManager(@NonNull final Node companionNode) {
+        Preconditions.checkNotNull(companionNode, "companionNode cannot be null");
+        mCompanionNode = companionNode;
+        mResourceXmlManager = new VastResourceXmlManager(companionNode);
+    }
+
+    /**
+     * Gets the width attribute for the companion ad or {@code null} if not present. This
+     * attribute is required according to the VAST 3.0 spec.
+     *
+     * @return Integer width attribute or {@code null}.
+     */
+    @Nullable
+    Integer getWidth() {
+        return XmlUtils.getAttributeValueAsInt(mCompanionNode, WIDTH);
+    }
+
+    /**
+     * Gets the height attribute for the companion ad or {@code null} if not present. This
+     * attribute is required according to the VAST 3.0 spec.
+     *
+     * @return Integer height attribute or {@code null}.
+     */
+    @Nullable
+    Integer getHeight() {
+        return XmlUtils.getAttributeValueAsInt(mCompanionNode, HEIGHT);
+    }
+
+    @NonNull
+    VastResourceXmlManager getResourceXmlManager() {
+        return mResourceXmlManager;
+    }
+
+    /**
+     * Gets the clickthrough url of this companion ad or {@code null} if it does not exist.
+     *
+     * @return The String clickthrough URL or {@code null}
+     */
+    @Nullable
+    String getClickThroughUrl() {
+        final Node node = XmlUtils.getFirstMatchingChildNode(
+                mCompanionNode,
+                COMPANION_CLICK_THROUGH
+        );
+        return XmlUtils.getNodeValue(node);
+    }
+
+    /**
+     * Gets a list of click trackers for this companion ad. If none are present, return an empty
+     * list.
+     *
+     * @return List of click tracker URLs or an empty list.
+     */
+    @NonNull
+    List<VastTracker> getClickTrackers() {
+        final List<VastTracker> companionAdClickTrackers = new ArrayList<VastTracker>();
+        final List<Node> trackerNodes = XmlUtils.getMatchingChildNodes(mCompanionNode, COMPANION_CLICK_TRACKING);
+        if (trackerNodes == null) {
+            return companionAdClickTrackers;
+        }
+        for (final Node trackerNode : trackerNodes) {
+            String uri = XmlUtils.getNodeValue(trackerNode);
+            if (!TextUtils.isEmpty(uri)) {
+                companionAdClickTrackers.add(new VastTracker(uri));
+            }
+        }
+        return companionAdClickTrackers;
+    }
+
+    /**
+     * Gets a list of creativeView trackers for this companion ad. These are impression trackers for
+     * just this companion ad as the normal impression trackers are reserved for the whole ad. These
+     * should fire when this companion ad is shown. If none are present, return an empty list.
+     *
+     * @return List of creative view URLs or an empty list.
+     */
+    @NonNull
+    List<VastTracker> getCompanionCreativeViewTrackers() {
+        final List<VastTracker> companionCreativeViewTrackers = new ArrayList<VastTracker>();
+        final Node node = XmlUtils.getFirstMatchingChildNode(
+                mCompanionNode,
+                TRACKING_EVENTS
+        );
+
+        if (node == null) {
+            return companionCreativeViewTrackers;
+        }
+
+        final List<Node> trackerNodes = XmlUtils.getMatchingChildNodes(
+                node,
+                VIDEO_TRACKER,
+                EVENT,
+                Collections.singletonList(CREATIVE_VIEW)
+        );
+
+        for (final Node trackerNode : trackerNodes) {
+            final String trackerUrl = XmlUtils.getNodeValue(trackerNode);
+            companionCreativeViewTrackers.add(new VastTracker(trackerUrl));
+        }
+
+        return companionCreativeViewTrackers;
+    }
+
+    boolean hasResources() {
+        return !TextUtils.isEmpty(mResourceXmlManager.getStaticResource()) ||
+                !TextUtils.isEmpty(mResourceXmlManager.getHTMLResource()) ||
+                !TextUtils.isEmpty(mResourceXmlManager.getIFrameResource());
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastErrorCode.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastErrorCode.java
new file mode 100644
index 00000000..f216a958
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastErrorCode.java
@@ -0,0 +1,63 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+/**
+ * The various possible error codes for VAST that MoPub supports. See
+ * http://www.iab.net/media/file/VASTv3.0.pdf for more information about the error codes.
+ */
+public enum VastErrorCode {
+    /**
+     * For any type of XML issue in the VAST document. e.g. missing a matching tag, missing a square
+     * bracket, not using CDATA correctly, etc.
+     */
+    XML_PARSING_ERROR("100"),
+
+    /**
+     * When following a wrapper redirect and the URI was either unavailable or reached a timeout
+     * as defined by the video player.
+     */
+    WRAPPER_TIMEOUT("301"),
+
+    /**
+     * When receiving a no ads VAST response after one or more Wrappers. See section 2.4.2.4 in the
+     * Vast 3.0 spec for details.
+     */
+    NO_ADS_VAST_RESPONSE("303"),
+
+    /**
+     * For any reason the linear video ad failed to download or play (or for errors during
+     * playback).
+     */
+    GENERAL_LINEAR_AD_ERROR("400"),
+
+    /**
+     * For any reason the companion ad failed to download or show. MoPub still tries to show the
+     * linear ad regardless of the status of the companion ad.
+     */
+    GENERAL_COMPANION_AD_ERROR("600"),
+
+    /**
+     * Any other error, or an unexpected error.
+     */
+    UNDEFINED_ERROR("900");
+
+    @NonNull private final String mErrorCode;
+
+    VastErrorCode(@NonNull String errorCode) {
+        Preconditions.checkNotNull(errorCode, "errorCode cannot be null");
+        mErrorCode = errorCode;
+    }
+
+    /**
+     * Gets the code for the error
+     *
+     * @return String of the code representing that error
+     */
+    @NonNull
+    String getErrorCode() {
+        return mErrorCode;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
new file mode 100644
index 00000000..824f9516
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with a "fractional" tracking threshold on the interval [0.0, 1.0].
+ * The tracker should be triggered after the given fraction of the video has been played.
+ */
+public class VastFractionalProgressTracker extends VastTracker implements Comparable<VastFractionalProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final float mFraction;
+
+    public VastFractionalProgressTracker(@NonNull final String trackingUrl, float trackingFraction) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingFraction >= 0);
+        mFraction = trackingFraction;
+    }
+
+    public float trackingFraction() {
+        return mFraction;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastFractionalProgressTracker other) {
+        float you = other.trackingFraction();
+        float me = trackingFraction();
+
+        return Double.compare(me, you);
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%2f: %s", mFraction, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastIconConfig.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastIconConfig.java
new file mode 100644
index 00000000..73648a27
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastIconConfig.java
@@ -0,0 +1,182 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.io.Serializable;
+import java.util.List;
+
+import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
+
+/**
+ * The data and event handlers for the icon displayed during a VAST 3.0 video.
+ */
+class VastIconConfig implements Serializable {
+    private static final long serialVersionUID = 0L;
+
+    private final int mWidth;
+    private final int mHeight;
+    private final int mOffsetMS;
+    @Nullable private final Integer mDurationMS;
+    @NonNull private final VastResource mVastResource;
+    @NonNull private final List<VastTracker> mClickTrackingUris;
+    @Nullable private final String mClickThroughUri;
+    @NonNull private final List<VastTracker> mViewTrackingUris;
+
+    VastIconConfig(int width,
+            int height,
+            @Nullable Integer offsetMS,
+            @Nullable Integer durationMS,
+            @NonNull VastResource vastResource,
+            @NonNull List<VastTracker> clickTrackingUris,
+            @Nullable String clickThroughUri,
+            @NonNull List<VastTracker> viewTrackingUris) {
+        Preconditions.checkNotNull(vastResource);
+        Preconditions.checkNotNull(clickTrackingUris);
+        Preconditions.checkNotNull(viewTrackingUris);
+
+        mWidth = width;
+        mHeight = height;
+        mOffsetMS = offsetMS == null ? 0 : offsetMS;
+        mDurationMS = durationMS;
+        mVastResource = vastResource;
+        mClickTrackingUris = clickTrackingUris;
+        mClickThroughUri = clickThroughUri;
+        mViewTrackingUris = viewTrackingUris;
+    }
+
+    int getWidth() {
+        return mWidth;
+    }
+
+    int getHeight() {
+        return mHeight;
+    }
+
+    /**
+     * The offset time into a video that the icon is displayed.
+     *
+     * @return the offset in milliseconds.
+     */
+    int getOffsetMS() {
+        return mOffsetMS;
+    }
+
+    /**
+     * The duration that the icon is displayed during a video.
+     *
+     * @return the duration in milliseconds.
+     */
+    @Nullable
+    Integer getDurationMS() {
+        return mDurationMS;
+    }
+
+    /**
+     * The resource describing the icon's type.
+     *
+     * @return the resource.
+     */
+    @NonNull
+    VastResource getVastResource() {
+        return mVastResource;
+    }
+
+    @NonNull
+    List<VastTracker> getClickTrackingUris() {
+        return mClickTrackingUris;
+    }
+
+    @Nullable
+    String getClickThroughUri() {
+        return mClickThroughUri;
+    }
+
+    @NonNull
+    List<VastTracker> getViewTrackingUris() {
+        return mViewTrackingUris;
+    }
+
+    /**
+     * Called when the icon is displayed during the video. Handles firing the impression trackers.
+     *
+     * @param context the context.
+     * @param contentPlayHead the time into the video.
+     * @param assetUri the uri of the video.
+     */
+    void handleImpression(@NonNull Context context, int contentPlayHead, @NonNull String assetUri) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(assetUri);
+
+        makeVastTrackingHttpRequest(
+                mViewTrackingUris,
+                null,
+                contentPlayHead,
+                assetUri,
+                context
+        );
+    }
+
+    /**
+     * Called when the icon is clicked. Handles forwarding the user to the click through uri.
+     *
+     * @param context                the context.
+     * @param webViewClickThroughUri The click through uri for Javascript, HTML and IFrame resources
+     *                               from the WebView
+     */
+    void handleClick(@NonNull final Context context, @Nullable String webViewClickThroughUri) {
+        Preconditions.checkNotNull(context);
+
+
+        final String correctClickThroughUri = mVastResource.getCorrectClickThroughUrl(
+                mClickThroughUri, webViewClickThroughUri);
+
+        if (TextUtils.isEmpty(correctClickThroughUri)) {
+            return;
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction == UrlAction.OPEN_IN_APP_BROWSER) {
+                            Bundle bundle = new Bundle();
+                            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
+
+                            Intent intent = Intents.getStartActivityIntent(
+                                    context, MoPubBrowser.class, bundle);
+                            try {
+                                Intents.startActivity(context, intent);
+                            } catch (IntentNotResolvableException e) {
+                                MoPubLog.d(e.getMessage());
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withoutMoPubBrowser()
+                .build()
+                .handleUrl(context, correctClickThroughUri);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastIconXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastIconXmlManager.java
new file mode 100644
index 00000000..68afcb66
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastIconXmlManager.java
@@ -0,0 +1,154 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Strings;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This XML manager handles Vast 3.0 icons.
+ */
+public class VastIconXmlManager {
+
+    // Element names
+    public static final String ICON_CLICKS = "IconClicks";
+    public static final String ICON_CLICK_TRACKING = "IconClickTracking";
+    public static final String ICON_CLICK_THROUGH = "IconClickThrough";
+    public static final String ICON_VIEW_TRACKING = "IconViewTracking";
+
+    // Attribute names
+    public static final String WIDTH = "width";
+    public static final String HEIGHT = "height";
+    public static final String OFFSET = "offset";
+    public static final String DURATION = "duration";
+
+    @NonNull private final Node mIconNode;
+    @NonNull private final VastResourceXmlManager mResourceXmlManager;
+
+    VastIconXmlManager(@NonNull final Node iconNode) {
+        Preconditions.checkNotNull(iconNode);
+        mIconNode = iconNode;
+        mResourceXmlManager = new VastResourceXmlManager(iconNode);
+    }
+
+    /**
+     * Gets the width attribute for the icon in dp or {@code null} if not present. This attribute
+     * is required according to the VAST 3.0 spec.
+     *
+     * @return Integer width attribute or {@code null}.
+     */
+    @Nullable
+    Integer getWidth() {
+        return XmlUtils.getAttributeValueAsInt(mIconNode, WIDTH);
+    }
+
+    /**
+     * Gets the height attribute for the icon in dp or {@code null} if not present. This attribute
+     * is required according to the VAST 3.0 spec.
+     *
+     * @return Integer height attribute or {@code null}.
+     */
+    @Nullable
+    Integer getHeight() {
+        return XmlUtils.getAttributeValueAsInt(mIconNode, HEIGHT);
+    }
+
+    /**
+     * Gets the offset attribute for the icon or {@code null} if not present or not formatted
+     * correctly. It represents the time in milliseconds into the video that the icon will be
+     * displayed. The attribute value is represented as HH:MM:SS[.mmm] and this method translates
+     * it to milliseconds. This attribute is optional according to the VAST 3.0 spec.
+     *
+     * @return Integer offset in milliseconds attribute or {@code null}.
+     */
+    @Nullable
+    Integer getOffsetMS() {
+        String iconOffsetStr = XmlUtils.getAttributeValue(mIconNode, OFFSET);
+        Integer iconOffset = null;
+        try {
+            iconOffset = Strings.parseAbsoluteOffset(iconOffsetStr);
+        } catch (NumberFormatException e) {
+            MoPubLog.d(String.format("Invalid VAST icon offset format: %s:", iconOffsetStr));
+        }
+        return iconOffset;
+    }
+
+    /**
+     * Gets the duration attribute for the icon or {@code null} if not present or not formatted
+     * correctly. It represents the duration in milliseconds that the icon will be displayed.
+     * The attribute value is represented as HH:MM:SS[.mmm] and this method translates it to
+     * milliseconds. This attribute is optional according to the VAST 3.0 spec.
+     *
+     * @return Integer duration in milliseconds attribute or {@code null}.
+     */
+    @Nullable
+    Integer getDurationMS() {
+        String iconDurationStr = XmlUtils.getAttributeValue(mIconNode, DURATION);
+        Integer iconDuration = null;
+        try {
+            iconDuration = Strings.parseAbsoluteOffset(iconDurationStr);
+        } catch (NumberFormatException e) {
+            MoPubLog.d(String.format("Invalid VAST icon duration format: %s:", iconDurationStr));
+        }
+        return iconDuration;
+    }
+
+    @NonNull
+    VastResourceXmlManager getResourceXmlManager() {
+        return mResourceXmlManager;
+    }
+
+    @NonNull
+    List<VastTracker> getClickTrackingUris() {
+        Node iconClicksNode = XmlUtils.getFirstMatchingChildNode(mIconNode, ICON_CLICKS);
+        List<VastTracker> iconClickTrackingUris = new ArrayList<VastTracker>();
+        if (iconClicksNode == null) {
+            return iconClickTrackingUris;
+        }
+
+        List<Node> iconClickTrackingNodes =
+                XmlUtils.getMatchingChildNodes(iconClicksNode, ICON_CLICK_TRACKING);
+        for (Node iconClickTrackingNode : iconClickTrackingNodes) {
+            String uri = XmlUtils.getNodeValue(iconClickTrackingNode);
+            if (uri != null) {
+                iconClickTrackingUris.add(new VastTracker(uri));
+            }
+        }
+        return iconClickTrackingUris;
+    }
+
+    @Nullable
+    String getClickThroughUri() {
+        Node iconClicksNode = XmlUtils.getFirstMatchingChildNode(mIconNode, ICON_CLICKS);
+        if (iconClicksNode == null) {
+            return null;
+        }
+
+        Node iconClickThroughNode =
+                XmlUtils.getFirstMatchingChildNode(iconClicksNode, ICON_CLICK_THROUGH);
+        return XmlUtils.getNodeValue(iconClickThroughNode);
+    }
+
+    @NonNull
+    List<VastTracker> getViewTrackingUris() {
+        List<Node> iconViewTrackingNodes =
+                XmlUtils.getMatchingChildNodes(mIconNode, ICON_VIEW_TRACKING);
+        List<VastTracker> iconViewTrackingUris = new ArrayList<VastTracker>();
+
+        for (Node iconViewTrackingNode : iconViewTrackingNodes) {
+            String uri = XmlUtils.getNodeValue(iconViewTrackingNode);
+            if (uri != null) {
+                iconViewTrackingUris.add(new VastTracker(uri));
+            }
+        }
+        return iconViewTrackingUris;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastInLineXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastInLineXmlManager.java
new file mode 100644
index 00000000..108d5f5c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastInLineXmlManager.java
@@ -0,0 +1,16 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import org.w3c.dom.Node;
+
+/**
+ * This XML manager handles InLine nodes. An InLine node can contain impression trackers,
+ * video ads, and companion ads.
+ */
+class VastInLineXmlManager extends VastBaseInLineWrapperXmlManager {
+
+    VastInLineXmlManager(@NonNull final Node inLineNode) {
+        super(inLineNode);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java
new file mode 100644
index 00000000..6852e38e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java
@@ -0,0 +1,411 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Strings;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * This XML manager handles the meta data around the video file. This includes video progress
+ * trackers and click trackers. This also houses the manager for the actual media file.
+ */
+class VastLinearXmlManager {
+
+    // Element names
+    private static final String TRACKING_EVENTS = "TrackingEvents";
+    private static final String VIDEO_CLICKS = "VideoClicks";
+    private static final String VIDEO_TRACKER = "Tracking";
+    private static final String CLICK_THROUGH = "ClickThrough";
+    private static final String CLICK_TRACKER = "ClickTracking";
+    private static final String MEDIA_FILES = "MediaFiles";
+    private static final String MEDIA_FILE = "MediaFile";
+    public static final String ICONS = "Icons";
+    public static final String ICON = "Icon";
+
+    // Attribute names
+    private static final String EVENT = "event";
+    private static final String OFFSET = "offset";
+    private static final String SKIP_OFFSET = "skipoffset";
+
+    // Attribute values
+    private static final String CREATIVE_VIEW = "creativeView";
+    private static final String START = "start";
+    private static final String FIRST_QUARTILE = "firstQuartile";
+    private static final String MIDPOINT = "midpoint";
+    private static final String THIRD_QUARTILE = "thirdQuartile";
+    private static final String COMPLETE = "complete";
+    private static final String PAUSE = "pause";
+    private static final String RESUME = "resume";
+    private static final String CLOSE = "close";
+    private static final String CLOSE_LINEAR = "closeLinear";
+    private static final String PROGRESS = "progress";
+    private static final String SKIP = "skip";
+
+    private static final int CREATIVE_VIEW_TRACKER_THRESHOLD = 0;
+    private static final int START_TRACKER_THRESHOLD = 2000;
+    private static final float FIRST_QUARTER_MARKER = 0.25f;
+    private static final float MID_POINT_MARKER = 0.50f;
+    private static final float THIRD_QUARTER_MARKER = 0.75f;
+
+    @NonNull private final Node mLinearNode;
+
+    VastLinearXmlManager(@NonNull final Node linearNode) {
+        Preconditions.checkNotNull(linearNode);
+        mLinearNode = linearNode;
+    }
+
+    /**
+     * Return a sorted list of the video's percent-based progress-trackers. These are the
+     * quartile trackers and any "progress" nodes with percent-based offsets.
+     *
+     * Quartile trackers look like:
+     * {@code
+     * <Tracking event="firstQuartile">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     *
+     * Percent-based progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="11%">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastFractionalProgressTracker> getFractionalProgressTrackers() {
+        // Add all the quartile trackers from VAST 2.0:
+        List<VastFractionalProgressTracker> percentTrackers = new ArrayList<VastFractionalProgressTracker>();
+
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackersByAttribute(FIRST_QUARTILE), FIRST_QUARTER_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackersByAttribute(MIDPOINT), MID_POINT_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackersByAttribute(THIRD_QUARTILE), THIRD_QUARTER_MARKER);
+
+        final Node trackingEvents = XmlUtils.getFirstMatchingChildNode(mLinearNode, TRACKING_EVENTS);
+        if (trackingEvents != null) {
+            // Get any other trackers with event="progress" offset="n%"
+            final List<Node> progressNodes = XmlUtils.getMatchingChildNodes(trackingEvents,
+                    VIDEO_TRACKER, EVENT, Collections.singletonList(PROGRESS));
+
+            for (Node progressNode : progressNodes) {
+                String offsetString = XmlUtils.getAttributeValue(progressNode, OFFSET);
+                if (offsetString == null) {
+                    continue;
+                }
+                offsetString = offsetString.trim();
+                if (Strings.isPercentageTracker(offsetString)) {
+                    String trackingUrl = XmlUtils.getNodeValue(progressNode);
+                    try {
+                        float trackingFraction =
+                                Float.parseFloat(offsetString.replace("%", "")) / 100f;
+                        percentTrackers.add(new VastFractionalProgressTracker(trackingUrl, trackingFraction));
+                    } catch (NumberFormatException e) {
+                        MoPubLog.d(String.format("Failed to parse VAST progress tracker %s",
+                                offsetString));
+                    }
+                }
+            }
+        }
+
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(percentTrackers);
+        return percentTrackers;
+    }
+
+    /**
+     * Return a sorted list of the video's absolute progress trackers. This includes start trackers
+     * and any "progress" nodes with absolute offsets.
+     *
+     * Start trackers live in nodes like:
+     * {@code
+     * <Tracking event="start">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     * Absolute progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="00:00:10.000">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastAbsoluteProgressTracker> getAbsoluteProgressTrackers() {
+        List<VastAbsoluteProgressTracker> trackers = new ArrayList<VastAbsoluteProgressTracker>();
+
+        // Start trackers are treated as absolute trackers with a 2s offset.
+        final List<String> startTrackers = getVideoTrackersByAttribute(START);
+        for (String url : startTrackers) {
+            trackers.add(new VastAbsoluteProgressTracker(url, START_TRACKER_THRESHOLD));
+        }
+
+        final Node trackingEvents = XmlUtils.getFirstMatchingChildNode(mLinearNode, TRACKING_EVENTS);
+        if (trackingEvents != null) {
+            // Parse progress trackers and extract the absolute offsets of the form "HH:MM:SS[.mmm]"
+
+            final List<Node> progressNodes = XmlUtils.getMatchingChildNodes(trackingEvents,
+                    VIDEO_TRACKER, EVENT, Collections.singletonList(PROGRESS));
+            for (Node progressNode : progressNodes) {
+                String offsetString = XmlUtils.getAttributeValue(progressNode, OFFSET);
+                if (offsetString == null) {
+                    continue;
+                }
+                offsetString = offsetString.trim();
+                if (Strings.isAbsoluteTracker(offsetString)) {
+                    String trackingUrl = XmlUtils.getNodeValue(progressNode);
+                    try {
+                        Integer trackingMilliseconds = Strings.parseAbsoluteOffset(offsetString);
+                        if (trackingMilliseconds != null) {
+                            trackers.add(new VastAbsoluteProgressTracker(trackingUrl, trackingMilliseconds));
+                        }
+                    } catch (NumberFormatException e) {
+                        MoPubLog.d(String.format("Failed to parse VAST progress tracker %s",
+                                offsetString));
+                    }
+                }
+            }
+
+            // Parse creativeView trackers
+            final List<Node> creativeViewNodes = XmlUtils.getMatchingChildNodes(trackingEvents,
+                    VIDEO_TRACKER, EVENT, Collections.singletonList(CREATIVE_VIEW));
+            for (Node creativeViewNode : creativeViewNodes) {
+                trackers.add(
+                        new VastAbsoluteProgressTracker(XmlUtils.getNodeValue(creativeViewNode),
+                                CREATIVE_VIEW_TRACKER_THRESHOLD));
+            }
+        }
+
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(trackers);
+        return trackers;
+    }
+
+    /**
+     * Gets a list of URLs for when the video finishes playing. This list may be empty.
+     *
+     * @return List of String URLs of video complete trackers.
+     */
+    @NonNull
+    List<VastTracker> getVideoCompleteTrackers() {
+        return getVideoTrackersByAttributeAsVastTrackers(COMPLETE);
+    }
+
+    /**
+     * Gets a list of URLs for when the video pauses. This list may be empty.
+     *
+     * @return List of String URLs of pause trackers.
+     */
+    @NonNull
+    List<VastTracker> getPauseTrackers() {
+        List<String> trackers = getVideoTrackersByAttribute(PAUSE);
+        List<VastTracker> vastRepeatableTrackers = new ArrayList<VastTracker>();
+        for (String tracker : trackers) {
+            vastRepeatableTrackers.add(new VastTracker(tracker, true));
+        }
+        return vastRepeatableTrackers;
+    }
+
+    /**
+     * Gets a list of URLs for when the video resumes. This list may be empty.
+     *
+     * @return List of String URLs of resume trackers.
+     */
+    @NonNull
+    List<VastTracker> getResumeTrackers() {
+        List<String> trackers = getVideoTrackersByAttribute(RESUME);
+        List<VastTracker> vastRepeatableTrackers = new ArrayList<VastTracker>();
+        for (String tracker : trackers) {
+            vastRepeatableTrackers.add(new VastTracker(tracker, true));
+        }
+        return vastRepeatableTrackers;
+    }
+
+    /**
+     * Gets a list of URLs for when the video closes. This list may be empty.
+     *
+     * @return List of String URLs of video closes.
+     */
+    @NonNull
+    List<VastTracker> getVideoCloseTrackers() {
+        List<VastTracker> closeTrackers = getVideoTrackersByAttributeAsVastTrackers(CLOSE);
+        closeTrackers.addAll(getVideoTrackersByAttributeAsVastTrackers(CLOSE_LINEAR));
+        return closeTrackers;
+    }
+
+    /**
+     * Gets a list of URLs for when the user skips the video. This list may be empty.
+     *
+     * @return List of String URLs of video skip trackers.
+     */
+    @NonNull
+    List<VastTracker> getVideoSkipTrackers() {
+        return getVideoTrackersByAttributeAsVastTrackers(SKIP);
+    }
+
+    /**
+     * Gets the clickthrough url. May be null.
+     *
+     * @return The clickthrough URL or {@code null} if there isn't one.
+     */
+    @Nullable
+    String getClickThroughUrl() {
+        final Node videoClicks = XmlUtils.getFirstMatchingChildNode(mLinearNode, VIDEO_CLICKS);
+        if (videoClicks == null) {
+            return null;
+        }
+        return XmlUtils.getNodeValue(XmlUtils.getFirstMatchingChildNode(videoClicks, CLICK_THROUGH));
+    }
+
+    /**
+     * Gets a list of URLs to track the video click event. This list may be empty.
+     *
+     * @return List of String URLs of click trackers.
+     */
+    @NonNull
+    List<VastTracker> getClickTrackers() {
+        List<VastTracker> clickTrackers = new ArrayList<VastTracker>();
+
+        final Node videoClicks = XmlUtils.getFirstMatchingChildNode(mLinearNode, VIDEO_CLICKS);
+        if (videoClicks == null) {
+            return clickTrackers;
+        }
+
+        final List<Node> clickTrackerNodes = XmlUtils.getMatchingChildNodes(
+                videoClicks,
+                CLICK_TRACKER
+        );
+
+        for (Node clickTrackerNode : clickTrackerNodes) {
+            String tracker = XmlUtils.getNodeValue(clickTrackerNode);
+            if (tracker != null) {
+                clickTrackers.add(new VastTracker(tracker));
+            }
+        }
+        return clickTrackers;
+    }
+
+    /**
+     * Gets where the video can be skipped from. This can be in a percentage or in the format
+     * 'hh:mm:ss(.mmm)' (for example, a video that is skippable 5 seconds into a 20 second video
+     * would be '25%', '00:00:05', or '00:00:05.000').
+     *
+     * @return The skip offset, or {@code null} if there isn't one.
+     */
+    @Nullable
+    String getSkipOffset() {
+        final String skipOffsetString = XmlUtils.getAttributeValue(mLinearNode, SKIP_OFFSET);
+        if (skipOffsetString == null) {
+            return null;
+        }
+
+        if (skipOffsetString.trim().isEmpty()) {
+            return null;
+        }
+
+        return skipOffsetString.trim();
+    }
+
+    /**
+     * If there is a Media section, return its XML manager.
+     *
+     * @return The {@link VastMediaXmlManager}
+     * or an empty list if there is no Media child node.
+     */
+    @NonNull
+    List<VastMediaXmlManager> getMediaXmlManagers() {
+        final List<VastMediaXmlManager> mediaXmlManagers = new ArrayList<VastMediaXmlManager>();
+
+        final Node mediaFiles = XmlUtils.getFirstMatchingChildNode(mLinearNode, MEDIA_FILES);
+        if (mediaFiles == null) {
+            return mediaXmlManagers;
+        }
+
+        List<Node> mediaNodes = XmlUtils.getMatchingChildNodes(mediaFiles, MEDIA_FILE);
+        for (Node mediaNode : mediaNodes) {
+            mediaXmlManagers.add(new VastMediaXmlManager(mediaNode));
+        }
+
+        return mediaXmlManagers;
+    }
+
+    @NonNull
+    List<VastIconXmlManager> getIconXmlManagers() {
+        final List<VastIconXmlManager> iconXmlManagers = new ArrayList<VastIconXmlManager>();
+
+        final Node icons= XmlUtils.getFirstMatchingChildNode(mLinearNode, ICONS);
+        if (icons == null) {
+            return iconXmlManagers;
+        }
+
+        List<Node> iconNodes = XmlUtils.getMatchingChildNodes(icons, ICON);
+        for (Node iconNode : iconNodes) {
+            iconXmlManagers.add(new VastIconXmlManager(iconNode));
+        }
+
+        return iconXmlManagers;
+    }
+
+    @NonNull
+    private List<VastTracker> getVideoTrackersByAttributeAsVastTrackers(
+            @NonNull final String attributeValue) {
+        List<String> trackers = getVideoTrackersByAttribute(attributeValue);
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>(trackers.size());
+        for (String tracker : trackers) {
+            vastTrackers.add(new VastTracker(tracker));
+        }
+        return vastTrackers;
+    }
+
+    /**
+     * This helper method makes it easy to get a tracking event with a specific name in a linear
+     * node. This returns an empty list if there isn't a tracker with that event name.
+     *
+     * @param attributeValue The name of the tracking event
+     * @return List of URLs with that tracker name or an empty list if none found.
+     */
+    @NonNull
+    private List<String> getVideoTrackersByAttribute(@NonNull final String attributeValue) {
+        Preconditions.checkNotNull(attributeValue);
+        List<String> videoTrackers = new ArrayList<String>();
+
+        final Node trackingEvents = XmlUtils.getFirstMatchingChildNode(mLinearNode, TRACKING_EVENTS);
+        if (trackingEvents == null) {
+            return videoTrackers;
+        }
+
+        final List<Node> videoTrackerNodes = XmlUtils.getMatchingChildNodes(
+                trackingEvents,
+                VIDEO_TRACKER,
+                EVENT,
+                Collections.singletonList(attributeValue)
+        );
+
+        for (Node videoTrackerNode : videoTrackerNodes) {
+            String tracker = XmlUtils.getNodeValue(videoTrackerNode);
+            if (tracker != null) {
+                videoTrackers.add(tracker);
+            }
+        }
+
+        return videoTrackers;
+    }
+
+    private void addQuartileTrackerWithFraction(
+            @NonNull final List<VastFractionalProgressTracker> trackers,
+            @NonNull final List<String> urls, float fraction) {
+        Preconditions.checkNotNull(trackers, "trackers cannot be null");
+        Preconditions.checkNotNull(urls, "urls cannot be null");
+        for (String url : urls) {
+            trackers.add(new VastFractionalProgressTracker(url, fraction));
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastMacro.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastMacro.java
new file mode 100644
index 00000000..dd5cf87b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastMacro.java
@@ -0,0 +1,29 @@
+package com.mopub.mobileads;
+
+/**
+ * Macros that MoPub supports. This is in the format of [name]. For example, an errorcode macro
+ * would show up as "http://www.somesite.com/somemethod?error=[ERRORCODE]"
+ */
+enum VastMacro {
+    /**
+     * The VAST error number that represents type of error. See {@link VastErrorCode} for possible
+     * values.
+     */
+    ERRORCODE,
+
+    /**
+     * Current progress of the video in the format HH:MM:SS.mmm. For example, 4.5 seconds into the
+     * video would be represented as 00:00:04.500.
+     */
+    CONTENTPLAYHEAD,
+
+    /**
+     * A random 8-digit number intended for cachebusting.
+     */
+    CACHEBUSTING,
+
+    /**
+     * The url of the current video.
+     */
+    ASSETURI
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastMacroHelper.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastMacroHelper.java
new file mode 100644
index 00000000..429376ba
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastMacroHelper.java
@@ -0,0 +1,105 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Handles macro substitution with actual data.
+ */
+public class VastMacroHelper {
+
+    @NonNull private final List<String> mOriginalUris;
+    @NonNull private final Map<VastMacro, String> mMacroDataMap;
+
+    public VastMacroHelper(@NonNull final List<String> uris) {
+        Preconditions.checkNotNull(uris, "uris cannot be null");
+        mOriginalUris = uris;
+        mMacroDataMap = new HashMap<VastMacro, String>();
+        mMacroDataMap.put(VastMacro.CACHEBUSTING, getCachebustingString());
+    }
+
+    @NonNull
+    public List<String> getUris() {
+        List<String> modifiedUris = new ArrayList<String>();
+
+        for(final String originalUri : mOriginalUris) {
+            String modifiedUri = originalUri;
+            if (TextUtils.isEmpty(modifiedUri)) {
+                continue;
+            }
+            for (final VastMacro vastMacro : VastMacro.values()) {
+                String value = mMacroDataMap.get(vastMacro);
+                if (value == null) {
+                    value = "";
+                }
+
+                modifiedUri = modifiedUri.replaceAll("\\[" + vastMacro.name() + "\\]",
+                        value);
+            }
+
+            modifiedUris.add(modifiedUri);
+        }
+
+        return modifiedUris;
+    }
+
+    @NonNull
+    public VastMacroHelper withErrorCode(@Nullable final VastErrorCode errorCode) {
+        if (errorCode != null) {
+            mMacroDataMap.put(VastMacro.ERRORCODE, errorCode.getErrorCode());
+        }
+        return this;
+    }
+
+    @NonNull
+    public VastMacroHelper withContentPlayHead(@Nullable final Integer contentPlayHeadMS) {
+        if (contentPlayHeadMS != null) {
+            String contentPlayHeadMSStr = formatContentPlayHead(contentPlayHeadMS);
+            if (!TextUtils.isEmpty(contentPlayHeadMSStr)) {
+                mMacroDataMap.put(VastMacro.CONTENTPLAYHEAD, contentPlayHeadMSStr);
+            }
+        }
+        return this;
+    }
+
+    @NonNull
+    public VastMacroHelper withAssetUri(@Nullable String assetUri) {
+        if (!TextUtils.isEmpty(assetUri)) {
+            // URL-encode any URLs
+            try {
+                assetUri = URLEncoder.encode(assetUri, "UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                MoPubLog.w("Failed to encode url", e);
+            }
+            mMacroDataMap.put(VastMacro.ASSETURI, assetUri);
+        }
+        return this;
+    }
+
+    @NonNull
+    private String getCachebustingString() {
+        return String.format(Locale.US, "%08d", Math.round(Math.random() * 100000000));
+    }
+
+    @NonNull
+    private String formatContentPlayHead(int contentPlayHeadMS) {
+        return String.format("%02d:%02d:%02d.%03d",
+                TimeUnit.MILLISECONDS.toHours(contentPlayHeadMS),
+                TimeUnit.MILLISECONDS.toMinutes(contentPlayHeadMS) % TimeUnit.HOURS.toMinutes(1),
+                TimeUnit.MILLISECONDS.toSeconds(contentPlayHeadMS) % TimeUnit.MINUTES.toSeconds(1),
+                contentPlayHeadMS % 1000);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
new file mode 100644
index 00000000..d2e16bc7
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
@@ -0,0 +1,177 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.common.CacheService;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+
+import static com.mopub.mobileads.VastVideoDownloadTask.VastVideoDownloadTaskListener;
+
+/**
+ * Given a VAST xml document, this class manages the lifecycle of parsing and finding a video and
+ * possibly companion ad. It provides the API for clients to prepare a
+ * {@link VastVideoConfig}.
+ */
+public class VastManager implements VastXmlManagerAggregator.VastXmlManagerAggregatorListener {
+    /**
+     * Users of this class should subscribe to this listener to get updates
+     * when a video is found or when no video is available.
+     */
+    public interface VastManagerListener {
+        /**
+         * Called when a video is found or if the VAST document is invalid. Passes in {@code null}
+         * when the VAST document is invalid.
+         *
+         * @param vastVideoConfig A configuration that can be used for displaying a VAST
+         *                               video or {@code null} if the VAST document is invalid.
+         */
+        void onVastVideoConfigurationPrepared(
+                @Nullable final VastVideoConfig vastVideoConfig);
+    }
+
+    @Nullable private VastManagerListener mVastManagerListener;
+    @Nullable private VastXmlManagerAggregator mVastXmlManagerAggregator;
+    private double mScreenAspectRatio;
+    private int mScreenAreaDp;
+
+    public VastManager(@NonNull final Context context) {
+        initializeScreenDimensions(context);
+    }
+
+    /**
+     * Creates and starts an async task that parses the VAST xml document.
+     *
+     * @param vastXml The initial VAST xml document
+     * @param vastManagerListener Notified when a video configuration has been found or when
+     *                            the VAST document is invalid
+     */
+    public void prepareVastVideoConfiguration(@Nullable final String vastXml,
+            @NonNull final VastManagerListener vastManagerListener,
+            @NonNull final Context context) {
+        Preconditions.checkNotNull(vastManagerListener, "vastManagerListener cannot be null");
+        Preconditions.checkNotNull(context, "context cannot be null");
+        if (mVastXmlManagerAggregator == null) {
+            mVastManagerListener = vastManagerListener;
+            mVastXmlManagerAggregator = new VastXmlManagerAggregator(this, mScreenAspectRatio,
+                    mScreenAreaDp, context.getApplicationContext());
+
+            try {
+                AsyncTasks.safeExecuteOnExecutor(mVastXmlManagerAggregator, vastXml);
+            } catch (Exception e) {
+                MoPubLog.d("Failed to aggregate vast xml", e);
+                mVastManagerListener.onVastVideoConfigurationPrepared(null);
+            }
+        }
+    }
+
+    /**
+     * Stops the VAST aggregator from continuing to follow wrapper redirects.
+     */
+    public void cancel() {
+        if (mVastXmlManagerAggregator != null) {
+            mVastXmlManagerAggregator.cancel(true);
+            mVastXmlManagerAggregator = null;
+        }
+    }
+
+    @Override
+    public void onAggregationComplete(@Nullable final VastVideoConfig vastVideoConfig) {
+        if (mVastManagerListener == null) {
+            throw new IllegalStateException(
+                    "mVastManagerListener cannot be null here. Did you call " +
+                            "prepareVastVideoConfiguration()?");
+        }
+        if (vastVideoConfig == null) {
+            mVastManagerListener.onVastVideoConfigurationPrepared(null);
+            return;
+        }
+
+        if (updateDiskMediaFileUrl(vastVideoConfig)) {
+            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfig);
+            return;
+        }
+
+        final VastVideoDownloadTask vastVideoDownloadTask = new VastVideoDownloadTask(
+                new VastVideoDownloadTaskListener() {
+                    @Override
+                    public void onComplete(boolean success) {
+                        if (success && updateDiskMediaFileUrl(vastVideoConfig)) {
+                            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfig);
+                        } else {
+                            mVastManagerListener.onVastVideoConfigurationPrepared(null);
+                        }
+                    }
+                }
+        );
+
+        try {
+            AsyncTasks.safeExecuteOnExecutor(
+                    vastVideoDownloadTask,
+                    vastVideoConfig.getNetworkMediaFileUrl()
+            );
+        } catch (Exception e) {
+            MoPubLog.d("Failed to download vast video", e);
+            mVastManagerListener.onVastVideoConfigurationPrepared(null);
+        }
+    }
+
+    /**
+     * This method takes the media file http url and checks to see if we have the media file downloaded
+     * and cached in the Disk LRU cache. If it is cached, then the {@link VastVideoConfig} is
+     * updated with the media file's url on disk.
+     *
+     * @param vastVideoConfig used to store the media file's disk url and web url
+     * @return true if the media file was already cached locally, otherwise false
+     */
+    private boolean updateDiskMediaFileUrl(
+            @NonNull final VastVideoConfig vastVideoConfig) {
+        Preconditions.checkNotNull(vastVideoConfig, "vastVideoConfig cannot be null");
+
+        final String networkMediaFileUrl = vastVideoConfig.getNetworkMediaFileUrl();
+        if (CacheService.containsKeyDiskCache(networkMediaFileUrl)) {
+            final String filePathDiskCache = CacheService.getFilePathDiskCache(networkMediaFileUrl);
+            vastVideoConfig.setDiskMediaFileUrl(filePathDiskCache);
+            return true;
+        }
+        return false;
+    }
+
+    private void initializeScreenDimensions(@NonNull final Context context) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        // This currently assumes that all vast videos will be played in landscape
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        final int xPx = display.getWidth();
+        final int yPx = display.getHeight();
+        // Use the screen density to convert x and y (in pixels) to DP. Also, check the density to
+        // make sure that this is a valid density and that this is not going to divide by 0.
+        float density = context.getResources().getDisplayMetrics().density;
+        if (density <= 0) {
+            density = 1;
+        }
+
+        // For landscape, width is always greater than height
+        int screenWidth = Math.max(xPx, yPx);
+        int screenHeight = Math.min(xPx, yPx);
+        mScreenAspectRatio = (double) screenWidth / screenHeight;
+        mScreenAreaDp = (int) ((screenWidth / density) * (screenHeight / density));
+    }
+
+    @VisibleForTesting
+    @Deprecated
+    int getScreenAreaDp() {
+        return mScreenAreaDp;
+    }
+
+    @VisibleForTesting
+    @Deprecated
+    double getScreenAspectRatio() {
+        return mScreenAspectRatio;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastMediaXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastMediaXmlManager.java
new file mode 100644
index 00000000..a86d500c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastMediaXmlManager.java
@@ -0,0 +1,83 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+/**
+ * This XML manager handles the actual video.
+ */
+class VastMediaXmlManager {
+
+    // Attribute names
+    private static final String WIDTH = "width";
+    private static final String HEIGHT = "height";
+    private static final String DELIVERY = "delivery";
+    private static final String VIDEO_TYPE  = "type";
+
+    @NonNull private final Node mMediaNode;
+
+    VastMediaXmlManager(@NonNull final Node mediaNode) {
+        Preconditions.checkNotNull(mediaNode, "mediaNode cannot be null");
+        mMediaNode = mediaNode;
+    }
+
+    /**
+     * 'progressive' for progressive download (e.g. HTTP) or 'streaming' for streaming protocols
+     * or {@code null} if not specified. MoPub expects to download the video. This is a required
+     * attribute.
+     *
+     * @return String of delivery type or {@code null}
+     */
+    @Nullable
+    String getDelivery() {
+        return XmlUtils.getAttributeValue(mMediaNode, DELIVERY);
+    }
+
+    /**
+     * Expected width of the video in pixels or {@code null} if not specified. This is a
+     * required attribute.
+     *
+     * @return Integer width of video or {@code null}
+     */
+    @Nullable
+    Integer getWidth() {
+        return XmlUtils.getAttributeValueAsInt(mMediaNode, WIDTH);
+    }
+
+    /**
+     * Expected height of the video in pixels or {@code null} if not specified. This is a
+     * required attribute.
+     *
+     * @return Integer height of video or {@code null}
+     */
+    @Nullable
+    Integer getHeight() {
+        return XmlUtils.getAttributeValueAsInt(mMediaNode, HEIGHT);
+    }
+
+    /**
+     * The MIME file type of the video or {@code null} if not specified. This is a required
+     * attribute. (e.g. 'video/x-flv' or 'video/mp4').
+     *
+     * @return The String type or {@code null}
+     */
+    @Nullable
+    String getType() {
+        return XmlUtils.getAttributeValue(mMediaNode, VIDEO_TYPE);
+    }
+
+    /**
+     * The URL of the video or {@code null} if not specified.
+     *
+     * @return String url of video or {@code null}
+     */
+    @Nullable
+    String getMediaUrl() {
+        return XmlUtils.getNodeValue(mMediaNode);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastResource.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastResource.java
new file mode 100644
index 00000000..41d387de
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastResource.java
@@ -0,0 +1,210 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * The data and its type used to populate a Vast 3.0 companion ad or icon.
+ */
+class VastResource implements Serializable {
+    private static final long serialVersionUID = 0L;
+
+    private static final List<String> VALID_IMAGE_TYPES =
+            Arrays.asList("image/jpeg", "image/png", "image/bmp", "image/gif");
+    private static final List<String> VALID_APPLICATION_TYPES =
+            Arrays.asList("application/x-javascript");
+
+    /**
+     * The type of resource ordered according to priority.
+     */
+    enum Type {
+        STATIC_RESOURCE,
+        HTML_RESOURCE,
+        IFRAME_RESOURCE
+    }
+
+    /**
+     * The type of the static resource. Only static resources only will have values other than NONE.
+     */
+    enum CreativeType {
+        NONE,
+        IMAGE,
+        JAVASCRIPT
+    }
+
+    @NonNull private String mResource;
+    @NonNull private Type mType;
+    @NonNull private CreativeType mCreativeType;
+    private int mWidth;
+    private int mHeight;
+
+    /**
+     * Helper method that tries to create a {@link VastResource} by accessing all resource types on
+     * the {@link VastResourceXmlManager} in order of priority defined by the {@link Type} enum.
+     *
+     * @param resourceXmlManager the manager used to populate the {@link VastResource}
+     * @param width              the expected width of the resource. This only affects IFrames.
+     * @param height             the expected height of the resource. This only affects IFrames.
+     * @return the newly created VastResource
+     */
+    @Nullable
+    static VastResource fromVastResourceXmlManager(
+            @NonNull final VastResourceXmlManager resourceXmlManager, final int width,
+            final int height) {
+        for (Type type : Type.values()) {
+            VastResource vastResource =
+                    fromVastResourceXmlManager(resourceXmlManager, type, width, height);
+            if (vastResource != null) {
+                return vastResource;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Tries to create a {@link VastResource} by accessing a specific resource {@link Type} on the
+     * {@link VastResourceXmlManager}.
+     *
+     * @param resourceXmlManager the manager used to populate the {@link VastResource}
+     * @param type the resource {@link Type} to try to access
+     * @param width the expected width of the resource. This only affects IFrames.
+     * @param height the expected height of the resource. This only affects IFrames.
+     * @return the newly created VastResource
+     */
+    @Nullable
+    static VastResource fromVastResourceXmlManager(
+            @NonNull final VastResourceXmlManager resourceXmlManager,
+            final @NonNull Type type, final int width, final int height) {
+        Preconditions.checkNotNull(resourceXmlManager);
+        Preconditions.checkNotNull(type);
+
+        String iFrameResource = resourceXmlManager.getIFrameResource();
+        String htmlResource = resourceXmlManager.getHTMLResource();
+        String staticResource = resourceXmlManager.getStaticResource();
+        String staticResourceType = resourceXmlManager.getStaticResourceType();
+
+        String resource;
+        CreativeType creativeType;
+
+        if (type == Type.STATIC_RESOURCE &&
+                staticResource != null && staticResourceType != null
+                && (VALID_IMAGE_TYPES.contains(staticResourceType)
+                || VALID_APPLICATION_TYPES.contains(staticResourceType))) {
+            resource = staticResource;
+            if (VALID_IMAGE_TYPES.contains(staticResourceType)) {
+                creativeType = CreativeType.IMAGE;
+            } else {
+                creativeType = CreativeType.JAVASCRIPT;
+            }
+        } else if (type == Type.HTML_RESOURCE && htmlResource != null) {
+            resource = htmlResource;
+            creativeType = CreativeType.NONE;
+        } else if (type == Type.IFRAME_RESOURCE && iFrameResource != null) {
+            resource = iFrameResource;
+            creativeType = CreativeType.NONE;
+        } else {
+            return null;
+        }
+
+        return new VastResource(resource, type, creativeType, width, height);
+    }
+
+    /**
+     * Private constructor. Use fromVastResourceXmlManager() to create a VastResource.
+     */
+    VastResource(@NonNull final String resource, @NonNull final Type type,
+            @NonNull final CreativeType creativeType, final int width, final int height) {
+        Preconditions.checkNotNull(resource);
+        Preconditions.checkNotNull(type);
+        Preconditions.checkNotNull(creativeType);
+
+        mResource = resource;
+        mType = type;
+        mCreativeType = creativeType;
+        mWidth = width;
+        mHeight = height;
+    }
+
+    @NonNull
+    public String getResource() {
+        return mResource;
+    }
+
+    @NonNull
+    public Type getType() {
+        return mType;
+    }
+
+    @NonNull
+    public CreativeType getCreativeType() {
+        return mCreativeType;
+    }
+
+    /**
+     * Initializes a WebView used to display the resource.
+     *
+     * @param webView the resource's WebView.
+     */
+    public void initializeWebView(@NonNull VastWebView webView) {
+        Preconditions.checkNotNull(webView);
+
+        if (mType == Type.IFRAME_RESOURCE) {
+            webView.loadData("<iframe frameborder=\"0\" scrolling=\"no\" marginheight=\"0\" " +
+                    "marginwidth=\"0\" style=\"border: 0px; margin: 0px;\" width=\"" + mWidth +
+                    "\" height=\"" + mHeight + "\" src=\"" + mResource + "\"></iframe>");
+        } else if (mType == Type.HTML_RESOURCE) {
+            webView.loadData(mResource);
+        } else if (mType == Type.STATIC_RESOURCE) {
+            if (mCreativeType == CreativeType.IMAGE) {
+                String data = "<html>" +
+                        "<head>" +
+                        "</head>" +
+                        // Set margin and padding to 0 in order to get rid of Android WebView
+                        // default padding
+                        "<body style=\"margin:0;padding:0\">" +
+                        "<img src=\"" + mResource + "\" width=\"100%\" style=\"max-width:100%;max-height:100%;\" />" +
+                        "</body>" +
+                        "</html>";
+                webView.loadData(data);
+            } else if (mCreativeType == CreativeType.JAVASCRIPT) {
+                String data = "<script src=\"" + mResource + "\"></script>";
+                webView.loadData(data);
+            }
+        }
+    }
+
+    /**
+     * Selects the correct click through url based on the type of resource.
+     *
+     * @param vastClickThroughUrl    The click through url as specified in the vast document. This
+     *                               is used with static images.
+     * @param webViewClickThroughUrl The click through url when pertaining to Javascript, HTML,
+     *                               IFrames that originated from a WebView.
+     * @return String representing the correct click through for the resource type which may be
+     * {@code null} if the correct click through url was not specified or {@code null}.
+     */
+    @Nullable
+    public String getCorrectClickThroughUrl(@Nullable final String vastClickThroughUrl,
+            @Nullable final String webViewClickThroughUrl) {
+        switch (mType) {
+            case STATIC_RESOURCE:
+                if (VastResource.CreativeType.IMAGE == mCreativeType) {
+                    return vastClickThroughUrl;
+                } else if (VastResource.CreativeType.JAVASCRIPT == mCreativeType) {
+                    return webViewClickThroughUrl;
+                }
+                return null;
+            case HTML_RESOURCE:
+            case IFRAME_RESOURCE:
+                return webViewClickThroughUrl;
+            default:
+                return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastResourceXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastResourceXmlManager.java
new file mode 100644
index 00000000..51db66d4
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastResourceXmlManager.java
@@ -0,0 +1,76 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+public class VastResourceXmlManager {
+
+    // Element names
+    public static final String STATIC_RESOURCE = "StaticResource";
+    public static final String IFRAME_RESOURCE = "IFrameResource";
+    public static final String HTML_RESOURCE = "HTMLResource";
+
+    // Attribute names
+    public static final String CREATIVE_TYPE = "creativeType";
+
+    @NonNull private final Node mResourceNode;
+
+    VastResourceXmlManager(@NonNull final Node resourceNode) {
+        Preconditions.checkNotNull(resourceNode);
+        mResourceNode = resourceNode;
+    }
+
+    /**
+     * If this node has a static resource, then this method returns the static resource data,
+     * if present. This returns {@code null} if this node does not have a static resource.
+     *
+     * @return The static resource data or {@code null}
+     */
+    @Nullable
+    String getStaticResource() {
+        return XmlUtils.getNodeValue(XmlUtils.getFirstMatchingChildNode(mResourceNode, STATIC_RESOURCE));
+    }
+
+    /**
+     * If this node has a static resource, then this method returns the type of the static resource.
+     * This returns {@code null} if this node does not have a static resource.
+     *
+     * @return The static resource type or {@code null}
+     */
+    @Nullable
+    String getStaticResourceType() {
+        Node staticResource = XmlUtils.getFirstMatchingChildNode(mResourceNode, STATIC_RESOURCE);
+        String attribute = XmlUtils.getAttributeValue(staticResource, CREATIVE_TYPE);
+        if (attribute != null) {
+            return attribute.toLowerCase();
+        }
+        return null;
+    }
+
+    /**
+     * If this node has an iframe resource, then this method returns the iframe resource data, if
+     * present. This returns {@code null} if this node does not have an iframe resource.
+     *
+     * @return The iframe resource data or {@code null}
+     */
+    @Nullable
+    String getIFrameResource() {
+        return XmlUtils.getNodeValue(XmlUtils.getFirstMatchingChildNode(mResourceNode, IFRAME_RESOURCE));
+    }
+
+    /**
+     * If this node has an HTML resource, then this method returns the HTML resource data, if
+     * present. This returns {@code null} if this node does not have an HTML resource.
+     *
+     * @return The HTML resource data or {@code null}
+     */
+    @Nullable
+    String getHTMLResource() {
+        return XmlUtils.getNodeValue(XmlUtils.getFirstMatchingChildNode(mResourceNode, HTML_RESOURCE));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
new file mode 100644
index 00000000..46019add
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
@@ -0,0 +1,45 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+
+/**
+ * State encapsulation for VAST tracking URLs that may or may not only be called once. For example,
+ * progress trackers are only called once, but error trackers are repeatable.
+ */
+public class VastTracker implements Serializable {
+    private static final long serialVersionUID = 0L;
+    @NonNull protected final String mTrackingUrl;
+    private boolean mCalled;
+    private boolean mIsRepeatable;
+
+    public VastTracker(@NonNull String trackingUrl) {
+        Preconditions.checkNotNull(trackingUrl);
+        mTrackingUrl = trackingUrl;
+    }
+
+    public VastTracker(@NonNull String trackingUrl, boolean isRepeatable) {
+        this(trackingUrl);
+        mIsRepeatable = isRepeatable;
+    }
+
+    @NonNull
+    public String getTrackingUrl() {
+        return mTrackingUrl;
+    }
+
+    public void setTracked() {
+        mCalled = true;
+    }
+
+    public boolean isTracked() {
+        return mCalled;
+    }
+
+    public boolean isRepeatable() {
+        return mIsRepeatable;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java
new file mode 100644
index 00000000..53e9c9ce
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java
@@ -0,0 +1,88 @@
+package com.mopub.mobileads;
+
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.widget.ImageView;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.ImageUtils;
+import com.mopub.mobileads.resource.DrawableConstants;
+
+public class VastVideoBlurLastVideoFrameTask extends AsyncTask<String, Void, Boolean> {
+    @NonNull private final MediaMetadataRetriever mMediaMetadataRetriever;
+    @NonNull private final ImageView mBlurredLastVideoFrameImageView;
+    private int mVideoDuration;
+    @Nullable private Bitmap mLastVideoFrame;
+    @Nullable private Bitmap mBlurredLastVideoFrame;
+
+    public VastVideoBlurLastVideoFrameTask(
+            @NonNull final MediaMetadataRetriever mediaMetadataRetriever,
+            @NonNull final ImageView blurredLastVideoFrameImageView, int videoDuration) {
+        mMediaMetadataRetriever = mediaMetadataRetriever;
+        mBlurredLastVideoFrameImageView = blurredLastVideoFrameImageView;
+        mVideoDuration = videoDuration;
+    }
+
+    @Override
+    protected Boolean doInBackground(String... videoPaths) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD_MR1) {
+            if (videoPaths == null || videoPaths.length == 0 || videoPaths[0] == null) {
+                return false;
+            }
+
+            try {
+                final String videoPath = videoPaths[0];
+
+                mMediaMetadataRetriever.setDataSource(videoPath);
+
+                mLastVideoFrame = mMediaMetadataRetriever.getFrameAtTime(
+                        mVideoDuration * 1000, MediaMetadataRetriever.OPTION_CLOSEST);
+
+                if (mLastVideoFrame == null) {
+                    return false;
+                }
+
+                mBlurredLastVideoFrame = ImageUtils.applyFastGaussianBlurToBitmap(
+                        mLastVideoFrame, 4);
+
+                return true;
+            } catch (Exception e) {
+                MoPubLog.d("Failed to blur last video frame", e);
+                return false;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    protected void onPostExecute(final Boolean success) {
+        if (isCancelled()) {
+            onCancelled();
+            return;
+        }
+
+        if (success != null && success) {
+            mBlurredLastVideoFrameImageView.setImageBitmap(mBlurredLastVideoFrame);
+            ImageUtils.setImageViewAlpha(mBlurredLastVideoFrameImageView,
+                    DrawableConstants.BlurredLastVideoFrame.ALPHA);
+        }
+    }
+
+    @Override
+    protected void onCancelled() {
+        MoPubLog.d("VastVideoBlurLastVideoFrameTask was cancelled.");
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    Bitmap getBlurredLastVideoFrame() {
+        return mBlurredLastVideoFrame;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCloseButtonWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCloseButtonWidget.java
new file mode 100644
index 00000000..a547b3a5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCloseButtonWidget.java
@@ -0,0 +1,149 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.mobileads.resource.DrawableConstants;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
+
+public class VastVideoCloseButtonWidget extends RelativeLayout {
+    @NonNull private TextView mTextView;
+    @NonNull private ImageView mImageView;
+    @NonNull private final ImageLoader mImageLoader;
+    @NonNull private CloseButtonDrawable mCloseButtonDrawable;
+
+    private final int mEdgePadding;
+    private final int mTextRightMargin;
+    private final int mImagePadding;
+    private final int mWidgetHeight;
+
+    public VastVideoCloseButtonWidget(@NonNull final Context context) {
+        super(context);
+
+        setId((int) Utils.generateUniqueId());
+
+        mEdgePadding = Dips.dipsToIntPixels(DrawableConstants.CloseButton.EDGE_PADDING, context);
+        mImagePadding = Dips.dipsToIntPixels(DrawableConstants.CloseButton.IMAGE_PADDING_DIPS, context);
+        mWidgetHeight = Dips.dipsToIntPixels(DrawableConstants.CloseButton.WIDGET_HEIGHT_DIPS, context);
+        mTextRightMargin = Dips.dipsToIntPixels(DrawableConstants.CloseButton.TEXT_RIGHT_MARGIN_DIPS, context);
+
+        mCloseButtonDrawable = new CloseButtonDrawable();
+        mImageLoader = Networking.getImageLoader(context);
+
+        createImageView();
+        createTextView();
+
+        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                WRAP_CONTENT,
+                mWidgetHeight);
+
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP | RelativeLayout.ALIGN_PARENT_RIGHT);
+        setLayoutParams(layoutParams);
+    }
+
+    private void createImageView() {
+        mImageView = new ImageView(getContext());
+        mImageView.setId((int) Utils.generateUniqueId());
+
+        final RelativeLayout.LayoutParams iconLayoutParams = new RelativeLayout.LayoutParams(
+                mWidgetHeight,
+                mWidgetHeight);
+
+        iconLayoutParams.addRule(ALIGN_PARENT_RIGHT);
+
+        mImageView.setImageDrawable(mCloseButtonDrawable);
+        mImageView.setPadding(mImagePadding, mImagePadding + mEdgePadding, mImagePadding + mEdgePadding, mImagePadding);
+        addView(mImageView, iconLayoutParams);
+    }
+
+    private void createTextView() {
+        mTextView = new TextView(getContext());
+        mTextView.setSingleLine();
+        mTextView.setEllipsize(TextUtils.TruncateAt.END);
+        mTextView.setTextColor(DrawableConstants.CloseButton.TEXT_COLOR);
+        mTextView.setTextSize(DrawableConstants.CloseButton.TEXT_SIZE_SP);
+        mTextView.setTypeface(DrawableConstants.CloseButton.TEXT_TYPEFACE);
+        mTextView.setText(DrawableConstants.CloseButton.DEFAULT_CLOSE_BUTTON_TEXT);
+
+        final RelativeLayout.LayoutParams textLayoutParams = new RelativeLayout.LayoutParams(
+                WRAP_CONTENT,
+                WRAP_CONTENT);
+
+        textLayoutParams.addRule(CENTER_VERTICAL);
+        textLayoutParams.addRule(LEFT_OF, mImageView.getId());
+
+        mTextView.setPadding(0, mEdgePadding, 0, 0);
+        // space between text and image
+        textLayoutParams.setMargins(0, 0, mTextRightMargin, 0);
+
+        addView(mTextView, textLayoutParams);
+    }
+
+    void updateCloseButtonText(@Nullable final String text) {
+        if (mTextView != null) {
+            mTextView.setText(text);
+        }
+    }
+
+    void updateCloseButtonIcon(@NonNull final String imageUrl) {
+        mImageLoader.get(imageUrl, new ImageLoader.ImageListener() {
+            @Override
+            public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                    final boolean isImmediate) {
+                Bitmap bitmap = imageContainer.getBitmap();
+                if (bitmap != null) {
+                    mImageView.setImageBitmap(bitmap);
+                } else {
+                    MoPubLog.d(String.format("%s returned null bitmap", imageUrl));
+                }
+            }
+
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to load image.", volleyError);
+            }
+        });
+    }
+
+    void setOnTouchListenerToContent(@Nullable View.OnTouchListener onTouchListener) {
+        mImageView.setOnTouchListener(onTouchListener);
+        mTextView.setOnTouchListener(onTouchListener);
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    ImageView getImageView() {
+        return mImageView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setImageView(ImageView imageView) {
+        mImageView = imageView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    TextView getTextView() {
+        return mTextView;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java
new file mode 100644
index 00000000..913f4bf3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java
@@ -0,0 +1,604 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Configuration;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Intents;
+import com.mopub.common.util.Strings;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
+
+public class VastVideoConfig implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    @NonNull private final ArrayList<VastTracker> mImpressionTrackers;
+    @NonNull private final ArrayList<VastFractionalProgressTracker> mFractionalTrackers;
+    @NonNull private final ArrayList<VastAbsoluteProgressTracker> mAbsoluteTrackers;
+    @NonNull private final ArrayList<VastTracker> mPauseTrackers;
+    @NonNull private final ArrayList<VastTracker> mResumeTrackers;
+    @NonNull private final ArrayList<VastTracker> mCompleteTrackers;
+    @NonNull private final ArrayList<VastTracker> mCloseTrackers;
+    @NonNull private final ArrayList<VastTracker> mSkipTrackers;
+    @NonNull private final ArrayList<VastTracker> mClickTrackers;
+    @NonNull private final ArrayList<VastTracker> mErrorTrackers;
+    @Nullable private String mClickThroughUrl;
+    @Nullable private String mNetworkMediaFileUrl;
+    @Nullable private String mDiskMediaFileUrl;
+    @Nullable private String mSkipOffset;
+    @Nullable private VastCompanionAdConfig mLandscapeVastCompanionAdConfig;
+    @Nullable private VastCompanionAdConfig mPortraitVastCompanionAdConfig;
+    @Nullable private VastIconConfig mVastIconConfig;
+
+    // Custom extensions
+    @Nullable private String mCustomCtaText;
+    @Nullable private String mCustomSkipText;
+    @Nullable private String mCustomCloseIconUrl;
+    @NonNull private DeviceUtils.ForceOrientation mCustomForceOrientation = DeviceUtils.ForceOrientation.FORCE_LANDSCAPE; // Default is forcing landscape
+
+    /**
+     * Flag to indicate if the VAST xml document has explicitly set the orientation as opposed to
+     * using the default.
+     */
+    private boolean mIsForceOrientationSet;
+
+    public VastVideoConfig() {
+        mImpressionTrackers = new ArrayList<VastTracker>();
+        mFractionalTrackers = new ArrayList<VastFractionalProgressTracker>();
+        mAbsoluteTrackers = new ArrayList<VastAbsoluteProgressTracker>();
+        mPauseTrackers = new ArrayList<VastTracker>();
+        mResumeTrackers = new ArrayList<VastTracker>();
+        mCompleteTrackers = new ArrayList<VastTracker>();
+        mCloseTrackers = new ArrayList<VastTracker>();
+        mSkipTrackers = new ArrayList<VastTracker>();
+        mClickTrackers = new ArrayList<VastTracker>();
+        mErrorTrackers = new ArrayList<VastTracker>();
+    }
+
+    /**
+     * Setters
+     */
+
+    public void addImpressionTrackers(@NonNull final List<VastTracker> impressionTrackers) {
+        Preconditions.checkNotNull(impressionTrackers, "impressionTrackers cannot be null");
+        mImpressionTrackers.addAll(impressionTrackers);
+    }
+
+    /**
+     * Add trackers for percentage-based tracking. This includes all quartile trackers and any
+     * "progress" events with other percentages.
+     */
+    public void addFractionalTrackers(@NonNull final List<VastFractionalProgressTracker> fractionalTrackers) {
+        Preconditions.checkNotNull(fractionalTrackers, "fractionalTrackers cannot be null");
+        mFractionalTrackers.addAll(fractionalTrackers);
+        Collections.sort(mFractionalTrackers);
+    }
+
+    /**
+     * Add trackers for absolute tracking. This includes start trackers, which have an absolute threshold of 2 seconds.
+     */
+    public void addAbsoluteTrackers(@NonNull final List<VastAbsoluteProgressTracker> absoluteTrackers) {
+        Preconditions.checkNotNull(absoluteTrackers, "absoluteTrackers cannot be null");
+        mAbsoluteTrackers.addAll(absoluteTrackers);
+        Collections.sort(mAbsoluteTrackers);
+    }
+
+    public void addCompleteTrackers(@NonNull final List<VastTracker> completeTrackers) {
+        Preconditions.checkNotNull(completeTrackers, "completeTrackers cannot be null");
+        mCompleteTrackers.addAll(completeTrackers);
+    }
+
+    /**
+     * Add trackers for when the video is paused.
+     *
+     * @param pauseTrackers List of String URLs to hit
+     */
+    public void addPauseTrackers(@NonNull List<VastTracker> pauseTrackers) {
+        Preconditions.checkNotNull(pauseTrackers, "pauseTrackers cannot be null");
+        mPauseTrackers.addAll(pauseTrackers);
+    }
+
+    /**
+     * Add trackers for when the video is resumed.
+     *
+     * @param resumeTrackers List of String URLs to hit
+     */
+    public void addResumeTrackers(@NonNull List<VastTracker> resumeTrackers) {
+        Preconditions.checkNotNull(resumeTrackers, "resumeTrackers cannot be null");
+        mResumeTrackers.addAll(resumeTrackers);
+    }
+
+    public void addCloseTrackers(@NonNull final List<VastTracker> closeTrackers) {
+        Preconditions.checkNotNull(closeTrackers, "closeTrackers cannot be null");
+        mCloseTrackers.addAll(closeTrackers);
+    }
+
+    public void addSkipTrackers(@NonNull final List<VastTracker> skipTrackers) {
+        Preconditions.checkNotNull(skipTrackers, "skipTrackers cannot be null");
+        mSkipTrackers.addAll(skipTrackers);
+    }
+
+    public void addClickTrackers(@NonNull final List<VastTracker> clickTrackers) {
+        Preconditions.checkNotNull(clickTrackers, "clickTrackers cannot be null");
+        mClickTrackers.addAll(clickTrackers);
+    }
+
+    /**
+     * Add trackers for errors.
+     *
+     * @param errorTrackers A URL to hit when an error happens.
+     */
+    public void addErrorTrackers(@NonNull final List<VastTracker> errorTrackers) {
+        Preconditions.checkNotNull(errorTrackers, "errorTrackers cannot be null");
+        mErrorTrackers.addAll(errorTrackers);
+    }
+
+    public void setClickThroughUrl(@Nullable final String clickThroughUrl) {
+        mClickThroughUrl = clickThroughUrl;
+    }
+
+    public void setNetworkMediaFileUrl(@Nullable final String networkMediaFileUrl) {
+        mNetworkMediaFileUrl = networkMediaFileUrl;
+    }
+
+    public void setDiskMediaFileUrl(@Nullable final String diskMediaFileUrl) {
+        mDiskMediaFileUrl = diskMediaFileUrl;
+    }
+
+    public void setVastCompanionAd(@Nullable final VastCompanionAdConfig landscapeVastCompanionAdConfig,
+            @Nullable final VastCompanionAdConfig portraitVastCompanionAdConfig) {
+        mLandscapeVastCompanionAdConfig = landscapeVastCompanionAdConfig;
+        mPortraitVastCompanionAdConfig = portraitVastCompanionAdConfig;
+    }
+
+    public void setVastIconConfig(@Nullable final VastIconConfig vastIconConfig) {
+        mVastIconConfig = vastIconConfig;
+    }
+
+    public void setCustomCtaText(@Nullable final String customCtaText) {
+        if (customCtaText != null) {
+            mCustomCtaText = customCtaText;
+        }
+    }
+
+    public void setCustomSkipText(@Nullable final String customSkipText) {
+        if (customSkipText != null) {
+            mCustomSkipText = customSkipText;
+        }
+    }
+
+    public void setCustomCloseIconUrl(@Nullable final String customCloseIconUrl) {
+        if (customCloseIconUrl != null) {
+            mCustomCloseIconUrl = customCloseIconUrl;
+        }
+    }
+
+    public void setCustomForceOrientation(@Nullable final DeviceUtils.ForceOrientation customForceOrientation) {
+        if (customForceOrientation != null && customForceOrientation != DeviceUtils.ForceOrientation.UNDEFINED) {
+            mCustomForceOrientation = customForceOrientation;
+            mIsForceOrientationSet = true;
+        }
+    }
+
+    public void setSkipOffset(@Nullable final String skipOffset) {
+        if (skipOffset != null) {
+            mSkipOffset = skipOffset;
+        }
+    }
+
+    /**
+     * Getters
+     */
+
+    @NonNull
+    public List<VastTracker> getImpressionTrackers() {
+        return mImpressionTrackers;
+    }
+
+    @NonNull
+    public ArrayList<VastAbsoluteProgressTracker> getAbsoluteTrackers() {
+        return mAbsoluteTrackers;
+    }
+
+    @NonNull
+    public ArrayList<VastFractionalProgressTracker> getFractionalTrackers() {
+        return mFractionalTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getPauseTrackers() {
+        return mPauseTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getResumeTrackers() {
+        return mResumeTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getCompleteTrackers() {
+        return mCompleteTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getCloseTrackers() {
+        return mCloseTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getSkipTrackers() {
+        return mSkipTrackers;
+    }
+
+    @NonNull
+    public List<VastTracker> getClickTrackers() {
+        return mClickTrackers;
+    }
+
+    /**
+     * Gets a list of error trackers.
+     *
+     * @return List of String URLs.
+     */
+    @NonNull
+    public List<VastTracker> getErrorTrackers() {
+        return mErrorTrackers;
+    }
+
+    @Nullable
+    public String getClickThroughUrl() {
+        return mClickThroughUrl;
+    }
+
+    @Nullable
+    public String getNetworkMediaFileUrl() {
+        return mNetworkMediaFileUrl;
+    }
+
+    @Nullable
+    public String getDiskMediaFileUrl() {
+        return mDiskMediaFileUrl;
+    }
+
+    @Nullable
+    public VastCompanionAdConfig getVastCompanionAd(final int orientation) {
+        switch (orientation) {
+            case Configuration.ORIENTATION_PORTRAIT:
+                return mPortraitVastCompanionAdConfig;
+            case Configuration.ORIENTATION_LANDSCAPE:
+                return mLandscapeVastCompanionAdConfig;
+            default:
+                return mLandscapeVastCompanionAdConfig;
+        }
+    }
+
+    @Nullable
+    public VastIconConfig getVastIconConfig() {
+        return mVastIconConfig;
+    }
+
+    @Nullable
+    public String getCustomCtaText() {
+        return mCustomCtaText;
+    }
+
+    @Nullable
+    public String getCustomSkipText() {
+        return mCustomSkipText;
+    }
+
+    @Nullable
+    public String getCustomCloseIconUrl() {
+        return mCustomCloseIconUrl;
+    }
+
+    public boolean isCustomForceOrientationSet() {
+        return mIsForceOrientationSet;
+    }
+
+    /**
+     * Returns whether or not there is a companion ad set. There must be both a landscape and a
+     * portrait companion ad set for this to be true.
+     *
+     * @return true if both the landscape and portrait companion ads are set, false otherwise.
+     */
+    public boolean hasCompanionAd() {
+        return mLandscapeVastCompanionAdConfig != null && mPortraitVastCompanionAdConfig != null;
+    }
+
+    /**
+     * Get custom force orientation
+     * @return ForceOrientation enum (default is FORCE_LANDSCAPE)
+     */
+    @NonNull
+    public DeviceUtils.ForceOrientation getCustomForceOrientation() {
+        return mCustomForceOrientation;
+    }
+
+    /**
+     * Gets the String specified in the VAST document regarding the skip offset. This should be in
+     * the form HH:MM:SS[.mmm] or n%. (e.g. 00:00:12, 00:00:12.345, 42%).
+     *
+     * @return String representation of the skip offset or {@code null} if not set.
+     */
+    @Nullable
+    public String getSkipOffsetString() {
+        return mSkipOffset;
+    }
+
+    /**
+     * Called when the video starts playing.
+     *
+     * @param context         The context. Can be application or activity context.
+     * @param contentPlayHead Current video playback time.
+     */
+    public void handleImpression(@NonNull final Context context, int contentPlayHead) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        makeVastTrackingHttpRequest(
+                mImpressionTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+    }
+
+    /**
+     * Called when the video is clicked. Handles forwarding the user to the specified click through
+     * url.
+     *
+     * @param activity        This has to be an activity to call startActivityForResult.
+     * @param contentPlayHead Current video playback time when clicked.
+     * @param requestCode     The code that identifies what kind of activity request is going to be
+     *                        made
+     */
+    public void handleClick(@NonNull final Activity activity, final int contentPlayHead,
+            final int requestCode) {
+        Preconditions.checkNotNull(activity, "activity cannot be null");
+
+        makeVastTrackingHttpRequest(
+                mClickTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                activity
+        );
+
+        if (TextUtils.isEmpty(mClickThroughUrl)) {
+            return;
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction == UrlAction.OPEN_IN_APP_BROWSER) {
+                            Bundle bundle = new Bundle();
+                            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
+
+                            final Class clazz = MoPubBrowser.class;
+                            final Intent intent = Intents.getStartActivityIntent(
+                                    activity, clazz, bundle);
+                            try {
+                                activity.startActivityForResult(intent, requestCode);
+                            } catch (ActivityNotFoundException e) {
+                                MoPubLog.d("Activity " + clazz.getName() + " not found. Did you " +
+                                        "declare it in your AndroidManifest.xml?");
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withoutMoPubBrowser()
+                .build().handleUrl(activity, mClickThroughUrl);
+    }
+
+    /**
+     * Called when the video is not finished and is resumed from the middle of the video.
+     *
+     * @param context         The context. Can be application or activity context.
+     * @param contentPlayHead Current video playback time.
+     */
+    public void handleResume(@NonNull final Context context, int contentPlayHead) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        makeVastTrackingHttpRequest(
+                mResumeTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+    }
+
+    /**
+     * Called when the video is not finished and is paused.
+     *
+     * @param context         The context. Can be application or activity context.
+     * @param contentPlayHead Current video playback time.
+     */
+    public void handlePause(@NonNull final Context context, int contentPlayHead) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        makeVastTrackingHttpRequest(
+                mPauseTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+    }
+
+    /**
+     * Called when the video is closed or skipped.
+     *
+     * @param context         The context. Can be application or activity context.
+     * @param contentPlayHead Current video playback time.
+     */
+    public void handleClose(@NonNull Context context, int contentPlayHead) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        makeVastTrackingHttpRequest(
+                mCloseTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+
+        makeVastTrackingHttpRequest(
+                mSkipTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+    }
+
+    /**
+     * Called when the video is played completely without skipping.
+     *
+     * @param context         The context. Can be application or activity context.
+     * @param contentPlayHead Current video playback time (should be duration of video).
+     */
+    public void handleComplete(@NonNull Context context, int contentPlayHead) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        makeVastTrackingHttpRequest(
+                mCompleteTrackers,
+                null,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+    }
+
+    /**
+     * Called when there is a problem with the video. Refer to the possible {@link VastErrorCode}s
+     * for a list of problems.
+     *
+     * @param context         The context. Can be application or activity context.
+     * @param contentPlayHead Current video playback time.
+     */
+    public void handleError(@NonNull Context context, @NonNull VastErrorCode errorCode,
+            int contentPlayHead) {
+        Preconditions.checkNotNull(context, "context cannot be null");
+        makeVastTrackingHttpRequest(
+                mErrorTrackers,
+                errorCode,
+                contentPlayHead,
+                mNetworkMediaFileUrl,
+                context
+        );
+    }
+
+    /**
+     * Returns untriggered VAST progress trackers with a progress before the provided position.
+     *
+     * @param currentPositionMillis the current video position in milliseconds.
+     * @param videoLengthMillis the total video length.
+     */
+    @NonNull
+    public List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
+        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
+            float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
+            List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
+
+            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
+            int absoluteTrackerCount = mAbsoluteTrackers.size();
+            for (int i = 0; i < absoluteTrackerCount; i++) {
+                VastAbsoluteProgressTracker tracker = mAbsoluteTrackers.get(i);
+                if (tracker.compareTo(absoluteTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
+
+            final VastFractionalProgressTracker fractionalTest = new VastFractionalProgressTracker("", progressFraction);
+            int fractionalTrackerCount = mFractionalTrackers.size();
+            for (int i = 0; i < fractionalTrackerCount; i++) {
+                VastFractionalProgressTracker tracker = mFractionalTrackers.get(i);
+                if (tracker.compareTo(fractionalTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
+
+            return untriggeredTrackers;
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    /**
+     * Returns the number of untriggered progress trackers.
+     *
+     * @return Integer count >= 0 of the remaining progress trackers.
+     */
+    public int getRemainingProgressTrackerCount() {
+        return getUntriggeredTrackersBefore(Integer.MAX_VALUE, Integer.MAX_VALUE).size();
+    }
+
+    /**
+     * Gets the skip offset in milliseconds. If the skip offset would be past the video duration,
+     * this returns null. If an error occurs, this returns null.
+     *
+     * @param videoDuration Used to calculate percentage based offsets.
+     * @return The skip offset in milliseconds. Can return null.
+     */
+    @Nullable
+    public Integer getSkipOffsetMillis(final int videoDuration) {
+        if (mSkipOffset != null) {
+            try {
+                if (Strings.isAbsoluteTracker(mSkipOffset)) {
+                    Integer skipOffsetMilliseconds = Strings.parseAbsoluteOffset(mSkipOffset);
+                    if (skipOffsetMilliseconds != null && skipOffsetMilliseconds < videoDuration) {
+                        return skipOffsetMilliseconds;
+                    }
+                } else if (Strings.isPercentageTracker(mSkipOffset)) {
+                    float percentage = Float.parseFloat(mSkipOffset.replace("%", "")) / 100f;
+                    int skipOffsetMillisecondsRounded = Math.round(videoDuration * percentage);
+                    if (skipOffsetMillisecondsRounded < videoDuration) {
+                        return skipOffsetMillisecondsRounded;
+                    }
+                } else {
+                    MoPubLog.d(
+                            String.format("Invalid VAST skipoffset format: %s", mSkipOffset));
+                }
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Failed to parse skipoffset %s", mSkipOffset));
+            }
+        }
+        return null;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java
new file mode 100644
index 00000000..0ca1a1ff
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java
@@ -0,0 +1,148 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.content.res.Configuration;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.resource.CtaButtonDrawable;
+import com.mopub.mobileads.resource.DrawableConstants;
+
+public class VastVideoCtaButtonWidget extends ImageView {
+    @NonNull private CtaButtonDrawable mCtaButtonDrawable;
+    @NonNull private final RelativeLayout.LayoutParams mLandscapeLayoutParams;
+    @NonNull private final RelativeLayout.LayoutParams mPortraitLayoutParams;
+
+    private boolean mIsVideoSkippable;
+    private boolean mIsVideoComplete;
+    private boolean mHasCompanionAd;
+    private boolean mHasClickthroughUrl;
+
+    public VastVideoCtaButtonWidget(@NonNull final Context context, final int videoViewId,
+            final boolean hasCompanionAd, final boolean hasClickthroughUrl) {
+        super(context);
+
+        mHasCompanionAd = hasCompanionAd;
+        mHasClickthroughUrl = hasClickthroughUrl;
+
+        setId((int) Utils.generateUniqueId());
+
+        final int width = Dips.dipsToIntPixels(DrawableConstants.CtaButton.WIDTH_DIPS, context);
+        final int height = Dips.dipsToIntPixels(DrawableConstants.CtaButton.HEIGHT_DIPS, context);
+        final int margin = Dips.dipsToIntPixels(DrawableConstants.CtaButton.MARGIN_DIPS, context);
+
+        mCtaButtonDrawable = new CtaButtonDrawable(context);
+        setImageDrawable(mCtaButtonDrawable);
+
+        // landscape layout: placed bottom-right corner of video view
+        mLandscapeLayoutParams = new RelativeLayout.LayoutParams(width, height);
+        mLandscapeLayoutParams.setMargins(margin, margin, margin, margin);
+        mLandscapeLayoutParams.addRule(RelativeLayout.ALIGN_BOTTOM, videoViewId);
+        mLandscapeLayoutParams.addRule(RelativeLayout.ALIGN_RIGHT, videoViewId);
+
+        // portrait layout: placed center below video view
+        mPortraitLayoutParams = new RelativeLayout.LayoutParams(width, height);
+        mPortraitLayoutParams.setMargins(margin, margin, margin, margin);
+        mPortraitLayoutParams.addRule(RelativeLayout.BELOW, videoViewId);
+        mPortraitLayoutParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
+
+        updateLayoutAndVisibility();
+    }
+
+    @Override
+    protected void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+
+        updateLayoutAndVisibility();
+    }
+
+    void updateCtaText(@NonNull final String customCtaText) {
+        mCtaButtonDrawable.setCtaText(customCtaText);
+    }
+
+    void notifyVideoSkippable() {
+        mIsVideoSkippable = true;
+        updateLayoutAndVisibility();
+    }
+
+    void notifyVideoComplete() {
+        mIsVideoSkippable = true;
+        mIsVideoComplete = true;
+        updateLayoutAndVisibility();
+    }
+
+    private void updateLayoutAndVisibility() {
+        // If the video does not have a clickthrough url, never show the CTA button
+        if (!mHasClickthroughUrl) {
+            setVisibility(View.GONE);
+            return;
+        }
+
+        // If video is not skippable yet, do not show CTA button
+        if (!mIsVideoSkippable) {
+            setVisibility(View.INVISIBLE);
+            return;
+        }
+
+        // If video has finished playing and there's a companion ad, do not show CTA button
+        if (mIsVideoComplete && mHasCompanionAd) {
+            setVisibility(View.GONE);
+            return;
+        }
+
+        final int currentOrientation = getResources().getConfiguration().orientation;
+
+        switch (currentOrientation) {
+            case Configuration.ORIENTATION_LANDSCAPE:
+                setVisibility(View.VISIBLE);
+                setLayoutParams(mLandscapeLayoutParams);
+                break;
+            case Configuration.ORIENTATION_PORTRAIT:
+                setVisibility(View.VISIBLE);
+                setLayoutParams(mPortraitLayoutParams);
+                break;
+            case Configuration.ORIENTATION_UNDEFINED:
+                MoPubLog.d("Screen orientation undefined: CTA button widget defaulting to portrait layout");
+                setVisibility(View.VISIBLE);
+                setLayoutParams(mPortraitLayoutParams);
+                break;
+            case Configuration.ORIENTATION_SQUARE:
+                MoPubLog.d("Screen orientation is deprecated ORIENTATION_SQUARE: CTA button widget defaulting to portrait layout");
+                setVisibility(View.VISIBLE);
+                setLayoutParams(mPortraitLayoutParams);
+                break;
+            default:
+                MoPubLog.d("Unrecognized screen orientation: CTA button widget defaulting to portrait layout");
+                setVisibility(View.VISIBLE);
+                setLayoutParams(mPortraitLayoutParams);
+                break;
+        }
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    String getCtaText() {
+        return mCtaButtonDrawable.getCtaText();
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean hasPortraitLayoutParams() {
+        return getLayoutParams().equals(mPortraitLayoutParams);
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean hasLandscapeLayoutParams() {
+        return getLayoutParams().equals(mLandscapeLayoutParams);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
index 778d7de1..910b59d2 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
@@ -29,7 +29,7 @@ public VastVideoDownloadTask(final VastVideoDownloadTaskListener listener) {
 
     @Override
     protected Boolean doInBackground(final String... params) {
-        if (params == null || params[0] == null) {
+        if (params == null || params.length == 0 || params[0] == null) {
             return false;
         }
 
@@ -37,7 +37,7 @@ protected Boolean doInBackground(final String... params) {
         AndroidHttpClient httpClient = null;
         try {
             httpClient = HttpClient.getHttpClient();
-            final HttpGet httpget = new HttpGet(videoUrl);
+            final HttpGet httpget = HttpClient.initializeHttpGet(videoUrl);
             final HttpResponse response = httpClient.execute(httpget);
 
             if (response == null || response.getEntity() == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoGradientStripWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoGradientStripWidget.java
new file mode 100644
index 00000000..bbc19b9b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoGradientStripWidget.java
@@ -0,0 +1,100 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.drawable.GradientDrawable;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
+import com.mopub.mobileads.resource.DrawableConstants;
+
+public class VastVideoGradientStripWidget extends ImageView {
+    @NonNull DeviceUtils.ForceOrientation mForceOrientation;
+    private int mVisibilityForCompanionAd;
+    private boolean mHasCompanionAd;
+    private boolean mIsVideoComplete;
+
+    public VastVideoGradientStripWidget(@NonNull final Context context,
+            @NonNull final GradientDrawable.Orientation gradientOrientation,
+            @NonNull final DeviceUtils.ForceOrientation forceOrientation,
+            final boolean hasCompanionAd, final int visibilityForCompanionAd, final int layoutVerb,
+            final int layoutAnchor) {
+        super(context);
+
+        mForceOrientation = forceOrientation;
+        mVisibilityForCompanionAd = visibilityForCompanionAd;
+        mHasCompanionAd = hasCompanionAd;
+
+        final GradientDrawable gradientDrawable = new GradientDrawable(gradientOrientation,
+                new int[] {DrawableConstants.GradientStrip.START_COLOR,
+                        DrawableConstants.GradientStrip.END_COLOR});
+        setImageDrawable(gradientDrawable);
+
+        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                RelativeLayout.LayoutParams.MATCH_PARENT,
+                Dips.dipsToIntPixels(DrawableConstants.GradientStrip.GRADIENT_STRIP_HEIGHT_DIPS,
+                        context));
+        layoutParams.addRule(layoutVerb, layoutAnchor);
+        setLayoutParams(layoutParams);
+
+        updateVisibility();
+    }
+
+    void notifyVideoComplete() {
+        mIsVideoComplete = true;
+        updateVisibility();
+    }
+
+    @Override
+    protected void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+
+        updateVisibility();
+    }
+
+    private void updateVisibility() {
+        if (mIsVideoComplete) {
+            if (mHasCompanionAd) {
+                setVisibility(mVisibilityForCompanionAd);
+            } else {
+                setVisibility(View.GONE);
+            }
+
+            return;
+        }
+
+        if (mForceOrientation == DeviceUtils.ForceOrientation.FORCE_PORTRAIT) {
+            setVisibility(View.INVISIBLE);
+        } else if (mForceOrientation == DeviceUtils.ForceOrientation.FORCE_LANDSCAPE) {
+            setVisibility(View.VISIBLE);
+        } else  {
+            final int currentOrientation = getResources().getConfiguration().orientation;
+
+            switch (currentOrientation) {
+                case Configuration.ORIENTATION_LANDSCAPE:
+                    setVisibility(View.VISIBLE);
+                    break;
+                case Configuration.ORIENTATION_PORTRAIT:
+                    setVisibility(View.INVISIBLE);
+                    break;
+                case Configuration.ORIENTATION_UNDEFINED:
+                    MoPubLog.d("Screen orientation undefined: do not show gradient strip widget");
+                    setVisibility(View.INVISIBLE);
+                    break;
+                case Configuration.ORIENTATION_SQUARE:
+                    MoPubLog.d("Screen orientation is deprecated ORIENTATION_SQUARE: do not show gradient strip widget");
+                    setVisibility(View.INVISIBLE);
+                    break;
+                default:
+                    MoPubLog.d("Unrecognized screen orientation: do not show gradient strip widget");
+                    setVisibility(View.INVISIBLE);
+                    break;
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
index b96d0f89..a3a14cd9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
@@ -1,11 +1,8 @@
 package com.mopub.mobileads;
 
-import android.net.Uri;
-
 import com.mopub.common.CacheService;
+import com.mopub.common.DataKeys;
 import com.mopub.mobileads.factories.VastManagerFactory;
-import com.mopub.mobileads.util.vast.VastManager;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
 
 import java.util.Map;
 
@@ -13,11 +10,11 @@
     private CustomEventInterstitialListener mCustomEventInterstitialListener;
     private String mVastResponse;
     private VastManager mVastManager;
-    private VastVideoConfiguration mVastVideoConfiguration;
+    private VastVideoConfig mVastVideoConfig;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
-        mVastResponse = Uri.decode(serverExtras.get(AdFetcher.HTML_RESPONSE_BODY_KEY));
+        mVastResponse = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
     }
 
     @Override
@@ -30,16 +27,16 @@ protected void preRenderHtml(CustomEventInterstitialListener customEventIntersti
         }
 
         mVastManager = VastManagerFactory.create(mContext);
-        mVastManager.prepareVastVideoConfiguration(mVastResponse, this);
+        mVastManager.prepareVastVideoConfiguration(mVastResponse, this, mContext);
     }
 
     @Override
-    protected void showInterstitial() {
-        MraidVideoPlayerActivity.startVast(mContext, mVastVideoConfiguration, mAdConfiguration);
+    public void showInterstitial() {
+        MraidVideoPlayerActivity.startVast(mContext, mVastVideoConfig, mBroadcastIdentifier);
     }
 
     @Override
-    protected void onInvalidate() {
+    public void onInvalidate() {
         if (mVastManager != null) {
             mVastManager.cancel();
         }
@@ -52,13 +49,13 @@ protected void onInvalidate() {
      */
 
     @Override
-    public void onVastVideoConfigurationPrepared(final VastVideoConfiguration vastVideoConfiguration) {
-        if (vastVideoConfiguration == null) {
+    public void onVastVideoConfigurationPrepared(final VastVideoConfig vastVideoConfig) {
+        if (vastVideoConfig == null) {
             mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.VIDEO_DOWNLOAD_ERROR);
             return;
         }
 
-        mVastVideoConfiguration = vastVideoConfiguration;
+        mVastVideoConfig = vastVideoConfig;
         mCustomEventInterstitialListener.onInterstitialLoaded();
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java
new file mode 100644
index 00000000..7f7eb5d3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java
@@ -0,0 +1,60 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.resource.DrawableConstants;
+import com.mopub.mobileads.resource.ProgressBarDrawable;
+
+public class VastVideoProgressBarWidget extends ImageView {
+    @NonNull private ProgressBarDrawable mProgressBarDrawable;
+
+    public VastVideoProgressBarWidget(@NonNull final Context context, final int anchorId) {
+        super(context);
+
+        setId((int) Utils.generateUniqueId());
+
+        mProgressBarDrawable = new ProgressBarDrawable(context);
+        setImageDrawable(mProgressBarDrawable);
+
+        final int progressBarHeight
+                = Dips.dipsToIntPixels(DrawableConstants.ProgressBar.HEIGHT_DIPS, context);
+
+        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                RelativeLayout.LayoutParams.MATCH_PARENT,
+                progressBarHeight);
+
+        layoutParams.addRule(RelativeLayout.ALIGN_BOTTOM, anchorId);
+
+        setLayoutParams(layoutParams);
+    }
+
+    void calibrateAndMakeVisible(final int duration, final int skipOffset) {
+        mProgressBarDrawable.setDurationAndSkipOffset(duration, skipOffset);
+        setVisibility(View.VISIBLE);
+    }
+
+    void updateProgress(final int progress) {
+        mProgressBarDrawable.setProgress(progress);
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    ProgressBarDrawable getImageViewDrawable() {
+        return mProgressBarDrawable;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setImageViewDrawable(@NonNull ProgressBarDrawable drawable) {
+        mProgressBarDrawable = drawable;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java
new file mode 100644
index 00000000..8fe0e8fd
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java
@@ -0,0 +1,78 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.resource.DrawableConstants;
+import com.mopub.mobileads.resource.RadialCountdownDrawable;
+
+public class VastVideoRadialCountdownWidget extends ImageView {
+    @NonNull private RadialCountdownDrawable mRadialCountdownDrawable;
+    private int mLastProgressMilliseconds;
+
+    public VastVideoRadialCountdownWidget(@NonNull final Context context) {
+        super(context);
+
+        setId((int) Utils.generateUniqueId());
+
+        final int sideLength = Dips.dipsToIntPixels(DrawableConstants.RadialCountdown.SIDE_LENGTH_DIPS, context);
+        final int topMargin = Dips.dipsToIntPixels(DrawableConstants.RadialCountdown.TOP_MARGIN_DIPS, context);
+        final int rightMargin = Dips.dipsToIntPixels(DrawableConstants.RadialCountdown.RIGHT_MARGIN_DIPS, context);
+        final int padding = Dips.dipsToIntPixels(DrawableConstants.RadialCountdown.PADDING_DIPS, context);
+
+        mRadialCountdownDrawable = new RadialCountdownDrawable(context);
+        setImageDrawable(mRadialCountdownDrawable);
+        setPadding(padding, padding, padding, padding);
+
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                sideLength,
+                sideLength);
+        layoutParams.setMargins(0, topMargin, rightMargin, 0);
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP | RelativeLayout.ALIGN_PARENT_RIGHT);
+        setLayoutParams(layoutParams);
+    }
+
+    void calibrateAndMakeVisible(final int initialCountdownMilliseconds) {
+        mRadialCountdownDrawable.setInitialCountdown(initialCountdownMilliseconds);
+        setVisibility(VISIBLE);
+    }
+
+    void updateCountdownProgress(final int initialCountdownMilliseconds, final int currentProgressMilliseconds) {
+        // There exists an Android video player bug where VideoView.getCurrentPosition()
+        // temporarily returns 0 right after backgrounding and switching back to the app.
+        // Therefore, we check against the last known current position to ensure that it's
+        // monotonically increasing.
+        if (currentProgressMilliseconds >= mLastProgressMilliseconds) {
+            int millisecondsUntilSkippable = initialCountdownMilliseconds - currentProgressMilliseconds;
+
+            // XXX
+            // After backgrounding and switching back to the app,
+            // this widget becomes erroneously visible.
+            if (millisecondsUntilSkippable < 0) {
+                setVisibility(GONE);
+            } else {
+                mRadialCountdownDrawable.updateCountdownProgress(currentProgressMilliseconds);
+                mLastProgressMilliseconds = currentProgressMilliseconds;
+            }
+        }
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    RadialCountdownDrawable getImageViewDrawable() {
+        return mRadialCountdownDrawable;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setImageViewDrawable(RadialCountdownDrawable drawable) {
+        mRadialCountdownDrawable = drawable;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
deleted file mode 100644
index 2d4431bf..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
+++ /dev/null
@@ -1,159 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.view.MotionEvent;
-import android.view.View;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.resource.CloseButtonDrawable;
-import com.mopub.mobileads.resource.CountdownDrawable;
-import com.mopub.mobileads.resource.LearnMoreDrawable;
-
-import static android.graphics.Color.BLACK;
-import static android.view.Gravity.CENTER_VERTICAL;
-import static android.view.Gravity.LEFT;
-import static android.view.Gravity.RIGHT;
-import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
-
-class VastVideoToolbar extends LinearLayout {
-    private static final int TOOLBAR_HEIGHT_DIPS = 44;
-    private static final int THRESHOLD_FOR_HIDING_VIDEO_DURATION = 200;
-
-    private final ToolbarWidget mDurationWidget;
-    private final ToolbarWidget mLearnMoreWidget;
-    private final ToolbarWidget mCountdownWidget;
-    private final ToolbarWidget mCloseButtonWidget;
-
-    public VastVideoToolbar(final Context context) {
-        super(context);
-
-        setId((int) Utils.generateUniqueId());
-
-        // Consume all click events on the video toolbar
-        setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                return true;
-            }
-        });
-
-        final int videoToolbarHeight = Dips.dipsToIntPixels(TOOLBAR_HEIGHT_DIPS, getContext());
-        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
-                FILL_PARENT,
-                videoToolbarHeight);
-        setLayoutParams(layoutParams);
-
-        setBackgroundColor(BLACK);
-        getBackground().setAlpha(180);
-
-        mDurationWidget = createDurationWidget();
-        mLearnMoreWidget = createLearnMoreWidget();
-        mCountdownWidget = createCountdownWidget();
-        mCloseButtonWidget = createCloseButtonWidget();
-
-        addView(mDurationWidget);
-        addView(mLearnMoreWidget);
-        addView(mCountdownWidget);
-        addView(mCloseButtonWidget);
-    }
-
-    String getDisplaySeconds(final long millisecondsRemaining) {
-        return String.valueOf(Math.round(Math.ceil(millisecondsRemaining / 1000f)));
-    }
-
-    void updateDurationWidget(final int remainingTime) {
-        if (remainingTime >= THRESHOLD_FOR_HIDING_VIDEO_DURATION) {
-            mDurationWidget.updateText("Ends in " + getDisplaySeconds(remainingTime) + " seconds");
-        } else if (remainingTime >= 0) {
-            mDurationWidget.updateText("Thanks for watching");
-        }
-    }
-
-    void updateCountdownWidget(final int remainingTime) {
-        if (remainingTime >= 0 && mCountdownWidget.getVisibility() == View.INVISIBLE) {
-            mCloseButtonWidget.setVisibility(View.GONE);
-            mCountdownWidget.setVisibility(View.VISIBLE);
-        }
-
-        mCountdownWidget.updateImageText(getDisplaySeconds(remainingTime));
-    }
-
-    void makeInteractable() {
-        // The countdown timer has ended and user can interact with close and learn more button
-        mCountdownWidget.setVisibility(View.GONE);
-        mLearnMoreWidget.setVisibility(View.VISIBLE);
-        mCloseButtonWidget.setVisibility(View.VISIBLE);
-    }
-
-    void setCloseButtonOnTouchListener(final OnTouchListener onTouchListener) {
-        mCloseButtonWidget.setOnTouchListener(onTouchListener);
-    }
-
-    void setLearnMoreButtonOnTouchListener(final OnTouchListener onTouchListener) {
-        mLearnMoreWidget.setOnTouchListener(onTouchListener);
-    }
-
-    private ToolbarWidget createDurationWidget() {
-        return new ToolbarWidget.Builder(getContext())
-                .weight(2f)
-                .widgetGravity(CENTER_VERTICAL | LEFT)
-                .hasText()
-                .textAlign(RelativeLayout.ALIGN_PARENT_LEFT)
-                .build();
-    }
-
-    private ToolbarWidget createLearnMoreWidget() {
-        return new ToolbarWidget.Builder(getContext())
-                .weight(1f)
-                .widgetGravity(CENTER_VERTICAL | RIGHT)
-                .defaultText("Learn More")
-                .drawable(new LearnMoreDrawable())
-                .visibility(View.INVISIBLE)
-                .build();
-    }
-
-    private ToolbarWidget createCountdownWidget() {
-        final CountdownDrawable countdownDrawable = new CountdownDrawable(getContext());
-
-        return new ToolbarWidget.Builder(getContext())
-                .weight(1f)
-                .widgetGravity(CENTER_VERTICAL | RIGHT)
-                .defaultText("Skip in")
-                .drawable(countdownDrawable)
-                .visibility(View.INVISIBLE)
-                .build();
-    }
-
-    private ToolbarWidget createCloseButtonWidget() {
-        return new ToolbarWidget.Builder(getContext())
-                .weight(1f)
-                .widgetGravity(CENTER_VERTICAL | RIGHT)
-                .defaultText("Close")
-                .drawable(new CloseButtonDrawable())
-                .visibility(View.GONE)
-                .build();
-    }
-
-    @Deprecated // for testing
-    ToolbarWidget getDurationWidget() {
-        return mDurationWidget;
-    }
-
-    @Deprecated // for testing
-    ToolbarWidget getLearnMoreWidget() {
-        return mLearnMoreWidget;
-    }
-
-    @Deprecated // for testing
-    ToolbarWidget getCountdownWidget() {
-        return mCountdownWidget;
-    }
-
-    @Deprecated // for testing
-    ToolbarWidget getCloseButtonWidget() {
-        return mCloseButtonWidget;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java
new file mode 100644
index 00000000..32904efb
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java
@@ -0,0 +1,162 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.media.MediaMetadataRetriever;
+import android.media.MediaPlayer;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.widget.ImageView;
+import android.widget.VideoView;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Streams;
+
+import java.io.File;
+import java.io.FileInputStream;
+
+/**
+ * Custom VideoView dedicated for VAST videos. This primarily deals with the blurring of the last
+ * frame when there's no companion ad and retrying the video.
+ */
+public class VastVideoView extends VideoView {
+
+    private static final int MAX_VIDEO_RETRIES = 1;
+    private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
+
+    @Nullable private VastVideoBlurLastVideoFrameTask mBlurLastVideoFrameTask;
+    @Nullable private MediaMetadataRetriever mMediaMetadataRetriever;
+    private int mVideoRetries;
+
+    public VastVideoView(@NonNull final Context context) {
+        super(context);
+        Preconditions.checkNotNull(context, "context cannot be null");
+        mMediaMetadataRetriever = createMediaMetadataRetriever();
+    }
+
+    /**
+     * Launches an async task to blur the last frame of the video. If the API of the device is not
+     * high enough, this does nothing.
+     *
+     * @param blurredLastVideoFrameImageView The view will get populated with the image when the
+     *                                       async task is finished.
+     */
+    public void prepareBlurredLastVideoFrame(
+            @NonNull final ImageView blurredLastVideoFrameImageView,
+            @NonNull final String diskMediaFileUrl) {
+        if (mMediaMetadataRetriever != null) {
+            mBlurLastVideoFrameTask = new VastVideoBlurLastVideoFrameTask(mMediaMetadataRetriever,
+                    blurredLastVideoFrameImageView, getDuration());
+
+            try {
+                AsyncTasks.safeExecuteOnExecutor(
+                        mBlurLastVideoFrameTask,
+                        diskMediaFileUrl
+                );
+            } catch (Exception e) {
+                MoPubLog.d("Failed to blur last video frame", e);
+            }
+        }
+    }
+
+    /**
+     * Called when the activity enclosing this view is destroyed. We do not want to continue this
+     * task when the activity expecting the result no longer exists.
+     */
+    public void onDestroy() {
+        if (mBlurLastVideoFrameTask != null &&
+                mBlurLastVideoFrameTask.getStatus() != AsyncTask.Status.FINISHED) {
+            mBlurLastVideoFrameTask.cancel(true);
+        }
+    }
+
+    boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra,
+            @NonNull final String diskMediaFileUrl) {
+        // XXX
+        // VideoView has a bug in versions lower than Jelly Bean, Api Level 16, Android 4.1
+        // For api < 16, VideoView is not able to read files written to disk since it reads them in
+        // a Context different from the Application and therefore does not have correct permission.
+        // To solve this problem we obtain the video file descriptor ourselves with valid permissions
+        // and pass it to the underlying MediaPlayer in VideoView.
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN
+                && what == MediaPlayer.MEDIA_ERROR_UNKNOWN
+                && extra == VIDEO_VIEW_FILE_PERMISSION_ERROR
+                && mVideoRetries < MAX_VIDEO_RETRIES) {
+
+            FileInputStream inputStream = null;
+            try {
+                mediaPlayer.reset();
+                final File file = new File(diskMediaFileUrl);
+                inputStream = new FileInputStream(file);
+                mediaPlayer.setDataSource(inputStream.getFD());
+
+                // XXX
+                // VideoView has a callback registered with the MediaPlayer to set a flag when the
+                // media file has been prepared. Start also sets a flag in VideoView indicating the
+                // desired state is to play the video. Therefore, whichever method finishes last
+                // will check both flags and begin playing the video.
+                mediaPlayer.prepareAsync();
+                start();
+                return true;
+            } catch (Exception e) {
+                return false;
+            } finally {
+                Streams.closeStream(inputStream);
+                mVideoRetries++;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Called when the activity enclosing this view is resumed.
+     */
+    public void onResume() {
+        // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
+        // and therefore reset the count to zero, to let it retry on error
+        mVideoRetries = 0;
+    }
+
+    @VisibleForTesting
+    @Nullable
+    MediaMetadataRetriever createMediaMetadataRetriever() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD_MR1) {
+            return new MediaMetadataRetriever();
+        }
+
+        return null;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setMediaMetadataRetriever(@NonNull MediaMetadataRetriever mediaMetadataRetriever) {
+        mMediaMetadataRetriever = mediaMetadataRetriever;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    @Nullable
+    VastVideoBlurLastVideoFrameTask getBlurLastVideoFrameTask() {
+        return mBlurLastVideoFrameTask;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setBlurLastVideoFrameTask(@NonNull VastVideoBlurLastVideoFrameTask blurLastVideoFrameTask) {
+        mBlurLastVideoFrameTask = blurLastVideoFrameTask;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    int getVideoRetries() {
+        return mVideoRetries;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index c73582b5..77f9cece 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -3,313 +3,331 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Bitmap;
+import android.content.res.Configuration;
 import android.graphics.Color;
-import android.graphics.drawable.Drawable;
 import android.graphics.drawable.GradientDrawable;
-import android.graphics.drawable.LayerDrawable;
 import android.media.MediaPlayer;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.View;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
 import android.widget.ImageView;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.Dips;
-import com.mopub.common.util.Drawables;
-import com.mopub.common.util.Streams;
-import com.mopub.common.util.VersionCode;
-import com.mopub.mobileads.util.vast.VastCompanionAd;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-
-import java.io.*;
-import java.util.*;
-import java.util.concurrent.*;
+import com.mopub.common.util.Utils;
+
+import java.io.Serializable;
 
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-import static com.mopub.common.HttpClient.initializeHttpGet;
-import static com.mopub.common.HttpClient.makeTrackingHttpRequest;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
 
-public class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {
-    static final String VAST_VIDEO_CONFIGURATION = "vast_video_configuration";
+public class VastVideoViewController extends BaseVideoViewController {
+    static final String VAST_VIDEO_CONFIG = "vast_video_config";
+    static final String CURRENT_POSITION = "current_position";
+    static final String RESUMED_VAST_CONFIG = "resumed_vast_config";
 
-    private static final float FIRST_QUARTER_MARKER = 0.25f;
-    private static final float MID_POINT_MARKER = 0.50f;
-    private static final float THIRD_QUARTER_MARKER = 0.75f;
     private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
+    private static final long VIDEO_COUNTDOWN_UPDATE_INTERVAL = 250;
     private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
-    private static final int MAX_VIDEO_RETRIES = 1;
-    private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
+    private static final int SEEKER_POSITION_NOT_INITIALIZED = -1;
+
+    /**
+     * Android WebViews supposedly have padding on each side of 10 dp. However, through empirical
+     * testing, the number is actually closer to 8 dp. Increasing the width and height of the
+     * WebView by this many dp will make the images inside not get cut off. This also prevents the
+     * image from being scrollable.
+     */
+    public static final int WEBVIEW_PADDING = 16;
 
-    private static final ThreadPoolExecutor sThreadPoolExecutor = new ThreadPoolExecutor(10, 50, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
     static final int DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON = 5 * 1000;
     static final int MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON = 16 * 1000;
 
-    private final VastVideoConfiguration mVastVideoConfiguration;
-    private final VastCompanionAd mVastCompanionAd;
-    private final VastVideoToolbar mVastVideoToolbar;
-    private final VideoView mVideoView;
-    private final ImageView mCompanionAdImageView;
-    private final View.OnTouchListener mClickThroughListener;
+    private final VastVideoConfig mVastVideoConfig;
 
-    private final Handler mHandler;
-    private final Runnable mVideoProgressCheckerRunnable;
-    private boolean mIsVideoProgressShouldBeChecked;
-    private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
+    @NonNull private final VastVideoView mVideoView;
+    @NonNull private VastVideoGradientStripWidget mTopGradientStripWidget;
+    @NonNull private VastVideoGradientStripWidget mBottomGradientStripWidget;
+    @NonNull private ImageView mBlurredLastVideoFrameImageView;
 
+    @NonNull private VastVideoProgressBarWidget mProgressBarWidget;
+    @NonNull private VastVideoRadialCountdownWidget mRadialCountdownWidget;
+    @NonNull private VastVideoCtaButtonWidget mCtaButtonWidget;
+    @NonNull private VastVideoCloseButtonWidget mCloseButtonWidget;
+
+    @Nullable private VastCompanionAdConfig mVastCompanionAdConfig;
+    @NonNull private final View mLandscapeCompanionAdView;
+    @NonNull private final View mPortraitCompanionAdView;
+    @Nullable private final VastIconConfig mVastIconConfig;
+    @NonNull private final View mIconView;
+
+    @NonNull private final VastVideoViewProgressRunnable mProgressCheckerRunnable;
+    @NonNull private final VastVideoViewCountdownRunnable mCountdownRunnable;
+    @NonNull private final View.OnTouchListener mClickThroughListener;
+
+    private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
     private boolean mShowCloseButtonEventFired;
-    private boolean mIsStartMarkHit;
-    private boolean mIsFirstMarkHit;
-    private boolean mIsSecondMarkHit;
-    private boolean mIsThirdMarkHit;
     private int mSeekerPositionOnPause;
     private boolean mIsVideoFinishedPlaying;
-    private int mVideoRetries;
-
-    VastVideoViewController(final Context context,
-            final Bundle bundle,
+    private boolean mVideoError;
+    private boolean mHasSkipOffset = false;
+    private boolean mIsCalibrationDone = false;
+    private int mDuration;
+
+    /**
+     * For when the video is closing.
+     */
+    private boolean mIsClosing = false;
+
+    VastVideoViewController(final Activity activity,
+            final Bundle intentExtras,
+            @Nullable final Bundle savedInstanceState,
             final long broadcastIdentifier,
             final BaseVideoViewControllerListener baseVideoViewControllerListener)
             throws IllegalStateException {
-        super(context, broadcastIdentifier, baseVideoViewControllerListener);
-        mHandler = new Handler();
-        mIsVideoProgressShouldBeChecked = false;
-        mSeekerPositionOnPause = -1;
-        mVideoRetries = 0;
-
-        Serializable serializable = bundle.getSerializable(VAST_VIDEO_CONFIGURATION);
-        if (serializable != null && serializable instanceof VastVideoConfiguration) {
-            mVastVideoConfiguration = (VastVideoConfiguration) serializable;
+        super(activity, broadcastIdentifier, baseVideoViewControllerListener);
+        mSeekerPositionOnPause = SEEKER_POSITION_NOT_INITIALIZED;
+
+        Serializable resumedVastConfiguration = null;
+        if (savedInstanceState != null) {
+            resumedVastConfiguration =
+                    savedInstanceState.getSerializable(RESUMED_VAST_CONFIG);
+        }
+        Serializable serializable = intentExtras.getSerializable(VAST_VIDEO_CONFIG);
+        if (resumedVastConfiguration != null
+                && resumedVastConfiguration instanceof VastVideoConfig) {
+            mVastVideoConfig = (VastVideoConfig) resumedVastConfiguration;
+            mSeekerPositionOnPause =
+                    savedInstanceState.getInt(CURRENT_POSITION, SEEKER_POSITION_NOT_INITIALIZED);
+        } else if (serializable != null && serializable instanceof VastVideoConfig) {
+            mVastVideoConfig = (VastVideoConfig) serializable;
         } else {
-            throw new IllegalStateException("VastVideoConfiguration is invalid");
+            throw new IllegalStateException("VastVideoConfig is invalid");
         }
 
-        if (mVastVideoConfiguration.getDiskMediaFileUrl() == null) {
-            throw new IllegalStateException("VastVideoConfiguration does not have a video disk path");
+        if (mVastVideoConfig.getDiskMediaFileUrl() == null) {
+            throw new IllegalStateException("VastVideoConfig does not have a video disk path");
         }
 
-        mVastCompanionAd = mVastVideoConfiguration.getVastCompanionAd();
+        mVastCompanionAdConfig = mVastVideoConfig.getVastCompanionAd(
+                activity.getResources().getConfiguration().orientation);
+        mVastIconConfig = mVastVideoConfig.getVastIconConfig();
 
         mClickThroughListener = new View.OnTouchListener() {
             @Override
             public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_UP && shouldAllowClickThrough()) {
-                    handleClick(
-                            mVastVideoConfiguration.getClickTrackers(),
-                            mVastVideoConfiguration.getClickThroughUrl()
-                    );
+                    mIsClosing = true;
+                    broadcastAction(ACTION_INTERSTITIAL_CLICK);
+                    mVastVideoConfig.handleClick(activity,
+                            mIsVideoFinishedPlaying ? mDuration : getCurrentPosition(),
+                            MOPUB_BROWSER_REQUEST_CODE);
                 }
                 return true;
             }
         };
 
-        createVideoBackground(context);
+        // Add widgets in the following order.
+        // Ordering matters because some placements are relative to other widgets.
+
+        // Solid black background
+        getLayout().setBackgroundColor(Color.BLACK);
 
-        mVideoView = createVideoView(context);
+        // Video view
+        mVideoView = createVideoView(activity, View.VISIBLE);
         mVideoView.requestFocus();
 
-        mVastVideoToolbar = createVastVideoToolBar(context);
-        getLayout().addView(mVastVideoToolbar);
+        // Companion ad view, set to invisible initially to have it be drawn to calculate size
+        mLandscapeCompanionAdView = createCompanionAdView(activity,
+                mVastVideoConfig.getVastCompanionAd(Configuration.ORIENTATION_LANDSCAPE),
+                View.INVISIBLE);
+        mPortraitCompanionAdView = createCompanionAdView(activity,
+                mVastVideoConfig.getVastCompanionAd(Configuration.ORIENTATION_PORTRAIT),
+                View.INVISIBLE);
+
+        // Top transparent gradient strip overlaying top of screen
+        addTopGradientStripWidget(activity);
+
+        // Progress bar overlaying bottom of video view
+        addProgressBarWidget(activity, View.INVISIBLE);
+
+        // Bottom transparent gradient strip above progress bar
+        addBottomGradientStripWidget(activity);
 
-        mCompanionAdImageView = createCompanionAdImageView(context);
+        // Radial countdown timer snapped to top-right corner of screen
+        addRadialCountdownWidget(activity, View.INVISIBLE);
 
-        makeTrackingHttpRequest(mVastVideoConfiguration.getImpressionTrackers(), context);
+        // Icon view
+        mIconView = createIconView(activity, mVastIconConfig, View.INVISIBLE);
 
-        mVideoProgressCheckerRunnable = createVideoProgressCheckerRunnable();
+        // Blurred last frame
+        addBlurredLastVideoFrameImageView(activity, View.INVISIBLE);
+
+        // CTA button
+        addCtaButtonWidget(activity);
+
+        // Close button snapped to top-right corner of screen
+        // Always add last to layout since it must be visible above all other views
+        addCloseButtonWidget(activity, View.GONE);
+
+        Handler mainHandler = new Handler(Looper.getMainLooper());
+        mProgressCheckerRunnable = new VastVideoViewProgressRunnable(this, mVastVideoConfig,
+                mainHandler);
+        mCountdownRunnable = new VastVideoViewCountdownRunnable(this, mainHandler);
     }
 
     @Override
-    VideoView getVideoView() {
+    protected VideoView getVideoView() {
         return mVideoView;
     }
 
     @Override
-    void onCreate() {
+    protected void onCreate() {
         super.onCreate();
-        getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
 
-        broadcastAction(ACTION_INTERSTITIAL_SHOW);
+        switch (mVastVideoConfig.getCustomForceOrientation()) {
+            case FORCE_PORTRAIT:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+                break;
+            case FORCE_LANDSCAPE:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+                break;
+            case DEVICE_ORIENTATION:
+                break;  // don't do anything
+            case UNDEFINED:
+                break;  // don't do anything
+            default:
+                break;
+        }
 
-        downloadCompanionAd();
+        mVastVideoConfig.handleImpression(getContext(), getCurrentPosition());
+        broadcastAction(ACTION_INTERSTITIAL_SHOW);
     }
 
     @Override
-    void onResume() {
-        // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
-        // and therefore reset the count to zero, to let it retry on error
-        mVideoRetries = 0;
-        startProgressChecker();
+    protected void onResume() {
+        startRunnables();
 
-        mVideoView.seekTo(mSeekerPositionOnPause);
+        if (mSeekerPositionOnPause > 0) {
+            mVideoView.seekTo(mSeekerPositionOnPause);
+        }
         if (!mIsVideoFinishedPlaying) {
             mVideoView.start();
         }
+        if (mSeekerPositionOnPause != SEEKER_POSITION_NOT_INITIALIZED) {
+            mVastVideoConfig.handleResume(getContext(), mSeekerPositionOnPause);
+        }
     }
 
     @Override
-    void onPause() {
-        stopProgressChecker();
-        mSeekerPositionOnPause = mVideoView.getCurrentPosition();
+    protected void onPause() {
+        stopRunnables();
+        mSeekerPositionOnPause = getCurrentPosition();
         mVideoView.pause();
+        if (!mIsVideoFinishedPlaying && !mIsClosing) {
+            mVastVideoConfig.handlePause(getContext(), mSeekerPositionOnPause);
+        }
     }
 
     @Override
-    void onDestroy() {
-        stopProgressChecker();
+    protected void onDestroy() {
+        stopRunnables();
         broadcastAction(ACTION_INTERSTITIAL_DISMISS);
+
+        mVideoView.onDestroy();
     }
 
-    // Enable the device's back button when the video close button has been displayed
     @Override
-    boolean backButtonEnabled() {
-        return mShowCloseButtonEventFired;
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        outState.putInt(CURRENT_POSITION, mSeekerPositionOnPause);
+        outState.putSerializable(RESUMED_VAST_CONFIG, mVastVideoConfig);
     }
 
     @Override
-    void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
-        if (requestCode == MOPUB_BROWSER_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
-            getBaseVideoViewControllerListener().onFinish();
+    protected void onConfigurationChanged(@Nullable final Configuration newConfig) {
+        final int orientation = getContext().getResources().getConfiguration().orientation;
+        mVastCompanionAdConfig = mVastVideoConfig.getVastCompanionAd(orientation);
+        if (mLandscapeCompanionAdView.getVisibility() == View.VISIBLE ||
+                mPortraitCompanionAdView.getVisibility() == View.VISIBLE) {
+            if (orientation == Configuration.ORIENTATION_PORTRAIT) {
+                mLandscapeCompanionAdView.setVisibility(View.INVISIBLE);
+                mPortraitCompanionAdView.setVisibility(View.VISIBLE);
+            } else {
+                mPortraitCompanionAdView.setVisibility(View.INVISIBLE);
+                mLandscapeCompanionAdView.setVisibility(View.VISIBLE);
+            }
+            if (mVastCompanionAdConfig != null) {
+                mVastCompanionAdConfig.handleImpression(getContext(), mDuration);
+            }
         }
     }
 
-    // DownloadTaskListener
+    // Enable the device's back button when the video close button has been displayed
     @Override
-    public void onComplete(String url, DownloadResponse downloadResponse) {
-        if (downloadResponse != null && downloadResponse.getStatusCode() == HttpStatus.SC_OK) {
-            final Bitmap companionAdBitmap = HttpResponses.asBitmap(downloadResponse);
-            if (companionAdBitmap != null) {
-                // If Bitmap fits in ImageView, then don't use MATCH_PARENT
-                final int width = Dips.dipsToIntPixels(companionAdBitmap.getWidth(), getContext());
-                final int height = Dips.dipsToIntPixels(companionAdBitmap.getHeight(), getContext());
-                final int imageViewWidth = mCompanionAdImageView.getMeasuredWidth();
-                final int imageViewHeight = mCompanionAdImageView.getMeasuredHeight();
-                if (width < imageViewWidth && height < imageViewHeight) {
-                    mCompanionAdImageView.getLayoutParams().width = width;
-                    mCompanionAdImageView.getLayoutParams().height = height;
-                }
-                mCompanionAdImageView.setImageBitmap(companionAdBitmap);
-                mCompanionAdImageView.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        if (mVastCompanionAd != null) {
-                            handleClick(
-                                    mVastCompanionAd.getClickTrackers(),
-                                    mVastCompanionAd.getClickThroughUrl()
-                            );
-                        }
-                    }
-                });
-            }
-        }
+    public boolean backButtonEnabled() {
+        return mShowCloseButtonEventFired;
     }
 
-    private void downloadCompanionAd() {
-        if (mVastCompanionAd != null) {
-            try {
-                final HttpGet httpGet = initializeHttpGet(mVastCompanionAd.getImageUrl(), getContext());
-                final DownloadTask downloadTask = new DownloadTask(this);
-                AsyncTasks.safeExecuteOnExecutor(downloadTask, httpGet);
-            } catch (Exception e) {
-                MoPubLog.d("Failed to download companion ad", e);
-            }
+    @Override
+    void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
+        if (requestCode == MOPUB_BROWSER_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
+            getBaseVideoViewControllerListener().onFinish();
         }
     }
 
-    private Runnable createVideoProgressCheckerRunnable() {
-        return new Runnable() {
-            @Override
-            public void run() {
-                float videoLength = mVideoView.getDuration();
-                float currentPosition = mVideoView.getCurrentPosition();
-
-                if (videoLength > 0) {
-                    float progressPercentage = currentPosition / videoLength;
-
-                    if (!mIsStartMarkHit && currentPosition >= 1000) {
-                        mIsStartMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getStartTrackers(), getContext());
-                    }
-
-                    if (!mIsFirstMarkHit && progressPercentage > FIRST_QUARTER_MARKER) {
-                        mIsFirstMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getFirstQuartileTrackers(), getContext());
-                    }
-
-                    if (!mIsSecondMarkHit && progressPercentage > MID_POINT_MARKER) {
-                        mIsSecondMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getMidpointTrackers(), getContext());
-                    }
-
-                    if (!mIsThirdMarkHit && progressPercentage > THIRD_QUARTER_MARKER) {
-                        mIsThirdMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getThirdQuartileTrackers(), getContext());
-                    }
-
-                    if (isLongVideo(mVideoView.getDuration()) ) {
-                        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - mVideoView.getCurrentPosition());
-                    }
-
-                    if (shouldBeInteractable()) {
-                        makeVideoInteractable();
-                    }
-                }
+    private void adjustSkipOffset() {
+        int videoDuration = getDuration();
 
-                mVastVideoToolbar.updateDurationWidget(mVideoView.getDuration() - mVideoView.getCurrentPosition());
+        // Default behavior: video is non-skippable if duration < 16 seconds
+        if (videoDuration < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
+            mShowCloseButtonDelay = videoDuration;
+        }
 
-                if (mIsVideoProgressShouldBeChecked) {
-                    mHandler.postDelayed(mVideoProgressCheckerRunnable, VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
-                }
-            }
-        };
+        // Override if skipoffset attribute is specified in VAST
+        final Integer skipOffsetMillis = mVastVideoConfig.getSkipOffsetMillis(videoDuration);
+        if (skipOffsetMillis != null) {
+            mShowCloseButtonDelay = skipOffsetMillis;
+            mHasSkipOffset = true;
+        }
     }
 
-    private void createVideoBackground(final Context context) {
-        GradientDrawable gradientDrawable = new GradientDrawable(
-                GradientDrawable.Orientation.TOP_BOTTOM,
-                new int[] {Color.argb(0,0,0,0), Color.argb(255,0,0,0)}
-        );
-        Drawable[] layers = new Drawable[2];
-        layers[0] = Drawables.THATCHED_BACKGROUND.decodeImage(context);
-        layers[1] = gradientDrawable;
-        LayerDrawable layerList = new LayerDrawable(layers);
-        getLayout().setBackgroundDrawable(layerList);
-    }
+    private VastVideoView createVideoView(@NonNull final Context context, int initialVisibility) {
+        if (mVastVideoConfig.getDiskMediaFileUrl() == null) {
+            throw new IllegalStateException("VastVideoConfig does not have a video disk path");
+        }
+        final VastVideoView videoView = new VastVideoView(context);
 
-    private VastVideoToolbar createVastVideoToolBar(final Context context) {
-        final VastVideoToolbar vastVideoToolbar = new VastVideoToolbar(context);
-        vastVideoToolbar.setCloseButtonOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
-                    getBaseVideoViewControllerListener().onFinish();
-                }
-                return true;
-            }
-        });
-        vastVideoToolbar.setLearnMoreButtonOnTouchListener(mClickThroughListener);
-        return vastVideoToolbar;
-    }
+        videoView.setId((int) Utils.generateUniqueId());
 
-    private VideoView createVideoView(final Context context) {
-        final VideoView videoView = new VideoView(context);
         videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
             @Override
             public void onPrepared(MediaPlayer mp) {
-                if (mVideoView.getDuration() < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
-                    mShowCloseButtonDelay = mVideoView.getDuration();
+                // Called when media source is ready for playback
+                // The VideoView duration defaults to -1 when the video is not prepared or playing;
+                // Therefore set it here so that we have access to it at all times
+                mDuration = mVideoView.getDuration();
+                adjustSkipOffset();
+                if (mVastCompanionAdConfig == null) {
+                    videoView.prepareBlurredLastVideoFrame(mBlurredLastVideoFrameImageView,
+                            mVastVideoConfig.getDiskMediaFileUrl());
                 }
+                mProgressBarWidget.calibrateAndMakeVisible(getDuration(), mShowCloseButtonDelay);
+                mRadialCountdownWidget.calibrateAndMakeVisible(mShowCloseButtonDelay);
+                mIsCalibrationDone = true;
             }
         });
         videoView.setOnTouchListener(mClickThroughListener);
@@ -317,18 +335,39 @@ public void onPrepared(MediaPlayer mp) {
         videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
             @Override
             public void onCompletion(MediaPlayer mp) {
-                stopProgressChecker();
+                stopRunnables();
                 makeVideoInteractable();
 
                 videoCompleted(false);
-
-                makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
                 mIsVideoFinishedPlaying = true;
 
-                videoView.setVisibility(View.GONE);
-                // check the drawable to see if the image view was populated with content
-                if (mCompanionAdImageView.getDrawable() != null) {
-                    mCompanionAdImageView.setVisibility(View.VISIBLE);
+                // Only fire the completion tracker if we hit all the progress marks. Some Android implementations
+                // fire the completion event even if the whole video isn't watched.
+                if (!mVideoError && mVastVideoConfig.getRemainingProgressTrackerCount() == 0) {
+                    mVastVideoConfig.handleComplete(getContext(), getCurrentPosition());
+                }
+
+                videoView.setVisibility(View.INVISIBLE);
+
+                mProgressBarWidget.setVisibility(View.GONE);
+                mIconView.setVisibility(View.GONE);
+
+                mTopGradientStripWidget.notifyVideoComplete();
+                mBottomGradientStripWidget.notifyVideoComplete();
+                mCtaButtonWidget.notifyVideoComplete();
+
+                // Show companion ad if available
+                if (mVastCompanionAdConfig != null) {
+                    final int orientation = context.getResources().getConfiguration().orientation;
+                    if (orientation == Configuration.ORIENTATION_PORTRAIT) {
+                        mPortraitCompanionAdView.setVisibility(View.VISIBLE);
+                    } else {
+                        mLandscapeCompanionAdView.setVisibility(View.VISIBLE);
+                    }
+                    mVastCompanionAdConfig.handleImpression(context, mDuration);
+                } else if (mBlurredLastVideoFrameImageView.getDrawable() != null) {
+                    // If there is no companion ad, show blurred last video frame with dark overlay
+                    mBlurredLastVideoFrameImageView.setVisibility(View.VISIBLE);
                 }
             }
         });
@@ -336,170 +375,498 @@ public void onCompletion(MediaPlayer mp) {
         videoView.setOnErrorListener(new MediaPlayer.OnErrorListener() {
             @Override
             public boolean onError(final MediaPlayer mediaPlayer, final int what, final int extra) {
-                if (retryMediaPlayer(mediaPlayer, what, extra)) {
+                if (videoView.retryMediaPlayer(mediaPlayer, what, extra,
+                        mVastVideoConfig.getDiskMediaFileUrl())) {
                     return true;
                 } else {
-                    stopProgressChecker();
+                    stopRunnables();
                     makeVideoInteractable();
                     videoError(false);
+                    mVideoError = true;
+
+                    mVastVideoConfig.handleError(getContext(),
+                            VastErrorCode.GENERAL_LINEAR_AD_ERROR, getCurrentPosition());
+
                     return false;
                 }
             }
         });
 
-        videoView.setVideoPath(mVastVideoConfiguration.getDiskMediaFileUrl());
+        videoView.setVideoPath(mVastVideoConfig.getDiskMediaFileUrl());
+        videoView.setVisibility(initialVisibility);
 
         return videoView;
     }
 
-    boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra) {
-        // XXX
-        // VideoView has a bug in versions lower than Jelly Bean, Api Level 16, Android 4.1
-        // For api < 16, VideoView is not able to read files written to disk since it reads them in
-        // a Context different from the Application and therefore does not have correct permission.
-        // To solve this problem we obtain the video file descriptor ourselves with valid permissions
-        // and pass it to the underlying MediaPlayer in VideoView.
-        if (VersionCode.currentApiLevel().isBelow(VersionCode.JELLY_BEAN)
-                && what == MediaPlayer.MEDIA_ERROR_UNKNOWN
-                && extra == VIDEO_VIEW_FILE_PERMISSION_ERROR
-                && mVideoRetries < MAX_VIDEO_RETRIES) {
-
-            FileInputStream inputStream = null;
-            try {
-                mediaPlayer.reset();
-                final File file = new File(mVastVideoConfiguration.getDiskMediaFileUrl());
-                inputStream = new FileInputStream(file);
-                mediaPlayer.setDataSource(inputStream.getFD());
-
-                // XXX
-                // VideoView has a callback registered with the MediaPlayer to set a flag when the
-                // media file has been prepared. Start also sets a flag in VideoView indicating the
-                // desired state is to play the video. Therefore, whichever method finishes last
-                // will check both flags and begin playing the video.
-                mediaPlayer.prepareAsync();
-                mVideoView.start();
+    private void addTopGradientStripWidget(@NonNull final Context context) {
+        boolean hasCompanionAd = (mVastCompanionAdConfig != null);
+
+        mTopGradientStripWidget = new VastVideoGradientStripWidget(context,
+                GradientDrawable.Orientation.TOP_BOTTOM,
+                mVastVideoConfig.getCustomForceOrientation(),
+                hasCompanionAd,
+                View.VISIBLE,
+                RelativeLayout.ALIGN_TOP,
+                getLayout().getId());
+        getLayout().addView(mTopGradientStripWidget);
+    }
+
+    private void addBottomGradientStripWidget(@NonNull final Context context) {
+        boolean hasCompanionAd = (mVastCompanionAdConfig != null);
+
+        mBottomGradientStripWidget = new VastVideoGradientStripWidget(context,
+                GradientDrawable.Orientation.BOTTOM_TOP,
+                mVastVideoConfig.getCustomForceOrientation(),
+                hasCompanionAd,
+                View.GONE,
+                RelativeLayout.ABOVE,
+                mProgressBarWidget.getId());
+        getLayout().addView(mBottomGradientStripWidget);
+    }
+
+    private void addProgressBarWidget(@NonNull final Context context, int initialVisibility) {
+        mProgressBarWidget = new VastVideoProgressBarWidget(context, mVideoView.getId());
+        mProgressBarWidget.setVisibility(initialVisibility);
+        getLayout().addView(mProgressBarWidget);
+    }
+
+    private void addRadialCountdownWidget(@NonNull final Context context, int initialVisibility) {
+        mRadialCountdownWidget = new VastVideoRadialCountdownWidget(context);
+        mRadialCountdownWidget.setVisibility(initialVisibility);
+        getLayout().addView(mRadialCountdownWidget);
+    }
+
+    private void addCtaButtonWidget(@NonNull final Context context) {
+        boolean hasCompanionAd = (mVastCompanionAdConfig != null);
+        boolean hasClickthroughUrl = !TextUtils.isEmpty(
+                mVastVideoConfig.getClickThroughUrl());
+
+        mCtaButtonWidget = new VastVideoCtaButtonWidget(context, mVideoView.getId(), hasCompanionAd,
+                hasClickthroughUrl);
+
+        getLayout().addView(mCtaButtonWidget);
+
+        mCtaButtonWidget.setOnTouchListener(mClickThroughListener);
+
+        // Update custom CTA text if specified in VAST extension
+        String customCtaText = mVastVideoConfig.getCustomCtaText();
+        if (customCtaText != null) {
+            mCtaButtonWidget.updateCtaText(customCtaText);
+        }
+    }
+
+    private void addCloseButtonWidget(@NonNull final Context context, int initialVisibility) {
+        mCloseButtonWidget = new VastVideoCloseButtonWidget(context);
+        mCloseButtonWidget.setVisibility(initialVisibility);
+
+        getLayout().addView(mCloseButtonWidget);
+
+        final View.OnTouchListener closeOnTouchListener = new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View view, MotionEvent motionEvent) {
+                final int currentPosition;
+                if (mIsVideoFinishedPlaying) {
+                    currentPosition = mDuration;
+                } else {
+                    currentPosition = getCurrentPosition();
+                }
+                if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+                    mIsClosing = true;
+                    mVastVideoConfig.handleClose(getContext(), currentPosition);
+                    getBaseVideoViewControllerListener().onFinish();
+                }
                 return true;
-            } catch (Exception e) {
-                return false;
-            } finally {
-                Streams.closeStream(inputStream);
-                mVideoRetries++;
             }
+        };
+
+        mCloseButtonWidget.setOnTouchListenerToContent(closeOnTouchListener);
+
+        // Update custom skip text if specified in VAST extensions
+        final String customSkipText = mVastVideoConfig.getCustomSkipText();
+        if (customSkipText != null) {
+            mCloseButtonWidget.updateCloseButtonText(customSkipText);
+        }
+
+        // Update custom close icon if specified in VAST extensions
+        final String customCloseIconUrl = mVastVideoConfig.getCustomCloseIconUrl();
+        if (customCloseIconUrl != null) {
+            mCloseButtonWidget.updateCloseButtonIcon(customCloseIconUrl);
         }
-        return false;
     }
 
-    private ImageView createCompanionAdImageView(final Context context) {
+    private void addBlurredLastVideoFrameImageView(@NonNull final Context context,
+            int initialVisibility) {
+
+        mBlurredLastVideoFrameImageView = new ImageView(context);
+        mBlurredLastVideoFrameImageView.setVisibility(initialVisibility);
+
+        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
+
+        getLayout().addView(mBlurredLastVideoFrameImageView, layoutParams);
+    }
+
+    /**
+     * Creates and lays out the webview used to display the companion ad.
+     *
+     * @param context         The context.
+     * @param vastCompanionAdConfig The data used to populate the view.
+     * @return the populated webview
+     */
+    @NonNull
+    @VisibleForTesting
+    View createCompanionAdView(@NonNull final Context context,
+            @Nullable final VastCompanionAdConfig vastCompanionAdConfig,
+            int initialVisibility) {
+        Preconditions.checkNotNull(context);
+
+        if (vastCompanionAdConfig == null) {
+            final View emptyView = new View(context);
+            emptyView.setVisibility(View.INVISIBLE);
+            return emptyView;
+        }
+
         RelativeLayout relativeLayout = new RelativeLayout(context);
         relativeLayout.setGravity(Gravity.CENTER);
         RelativeLayout.LayoutParams layoutParams =
                 new RelativeLayout.LayoutParams(
                         RelativeLayout.LayoutParams.MATCH_PARENT,
                         RelativeLayout.LayoutParams.MATCH_PARENT);
-        layoutParams.addRule(RelativeLayout.BELOW, mVastVideoToolbar.getId());
         getLayout().addView(relativeLayout, layoutParams);
 
-        ImageView imageView = new ImageView(context);
-        // Set to invisible to have it be drawn to calculate size
-        imageView.setVisibility(View.INVISIBLE);
+        VastWebView companionView = VastWebView.createView(context,
+                vastCompanionAdConfig.getVastResource());
+
+        // For javascript, HTML, and IFrames, ignore the traditional clickthrough url and open all
+        // new urls in the MoPub Browser. For static images, use the clickthrough url specified in
+        // the VAST document. These two handleClicks make it so that the correct behavior happens
+        // in these special cases. onVastWebViewClick is called in both circumstances to fire the
+        // click trackers.
+        companionView.setVastWebViewClickListener(new VastWebView.VastWebViewClickListener() {
+            @Override
+            public void onVastWebViewClick() {
+                broadcastAction(ACTION_INTERSTITIAL_CLICK);
+                makeVastTrackingHttpRequest(
+                        vastCompanionAdConfig.getClickTrackers(),
+                        null,
+                        mDuration,
+                        null,
+                        context
+                );
+                vastCompanionAdConfig.handleClick(context, MOPUB_BROWSER_REQUEST_CODE, null);
+            }
+        });
+        companionView.setWebViewClient(new WebViewClient() {
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                vastCompanionAdConfig.handleClick(context, MOPUB_BROWSER_REQUEST_CODE, url);
+                return true;
+            }
+        });
+
+        companionView.setVisibility(initialVisibility);
 
         final RelativeLayout.LayoutParams companionAdLayout = new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.MATCH_PARENT,
-                RelativeLayout.LayoutParams.MATCH_PARENT
+                Dips.dipsToIntPixels(vastCompanionAdConfig.getWidth() + WEBVIEW_PADDING, context),
+                Dips.dipsToIntPixels(vastCompanionAdConfig.getHeight() + WEBVIEW_PADDING, context)
         );
+        companionAdLayout.addRule(RelativeLayout.CENTER_IN_PARENT, RelativeLayout.TRUE);
 
-        relativeLayout.addView(imageView, companionAdLayout);
-        return imageView;
+        relativeLayout.addView(companionView, companionAdLayout);
+        return companionView;
     }
 
-    private void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
-        makeTrackingHttpRequest(clickThroughTrackers, getContext());
+    /**
+     * Creates and lays out the webview used to display the icon.
+     *
+     * @param context the context.
+     * @param vastIconConfig the data used to populate the view.
+     * @return the populated webview.
+     */
+    @NonNull
+    @VisibleForTesting
+    View createIconView(@NonNull final Context context, @Nullable final VastIconConfig vastIconConfig, int initialVisibility) {
+        Preconditions.checkNotNull(context);
+
+        if (vastIconConfig == null) {
+            return new View(context);
+        }
+
+        VastWebView iconView = VastWebView.createView(context, vastIconConfig.getVastResource());
+        iconView.setVastWebViewClickListener(new VastWebView.VastWebViewClickListener() {
+            @Override
+            public void onVastWebViewClick() {
+                makeVastTrackingHttpRequest(
+                        vastIconConfig.getClickTrackingUris(),
+                        null,
+                        getCurrentPosition(),
+                        getNetworkMediaFileUrl(),
+                        context
+                );
+                vastIconConfig.handleClick(getContext(), null);
+            }
+        });
+        iconView.setWebViewClient(new WebViewClient() {
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                vastIconConfig.handleClick(getContext(), url);
+                return true;
+            }
+        });
+        iconView.setVisibility(initialVisibility);
+
+        // Add extra room for the WebView to account for the natural padding in Android WebViews.
+        RelativeLayout.LayoutParams layoutParams =
+                new RelativeLayout.LayoutParams(
+                        Dips.asIntPixels(vastIconConfig.getWidth() + WEBVIEW_PADDING, context),
+                        Dips.asIntPixels(vastIconConfig.getHeight() + WEBVIEW_PADDING, context));
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
 
-        videoClicked();
+        getLayout().addView(iconView, layoutParams);
 
-        Bundle bundle = new Bundle();
-        bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+        return iconView;
+    }
 
-        getBaseVideoViewControllerListener().onStartActivityForResult(MoPubBrowser.class,
-                MOPUB_BROWSER_REQUEST_CODE, bundle);
+    int getDuration() {
+        return mVideoView.getDuration();
     }
 
-    private boolean isLongVideo(final int duration) {
-        return (duration >= MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+    int getCurrentPosition() {
+        return mVideoView.getCurrentPosition();
     }
 
-    private void makeVideoInteractable() {
+    void makeVideoInteractable() {
         mShowCloseButtonEventFired = true;
-        mVastVideoToolbar.makeInteractable();
+
+        mRadialCountdownWidget.setVisibility(View.GONE);
+        mCloseButtonWidget.setVisibility(View.VISIBLE);
+
+        mCtaButtonWidget.notifyVideoSkippable();
     }
 
-    private boolean shouldBeInteractable() {
-        return !mShowCloseButtonEventFired && mVideoView.getCurrentPosition() > mShowCloseButtonDelay;
+    boolean shouldBeInteractable() {
+        return !mShowCloseButtonEventFired && getCurrentPosition() >= mShowCloseButtonDelay;
     }
 
-    private boolean shouldAllowClickThrough() {
-        return mShowCloseButtonEventFired;
+    void updateCountdown() {
+        if (mIsCalibrationDone) {
+            mRadialCountdownWidget.updateCountdownProgress(mShowCloseButtonDelay, getCurrentPosition());
+        }
+    }
+
+    void updateProgressBar() {
+        mProgressBarWidget.updateProgress(getCurrentPosition());
     }
 
-    private void startProgressChecker() {
-        if (!mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = true;
-            mHandler.post(mVideoProgressCheckerRunnable);
+    String getNetworkMediaFileUrl() {
+        if (mVastVideoConfig == null) {
+            return null;
         }
+        return mVastVideoConfig.getNetworkMediaFileUrl();
     }
 
-    private void stopProgressChecker() {
-        if (mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = false;
-            mHandler.removeCallbacks(mVideoProgressCheckerRunnable);
+    /**
+     * Displays and impresses the icon if the current position of the video is greater than the
+     * offset of the icon. Once the current position is greater than the offset plus duration, the
+     * icon is then hidden again.
+     *
+     * @param currentPosition the current position of the video in milliseconds.
+     */
+    void handleIconDisplay(int currentPosition) {
+        if (mVastIconConfig == null || currentPosition < mVastIconConfig.getOffsetMS()) {
+            return;
+        }
+
+        mIconView.setVisibility(View.VISIBLE);
+        mVastIconConfig.handleImpression(getContext(), currentPosition, getNetworkMediaFileUrl());
+
+        if (mVastIconConfig.getDurationMS() == null) {
+            return;
+        }
+
+        if (currentPosition >= mVastIconConfig.getOffsetMS() + mVastIconConfig.getDurationMS()) {
+            mIconView.setVisibility(View.GONE);
         }
     }
 
+    private boolean shouldAllowClickThrough() {
+        return mShowCloseButtonEventFired;
+    }
+
+    private void startRunnables() {
+        mProgressCheckerRunnable.startRepeating(VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
+        mCountdownRunnable.startRepeating(VIDEO_COUNTDOWN_UPDATE_INTERVAL);
+    }
+
+    private void stopRunnables() {
+        mProgressCheckerRunnable.stop();
+        mCountdownRunnable.stop();
+    }
+
     // for testing
     @Deprecated
-    boolean getIsVideoProgressShouldBeChecked() {
-        return mIsVideoProgressShouldBeChecked;
+    @VisibleForTesting
+    VastVideoViewProgressRunnable getProgressCheckerRunnable() {
+        return mProgressCheckerRunnable;
     }
 
-    // for testing
     @Deprecated
-    int getVideoRetries() {
-        return mVideoRetries;
+    @VisibleForTesting
+    VastVideoViewCountdownRunnable getCountdownRunnable() {
+        return mCountdownRunnable;
     }
 
     // for testing
     @Deprecated
-    Runnable getVideoProgressCheckerRunnable() {
-        return mVideoProgressCheckerRunnable;
+    @VisibleForTesting
+    boolean getHasSkipOffset() {
+        return mHasSkipOffset;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     int getShowCloseButtonDelay() {
         return mShowCloseButtonDelay;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean isShowCloseButtonEventFired() {
         return mShowCloseButtonEventFired;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     void setCloseButtonVisible(boolean visible) {
         mShowCloseButtonEventFired = visible;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean isVideoFinishedPlaying() {
         return mIsVideoFinishedPlaying;
     }
 
     // for testing
     @Deprecated
-    ImageView getCompanionAdImageView() {
-        return mCompanionAdImageView;
+    @VisibleForTesting
+    boolean isCalibrationDone() {
+        return mIsCalibrationDone;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    View getLandscapeCompanionAdView() {
+        return mLandscapeCompanionAdView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    View getPortraitCompanionAdView() {
+        return mPortraitCompanionAdView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean getVideoError() {
+        return mVideoError;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setVideoError() {
+        mVideoError = true;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    View getIconView() {
+        return mIconView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoGradientStripWidget getTopGradientStripWidget() {
+        return mTopGradientStripWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoGradientStripWidget getBottomGradientStripWidget() {
+        return mBottomGradientStripWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoProgressBarWidget getProgressBarWidget() {
+        return mProgressBarWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setProgressBarWidget(@NonNull VastVideoProgressBarWidget progressBarWidget) {
+        mProgressBarWidget = progressBarWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoRadialCountdownWidget getRadialCountdownWidget() {
+        return mRadialCountdownWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setRadialCountdownWidget(@NonNull VastVideoRadialCountdownWidget radialCountdownWidget) {
+        mRadialCountdownWidget = radialCountdownWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoCtaButtonWidget getCtaButtonWidget() {
+        return mCtaButtonWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoCloseButtonWidget getCloseButtonWidget() {
+        return mCloseButtonWidget;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    ImageView getBlurredLastVideoFrameImageView() {
+        return mBlurredLastVideoFrameImageView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoView getVastVideoView() {
+        return mVideoView;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    void setIsClosing(boolean isClosing) {
+        mIsClosing = isClosing;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
new file mode 100644
index 00000000..c3602e9f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
@@ -0,0 +1,34 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+/**
+ * This class is used to update a {@link VastVideoViewController}'s countdown display according to rules
+ * contained in the {@link VastVideoViewController}
+ */
+public class VastVideoViewCountdownRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+
+    public VastVideoViewCountdownRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+        Preconditions.checkNotNull(handler);
+        Preconditions.checkNotNull(videoViewController);
+
+
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        mVideoViewController.updateCountdown();
+
+        if (mVideoViewController.shouldBeInteractable()) {
+            mVideoViewController.makeVideoInteractable();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
new file mode 100644
index 00000000..d7abf6c3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
@@ -0,0 +1,59 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.TrackingRequest;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A runnable that is used to measure video progress and track video progress events for video ads.
+ *
+ */
+public class VastVideoViewProgressRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+    @NonNull private final VastVideoConfig mVastVideoConfig;
+
+    public VastVideoViewProgressRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull final VastVideoConfig vastVideoConfig,
+            @NonNull Handler handler) {
+        super(handler);
+
+        Preconditions.checkNotNull(videoViewController);
+        Preconditions.checkNotNull(vastVideoConfig);
+        mVideoViewController = videoViewController;
+        mVastVideoConfig = vastVideoConfig;
+    }
+
+    @Override
+    public void doWork() {
+        int videoLength = mVideoViewController.getDuration();
+        int currentPosition = mVideoViewController.getCurrentPosition();
+
+        mVideoViewController.updateProgressBar();
+
+        if (videoLength > 0) {
+            final List<VastTracker> trackersToTrack =
+                    mVastVideoConfig.getUntriggeredTrackersBefore(currentPosition, videoLength);
+            if (!trackersToTrack.isEmpty()) {
+                final List<String> trackUrls = new ArrayList<String>();
+                for (VastTracker tracker : trackersToTrack) {
+                    trackUrls.add(tracker.getTrackingUrl());
+                    tracker.setTracked();
+                }
+                TrackingRequest.makeTrackingHttpRequest(
+                        new VastMacroHelper(trackUrls)
+                                .withAssetUri(mVideoViewController.getNetworkMediaFileUrl())
+                                .withContentPlayHead(currentPosition)
+                                .getUris(),
+                        mVideoViewController.getContext());
+            }
+
+            mVideoViewController.handleIconDisplay(currentPosition);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastWebView.java
new file mode 100644
index 00000000..5889cd0b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastWebView.java
@@ -0,0 +1,112 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.MotionEvent;
+import android.view.View;
+
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.VersionCode;
+
+import static com.mopub.common.util.VersionCode.currentApiLevel;
+
+/**
+ * A WebView customized for Vast video needs.
+ */
+class VastWebView extends BaseWebView {
+    interface VastWebViewClickListener {
+        void onVastWebViewClick();
+    }
+
+    @Nullable VastWebViewClickListener mVastWebViewClickListener;
+
+    VastWebView(Context context) {
+        super(context);
+
+        disableScrollingAndZoom();
+        getSettings().setJavaScriptEnabled(true);
+
+        if (currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)) {
+            enablePlugins(true);
+        }
+
+        setBackgroundColor(Color.TRANSPARENT);
+        setOnTouchListener(new VastWebViewOnTouchListener());
+        setId((int) Utils.generateUniqueId());
+    }
+
+    void loadData(String data) {
+        loadDataWithBaseURL("http://" + Constants.HOST + "/",
+                data, "text/html", "utf-8", null);
+    }
+
+    void setVastWebViewClickListener(@NonNull VastWebViewClickListener vastWebViewClickListener) {
+        mVastWebViewClickListener = vastWebViewClickListener;
+    }
+
+    private void disableScrollingAndZoom() {
+        setHorizontalScrollBarEnabled(false);
+        setHorizontalScrollbarOverlay(false);
+        setVerticalScrollBarEnabled(false);
+        setVerticalScrollbarOverlay(false);
+        getSettings().setSupportZoom(false);
+        setScrollBarStyle(View.SCROLLBARS_INSIDE_OVERLAY);
+    }
+
+    /**
+     * Creates and populates a webview.
+     *
+     * @param context      the context.
+     * @param vastResource A resource describing the contents of the webview
+     * @return a fully populated webview
+     */
+    @NonNull
+    static VastWebView createView(@NonNull final Context context,
+            @NonNull final VastResource vastResource) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(vastResource);
+
+        VastWebView webView = new VastWebView(context);
+        vastResource.initializeWebView(webView);
+
+        return webView;
+    }
+
+    /**
+     * Custom on touch listener to easily detect clicks on the entire WebView.
+     */
+    class VastWebViewOnTouchListener implements View.OnTouchListener {
+        private boolean mClickStarted;
+
+        @Override
+        public boolean onTouch(View v, MotionEvent event) {
+            switch (event.getAction()) {
+                case MotionEvent.ACTION_DOWN:
+                    mClickStarted = true;
+                    break;
+                case MotionEvent.ACTION_UP:
+                    if (!mClickStarted) {
+                        return false;
+                    }
+                    mClickStarted = false;
+                    if (mVastWebViewClickListener != null) {
+                        mVastWebViewClickListener.onVastWebViewClick();
+                    }
+            }
+
+            return false;
+        }
+    }
+
+    @VisibleForTesting
+    @Deprecated
+    @NonNull
+    VastWebViewClickListener getVastWebViewClickListener() {
+        return mVastWebViewClickListener;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastWrapperXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastWrapperXmlManager.java
new file mode 100644
index 00000000..0bf3c15a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastWrapperXmlManager.java
@@ -0,0 +1,39 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This XML manager handles Wrapper nodes. Wrappers redirect to other VAST documents (which may
+ * in turn redirect to more wrappers). Wrappers can also contain impression trackers,
+ * trackers for a video ad, and companion ads.
+ */
+class VastWrapperXmlManager extends VastBaseInLineWrapperXmlManager {
+
+    // Element names
+    private static final String VAST_AD_TAG = "VASTAdTagURI";
+
+    VastWrapperXmlManager(@NonNull final Node wrapperNode) {
+        super(wrapperNode);
+        Preconditions.checkNotNull(wrapperNode);
+    }
+
+    /**
+     * Gets the redirect URI to the next VAST xml document. If no redirect URL, return null.
+     *
+     * @return The redirect URI or {@code null} if there isn't one.
+     */
+    @Nullable
+    String getVastAdTagURI() {
+        Node vastAdTagURINode = XmlUtils.getFirstMatchingChildNode(mNode, VAST_AD_TAG);
+        return XmlUtils.getNodeValue(vastAdTagURINode);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManager.java
new file mode 100644
index 00000000..e13d7c60
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManager.java
@@ -0,0 +1,184 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Parses the VAST XML to spec. See www.iab.net for details.
+ * Currently using the VAST 3.0 spec found here: http://www.iab.net/media/file/VASTv3.0.pdf.
+ */
+class VastXmlManager {
+    private static final String ROOT_TAG = "MPMoVideoXMLDocRoot";
+    private static final String ROOT_TAG_OPEN = "<" + ROOT_TAG + ">";
+    private static final String ROOT_TAG_CLOSE = "</" + ROOT_TAG + ">";
+
+    // Element names
+    private static final String AD = "Ad";
+    private static final String ERROR = "Error";
+
+    // Custom element names for VAST 3.0 extensions
+    private static final String MP_IMPRESSION_TRACKER = "MP_TRACKING_URL";
+    private static final String CUSTOM_CTA_TEXT = "MoPubCtaText";
+    private static final String CUSTOM_SKIP_TEXT = "MoPubSkipText";
+    private static final String CUSTOM_CLOSE_ICON = "MoPubCloseIcon";
+    private static final String CUSTOM_FORCE_ORIENTATION = "MoPubForceOrientation";
+
+    // Constants for custom extensions
+    private static final int MAX_CTA_TEXT_LENGTH = 15;
+    private static final int MAX_SKIP_TEXT_LENGTH = 8;
+
+    @Nullable private Document mVastDoc;
+
+    /**
+     * Helper function that builds a document and tries to parse the XML.
+     *
+     * @param xmlString The XML to parse
+     * @throws ParserConfigurationException If the parser is poorly configured
+     * @throws IOException                  If we can't read the document for any reason
+     * @throws SAXException                 If the XML is poorly formatted
+     */
+    void parseVastXml(@NonNull String xmlString) throws ParserConfigurationException,
+            IOException, SAXException {
+        Preconditions.checkNotNull(xmlString, "xmlString cannot be null");
+
+        // if the xml string starts with <?xml?>, this tag can break parsing if it isn't formatted exactly right
+        // or if it's not the first line of the document...we're just going to strip it
+        xmlString = xmlString.replaceFirst("<\\?.*\\?>", "");
+
+        // adserver may embed additional impression trackers as a sibling node of <VAST>
+        // wrap entire document in root node for this case.
+        String documentString = ROOT_TAG_OPEN + xmlString + ROOT_TAG_CLOSE;
+
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        documentBuilderFactory.setCoalescing(true);
+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+        mVastDoc = documentBuilder.parse(new InputSource(new StringReader(documentString)));
+    }
+
+    /**
+     * If there is an Ad element, return its XML manager. This is the starting point for VAST
+     * XML documents, and VAST has this as the expected first child. There may be more than one Ad
+     * node in a VAST document. This returns a list of all Ad nodes or an empty list if no Ad nodes
+     * were found.
+     *
+     * @return A List of {@link VastAdXmlManager} or an
+     * empty list if there is no Ad child node.
+     */
+
+    @NonNull
+    List<VastAdXmlManager> getAdXmlManagers() {
+        List<VastAdXmlManager> vastAdXmlManagers = new ArrayList<VastAdXmlManager>();
+        if (mVastDoc == null) {
+            return vastAdXmlManagers;
+        }
+        NodeList nodes = mVastDoc.getElementsByTagName(AD);
+        for (int i = 0; i < nodes.getLength(); ++i) {
+            vastAdXmlManagers.add(new VastAdXmlManager(nodes.item(i)));
+        }
+        return vastAdXmlManagers;
+    }
+
+    /**
+     * Vast documents can have just an error element. This usually is used to indicate that no ad is
+     * available. This gets the url of the error tracker.
+     *
+     * @return The URL of the error tracker or null if it does not exist.
+     */
+    @Nullable
+    VastTracker getErrorTracker() {
+        if (mVastDoc == null) {
+            return null;
+        }
+        String errorTracker = XmlUtils.getFirstMatchingStringData(mVastDoc, ERROR);
+        if (TextUtils.isEmpty(errorTracker)) {
+            return null;
+        }
+        return new VastTracker(errorTracker);
+    }
+
+    /**
+     * Gets a list of MoPub specific impression trackers.
+     *
+     * @return List of URL impression trackers or an empty list if none present.
+     */
+    @NonNull
+    List<VastTracker> getMoPubImpressionTrackers() {
+        List<String> trackers = XmlUtils.getStringDataAsList(mVastDoc, MP_IMPRESSION_TRACKER);
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>(trackers.size());
+        for (String tracker : trackers) {
+            vastTrackers.add(new VastTracker(tracker));
+        }
+        return vastTrackers;
+    }
+
+    /**
+     * Gets the custom call to action text or {@code null} if not specified or too long.
+     *
+     * @return String cta or {@code null}
+     */
+    @Nullable
+    String getCustomCtaText() {
+        String customCtaText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CTA_TEXT);
+        if (customCtaText != null && customCtaText.length() <= MAX_CTA_TEXT_LENGTH) {
+            return customCtaText;
+        }
+
+        return null;
+    }
+
+    /**
+     * Gets the custom text of the skip button or {@code null} if not specified or too long.
+     *
+     * @return String skip text or {@code null}
+     */
+    @Nullable
+    String getCustomSkipText() {
+        String customSkipText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_SKIP_TEXT);
+        if (customSkipText != null && customSkipText.length() <= MAX_SKIP_TEXT_LENGTH) {
+            return customSkipText;
+        }
+
+        return null;
+    }
+
+    /**
+     * Gets the custom icon URL or {@code null} if none specified.
+     *
+     * @return String URL of the custom icon or {@code null}
+     */
+    @Nullable
+    String getCustomCloseIconUrl() {
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CLOSE_ICON);
+    }
+
+    /**
+     * Gets the orientation that this ad should be forced in. This returns UNDEFINED if not
+     * specified.
+     *
+     * @return {@code ForceOrientation} orientation or {@code UNDEFINED}
+     */
+    @NonNull
+    ForceOrientation getCustomForceOrientation() {
+        return ForceOrientation.getForceOrientation(
+                XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_FORCE_ORIENTATION));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
new file mode 100644
index 00000000..09c5d7b7
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
@@ -0,0 +1,712 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Point;
+import android.net.http.AndroidHttpClient;
+import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.common.HttpClient;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Strings;
+import com.mopub.network.Networking;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
+
+
+/**
+ * AsyncTask that reads in VAST xml and resolves redirects. This returns a
+ * fully formed {@link VastVideoConfig} so that the video can be
+ * displayed with the settings and trackers set in the configuration.
+ */
+public class VastXmlManagerAggregator extends AsyncTask<String, Void, VastVideoConfig> {
+
+    /**
+     * Listener for when the xml parsing is done.
+     */
+    interface VastXmlManagerAggregatorListener {
+        /**
+         * When all the wrappers have resolved and aggregation is done, this passes in
+         * a video configuration or null if one is not found.
+         * @param vastVideoConfig The video configuration found or null if
+         *                               no video was found.
+         */
+        void onAggregationComplete(final @Nullable VastVideoConfig vastVideoConfig);
+    }
+
+    /**
+     * Flag for companion ad orientation during xml parsing.
+     */
+    enum CompanionOrientation {
+        LANDSCAPE,
+        PORTRAIT
+    }
+
+    // More than reasonable number of nested VAST urls to follow
+    static final int MAX_TIMES_TO_FOLLOW_VAST_REDIRECT = 10;
+    private static final double ASPECT_RATIO_WEIGHT = 70;
+    private static final double AREA_WEIGHT = 30;
+    private static final List<String> VIDEO_MIME_TYPES =
+            Arrays.asList("video/mp4", "video/3gpp");
+    private static final int MINIMUM_COMPANION_AD_WIDTH = 300;
+    private static final int MINIMUM_COMPANION_AD_HEIGHT = 250;
+
+    @NonNull private final WeakReference<VastXmlManagerAggregatorListener> mVastXmlManagerAggregatorListener;
+    private final double mScreenAspectRatio;
+    private final int mScreenAreaDp;
+    @NonNull private final Context mContext;
+
+    /**
+     * Number of times this has followed a redirect. This value is only
+     * accessed and set on the background thread.
+     */
+    private int mTimesFollowedVastRedirect;
+
+    VastXmlManagerAggregator(@NonNull final VastXmlManagerAggregatorListener vastXmlManagerAggregatorListener,
+            final double screenAspectRatio,
+            final int screenAreaDp,
+            @NonNull final Context context) {
+        super();
+
+        Preconditions.checkNotNull(vastXmlManagerAggregatorListener);
+        Preconditions.checkNotNull(context);
+        mVastXmlManagerAggregatorListener =
+                new WeakReference<VastXmlManagerAggregatorListener>(vastXmlManagerAggregatorListener);
+        mScreenAspectRatio = screenAspectRatio;
+        mScreenAreaDp = screenAreaDp;
+        mContext = context.getApplicationContext();
+    }
+
+    @Override
+    protected void onPreExecute() {
+        // This is to set the WebView user agent in case it was not already set by some other
+        // element (such as the request queue).
+        Networking.getUserAgent(mContext);
+    }
+
+    @Override
+    protected VastVideoConfig doInBackground(@Nullable String... strings) {
+        AndroidHttpClient httpClient = null;
+        try {
+            httpClient = HttpClient.getHttpClient();
+            if (strings != null && strings.length > 0) {
+                String vastXml = strings[0];
+                if (vastXml == null) {
+                    return null;
+                }
+                return evaluateVastXmlManager(vastXml, httpClient, new ArrayList<VastTracker>());
+            }
+        } catch (Exception e) {
+            MoPubLog.d("Failed to parse VAST XML", e);
+        } finally {
+            if (httpClient != null) {
+                httpClient.close();
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    protected void onPostExecute(final @Nullable VastVideoConfig vastVideoConfig) {
+        final VastXmlManagerAggregatorListener listener = mVastXmlManagerAggregatorListener.get();
+        if (listener != null) {
+            listener.onAggregationComplete(vastVideoConfig);
+        }
+    }
+
+    @Override
+    protected void onCancelled() {
+        final VastXmlManagerAggregatorListener listener = mVastXmlManagerAggregatorListener.get();
+        if (listener != null) {
+            listener.onAggregationComplete(null);
+        }
+    }
+
+    /**
+     * Recursively traverses the VAST xml documents and finds the first Linear creative containing a
+     * valid media file. For each Ad element in a document, the method will first try to find a
+     * valid Linear creative in the InLine element. If it does not find one, it will then try to
+     * resolve the Wrapper element which should redirect to more VAST xml documents with more InLine
+     * elements.
+     * <p/>
+     * The list of error trackers are propagated through each wrapper redirect. If at the end of the
+     * wrapper chain, there's no ad, then the error trackers for the entire wrapper chain are fired.
+     * If a valid video is found, the error trackers are stored in the video configuration for
+     * non-xml errors.
+     *
+     * @param vastXml           The xml that this class parses
+     * @param androidHttpClient This is used to follow redirects
+     * @param errorTrackers     This is the current list of error tracker URLs to hit if something
+     *                          goes wrong.
+     * @return {@link VastVideoConfig} with all available fields set or null if the xml is
+     * invalid or null.
+     */
+    @VisibleForTesting
+    @Nullable
+    VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
+            @NonNull final AndroidHttpClient androidHttpClient,
+            @NonNull final List<VastTracker> errorTrackers) {
+        Preconditions.checkNotNull(vastXml, "vastXml cannot be null");
+        Preconditions.checkNotNull(androidHttpClient, "androidHttpClient cannot be null");
+        Preconditions.checkNotNull(errorTrackers, "errorTrackers cannot be null");
+
+        final VastXmlManager xmlManager = new VastXmlManager();
+        try {
+            xmlManager.parseVastXml(vastXml);
+        } catch (Exception e) {
+            MoPubLog.d("Failed to parse VAST XML", e);
+            makeVastTrackingHttpRequest(errorTrackers, VastErrorCode.XML_PARSING_ERROR, null,
+                    null, mContext);
+            return null;
+        }
+
+        List<VastAdXmlManager> vastAdXmlManagers = xmlManager.getAdXmlManagers();
+
+        // If there are no ads, fire the error trackers
+        if (fireErrorTrackerIfNoAds(vastAdXmlManagers, xmlManager, mContext)) {
+            return null;
+        }
+
+        for (VastAdXmlManager vastAdXmlManager : vastAdXmlManagers) {
+
+            if (!isValidSequenceNumber(vastAdXmlManager.getSequence())) {
+                continue;
+            }
+
+            // InLine evaluation
+            VastInLineXmlManager vastInLineXmlManager = vastAdXmlManager.getInLineXmlManager();
+            if (vastInLineXmlManager != null) {
+                VastVideoConfig vastVideoConfig = evaluateInLineXmlManager(
+                        vastInLineXmlManager, errorTrackers);
+                // If the vastVideoConfig is non null, it means we found a valid media file
+                if (vastVideoConfig != null) {
+                    populateMoPubCustomElements(xmlManager, vastVideoConfig);
+                    return vastVideoConfig;
+                }
+            }
+
+            // Wrapper evaluation
+            VastWrapperXmlManager vastWrapperXmlManager = vastAdXmlManager.getWrapperXmlManager();
+            if (vastWrapperXmlManager != null) {
+                final List<VastTracker> wrapperErrorTrackers = new ArrayList<VastTracker>(errorTrackers);
+                wrapperErrorTrackers.addAll(vastWrapperXmlManager.getErrorTrackers());
+                String vastRedirectXml = evaluateWrapperRedirect(vastWrapperXmlManager,
+                        androidHttpClient, wrapperErrorTrackers);
+                if (vastRedirectXml == null) {
+                    continue;
+                }
+
+                VastVideoConfig vastVideoConfig = evaluateVastXmlManager(
+                        vastRedirectXml,
+                        androidHttpClient,
+                        wrapperErrorTrackers);
+                // If we don't find a valid video creative somewhere down this wrapper chain,
+                // look at the next Ad element
+                // NOTE: Wrapper elements will never contain media files according to the VAST
+                // 3.0 spec
+                if (vastVideoConfig == null) {
+                    continue;
+                }
+
+                // If we have a vastVideoConfig it means that we found a valid media file
+                // in one of Wrapper redirects. Therefore, aggregate all trackers in the wrapper
+                vastVideoConfig.addImpressionTrackers(
+                        vastWrapperXmlManager.getImpressionTrackers());
+                List<VastLinearXmlManager> linearXmlManagers =
+                        vastWrapperXmlManager.getLinearXmlManagers();
+                for (VastLinearXmlManager linearXmlManager : linearXmlManagers) {
+                    populateLinearTrackersAndIcon(linearXmlManager, vastVideoConfig);
+                }
+
+                // Only populate a companion ad if we don't already have one from one of the
+                // redirects
+                if (!vastVideoConfig.hasCompanionAd()) {
+                    vastVideoConfig.setVastCompanionAd(
+                            getBestCompanionAd(vastWrapperXmlManager.getCompanionAdXmlManagers(),
+                                    CompanionOrientation.LANDSCAPE),
+                            getBestCompanionAd(vastWrapperXmlManager.getCompanionAdXmlManagers(),
+                                    CompanionOrientation.PORTRAIT));
+                } else {
+                    // Otherwise append the companion trackers if it doesn't have resources
+                    final VastCompanionAdConfig landscapeCompanionAd = vastVideoConfig.getVastCompanionAd(
+                            Configuration.ORIENTATION_LANDSCAPE);
+                    final VastCompanionAdConfig portraitCompanionAd = vastVideoConfig.getVastCompanionAd(
+                            Configuration.ORIENTATION_PORTRAIT);
+                    if (landscapeCompanionAd != null && portraitCompanionAd != null) {
+                        for (final VastCompanionAdXmlManager companionAdXmlManager : vastWrapperXmlManager.getCompanionAdXmlManagers()) {
+                            if (!companionAdXmlManager.hasResources()) {
+                                landscapeCompanionAd.addClickTrackers(
+                                        companionAdXmlManager.getClickTrackers());
+                                landscapeCompanionAd.addCreativeViewTrackers(
+                                        companionAdXmlManager.getCompanionCreativeViewTrackers());
+                                portraitCompanionAd.addClickTrackers(
+                                        companionAdXmlManager.getClickTrackers());
+                                portraitCompanionAd.addCreativeViewTrackers(
+                                        companionAdXmlManager.getCompanionCreativeViewTrackers());
+                            }
+                        }
+                    }
+                }
+
+                populateMoPubCustomElements(xmlManager, vastVideoConfig);
+
+                return vastVideoConfig;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Parses and evaluates an InLine element looking for a valid media file. InLine elements are
+     * evaluated in order and the first valid media file found is used. If a media file is
+     * found, a {@link VastVideoConfig} is created and trackers are aggregated. If a
+     * valid companion ad is found, it is also added to the configuration.
+     *
+     * @param vastInLineXmlManager used to extract the media file, clickthrough link, trackers, and
+     *                         companion ad
+     * @param errorTrackers The error trackers from previous wrappers
+     * @return a {@link VastVideoConfig} or null if a valid media file was not found
+     */
+    @Nullable
+    private VastVideoConfig evaluateInLineXmlManager(
+            @NonNull final VastInLineXmlManager vastInLineXmlManager,
+            @NonNull final List<VastTracker> errorTrackers) {
+        Preconditions.checkNotNull(vastInLineXmlManager);
+
+        List<VastLinearXmlManager> linearXmlManagers = vastInLineXmlManager.getLinearXmlManagers();
+        for (VastLinearXmlManager linearXmlManager : linearXmlManagers) {
+            String bestMediaFileUrl = getBestMediaFileUrl(linearXmlManager.getMediaXmlManagers());
+            if (bestMediaFileUrl != null) {
+                // Create vast video configuration and populate initial trackers
+                VastVideoConfig vastVideoConfig = new VastVideoConfig();
+                vastVideoConfig.addImpressionTrackers(vastInLineXmlManager.getImpressionTrackers());
+                populateLinearTrackersAndIcon(linearXmlManager, vastVideoConfig);
+
+                // Linear nodes will only have a click through url and network media file when they
+                // are under an InLine element. They will not have these assets when they are under
+                // a Wrapper element.
+                vastVideoConfig.setClickThroughUrl(linearXmlManager.getClickThroughUrl());
+                vastVideoConfig.setNetworkMediaFileUrl(bestMediaFileUrl);
+
+                vastVideoConfig.setVastCompanionAd(
+                        getBestCompanionAd(vastInLineXmlManager.getCompanionAdXmlManagers(),
+                                CompanionOrientation.LANDSCAPE),
+                        getBestCompanionAd(vastInLineXmlManager.getCompanionAdXmlManagers(),
+                                CompanionOrientation.PORTRAIT));
+                errorTrackers.addAll(vastInLineXmlManager.getErrorTrackers());
+                vastVideoConfig.addErrorTrackers(errorTrackers);
+                return vastVideoConfig;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Retrieves the Wrapper's redirect uri and follows it to return the next VAST xml String.
+     *
+     * @param vastWrapperXmlManager used to get the redirect uri
+     * @param androidHttpClient     the http client
+     * @param wrapperErrorTrackers  Error trackers to hit if something goes wrong
+     * @return the next VAST xml String or {@code null} if it could not be resolved
+     */
+    @Nullable
+    private String evaluateWrapperRedirect(@NonNull VastWrapperXmlManager vastWrapperXmlManager,
+            @NonNull AndroidHttpClient androidHttpClient,
+            @NonNull List<VastTracker> wrapperErrorTrackers) {
+        String vastAdTagUri = vastWrapperXmlManager.getVastAdTagURI();
+        if (vastAdTagUri == null) {
+            return null;
+        }
+
+        String vastRedirectXml = null;
+        try {
+            vastRedirectXml = followVastRedirect(androidHttpClient, vastAdTagUri);
+        } catch (Exception e) {
+            MoPubLog.d("Failed to follow VAST redirect", e);
+            if (!wrapperErrorTrackers.isEmpty()) {
+                makeVastTrackingHttpRequest(wrapperErrorTrackers, VastErrorCode.WRAPPER_TIMEOUT,
+                                null, null, mContext);
+            }
+        }
+
+        return vastRedirectXml;
+    }
+
+    /**
+     * This method aggregates all trackers found in the linearXmlManager and adds them to the
+     * {@link VastVideoConfig}. This method also populates the skip offset and icon if they
+     * have not already been populated in one of the wrapper redirects.
+     *
+     * @param linearXmlManager used to retrieve trackers, and assets
+     * @param vastVideoConfig modified in this method to store trackers and assets
+     */
+    private void populateLinearTrackersAndIcon(@NonNull final VastLinearXmlManager linearXmlManager,
+            @NonNull final VastVideoConfig vastVideoConfig) {
+        Preconditions.checkNotNull(linearXmlManager, "linearXmlManager cannot be null");
+        Preconditions.checkNotNull(vastVideoConfig, "vastVideoConfig cannot be null");
+
+        vastVideoConfig.addAbsoluteTrackers(linearXmlManager.getAbsoluteProgressTrackers());
+        vastVideoConfig.addFractionalTrackers(
+                linearXmlManager.getFractionalProgressTrackers());
+        vastVideoConfig.addPauseTrackers(linearXmlManager.getPauseTrackers());
+        vastVideoConfig.addResumeTrackers(linearXmlManager.getResumeTrackers());
+        vastVideoConfig.addCompleteTrackers(linearXmlManager.getVideoCompleteTrackers());
+        vastVideoConfig.addCloseTrackers(linearXmlManager.getVideoCloseTrackers());
+        vastVideoConfig.addSkipTrackers(linearXmlManager.getVideoSkipTrackers());
+        vastVideoConfig.addClickTrackers(linearXmlManager.getClickTrackers());
+
+        // Only set the skip offset if we haven't set it already in one of the redirects
+        if (vastVideoConfig.getSkipOffsetString() == null) {
+            vastVideoConfig.setSkipOffset(linearXmlManager.getSkipOffset());
+        }
+
+        // Only set the icon if we haven't set it already in one of the redirects
+        if (vastVideoConfig.getVastIconConfig() == null) {
+            vastVideoConfig.setVastIconConfig(getBestIcon(linearXmlManager.getIconXmlManagers()));
+        }
+    }
+
+    /**
+     * Parses all custom MoPub specific custom extensions and impression trackers
+     * and populates them in the {@link VastVideoConfig}. These extensions are not part
+     * of the Vast 3.0 spec and are appended to the root of the xml document.
+     *
+     * @param xmlManager used to retrieve the custom extensions and impression trackers
+     * @param vastVideoConfig modified in this method to store custom extensions and
+     *                               impression trackers
+     */
+    private void populateMoPubCustomElements(@NonNull final VastXmlManager xmlManager,
+            @NonNull final VastVideoConfig vastVideoConfig) {
+        Preconditions.checkNotNull(xmlManager, "xmlManager cannot be null");
+        Preconditions.checkNotNull(vastVideoConfig, "vastVideoConfig cannot be null");
+
+        vastVideoConfig.addImpressionTrackers(xmlManager.getMoPubImpressionTrackers());
+
+        if (vastVideoConfig.getCustomCtaText() == null) {
+            vastVideoConfig.setCustomCtaText(xmlManager.getCustomCtaText());
+        }
+        if (vastVideoConfig.getCustomSkipText() == null) {
+            vastVideoConfig.setCustomSkipText(xmlManager.getCustomSkipText());
+        }
+        if (vastVideoConfig.getCustomCloseIconUrl() == null) {
+            vastVideoConfig.setCustomCloseIconUrl(xmlManager.getCustomCloseIconUrl());
+        }
+        if (!vastVideoConfig.isCustomForceOrientationSet()) {
+            vastVideoConfig.setCustomForceOrientation(xmlManager.getCustomForceOrientation());
+        }
+    }
+
+    /**
+     * Fires the available error tracker if the sole element in this vast document is an Error
+     * element. In the VAST 3.0 spec in section 2.4.2.4, the No Ad Response can be represented by a
+     * VAST document with only the Error element and no Ad elements. Returns whether or not the
+     * error tracker was fired.
+     *
+     * @param vastAdXmlManagers The List of AdXmlManagers to determine if there are any ads
+     *                          available
+     * @param xmlManager        The current VastXmlManager that's used to get the new error tracker
+     * @param context           Used to send an http request
+     * @return {@code true} if the error tracker was fired, {@code false} if the error tracker was
+     * not fired.
+     */
+    private boolean fireErrorTrackerIfNoAds(
+            @NonNull final List<VastAdXmlManager> vastAdXmlManagers,
+            @NonNull final VastXmlManager xmlManager, @NonNull Context context) {
+        // When there is no <Ad> tag and when there is an error tracker
+        if (vastAdXmlManagers.isEmpty() && xmlManager.getErrorTracker() != null ) {
+            // Only use NO_ADS_VAST_RESPONSE if we've followed one or more wrappers
+            makeVastTrackingHttpRequest(
+                    Collections.singletonList(xmlManager.getErrorTracker()),
+                    mTimesFollowedVastRedirect > 0
+                            ? VastErrorCode.NO_ADS_VAST_RESPONSE
+                            : VastErrorCode.UNDEFINED_ERROR,
+                    null, null, context);
+            return true;
+        }
+        return false;
+    }
+
+    @VisibleForTesting
+    @Nullable
+    String getBestMediaFileUrl(@NonNull final List<VastMediaXmlManager> managers) {
+        Preconditions.checkNotNull(managers, "managers cannot be null");
+        final List<VastMediaXmlManager> mediaXmlManagers = new ArrayList<VastMediaXmlManager>(managers);
+        double bestMediaFitness = Double.POSITIVE_INFINITY;
+        String bestMediaFileUrl = null;
+
+        final Iterator<VastMediaXmlManager> xmlManagerIterator = mediaXmlManagers.iterator();
+        while (xmlManagerIterator.hasNext()) {
+            final VastMediaXmlManager mediaXmlManager = xmlManagerIterator.next();
+
+            final String mediaType = mediaXmlManager.getType();
+            final String mediaUrl = mediaXmlManager.getMediaUrl();
+            if (!VIDEO_MIME_TYPES.contains(mediaType) || mediaUrl == null) {
+                xmlManagerIterator.remove();
+                continue;
+            }
+
+            final Integer mediaWidth = mediaXmlManager.getWidth();
+            final Integer mediaHeight = mediaXmlManager.getHeight();
+            if (mediaWidth == null || mediaWidth <= 0 || mediaHeight == null || mediaHeight <= 0) {
+                continue;
+            }
+
+            final double mediaFitness = calculateFitness(mediaWidth, mediaHeight);
+            if (mediaFitness < bestMediaFitness) {
+                bestMediaFitness = mediaFitness;
+                bestMediaFileUrl = mediaUrl;
+            }
+        }
+
+        return bestMediaFileUrl;
+    }
+
+    @VisibleForTesting
+    @Nullable
+    VastCompanionAdConfig getBestCompanionAd(
+            @NonNull final List<VastCompanionAdXmlManager> managers,
+            @NonNull final CompanionOrientation orientation) {
+        Preconditions.checkNotNull(managers, "managers cannot be null");
+        Preconditions.checkNotNull(orientation, "orientation cannot be null");
+
+        final List<VastCompanionAdXmlManager> companionXmlManagers =
+                new ArrayList<VastCompanionAdXmlManager>(managers);
+        double bestCompanionFitness = Double.POSITIVE_INFINITY;
+        VastCompanionAdXmlManager bestCompanionXmlManager = null;
+        VastResource bestVastResource = null;
+        Point bestVastScaledDimensions = null;
+
+        // Look for the best companion ad in order of prioritized resource types
+        for (VastResource.Type type : VastResource.Type.values()) {
+            final Iterator<VastCompanionAdXmlManager> xmlManagerIterator =
+                    companionXmlManagers.iterator();
+            while (xmlManagerIterator.hasNext()) {
+                final VastCompanionAdXmlManager companionXmlManager = xmlManagerIterator.next();
+
+                final Integer width = companionXmlManager.getWidth();
+                final Integer height = companionXmlManager.getHeight();
+                if (width == null || width < MINIMUM_COMPANION_AD_WIDTH ||
+                        height == null || height < MINIMUM_COMPANION_AD_HEIGHT) {
+                    continue;
+                }
+
+                Point vastScaledDimensions = getScaledDimensions(width, height);
+                VastResource vastResource = VastResource.fromVastResourceXmlManager(
+                        companionXmlManager.getResourceXmlManager(), type,
+                        vastScaledDimensions.x, vastScaledDimensions.y);
+                if (vastResource == null) {
+                    continue;
+                }
+
+                final double companionFitness;
+                if (CompanionOrientation.PORTRAIT == orientation) {
+                    companionFitness = calculateFitness(height, width);
+                } else {
+                    companionFitness = calculateFitness(width, height);
+                }
+                if (companionFitness < bestCompanionFitness) {
+                    bestCompanionFitness = companionFitness;
+                    bestCompanionXmlManager = companionXmlManager;
+                    bestVastResource = vastResource;
+                    bestVastScaledDimensions = vastScaledDimensions;
+                }
+            }
+            if (bestCompanionXmlManager != null) {
+                break;
+            }
+        }
+
+        if (bestCompanionXmlManager != null) {
+            return new VastCompanionAdConfig(
+                    bestVastScaledDimensions.x,
+                    bestVastScaledDimensions.y,
+                    bestVastResource,
+                    bestCompanionXmlManager.getClickThroughUrl(),
+                    bestCompanionXmlManager.getClickTrackers(),
+                    bestCompanionXmlManager.getCompanionCreativeViewTrackers()
+            );
+        }
+        return null;
+    }
+
+    /**
+     * Given a width and height for a resource, if the dimensions are larger than the screen size
+     * then scale them down to fit in the screen while maintaining the aspect ratio. Scaling
+     * takes into account the default Android WebView padding.
+     *
+     * @param widthDp width of the resource in dips
+     * @param heightDp height of the resource in dips
+     * @return the new scaled dimensions that honor the aspect ratio
+     */
+    @VisibleForTesting
+    @NonNull
+    Point getScaledDimensions(int widthDp, int heightDp) {
+        Point defaultPoint = new Point(widthDp, heightDp);
+        final Display display = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        int x = display.getWidth();
+        int y = display.getHeight();
+
+        // For landscape, width is always greater than height
+        int screenWidth = Math.max(x, y);
+        int screenHeight = Math.min(x, y);
+
+        int widthPx = Dips.dipsToIntPixels(widthDp, mContext);
+        int heightPx = Dips.dipsToIntPixels(heightDp, mContext);
+
+        // Return if the width and height already fit in the screen
+        if (widthPx <= screenWidth && heightPx <= screenHeight) {
+            return defaultPoint;
+        }
+
+        float widthRatio = (float) widthPx / screenWidth;
+        float heightRatio = (float) heightPx / screenHeight;
+
+        Point point = new Point();
+        if (widthRatio >= heightRatio) {
+            point.x = screenWidth - VastVideoViewController.WEBVIEW_PADDING;
+            point.y = (int) (heightPx / widthRatio) - VastVideoViewController.WEBVIEW_PADDING;
+        } else {
+            point.x = (int) (widthPx / heightRatio) - VastVideoViewController.WEBVIEW_PADDING;
+            point.y = screenHeight - VastVideoViewController.WEBVIEW_PADDING;
+        }
+
+        if (point.x < 0 || point.y < 0) {
+            return defaultPoint;
+        }
+
+        point.x = Dips.pixelsToIntDips(point.x, mContext);
+        point.y = Dips.pixelsToIntDips(point.y, mContext);
+
+        return point;
+    }
+
+    @VisibleForTesting
+    @Nullable
+    VastIconConfig getBestIcon(@NonNull final List<VastIconXmlManager> managers) {
+        Preconditions.checkNotNull(managers, "managers cannot be null");
+        final List<VastIconXmlManager> iconXmlManagers = new ArrayList<VastIconXmlManager>(managers);
+
+        // Look for the best icon in order of prioritized resource types
+        for (VastResource.Type type : VastResource.Type.values()) {
+            final Iterator<VastIconXmlManager> xmlManagerIterator = iconXmlManagers.iterator();
+            while (xmlManagerIterator.hasNext()) {
+                final VastIconXmlManager iconXmlManager = xmlManagerIterator.next();
+
+                final Integer width = iconXmlManager.getWidth();
+                final Integer height = iconXmlManager.getHeight();
+
+                // Icons can be a max of 300 x 300 dp
+                if (width == null || width <= 0 || width > 300
+                        || height == null || height <= 0 || height > 300) {
+                    continue;
+                }
+
+                VastResource vastResource = VastResource.fromVastResourceXmlManager(
+                        iconXmlManager.getResourceXmlManager(), type, width, height);
+
+                if (vastResource == null) {
+                    continue;
+                }
+
+                return new VastIconConfig(
+                        iconXmlManager.getWidth(),
+                        iconXmlManager.getHeight(),
+                        iconXmlManager.getOffsetMS(),
+                        iconXmlManager.getDurationMS(),
+                        vastResource,
+                        iconXmlManager.getClickTrackingUris(),
+                        iconXmlManager.getClickThroughUri(),
+                        iconXmlManager.getViewTrackingUris());
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Calculates the fitness of the media file or companion by comparing its aspect ratio and
+     * area to those of the device. The closer to 0 the score, the better. The fitness function
+     * weighs aspect ratios and areas differently.
+     *
+     * @param widthDp the width of the media file or companion ad
+     * @param heightDp the height of th media file or companion ad
+     * @return the fitness score. The closer to 0, the better.
+     */
+    private double calculateFitness(final int widthDp, final int heightDp) {
+        final double mediaAspectRatio = (double) widthDp / heightDp;
+        final int mediaAreaDp = widthDp * heightDp;
+        final double aspectRatioRatio = mediaAspectRatio / mScreenAspectRatio;
+        final double areaRatio = (double) mediaAreaDp / mScreenAreaDp;
+        return ASPECT_RATIO_WEIGHT * Math.abs(Math.log(aspectRatioRatio))
+                + AREA_WEIGHT * Math.abs(Math.log(areaRatio));
+    }
+
+    /**
+     * Since MoPub does not support ad pods, do not accept any positive integers greater than 1.
+     * MoPub will use the first ad in an ad pod (sequence = 1), but it will ignore all other ads in
+     * the pod. If no sequence number, MoPub treats it like a stand-alone ad. If the sequence number
+     * is nonsensical (e.g. negative, fails to parse as an integer), MoPub treats it like a
+     * stand-alone ad.
+     *
+     * @param sequence The sequence number
+     * @return True if this is a sequence number that MoPub would show an ad for, false if not.
+     */
+    static boolean isValidSequenceNumber(@Nullable final String sequence) {
+        if (TextUtils.isEmpty(sequence)) {
+            return true;
+        }
+        try {
+            final int sequenceInt = Integer.parseInt(sequence);
+            return sequenceInt < 2;
+        } catch (NumberFormatException e) {
+            // Since the sequence number is not a valid integer, go ahead and pretend there's no
+            // sequence number and show this ad
+            return true;
+        }
+    }
+
+    @Nullable
+    private String followVastRedirect(@NonNull final AndroidHttpClient httpClient,
+            @NonNull final String redirectUrl) throws Exception {
+        Preconditions.checkNotNull(httpClient);
+        Preconditions.checkNotNull(redirectUrl);
+
+        if (mTimesFollowedVastRedirect < MAX_TIMES_TO_FOLLOW_VAST_REDIRECT) {
+            mTimesFollowedVastRedirect++;
+
+            final HttpGet httpget = HttpClient.initializeHttpGet(redirectUrl);
+            final HttpResponse response = httpClient.execute(httpget);
+            final HttpEntity entity = response.getEntity();
+            return (entity != null) ? Strings.fromStream(entity.getContent()) : null;
+        }
+        return null;
+    }
+
+    @VisibleForTesting
+    @Deprecated
+    void setTimesFollowedVastRedirect(final int timesFollowedVastRedirect) {
+        mTimesFollowedVastRedirect = timesFollowedVastRedirect;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
index bb9a23df..cdb92180 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
@@ -1,16 +1,19 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 
 public class ViewGestureDetector extends GestureDetector {
     private final View mView;
 
-    interface UserClickListener {
+    public interface UserClickListener {
         void onUserClick();
         void onResetUserClick();
         boolean wasClicked();
@@ -19,8 +22,8 @@
     private AdAlertGestureListener mAdAlertGestureListener;
     private UserClickListener mUserClickListener;
 
-    public ViewGestureDetector(Context context, View view, AdConfiguration adConfiguration)  {
-        this(context, view, new AdAlertGestureListener(view, adConfiguration));
+    public ViewGestureDetector(@NonNull Context context, @NonNull View view, @Nullable AdReport adReport)  {
+        this(context, view, new AdAlertGestureListener(view, adReport));
     }
 
     private ViewGestureDetector(Context context, View view, AdAlertGestureListener adAlertGestureListener) {
@@ -32,7 +35,7 @@ private ViewGestureDetector(Context context, View view, AdAlertGestureListener a
         setIsLongpressEnabled(false);
     }
 
-    void sendTouchEvent(MotionEvent motionEvent) {
+    public void sendTouchEvent(MotionEvent motionEvent) {
         switch (motionEvent.getAction()) {
             case MotionEvent.ACTION_UP:
                 if (mUserClickListener != null) {
@@ -60,7 +63,7 @@ void sendTouchEvent(MotionEvent motionEvent) {
         }
     }
 
-    void setUserClickListener(UserClickListener listener) {
+    public void setUserClickListener(UserClickListener listener) {
         mUserClickListener = listener;
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
index e4d92329..975b69cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
@@ -1,84 +1,32 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.location.Location;
 
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-
-import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
+import com.mopub.common.Constants;
 
 public class WebViewAdUrlGenerator extends AdUrlGenerator {
-    public WebViewAdUrlGenerator(Context context) {
+    private final boolean mIsStorePictureSupported;
+
+    public WebViewAdUrlGenerator(Context context, boolean isStorePictureSupported) {
         super(context);
+        mIsStorePictureSupported = isStorePictureSupported;
     }
 
     @Override
     public String generateUrlString(String serverHostname) {
-        initUrlString(serverHostname, MoPubView.AD_HANDLER);
-
-        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        initUrlString(serverHostname, Constants.AD_HANDLER);
 
         setApiVersion("6");
 
-        setAdUnitId(mAdUnitId);
-
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setUdid(clientMetadata.getAdvertisingId());
-
-        setDoNotTrack(clientMetadata.isDoNotTrackSet());
-
-        setKeywords(mKeywords);
-
-        Location location = mLocation;
-        if (location == null) {
-            location = LocationService.getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-        setLocation(location);
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        setMraidFlag(detectIsMraidSupported());
-
-        String networkOperator = clientMetadata.getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        addBaseParams(clientMetadata);
 
-        setExternalStoragePermission(isStorePictureSupported(mContext));
+        setMraidFlag(true);
 
-        setTwitterAppInstalledFlag();
+        setExternalStoragePermission(mIsStorePictureSupported);
 
         return getFinalUrlString();
     }
-
-    private boolean detectIsMraidSupported() {
-        boolean mraid = true;
-        try {
-            Class.forName("com.mopub.mobileads.MraidView");
-        } catch (ClassNotFoundException e) {
-            mraid = false;
-        }
-        return mraid;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetchTaskFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetchTaskFactory.java
deleted file mode 100644
index 23c463be..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetchTaskFactory.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import com.mopub.mobileads.AdFetchTask;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.TaskTracker;
-
-public class AdFetchTaskFactory {
-    protected static AdFetchTaskFactory instance = new AdFetchTaskFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(AdFetchTaskFactory factory) {
-        instance = factory;
-    }
-
-    public static AdFetchTask create(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        return instance.internalCreate(taskTracker, adViewController, userAgent, timeoutMilliseconds);
-    }
-
-    protected AdFetchTask internalCreate(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        return new AdFetchTask(taskTracker, adViewController, userAgent, timeoutMilliseconds);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetcherFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetcherFactory.java
deleted file mode 100644
index 7490ced8..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetcherFactory.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import com.mopub.mobileads.AdFetcher;
-import com.mopub.mobileads.AdViewController;
-
-public class AdFetcherFactory {
-    protected static AdFetcherFactory instance = new AdFetcherFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(AdFetcherFactory factory) {
-        instance = factory;
-    }
-
-    public static AdFetcher create(AdViewController adViewController, String userAgent) {
-        return instance.internalCreate(adViewController, userAgent);
-    }
-
-    protected AdFetcher internalCreate(AdViewController adViewController, String userAgent) {
-        return new AdFetcher(adViewController, userAgent);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
index bf363e57..d6a53767 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
@@ -1,8 +1,13 @@
 package com.mopub.mobileads.factories;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventBannerAdapter;
 import com.mopub.mobileads.MoPubView;
 
+import java.util.Map;
+
 public class CustomEventBannerAdapterFactory {
     protected static CustomEventBannerAdapterFactory instance = new CustomEventBannerAdapterFactory();
 
@@ -11,11 +16,19 @@ public static void setInstance(CustomEventBannerAdapterFactory factory) {
         instance = factory;
     }
 
-    public static CustomEventBannerAdapter create(MoPubView moPubView, String className, String classData) {
-        return instance.internalCreate(moPubView, className, classData);
+    public static CustomEventBannerAdapter create(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @NonNull AdReport adReport) {
+        return instance.internalCreate(moPubView, className, serverExtras, broadcastIdentifier, adReport);
     }
 
-    protected CustomEventBannerAdapter internalCreate(MoPubView moPubView, String className, String classData) {
-        return new CustomEventBannerAdapter(moPubView, className, classData);
+    protected CustomEventBannerAdapter internalCreate(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @NonNull AdReport adReport) {
+        return new CustomEventBannerAdapter(moPubView, className, serverExtras, broadcastIdentifier, adReport);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
index f6534dda..e7042f5c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
@@ -1,8 +1,11 @@
 package com.mopub.mobileads.factories;
 
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventInterstitialAdapter;
 import com.mopub.mobileads.MoPubInterstitial;
 
+import java.util.Map;
+
 public class CustomEventInterstitialAdapterFactory {
     protected static CustomEventInterstitialAdapterFactory instance = new CustomEventInterstitialAdapterFactory();
 
@@ -11,11 +14,11 @@ public static void setInstance(CustomEventInterstitialAdapterFactory factory) {
         instance = factory;
     }
 
-    public static CustomEventInterstitialAdapter create(MoPubInterstitial moPubInterstitial, String className, String classData) {
-        return instance.internalCreate(moPubInterstitial, className, classData);
+    public static CustomEventInterstitialAdapter create(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
+        return instance.internalCreate(moPubInterstitial, className, serverExtras, broadcastIdentifier, adReport);
     }
 
-    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, String classData) {
-        return new CustomEventInterstitialAdapter(moPubInterstitial, className, classData);
+    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
+        return new CustomEventInterstitialAdapter(moPubInterstitial, className, serverExtras, broadcastIdentifier, adReport);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
index e7d300b1..59b9544d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlBannerWebView;
 
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
@@ -12,22 +12,22 @@
 
     public static HtmlBannerWebView create(
             Context context,
+            AdReport adReport,
             CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+            String clickthroughUrl) {
+        return instance.internalCreate(context, adReport, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
     }
 
     public HtmlBannerWebView internalCreate(
             Context context,
+            AdReport adReport,
             CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        HtmlBannerWebView htmlBannerWebView = new HtmlBannerWebView(context, adConfiguration);
+            String clickthroughUrl) {
+        HtmlBannerWebView htmlBannerWebView = new HtmlBannerWebView(context, adReport);
         htmlBannerWebView.init(customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
         return htmlBannerWebView;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
index ab8c4490..65d97a39 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlInterstitialWebView;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -12,22 +12,22 @@
 
     public static HtmlInterstitialWebView create(
             Context context,
+            AdReport adReport,
             CustomEventInterstitialListener customEventInterstitialListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+            String clickthroughUrl) {
+        return instance.internalCreate(context, adReport, customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl);
     }
 
     public HtmlInterstitialWebView internalCreate(
             Context context,
+            AdReport adReport,
             CustomEventInterstitialListener customEventInterstitialListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        HtmlInterstitialWebView htmlInterstitialWebView = new HtmlInterstitialWebView(context, adConfiguration);
+            String clickthroughUrl) {
+        HtmlInterstitialWebView htmlInterstitialWebView = new HtmlInterstitialWebView(context, adReport);
         htmlInterstitialWebView.init(customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl);
         return htmlInterstitialWebView;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java
new file mode 100644
index 00000000..50c5391e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java
@@ -0,0 +1,30 @@
+package com.mopub.mobileads.factories;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.PlacementType;
+
+public class MraidControllerFactory {
+    protected static MraidControllerFactory instance = new MraidControllerFactory();
+
+    @VisibleForTesting
+    public static void setInstance(MraidControllerFactory factory) {
+        instance = factory;
+    }
+
+    public static MraidController create(@NonNull final Context context, 
+            @NonNull final AdReport adReport, 
+            @NonNull final PlacementType placementType) {
+        return instance.internalCreate(context, adReport, placementType);
+    }
+
+    protected MraidController internalCreate(@NonNull final Context context, 
+            @NonNull final AdReport adReport, 
+            @NonNull final PlacementType placementType) {
+        return new MraidController(context, adReport, placementType);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidViewFactory.java
deleted file mode 100644
index a139babf..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidViewFactory.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import android.content.Context;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.MraidView;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-
-public class MraidViewFactory {
-    protected static MraidViewFactory instance = new MraidViewFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(MraidViewFactory factory) {
-        instance = factory;
-    }
-
-    public static MraidView create(Context context, AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, adConfiguration);
-    }
-
-    public static MraidView create(
-            Context context,
-            AdConfiguration adConfiguration,
-            MraidView.ExpansionStyle expansionStyle,
-            NativeCloseButtonStyle buttonStyle,
-            MraidView.PlacementType placementType) {
-        return instance.internalCreate(context, adConfiguration, expansionStyle, buttonStyle, placementType);
-    }
-
-    protected MraidView internalCreate(Context context, AdConfiguration adConfiguration) {
-        return new MraidView(context, adConfiguration);
-    }
-
-    protected MraidView internalCreate(
-            Context context,
-            AdConfiguration adConfiguration,
-            MraidView.ExpansionStyle expansionStyle,
-            NativeCloseButtonStyle buttonStyle,
-            MraidView.PlacementType placementType) {
-        return new MraidView(context, adConfiguration, expansionStyle, buttonStyle, placementType);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java
index d562ffcc..68f918c2 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.util.vast.VastManager;
+import com.mopub.mobileads.VastManager;
 
 public class VastManagerFactory {
     protected static VastManagerFactory instance = new VastManagerFactory();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/ViewGestureDetectorFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/ViewGestureDetectorFactory.java
deleted file mode 100644
index d8e377c0..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/ViewGestureDetectorFactory.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import android.content.Context;
-import android.view.View;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.ViewGestureDetector;
-
-public class ViewGestureDetectorFactory {
-    protected static ViewGestureDetectorFactory instance = new ViewGestureDetectorFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(ViewGestureDetectorFactory factory) {
-        instance = factory;
-    }
-
-    public static ViewGestureDetector create(Context context, View view, AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, view, adConfiguration);
-    }
-
-    protected ViewGestureDetector internalCreate(Context context, View view, AdConfiguration adConfiguration) {
-        return new ViewGestureDetector(context, view, adConfiguration);
-    }
-}
-
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java
new file mode 100644
index 00000000..d12bf8e1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java
@@ -0,0 +1,34 @@
+package com.mopub.mobileads.resource;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+
+public abstract class BaseWidgetDrawable extends Drawable {
+    protected void drawTextWithinBounds(@NonNull final Canvas canvas,
+            @NonNull final Paint textPaint, @NonNull final Rect textRect,
+            @NonNull final String text) {
+        textPaint.getTextBounds(text, 0, text.length(), textRect);
+        final float textHeight = textPaint.descent() - textPaint.ascent();
+        final float textOffset = (textHeight / 2) - textPaint.descent();
+        canvas.drawText(text, getBounds().centerX(), getBounds().centerY() + textOffset, textPaint);
+    }
+
+    @Override
+    public void setAlpha(int i) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CircleDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CircleDrawable.java
deleted file mode 100644
index 3d604a87..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CircleDrawable.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package com.mopub.mobileads.resource;
-
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.ColorFilter;
-import android.graphics.Paint;
-import android.graphics.drawable.Drawable;
-
-public abstract class CircleDrawable extends Drawable {
-    private final Paint mPaint;
-
-    public CircleDrawable() {
-        super();
-
-        mPaint = new Paint();
-
-        mPaint.setAntiAlias(true);
-        mPaint.setStrokeWidth(3);
-        mPaint.setColor(Color.WHITE);
-        mPaint.setStyle(Paint.Style.STROKE);
-    }
-
-    @Override
-    public void draw(final Canvas canvas) {
-        canvas.drawCircle(getCenterX(), getCenterY(), getRadius(), mPaint);
-    }
-
-    @Override
-    public void setAlpha(int i) {
-
-    }
-
-    @Override
-    public void setColorFilter(ColorFilter colorFilter) {
-
-    }
-
-    @Override
-    public int getOpacity() {
-        return 0;
-    }
-
-    protected Paint getPaint() {
-        return mPaint;
-    }
-
-    protected int getCenterX() {
-        return getBounds().width() / 2;
-    }
-
-    protected int getCenterY() {
-        return getBounds().height() / 2;
-    }
-
-    protected int getRadius() {
-        return Math.min(getCenterX(), getCenterY());
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
index af32b51a..8fc410a5 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
@@ -1,48 +1,26 @@
 package com.mopub.mobileads.resource;
 
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Paint;
-import android.graphics.Path;
-import android.graphics.Point;
 
-public class CloseButtonDrawable extends CircleDrawable {
-    private Point centerPoint;
-    private Point bottomLeftPoint;
-    private Point topLeftPoint;
-    private Point topRightPoint;
-    private Point bottomRightPoint;
+public class CloseButtonDrawable extends BaseWidgetDrawable {
     private final Paint closeButtonPaint;
-    private int mDisplacement;
 
     public CloseButtonDrawable() {
         super();
 
-        closeButtonPaint = new Paint(getPaint());
-        closeButtonPaint.setStrokeWidth(4.5f);
-        closeButtonPaint.setStrokeCap(Paint.Cap.ROUND);
+        closeButtonPaint = new Paint();
+        closeButtonPaint.setColor(DrawableConstants.CloseButton.STROKE_COLOR);
+        closeButtonPaint.setStrokeWidth(DrawableConstants.CloseButton.STROKE_WIDTH);
+        closeButtonPaint.setStrokeCap(DrawableConstants.CloseButton.STROKE_CAP);
     }
 
     @Override
     public void draw(final Canvas canvas) {
-        super.draw(canvas);
-
-        mDisplacement = (int) (0.5f * getRadius() / (float) Math.sqrt(2f));
-
-        centerPoint = new Point(getCenterX(), getCenterY());
-
-        bottomLeftPoint = new Point(centerPoint);
-        bottomLeftPoint.offset(-mDisplacement, mDisplacement);
-
-        topLeftPoint = new Point(centerPoint);
-        topLeftPoint.offset(-mDisplacement, -mDisplacement);
-
-        topRightPoint = new Point(centerPoint);
-        topRightPoint.offset(mDisplacement, -mDisplacement);
-
-        bottomRightPoint = new Point(centerPoint);
-        bottomRightPoint.offset(mDisplacement, mDisplacement);
-
-        canvas.drawLine(bottomLeftPoint.x, bottomLeftPoint.y, topRightPoint.x, topRightPoint.y, closeButtonPaint);
-        canvas.drawLine(topLeftPoint.x, topLeftPoint.y, bottomRightPoint.x, bottomRightPoint.y, closeButtonPaint);
+        final int w = getBounds().width();
+        final int h = getBounds().height();
+        canvas.drawLine(0, h, w, 0, closeButtonPaint);
+        canvas.drawLine(0, 0, w, h, closeButtonPaint);
     }
-}
\ No newline at end of file
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CountdownDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CountdownDrawable.java
deleted file mode 100644
index 16fb2074..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CountdownDrawable.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.mopub.mobileads.resource;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.Rect;
-
-import com.mopub.common.util.Dips;
-
-public class CountdownDrawable extends CircleDrawable implements TextDrawable {
-    private final static float TEXT_SIZE_SP = 18f;
-    private final Paint mTextPaint;
-    private String mSecondsRemaining;
-    private final float textSizePixels;
-    private Rect mTextRect;
-
-    public CountdownDrawable(final Context context) {
-        super();
-
-        mSecondsRemaining = "";
-
-        mTextPaint = new Paint();
-
-        textSizePixels = Dips.dipsToFloatPixels(TEXT_SIZE_SP, context);
-
-        mTextPaint.setTextSize(textSizePixels);
-        mTextPaint.setAntiAlias(true);
-        mTextPaint.setColor(Color.WHITE);
-        mTextPaint.setStyle(Paint.Style.FILL);
-        mTextPaint.setTextAlign(Paint.Align.LEFT);
-
-        mTextRect = new Rect();
-    }
-
-    @Override
-    public void draw(final Canvas canvas) {
-        super.draw(canvas);
-
-        final String text = String.valueOf(mSecondsRemaining);
-
-        mTextPaint.getTextBounds(text, 0, text.length(), mTextRect);
-
-        final int x = getCenterX() - mTextRect.width() / 2;
-        final int y = getCenterY() + mTextRect.height() / 2;
-
-        canvas.drawText(text, x, y, mTextPaint);
-    }
-
-    /**
-     * TextDrawable implementation
-     */
-
-    public void updateText(final String text) {
-        if (!mSecondsRemaining.equals(text)) {
-            mSecondsRemaining = text;
-            invalidateSelf();
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CtaButtonDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CtaButtonDrawable.java
new file mode 100644
index 00000000..d3077bac
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CtaButtonDrawable.java
@@ -0,0 +1,83 @@
+package com.mopub.mobileads.resource;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.Dips;
+
+public class CtaButtonDrawable extends BaseWidgetDrawable {
+    @NonNull private final Paint mBackgroundPaint;
+    @NonNull private final Paint mOutlinePaint;
+    @NonNull private final Paint mTextPaint;
+    @NonNull private final RectF mButtonRect;
+    @NonNull private final Rect mTextRect;
+
+    private final int mButtonCornerRadius;
+    private String mCtaText;
+
+    public CtaButtonDrawable(@NonNull final Context context) {
+        super();
+
+        final int outlineStrokeWidth = Dips.dipsToIntPixels(
+                DrawableConstants.CtaButton.OUTLINE_STROKE_WIDTH_DIPS, context);
+        final float textSize = Dips.dipsToFloatPixels(
+                DrawableConstants.CtaButton.TEXT_SIZE_SP, context);
+
+        mBackgroundPaint = new Paint();
+        mBackgroundPaint.setColor(DrawableConstants.CtaButton.BACKGROUND_COLOR);
+        mBackgroundPaint.setAlpha(DrawableConstants.CtaButton.BACKGROUND_ALPHA);
+        mBackgroundPaint.setStyle(DrawableConstants.CtaButton.BACKGROUND_STYLE);
+        mBackgroundPaint.setAntiAlias(true);
+
+        mOutlinePaint = new Paint();
+        mOutlinePaint.setColor(DrawableConstants.CtaButton.OUTLINE_COLOR);
+        mOutlinePaint.setAlpha(DrawableConstants.CtaButton.OUTLINE_ALPHA);
+        mOutlinePaint.setStyle(DrawableConstants.CtaButton.OUTLINE_STYLE);
+        mOutlinePaint.setStrokeWidth(outlineStrokeWidth);
+        mOutlinePaint.setAntiAlias(true);
+
+        mTextPaint = new Paint();
+        mTextPaint.setColor(DrawableConstants.CtaButton.TEXT_COLOR);
+        mTextPaint.setTextAlign(DrawableConstants.CtaButton.TEXT_ALIGN);
+        mTextPaint.setTypeface(DrawableConstants.CtaButton.TEXT_TYPEFACE);
+        mTextPaint.setTextSize(textSize);
+        mTextPaint.setAntiAlias(true);
+
+        mTextRect = new Rect();
+        mCtaText = DrawableConstants.CtaButton.DEFAULT_CTA_TEXT;
+
+        mButtonRect = new RectF();
+        mButtonCornerRadius = Dips.dipsToIntPixels(DrawableConstants.CtaButton.CORNER_RADIUS_DIPS, context);
+    }
+
+    @Override
+    public void draw(final Canvas canvas) {
+        mButtonRect.set(getBounds());
+
+        // Rounded rectangle background fill
+        canvas.drawRoundRect(mButtonRect, mButtonCornerRadius, mButtonCornerRadius, mBackgroundPaint);
+
+        // Rounded rectangle outline
+        canvas.drawRoundRect(mButtonRect, mButtonCornerRadius, mButtonCornerRadius, mOutlinePaint);
+
+        // CTA text
+        drawTextWithinBounds(canvas, mTextPaint, mTextRect, mCtaText);
+    }
+
+    public void setCtaText(@NonNull final String ctaText) {
+        mCtaText = ctaText;
+        invalidateSelf();
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    public String getCtaText() {
+        return mCtaText;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
new file mode 100644
index 00000000..5c2b844f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
@@ -0,0 +1,91 @@
+package com.mopub.mobileads.resource;
+
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+
+public class DrawableConstants {
+
+    public static class ProgressBar {
+        public static final int HEIGHT_DIPS = 4;
+        public static final int NUGGET_WIDTH_DIPS = 4;
+
+        public static final int BACKGROUND_COLOR = Color.WHITE;
+        public static final int BACKGROUND_ALPHA = 128;
+        public static final Paint.Style BACKGROUND_STYLE = Paint.Style.FILL;
+
+        public static final int PROGRESS_COLOR = Color.parseColor("#FFCC4D");
+        public static final int PROGRESS_ALPHA = 255;
+        public static final Paint.Style PROGRESS_STYLE = Paint.Style.FILL;
+    }
+
+    public static class RadialCountdown {
+        public static final int SIDE_LENGTH_DIPS = 45;
+        public static final int TOP_MARGIN_DIPS = 16;
+        public static final int RIGHT_MARGIN_DIPS = 16;
+        public static final int PADDING_DIPS = 5;
+
+        public static final int CIRCLE_STROKE_WIDTH_DIPS = 3;
+        public static final float TEXT_SIZE_SP = 18f;
+        public static final float START_ANGLE = -90f;
+
+        public static final int BACKGROUND_COLOR = Color.WHITE;
+        public static final int BACKGROUND_ALPHA = 128;
+        public static final Paint.Style BACKGROUND_STYLE = Paint.Style.STROKE;
+
+        public static final int PROGRESS_COLOR = Color.WHITE;
+        public static final int PROGRESS_ALPHA = 255;
+        public static final Paint.Style PROGRESS_STYLE = Paint.Style.STROKE;
+
+        public static final int TEXT_COLOR = Color.WHITE;
+        public static final Paint.Align TEXT_ALIGN = Paint.Align.CENTER;
+    }
+
+    public static class CtaButton {
+        public static final int WIDTH_DIPS = 200;
+        public static final int HEIGHT_DIPS = 42;
+        public static final int MARGIN_DIPS = 16;
+        public static final int CORNER_RADIUS_DIPS = 6;
+        public static final int OUTLINE_STROKE_WIDTH_DIPS = 2;
+        public static final float TEXT_SIZE_SP = 20f;
+
+        public static final int BACKGROUND_COLOR = Color.BLACK;
+        public static final int BACKGROUND_ALPHA = 51;
+        public static final Paint.Style BACKGROUND_STYLE = Paint.Style.FILL;
+
+        public static final int OUTLINE_COLOR = Color.WHITE;
+        public static final int OUTLINE_ALPHA = 51;
+        public static final Paint.Style OUTLINE_STYLE = Paint.Style.STROKE;
+
+        public static final String DEFAULT_CTA_TEXT = "Learn More";
+        public static final Typeface TEXT_TYPEFACE = Typeface.create("Helvetica", Typeface.BOLD);
+        public static final int TEXT_COLOR = Color.WHITE;
+        public static final Paint.Align TEXT_ALIGN = Paint.Align.CENTER;
+    }
+    
+    public static class CloseButton {
+        public static final int WIDGET_HEIGHT_DIPS = 46;
+        public static final int EDGE_PADDING = 16;
+        public static final int IMAGE_PADDING_DIPS = 5;
+        public static final int TEXT_RIGHT_MARGIN_DIPS = 7;
+        public static final float TEXT_SIZE_SP = 20f;
+
+        public static final int STROKE_COLOR = Color.WHITE;
+        public static final float STROKE_WIDTH = 8f;
+        public static final Paint.Cap STROKE_CAP = Paint.Cap.ROUND;
+
+        public static final String DEFAULT_CLOSE_BUTTON_TEXT = "";
+        public static final Typeface TEXT_TYPEFACE = Typeface.create("Helvetica", Typeface.NORMAL);
+        public static final int TEXT_COLOR = Color.WHITE;
+    }
+    
+    public static class GradientStrip {
+        public static final int GRADIENT_STRIP_HEIGHT_DIPS = 72;
+        public static final int START_COLOR = Color.argb(102, 0, 0, 0);
+        public static final int END_COLOR = Color.argb(0, 255, 255, 255);
+    }
+
+    public static class BlurredLastVideoFrame {
+        public static final int ALPHA = 128;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/LearnMoreDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/LearnMoreDrawable.java
deleted file mode 100644
index 0ab64cc8..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/LearnMoreDrawable.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package com.mopub.mobileads.resource;
-
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.Point;
-
-public class LearnMoreDrawable extends CircleDrawable {
-
-    private final Paint learnMorePaint;
-    private Point centerPoint;
-    private Point bottomLeftPoint;
-    private Point topRightPoint;
-    private Point leftBarbPoint;
-    private Point rightBarbPoint;
-    private int mDisplacement;
-    private int mBarbLength;
-
-    public LearnMoreDrawable() {
-        super();
-
-        learnMorePaint = new Paint(getPaint());
-        learnMorePaint.setStrokeWidth(4.5f);
-        learnMorePaint.setStrokeCap(Paint.Cap.ROUND);
-    }
-
-    @Override
-    public void draw(final Canvas canvas) {
-        super.draw(canvas);
-
-        mDisplacement = (int) (0.5f * getRadius() / Math.sqrt(2f));
-        mBarbLength = (int) (1.5f * mDisplacement);
-
-        centerPoint = new Point(getCenterX(), getCenterY());
-
-        bottomLeftPoint = new Point(centerPoint);
-        bottomLeftPoint.offset(-mDisplacement, mDisplacement);
-
-        topRightPoint = new Point(centerPoint);
-        topRightPoint.offset(mDisplacement, -mDisplacement);
-
-        leftBarbPoint = new Point(topRightPoint);
-        leftBarbPoint.offset(-mBarbLength, 0);
-
-        rightBarbPoint = new Point(topRightPoint);
-        rightBarbPoint.offset(0, mBarbLength);
-
-        canvas.drawLine(bottomLeftPoint.x, bottomLeftPoint.y, topRightPoint.x, topRightPoint.y, learnMorePaint);
-        canvas.drawLine(topRightPoint.x, topRightPoint.y, leftBarbPoint.x, leftBarbPoint.y, learnMorePaint);
-        canvas.drawLine(topRightPoint.x, topRightPoint.y, rightBarbPoint.x, rightBarbPoint.y, learnMorePaint);
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
index 94228d44..7071ffa0 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
@@ -17,63 +17,48 @@
             "  }\n" +
             "}());\n" +
             "\n" +
-            "(function() {\n" +
-            "  // Establish the root mraidbridge object.\n" +
-            "  var mraidbridge = window.mraidbridge = {};\n" +
-            "\n" +
-            "  // native SDK is ready to process mraid commands.\n" +
-            "  var nativeSDKFiredReady = false;\n" +
-            "\n" +
-            "  // Listeners for bridge events.\n" +
-            "  var listeners = {};\n" +
-            "\n" +
-            "  // Queue to track pending calls to the native SDK.\n" +
-            "  var nativeCallQueue = [];\n" +
             "\n" +
-            "  // Whether a native call is currently in progress.\n" +
-            "  var nativeCallInFlight = false;\n" +
+            "(function() {\n" +
+            "  var mraid = window.mraid = {};\n" +
             "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  mraidbridge.fireReadyEvent = function() {\n" +
-            "    nativeSDKFiredReady = true;\n" +
-            "    mraidbridge.fireEvent('ready');\n" +
-            "  };\n" +
+            "  // Bridge interface to SDK\n" +
             "\n" +
-            "  mraidbridge.fireChangeEvent = function(properties) {\n" +
-            "    mraidbridge.fireEvent('change', properties);\n" +
+            "  var bridge = window.mraidbridge = {\n" +
+            "    nativeSDKFiredReady: false,\n" +
+            "    nativeCallQueue: [],\n" +
+            "    nativeCallInFlight: false,\n" +
+            "    lastSizeChangeProperties: null\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.fireErrorEvent = function(message, action) {\n" +
-            "    mraidbridge.fireEvent('error', message, action);\n" +
-            "  };\n" +
             "\n" +
-            "  mraidbridge.fireEvent = function(type) {\n" +
-            "    var ls = listeners[type];\n" +
-            "    if (ls) {\n" +
-            "      var args = Array.prototype.slice.call(arguments);\n" +
-            "      args.shift();\n" +
-            "      var l = ls.length;\n" +
-            "      for (var i = 0; i < l; i++) {\n" +
-            "        ls[i].apply(null, args);\n" +
+            "  bridge.fireChangeEvent = function(properties) {\n" +
+            "    for (var p in properties) {\n" +
+            "      if (properties.hasOwnProperty(p)) {\n" +
+            "        // Change handlers defined by MRAID below\n" +
+            "        var handler = changeHandlers[p];\n" +
+            "        handler(properties[p]);\n" +
             "      }\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.nativeCallComplete = function(command) {\n" +
-            "    if (nativeCallQueue.length === 0) {\n" +
-            "      nativeCallInFlight = false;\n" +
+            "  bridge.nativeCallComplete = function(command) {\n" +
+            "    if (this.nativeCallQueue.length === 0) {\n" +
+            "      this.nativeCallInFlight = false;\n" +
             "      return;\n" +
             "    }\n" +
             "\n" +
-            "    var nextCall = nativeCallQueue.pop();\n" +
+            "    var nextCall = this.nativeCallQueue.pop();\n" +
             "    window.location = nextCall;\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.executeNativeCall = function(command) {\n" +
-            "    if (!nativeSDKFiredReady) {\n" +
+            "  bridge.executeNativeCall = function(args) {\n" +
+            "    var command = args.shift();\n" +
+            "\n" +
+            "    if (!this.nativeSDKFiredReady) {\n" +
             "        console.log('rejecting ' + command + ' because mraid is not ready');\n" +
-            "        mraidbridge.fireErrorEvent('mraid is not ready', command);\n" +
+            "        bridge.notifyErrorEvent('mraid is not ready', command);\n" +
             "        return;\n" +
             "    }\n" +
             "\n" +
@@ -82,9 +67,9 @@
             "    var key, value;\n" +
             "    var isFirstArgument = true;\n" +
             "\n" +
-            "    for (var i = 1; i < arguments.length; i += 2) {\n" +
-            "      key = arguments[i];\n" +
-            "      value = arguments[i + 1];\n" +
+            "    for (var i = 0; i < args.length; i += 2) {\n" +
+            "      key = args[i];\n" +
+            "      value = args[i + 1];\n" +
             "\n" +
             "      if (value === null) continue;\n" +
             "\n" +
@@ -98,55 +83,133 @@
             "      call += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n" +
             "    }\n" +
             "\n" +
-            "    if (nativeCallInFlight) {\n" +
-            "      nativeCallQueue.push(call);\n" +
+            "    if (this.nativeCallInFlight) {\n" +
+            "      this.nativeCallQueue.push(call);\n" +
             "    } else {\n" +
-            "      nativeCallInFlight = true;\n" +
+            "      this.nativeCallInFlight = true;\n" +
             "      window.location = call;\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  mraidbridge.addEventListener = function(event, listener) {\n" +
-            "    var eventListeners;\n" +
-            "    listeners[event] = listeners[event] || [];\n" +
-            "    eventListeners = listeners[event];\n" +
+            "  bridge.setCurrentPosition = function(x, y, width, height) {\n" +
+            "    currentPosition = {\n" +
+            "      x: x,\n" +
+            "      y: y,\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set current position to ' + stringify(currentPosition));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setDefaultPosition = function(x, y, width, height) {\n" +
+            "    defaultPosition = {\n" +
+            "      x: x,\n" +
+            "      y: y,\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set default position to ' + stringify(defaultPosition));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setMaxSize = function(width, height) {\n" +
+            "    maxSize = {\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "\n" +
+            "    expandProperties.width = width;\n" +
+            "    expandProperties.height = height;\n" +
             "\n" +
-            "    for (var l in eventListeners) {\n" +
-            "      // Listener already registered, so no need to add it.\n" +
-            "      if (listener === l) return;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set max size to ' + stringify(maxSize));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setPlacementType = function(_placementType) {\n" +
+            "    placementType = _placementType;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set placement type to ' + stringify(placementType));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setScreenSize = function(width, height) {\n" +
+            "    screenSize = {\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set screen size to ' + stringify(screenSize));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setState = function(_state) {\n" +
+            "    state = _state;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));\n" +
+            "    broadcastEvent(EVENTS.STATECHANGE, state);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setIsViewable = function(_isViewable) {\n" +
+            "    isViewable = _isViewable;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));\n" +
+            "    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setSupports = function(sms, tel, calendar, storePicture, inlineVideo) {\n" +
+            "    supportProperties = {\n" +
+            "      sms: sms,\n" +
+            "      tel: tel,\n" +
+            "      calendar: calendar,\n" +
+            "      storePicture: storePicture,\n" +
+            "      inlineVideo: inlineVideo\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyReadyEvent = function() {\n" +
+            "    this.nativeSDKFiredReady = true;\n" +
+            "    broadcastEvent(EVENTS.READY);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyErrorEvent = function(message, action) {\n" +
+            "    broadcastEvent(EVENTS.ERROR, message, action);\n" +
+            "  };\n" +
+            "\n" +
+            "  // Temporary aliases while we migrate to the new API\n" +
+            "  bridge.fireReadyEvent = bridge.notifyReadyEvent;\n" +
+            "  bridge.fireErrorEvent = bridge.notifyErrorEvent;\n" +
+            "\n" +
+            "  bridge.notifySizeChangeEvent = function(width, height) {\n" +
+            "    if (this.lastSizeChangeProperties &&\n" +
+            "          width == this.lastSizeChangeProperties.width && height == this.lastSizeChangeProperties.height) {\n" +
+            "      return;\n" +
             "    }\n" +
             "\n" +
-            "    eventListeners.push(listener);\n" +
+            "    this.lastSizeChangeProperties = {\n" +
+            "        width: width,\n" +
+            "        height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.SIZECHANGE, width, height);\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.removeEventListener = function(event, listener) {\n" +
-            "    if (listeners.hasOwnProperty(event)) {\n" +
-            "      var eventListeners = listeners[event];\n" +
-            "      if (eventListeners) {\n" +
-            "        var idx = eventListeners.indexOf(listener);\n" +
-            "        if (idx !== -1) {\n" +
-            "          eventListeners.splice(idx, 1);\n" +
-            "        }\n" +
-            "      }\n" +
+            "  bridge.notifyStateChangeEvent = function() {\n" +
+            "    if (state === STATES.LOADING) {\n" +
+            "      broadcastEvent(EVENTS.INFO, 'Native SDK initialized.');\n" +
             "    }\n" +
+            "\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));\n" +
+            "    broadcastEvent(EVENTS.STATECHANGE, state);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyViewableChangeEvent = function() {\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));\n" +
+            "    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);\n" +
             "  };\n" +
-            "}());\n" +
             "\n" +
-            "(function() {\n" +
-            "  var mraid = window.mraid = {};\n" +
-            "  var bridge = window.mraidbridge;\n" +
             "\n" +
             "  // Constants. ////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  var VERSION = mraid.VERSION = '1.0';\n" +
+            "  var VERSION = mraid.VERSION = '2.0';\n" +
             "\n" +
             "  var STATES = mraid.STATES = {\n" +
-            "    LOADING: 'loading',     // Initial state.\n" +
+            "    LOADING: 'loading',\n" +
             "    DEFAULT: 'default',\n" +
             "    EXPANDED: 'expanded',\n" +
-            "    HIDDEN: 'hidden'\n" +
+            "    HIDDEN: 'hidden',\n" +
+            "    RESIZED: 'resized'\n" +
             "  };\n" +
             "\n" +
             "  var EVENTS = mraid.EVENTS = {\n" +
@@ -154,7 +217,8 @@
             "    INFO: 'info',\n" +
             "    READY: 'ready',\n" +
             "    STATECHANGE: 'stateChange',\n" +
-            "    VIEWABLECHANGE: 'viewableChange'\n" +
+            "    VIEWABLECHANGE: 'viewableChange',\n" +
+            "    SIZECHANGE: 'sizeChange'\n" +
             "  };\n" +
             "\n" +
             "  var PLACEMENT_TYPES = mraid.PLACEMENT_TYPES = {\n" +
@@ -167,14 +231,44 @@
             "\n" +
             "  // Properties which define the behavior of an expandable ad.\n" +
             "  var expandProperties = {\n" +
-            "    width: -1,\n" +
-            "    height: -1,\n" +
+            "    width: false,\n" +
+            "    height: false,\n" +
             "    useCustomClose: false,\n" +
-            "    isModal: true,\n" +
-            "    lockOrientation: false\n" +
+            "    isModal: true\n" +
+            "  };\n" +
+            "\n" +
+            "  var resizeProperties = {\n" +
+            "    width: false,\n" +
+            "    height: false,\n" +
+            "    offsetX: false,\n" +
+            "    offsetY: false,\n" +
+            "    customClosePosition: 'top-right',\n" +
+            "    allowOffscreen: true\n" +
+            "  };\n" +
+            "\n" +
+            "  var orientationProperties = {\n" +
+            "    allowOrientationChange: true,\n" +
+            "    forceOrientation: \"none\"\n" +
+            "  };\n" +
+            "\n" +
+            "  var supportProperties = {\n" +
+            "    sms: false,\n" +
+            "    tel: false,\n" +
+            "    calendar: false,\n" +
+            "    storePicture: false,\n" +
+            "    inlineVideo: false\n" +
             "  };\n" +
             "\n" +
-            "  var hasSetCustomSize = false;\n" +
+            "  // default is undefined so that notifySizeChangeEvent can track changes\n" +
+            "  var lastSizeChangeProperties;\n" +
+            "\n" +
+            "  var maxSize = {};\n" +
+            "\n" +
+            "  var currentPosition = {};\n" +
+            "\n" +
+            "  var defaultPosition = {};\n" +
+            "\n" +
+            "  var screenSize = {};\n" +
             "\n" +
             "  var hasSetCustomClose = false;\n" +
             "\n" +
@@ -186,18 +280,8 @@
             "\n" +
             "  var isViewable = false;\n" +
             "\n" +
-            "  var screenSize = { width: -1, height: -1 };\n" +
-            "\n" +
             "  var placementType = PLACEMENT_TYPES.UNKNOWN;\n" +
             "\n" +
-            "  var supports = {\n" +
-            "    sms: false,\n" +
-            "    tel: false,\n" +
-            "    calendar: false,\n" +
-            "    storePicture: false,\n" +
-            "    inlineVideo: false\n" +
-            "  };\n" +
-            "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
             "  var EventListeners = function(event) {\n" +
@@ -233,7 +317,7 @@
             "\n" +
             "    this.broadcast = function(args) {\n" +
             "      for (var id in listeners) {\n" +
-            "        if (listeners.hasOwnProperty(id)) listeners[id].apply({}, args);\n" +
+            "        if (listeners.hasOwnProperty(id)) listeners[id].apply(mraid, args);\n" +
             "      }\n" +
             "    };\n" +
             "\n" +
@@ -309,29 +393,17 @@
             "      placementType = val;\n" +
             "    },\n" +
             "\n" +
-            "    screenSize: function(val) {\n" +
+            "    sizeChange: function(val) {\n" +
             "      broadcastEvent(EVENTS.INFO, 'Set screenSize to ' + stringify(val));\n" +
             "      for (var key in val) {\n" +
             "        if (val.hasOwnProperty(key)) screenSize[key] = val[key];\n" +
             "      }\n" +
-            "\n" +
-            "      if (!hasSetCustomSize) {\n" +
-            "        expandProperties['width'] = screenSize['width'];\n" +
-            "        expandProperties['height'] = screenSize['height'];\n" +
-            "      }\n" +
-            "    },\n" +
-            "\n" +
-            "    expandProperties: function(val) {\n" +
-            "      broadcastEvent(EVENTS.INFO, 'Merging expandProperties with ' + stringify(val));\n" +
-            "      for (var key in val) {\n" +
-            "        if (val.hasOwnProperty(key)) expandProperties[key] = val[key];\n" +
-            "      }\n" +
             "    },\n" +
             "\n" +
             "    supports: function(val) {\n" +
             "      broadcastEvent(EVENTS.INFO, 'Set supports to ' + stringify(val));\n" +
-            "        supports = val;\n" +
-            "    },\n" +
+            "        supportProperties = val;\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
             "  var validate = function(obj, validators, action, merge) {\n" +
@@ -343,7 +415,7 @@
             "      } else {\n" +
             "        for (var i in validators) {\n" +
             "          if (validators.hasOwnProperty(i) && obj[i] === undefined) {\n" +
-            "            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i + '.', action);\n" +
+            "            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i, action);\n" +
             "            return false;\n" +
             "          }\n" +
             "        }\n" +
@@ -355,8 +427,7 @@
             "      var value = obj[prop];\n" +
             "      if (validator && !validator(value)) {\n" +
             "        // Failed validation.\n" +
-            "        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid.',\n" +
-            "          action);\n" +
+            "        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid: ' + value, action);\n" +
             "        return false;\n" +
             "      }\n" +
             "    }\n" +
@@ -364,40 +435,20 @@
             "  };\n" +
             "\n" +
             "  var expandPropertyValidators = {\n" +
-            "    width: function(v) { return !isNaN(v) && v >= 0; },\n" +
-            "    height: function(v) { return !isNaN(v) && v >= 0; },\n" +
             "    useCustomClose: function(v) { return (typeof v === 'boolean'); },\n" +
-            "    lockOrientation: function(v) { return (typeof v === 'boolean'); }\n" +
             "  };\n" +
             "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  bridge.addEventListener('change', function(properties) {\n" +
-            "    for (var p in properties) {\n" +
-            "      if (properties.hasOwnProperty(p)) {\n" +
-            "        var handler = changeHandlers[p];\n" +
-            "        handler(properties[p]);\n" +
-            "      }\n" +
-            "    }\n" +
-            "  });\n" +
-            "\n" +
-            "  bridge.addEventListener('error', function(message, action) {\n" +
-            "    broadcastEvent(EVENTS.ERROR, message, action);\n" +
-            "  });\n" +
-            "\n" +
-            "  bridge.addEventListener('ready', function() {\n" +
-            "    broadcastEvent(EVENTS.READY);\n" +
-            "  });\n" +
-            "\n" +
-            "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
-            "\n" +
             "  mraid.addEventListener = function(event, listener) {\n" +
             "    if (!event || !listener) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Both event and listener are required.', 'addEventListener');\n" +
             "    } else if (!contains(event, EVENTS)) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Unknown MRAID event: ' + event, 'addEventListener');\n" +
             "    } else {\n" +
-            "      if (!listeners[event]) listeners[event] = new EventListeners(event);\n" +
+            "      if (!listeners[event]) {\n" +
+            "        listeners[event] = new EventListeners(event);\n" +
+            "      }\n" +
             "      listeners[event].add(listener);\n" +
             "    }\n" +
             "  };\n" +
@@ -406,45 +457,25 @@
             "    if (state === STATES.HIDDEN) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Ad cannot be closed when it is already hidden.',\n" +
             "        'close');\n" +
-            "    } else bridge.executeNativeCall('close');\n" +
+            "    } else bridge.executeNativeCall(['close']);\n" +
             "  };\n" +
             "\n" +
             "  mraid.expand = function(URL) {\n" +
-            "    if (this.getState() !== STATES.DEFAULT) {\n" +
-            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default state.', 'expand');\n" +
+            "    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default or resized state.', 'expand');\n" +
             "    } else {\n" +
-            "      var args = ['expand'];\n" +
-            "\n" +
-            "      if (this.getHasSetCustomClose()) {\n" +
-            "        args = args.concat(['shouldUseCustomClose', expandProperties.useCustomClose ? 'true' : 'false']);\n" +
-            "      }\n" +
-            "\n" +
-            "      if (this.getHasSetCustomSize()) {\n" +
-            "        if (expandProperties.width >= 0 && expandProperties.height >= 0) {\n" +
-            "          args = args.concat(['w', expandProperties.width, 'h', expandProperties.height]);\n" +
-            "        }\n" +
-            "      }\n" +
-            "\n" +
-            "      if (typeof expandProperties.lockOrientation !== 'undefined') {\n" +
-            "        args = args.concat(['lockOrientation', expandProperties.lockOrientation]);\n" +
-            "      }\n" +
+            "      var args = ['expand',\n" +
+            "        'shouldUseCustomClose', expandProperties.useCustomClose\n" +
+            "      ];\n" +
             "\n" +
             "      if (URL) {\n" +
             "        args = args.concat(['url', URL]);\n" +
             "      }\n" +
             "\n" +
-            "      bridge.executeNativeCall.apply(this, args);\n" +
+            "      bridge.executeNativeCall(args);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getHasSetCustomClose = function() {\n" +
-            "      return hasSetCustomClose;\n" +
-            "  };\n" +
-            "\n" +
-            "  mraid.getHasSetCustomSize = function() {\n" +
-            "      return hasSetCustomSize;\n" +
-            "  };\n" +
-            "\n" +
             "  mraid.getExpandProperties = function() {\n" +
             "    var properties = {\n" +
             "      width: expandProperties.width,\n" +
@@ -455,56 +486,93 @@
             "    return properties;\n" +
             "  };\n" +
             "\n" +
+            "\n" +
+            "  mraid.getCurrentPosition = function() {\n" +
+            "    return {\n" +
+            "      x: currentPosition.x,\n" +
+            "      y: currentPosition.y,\n" +
+            "      width: currentPosition.width,\n" +
+            "      height: currentPosition.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  mraid.getDefaultPosition = function() {\n" +
+            "    return {\n" +
+            "      x: defaultPosition.x,\n" +
+            "      y: defaultPosition.y,\n" +
+            "      width: defaultPosition.width,\n" +
+            "      height: defaultPosition.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  mraid.getMaxSize = function() {\n" +
+            "    return {\n" +
+            "      width: maxSize.width,\n" +
+            "      height: maxSize.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
             "  mraid.getPlacementType = function() {\n" +
             "    return placementType;\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getState = function() {\n" +
-            "    return state;\n" +
+            "  mraid.getScreenSize = function() {\n" +
+            "    return {\n" +
+            "      width: screenSize.width,\n" +
+            "      height: screenSize.height\n" +
+            "    };\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getVersion = function() {\n" +
-            "    return mraid.VERSION;\n" +
+            "  mraid.getState = function() {\n" +
+            "    return state;\n" +
             "  };\n" +
             "\n" +
             "  mraid.isViewable = function() {\n" +
             "    return isViewable;\n" +
             "  };\n" +
             "\n" +
+            "  mraid.getVersion = function() {\n" +
+            "    return mraid.VERSION;\n" +
+            "  };\n" +
+            "\n" +
             "  mraid.open = function(URL) {\n" +
             "    if (!URL) broadcastEvent(EVENTS.ERROR, 'URL is required.', 'open');\n" +
-            "    else bridge.executeNativeCall('open', 'url', URL);\n" +
+            "    else bridge.executeNativeCall(['open', 'url', URL]);\n" +
             "  };\n" +
             "\n" +
             "  mraid.removeEventListener = function(event, listener) {\n" +
-            "    if (!event) broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');\n" +
-            "    else {\n" +
-            "      if (listener && (!listeners[event] || !listeners[event].remove(listener))) {\n" +
-            "        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.',\n" +
-            "          'removeEventListener');\n" +
-            "        return;\n" +
-            "      } else if (listeners[event]) listeners[event].removeAll();\n" +
+            "    if (!event) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');\n" +
+            "      return;\n" +
+            "    }\n" +
             "\n" +
-            "      if (listeners[event] && listeners[event].count === 0) {\n" +
-            "        listeners[event] = null;\n" +
-            "        delete listeners[event];\n" +
+            "    if (listener) {\n" +
+            "      // If we have a valid event, we'll try to remove the listener from it.\n" +
+            "      var success = false;\n" +
+            "      if (listeners[event]) {\n" +
+            "        success = listeners[event].remove(listener);\n" +
+            "      }\n" +
+            "\n" +
+            "      // If we didn't have a valid event or couldn't remove the listener from the event, broadcast an error and return early.\n" +
+            "      if (!success) {\n" +
+            "        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.', 'removeEventListener');\n" +
+            "        return;\n" +
             "      }\n" +
+            "\n" +
+            "    } else if (!listener && listeners[event]) {\n" +
+            "      listeners[event].removeAll();\n" +
+            "    }\n" +
+            "\n" +
+            "    if (listeners[event] && listeners[event].count === 0) {\n" +
+            "      listeners[event] = null;\n" +
+            "      delete listeners[event];\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
             "  mraid.setExpandProperties = function(properties) {\n" +
             "    if (validate(properties, expandPropertyValidators, 'setExpandProperties', true)) {\n" +
-            "      if (properties.hasOwnProperty('width') || properties.hasOwnProperty('height')) {\n" +
-            "        hasSetCustomSize = true;\n" +
-            "      }\n" +
-            "\n" +
-            "      if (properties.hasOwnProperty('useCustomClose')) hasSetCustomClose = true;\n" +
-            "\n" +
-            "      var desiredProperties = ['width', 'height', 'useCustomClose', 'lockOrientation'];\n" +
-            "      var length = desiredProperties.length;\n" +
-            "      for (var i = 0; i < length; i++) {\n" +
-            "        var propname = desiredProperties[i];\n" +
-            "        if (properties.hasOwnProperty(propname)) expandProperties[propname] = properties[propname];\n" +
+            "      if (properties.hasOwnProperty('useCustomClose')) {\n" +
+            "        expandProperties.useCustomClose = properties.useCustomClose;\n" +
             "      }\n" +
             "    }\n" +
             "  };\n" +
@@ -512,7 +580,7 @@
             "  mraid.useCustomClose = function(shouldUseCustomClose) {\n" +
             "    expandProperties.useCustomClose = shouldUseCustomClose;\n" +
             "    hasSetCustomClose = true;\n" +
-            "    bridge.executeNativeCall('usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose);\n" +
+            "    bridge.executeNativeCall(['usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose]);\n" +
             "  };\n" +
             "\n" +
             "  // MRAID 2.0 APIs ////////////////////////////////////////////////////////////////////////////////\n" +
@@ -520,14 +588,14 @@
             "  mraid.createCalendarEvent = function(parameters) {\n" +
             "    CalendarEventParser.initialize(parameters);\n" +
             "    if (CalendarEventParser.parse()) {\n" +
-            "      bridge.executeNativeCall.apply(this, CalendarEventParser.arguments);\n" +
+            "      bridge.executeNativeCall(CalendarEventParser.arguments);\n" +
             "    } else {\n" +
             "      broadcastEvent(EVENTS.ERROR, CalendarEventParser.errors[0], 'createCalendarEvent');\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
             "  mraid.supports = function(feature) {\n" +
-            "    return supports[feature];\n" +
+            "    return supportProperties[feature];\n" +
             "  };\n" +
             "\n" +
             "  mraid.playVideo = function(uri) {\n" +
@@ -539,7 +607,7 @@
             "    if (!uri) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'playVideo must be called with a valid URI', 'playVideo');\n" +
             "    } else {\n" +
-            "      bridge.executeNativeCall.apply(this, ['playVideo', 'uri', uri]);\n" +
+            "      bridge.executeNativeCall(['playVideo', 'uri', uri]);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
@@ -552,36 +620,102 @@
             "    if (!uri) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'storePicture must be called with a valid URI', 'storePicture');\n" +
             "    } else {\n" +
-            "      bridge.executeNativeCall.apply(this, ['storePicture', 'uri', uri]);\n" +
+            "      bridge.executeNativeCall(['storePicture', 'uri', uri]);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.resize = function() {\n" +
-            "    bridge.executeNativeCall('resize');\n" +
-            "  };\n" +
             "\n" +
-            "  mraid.getResizeProperties = function() {\n" +
-            "    bridge.executeNativeCall('getResizeProperties');\n" +
+            "  var resizePropertyValidators = {\n" +
+            "    width: function(v) {\n" +
+            "      return !isNaN(v) && v > 0;\n" +
+            "    },\n" +
+            "    height: function(v) {\n" +
+            "      return !isNaN(v) && v > 0;\n" +
+            "    },\n" +
+            "    offsetX: function(v) {\n" +
+            "      return !isNaN(v);\n" +
+            "    },\n" +
+            "    offsetY: function(v) {\n" +
+            "      return !isNaN(v);\n" +
+            "    },\n" +
+            "    customClosePosition: function(v) {\n" +
+            "      return (typeof v === 'string' &&\n" +
+            "        ['top-right', 'bottom-right', 'top-left', 'bottom-left', 'center', 'top-center', 'bottom-center'].indexOf(v) > -1);\n" +
+            "    },\n" +
+            "    allowOffscreen: function(v) {\n" +
+            "      return (typeof v === 'boolean');\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.setResizeProperties = function(resizeProperties) {\n" +
-            "    bridge.executeNativeCall('setResizeProperties', 'resizeProperties', resizeProperties);\n" +
+            "  mraid.setOrientationProperties = function(properties) {\n" +
+            "\n" +
+            "    if (properties.hasOwnProperty('allowOrientationChange')) {\n" +
+            "      orientationProperties.allowOrientationChange = properties.allowOrientationChange;\n" +
+            "    }\n" +
+            "\n" +
+            "    if (properties.hasOwnProperty('forceOrientation')) {\n" +
+            "      orientationProperties.forceOrientation = properties.forceOrientation;\n" +
+            "    }\n" +
+            "\n" +
+            "    var args = ['setOrientationProperties',\n" +
+            "      'allowOrientationChange', orientationProperties.allowOrientationChange,\n" +
+            "      'forceOrientation', orientationProperties.forceOrientation\n" +
+            "    ];\n" +
+            "    bridge.executeNativeCall(args);\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getCurrentPosition = function() {\n" +
-            "    bridge.executeNativeCall('getCurrentPosition');\n" +
+            "  mraid.getOrientationProperties = function() {\n" +
+            "    return {\n" +
+            "      allowOrientationChange: orientationProperties.allowOrientationChange,\n" +
+            "      forceOrientation: orientationProperties.forceOrientation\n" +
+            "    };\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getDefaultPosition = function() {\n" +
-            "    bridge.executeNativeCall('getDefaultPosition');\n" +
+            "  mraid.resize = function() {\n" +
+            "    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be resized from the default or resized state.', 'resize');\n" +
+            "    } else if (!resizeProperties.width || !resizeProperties.height) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Must set resize properties before calling resize()', 'resize');\n" +
+            "    } else {\n" +
+            "      var args = ['resize',\n" +
+            "        'width', resizeProperties.width,\n" +
+            "        'height', resizeProperties.height,\n" +
+            "        'offsetX', resizeProperties.offsetX || 0,\n" +
+            "        'offsetY', resizeProperties.offsetY || 0,\n" +
+            "        'customClosePosition', resizeProperties.customClosePosition,\n" +
+            "        'allowOffscreen', !!resizeProperties.allowOffscreen\n" +
+            "        ];\n" +
+            "\n" +
+            "      bridge.executeNativeCall(args);\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getMaxSize = function() {\n" +
-            "    bridge.executeNativeCall('getMaxSize');\n" +
+            "  mraid.getResizeProperties = function() {\n" +
+            "    var properties = {\n" +
+            "      width: resizeProperties.width,\n" +
+            "      height: resizeProperties.height,\n" +
+            "      offsetX: resizeProperties.offsetX,\n" +
+            "      offsetY: resizeProperties.offsetY,\n" +
+            "      customClosePosition: resizeProperties.customClosePosition,\n" +
+            "      allowOffscreen: resizeProperties.allowOffscreen\n" +
+            "    };\n" +
+            "    return properties;\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getScreenSize = function() {\n" +
-            "    bridge.executeNativeCall('getScreenSize');\n" +
+            "  mraid.setResizeProperties = function(properties) {\n" +
+            "    if (validate(properties, resizePropertyValidators, 'setResizeProperties', true)) {\n" +
+            "\n" +
+            "      var desiredProperties = ['width', 'height', 'offsetX', 'offsetY', 'customClosePosition', 'allowOffscreen'];\n" +
+            "\n" +
+            "      var length = desiredProperties.length;\n" +
+            "\n" +
+            "      for (var i = 0; i < length; i++) {\n" +
+            "        var propname = desiredProperties[i];\n" +
+            "        if (properties.hasOwnProperty(propname)) {\n" +
+            "          resizeProperties[propname] = properties[propname];\n" +
+            "        }\n" +
+            "      }\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
             "  var CalendarEventParser = {\n" +
@@ -663,7 +797,7 @@
             "      var validValues = ['opaque', 'transparent'];\n" +
             "\n" +
             "      if (this.parameters.hasOwnProperty('transparency')) {\n" +
-            "        var transparency = this.parameters['transparency'];\n" +
+            "        var transparency = this.parameters.transparency;\n" +
             "        if (contains(transparency, validValues)) {\n" +
             "          this.arguments.push('transparency');\n" +
             "          this.arguments.push(transparency);\n" +
@@ -688,7 +822,7 @@
             "\n" +
             "    parseRecurrenceInterval: function(recurrenceDict) {\n" +
             "      if (recurrenceDict.hasOwnProperty('interval')) {\n" +
-            "        var interval = recurrenceDict['interval'];\n" +
+            "        var interval = recurrenceDict.interval;\n" +
             "        if (!interval) {\n" +
             "          this.errors.push('Recurrence interval cannot be null.');\n" +
             "        } else {\n" +
@@ -704,7 +838,7 @@
             "\n" +
             "    parseRecurrenceFrequency: function(recurrenceDict) {\n" +
             "      if (recurrenceDict.hasOwnProperty('frequency')) {\n" +
-            "        var frequency = recurrenceDict['frequency'];\n" +
+            "        var frequency = recurrenceDict.frequency;\n" +
             "        var validFrequencies = ['daily', 'weekly', 'monthly', 'yearly'];\n" +
             "        if (contains(frequency, validFrequencies)) {\n" +
             "          this.arguments.push('frequency');\n" +
@@ -716,7 +850,7 @@
             "    },\n" +
             "\n" +
             "    parseRecurrenceEndDate: function(recurrenceDict) {\n" +
-            "      var expires = recurrenceDict['expires'];\n" +
+            "      var expires = recurrenceDict.expires;\n" +
             "\n" +
             "      if (!expires) {\n" +
             "        return;\n" +
@@ -748,7 +882,7 @@
             "        this.arguments.push(kind);\n" +
             "        this.arguments.push(dateString);\n" +
             "      }\n" +
-            "    },\n" +
+            "    }\n" +
             "  };\n" +
             "}());\n";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java
new file mode 100644
index 00000000..88fc74dc
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java
@@ -0,0 +1,113 @@
+package com.mopub.mobileads.resource;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
+
+public class ProgressBarDrawable extends BaseWidgetDrawable {
+    @NonNull private final Paint mBackgroundPaint;
+    @NonNull private final Paint mProgressPaint;
+
+    private int mDuration;
+    private int mSkipOffset;
+    private int mCurrentProgress;
+    private int mLastProgress;
+    private float mSkipRatio;
+    private final int mNuggetWidth;
+
+    public ProgressBarDrawable(@NonNull final Context context) {
+        super();
+
+        mBackgroundPaint = new Paint();
+        mBackgroundPaint.setColor(DrawableConstants.ProgressBar.BACKGROUND_COLOR);
+        mBackgroundPaint.setAlpha(DrawableConstants.ProgressBar.BACKGROUND_ALPHA);
+        mBackgroundPaint.setStyle(DrawableConstants.ProgressBar.BACKGROUND_STYLE);
+        mBackgroundPaint.setAntiAlias(true);
+
+        mProgressPaint = new Paint();
+        mProgressPaint.setColor(DrawableConstants.ProgressBar.PROGRESS_COLOR);
+        mProgressPaint.setAlpha(DrawableConstants.ProgressBar.PROGRESS_ALPHA);
+        mProgressPaint.setStyle(DrawableConstants.ProgressBar.PROGRESS_STYLE);
+        mProgressPaint.setAntiAlias(true);
+
+        mNuggetWidth = Dips.dipsToIntPixels(DrawableConstants.ProgressBar.NUGGET_WIDTH_DIPS, context);
+    }
+
+    @Override
+    public void draw(final Canvas canvas) {
+        // Background translucent bar
+        canvas.drawRect(getBounds(), mBackgroundPaint);
+
+        // Progress bar
+        float progressRatio = (float) mCurrentProgress / mDuration;
+        canvas.drawRect(getBounds().left,
+                getBounds().top,
+                getBounds().right * progressRatio,
+                getBounds().bottom,
+                mProgressPaint);
+
+        // Draw skipoffset nugget if skipoffset is in range (0, duration)
+        if (mSkipOffset > 0 && mSkipOffset < mDuration) {
+            float nuggetPosition = getBounds().right * mSkipRatio;
+
+            canvas.drawRect(nuggetPosition,
+                    getBounds().top,
+                    nuggetPosition + mNuggetWidth,
+                    getBounds().bottom,
+                    mProgressPaint);
+        }
+    }
+
+    public void setDurationAndSkipOffset(final int duration, final int skipOffset) {
+        mDuration = duration;
+        mSkipOffset = skipOffset;
+        mSkipRatio = (float) mSkipOffset / mDuration;
+    }
+
+    public void setProgress(final int currentProgress) {
+        // There exists two Android video player bugs in VideoView.getCurrentPosition():
+        // 1) It temporarily returns 0 right after backgrounding and switching back to the app.
+        // 2) Near the end of the video, it never reaches duration and actually returns decreasing values.
+        //
+        // Therefore, we incorporate two checks to get around the bugs and potential visual glitches:
+        // 1) Check against the last known current position to ensure that it's monotonically increasing.
+        // 2) If not monotonically increasing, we only force completion and draw the entire progress
+        // bar when the current position is not 0, i.e. not right after backgrounding.
+
+        if (currentProgress >= mLastProgress) {
+            mCurrentProgress = currentProgress;
+            mLastProgress = currentProgress;
+        } else if (currentProgress != 0) {
+            MoPubLog.d(String.format("Progress not monotonically increasing: last = %d, current = %d",
+                    mLastProgress,
+                    currentProgress));
+            forceCompletion();
+        }
+
+        invalidateSelf();
+    }
+
+    @VisibleForTesting
+    public void forceCompletion() {
+        mCurrentProgress = mDuration;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    public float getSkipRatio() {
+        return mSkipRatio;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    public int getCurrentProgress() {
+        return mCurrentProgress;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/RadialCountdownDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/RadialCountdownDrawable.java
new file mode 100644
index 00000000..318a6834
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/RadialCountdownDrawable.java
@@ -0,0 +1,88 @@
+package com.mopub.mobileads.resource;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Numbers;
+
+public class RadialCountdownDrawable extends BaseWidgetDrawable {
+    @NonNull private final Paint mCirclePaint;
+    @NonNull private final Paint mArcPaint;
+    @NonNull private final Paint mTextPaint;
+    @NonNull private Rect mTextRect;
+
+    private int mInitialCountdownMilliseconds;
+    private int mSecondsRemaining;
+    private float mSweepAngle;
+
+    public RadialCountdownDrawable(@NonNull final Context context) {
+        final int circleStrokeWidth = Dips.dipsToIntPixels(
+                DrawableConstants.RadialCountdown.CIRCLE_STROKE_WIDTH_DIPS, context);
+        final float textSizePixels = Dips.dipsToFloatPixels(
+                DrawableConstants.RadialCountdown.TEXT_SIZE_SP, context);
+
+        // Unfilled progress
+        mCirclePaint = new Paint();
+        mCirclePaint.setColor(DrawableConstants.RadialCountdown.BACKGROUND_COLOR);
+        mCirclePaint.setAlpha(DrawableConstants.RadialCountdown.BACKGROUND_ALPHA);
+        mCirclePaint.setStyle(DrawableConstants.RadialCountdown.BACKGROUND_STYLE);
+        mCirclePaint.setStrokeWidth(circleStrokeWidth);
+        mCirclePaint.setAntiAlias(true);
+
+        // Filled progress
+        mArcPaint = new Paint();
+        mArcPaint.setColor(DrawableConstants.RadialCountdown.PROGRESS_COLOR);
+        mArcPaint.setAlpha(DrawableConstants.RadialCountdown.PROGRESS_ALPHA);
+        mArcPaint.setStyle(DrawableConstants.RadialCountdown.PROGRESS_STYLE);
+        mArcPaint.setStrokeWidth(circleStrokeWidth);
+        mArcPaint.setAntiAlias(true);
+
+        // Countdown number text
+        mTextPaint = new Paint();
+        mTextPaint.setColor(DrawableConstants.RadialCountdown.TEXT_COLOR);
+        mTextPaint.setTextAlign(DrawableConstants.RadialCountdown.TEXT_ALIGN);
+        mTextPaint.setTextSize(textSizePixels);
+        mTextPaint.setAntiAlias(true);
+
+        mTextRect = new Rect();
+    }
+
+    @Override
+    public void draw(final Canvas canvas) {
+        final int centerX = getBounds().centerX();
+        final int centerY = getBounds().centerY();
+        final int radius = Math.min(centerX, centerY);
+
+        canvas.drawCircle(centerX, centerY, radius, mCirclePaint);
+
+        final String secondsRemainingText = String.valueOf(mSecondsRemaining);
+        drawTextWithinBounds(canvas, mTextPaint, mTextRect, secondsRemainingText);
+
+        final RectF circle = new RectF(getBounds());
+        canvas.drawArc(circle, DrawableConstants.RadialCountdown.START_ANGLE, mSweepAngle, false, mArcPaint);
+    }
+
+    public void setInitialCountdown(final int initialCountdownMilliseconds) {
+        mInitialCountdownMilliseconds = initialCountdownMilliseconds;
+    }
+
+    public void updateCountdownProgress(final int currentProgressMilliseconds) {
+        int remainingCountdownMilliseconds = mInitialCountdownMilliseconds - currentProgressMilliseconds;
+        mSecondsRemaining = (int) Numbers.convertMillisecondsToSecondsRoundedUp(remainingCountdownMilliseconds);
+        mSweepAngle = 360f * currentProgressMilliseconds / mInitialCountdownMilliseconds;
+        invalidateSelf();
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    public int getInitialCountdownMilliseconds() {
+        return mInitialCountdownMilliseconds;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/TextDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/TextDrawable.java
deleted file mode 100644
index 46b60a4c..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/TextDrawable.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package com.mopub.mobileads.resource;
-
-public interface TextDrawable {
-    public void updateText(final String text);
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java
deleted file mode 100644
index 5a2aebe0..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java
+++ /dev/null
@@ -1,725 +0,0 @@
-package com.mopub.mobileads.util;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Utilities for encoding and decoding the Base64 representation of
- * binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
- * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
- */
-public class Base64 {
-    /**
-     * Default values for encoder/decoder flags.
-     */
-    public static final int DEFAULT = 0;
-
-    /**
-     * Encoder flag bit to omit the padding '=' characters at the end
-     * of the output (if any).
-     */
-    public static final int NO_PADDING = 1;
-
-    /**
-     * Encoder flag bit to omit all line terminators (i.e., the output
-     * will be on one long line).
-     */
-    public static final int NO_WRAP = 2;
-
-    /**
-     * Encoder flag bit to indicate lines should be terminated with a
-     * CRLF pair instead of just an LF.  Has no effect if {@code
-     * NO_WRAP} is specified as well.
-     */
-    public static final int CRLF = 4;
-
-    /**
-     * Encoder/decoder flag bit to indicate using the "URL and
-     * filename safe" variant of Base64 (see RFC 3548 section 4) where
-     * {@code -} and {@code _} are used in place of {@code +} and
-     * {@code /}.
-     */
-    public static final int URL_SAFE = 8;
-
-    /**
-     * Flag to pass to Base64OutputStream to indicate that it
-     * should not close the output stream it is wrapping when it
-     * itself is closed.
-     */
-    public static final int NO_CLOSE = 16;
-
-    //  --------------------------------------------------------
-    //  shared code
-    //  --------------------------------------------------------
-
-    /* package */ static abstract class Coder {
-        public byte[] output;
-        public int op;
-
-        /**
-         * Encode/decode another block of input data.  this.output is
-         * provided by the caller, and must be big enough to hold all
-         * the coded data.  On exit, this.opwill be set to the length
-         * of the coded data.
-         *
-         * @param finish true if this is the final call to process for
-         *        this object.  Will finalize the coder state and
-         *        include any final bytes in the output.
-         *
-         * @return true if the input so far is good; false if some
-         *         error has been detected in the input stream..
-         */
-        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
-
-        /**
-         * @return the maximum number of bytes a call to process()
-         * could produce for the given number of input bytes.  This may
-         * be an overestimate.
-         */
-        public abstract int maxOutputSize(int len);
-    }
-
-    //  --------------------------------------------------------
-    //  decoding
-    //  --------------------------------------------------------
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param str    the input String to decode, which is converted to
-     *               bytes using the default charset
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(String str, int flags) {
-        return decode(str.getBytes(), flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param input the input array to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(byte[] input, int flags) {
-        return decode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param input  the data to decode
-     * @param offset the position within the input array at which to start
-     * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(byte[] input, int offset, int len, int flags) {
-        // Allocate space for the most data the input could represent.
-        // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
-
-        if (!decoder.process(input, offset, len, true)) {
-            throw new IllegalArgumentException("bad base-64");
-        }
-
-        // Maybe we got lucky and allocated exactly enough output space.
-        if (decoder.op == decoder.output.length) {
-            return decoder.output;
-        }
-
-        // Need to shorten the array, so allocate a new one of the
-        // right size and copy.
-        byte[] temp = new byte[decoder.op];
-        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
-        return temp;
-    }
-
-    /* package */ static class Decoder extends Coder {
-        /**
-         * Lookup table for turning bytes into their position in the
-         * Base64 alphabet.
-         */
-        private static final int DECODE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /**
-         * Decode lookup table for the "web safe" variant (RFC 3548
-         * sec. 4) where - and _ replace + and /.
-         */
-        private static final int DECODE_WEBSAFE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /** Non-data values in the DECODE arrays. */
-        private static final int SKIP = -1;
-        private static final int EQUALS = -2;
-
-        /**
-         * States 0-3 are reading through the next input tuple.
-         * State 4 is having read one '=' and expecting exactly
-         * one more.
-         * State 5 is expecting no more data or padding characters
-         * in the input.
-         * State 6 is the error state; an error has been detected
-         * in the input and no future input can "fix" it.
-         */
-        private int state;   // state number (0 to 6)
-        private int value;
-
-        final private int[] alphabet;
-
-        public Decoder(int flags, byte[] output) {
-            this.output = output;
-
-            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
-            state = 0;
-            value = 0;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could decode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 3/4 + 10;
-        }
-
-        /**
-         * Decode another block of input data.
-         *
-         * @return true if the state machine is still healthy.  false if
-         *         bad base-64 data has been detected in the input stream.
-         */
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            if (this.state == 6) return false;
-
-            int p = offset;
-            len += offset;
-
-            // Using local variables makes the decoder about 12%
-            // faster than if we manipulate the member variables in
-            // the loop.  (Even alphabet makes a measurable
-            // difference, which is somewhat surprising to me since
-            // the member variable is final.)
-            int state = this.state;
-            int value = this.value;
-            int op = 0;
-            final byte[] output = this.output;
-            final int[] alphabet = this.alphabet;
-
-            while (p < len) {
-                // Try the fast path:  we're starting a new tuple and the
-                // next four bytes of the input stream are all data
-                // bytes.  This corresponds to going through states
-                // 0-1-2-3-0.  We expect to use this method for most of
-                // the data.
-                //
-                // If any of the next four bytes of input are non-data
-                // (whitespace, etc.), value will end up negative.  (All
-                // the non-data values in decode are small negative
-                // numbers, so shifting any of them up and or'ing them
-                // together will result in a value with its top bit set.)
-                //
-                // You can remove this whole block and the output should
-                // be the same, just slower.
-                if (state == 0) {
-                    while (p+4 <= len &&
-                            (value = ((alphabet[input[p] & 0xff] << 18) |
-                                    (alphabet[input[p+1] & 0xff] << 12) |
-                                    (alphabet[input[p+2] & 0xff] << 6) |
-                                    (alphabet[input[p+3] & 0xff]))) >= 0) {
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        p += 4;
-                    }
-                    if (p >= len) break;
-                }
-
-                // The fast path isn't available -- either we've read a
-                // partial tuple, or the next four input bytes aren't all
-                // data, or whatever.  Fall back to the slower state
-                // machine implementation.
-
-                int d = alphabet[input[p++] & 0xff];
-
-                switch (state) {
-                    case 0:
-                        if (d >= 0) {
-                            value = d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 1:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 2:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect exactly one more padding character.
-                            output[op++] = (byte) (value >> 4);
-                            state = 4;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 3:
-                        if (d >= 0) {
-                            // Emit the output triple and return to state 0.
-                            value = (value << 6) | d;
-                            output[op+2] = (byte) value;
-                            output[op+1] = (byte) (value >> 8);
-                            output[op] = (byte) (value >> 16);
-                            op += 3;
-                            state = 0;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect no further data or padding characters.
-                            output[op+1] = (byte) (value >> 2);
-                            output[op] = (byte) (value >> 10);
-                            op += 2;
-                            state = 5;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 4:
-                        if (d == EQUALS) {
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 5:
-                        if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-                }
-            }
-
-            if (!finish) {
-                // We're out of input, but a future call could provide
-                // more.
-                this.state = state;
-                this.value = value;
-                this.op = op;
-                return true;
-            }
-
-            // Done reading input.  Now figure out where we are left in
-            // the state machine and finish up.
-
-            switch (state) {
-                case 0:
-                    // Output length is a multiple of three.  Fine.
-                    break;
-                case 1:
-                    // Read one extra input byte, which isn't enough to
-                    // make another output byte.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 2:
-                    // Read two extra input bytes, enough to emit 1 more
-                    // output byte.  Fine.
-                    output[op++] = (byte) (value >> 4);
-                    break;
-                case 3:
-                    // Read three extra input bytes, enough to emit 2 more
-                    // output bytes.  Fine.
-                    output[op++] = (byte) (value >> 10);
-                    output[op++] = (byte) (value >> 2);
-                    break;
-                case 4:
-                    // Read one padding '=' when we expected 2.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 5:
-                    // Read all the padding '='s we expected and no more.
-                    // Fine.
-                    break;
-            }
-
-            this.state = state;
-            this.op = op;
-            return true;
-        }
-    }
-
-    //  --------------------------------------------------------
-    //  encoding
-    //  --------------------------------------------------------
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
-     *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static String encodeToString(byte[] input, int flags) {
-        try {
-            return new String(encode(input, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static String encodeToString(byte[] input, int offset, int len, int flags) {
-        try {
-            return new String(encode(input, offset, len, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static byte[] encode(byte[] input, int flags) {
-        return encode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static byte[] encode(byte[] input, int offset, int len, int flags) {
-        Encoder encoder = new Encoder(flags, null);
-
-        // Compute the exact length of the array we will produce.
-        int output_len = len / 3 * 4;
-
-        // Account for the tail of the data and the padding bytes, if any.
-        if (encoder.do_padding) {
-            if (len % 3 > 0) {
-                output_len += 4;
-            }
-        } else {
-            switch (len % 3) {
-                case 0: break;
-                case 1: output_len += 2; break;
-                case 2: output_len += 3; break;
-            }
-        }
-
-        // Account for the newlines, if any.
-        if (encoder.do_newline && len > 0) {
-            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                    (encoder.do_cr ? 2 : 1);
-        }
-
-        encoder.output = new byte[output_len];
-        encoder.process(input, offset, len, true);
-
-        assert encoder.op == output_len;
-
-        return encoder.output;
-    }
-
-    /* package */ static class Encoder extends Coder {
-        /**
-         * Emit a new line every this many output tuples.  Corresponds to
-         * a 76-character line length (the maximum allowable according to
-         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
-         */
-        public static final int LINE_GROUPS = 19;
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
-         */
-        private static final byte ENCODE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
-        };
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
-         */
-        private static final byte ENCODE_WEBSAFE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
-        };
-
-        final private byte[] tail;
-        /* package */ int tailLen;
-        private int count;
-
-        final public boolean do_padding;
-        final public boolean do_newline;
-        final public boolean do_cr;
-        final private byte[] alphabet;
-
-        public Encoder(int flags, byte[] output) {
-            this.output = output;
-
-            do_padding = (flags & NO_PADDING) == 0;
-            do_newline = (flags & NO_WRAP) == 0;
-            do_cr = (flags & CRLF) != 0;
-            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
-
-            tail = new byte[2];
-            tailLen = 0;
-
-            count = do_newline ? LINE_GROUPS : -1;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could encode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 8/5 + 10;
-        }
-
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            // Using local variables makes the encoder about 9% faster.
-            final byte[] alphabet = this.alphabet;
-            final byte[] output = this.output;
-            int op = 0;
-            int count = this.count;
-
-            int p = offset;
-            len += offset;
-            int v = -1;
-
-            // First we need to concatenate the tail of the previous call
-            // with any input bytes available now and see if we can empty
-            // the tail.
-
-            switch (tailLen) {
-                case 0:
-                    // There was no tail.
-                    break;
-
-                case 1:
-                    if (p+2 <= len) {
-                        // A 1-byte tail with at least 2 bytes of
-                        // input available now.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((input[p++] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    };
-                    break;
-
-                case 2:
-                    if (p+1 <= len) {
-                        // A 2-byte tail with at least 1 byte of input.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((tail[1] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    }
-                    break;
-            }
-
-            if (v != -1) {
-                output[op++] = alphabet[(v >> 18) & 0x3f];
-                output[op++] = alphabet[(v >> 12) & 0x3f];
-                output[op++] = alphabet[(v >> 6) & 0x3f];
-                output[op++] = alphabet[v & 0x3f];
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            // At this point either there is no tail, or there are fewer
-            // than 3 bytes of input available.
-
-            // The main loop, turning 3 input bytes into 4 output bytes on
-            // each iteration.
-            while (p+3 <= len) {
-                v = ((input[p] & 0xff) << 16) |
-                        ((input[p+1] & 0xff) << 8) |
-                        (input[p+2] & 0xff);
-                output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op+1] = alphabet[(v >> 12) & 0x3f];
-                output[op+2] = alphabet[(v >> 6) & 0x3f];
-                output[op+3] = alphabet[v & 0x3f];
-                p += 3;
-                op += 4;
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            if (finish) {
-                // Finish up the tail of the input.  Note that we need to
-                // consume any bytes in tail before any bytes
-                // remaining in input; there should be at most two bytes
-                // total.
-
-                if (p-tailLen == len-1) {
-                    int t = 0;
-                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (p-tailLen == len-2) {
-                    int t = 0;
-                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 12) & 0x3f];
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                }
-
-                assert tailLen == 0;
-                assert p == len;
-            } else {
-                // Save the leftovers in tail to be consumed on the next
-                // call to encodeInternal.
-
-                if (p == len-1) {
-                    tail[tailLen++] = input[p];
-                } else if (p == len-2) {
-                    tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p+1];
-                }
-            }
-
-            this.op = op;
-            this.count = count;
-
-            return true;
-        }
-    }
-
-    private Base64() { }   // don't instantiate
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Interstitials.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Interstitials.java
deleted file mode 100644
index a4e4d384..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Interstitials.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.graphics.Color;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-
-public class Interstitials {
-    private Interstitials(){}
-
-    public static boolean addCloseEventRegion(final ViewGroup viewGroup, final ViewGroup.LayoutParams layoutParams, final View.OnClickListener onClickListener) {
-        if (viewGroup == null || viewGroup.getContext() == null) {
-            return false;
-        }
-
-        // An area of the screen that will always lead to an expanded MRAID ad collapsing.
-        final Button closeEventRegion = new Button(viewGroup.getContext());
-        closeEventRegion.setVisibility(View.VISIBLE);
-        closeEventRegion.setBackgroundColor(Color.TRANSPARENT);
-        closeEventRegion.setOnClickListener(onClickListener);
-
-        viewGroup.addView(closeEventRegion, layoutParams);
-
-        return true;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
deleted file mode 100644
index da58d1f5..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.net.Uri;
-import android.os.Environment;
-
-import com.mopub.common.util.IntentUtils;
-import com.mopub.common.util.VersionCode;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.os.Environment.MEDIA_MOUNTED;
-
-public class Mraids {
-    public static final String ANDROID_CALENDAR_CONTENT_TYPE = "vnd.android.cursor.item/event";
-
-    public static boolean isTelAvailable(Context context) {
-        Intent telIntent = new Intent(Intent.ACTION_DIAL);
-        telIntent.setData(Uri.parse("tel:"));
-
-        return IntentUtils.deviceCanHandleIntent(context, telIntent);
-    }
-
-    public static boolean isSmsAvailable(Context context) {
-        Intent smsIntent = new Intent(Intent.ACTION_VIEW);
-        smsIntent.setData(Uri.parse("sms:"));
-
-        return IntentUtils.deviceCanHandleIntent(context, smsIntent);
-    }
-
-    public static boolean isStorePictureSupported(Context context) {
-        return MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
-                && context.checkCallingOrSelfPermission(WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
-    }
-
-    public static boolean isCalendarAvailable(Context context) {
-        Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
-
-        return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
-                && IntentUtils.deviceCanHandleIntent(context, calendarIntent);
-    }
-
-    public static boolean isInlineVideoAvailable(Context context) {
-        Intent mraidVideoIntent = new Intent(context, MraidVideoPlayerActivity.class);
-
-        return IntentUtils.deviceCanHandleIntent(context, mraidVideoIntent);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
deleted file mode 100644
index d96476f4..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-
-import com.mopub.common.logging.MoPubLog;
-
-public class Utils {
-    private Utils() {}
-
-    public static boolean executeIntent(Context context, Intent intent, String errorMessage) {
-        try {
-            if (!(context instanceof Activity)) {
-                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            }
-            context.startActivity(intent);
-        } catch (Exception e) {
-            MoPubLog.d((errorMessage != null)
-                    ? errorMessage
-                    : "Unable to start intent.");
-            return false;
-        }
-        return true;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
index f368ccd3..57eb0f0c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
@@ -1,33 +1,55 @@
 package com.mopub.mobileads.util;
 
-import android.util.Log;
+import android.annotation.TargetApi;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
 import android.webkit.JsPromptResult;
 import android.webkit.JsResult;
 import android.webkit.WebChromeClient;
 import android.webkit.WebView;
 
-import java.lang.reflect.Method;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Reflection.MethodBuilder;
 
 public class WebViews {
-    private static final String LOGTAG = "MoPub - WebViewsUtil";
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    public static void onResume(@NonNull WebView webView) {
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
+            webView.onResume();
+            return;
+        }
 
-    public static void onPause(WebView webView) {
+        // Method is still available, but hidden. Invoke using reflection.
         try {
-            Method onPause = WebView.class.getDeclaredMethod("onPause");
-            onPause.invoke(webView);
+            new MethodBuilder(webView, "onResume").setAccessible().execute();
         } catch (Exception e) {
-            // can't call this before API level 11
-            return;
+            // no-op
         }
     }
 
-    public static void onResume(WebView webView) {
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    public static void onPause(@NonNull WebView webView, boolean isFinishing) {
+        // XXX
+        // We need to call WebView#stopLoading and WebView#loadUrl here due to an Android
+        // bug where the audio of an HTML5 video will continue to play after the activity has been
+        // destroyed. The web view must stop then load an invalid url during the onPause lifecycle
+        // event in order to stop the audio.
+        if (isFinishing) {
+            webView.stopLoading();
+            webView.loadUrl("");
+        }
+
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
+            webView.onPause();
+            return;
+        }
+
+        // Method is still available, but hidden. Invoke using reflection.
         try {
-            Method onResume = WebView.class.getDeclaredMethod("onResume");
-            onResume.invoke(webView);
+            new MethodBuilder(webView, "onPause").setAccessible().execute();
         } catch (Exception e) {
-            // can't call this before API level 11
-            return;
+            // no-op
         }
     }
 
@@ -35,25 +57,29 @@ public static void setDisableJSChromeClient(WebView webView) {
         webView.setWebChromeClient(new WebChromeClient() {
             @Override
             public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsBeforeUnload(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
         });
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/XmlUtils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/XmlUtils.java
new file mode 100644
index 00000000..d5c8d3b5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/XmlUtils.java
@@ -0,0 +1,270 @@
+package com.mopub.mobileads.util;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class XmlUtils {
+    private XmlUtils() {}
+
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName}.
+     *
+     * Only direct children are checked.
+     */
+    public static Node getFirstMatchingChildNode(final Node node, final String nodeName) {
+        return getFirstMatchingChildNode(node, nodeName, null, null);
+    }
+
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName} that has an
+     * attribute named {@code attributeName} with a value that matches one of {@code attributeValues}.
+     *
+     * Only direct children are checked.
+     *
+     * @param nodeName matching nodes must have this name.
+     * @param attributeName matching nodes must have an attribute with this name.
+     *                      Use null to match nodes with any attributes.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values. Use null to match nodes with any attribute
+     *                        value.
+     */
+    public static Node getFirstMatchingChildNode(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
+        if (node == null || nodeName == null) {
+            return null;
+        }
+
+        final List<Node> nodes = getMatchingChildNodes(node, nodeName, attributeName, attributeValues);
+        if (nodes != null && !nodes.isEmpty()) {
+            return nodes.get(0);
+        }
+        return null;
+    }
+
+    /**
+     * Return children of the {@code node} parameter with a matching {@code nodeName}.
+     *
+     * @param node the root node to look beneath.
+     * @param nodeName all child nodes will match this element.
+     * @return child nodes that match the nodeName
+     */
+    public static List<Node> getMatchingChildNodes(final Node node, final String nodeName) {
+        return getMatchingChildNodes(node, nodeName, null, null);
+    }
+
+    /**
+     * Return children of the {@code node} parameter with a matching {@code nodeName} &
+     * {@code attributeName} that matches at least one of the passed-in {@code attributeValues}.
+     * If {@code attributeValues} is empty, no nodes will match. To match names only,
+     * pass null for both {@code attributeName} and {@code attributeValues}.
+     *
+     * @param node the root node to look beneath.
+     * @param nodeName all child nodes will match this element.
+     * @param attributeName all matching child nodes will have an attribute of this name.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values.
+     * @return child nodes that match all parameters
+     */
+    public static List<Node> getMatchingChildNodes(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
+        if (node == null || nodeName == null) {
+            return null;
+        }
+
+        final List<Node> nodes = new ArrayList<Node>();
+        final NodeList nodeList = node.getChildNodes();
+        for (int i = 0; i < nodeList.getLength(); ++i) {
+            Node childNode = nodeList.item(i);
+            if (childNode.getNodeName().equals(nodeName)
+                    && nodeMatchesAttributeFilter(childNode, attributeName, attributeValues)) {
+                nodes.add(childNode);
+            }
+        }
+        return nodes;
+    }
+
+    /**
+     * Returns {@code true} iff the node has the attribute {@code attributeName} with a value that
+     * matches one of {@code attributeValues}.
+     */
+    public static boolean nodeMatchesAttributeFilter(final Node node, final String attributeName, final List<String> attributeValues) {
+        if (attributeName == null || attributeValues == null) {
+            return true;
+        }
+
+        final NamedNodeMap attrMap = node.getAttributes();
+        if (attrMap != null) {
+            Node attrNode = attrMap.getNamedItem(attributeName);
+            if (attrNode != null && attributeValues.contains(attrNode.getNodeValue())) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public static String getNodeValue(final Node node) {
+        if (node != null
+                && node.getFirstChild() != null
+                && node.getFirstChild().getNodeValue() != null) {
+            return node.getFirstChild().getNodeValue().trim();
+        }
+        return null;
+    }
+
+    public static Integer getAttributeValueAsInt(final Node node, final String attributeName) {
+        if (node == null || attributeName == null) {
+            return null;
+        }
+
+        try {
+            return Integer.parseInt(getAttributeValue(node, attributeName));
+        } catch (NumberFormatException e) {
+            return null;
+        }
+    }
+
+    public static String getAttributeValue(final Node node, final String attributeName) {
+        if (node == null || attributeName == null) {
+            return null;
+        }
+
+        final NamedNodeMap attrMap = node.getAttributes();
+        final Node attrNode = attrMap.getNamedItem(attributeName);
+
+        // XXX: the attribute value must be retrieved using attrNode.getNodeValue(). Even though
+        // getNodeValue(attrNode) works in unit testing, it does not work in production. We were
+        // unable to figure out exactly why.
+        if (attrNode != null) {
+            return attrNode.getNodeValue();
+        }
+        return null;
+    }
+
+    /**
+     * Get a list of data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Each node that matches these is
+     * processed by the {@code nodeProcessor} and all non-null results returned by the processor are
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return a {@code List<T>} with processed node data.
+     */
+    public static <T> List<T> getListFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        final ArrayList<T> results = new ArrayList<T>();
+
+        if (vastDoc == null) {
+            return results;
+        }
+
+        final NodeList nodes = vastDoc.getElementsByTagName(elementName);
+        if (nodes == null) {
+            return results;
+        }
+
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
+        for (int i = 0; i < nodes.getLength(); i++) {
+            final Node node = nodes.item(i);
+
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    results.add(processed);
+                }
+            }
+        }
+
+        return results;
+    }
+
+    /**
+     * Get first matching data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Nodes that match are processed by
+     * the {@code nodeProcessor} until the first non-null result returned by the processor is
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return node data of type {@code <T>} from first node that matches.
+     */
+    public static <T> T getFirstMatchFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        if (vastDoc == null) {
+            return null;
+        }
+
+        final NodeList nodes = vastDoc.getElementsByTagName(elementName);
+        if (nodes == null) {
+            return null;
+        }
+
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
+        for (int i = 0; i < nodes.getLength(); i++) {
+            final Node node = nodes.item(i);
+
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    return processed;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public static String getFirstMatchingStringData(final Document vastDoc, final String elementName) {
+        return getFirstMatchingStringData(vastDoc, elementName, null, null);
+    }
+
+    public static String getFirstMatchingStringData(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getFirstMatchFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    public static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
+        return getStringDataAsList(vastDoc, elementName, null, null);
+    }
+
+    public static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    public static List<Node> getNodesWithElementAndAttribute(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+       return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<Node>() {
+           @Override
+           public Node process(final Node node) {
+               return node;
+           }
+       });
+    }
+
+    public interface NodeProcessor<T> {
+        T process(Node node);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastCompanionAd.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastCompanionAd.java
deleted file mode 100644
index 55609e52..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastCompanionAd.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-public class VastCompanionAd implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private final Integer mWidth;
-    private final Integer mHeight;
-    private final String mImageUrl;
-    private final String mClickThroughUrl;
-    private final ArrayList<String> mClickTrackers;
-
-    public VastCompanionAd(
-            Integer width,
-            Integer height,
-            String imageUrl,
-            String clickThroughUrl,
-            ArrayList<String> clickTrackers) {
-        mWidth = width;
-        mHeight = height;
-        mImageUrl = imageUrl;
-        mClickThroughUrl = clickThroughUrl;
-        mClickTrackers = clickTrackers;
-    }
-
-    public Integer getWidth() {
-        return mWidth;
-    }
-
-    public Integer getHeight() {
-        return mHeight;
-    }
-
-    public String getImageUrl() {
-        return mImageUrl;
-    }
-
-    public String getClickThroughUrl() {
-        return mClickThroughUrl;
-    }
-
-    public List<String> getClickTrackers() {
-        return mClickTrackers;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
deleted file mode 100644
index ab6c0dce..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
+++ /dev/null
@@ -1,266 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import android.content.Context;
-import android.view.Display;
-import android.view.WindowManager;
-import com.mopub.common.CacheService;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.mobileads.VastVideoDownloadTask;
-
-import java.util.*;
-
-import static com.mopub.mobileads.VastVideoDownloadTask.VastVideoDownloadTaskListener;
-import static com.mopub.mobileads.util.vast.VastXmlManagerAggregator.VastXmlManagerAggregatorListener;
-
-public class VastManager implements VastXmlManagerAggregatorListener {
-    public interface VastManagerListener {
-        public void onVastVideoConfigurationPrepared(final VastVideoConfiguration vastVideoConfiguration);
-    }
-
-    private static final double ASPECT_RATIO_WEIGHT = 40;
-    private static final double AREA_WEIGHT = 60;
-    private static final List<String> VIDEO_MIME_TYPES =
-            Arrays.asList("video/mp4", "video/3gpp");
-    private static final List<String> COMPANION_IMAGE_MIME_TYPES =
-            Arrays.asList("image/jpeg", "image/png", "image/bmp", "image/gif");
-
-    private VastManagerListener mVastManagerListener;
-
-    private VastXmlManagerAggregator mVastXmlManagerAggregator;
-    private double mScreenAspectRatio;
-    private int mScreenArea;
-
-    public VastManager(final Context context) {
-        initializeScreenDimensions(context);
-    }
-
-    public void prepareVastVideoConfiguration(final String vastXml, final VastManagerListener vastManagerListener) {
-        if (mVastXmlManagerAggregator == null) {
-            mVastManagerListener = vastManagerListener;
-            mVastXmlManagerAggregator = new VastXmlManagerAggregator(this);
-
-            try {
-                AsyncTasks.safeExecuteOnExecutor(mVastXmlManagerAggregator, vastXml);
-            } catch (Exception e) {
-                MoPubLog.d("Failed to aggregate vast xml", e);
-
-                if (mVastManagerListener != null) {
-                    mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                }
-            }
-        }
-    }
-
-    public void cancel() {
-        if (mVastXmlManagerAggregator != null) {
-            mVastXmlManagerAggregator.cancel(true);
-            mVastXmlManagerAggregator = null;
-        }
-    }
-
-    @Override
-    public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
-        mVastXmlManagerAggregator = null;
-        if (vastXmlManagers == null) {
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-            }
-            return;
-        }
-
-        final VastVideoConfiguration vastVideoConfiguration =
-                createVastVideoConfigurationFromXml(vastXmlManagers);
-
-        if (updateDiskMediaFileUrl(vastVideoConfiguration)) {
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
-            }
-            return;
-        }
-
-        final VastVideoDownloadTask vastVideoDownloadTask = new VastVideoDownloadTask(
-                new VastVideoDownloadTaskListener() {
-                    @Override
-                    public void onComplete(boolean success) {
-                        if (success && updateDiskMediaFileUrl(vastVideoConfiguration)) {
-                            if (mVastManagerListener != null) {
-                                mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
-                            }
-                        } else {
-                            if (mVastManagerListener != null) {
-                                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                            }
-                        }
-                    }
-                }
-        );
-
-        try {
-            AsyncTasks.safeExecuteOnExecutor(
-                    vastVideoDownloadTask,
-                    vastVideoConfiguration.getNetworkMediaFileUrl()
-            );
-        } catch (Exception e) {
-            MoPubLog.d("Failed to download vast video", e);
-
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-            }
-        }
-    }
-
-    private boolean updateDiskMediaFileUrl(final VastVideoConfiguration vastVideoConfiguration) {
-        final String networkMediaFileUrl = vastVideoConfiguration.getNetworkMediaFileUrl();
-        if (CacheService.containsKeyDiskCache(networkMediaFileUrl)) {
-            final String filePathDiskCache = CacheService.getFilePathDiskCache(networkMediaFileUrl);
-            vastVideoConfiguration.setDiskMediaFileUrl(filePathDiskCache);
-            return true;
-        }
-        return false;
-    }
-
-    private void initializeScreenDimensions(final Context context) {
-        // This currently assumes that all vast videos will be played in landscape
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        int x = display.getWidth();
-        int y = display.getHeight();
-
-        // For landscape, width is always greater than height
-        int screenWidth = Math.max(x, y);
-        int screenHeight = Math.min(x, y);
-        mScreenAspectRatio = (double) screenWidth / screenHeight;
-        mScreenArea = screenWidth * screenHeight;
-    }
-
-    private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<VastXmlManager> xmlManagers) {
-        final VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-
-        final List<VastXmlManager.MediaXmlManager> mediaXmlManagers = new ArrayList<VastXmlManager.MediaXmlManager>();
-        final List<VastXmlManager.ImageCompanionAdXmlManager> companionXmlManagers = new ArrayList<VastXmlManager.ImageCompanionAdXmlManager>();
-        for (VastXmlManager xmlManager : xmlManagers) {
-            vastVideoConfiguration.addImpressionTrackers(xmlManager.getImpressionTrackers());
-
-            vastVideoConfiguration.addStartTrackers(xmlManager.getVideoStartTrackers());
-            vastVideoConfiguration.addFirstQuartileTrackers(xmlManager.getVideoFirstQuartileTrackers());
-            vastVideoConfiguration.addMidpointTrackers(xmlManager.getVideoMidpointTrackers());
-            vastVideoConfiguration.addThirdQuartileTrackers(xmlManager.getVideoThirdQuartileTrackers());
-            vastVideoConfiguration.addCompleteTrackers(xmlManager.getVideoCompleteTrackers());
-
-            vastVideoConfiguration.addClickTrackers(xmlManager.getClickTrackers());
-
-            if (vastVideoConfiguration.getClickThroughUrl() == null) {
-                vastVideoConfiguration.setClickThroughUrl(xmlManager.getClickThroughUrl());
-            }
-
-            mediaXmlManagers.addAll(xmlManager.getMediaXmlManagers());
-            companionXmlManagers.addAll(xmlManager.getCompanionAdXmlManagers());
-        }
-
-        vastVideoConfiguration.setNetworkMediaFileUrl(getBestMediaFileUrl(mediaXmlManagers));
-        vastVideoConfiguration.setVastCompanionAd(getBestCompanionAd(companionXmlManagers));
-
-        return vastVideoConfiguration;
-    }
-
-    String getBestMediaFileUrl(final List<VastXmlManager.MediaXmlManager> managers) {
-        final List<VastXmlManager.MediaXmlManager> mediaXmlManagers = new ArrayList<VastXmlManager.MediaXmlManager>(managers);
-        double bestMediaFitness = Double.POSITIVE_INFINITY;
-        String bestMediaFileUrl = null;
-
-        final Iterator<VastXmlManager.MediaXmlManager> xmlManagerIterator = mediaXmlManagers.iterator();
-        while (xmlManagerIterator.hasNext()) {
-            final VastXmlManager.MediaXmlManager mediaXmlManager = xmlManagerIterator.next();
-
-            final String mediaType = mediaXmlManager.getType();
-            final String mediaUrl = mediaXmlManager.getMediaUrl();
-            if (!VIDEO_MIME_TYPES.contains(mediaType) || mediaUrl == null) {
-                xmlManagerIterator.remove();
-                continue;
-            }
-
-            final Integer mediaWidth = mediaXmlManager.getWidth();
-            final Integer mediaHeight = mediaXmlManager.getHeight();
-            if (mediaWidth == null || mediaWidth <= 0 || mediaHeight == null || mediaHeight <= 0) {
-                continue;
-            }
-
-            final double mediaFitness = calculateFitness(mediaWidth, mediaHeight);
-            if (mediaFitness < bestMediaFitness) {
-                bestMediaFitness = mediaFitness;
-                bestMediaFileUrl = mediaUrl;
-            }
-        }
-
-        if (bestMediaFileUrl == null && !mediaXmlManagers.isEmpty()) {
-            bestMediaFileUrl = mediaXmlManagers.get(0).getMediaUrl();
-        }
-
-        return bestMediaFileUrl;
-    }
-
-    VastCompanionAd getBestCompanionAd(final List<VastXmlManager.ImageCompanionAdXmlManager> managers) {
-        final List<VastXmlManager.ImageCompanionAdXmlManager> companionXmlManagers =
-                new ArrayList<VastXmlManager.ImageCompanionAdXmlManager>(managers);
-        double bestCompanionFitness = Double.POSITIVE_INFINITY;
-        VastXmlManager.ImageCompanionAdXmlManager bestCompanionXmlManager = null;
-
-        final Iterator<VastXmlManager.ImageCompanionAdXmlManager> xmlManagerIterator = companionXmlManagers.iterator();
-        while (xmlManagerIterator.hasNext()) {
-            final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = xmlManagerIterator.next();
-
-            final String imageType = companionXmlManager.getType();
-            final String imageUrl = companionXmlManager.getImageUrl();
-            if (!COMPANION_IMAGE_MIME_TYPES.contains(imageType) || imageUrl == null) {
-                xmlManagerIterator.remove();
-                continue;
-            }
-
-            final Integer imageWidth = companionXmlManager.getWidth();
-            final Integer imageHeight = companionXmlManager.getHeight();
-            if (imageWidth == null || imageWidth <= 0 || imageHeight == null || imageHeight <= 0) {
-                continue;
-            }
-
-            final double companionFitness = calculateFitness(imageWidth, imageHeight);
-            if (companionFitness < bestCompanionFitness) {
-                bestCompanionFitness = companionFitness;
-                bestCompanionXmlManager = companionXmlManager;
-            }
-        }
-
-        if (bestCompanionXmlManager == null && !companionXmlManagers.isEmpty()) {
-            bestCompanionXmlManager = companionXmlManagers.get(0);
-        }
-
-        if (bestCompanionXmlManager != null) {
-            return new VastCompanionAd(
-                    bestCompanionXmlManager.getWidth(),
-                    bestCompanionXmlManager.getHeight(),
-                    bestCompanionXmlManager.getImageUrl(),
-                    bestCompanionXmlManager.getClickThroughUrl(),
-                    new ArrayList<String>(bestCompanionXmlManager.getClickTrackers())
-            );
-        }
-        return null;
-    }
-
-    private double calculateFitness(final int width, final int height) {
-        final double mediaAspectRatio = (double) width / height;
-        final int mediaArea = width * height;
-        final double aspectRatioRatio = mediaAspectRatio / mScreenAspectRatio;
-        final double areaRatio = (double) mediaArea / mScreenArea;
-        return ASPECT_RATIO_WEIGHT * Math.abs(Math.log(aspectRatioRatio))
-                + AREA_WEIGHT * Math.abs(Math.log(areaRatio));
-    }
-
-    @Deprecated // for testing
-    int getScreenArea() {
-        return mScreenArea;
-    }
-
-    @Deprecated // for testing
-    double getScreenAspectRatio() {
-        return mScreenAspectRatio;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
deleted file mode 100644
index aeae8b9f..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-public class VastVideoConfiguration implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private ArrayList<String> mImpressionTrackers;
-    private ArrayList<String> mStartTrackers;
-    private ArrayList<String> mFirstQuartileTrackers;
-    private ArrayList<String> mMidpointTrackers;
-    private ArrayList<String> mThirdQuartileTrackers;
-    private ArrayList<String> mCompleteTrackers;
-    private ArrayList<String> mClickTrackers;
-    private String mClickThroughUrl;
-    private String mNetworkMediaFileUrl;
-    private String mDiskMediaFileUrl;
-    private VastCompanionAd mVastCompanionAd;
-
-    public VastVideoConfiguration() {
-        mImpressionTrackers = new ArrayList<String>();
-        mStartTrackers = new ArrayList<String>();
-        mFirstQuartileTrackers = new ArrayList<String>();
-        mMidpointTrackers = new ArrayList<String>();
-        mThirdQuartileTrackers = new ArrayList<String>();
-        mCompleteTrackers = new ArrayList<String>();
-        mClickTrackers = new ArrayList<String>();
-    }
-
-    /**
-     * Setters
-     */
-
-    public void addImpressionTrackers(final List<String> impressionTrackers) {
-        mImpressionTrackers.addAll(impressionTrackers);
-    }
-
-    public void addStartTrackers(final List<String> startTrackers) {
-        mStartTrackers.addAll(startTrackers);
-    }
-
-    public void addFirstQuartileTrackers(final List<String> firstQuartileTrackers) {
-        mFirstQuartileTrackers.addAll(firstQuartileTrackers);
-    }
-
-    public void addMidpointTrackers(final List<String> midpointTrackers) {
-        mMidpointTrackers.addAll(midpointTrackers);
-    }
-
-    public void addThirdQuartileTrackers(final List<String> thirdQuartileTrackers) {
-        mThirdQuartileTrackers.addAll(thirdQuartileTrackers);
-    }
-
-    public void addCompleteTrackers(final List<String> completeTrackers) {
-        mCompleteTrackers.addAll(completeTrackers);
-    }
-
-    public void addClickTrackers(final List<String> clickTrackers) {
-        mClickTrackers.addAll(clickTrackers);
-    }
-
-    public void setClickThroughUrl(final String clickThroughUrl) {
-        mClickThroughUrl = clickThroughUrl;
-    }
-
-    public void setNetworkMediaFileUrl(final String networkMediaFileUrl) {
-        mNetworkMediaFileUrl = networkMediaFileUrl;
-    }
-
-    public void setDiskMediaFileUrl(final String diskMediaFileUrl) {
-        mDiskMediaFileUrl = diskMediaFileUrl;
-    }
-
-    public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
-        mVastCompanionAd = vastCompanionAd;
-    }
-
-    /**
-     * Getters
-     */
-
-    public List<String> getImpressionTrackers() {
-        return mImpressionTrackers;
-    }
-
-    public List<String> getStartTrackers() {
-        return mStartTrackers;
-    }
-
-    public List<String> getFirstQuartileTrackers() {
-        return mFirstQuartileTrackers;
-    }
-
-    public List<String> getMidpointTrackers() {
-        return mMidpointTrackers;
-    }
-
-    public List<String> getThirdQuartileTrackers() {
-        return mThirdQuartileTrackers;
-    }
-
-    public List<String> getCompleteTrackers() {
-        return mCompleteTrackers;
-    }
-
-    public List<String> getClickTrackers() {
-        return mClickTrackers;
-    }
-
-    public String getClickThroughUrl() {
-        return mClickThroughUrl;
-    }
-
-    public String getNetworkMediaFileUrl() {
-        return mNetworkMediaFileUrl;
-    }
-
-    public String getDiskMediaFileUrl() {
-        return mDiskMediaFileUrl;
-    }
-
-    public VastCompanionAd getVastCompanionAd() {
-        return mVastCompanionAd;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
deleted file mode 100644
index 8b098a7d..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
+++ /dev/null
@@ -1,241 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.*;
-import java.util.*;
-
-class VastXmlManager {
-    private static final String ROOT_TAG = "MPMoVideoXMLDocRoot";
-    private static final String ROOT_TAG_OPEN = "<" + ROOT_TAG + ">";
-    private static final String ROOT_TAG_CLOSE = "</" + ROOT_TAG + ">";
-
-    // Element names
-    private static final String IMPRESSION_TRACKER = "Impression";
-    private static final String VIDEO_TRACKER = "Tracking";
-    private static final String CLICK_THROUGH = "ClickThrough";
-    private static final String CLICK_TRACKER = "ClickTracking";
-    private static final String MEDIA_FILE = "MediaFile";
-    private static final String VAST_AD_TAG = "VASTAdTagURI";
-    private static final String MP_IMPRESSION_TRACKER = "MP_TRACKING_URL";
-    private static final String COMPANION = "Companion";
-
-    // Attribute names
-    private static final String EVENT = "event";
-    private static final String WIDTH = "width";
-    private static final String HEIGHT = "height";
-
-    // Attibute values
-    private static final String START = "start";
-    private static final String FIRST_QUARTILE = "firstQuartile";
-    private static final String MIDPOINT = "midpoint";
-    private static final String THIRD_QUARTILE = "thirdQuartile";
-    private static final String COMPLETE = "complete";
-
-    // This class currently assumes an image type companion ad since that is what we are supporting
-    class ImageCompanionAdXmlManager {
-        // Element name
-        private static final String TRACKING_EVENTS = "TrackingEvents";
-        private static final String COMPANION_STATIC_RESOURCE = "StaticResource";
-        private static final String COMPANION_CLICK_THROUGH = "CompanionClickThrough";
-        // Attribute value
-        private static final String CREATIVE_VIEW = "creativeView";
-        // Attribute name
-        private static final String CREATIVE_TYPE = "creativeType";
-        private final Node mCompanionNode;
-
-        ImageCompanionAdXmlManager(final Node companionNode) throws IllegalArgumentException {
-            if (companionNode == null) {
-                throw new IllegalArgumentException("Companion node cannot be null");
-            }
-            mCompanionNode = companionNode;
-        }
-
-        Integer getWidth() {
-            return XmlUtils.getAttributeValueAsInt(mCompanionNode, WIDTH);
-        }
-
-        Integer getHeight() {
-            return XmlUtils.getAttributeValueAsInt(mCompanionNode, HEIGHT);
-        }
-
-        String getType() {
-            final Node node = XmlUtils.getFirstMatchingChildNode(
-                    mCompanionNode,
-                    COMPANION_STATIC_RESOURCE
-            );
-            return XmlUtils.getAttributeValue(node, CREATIVE_TYPE);
-        }
-
-        String getImageUrl() {
-            final Node node = XmlUtils.getFirstMatchingChildNode(
-                    mCompanionNode,
-                    COMPANION_STATIC_RESOURCE
-            );
-            return XmlUtils.getNodeValue(node);
-        }
-
-        String getClickThroughUrl() {
-            final Node node = XmlUtils.getFirstMatchingChildNode(
-                    mCompanionNode,
-                    COMPANION_CLICK_THROUGH
-            );
-            return XmlUtils.getNodeValue(node);
-        }
-
-        List<String> getClickTrackers() {
-            final List<String> companionAdClickTrackers = new ArrayList<String>();
-            final Node node = XmlUtils.getFirstMatchingChildNode(
-                    mCompanionNode,
-                    TRACKING_EVENTS
-            );
-
-            if (node == null) {
-                return companionAdClickTrackers;
-            }
-
-            final List<Node> trackerNodes = XmlUtils.getMatchingChildNodes(
-                    node,
-                    VIDEO_TRACKER,
-                    EVENT,
-                    Arrays.asList(CREATIVE_VIEW)
-            );
-
-            for (final Node trackerNode : trackerNodes) {
-                if (trackerNode.getFirstChild() != null) {
-                    companionAdClickTrackers.add(trackerNode.getFirstChild().getNodeValue().trim());
-                }
-            }
-
-            return companionAdClickTrackers;
-        }
-    }
-
-    class MediaXmlManager {
-        // Attribute names
-        private static final String DELIVERY = "delivery";
-        private static final String VIDEO_TYPE  = "type";
-        private final Node mMediaNode;
-
-        MediaXmlManager(final Node mediaNode) throws IllegalArgumentException {
-            if (mediaNode == null) {
-                throw new IllegalArgumentException("Media node cannot be null");
-            }
-            mMediaNode = mediaNode;
-        }
-
-        String getDelivery() {
-            return XmlUtils.getAttributeValue(mMediaNode, DELIVERY);
-        }
-
-        Integer getWidth() {
-            return XmlUtils.getAttributeValueAsInt(mMediaNode, WIDTH);
-        }
-
-        Integer getHeight() {
-            return XmlUtils.getAttributeValueAsInt(mMediaNode, HEIGHT);
-        }
-
-        String getType() {
-            return XmlUtils.getAttributeValue(mMediaNode, VIDEO_TYPE);
-        }
-
-        String getMediaUrl() {
-            return XmlUtils.getNodeValue(mMediaNode);
-        }
-    }
-
-    private Document mVastDoc;
-
-    void parseVastXml(String xmlString) throws ParserConfigurationException, IOException, SAXException {
-        // if the xml string starts with <?xml?>, this tag can break parsing if it isn't formatted exactly right
-        // or if it's not the first line of the document...we're just going to strip it
-        xmlString = xmlString.replaceFirst("<\\?.*\\?>", "");
-
-        // adserver may embed additional impression trackers as a sibling node of <VAST>
-        // wrap entire document in root node for this case.
-        String documentString = ROOT_TAG_OPEN + xmlString + ROOT_TAG_CLOSE;
-
-        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
-        documentBuilderFactory.setCoalescing(true);
-        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
-        mVastDoc = documentBuilder.parse(new InputSource(new StringReader(documentString)));
-    }
-
-    String getVastAdTagURI() {
-        List<String> uriWrapper = XmlUtils.getStringDataAsList(mVastDoc, VAST_AD_TAG);
-        return (uriWrapper.size() > 0) ? uriWrapper.get(0) : null;
-    }
-
-    List<String> getImpressionTrackers() {
-        List<String> impressionTrackers = XmlUtils.getStringDataAsList(mVastDoc, IMPRESSION_TRACKER);
-        impressionTrackers.addAll(XmlUtils.getStringDataAsList(mVastDoc, MP_IMPRESSION_TRACKER));
-
-        return impressionTrackers;
-    }
-
-    List<String> getVideoStartTrackers() {
-        return getVideoTrackerByAttribute(START);
-    }
-
-    List<String> getVideoFirstQuartileTrackers() {
-        return getVideoTrackerByAttribute(FIRST_QUARTILE);
-    }
-
-    List<String> getVideoMidpointTrackers() {
-        return getVideoTrackerByAttribute(MIDPOINT);
-    }
-
-    List<String> getVideoThirdQuartileTrackers() {
-        return getVideoTrackerByAttribute(THIRD_QUARTILE);
-    }
-
-    List<String> getVideoCompleteTrackers() {
-        return getVideoTrackerByAttribute(COMPLETE);
-    }
-
-    String getClickThroughUrl() {
-        List<String> clickUrlWrapper = XmlUtils.getStringDataAsList(mVastDoc, CLICK_THROUGH);
-        return (clickUrlWrapper.size() > 0) ? clickUrlWrapper.get(0) : null;
-    }
-
-    List<String> getClickTrackers() {
-        return XmlUtils.getStringDataAsList(mVastDoc, CLICK_TRACKER);
-    }
-
-    String getMediaFileUrl() {
-        List<String> urlWrapper = XmlUtils.getStringDataAsList(mVastDoc, MEDIA_FILE);
-        return (urlWrapper.size() > 0) ? urlWrapper.get(0) : null;
-    }
-
-    List<MediaXmlManager> getMediaXmlManagers() {
-        final NodeList nodes = mVastDoc.getElementsByTagName(MEDIA_FILE);
-        final List<MediaXmlManager> mediaXmlManagers =
-                new ArrayList<MediaXmlManager>(nodes.getLength());
-        for (int i = 0; i < nodes.getLength(); ++i) {
-            mediaXmlManagers.add(new MediaXmlManager(nodes.item(i)));
-        }
-        return mediaXmlManagers;
-    }
-
-    List<ImageCompanionAdXmlManager> getCompanionAdXmlManagers() {
-        final NodeList nodes = mVastDoc.getElementsByTagName(COMPANION);
-        final List<ImageCompanionAdXmlManager> imageCompanionAdXmlManagers =
-                new ArrayList<ImageCompanionAdXmlManager>(nodes.getLength());
-        for (int i = 0; i < nodes.getLength(); ++i) {
-            imageCompanionAdXmlManagers.add(new ImageCompanionAdXmlManager(nodes.item(i)));
-        }
-        return imageCompanionAdXmlManagers;
-    }
-
-    private List<String> getVideoTrackerByAttribute(final String attributeValue) {
-        return XmlUtils.getStringDataAsList(mVastDoc, VIDEO_TRACKER, EVENT, attributeValue);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
deleted file mode 100644
index e9d377ed..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import android.net.http.AndroidHttpClient;
-import android.os.AsyncTask;
-
-import com.mopub.common.HttpClient;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Strings;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.List;
-
-public class VastXmlManagerAggregator extends AsyncTask<String, Void, List<VastXmlManager>> {
-    interface VastXmlManagerAggregatorListener {
-        void onAggregationComplete(final List<VastXmlManager> vastXmlManagers);
-    }
-
-    // More than reasonable number of nested VAST urls to follow
-    static final int MAX_TIMES_TO_FOLLOW_VAST_REDIRECT = 20;
-    private final WeakReference<VastXmlManagerAggregatorListener> mVastXmlManagerAggregatorListener;
-    private int mTimesFollowedVastRedirect;
-
-    VastXmlManagerAggregator(final VastXmlManagerAggregatorListener vastXmlManagerAggregatorListener) {
-        super();
-        mVastXmlManagerAggregatorListener =
-                new WeakReference<VastXmlManagerAggregatorListener>(vastXmlManagerAggregatorListener);
-    }
-
-    @Override
-    protected List<VastXmlManager> doInBackground(String... strings) {
-        List<VastXmlManager> vastXmlManagers = null;
-        AndroidHttpClient httpClient = null;
-        try {
-            httpClient = HttpClient.getHttpClient();
-            if (strings != null && strings.length > 0) {
-                String vastXml = strings[0];
-
-                vastXmlManagers = new ArrayList<VastXmlManager>();
-                while (vastXml != null && vastXml.length() > 0 && !isCancelled()) {
-                    final VastXmlManager xmlManager = new VastXmlManager();
-                    xmlManager.parseVastXml(vastXml);
-                    vastXmlManagers.add(xmlManager);
-                    vastXml = followVastRedirect(httpClient, xmlManager.getVastAdTagURI());
-                }
-            }
-        } catch (Exception e) {
-            MoPubLog.d("Failed to parse VAST XML", e);
-        } finally {
-            if (httpClient != null) {
-                httpClient.close();
-            }
-        }
-
-        return vastXmlManagers;
-    }
-
-    @Override
-    protected void onPostExecute(final List<VastXmlManager> vastXmlManagers) {
-        final VastXmlManagerAggregatorListener listener = mVastXmlManagerAggregatorListener.get();
-        if (listener != null) {
-            listener.onAggregationComplete(vastXmlManagers);
-        }
-    }
-
-    @Override
-    protected void onCancelled() {
-        final VastXmlManagerAggregatorListener listener = mVastXmlManagerAggregatorListener.get();
-        if (listener != null) {
-            listener.onAggregationComplete(null);
-        }
-    }
-
-    String followVastRedirect(final AndroidHttpClient httpClient, final String redirectUrl) throws Exception {
-        if (redirectUrl != null && mTimesFollowedVastRedirect < MAX_TIMES_TO_FOLLOW_VAST_REDIRECT) {
-            mTimesFollowedVastRedirect++;
-
-            final HttpGet httpget = new HttpGet(redirectUrl);
-            final HttpResponse response = httpClient.execute(httpget);
-            final HttpEntity entity = response.getEntity();
-            return (entity != null) ? Strings.fromStream(entity.getContent()) : null;
-        }
-        return null;
-    }
-
-    @Deprecated
-    void setTimesFollowedVastRedirect(final int timesFollowedVastRedirect) {
-        mTimesFollowedVastRedirect = timesFollowedVastRedirect;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
deleted file mode 100644
index 79e92584..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-class XmlUtils {
-    private XmlUtils() {}
-
-    static Node getFirstMatchingChildNode(final Node node, final String nodeName) {
-        return getFirstMatchingChildNode(node, nodeName, null, null);
-    }
-
-    static Node getFirstMatchingChildNode(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
-        if (node == null || nodeName == null) {
-            return null;
-        }
-
-        final List<Node> nodes = getMatchingChildNodes(node, nodeName, attributeName, attributeValues);
-        if (nodes != null && !nodes.isEmpty()) {
-            return nodes.get(0);
-        }
-        return null;
-    }
-
-    static List<Node> getMatchingChildNodes(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
-        if (node == null || nodeName == null) {
-            return null;
-        }
-
-        final List<Node> nodes = new ArrayList<Node>();
-        final NodeList nodeList = node.getChildNodes();
-        for (int i = 0; i < nodeList.getLength(); ++i) {
-            Node childNode = nodeList.item(i);
-            if (childNode.getNodeName().equals(nodeName)
-                    && nodeMatchesAttributeFilter(childNode, attributeName, attributeValues)) {
-                nodes.add(childNode);
-            }
-        }
-        return nodes;
-    }
-
-    static boolean nodeMatchesAttributeFilter(final Node node, final String attributeName, final List<String> attributeValues) {
-        if (attributeName == null || attributeValues == null) {
-            return true;
-        }
-
-        final NamedNodeMap attrMap = node.getAttributes();
-        if (attrMap != null) {
-            Node attrNode = attrMap.getNamedItem(attributeName);
-            if (attrNode != null && attributeValues.contains(attrNode.getNodeValue())) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    static String getNodeValue(final Node node) {
-        if (node != null
-                && node.getFirstChild() != null
-                && node.getFirstChild().getNodeValue() != null) {
-            return node.getFirstChild().getNodeValue().trim();
-        }
-        return null;
-    }
-
-    static Integer getAttributeValueAsInt(final Node node, final String attributeName) {
-        if (node == null || attributeName == null) {
-            return null;
-        }
-
-        try {
-            return Integer.parseInt(getAttributeValue(node, attributeName));
-        } catch (NumberFormatException e) {
-            return null;
-        }
-    }
-
-    static String getAttributeValue(final Node node, final String attributeName) {
-        if (node == null || attributeName == null) {
-            return null;
-        }
-
-        final NamedNodeMap attrMap = node.getAttributes();
-        final Node attrNode = attrMap.getNamedItem(attributeName);
-        if (attrNode != null) {
-            return attrNode.getNodeValue();
-        }
-        return null;
-    }
-
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
-        return getStringDataAsList(vastDoc, elementName, null, null);
-    }
-
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
-        final ArrayList<String> results = new ArrayList<String>();
-
-        if (vastDoc == null) {
-            return results;
-        }
-
-        final NodeList nodes = vastDoc.getElementsByTagName(elementName);
-
-        if (nodes == null) {
-            return results;
-        }
-
-        for (int i = 0; i < nodes.getLength(); i++) {
-            final Node node = nodes.item(i);
-
-            if (node != null && nodeMatchesAttributeFilter(node, attributeName, Arrays.asList(attributeValue))) {
-                // since we parsed with coalescing set to true, CDATA is added as the child of the element
-                final String nodeValue = getNodeValue(node);
-                if (nodeValue != null) {
-                    results.add(nodeValue);
-                }
-            }
-        }
-
-        return results;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java
new file mode 100644
index 00000000..558439d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java
@@ -0,0 +1,105 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.AdViewController;
+import com.mopub.mobileads.CustomEventBanner;
+import com.mopub.mobileads.factories.MraidControllerFactory;
+import com.mopub.mraid.MraidController.MraidListener;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
+
+class MraidBanner extends CustomEventBanner {
+
+    @Nullable private MraidController mMraidController;
+    @Nullable private CustomEventBannerListener mBannerListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    @Override
+    protected void loadBanner(@NonNull Context context,
+                    @NonNull CustomEventBannerListener customEventBannerListener,
+                    @NonNull Map<String, Object> localExtras,
+                    @NonNull Map<String, String> serverExtras) {
+        mBannerListener = customEventBannerListener;
+
+        String htmlData;
+        if (extrasAreValid(serverExtras)) {
+            htmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
+        } else {
+            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            return;
+        }
+
+        try {
+            AdReport adReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            mMraidController = MraidControllerFactory.create(
+                    context, adReport, PlacementType.INLINE);
+        } catch (ClassCastException e) {
+            MoPubLog.w("MRAID banner creating failed:", e);
+            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            return;
+        }
+
+        mMraidController.setDebugListener(mDebugListener);
+        mMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // Honoring the server dimensions forces the WebView to be the size of the banner
+                AdViewController.setShouldHonorServerDimensions(view);
+                mBannerListener.onBannerLoaded(view);
+            }
+
+            @Override
+            public void onFailedToLoad() {
+                mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            }
+
+            @Override
+            public void onExpand() {
+                mBannerListener.onBannerExpanded();
+                mBannerListener.onBannerClicked();
+            }
+
+            @Override
+            public void onOpen() {
+                mBannerListener.onBannerClicked();
+            }
+
+            @Override
+            public void onClose() {
+                mBannerListener.onBannerCollapsed();
+            }
+        });
+        mMraidController.loadContent(htmlData);
+    }
+
+    @Override
+    protected void onInvalidate() {
+        if (mMraidController != null) {
+            mMraidController.setMraidListener(null);
+            mMraidController.destroy();
+        }
+    }
+
+    private boolean extrasAreValid(Map<String, String> serverExtras) {
+        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
+    }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mMraidController != null) {
+            mMraidController.setDebugListener(debugListener);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java
new file mode 100644
index 00000000..bd907c1a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java
@@ -0,0 +1,622 @@
+package com.mopub.mraid;
+
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.Constants;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.ViewGestureDetector;
+import com.mopub.mobileads.ViewGestureDetector.UserClickListener;
+import com.mopub.mobileads.resource.MraidJavascript;
+import com.mopub.mraid.MraidBridge.MraidWebView.OnVisibilityChangedListener;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
+import org.apache.http.NameValuePair;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MraidBridge {
+    private final AdReport mAdReport;
+
+    public interface MraidBridgeListener {
+        void onPageLoaded();
+
+        void onPageFailedToLoad();
+
+        void onVisibilityChanged(boolean isVisible);
+
+        boolean onJsAlert(@NonNull String message, @NonNull JsResult result);
+
+        boolean onConsoleMessage(@NonNull ConsoleMessage consoleMessage);
+
+        void onResize(int width, int height, int offsetX,
+                int offsetY, @NonNull ClosePosition closePosition, boolean allowOffscreen)
+                throws MraidCommandException;
+
+        void onExpand(URI uri, boolean shouldUseCustomClose) throws MraidCommandException;
+
+        void onClose();
+
+        void onUseCustomClose(boolean shouldUseCustomClose);
+
+        void onSetOrientationProperties(boolean allowOrientationChange, MraidOrientation
+                forceOrientation) throws MraidCommandException;
+
+        void onOpen(URI uri);
+
+        void onPlayVideo(URI uri);
+    }
+
+    private final String FILTERED_JAVASCRIPT_SOURCE = MraidJavascript.JAVASCRIPT_SOURCE
+            .replaceAll("(?m)^\\s+", "")
+            .replaceAll("(?m)^//.*(?=\\n)", "");
+
+    @NonNull private final PlacementType mPlacementType;
+
+    @NonNull private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    @Nullable private MraidBridgeListener mMraidBridgeListener;
+
+    @Nullable private MraidWebView mMraidWebView;
+
+    private boolean mIsClicked;
+
+    private boolean mHasLoaded;
+
+    MraidBridge(@Nullable AdReport adReport, @NonNull PlacementType placementType) {
+        this(adReport, placementType, new MraidNativeCommandHandler());
+    }
+
+    @VisibleForTesting
+    MraidBridge(@Nullable AdReport adReport, @NonNull PlacementType placementType,
+            @NonNull MraidNativeCommandHandler mraidNativeCommandHandler) {
+        mAdReport = adReport;
+        mPlacementType = placementType;
+        mMraidNativeCommandHandler = mraidNativeCommandHandler;
+    }
+
+    void setMraidBridgeListener(@Nullable MraidBridgeListener listener) {
+        mMraidBridgeListener = listener;
+    }
+
+    void attachView(@NonNull MraidWebView mraidWebView) {
+        mMraidWebView = mraidWebView;
+        mMraidWebView.getSettings().setJavaScriptEnabled(true);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            if (mPlacementType == PlacementType.INTERSTITIAL) {
+                mraidWebView.getSettings().setMediaPlaybackRequiresUserGesture(false);
+            }
+        }
+
+        mMraidWebView.loadUrl("javascript:" + FILTERED_JAVASCRIPT_SOURCE);
+        mMraidWebView.setScrollContainer(false);
+        mMraidWebView.setVerticalScrollBarEnabled(false);
+        mMraidWebView.setHorizontalScrollBarEnabled(false);
+        mMraidWebView.setBackgroundColor(Color.BLACK);
+
+        mMraidWebView.setWebViewClient(mMraidWebViewClient);
+
+        mMraidWebView.setWebChromeClient(new WebChromeClient() {
+            @Override
+            public boolean onJsAlert(final WebView view, final String url, final String message,
+                    final JsResult result) {
+                if (mMraidBridgeListener != null) {
+                    return mMraidBridgeListener.onJsAlert(message, result);
+                }
+                return super.onJsAlert(view, url, message, result);
+            }
+
+            @Override
+            public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+                if (mMraidBridgeListener != null) {
+                    return mMraidBridgeListener.onConsoleMessage(consoleMessage);
+                }
+                return super.onConsoleMessage(consoleMessage);
+            }
+
+            @Override
+            public void onShowCustomView(final View view, final CustomViewCallback callback) {
+                super.onShowCustomView(view, callback);
+            }
+        });
+
+        final ViewGestureDetector gestureDetector = new ViewGestureDetector(
+                mMraidWebView.getContext(), mMraidWebView, mAdReport);
+        gestureDetector.setUserClickListener(new UserClickListener() {
+            @Override
+            public void onUserClick() {
+                mIsClicked = true;
+            }
+
+            @Override
+            public void onResetUserClick() {
+                mIsClicked = false;
+            }
+
+            @Override
+            public boolean wasClicked() {
+                return mIsClicked;
+            }
+        });
+
+        mMraidWebView.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(final View v, final MotionEvent event) {
+                gestureDetector.sendTouchEvent(event);
+
+                switch (event.getAction()) {
+                    case MotionEvent.ACTION_DOWN:
+                    case MotionEvent.ACTION_UP:
+                        if (!v.hasFocus()) {
+                            v.requestFocus();
+                        }
+                        break;
+                }
+                return false;
+            }
+        });
+
+        mMraidWebView.setVisibilityChangedListener(new OnVisibilityChangedListener() {
+            @Override
+            public void onVisibilityChanged(final boolean isVisible) {
+                if (mMraidBridgeListener != null) {
+                    mMraidBridgeListener.onVisibilityChanged(isVisible);
+                }
+            }
+        });
+    }
+
+    void detach() {
+        mMraidWebView = null;
+    }
+
+    public void setContentHtml(@NonNull String htmlData) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("MRAID bridge called setContentHtml before WebView was attached");
+            return;
+        }
+
+        mHasLoaded = false;
+        mMraidWebView.loadDataWithBaseURL("http://" + Constants.HOST + "/",
+                htmlData, "text/html", "UTF-8", null);
+    }
+
+    public void setContentUrl(String url) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("MRAID bridge called setContentHtml while WebView was not attached");
+            return;
+        }
+
+        mHasLoaded = false;
+        mMraidWebView.loadUrl(url);
+    }
+
+    void injectJavaScript(@NonNull String javascript) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("Attempted to inject Javascript into MRAID WebView while was not "
+                    + "attached:\n\t" + javascript);
+            return;
+        }
+        MoPubLog.v("Injecting Javascript into MRAID WebView:\n\t" + javascript);
+        mMraidWebView.loadUrl("javascript:" + javascript);
+    }
+
+    private void fireErrorEvent(@NonNull MraidJavascriptCommand command, @NonNull String message) {
+        injectJavaScript("window.mraidbridge.notifyErrorEvent("
+                + JSONObject.quote(command.toJavascriptString()) + ", "
+                + JSONObject.quote(message) + ")");
+    }
+
+    private void fireNativeCommandCompleteEvent(@NonNull MraidJavascriptCommand command) {
+        injectJavaScript("window.mraidbridge.nativeCallComplete("
+                + JSONObject.quote(command.toJavascriptString()) + ")");
+    }
+
+    public static class MraidWebView extends BaseWebView {
+        public interface OnVisibilityChangedListener {
+            void onVisibilityChanged(boolean isVisible);
+        }
+
+        @Nullable private OnVisibilityChangedListener mOnVisibilityChangedListener;
+
+        private boolean mIsVisible;
+
+        public MraidWebView(Context context) {
+            super(context);
+            mIsVisible = getVisibility() == View.VISIBLE;
+        }
+
+        void setVisibilityChangedListener(@Nullable OnVisibilityChangedListener listener) {
+            mOnVisibilityChangedListener = listener;
+        }
+
+        @Override
+        protected void onVisibilityChanged(@NonNull View changedView, int visibility) {
+            super.onVisibilityChanged(changedView, visibility);
+            boolean newIsVisible = (visibility == View.VISIBLE);
+            if (newIsVisible != mIsVisible) {
+                mIsVisible = newIsVisible;
+                if (mOnVisibilityChangedListener != null) {
+                    mOnVisibilityChangedListener.onVisibilityChanged(mIsVisible);
+                }
+            }
+        }
+
+        public boolean isVisible() {
+            return mIsVisible;
+        }
+    }
+
+    private final WebViewClient mMraidWebViewClient = new WebViewClient() {
+        @Override
+        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
+            MoPubLog.d("Error: " + description);
+            super.onReceivedError(view, errorCode, description, failingUrl);
+        }
+
+        @Override
+        public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String url) {
+            return handleShouldOverrideUrl(url);
+        }
+
+        @Override
+        public void onPageFinished(@NonNull WebView view, @NonNull String url) {
+            handlePageFinished();
+        }
+    };
+
+    @VisibleForTesting
+    boolean handleShouldOverrideUrl(@NonNull final String url) {
+        URI uri;
+        try {
+            uri = new URI(url);
+        } catch (URISyntaxException e) {
+            MoPubLog.w("Invalid MRAID URL: " + url);
+            fireErrorEvent(MraidJavascriptCommand.UNSPECIFIED, "Mraid command sent an invalid URL");
+            return true;
+        }
+
+        // Note that scheme will be null when we are passed a relative Uri
+        String scheme = uri.getScheme();
+        String host = uri.getHost();
+
+        if ("mopub".equals(scheme)) {
+            if ("failLoad".equals(host)) {
+                if (mPlacementType == PlacementType.INLINE && mMraidBridgeListener != null) {
+                    mMraidBridgeListener.onPageFailedToLoad();
+                }
+            }
+            return true;
+        }
+
+        if ("mraid".equals(scheme)) {
+            Map<String, String> params = new HashMap<String, String>();
+            for (NameValuePair pair : URLEncodedUtils.parse(uri, "UTF-8")) {
+                params.put(pair.getName(), pair.getValue());
+            }
+            MraidJavascriptCommand command = MraidJavascriptCommand.fromJavascriptString(host);
+            try {
+                runCommand(command, params);
+            } catch (MraidCommandException exception) {
+                fireErrorEvent(command, exception.getMessage());
+            }
+            fireNativeCommandCompleteEvent(command);
+            return true;
+        }
+
+        // This block handles all other URLs, including sms://, tel://,
+        // clicking a hyperlink, or setting window.location directly in Javascript. It checks for
+        // clicked in order to avoid interfering with automatically browser redirects.
+        if (mIsClicked) {
+            Intent intent = new Intent();
+            intent.setAction(Intent.ACTION_VIEW);
+            intent.setData(Uri.parse(url));
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+            try {
+                if (mMraidWebView == null) {
+                    MoPubLog.d("WebView was detached. Unable to load a URL");
+                    return true;
+                }
+                mMraidWebView.getContext().startActivity(intent);
+                return true;
+            } catch (ActivityNotFoundException e) {
+                MoPubLog.d("No activity found to handle this URL " + url);
+                return false;
+            }
+        }
+
+        return false;
+    }
+
+    @VisibleForTesting
+    private void handlePageFinished() {
+        // This can happen a second time if the ad does something that changes the window location,
+        // such as a redirect, changing window.location in Javascript, or programmatically clicking
+        // a hyperlink. Note that the handleShouldOverrideUrl method skips doing its own
+        // processing if the user hasn't clicked the ad.
+        if (mHasLoaded) {
+            return;
+        }
+
+        mHasLoaded = true;
+        if (mMraidBridgeListener != null) {
+            mMraidBridgeListener.onPageLoaded();
+        }
+    }
+
+    @VisibleForTesting
+    void runCommand(@NonNull final MraidJavascriptCommand command,
+            @NonNull Map<String, String> params)
+            throws MraidCommandException {
+        if (command.requiresClick(mPlacementType) && !mIsClicked) {
+            throw new MraidCommandException("Cannot execute this command unless the user clicks");
+        }
+
+        if (mMraidBridgeListener == null) {
+            throw new MraidCommandException("Invalid state to execute this command");
+        }
+
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("The current WebView is being destroyed");
+        }
+
+        switch (command) {
+            case CLOSE:
+                mMraidBridgeListener.onClose();
+                break;
+            case RESIZE:
+                // All these params are required
+                int width = checkRange(parseSize(params.get("width")), 0, 100000);
+                int height = checkRange(parseSize(params.get("height")), 0, 100000);
+                int offsetX = checkRange(parseSize(params.get("offsetX")), -100000, 100000);
+                int offsetY = checkRange(parseSize(params.get("offsetY")), -100000, 100000);
+                ClosePosition closePosition = parseClosePosition(
+                        params.get("customClosePosition"), ClosePosition.TOP_RIGHT);
+                boolean allowOffscreen = parseBoolean(params.get("allowOffscreen"), true);
+                mMraidBridgeListener.onResize(
+                        width, height, offsetX, offsetY, closePosition, allowOffscreen);
+                break;
+            case EXPAND:
+                URI uri = parseURI(params.get("url"), null);
+                boolean shouldUseCustomClose = parseBoolean(params.get("shouldUseCustomClose"),
+                        false);
+                mMraidBridgeListener.onExpand(uri, shouldUseCustomClose);
+                break;
+            case USE_CUSTOM_CLOSE:
+                shouldUseCustomClose = parseBoolean(params.get("shouldUseCustomClose"), false);
+                mMraidBridgeListener.onUseCustomClose(shouldUseCustomClose);
+                break;
+            case OPEN:
+                uri = parseURI(params.get("url"));
+                mMraidBridgeListener.onOpen(uri);
+                break;
+            case SET_ORIENTATION_PROPERTIES:
+                boolean allowOrientationChange = parseBoolean(params.get("allowOrientationChange"));
+                MraidOrientation forceOrientation = parseOrientation(params.get("forceOrientation"));
+
+                mMraidBridgeListener.onSetOrientationProperties(allowOrientationChange,
+                        forceOrientation);
+                break;
+            case PLAY_VIDEO:
+                uri = parseURI(params.get("uri"));
+                mMraidBridgeListener.onPlayVideo(uri);
+                break;
+            case STORE_PICTURE:
+                uri = parseURI(params.get("uri"));
+                mMraidNativeCommandHandler.storePicture(mMraidWebView.getContext(), uri.toString(),
+                        new MraidCommandFailureListener() {
+                            @Override
+                            public void onFailure(final MraidCommandException exception) {
+                                fireErrorEvent(command, exception.getMessage());
+                            }
+                        });
+                break;
+
+            case CREATE_CALENDAR_EVENT:
+                mMraidNativeCommandHandler.createCalendarEvent(mMraidWebView.getContext(), params);
+                break;
+            case UNSPECIFIED:
+                throw new MraidCommandException("Unspecified MRAID Javascript command");
+        }
+    }
+
+    private ClosePosition parseClosePosition(@NonNull String text,
+            @NonNull ClosePosition defaultValue)
+            throws MraidCommandException {
+        if (TextUtils.isEmpty(text)) {
+            return defaultValue;
+        }
+
+        if (text.equals("top-left")) {
+            return ClosePosition.TOP_LEFT;
+        } else if (text.equals("top-right")) {
+            return ClosePosition.TOP_RIGHT;
+        } else if (text.equals("center")) {
+            return ClosePosition.CENTER;
+        } else if (text.equals("bottom-left")) {
+            return ClosePosition.BOTTOM_LEFT;
+        } else if (text.equals("bottom-right")) {
+            return ClosePosition.BOTTOM_RIGHT;
+        } else if (text.equals("top-center")) {
+            return ClosePosition.TOP_CENTER;
+        } else if (text.equals("bottom-center")) {
+            return ClosePosition.BOTTOM_CENTER;
+        } else {
+            throw new MraidCommandException("Invalid close position: " + text);
+        }
+    }
+
+    private int parseSize(@NonNull String text) throws MraidCommandException {
+        int result;
+        try {
+            result = Integer.parseInt(text, 10);
+        } catch (NumberFormatException e) {
+            throw new MraidCommandException("Invalid numeric parameter: " + text);
+        }
+        return result;
+    }
+
+    private MraidOrientation parseOrientation(String text) throws MraidCommandException {
+        if ("portrait".equals(text)) {
+            return MraidOrientation.PORTRAIT;
+        } else if ("landscape".equals(text)) {
+            return MraidOrientation.LANDSCAPE;
+        } else if ("none".equals(text)) {
+            return MraidOrientation.NONE;
+        } else {
+            throw new MraidCommandException("Invalid orientation: " + text);
+        }
+    }
+
+    private int checkRange(int value, int min, int max) throws MraidCommandException {
+        if (value < min || value > max) {
+            throw new MraidCommandException("Integer parameter out of range: " + value);
+        }
+        return value;
+    }
+
+    private boolean parseBoolean(
+            @Nullable String text, boolean defaultValue) throws MraidCommandException {
+        if (text == null) {
+            return defaultValue;
+        }
+        return parseBoolean(text);
+    }
+
+    private boolean parseBoolean(final String text) throws MraidCommandException {
+        if ("true".equals(text)) {
+            return true;
+        } else if ("false".equals(text)) {
+            return false;
+        }
+        throw new MraidCommandException("Invalid boolean parameter: " + text);
+    }
+
+    @NonNull
+    private URI parseURI(@Nullable String encodedText, URI defaultValue)
+            throws MraidCommandException {
+        if (encodedText == null) {
+            return defaultValue;
+        }
+        return parseURI(encodedText);
+    }
+
+    @NonNull
+    private URI parseURI(@Nullable String encodedText) throws MraidCommandException {
+        if (encodedText == null) {
+            throw new MraidCommandException("Parameter cannot be null");
+        }
+        try {
+            return new URI(encodedText);
+        } catch (URISyntaxException e) {
+            throw new MraidCommandException("Invalid URL parameter: " + encodedText);
+        }
+    }
+
+    void notifyViewability(boolean isViewable) {
+        injectJavaScript("mraidbridge.setIsViewable("
+                + isViewable
+                + ")");
+    }
+
+    void notifyPlacementType(PlacementType placementType) {
+        injectJavaScript("mraidbridge.setPlacementType("
+                + JSONObject.quote(placementType.toJavascriptString())
+                + ")");
+    }
+
+    void notifyViewState(ViewState state) {
+        injectJavaScript("mraidbridge.setState("
+                + JSONObject.quote(state.toJavascriptString())
+                + ")");
+    }
+
+    void notifySupports(boolean sms, boolean telephone, boolean calendar,
+            boolean storePicture, boolean inlineVideo) {
+        injectJavaScript("mraidbridge.setSupports("
+                + sms + "," + telephone + "," + calendar + "," + storePicture + "," + inlineVideo
+                + ")");
+    }
+
+    @NonNull
+    private String stringifyRect(Rect rect) {
+        return rect.left + "," + rect.top + "," + rect.width() + "," + rect.height();
+    }
+
+    @NonNull
+    private String stringifySize(Rect rect) {
+        return rect.width() + "," + rect.height();
+    }
+
+    public void notifyScreenMetrics(@NonNull final MraidScreenMetrics screenMetrics) {
+        injectJavaScript("mraidbridge.setScreenSize("
+                + stringifySize(screenMetrics.getScreenRectDips())
+                + ");mraidbridge.setMaxSize("
+                + stringifySize(screenMetrics.getRootViewRectDips())
+                + ");mraidbridge.setCurrentPosition("
+                + stringifyRect(screenMetrics.getCurrentAdRectDips())
+                + ");mraidbridge.setDefaultPosition("
+                + stringifyRect(screenMetrics.getDefaultAdRectDips())
+                + ")");
+        injectJavaScript("mraidbridge.notifySizeChangeEvent("
+                + stringifySize(screenMetrics.getCurrentAdRect())
+                + ")");
+    }
+
+    void notifyReady() {
+        injectJavaScript("mraidbridge.notifyReadyEvent();");
+    }
+
+    boolean isClicked() {
+        return mIsClicked;
+    }
+
+    boolean isVisible() {
+        return mMraidWebView != null && mMraidWebView.isVisible();
+    }
+
+    boolean isAttached() {
+        return mMraidWebView != null;
+    }
+
+    boolean isLoaded() {
+        return mHasLoaded;
+    }
+
+    @VisibleForTesting
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    void setClicked(boolean clicked) {
+        mIsClicked = clicked;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java
new file mode 100644
index 00000000..3db8e050
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java
@@ -0,0 +1,19 @@
+package com.mopub.mraid;
+
+class MraidCommandException extends Exception {
+    MraidCommandException() {
+        super();
+    }
+
+    MraidCommandException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    MraidCommandException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+
+    MraidCommandException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
new file mode 100644
index 00000000..c66ceb88
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
@@ -0,0 +1,1117 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.graphics.Rect;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver.OnPreDrawListener;
+import android.view.WindowManager;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Views;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.util.WebViews;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+
+import java.lang.ref.WeakReference;
+import java.net.URI;
+
+import static android.content.pm.ActivityInfo.CONFIG_ORIENTATION;
+import static android.content.pm.ActivityInfo.CONFIG_SCREEN_SIZE;
+import static com.mopub.common.util.Utils.bitMaskContainsFlag;
+
+public class MraidController {
+    private final AdReport mAdReport;
+
+    public interface MraidListener {
+        public void onLoaded(View view);
+        public void onFailedToLoad();
+        public void onExpand();
+        public void onOpen();
+        public void onClose();
+    }
+
+    public interface UseCustomCloseListener {
+        public void useCustomCloseChanged(boolean useCustomClose);
+    }
+
+    /**
+     * Holds a weak reference to the activity if the context that is passed in is an activity.
+     * While this field is never null, the reference could become null. This reference starts out
+     * null if the passed-in context is not an activity.
+     */
+    @NonNull private final WeakReference<Activity> mWeakActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final PlacementType mPlacementType;
+
+    // An ad container, which contains the ad web view in default state, but is empty when expanded.
+    @NonNull private final FrameLayout mDefaultAdContainer;
+
+    // Ad ad container which contains the ad view in expanded state.
+    @NonNull private final CloseableLayout mCloseableAdContainer;
+
+    // Root view, where we'll add the expanded ad
+    @Nullable private ViewGroup mRootView;
+
+    // Helper classes for updating screen values
+    @NonNull private final ScreenMetricsWaiter mScreenMetricsWaiter;
+    @NonNull private final MraidScreenMetrics mScreenMetrics;
+
+    // Current view state
+    @NonNull private ViewState mViewState = ViewState.LOADING;
+
+    // Listeners
+    @Nullable private MraidListener mMraidListener;
+    @Nullable private UseCustomCloseListener mOnCloseButtonListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    // The WebView which will display the ad. "Two part" creatives, loaded via handleExpand(URL)
+    // are shown in a separate web view
+    @Nullable private MraidWebView mMraidWebView;
+    @Nullable private MraidWebView mTwoPartWebView;
+
+    // A bridge to handle all interactions with the WebView HTML and Javascript.
+    @NonNull private final MraidBridge mMraidBridge;
+    @NonNull private final MraidBridge mTwoPartBridge;
+
+    @NonNull private OrientationBroadcastReceiver mOrientationBroadcastReceiver =
+            new OrientationBroadcastReceiver();
+
+    // Stores the requested orientation for the Activity to which this controller's view belongs.
+    // This is needed to restore the Activity's requested orientation in the event that the view
+    // itself requires an orientation lock.
+    @Nullable private Integer mOriginalActivityOrientation;
+
+    private boolean mAllowOrientationChange = true;
+    private MraidOrientation mForceOrientation = MraidOrientation.NONE;
+
+    private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    private boolean mIsPaused;
+
+    public MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType) {
+        this(context, adReport, placementType,
+                new MraidBridge(adReport, placementType),
+                new MraidBridge(adReport, PlacementType.INTERSTITIAL),
+                new ScreenMetricsWaiter());
+    }
+
+    @VisibleForTesting
+    MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType,
+            @NonNull MraidBridge bridge, @NonNull MraidBridge twoPartBridge,
+            @NonNull ScreenMetricsWaiter screenMetricsWaiter) {
+        mContext = context.getApplicationContext();
+        Preconditions.checkNotNull(mContext);
+        mAdReport = adReport;
+        if (context instanceof Activity) {
+            mWeakActivity = new WeakReference<Activity>((Activity) context);
+        } else {
+            // Make sure mWeakActivity itself is never null, though the reference
+            // it's pointing to could be null.
+            mWeakActivity = new WeakReference<Activity>(null);
+        }
+
+        mPlacementType = placementType;
+        mMraidBridge = bridge;
+        mTwoPartBridge = twoPartBridge;
+        mScreenMetricsWaiter = screenMetricsWaiter;
+
+        mViewState = ViewState.LOADING;
+
+        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+        mScreenMetrics = new MraidScreenMetrics(mContext, displayMetrics.density);
+        mDefaultAdContainer = new FrameLayout(mContext);
+        mCloseableAdContainer = new CloseableLayout(mContext);
+        mCloseableAdContainer.setOnCloseListener(new OnCloseListener() {
+            @Override
+            public void onClose() {
+                handleClose();
+            }
+        });
+
+        View dimmingView = new View(mContext);
+        dimmingView.setOnTouchListener(new OnTouchListener() {
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+        mCloseableAdContainer.addView(dimmingView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        mOrientationBroadcastReceiver.register(mContext);
+
+        mMraidBridge.setMraidBridgeListener(mMraidBridgeListener);
+        mTwoPartBridge.setMraidBridgeListener(mTwoPartBridgeListener);
+        mMraidNativeCommandHandler = new MraidNativeCommandHandler();
+    }
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mMraidBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handlePageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            if (mMraidListener != null) {
+                mMraidListener.onFailedToLoad();
+            }
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The bridge only receives visibility events if there is no 2 part covering it
+            if (!mTwoPartBridge.isAttached()) {
+                mMraidBridge.notifyViewability(isVisible);
+            }
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            handleResize(width, height, offsetX, offsetY, closePosition, allowOffscreen);
+        }
+
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose)
+                throws MraidCommandException {
+            handleExpand(uri, shouldUseCustomClose);
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(@NonNull final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mTwoPartBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handleTwoPartPageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            // no-op for two-part expandables. An expandable failing to load should not trigger failover.
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The original web view must see the 2-part bridges visibility
+            mMraidBridge.notifyViewability(isVisible);
+            mTwoPartBridge.notifyViewability(isVisible);
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            throw new MraidCommandException("Not allowed to resize from an expanded state");
+        }
+
+        @Override
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose) {
+            // The MRAID spec dictates that this is ignored rather than firing an error
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    public void setMraidListener(@Nullable MraidListener mraidListener) {
+        mMraidListener = mraidListener;
+    }
+
+    public void setUseCustomCloseListener(@Nullable UseCustomCloseListener listener) {
+        mOnCloseButtonListener = listener;
+    }
+
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+    }
+
+    public void loadContent(@NonNull String htmlData) {
+        Preconditions.checkState(mMraidWebView == null, "loadContent should only be called once");
+
+        mMraidWebView = new MraidWebView(mContext);
+        mMraidBridge.attachView(mMraidWebView);
+        mDefaultAdContainer.addView(mMraidWebView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        // onPageLoaded gets fired once the html is loaded into the webView
+        mMraidBridge.setContentHtml(htmlData);
+    }
+
+    // onPageLoaded gets fired once the html is loaded into the webView.
+    private int getDisplayRotation() {
+        WindowManager wm = (WindowManager) mContext
+                .getSystemService(Context.WINDOW_SERVICE);
+        return wm.getDefaultDisplay().getRotation();
+    }
+
+    @VisibleForTesting
+    boolean handleConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+        //noinspection SimplifiableIfStatement
+        if (mDebugListener != null) {
+            return mDebugListener.onConsoleMessage(consoleMessage);
+        }
+        return true;
+    }
+
+    @VisibleForTesting
+    boolean handleJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+        if (mDebugListener != null) {
+            return mDebugListener.onJsAlert(message, result);
+        }
+        result.confirm();
+        return true;
+    }
+
+    @VisibleForTesting
+    static class ScreenMetricsWaiter {
+        static class WaitRequest {
+            @NonNull private final View[] mViews;
+            @NonNull private final Handler mHandler;
+            @Nullable private Runnable mSuccessRunnable;
+            int mWaitCount;
+
+            private WaitRequest(@NonNull Handler handler, @NonNull final View[] views) {
+                mHandler = handler;
+                mViews = views;
+            }
+
+            private void countDown() {
+                mWaitCount--;
+                if (mWaitCount == 0 && mSuccessRunnable != null) {
+                    mSuccessRunnable.run();
+                    mSuccessRunnable = null;
+                }
+            }
+
+            private final Runnable mWaitingRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    for (final View view : mViews) {
+                        // Immediately count down for any views that already have a size
+                        if (view.getHeight() > 0 || view.getWidth() > 0) {
+                            countDown();
+                            continue;
+                        }
+
+                        // For views that didn't have a size, listen (once) for a preDraw. Note
+                        // that this doesn't leak because the ViewTreeObserver gets detached when
+                        // the view is no longer part of the view hierarchy.
+                        view.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
+                            @Override
+                            public boolean onPreDraw() {
+                                view.getViewTreeObserver().removeOnPreDrawListener(this);
+                                countDown();
+                                return true;
+                            }
+                        });
+                    }
+                }
+            };
+
+            void start(@NonNull Runnable successRunnable) {
+                mSuccessRunnable = successRunnable;
+                mWaitCount = mViews.length;
+                mHandler.post(mWaitingRunnable);
+            }
+
+            void cancel() {
+                mHandler.removeCallbacks(mWaitingRunnable);
+                mSuccessRunnable = null;
+            }
+        }
+
+        @NonNull private final Handler mHandler = new Handler();
+        @Nullable private WaitRequest mLastWaitRequest;
+
+        WaitRequest waitFor(@NonNull View... views) {
+            mLastWaitRequest = new WaitRequest(mHandler, views);
+            return mLastWaitRequest;
+        }
+
+        void cancelLastRequest() {
+            if (mLastWaitRequest != null) {
+                mLastWaitRequest.cancel();
+                mLastWaitRequest = null;
+            }
+        }
+    }
+
+    @Nullable
+    private View getCurrentWebView() {
+        return mTwoPartBridge.isAttached() ? mTwoPartWebView : mMraidWebView;
+    }
+
+    private boolean isInlineVideoAvailable() {
+        //noinspection SimplifiableIfStatement
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || getCurrentWebView() == null) {
+            return false;
+        }
+
+        return mMraidNativeCommandHandler.isInlineVideoAvailable(activity, getCurrentWebView());
+    }
+
+    @VisibleForTesting
+    void handlePageLoad() {
+        setViewState(ViewState.DEFAULT, new Runnable() {
+            @Override
+            public void run() {
+                mMraidBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        MraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        MraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mMraidBridge.notifyPlacementType(mPlacementType);
+                mMraidBridge.notifyViewability(mMraidBridge.isVisible());
+                mMraidBridge.notifyReady();
+            }
+        });
+
+        // Call onLoaded immediately. This causes the container to get added to the view hierarchy
+        if (mMraidListener != null) {
+            mMraidListener.onLoaded(mDefaultAdContainer);
+        }
+    }
+
+    @VisibleForTesting
+    void handleTwoPartPageLoad() {
+        updateScreenMetricsAsync(new Runnable() {
+            @Override
+            public void run() {
+                mTwoPartBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        mMraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        mMraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mTwoPartBridge.notifyViewState(mViewState);
+                mTwoPartBridge.notifyPlacementType(mPlacementType);
+                mTwoPartBridge.notifyViewability(mTwoPartBridge.isVisible());
+                mTwoPartBridge.notifyReady();
+            }
+        });
+    }
+
+    /**
+     * Updates screen metrics, calling the successRunnable once they are available. The
+     * successRunnable will always be called asynchronously, ie on the next main thread loop.
+     */
+    private void updateScreenMetricsAsync(@Nullable final Runnable successRunnable) {
+        // Don't allow multiple metrics wait requests at once
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        // Determine which web view should be used for the current ad position
+        final View currentWebView = getCurrentWebView();
+        if (currentWebView == null) {
+            return;
+        }
+
+        // Wait for the next draw pass on the default ad container and current web view
+        mScreenMetricsWaiter.waitFor(mDefaultAdContainer, currentWebView).start(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+                        mScreenMetrics.setScreenSize(
+                                displayMetrics.widthPixels, displayMetrics.heightPixels);
+
+                        int[] location = new int[2];
+                        View rootView = getRootView();
+                        rootView.getLocationOnScreen(location);
+                        mScreenMetrics.setRootViewPosition(location[0], location[1],
+                                rootView.getWidth(),
+                                rootView.getHeight());
+
+                        mDefaultAdContainer.getLocationOnScreen(location);
+                        mScreenMetrics.setDefaultAdPosition(location[0], location[1],
+                                mDefaultAdContainer.getWidth(),
+                                mDefaultAdContainer.getHeight());
+
+                        currentWebView.getLocationOnScreen(location);
+                        mScreenMetrics.setCurrentAdPosition(location[0], location[1],
+                                currentWebView.getWidth(),
+                                currentWebView.getHeight());
+
+                        // Always notify both bridges of the new metrics
+                        mMraidBridge.notifyScreenMetrics(mScreenMetrics);
+                        if (mTwoPartBridge.isAttached()) {
+                            mTwoPartBridge.notifyScreenMetrics(mScreenMetrics);
+                        }
+
+                        if (successRunnable != null) {
+                            successRunnable.run();
+                        }
+                    }
+                });
+    }
+
+    void handleOrientationChange(int currentRotation) {
+        updateScreenMetricsAsync(null);
+    }
+
+    public void pause(boolean isFinishing) {
+        mIsPaused = true;
+
+        // This causes an inline video to pause if there is one playing
+        if (mMraidWebView != null) {
+            WebViews.onPause(mMraidWebView, isFinishing);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onPause(mTwoPartWebView, isFinishing);
+        }
+    }
+
+    public void resume() {
+        mIsPaused = false;
+
+        // This causes an inline video to resume if it was playing previously
+        if (mMraidWebView != null) {
+            WebViews.onResume(mMraidWebView);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onResume(mTwoPartWebView);
+        }
+    }
+
+    public void destroy() {
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        try {
+            mOrientationBroadcastReceiver.unregister();
+        } catch (IllegalArgumentException e) {
+            if (!e.getMessage().contains("Receiver not registered")) {
+                throw e;
+            } // Else ignore this exception.
+        }
+
+        // Pause the controller to make sure the video gets stopped.
+        if (!mIsPaused) {
+            pause(true);
+        }
+
+        // Remove the closeable ad container from the view hierarchy, if necessary
+        Views.removeFromParent(mCloseableAdContainer);
+
+        // Calling destroy eliminates a memory leak on Gingerbread devices
+        mMraidBridge.detach();
+        if (mMraidWebView != null) {
+            mMraidWebView.destroy();
+            mMraidWebView = null;
+        }
+        mTwoPartBridge.detach();
+        if (mTwoPartWebView != null) {
+            mTwoPartWebView.destroy();
+            mTwoPartWebView = null;
+        }
+    }
+
+    private void setViewState(@NonNull ViewState viewState) {
+        setViewState(viewState, null);
+    }
+
+    private void setViewState(@NonNull ViewState viewState, @Nullable Runnable successRunnable) {
+        // Make sure this is a valid transition.
+        MoPubLog.d("MRAID state set to " + viewState);
+        mViewState = viewState;
+        mMraidBridge.notifyViewState(viewState);
+
+        // Changing state notifies the two part view, but only if it's loaded
+        if (mTwoPartBridge.isLoaded()) {
+            mTwoPartBridge.notifyViewState(viewState);
+        }
+
+        if (mMraidListener != null) {
+            if (viewState == ViewState.EXPANDED) {
+                mMraidListener.onExpand();
+            } else if (viewState == ViewState.HIDDEN) {
+                mMraidListener.onClose();
+            }
+        }
+
+        updateScreenMetricsAsync(successRunnable);
+    }
+
+    int clampInt(int min, int target, int max) {
+        return Math.max(min, Math.min(target, max));
+    }
+
+    @VisibleForTesting
+    void handleResize(final int widthDips, final int heightDips, final int offsetXDips,
+            final int offsetYDips, @NonNull final ClosePosition closePosition,
+            final boolean allowOffscreen)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to resize after the WebView is destroyed");
+        }
+
+        // The spec says that there is no effect calling resize from loaded or hidden, but that
+        // calling it from expanded should raise an error.
+        if (mViewState == ViewState.LOADING
+                || mViewState == ViewState.HIDDEN) {
+            return;
+        } else if (mViewState == ViewState.EXPANDED) {
+            throw new MraidCommandException("Not allowed to resize from an already expanded ad");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            throw new MraidCommandException("Not allowed to resize from an interstitial ad");
+        }
+
+        // Translate coordinates to px and get the resize rect
+        int width = Dips.dipsToIntPixels(widthDips, mContext);
+        int height = Dips.dipsToIntPixels(heightDips, mContext);
+        int offsetX = Dips.dipsToIntPixels(offsetXDips, mContext);
+        int offsetY = Dips.dipsToIntPixels(offsetYDips, mContext);
+        int left = mScreenMetrics.getDefaultAdRect().left + offsetX;
+        int top = mScreenMetrics.getDefaultAdRect().top + offsetY;
+        Rect resizeRect = new Rect(left, top, left + width, top + height);
+
+        if (!allowOffscreen) {
+            // Require the entire ad to be on-screen.
+            Rect bounds = mScreenMetrics.getRootViewRect();
+            if (resizeRect.width() > bounds.width() || resizeRect.height() > bounds.height()) {
+                throw new MraidCommandException("resizeProperties specified a size ("
+                        + widthDips + ", " + heightDips + ") and offset ("
+                        + offsetXDips + ", " + offsetYDips + ") that doesn't allow the ad to"
+                        + " appear within the max allowed size ("
+                        + mScreenMetrics.getRootViewRectDips().width() + ", "
+                        + mScreenMetrics.getRootViewRectDips().height() + ")");
+            }
+
+            // Offset the resize rect so that it displays on the screen
+            int newLeft = clampInt(bounds.left, resizeRect.left, bounds.right - resizeRect.width());
+            int newTop = clampInt(bounds.top, resizeRect.top, bounds.bottom - resizeRect.height());
+            resizeRect.offsetTo(newLeft, newTop);
+        }
+
+        // The entire close region must always be visible.
+        Rect closeRect = new Rect();
+        mCloseableAdContainer.applyCloseRegionBounds(closePosition, resizeRect, closeRect);
+        if (!mScreenMetrics.getRootViewRect().contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + heightDips + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that doesn't allow the close"
+                    + " region to appear within the max allowed size ("
+                    + mScreenMetrics.getRootViewRectDips().width() + ", "
+                    + mScreenMetrics.getRootViewRectDips().height() + ")");
+        }
+
+        if (!resizeRect.contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + height + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
+                    + "within the resized ad.");
+        }
+
+        // Resized ads always rely on the creative's close button (as if useCustomClose were true)
+        mCloseableAdContainer.setCloseVisible(false);
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        // Put the ad in the closeable container and resize it
+        LayoutParams layoutParams = new LayoutParams(resizeRect.width(), resizeRect.height());
+        layoutParams.leftMargin = resizeRect.left - mScreenMetrics.getRootViewRect().left;
+        layoutParams.topMargin = resizeRect.top - mScreenMetrics.getRootViewRect().top;
+        if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.removeView(mMraidWebView);
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            mCloseableAdContainer.addView(mMraidWebView,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+            getRootView().addView(mCloseableAdContainer, layoutParams);
+        } else if (mViewState == ViewState.RESIZED) {
+            mCloseableAdContainer.setLayoutParams(layoutParams);
+        }
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        setViewState(ViewState.RESIZED);
+    }
+
+    void handleExpand(@Nullable URI uri, boolean shouldUseCustomClose)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to expand after the WebView is destroyed");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            return;
+        }
+
+        if (mViewState != ViewState.DEFAULT && mViewState != ViewState.RESIZED) {
+            return;
+        }
+
+        applyOrientation();
+
+        // For two part expands, create a new web view
+        boolean isTwoPart = (uri != null);
+        if (isTwoPart) {
+            // Of note: the two part ad will start off with its view state as LOADING, and will
+            // transition to EXPANDED once the page is fully loaded
+            mTwoPartWebView = new MraidWebView(mContext);
+            mTwoPartBridge.attachView(mTwoPartWebView);
+
+            // onPageLoaded gets fired once the html is loaded into the two part webView
+            mTwoPartBridge.setContentUrl(uri.toString());
+        }
+
+        // Make sure the correct webView is in the closeable  container and make it full screen
+        LayoutParams layoutParams = new LayoutParams(
+                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        if (mViewState == ViewState.DEFAULT) {
+            if (isTwoPart) {
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            } else {
+                mDefaultAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mMraidWebView, layoutParams);
+            }
+            getRootView().addView(mCloseableAdContainer,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        } else if (mViewState == ViewState.RESIZED) {
+            if (isTwoPart) {
+                // Move the ad back to the original container so that when we close the
+                // resized ad, it will be in the correct place
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, layoutParams);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            }
+            // If we were resized and not 2 part, nothing to do.
+        }
+        mCloseableAdContainer.setLayoutParams(layoutParams);
+        handleCustomClose(shouldUseCustomClose);
+
+        // Update to expanded once we have new screen metrics. This won't update the two-part ad,
+        // because it is not yet loaded.
+        setViewState(ViewState.EXPANDED);
+    }
+
+    @VisibleForTesting
+    void handleClose() {
+        if (mMraidWebView == null) {
+            // Doesn't throw an exception because the ad has been destroyed
+            return;
+        }
+
+        if (mViewState == ViewState.LOADING || mViewState == ViewState.HIDDEN) {
+            return;
+        }
+
+        // Unlock the orientation before changing the view hierarchy.
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            unApplyOrientation();
+        }
+
+        if (mViewState == ViewState.RESIZED || mViewState == ViewState.EXPANDED) {
+            if (mTwoPartBridge.isAttached() && mTwoPartWebView != null) {
+                // If we have a two part web view, simply remove it from the closeable container
+                mCloseableAdContainer.removeView(mTwoPartWebView);
+                mTwoPartBridge.detach();
+            } else {
+                // Move the web view from the closeable container back to the default container
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, new LayoutParams(
+                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+                mDefaultAdContainer.setVisibility(View.VISIBLE);
+            }
+            getRootView().removeView(mCloseableAdContainer);
+
+            // Set the view state to default
+            setViewState(ViewState.DEFAULT);
+        } else if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            setViewState(ViewState.HIDDEN);
+        }
+    }
+
+    @NonNull
+    @TargetApi(VERSION_CODES.KITKAT)
+    private ViewGroup getRootView() {
+        if (mRootView == null) {
+            // This method should never be called this method before the container is ready, ie before
+            // handlePageLoad.
+            if (VERSION.SDK_INT >= VERSION_CODES.KITKAT) {
+                Preconditions.checkState(mDefaultAdContainer.isAttachedToWindow());
+            }
+
+            mRootView = (ViewGroup) mDefaultAdContainer.getRootView().findViewById(
+                    android.R.id.content);
+        }
+
+        return mRootView;
+    }
+
+    @VisibleForTesting
+    void handleShowVideo(@NonNull String videoUrl) {
+        MraidVideoPlayerActivity.startMraid(mContext, videoUrl);
+    }
+
+    @VisibleForTesting
+    void lockOrientation(final int screenOrientation) throws MraidCommandException {
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || !shouldAllowForceOrientation(mForceOrientation)) {
+            throw new MraidCommandException("Attempted to lock orientation to unsupported value: " +
+                    mForceOrientation.name());
+        }
+
+        if (mOriginalActivityOrientation == null) {
+            mOriginalActivityOrientation = activity.getRequestedOrientation();
+        }
+
+        activity.setRequestedOrientation(screenOrientation);
+    }
+
+    @VisibleForTesting
+    void applyOrientation() throws MraidCommandException {
+        if (mForceOrientation == MraidOrientation.NONE) {
+            if (mAllowOrientationChange) {
+                // If screen orientation can be changed, an orientation of NONE means that any
+                // orientation lock should be removed
+                unApplyOrientation();
+            } else {
+                final Activity activity = mWeakActivity.get();
+                if (activity == null) {
+                    throw new MraidCommandException("Unable to set MRAID expand orientation to " +
+                            "'none'; expected passed in Activity Context.");
+                }
+
+                // If screen orientation cannot be changed and we can obtain the current
+                // screen orientation, locking it to the current orientation is a best effort
+                lockOrientation(DeviceUtils.getScreenOrientation(activity));
+            }
+        } else {
+            // Otherwise, we have a valid, non-NONE orientation. Lock the screen based on this value
+            lockOrientation(mForceOrientation.getActivityInfoOrientation());
+        }
+    }
+
+    @VisibleForTesting
+    void unApplyOrientation() {
+        final Activity activity = mWeakActivity.get();
+        if (activity != null && mOriginalActivityOrientation != null) {
+            activity.setRequestedOrientation(mOriginalActivityOrientation);
+        }
+        mOriginalActivityOrientation = null;
+    }
+
+    @TargetApi(VERSION_CODES.HONEYCOMB_MR2)
+    @VisibleForTesting
+    boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
+        // NONE is the default and always allowed
+        if (newOrientation == MraidOrientation.NONE) {
+            return true;
+        }
+
+        final Activity activity = mWeakActivity.get();
+        // If we can't obtain an Activity, return false
+        if (activity == null) {
+            return false;
+        }
+
+        final ActivityInfo activityInfo;
+        try {
+            activityInfo = activity.getPackageManager().getActivityInfo(
+                    new ComponentName(activity, activity.getClass()), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        // If an orientation is explicitly declared in the manifest, allow forcing this orientation
+        final int activityOrientation = activityInfo.screenOrientation;
+        if (activityOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+            return activityOrientation == newOrientation.getActivityInfoOrientation();
+        }
+
+        // Make sure the config changes won't tear down the activity when moving to this orientation
+        // The necessary configChanges must always include "orientation"
+        boolean containsNecessaryConfigChanges =
+                bitMaskContainsFlag(activityInfo.configChanges, CONFIG_ORIENTATION);
+
+        // And on API 13+, configChanges must also include "screenSize"
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR2) {
+            containsNecessaryConfigChanges = containsNecessaryConfigChanges
+                    && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
+        }
+
+        return containsNecessaryConfigChanges;
+    }
+
+    @VisibleForTesting
+    void handleCustomClose(boolean useCustomClose) {
+        boolean wasUsingCustomClose = !mCloseableAdContainer.isCloseVisible();
+        if (useCustomClose == wasUsingCustomClose) {
+            return;
+        }
+
+        mCloseableAdContainer.setCloseVisible(!useCustomClose);
+        if (mOnCloseButtonListener != null) {
+            mOnCloseButtonListener.useCustomCloseChanged(useCustomClose);
+        }
+    }
+
+    @NonNull
+    public FrameLayout getAdContainer() {
+        return mDefaultAdContainer;
+    }
+
+    /**
+     * Loads a javascript URL. Useful for running callbacks, such as javascript:webviewDidClose()
+     */
+    public void loadJavascript(@NonNull String javascript) {
+        mMraidBridge.injectJavaScript(javascript);
+    }
+
+    @VisibleForTesting
+    class OrientationBroadcastReceiver extends BroadcastReceiver {
+        @Nullable private Context mContext;
+
+        // -1 until this gets set at least once
+        private int mLastRotation = -1;
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (mContext == null) {
+                return;
+            }
+
+            if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {
+                int orientation = getDisplayRotation();
+
+                if (orientation != mLastRotation) {
+                    mLastRotation = orientation;
+                    handleOrientationChange(mLastRotation);
+                }
+            }
+        }
+
+        public void register(@NonNull final Context context) {
+            Preconditions.checkNotNull(context);
+            mContext = context.getApplicationContext();
+            if (mContext != null) {
+                mContext.registerReceiver(this,
+                        new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
+            }
+        }
+
+        public void unregister() {
+            if (mContext != null) {
+                mContext.unregisterReceiver(this);
+                mContext = null;
+            }
+        }
+    }
+
+    @NonNull
+    public Context getContext() {
+        return mContext;
+    }
+
+    @VisibleForTesting
+    void handleSetOrientationProperties(final boolean allowOrientationChange,
+            final MraidOrientation forceOrientation) throws MraidCommandException {
+        if (!shouldAllowForceOrientation(forceOrientation)) {
+            throw new MraidCommandException(
+                    "Unable to force orientation to " + forceOrientation);
+        }
+
+        mAllowOrientationChange = allowOrientationChange;
+        mForceOrientation = forceOrientation;
+
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            applyOrientation();
+        }
+    }
+
+    /**
+     * Attempts to handle mopubnativebrowser links in the device browser, deep-links in the
+     * corresponding application, and all other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleOpen(@NonNull final String url) {
+        if (mMraidListener != null) {
+            mMraidListener.onOpen();
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .build().handleUrl(mContext, url);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    ViewState getViewState() {
+        return mViewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setViewStateForTesting(@NonNull ViewState viewState) {
+        mViewState = viewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    CloseableLayout getExpandedAdContainer() {
+        return mCloseableAdContainer;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootView(FrameLayout rootView) {
+        mRootView = rootView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootViewSize(int width, int height) {
+        mScreenMetrics.setRootViewPosition(0, 0, width, height);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    Integer getOriginalActivityOrientation() {
+        return mOriginalActivityOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    boolean getAllowOrientationChange() {
+        return mAllowOrientationChange;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidOrientation getForceOrientation() {
+        return mForceOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setOrientationBroadcastReceiver(OrientationBroadcastReceiver receiver) {
+        mOrientationBroadcastReceiver = receiver;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getTwoPartWebView() {
+        return mTwoPartWebView;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java
new file mode 100644
index 00000000..f7e1ae39
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java
@@ -0,0 +1,31 @@
+package com.mopub.mraid;
+
+
+import android.support.annotation.NonNull;
+
+import com.mopub.mobileads.MraidActivity;
+import com.mopub.mobileads.ResponseBodyInterstitial;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+
+class MraidInterstitial extends ResponseBodyInterstitial {
+    private String mHtmlData;
+
+    @Override
+    protected void extractExtras(Map<String, String> serverExtras) {
+        mHtmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
+    }
+
+    @Override
+    protected void preRenderHtml(@NonNull CustomEventInterstitialListener
+            customEventInterstitialListener) {
+        MraidActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
+    }
+
+    @Override
+    public void showInterstitial() {
+        MraidActivity.start(mContext, mAdReport, mHtmlData, mBroadcastIdentifier);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java
new file mode 100644
index 00000000..bb1b175e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java
@@ -0,0 +1,70 @@
+package com.mopub.mraid;
+
+import android.support.annotation.NonNull;
+
+public enum MraidJavascriptCommand {
+    CLOSE("close"),
+    EXPAND("expand") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return placementType == PlacementType.INLINE;
+        }
+    },
+    USE_CUSTOM_CLOSE("usecustomclose"),
+    OPEN("open") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    RESIZE("resize") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    SET_ORIENTATION_PROPERTIES("setOrientationProperties"),
+    PLAY_VIDEO("playVideo") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return placementType == PlacementType.INLINE;
+        }
+    },
+    STORE_PICTURE("storePicture") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    CREATE_CALENDAR_EVENT("createCalendarEvent") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    UNSPECIFIED("");
+
+    @NonNull private final String mJavascriptString;
+
+    MraidJavascriptCommand(@NonNull String javascriptString) {
+        mJavascriptString = javascriptString;
+    }
+
+    static MraidJavascriptCommand fromJavascriptString(@NonNull String string) {
+        for (MraidJavascriptCommand command : MraidJavascriptCommand.values()) {
+            if (command.mJavascriptString.equals(string)) {
+                return command;
+            }
+        }
+
+        return UNSPECIFIED;
+    }
+
+    String toJavascriptString() {
+        return mJavascriptString;
+    }
+
+    boolean requiresClick(@NonNull PlacementType placementType) {
+        return false;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
new file mode 100644
index 00000000..bc0a2d82
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
@@ -0,0 +1,582 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.media.MediaScannerConnection;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build.VERSION_CODES;
+import android.os.Environment;
+import android.provider.CalendarContract;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Intents;
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.VersionCode;
+import com.mopub.mobileads.factories.HttpClientFactory;
+import com.mopub.network.HeaderUtils;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.os.Environment.MEDIA_MOUNTED;
+import static com.mopub.common.HttpClient.*;
+import static com.mopub.common.util.ResponseHeader.LOCATION;
+
+public class MraidNativeCommandHandler {
+    interface MraidCommandFailureListener {
+        void onFailure(MraidCommandException exception);
+    }
+
+    @VisibleForTesting
+    static final String MIME_TYPE_HEADER = "Content-Type";
+
+    private static final int MAX_NUMBER_DAYS_IN_MONTH = 31;
+    private static final String[] DATE_FORMATS = {
+            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
+            "yyyy-MM-dd'T'HH:mmZZZZZ"
+    };
+
+    public static final String ANDROID_CALENDAR_CONTENT_TYPE = "vnd.android.cursor.item/event";
+
+    void createCalendarEvent(final Context context, final Map<String, String> params)
+            throws MraidCommandException {
+        if (isCalendarAvailable(context)) {
+            try {
+                Map<String, Object> calendarParams = translateJSParamsToAndroidCalendarEventMapping(params);
+                Intent intent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
+                for (String key : calendarParams.keySet()) {
+                    Object value = calendarParams.get(key);
+                    if (value instanceof Long) {
+                        intent.putExtra(key, ((Long) value).longValue());
+                    } else if (value instanceof Integer) {
+                        intent.putExtra(key, ((Integer) value).intValue());
+                    } else {
+                        intent.putExtra(key, (String) value);
+                    }
+                }
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                context.startActivity(intent);
+            } catch (ActivityNotFoundException e) {
+                MoPubLog.d("no calendar app installed");
+                throw new MraidCommandException(
+                        "Action is unsupported on this device - no calendar app installed");
+            } catch (IllegalArgumentException e) {
+                MoPubLog.d("create calendar: invalid parameters " + e.getMessage());
+                throw new MraidCommandException(e);
+            } catch (Exception e) {
+                MoPubLog.d("could not create calendar event");
+                throw new MraidCommandException(e);
+            }
+        } else {
+            MoPubLog.d("unsupported action createCalendarEvent for devices pre-ICS");
+            throw new MraidCommandException("Action is " +
+                    "unsupported on this device (need Android version Ice Cream Sandwich or " +
+                    "above)");
+        }
+    }
+
+    void storePicture(@NonNull final Context context,
+            @NonNull final String imageUrl,
+            @NonNull MraidCommandFailureListener failureListener) throws MraidCommandException {
+        if (!isStorePictureSupported(context)) {
+            MoPubLog.d("Error downloading file - the device does not have an SD card mounted, or " +
+                    "the Android permission is not granted.");
+            throw new MraidCommandException("Error downloading file " +
+                    " - the device does not have an SD card mounted, " +
+                    "or the Android permission is not granted.");
+        }
+
+        if (context instanceof Activity) {
+            showUserDialog(context, imageUrl, failureListener);
+        } else {
+            Toast.makeText(context, "Downloading image to Picture gallery...", Toast.LENGTH_SHORT).show();
+            downloadImage(context, imageUrl, failureListener);
+        }
+    }
+
+    boolean isTelAvailable(Context context) {
+        Intent telIntent = new Intent(Intent.ACTION_DIAL);
+        telIntent.setData(Uri.parse("tel:"));
+
+        return Intents.deviceCanHandleIntent(context, telIntent);
+    }
+
+    boolean isSmsAvailable(Context context) {
+        Intent smsIntent = new Intent(Intent.ACTION_VIEW);
+        smsIntent.setData(Uri.parse("sms:"));
+
+        return Intents.deviceCanHandleIntent(context, smsIntent);
+    }
+
+    public static boolean isStorePictureSupported(Context context) {
+        return MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
+                && context.checkCallingOrSelfPermission(WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
+    }
+
+    static boolean isCalendarAvailable(Context context) {
+        Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
+
+        return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
+                && Intents.deviceCanHandleIntent(context, calendarIntent);
+    }
+
+    /**
+     * Inline video support was added in 3.1. Returns true if the activity has hardware acceleration
+     * enabled in its foreground window and only if the View or any ParentView in the view tree
+     * has not had hardware acceleration explicitly turned off.
+     */
+    // TargetApi is needed to access hardware accelerated flags
+    @TargetApi(11)
+    boolean isInlineVideoAvailable(@NonNull Activity activity, @NonNull View view) {
+        // In addition to potential hardware acceleration problems, there is a problem in the WebKit
+        // HTML5VideoView implementation pre-Gingerbread that would result in HTML5VideoViewProxy
+        // holding on to an instance of the WebView even after the WebView is destroyed. For
+        // this reason, we never allow inline video on Gingerbread devices.
+        if (VersionCode.currentApiLevel().isBelow(VersionCode.HONEYCOMB_MR1)) {
+            return false;
+        }
+
+        // Hardware Acceleration
+        // Hardware acceleration for the application and activity is enabled by default
+        // in API >= 14 (Ice Cream Sandwich)
+        // http://developer.android.com/reference/android/R.attr.html#hardwareAccelerated
+        // http://developer.android.com/guide/topics/graphics/hardware-accel.html
+
+        // HTML5 Inline Video
+        // http://developer.android.com/about/versions/android-3.1.html
+
+        // Traverse up the View tree to determine if any views are being software rendered
+        // You can only disable hardware acceleration at the view level by setting the layer type
+        View tempView = view;
+        while (true) {
+            // View#isHardwareAccelerated does not reflect the layer type used to render the view
+            // therefore we have to check for both
+            if (!tempView.isHardwareAccelerated()
+                    || Utils.bitMaskContainsFlag(tempView.getLayerType(), View.LAYER_TYPE_SOFTWARE)) {
+                return false;
+            }
+
+            // If parent is not a view or parent is null then break
+            if (!(tempView.getParent() instanceof View)) {
+                break;
+            }
+
+            tempView = (View)tempView.getParent();
+        }
+
+        // Has hardware acceleration been enabled in the current window?
+        // Hardware acceleration can only be enabled for a window, not disabled
+        // This flag is automatically set by the system if the android:hardwareAccelerated
+        // XML attribute is set to true on an activity or on the application.
+        // http://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_HARDWARE_ACCELERATED
+        Window window = activity.getWindow();
+        if (window != null) {
+            if (Utils.bitMaskContainsFlag(window.getAttributes().flags,
+                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
+    private Map<String, Object> translateJSParamsToAndroidCalendarEventMapping(Map<String, String> params) {
+        Map<String, Object> validatedParamsMapping = new HashMap<String, Object>();
+        if (!params.containsKey("description") || !params.containsKey("start")) {
+            throw new IllegalArgumentException("Missing start and description fields");
+        }
+
+        validatedParamsMapping.put(CalendarContract.Events.TITLE, params.get("description"));
+
+        if (params.containsKey("start") && params.get("start") != null) {
+            Date startDateTime = parseDate(params.get("start"));
+            if (startDateTime != null) {
+                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_BEGIN_TIME, startDateTime.getTime());
+            } else {
+                throw new IllegalArgumentException("Invalid calendar event: start time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
+            }
+        } else {
+            throw new IllegalArgumentException("Invalid calendar event: start is null.");
+        }
+
+        if (params.containsKey("end") && params.get("end") != null) {
+            Date endDateTime = parseDate(params.get("end"));
+            if (endDateTime != null) {
+                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_END_TIME, endDateTime.getTime());
+            } else {
+                throw new IllegalArgumentException("Invalid calendar event: end time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
+            }
+        }
+
+        if (params.containsKey("location")) {
+            validatedParamsMapping.put(CalendarContract.Events.EVENT_LOCATION, params.get("location"));
+        }
+
+        if (params.containsKey("summary")) {
+            validatedParamsMapping.put(CalendarContract.Events.DESCRIPTION, params.get("summary"));
+        }
+
+        if (params.containsKey("transparency")) {
+            validatedParamsMapping.put(
+                    CalendarContract.Events.AVAILABILITY,
+                    params.get("transparency").equals("transparent") ?
+                            CalendarContract.Events.AVAILABILITY_FREE :
+                            CalendarContract.Events.AVAILABILITY_BUSY
+            );
+        }
+
+        validatedParamsMapping.put(CalendarContract.Events.RRULE, parseRecurrenceRule(params));
+
+        return validatedParamsMapping;
+    }
+
+    private Date parseDate(String dateTime) {
+        Date result = null;
+        for (final String DATE_FORMAT : DATE_FORMATS) {
+            try {
+                result = new SimpleDateFormat(DATE_FORMAT, Locale.US).parse(dateTime);
+                if (result != null) {
+                    break;
+                }
+            } catch (ParseException e) {
+                // an exception is okay, just try the next format and find the first one that works
+            }
+        }
+        return result;
+    }
+
+    private String parseRecurrenceRule(Map<String, String> params) throws IllegalArgumentException {
+        StringBuilder rule = new StringBuilder();
+        if (params.containsKey("frequency")) {
+            String frequency = params.get("frequency");
+            int interval = -1;
+            if (params.containsKey("interval")) {
+                interval = Integer.parseInt(params.get("interval"));
+            }
+            if ("daily".equals(frequency)) {
+                rule.append("FREQ=DAILY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+            } else if ("weekly".equals(frequency)) {
+                rule.append("FREQ=WEEKLY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+                if (params.containsKey("daysInWeek")) {
+                    String weekdays = translateWeekIntegersToDays(params.get("daysInWeek"));
+                    if (weekdays == null) {
+                        throw new IllegalArgumentException("invalid ");
+                    }
+                    rule.append("BYDAY=" + weekdays + ";");
+                }
+            } else if ("monthly".equals(frequency)) {
+                rule.append("FREQ=MONTHLY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+                if (params.containsKey("daysInMonth")) {
+                    String monthDays = translateMonthIntegersToDays(params.get("daysInMonth"));
+                    if (monthDays == null) {
+                        throw new IllegalArgumentException();
+                    }
+                    rule.append("BYMONTHDAY=" + monthDays + ";");
+                }
+            } else {
+                throw new IllegalArgumentException("frequency is only supported for daily, weekly, and monthly.");
+            }
+        }
+        return rule.toString();
+    }
+
+    private String translateWeekIntegersToDays(String expression) throws IllegalArgumentException {
+        StringBuilder daysResult = new StringBuilder();
+        boolean[] daysAlreadyCounted = new boolean[7];
+        String[] days = expression.split(",");
+        int dayNumber;
+        for (final String day : days) {
+            dayNumber = Integer.parseInt(day);
+            dayNumber = dayNumber == 7 ? 0 : dayNumber;
+            if (!daysAlreadyCounted[dayNumber]) {
+                daysResult.append(dayNumberToDayOfWeekString(dayNumber) + ",");
+                daysAlreadyCounted[dayNumber] = true;
+            }
+        }
+        if (days.length == 0) {
+            throw new IllegalArgumentException("must have at least 1 day of the week if specifying repeating weekly");
+        }
+        daysResult.deleteCharAt(daysResult.length() - 1);
+        return daysResult.toString();
+    }
+
+    private String translateMonthIntegersToDays(String expression) throws IllegalArgumentException {
+        StringBuilder daysResult = new StringBuilder();
+        boolean[] daysAlreadyCounted = new boolean[2 * MAX_NUMBER_DAYS_IN_MONTH + 1]; //for -31 to 31
+        String[] days = expression.split(",");
+        int dayNumber;
+        for (final String day : days) {
+            dayNumber = Integer.parseInt(day);
+            if (!daysAlreadyCounted[dayNumber + MAX_NUMBER_DAYS_IN_MONTH]) {
+                daysResult.append(dayNumberToDayOfMonthString(dayNumber) + ",");
+                daysAlreadyCounted[dayNumber + MAX_NUMBER_DAYS_IN_MONTH] = true;
+            }
+        }
+        if (days.length == 0) {
+            throw new IllegalArgumentException("must have at least 1 day of the month if specifying repeating weekly");
+        }
+        daysResult.deleteCharAt(daysResult.length() - 1);
+        return daysResult.toString();
+    }
+
+    private String dayNumberToDayOfWeekString(int number) throws IllegalArgumentException {
+        String dayOfWeek;
+        switch (number) {
+            case 0:
+                dayOfWeek = "SU";
+                break;
+            case 1:
+                dayOfWeek = "MO";
+                break;
+            case 2:
+                dayOfWeek = "TU";
+                break;
+            case 3:
+                dayOfWeek = "WE";
+                break;
+            case 4:
+                dayOfWeek = "TH";
+                break;
+            case 5:
+                dayOfWeek = "FR";
+                break;
+            case 6:
+                dayOfWeek = "SA";
+                break;
+            default:
+                throw new IllegalArgumentException("invalid day of week " + number);
+        }
+        return dayOfWeek;
+    }
+
+    private String dayNumberToDayOfMonthString(int number) throws IllegalArgumentException {
+        String dayOfMonth;
+        // https://android.googlesource.com/platform/frameworks/opt/calendar/+/504844526f1b7afec048c6d2976ffb332670d5ba/src/com/android/calendarcommon2/EventRecurrence.java
+        if (number != 0 && number >= -MAX_NUMBER_DAYS_IN_MONTH && number <= MAX_NUMBER_DAYS_IN_MONTH) {
+            dayOfMonth = "" + number;
+        } else {
+            throw new IllegalArgumentException("invalid day of month " + number);
+        }
+        return dayOfMonth;
+    }
+
+    void downloadImage(final Context context, final String uriString,
+            final MraidCommandFailureListener failureListener) {
+        final DownloadImageAsyncTask downloadImageAsyncTask = new DownloadImageAsyncTask(context,
+                new DownloadImageAsyncTask.DownloadImageAsyncTaskListener() {
+                    @Override
+                    public void onSuccess() {
+                        MoPubLog.d("Image successfully saved.");
+                    }
+
+                    @Override
+                    public void onFailure() {
+                        Toast.makeText(context, "Image failed to download.", Toast.LENGTH_SHORT).show();
+                        MoPubLog.d("Error downloading and saving image file.");
+                        failureListener.onFailure(new MraidCommandException("Error " +
+                                "downloading and saving image file."));
+                    }
+                });
+        AsyncTasks.safeExecuteOnExecutor(downloadImageAsyncTask, uriString);
+    }
+
+    private void showUserDialog(final Context context, final String imageUrl,
+            final MraidCommandFailureListener failureListener) {
+        AlertDialog.Builder alertDialogDownloadImage = new AlertDialog.Builder(context);
+        alertDialogDownloadImage
+                .setTitle("Save Image")
+                .setMessage("Download image to Picture gallery?")
+                .setNegativeButton("Cancel", null)
+                .setPositiveButton("Okay", new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        downloadImage(context, imageUrl, failureListener);
+                    }
+                })
+                .setCancelable(true)
+                .show();
+    }
+
+    private static class DownloadImageAsyncTask extends AsyncTask<String, Void, Boolean> {
+        interface DownloadImageAsyncTaskListener {
+            void onSuccess();
+
+            void onFailure();
+        }
+
+        private final Context mContext;
+        private final DownloadImageAsyncTaskListener mListener;
+
+        public DownloadImageAsyncTask(@NonNull final Context context,
+                @NonNull final DownloadImageAsyncTaskListener listener) {
+            super();
+            mContext = context.getApplicationContext();
+            mListener = listener;
+        }
+
+        @Override
+        protected Boolean doInBackground(@NonNull String[] params) {
+            Preconditions.checkState(params.length > 0);
+            Preconditions.checkNotNull(params[0]);
+
+            final File pictureStoragePath = getPictureStoragePath();
+
+            //noinspection ResultOfMethodCallIgnored
+            pictureStoragePath.mkdirs();
+
+            final String uriString = params[0];
+            URI uri = URI.create(uriString);
+
+            final HttpClient httpClient = HttpClientFactory.create();
+            final HttpGet httpGet = initializeHttpGet(uri.toString());
+
+            InputStream pictureInputStream = null;
+            OutputStream pictureOutputStream = null;
+            try {
+                final HttpResponse httpResponse = httpClient.execute(httpGet);
+                pictureInputStream = httpResponse.getEntity().getContent();
+
+                final String redirectLocation = HeaderUtils.extractHeader(httpResponse, LOCATION);
+                if (redirectLocation != null) {
+                    uri = URI.create(redirectLocation);
+                }
+
+                final String pictureFileName = getFileNameForUriAndHttpResponse(uri, httpResponse);
+                final File pictureFile = new File(pictureStoragePath, pictureFileName);
+                pictureOutputStream = new FileOutputStream(pictureFile);
+                Streams.copyContent(pictureInputStream, pictureOutputStream);
+
+                final String pictureFileFullPath = pictureFile.toString();
+                loadPictureIntoGalleryApp(pictureFileFullPath);
+
+                return true;
+            } catch (IOException e) {
+                return false;
+            } finally {
+                Streams.closeStream(pictureInputStream);
+                Streams.closeStream(pictureOutputStream);
+            }
+        }
+
+        @Override
+        protected void onPostExecute(final Boolean success) {
+            if (success != null && success) {
+                mListener.onSuccess();
+            } else {
+                mListener.onFailure();
+            }
+        }
+
+        private String getFileNameForUriAndHttpResponse(final URI uri, final HttpResponse response) {
+            final String path = uri.getPath();
+
+            if (path == null) {
+                return null;
+            }
+
+            String filename = new File(path).getName();
+
+            Header header = response.getFirstHeader(MIME_TYPE_HEADER);
+            if (header != null) {
+                String[] fields = header.getValue().split(";");
+                for (final String field : fields) {
+                    String extension;
+                    if (field.contains("image/")) {
+                        extension = "." + field.split("/")[1];
+                        if (!filename.endsWith(extension)) {
+                            filename += extension;
+                        }
+                        break;
+                    }
+                }
+            }
+
+            return filename;
+        }
+
+        private File getPictureStoragePath() {
+            return new File(Environment.getExternalStorageDirectory(), "Pictures");
+        }
+
+        private void loadPictureIntoGalleryApp(final String filename) {
+            MoPubMediaScannerConnectionClient mediaScannerConnectionClient =
+                    new MoPubMediaScannerConnectionClient(filename, null);
+            final MediaScannerConnection mediaScannerConnection =
+                    new MediaScannerConnection(mContext, mediaScannerConnectionClient);
+            mediaScannerConnectionClient.setMediaScannerConnection(mediaScannerConnection);
+            mediaScannerConnection.connect();
+        }
+    }
+
+    private static class MoPubMediaScannerConnectionClient
+            implements MediaScannerConnection.MediaScannerConnectionClient {
+        private final String mFilename;
+        private final String mMimeType;
+        private MediaScannerConnection mMediaScannerConnection;
+
+        private MoPubMediaScannerConnectionClient(String filename, String mimeType) {
+            mFilename = filename;
+            mMimeType = mimeType;
+        }
+
+        private void setMediaScannerConnection(MediaScannerConnection connection) {
+            mMediaScannerConnection = connection;
+        }
+
+        @Override
+        public void onMediaScannerConnected() {
+            if (mMediaScannerConnection != null) {
+                mMediaScannerConnection.scanFile(mFilename, mMimeType);
+            }
+        }
+
+        @Override
+        public void onScanCompleted(String path, Uri uri) {
+            if (mMediaScannerConnection != null) {
+                mMediaScannerConnection.disconnect();
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java
new file mode 100644
index 00000000..5b2bdb56
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java
@@ -0,0 +1,19 @@
+package com.mopub.mraid;
+
+import android.content.pm.ActivityInfo;
+
+enum MraidOrientation {
+    PORTRAIT(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT),
+    LANDSCAPE(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE),
+    NONE(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+
+    private final int mActivityInfoOrientation;
+
+    MraidOrientation(final int activityInfoOrientation) {
+        mActivityInfoOrientation = activityInfoOrientation;
+    }
+
+    int getActivityInfoOrientation() {
+        return mActivityInfoOrientation;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java
new file mode 100644
index 00000000..972a0577
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java
@@ -0,0 +1,118 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.util.Dips;
+
+/**
+ * Screen metrics needed by the MRAID container.
+ *
+ * Each rectangle is stored using both it's original and scaled coordinates to avoid allocating
+ * extra memory that would otherwise be needed to do these conversions.
+ */
+class MraidScreenMetrics {
+    @NonNull private final Context mContext;
+    @NonNull private final Rect mScreenRect;
+    @NonNull private final Rect mScreenRectDips;
+
+    @NonNull private final Rect mRootViewRect;
+    @NonNull private final Rect mRootViewRectDips;
+
+    @NonNull private final Rect mCurrentAdRect;
+    @NonNull private final Rect mCurrentAdRectDips;
+
+    @NonNull private final Rect mDefaultAdRect;
+    @NonNull private final Rect mDefaultAdRectDips;
+
+    private final float mDensity;
+
+    MraidScreenMetrics(Context context, float density) {
+        mContext = context.getApplicationContext();
+        mDensity = density;
+
+        mScreenRect = new Rect();
+        mScreenRectDips = new Rect();
+
+        mRootViewRect = new Rect();
+        mRootViewRectDips = new Rect();
+
+        mCurrentAdRect = new Rect();
+        mCurrentAdRectDips = new Rect();
+
+        mDefaultAdRect = new Rect();
+        mDefaultAdRectDips = new Rect();
+    }
+
+    private void convertToDips(Rect sourceRect, Rect outRect) {
+        outRect.set(Dips.pixelsToIntDips(sourceRect.left, mContext),
+                Dips.pixelsToIntDips(sourceRect.top, mContext),
+                Dips.pixelsToIntDips(sourceRect.right, mContext),
+                Dips.pixelsToIntDips(sourceRect.bottom, mContext));
+    }
+
+    public float getDensity() {
+        return mDensity;
+    }
+
+    void setScreenSize(int width, int height) {
+        mScreenRect.set(0, 0, width, height);
+        convertToDips(mScreenRect, mScreenRectDips);
+    }
+
+    @NonNull
+    Rect getScreenRect() {
+        return mScreenRect;
+    }
+
+    @NonNull
+    Rect getScreenRectDips() {
+        return mScreenRectDips;
+    }
+
+    void setRootViewPosition(int x, int y, int width, int height) {
+        mRootViewRect.set(x, y, x + width, y + height);
+        convertToDips(mRootViewRect, mRootViewRectDips);
+    }
+
+    @NonNull
+    Rect getRootViewRect() {
+        return mRootViewRect;
+    }
+
+    @NonNull
+    Rect getRootViewRectDips() {
+        return mRootViewRectDips;
+    }
+
+    void setCurrentAdPosition(int x, int y, int width, int height) {
+        mCurrentAdRect.set(x, y, x + width, y + height);
+        convertToDips(mCurrentAdRect, mCurrentAdRectDips);
+    }
+
+    @NonNull
+    Rect getCurrentAdRect() {
+        return mCurrentAdRect;
+    }
+
+    @NonNull
+    Rect getCurrentAdRectDips() {
+        return mCurrentAdRectDips;
+    }
+
+    void setDefaultAdPosition(int x, int y, int width, int height) {
+        mDefaultAdRect.set(x, y, x + width, y + height);
+        convertToDips(mDefaultAdRect, mDefaultAdRectDips);
+    }
+
+    @NonNull
+    Rect getDefaultAdRect() {
+        return mDefaultAdRect;
+    }
+
+    @NonNull
+    Rect getDefaultAdRectDips() {
+        return mDefaultAdRectDips;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
similarity index 71%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
rename to mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
index 06111b88..8aea4da9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
@@ -1,14 +1,19 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.content.Context;
+import android.content.res.Configuration;
 import android.graphics.drawable.StateListDrawable;
 import android.media.MediaPlayer;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.widget.ImageButton;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.util.Dips;
+import com.mopub.mobileads.BaseVideoViewController;
 
 import static android.view.View.GONE;
 import static android.view.View.OnClickListener;
@@ -26,8 +31,12 @@
     private int mButtonPadding;
     private int mButtonSize;
 
-    MraidVideoViewController(final Context context, final Bundle bundle, final long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
-        super(context, broadcastIdentifier, baseVideoViewControllerListener);
+    public MraidVideoViewController(final Context context,
+            final Bundle intentExtras,
+            final Bundle savedInstanceState,
+            final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+        // No broadcast identifiers are used by MraidVideoViews.
+        super(context, null, baseVideoViewControllerListener);
 
         mVideoView = new VideoView(context);
         mVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
@@ -48,11 +57,11 @@ public boolean onError(MediaPlayer mediaPlayer, int what, int extra) {
             }
         });
 
-        mVideoView.setVideoPath(bundle.getString(VIDEO_URL));
+        mVideoView.setVideoPath(intentExtras.getString(VIDEO_URL));
     }
 
     @Override
-    void onCreate() {
+    protected void onCreate() {
         super.onCreate();
         mButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE, getContext());
         mButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING, getContext());
@@ -62,25 +71,35 @@ void onCreate() {
     }
 
     @Override
-    VideoView getVideoView() {
+    protected VideoView getVideoView() {
         return mVideoView;
     }
 
     @Override
-    void onDestroy() {}
+    protected void onDestroy() {}
+
+    @Override
+    protected void onPause() {}
 
     @Override
-    void onPause() {}
+    protected void onResume() {}
 
     @Override
-    void onResume() {}
+    protected void onSaveInstanceState(@NonNull Bundle outState) {}
+
+    @Override
+    protected void onConfigurationChanged(@Nullable Configuration newConfig) {
+    }
 
     private void createInterstitialCloseButton() {
         mCloseButton = new ImageButton(getContext());
         StateListDrawable states = new StateListDrawable();
-        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(getContext()));
-        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(getContext()));
+        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.createDrawable(
+                getContext()));
+        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.createDrawable(
+                getContext()));
         mCloseButton.setImageDrawable(states);
+        //noinspection deprecation
         mCloseButton.setBackgroundDrawable(null);
         mCloseButton.setOnClickListener(new OnClickListener() {
             public void onClick(View v) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java
new file mode 100644
index 00000000..5d1d92c6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java
@@ -0,0 +1,25 @@
+package com.mopub.mraid;
+
+import android.support.annotation.NonNull;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * Debugging callback interface to make it easier for integration tests to debug MRAID ads.
+ */
+@VisibleForTesting
+public interface MraidWebViewDebugListener {
+    /**
+     * @see WebChromeClient#onJsAlert(WebView, String, String, JsResult)
+     */
+    boolean onJsAlert(@NonNull String message, @NonNull JsResult result);
+
+    /**
+     * @see WebChromeClient#onConsoleMessage(ConsoleMessage)
+     */
+    boolean onConsoleMessage(@NonNull ConsoleMessage consoleMessage);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java b/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java
new file mode 100644
index 00000000..5d43c066
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java
@@ -0,0 +1,12 @@
+package com.mopub.mraid;
+
+import java.util.Locale;
+
+public enum PlacementType {
+    INLINE,
+    INTERSTITIAL;
+
+    String toJavascriptString() {
+        return toString().toLowerCase(Locale.US);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java b/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java
new file mode 100644
index 00000000..40fc1cef
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java
@@ -0,0 +1,15 @@
+package com.mopub.mraid;
+
+import java.util.Locale;
+
+public enum ViewState {
+    LOADING,
+    DEFAULT,
+    RESIZED,
+    EXPANDED,
+    HIDDEN;
+
+    public String toJavascriptString() {
+        return toString().toLowerCase(Locale.US);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
index 6cc0ca94..28bd5620 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -2,9 +2,12 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
@@ -18,22 +21,17 @@
  */
 @Deprecated
 public final class AdapterHelper {
-    private final WeakReference<Activity> mActivity;
-    private final Context mApplicationContext;
+    @NonNull private final WeakReference<Activity> mActivity;
+    @NonNull private final Context mApplicationContext;
     private final int mStart;
     private final int mInterval;
 
     @Deprecated
-    public AdapterHelper(final Context context, final int start, final int interval) throws IllegalArgumentException {
-        if (context == null) {
-            throw new IllegalArgumentException("Illegal argument: Context was null.");
-        } else if (!(context instanceof Activity)) {
-            throw new IllegalArgumentException("Illegal argument: Context must be instance of Activity.");
-        } else if (start < 0) {
-            throw new IllegalArgumentException("Illegal argument: negative starting position.");
-        } else if (interval < 2) {
-            throw new IllegalArgumentException("Illegal argument: interval must be at least 2.");
-        }
+    public AdapterHelper(@NonNull final Context context, final int start, final int interval) {
+        Preconditions.checkNotNull(context, "Context cannot be null.");
+        Preconditions.checkArgument(context instanceof Activity, "Context must be an Activity.");
+        Preconditions.checkArgument(start >= 0, "start position must be non-negative");
+        Preconditions.checkArgument(interval >= 2, "interval must be at least 2");
 
         mActivity = new WeakReference<Activity>((Activity) context);
         mApplicationContext = context.getApplicationContext();
@@ -42,15 +40,16 @@ public AdapterHelper(final Context context, final int start, final int interval)
     }
 
     @Deprecated
-    public View getAdView(final View convertView,
-            final ViewGroup parent,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder,
-            final MoPubNativeListener moPubNativeListener) {
+    @NonNull
+    public View getAdView(@Nullable final View convertView,
+            @Nullable final ViewGroup parent,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder,
+            @Nullable @SuppressWarnings("unused") final MoPubNativeListener moPubNativeListener) {
         final Activity activity = mActivity.get();
         if (activity == null) {
-            MoPubLog.d("Weak reference to Activity Context in AdapterHelper became null. " +
-                    "Returning empty view.");
+            MoPubLog.w("Weak reference to Activity Context in"
+                    + " AdapterHelper became null. Returning empty view.");
             return new View(mApplicationContext);
         }
 
@@ -59,8 +58,7 @@ public View getAdView(final View convertView,
                 parent,
                 activity,
                 nativeResponse,
-                viewBinder,
-                moPubNativeListener
+                viewBinder
         );
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
index 9f5b58cf..4f463ba5 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
@@ -1,16 +1,24 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.view.View;
 
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.CustomEventNative.ImageListener;
@@ -22,26 +30,26 @@
         public void onAdImpressed();
         public void onAdClicked();
     }
-    private NativeEventListener mNativeEventListener;
+    @Nullable private NativeEventListener mNativeEventListener;
 
     static final double MIN_STAR_RATING = 0;
     static final double MAX_STAR_RATING = 5;
 
     // Basic fields
-    private String mMainImageUrl;
-    private String mIconImageUrl;
-    private String mClickDestinationUrl;
-    private String mCallToAction;
-    private String mTitle;
-    private String mText;
-    private Double mStarRating;
+    @Nullable private String mMainImageUrl;
+    @Nullable private String mIconImageUrl;
+    @Nullable private String mClickDestinationUrl;
+    @Nullable private String mCallToAction;
+    @Nullable private String mTitle;
+    @Nullable private String mText;
+    @Nullable private Double mStarRating;
 
     // Impression logistics
-    private final Set<String> mImpressionTrackers;
+    @NonNull private final Set<String> mImpressionTrackers;
     private int mImpressionMinTimeViewed;
 
     // Extras
-    private final Map<String, Object> mExtras;
+    @NonNull private final Map<String, Object> mExtras;
 
     // Event Logistics
     private boolean mIsOverridingClickTracker;
@@ -58,6 +66,7 @@
     /**
      * Returns the String url corresponding to the ad's main image.
      */
+    @Nullable
     @Override
     final public String getMainImageUrl() {
         return mMainImageUrl;
@@ -66,6 +75,7 @@ final public String getMainImageUrl() {
     /**
      * Returns the String url corresponding to the ad's icon image.
      */
+    @Nullable
     @Override
     final public String getIconImageUrl() {
         return mIconImageUrl;
@@ -78,6 +88,7 @@ final public String getIconImageUrl() {
      * and {@link BaseForwardingNativeAd#getImpressionMinTimeViewed()} for relevant
      * impression-tracking parameters.
      */
+    @NonNull
     @Override
     final public Set<String> getImpressionTrackers() {
         return new HashSet<String>(mImpressionTrackers);
@@ -86,6 +97,7 @@ final public String getIconImageUrl() {
     /**
      * Returns the String url that the device will attempt to resolve when the ad is clicked.
      */
+    @Nullable
     @Override
     final public String getClickDestinationUrl() {
         return mClickDestinationUrl;
@@ -94,6 +106,7 @@ final public String getClickDestinationUrl() {
     /**
      * Returns the Call To Action String (i.e. "Download" or "Learn More") associated with this ad.
      */
+    @Nullable
     @Override
     final public String getCallToAction() {
         return mCallToAction;
@@ -102,6 +115,7 @@ final public String getCallToAction() {
     /**
      * Returns the String corresponding to the ad's title.
      */
+    @Nullable
     @Override
     final public String getTitle() {
         return mTitle;
@@ -110,6 +124,7 @@ final public String getTitle() {
     /**
      * Returns the String corresponding to the ad's body text.
      */
+    @Nullable
     @Override
     final public String getText() {
         return mText;
@@ -120,6 +135,7 @@ final public String getText() {
      * advertised app. Note that this method may return null if the star rating was either never set
      * or invalid.
      */
+    @Nullable
     @Override
     final public Double getStarRating() {
         return mStarRating;
@@ -150,8 +166,12 @@ final public int getImpressionMinTimeViewed() {
      * Given a particular String key, return the associated Object value from the ad's extras map.
      * See {@link BaseForwardingNativeAd#getExtras()} for more information.
      */
+    @Nullable
     @Override
-    final public Object getExtra(final String key) {
+    final public Object getExtra(@NonNull final String key) {
+        if (!NoThrow.checkNotNull(key, "getExtra key is not allowed to be null")) {
+            return null;
+        }
         return mExtras.get(key);
     }
 
@@ -161,6 +181,7 @@ final public Object getExtra(final String key) {
      * with MoPub's direct-sold native ads or from mediated networks that pass back additional
      * fields.
      */
+    @NonNull
     @Override
     final public Map<String, Object> getExtras() {
         return new HashMap<String, Object>(mExtras);
@@ -190,35 +211,36 @@ final public boolean isOverridingClickTracker() {
 
     // Setters
     @Override
-    public final void setNativeEventListener(final NativeEventListener nativeEventListener) {
+    public final void setNativeEventListener(
+            @Nullable final NativeEventListener nativeEventListener) {
         mNativeEventListener = nativeEventListener;
     }
 
-    final void setMainImageUrl(final String mainImageUrl) {
+    final void setMainImageUrl(@Nullable final String mainImageUrl) {
         mMainImageUrl = mainImageUrl;
     }
 
-    final void setIconImageUrl(final String iconImageUrl) {
+    final void setIconImageUrl(@Nullable final String iconImageUrl) {
         mIconImageUrl = iconImageUrl;
     }
 
-    final void setClickDestinationUrl(final String clickDestinationUrl) {
+    final void setClickDestinationUrl(@Nullable final String clickDestinationUrl) {
         mClickDestinationUrl = clickDestinationUrl;
     }
 
-    final void setCallToAction(final String callToAction) {
+    final void setCallToAction(@Nullable final String callToAction) {
         mCallToAction = callToAction;
     }
 
-    final void setTitle(final String title) {
+    final void setTitle(@Nullable final String title) {
         mTitle = title;
     }
 
-    final void setText(final String text) {
+    final void setText(@Nullable final String text) {
         mText = text;
     }
 
-    final void setStarRating(final Double starRating) {
+    final void setStarRating(@Nullable final Double starRating) {
         if (starRating == null) {
             mStarRating = null;
         } else if (starRating >= MIN_STAR_RATING && starRating <= MAX_STAR_RATING) {
@@ -229,11 +251,17 @@ final void setStarRating(final Double starRating) {
         }
     }
 
-    final void addExtra(final String key, final Object value) {
+    final void addExtra(@NonNull final String key, @Nullable final Object value) {
+        if (!NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
+            return;
+        }
         mExtras.put(key, value);
     }
 
-    final void addImpressionTracker(final String url) {
+    final void addImpressionTracker(@NonNull final String url) {
+        if (!NoThrow.checkNotNull(url, "impressionTracker url is not allowed to be null")) {
+            return;
+        }
         mImpressionTrackers.add(url);
     }
 
@@ -259,7 +287,7 @@ final void setOverridingClickTracker(final boolean isOverridingClickTracker) {
      * This method is optional.
      */
     @Override
-    public void prepare(final View view) { }
+    public void prepare(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -277,7 +305,7 @@ public void recordImpression() { }
      * This method is optional.
      */
     @Override
-    public void handleClick(final View view) { }
+    public void handleClick(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -287,7 +315,7 @@ public void handleClick(final View view) { }
      * This method is optional.
      */
     @Override
-    public void clear(final View view) { }
+    public void clear(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -307,7 +335,9 @@ public void destroy() { }
      * {@link BaseForwardingNativeAd#prepare}.
      */
     protected final void notifyAdImpressed() {
-        mNativeEventListener.onAdImpressed();
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdImpressed();
+        }
     }
 
     /**
@@ -318,7 +348,9 @@ protected final void notifyAdImpressed() {
      * {@link BaseForwardingNativeAd#prepare}.
      */
     protected final void notifyAdClicked() {
-        mNativeEventListener.onAdClicked();
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdClicked();
+        }
     }
 
     /**
@@ -326,19 +358,45 @@ protected final void notifyAdClicked() {
      * cache before calling {@link CustomEventNativeListener#onNativeAdLoaded}. Doing so will
      * force images to cache before displaying the ad.
      */
-    static void preCacheImages(final Context context,
-            final List<String> imageUrls,
-            final ImageListener imageListener) {
-        ImageService.get(context, imageUrls, new ImageService.ImageServiceListener() {
+    static void preCacheImages(@NonNull final Context context,
+            @NonNull final List<String> imageUrls,
+            @NonNull final ImageListener imageListener) {
+        final ImageLoader imageLoader = Networking.getImageLoader(context);
+        // These Atomics are only accessed on the main thread.
+        // We use Atomics here so we can change their values while keeping a reference for the inner class.
+        final AtomicInteger imageCounter = new AtomicInteger(imageUrls.size());
+        final AtomicBoolean anyFailures = new AtomicBoolean(false);
+        ImageLoader.ImageListener volleyImageListener = new ImageLoader.ImageListener() {
             @Override
-            public void onSuccess(final Map<String, Bitmap> bitmaps) {
-                imageListener.onImagesCached();
+            public void onResponse(final ImageLoader.ImageContainer imageContainer, final boolean isImmediate) {
+                // Image Loader returns a "default" response immediately. We want to ignore this
+                // unless the image is already cached.
+                if (imageContainer.getBitmap() != null) {
+                    final int count = imageCounter.decrementAndGet();
+                    if (count == 0 && !anyFailures.get()) {
+                        imageListener.onImagesCached();
+                    }
+                }
             }
 
             @Override
-            public void onFail() {
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to download a native ads image:", volleyError);
+                boolean anyPreviousErrors = anyFailures.getAndSet(true);
+                imageCounter.decrementAndGet();
+                if (!anyPreviousErrors) {
+                    imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                }
+            }
+        };
+
+        for (String url : imageUrls) {
+            if (TextUtils.isEmpty(url)) {
+                anyFailures.set(true);
                 imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                return;
             }
-        });
+            imageLoader.get(url, volleyImageListener);
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
index bcfea7c7..0809b8d2 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
@@ -1,6 +1,7 @@
 package com.mopub.nativeads;
 
 import android.os.Handler;
+import android.support.annotation.NonNull;
 
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
@@ -8,15 +9,16 @@
  * Returns a preset client positioning object.
  */
 class ClientPositioningSource implements PositioningSource {
-    private Handler mHandler = new Handler();
-    private final MoPubClientPositioning mPositioning;
+    @NonNull private final Handler mHandler = new Handler();
+    @NonNull private final MoPubClientPositioning mPositioning;
 
-    ClientPositioningSource(MoPubClientPositioning positioning) {
+    ClientPositioningSource(@NonNull MoPubClientPositioning positioning) {
         mPositioning = MoPubNativeAdPositioning.clone(positioning);
     }
 
     @Override
-    public void loadPositions(final String adUnitId, final PositioningListener listener) {
+    public void loadPositions(@NonNull final String adUnitId,
+            @NonNull final PositioningListener listener) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java b/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
deleted file mode 100644
index ad256b8b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.mopub.nativeads;
-
-public class Constants {
-    public static final String LOGTAG = "MoPub Native";
-
-    static final String NATIVE_HOST = "ads.mopub.com";
-    static final String NATIVE_HANDLER = "/m/ad";
-
-    static final String POSITIONING_HOST = "ads.mopub.com";
-    static final String POSITIONING_HANDLER = "/m/pos";
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
index 03397057..8893bd1f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
@@ -1,47 +1,53 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import java.util.Map;
 
 /**
- * CustomEventNative is a base class for custom events that support native ads. By implementing
- * subclasses of CustomEventNative, you can enable the MoPub SDK to support a wider
- * variety of third-party ad networks, or execute any of your application code on demand.
+ * {@code CustomEventNative} is a base class for custom events that support native ads. By
+ * implementing subclasses of {@code CustomEventNative}, you can enable the MoPub SDK to support a
+ * wider variety of third-party ad networks, or execute any of your application code on demand.
  *
- * At runtime, the MoPub SDK will find and instantiate a CustomEventNative subclass as needed
- * and invoke its loadNativeAd() method.
+ * At runtime, the MoPub SDK will find and instantiate a {@code CustomEventNative} subclass as
+ * needed and invoke its {@link #loadNativeAd} method.
  */
 public abstract class CustomEventNative {
     /**
      * When the MoPub SDK receives a response indicating it should load a custom event, it will send
-     * this message to your custom event class. Your implementation of this method can either load
-     * a native ad from a third-party ad network, or execute any application code. It must also
-     * notify the provided CustomEventNativeListener Object of certain lifecycle events.
+     * this message to your custom event class. Your implementation of this method can either load a
+     * native ad from a third-party ad network, or execute any application code. It must also notify
+     * the provided {@link CustomEventNativeListener} Object of certain lifecycle events.
      *
-     * The localExtras parameter is a Map containing additional custom data that is set within
-     * your application by calling MoPubNative.setLocalExtras(Map<String, Object>). Note that the
-     * localExtras Map is a copy of the Map supplied to setLocalExtras().
-     *
-     * The serverExtras parameter is a Map containing additional custom data configurable on the
-     * MoPub website that you want to associate with a given custom event request. This data may be
-     * used to pass dynamic information, such as publisher IDs, without changes in application code.
+     * @param context The activity context.
+     * @param customEventNativeListener An Object that must be notified of certain lifecycle
+     * events.
+     * @param localExtras A Map containing additional custom data that is set within your
+     * application by calling {@link MoPubNative#setLocalExtras(Map<String, Object>)}. Note that the
+     * localExtras Map is a copy of the Map supplied to {@link MoPubNative#setLocalExtras(Map<String,
+     * Object>)}.
+     * @param serverExtras A Map containing additional custom data configurable on the MoPub website
+     * that you want to associate with a given custom event request. This data may be used to pass
+     * dynamic information, such as publisher IDs, without changes in application code.
      */
-    protected abstract void loadNativeAd(final Context context,
-            final CustomEventNativeListener customEventNativeListener,
-            final Map<String, Object> localExtras,
-            final Map<String, String> serverExtras);
+    protected abstract void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras);
 
     public interface ImageListener {
         /**
-         * Called when images are successfully cached. If you haven't already called
-         * {@link CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
+         * Called when images are successfully cached. If you haven't already called {@link
+         * CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
          */
         void onImagesCached();
 
         /**
-         * Called when images failed to cache. You should typically call
-         * {@link CustomEventNativeListener#onNativeAdFailed} from this callback.
+         * Called when images failed to cache. You should typically call {@link
+         * CustomEventNativeListener#onNativeAdFailed} from this callback.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onImagesFailedToCache(NativeErrorCode errorCode);
     }
@@ -51,6 +57,8 @@ protected abstract void loadNativeAd(final Context context,
          * Your custom event subclass must call this method when it successfully loads a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param nativeAd The ad that was succesfully loaded.
          */
         void onNativeAdLoaded(NativeAdInterface nativeAd);
 
@@ -58,6 +66,8 @@ protected abstract void loadNativeAd(final Context context,
          * Your custom event subclass must call this method when it fails to load a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onNativeAdFailed(NativeErrorCode errorCode);
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
index 224fa646..b695033b 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
@@ -1,31 +1,25 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.util.Json;
+import com.mopub.common.DataKeys;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
+import com.mopub.network.AdResponse;
 
-import java.util.HashMap;
 import java.util.Map;
 
 final class CustomEventNativeAdapter {
     private CustomEventNativeAdapter() {}
 
-    static final String RESPONSE_BODY_KEY = "response_body_key";
-
-    public static void loadNativeAd(final Context context,
-            final Map<String, Object> localExtras,
-            final DownloadResponse downloadResponse,
-            final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
-
-        final String customEventNativeData = downloadResponse.getFirstHeader(ResponseHeader.CUSTOM_EVENT_DATA);
-        final String customEventNativeClassName = downloadResponse.getFirstHeader(ResponseHeader.CUSTOM_EVENT_NAME);
+    public static void loadNativeAd(@NonNull final Context context,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final AdResponse adResponse,
+            @NonNull final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
 
         final CustomEventNative customEventNative;
+        String customEventNativeClassName = adResponse.getCustomEventClassName();
         try {
             customEventNative = CustomEventNativeFactory.create(customEventNativeClassName);
         } catch (Exception e) {
@@ -33,22 +27,22 @@ public static void loadNativeAd(final Context context,
             customEventNativeListener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_NOT_FOUND);
             return;
         }
+        if (adResponse.hasJson()) {
+            localExtras.put(DataKeys.JSON_BODY_KEY, adResponse.getJsonBody());
+        }
 
-        Map<String, String> serverExtras = new HashMap<String, String>();
-        // Attempt to load the JSON extras into mServerExtras.
+        // Custom event classes can be developed by any third party and may not be tested.
+        // We catch all exceptions here to prevent crashes from untested code.
         try {
-            serverExtras = Json.jsonStringToMap(customEventNativeData);
+            customEventNative.loadNativeAd(
+                    context,
+                    customEventNativeListener,
+                    localExtras,
+                    adResponse.getServerExtras()
+            );
         } catch (Exception e) {
-            MoPubLog.w("Failed to create Map from JSON: " + customEventNativeData, e);
+            MoPubLog.w("Loading custom event native threw an error.", e);
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_NOT_FOUND);
         }
-
-        serverExtras.put(RESPONSE_BODY_KEY, HttpResponses.asResponseString(downloadResponse));
-
-        customEventNative.loadNativeAd(
-                context,
-                customEventNativeListener,
-                localExtras,
-                serverExtras
-        );
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
deleted file mode 100644
index f355fe69..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.mopub.nativeads;
-
-import android.graphics.Bitmap;
-import com.mopub.common.CacheService;
-
-import java.util.*;
-
-import static com.mopub.common.CacheService.DiskLruCacheGetListener;
-
-class ImageDiskTaskManager extends TaskManager<Bitmap> {
-    private final List<String> mUrls;
-    private final int mMaxImageWidth;
-
-    ImageDiskTaskManager(final List<String> urls,
-            final TaskManagerListener<Bitmap> imageTaskManagerListener,
-            final int maxImageWidth)
-            throws IllegalArgumentException {
-        super(urls, imageTaskManagerListener);
-        mMaxImageWidth = maxImageWidth;
-        mUrls = urls;
-    }
-
-    @Override
-    void execute() {
-        if (mUrls.isEmpty()) {
-            mImageTaskManagerListener.onSuccess(mResults);
-        }
-
-        ImageDiskTaskListener imageDiskTaskListener = new ImageDiskTaskListener(mMaxImageWidth);
-        for (final String url : mUrls) {
-            CacheService.getFromDiskCacheAsync(url, imageDiskTaskListener);
-        }
-    }
-
-    void failAllTasks() {
-        if (mFailed.compareAndSet(false, true)) {
-            mImageTaskManagerListener.onFail();
-        }
-    }
-
-    private class ImageDiskTaskListener implements DiskLruCacheGetListener {
-
-        private final int mTargetWidth;
-
-        ImageDiskTaskListener(final int targetWidth) {
-            mTargetWidth = targetWidth;
-        }
-
-        @Override
-        public void onComplete(final String key, final byte[] content) {
-            if (key == null) {
-                failAllTasks();
-                return;
-            } else {
-                Bitmap bitmap = null;
-                if (content != null) {
-                     bitmap = ImageService.byteArrayToBitmap(content, mTargetWidth);
-                }
-                mResults.put(key, bitmap);
-            }
-
-            if (mCompletedCount.incrementAndGet() == mSize) {
-                mImageTaskManagerListener.onSuccess(mResults);
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
deleted file mode 100644
index b022aa2f..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package com.mopub.nativeads;
-
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.logging.MoPubLog;
-
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpUriRequest;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.common.DownloadTask.DownloadTaskListener;
-import static java.util.Map.Entry;
-
-class ImageDownloadTaskManager extends TaskManager<DownloadResponse> {
-
-    private final Map<HttpUriRequest, DownloadTask> mDownloadTasks;
-    private final int mRequestedWidth;
-
-    ImageDownloadTaskManager(final List<String> urls,
-                             final TaskManagerListener<DownloadResponse> imageTaskManagerListener,
-                             final int requestedWidth)
-            throws IllegalArgumentException {
-        super(urls, imageTaskManagerListener);
-
-        mRequestedWidth = requestedWidth;
-
-        final DownloadTaskListener downloadTaskListener = new ImageDownloadTaskListener();
-        mDownloadTasks = new HashMap<HttpUriRequest, DownloadTask>(urls.size());
-        for (final String url : urls) {
-            final HttpGet httpGet = new HttpGet(url);
-            mDownloadTasks.put(httpGet, new DownloadTask(downloadTaskListener));
-        }
-    }
-
-    @Override
-    void execute() {
-        if (mDownloadTasks.isEmpty()) {
-            mImageTaskManagerListener.onSuccess(mResults);
-        }
-
-        for (final Entry<HttpUriRequest, DownloadTask> entry : mDownloadTasks.entrySet()) {
-            final HttpUriRequest httpUriRequest = entry.getKey();
-            final DownloadTask downloadTask = entry.getValue();
-
-            try {
-                AsyncTasks.safeExecuteOnExecutor(downloadTask, httpUriRequest);
-            } catch (Exception e) {
-                MoPubLog.d("Failed to download image", e);
-
-                mImageTaskManagerListener.onFail();
-            }
-        }
-    }
-
-    void failAllTasks() {
-        if (mFailed.compareAndSet(false, true)) {
-            for (final DownloadTask downloadTask : mDownloadTasks.values()) {
-                downloadTask.cancel(true);
-            }
-            mImageTaskManagerListener.onFail();
-        }
-    }
-
-    private class ImageDownloadTaskListener implements DownloadTaskListener {
-        @Override
-        public void onComplete(final String url, final DownloadResponse downloadResponse) {
-            if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.d("Failed to download image: " + url);
-                failAllTasks();
-                return;
-            }
-
-            MoPubLog.d("Successfully downloaded image bye array: " + url);
-            mResults.put(url, downloadResponse);
-            if (mCompletedCount.incrementAndGet() == mSize) {
-                mImageTaskManagerListener.onSuccess(mResults);
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
deleted file mode 100644
index d020becc..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
+++ /dev/null
@@ -1,287 +0,0 @@
-package com.mopub.nativeads;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Point;
-import android.view.Display;
-import android.view.WindowManager;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.VersionCode;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static android.graphics.BitmapFactory.Options;
-import static android.graphics.BitmapFactory.decodeByteArray;
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.nativeads.TaskManager.TaskManagerListener;
-import static java.util.Map.Entry;
-
-class ImageService {
-    private static final int TWO_MEGABYTES = 2097152;
-    private static int sTargetWidth = -1;
-
-    interface ImageServiceListener {
-        void onSuccess(Map<String, Bitmap> bitmaps);
-        void onFail();
-    }
-
-    @TargetApi(13)
-    @VisibleForTesting
-    static void initialize(Context context) {
-        if (sTargetWidth == -1) {
-            // Get Display Options
-            WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-            Display display = wm.getDefaultDisplay();
-            Point size = new Point();
-            if (VersionCode.currentApiLevel().isBelow(HONEYCOMB_MR2)) {
-                size.set(display.getWidth(), display.getHeight());
-            } else {
-                display.getSize(size);
-            }
-
-            // Make our images no wider than the skinny side of the display.
-            sTargetWidth = Math.min(size.x, size.y);
-        }
-    }
-
-    static void get(final Context context, final List<String> urls, final ImageServiceListener imageServiceListener) {
-        initialize(context);
-        CacheService.initialize(context);
-        get(urls, imageServiceListener);
-    }
-
-    static void get(final List<String> urls, final ImageServiceListener imageServiceListener) {
-        final Map<String, Bitmap> cacheBitmaps = new HashMap<String, Bitmap>(urls.size());
-        final List<String> urlCacheMisses = getBitmapsFromMemoryCache(urls, cacheBitmaps);
-
-        if (urlCacheMisses.isEmpty()) {
-            imageServiceListener.onSuccess(cacheBitmaps);
-            return;
-        }
-
-        final ImageDiskTaskManager imageDiskTaskManager;
-        try {
-            imageDiskTaskManager = new ImageDiskTaskManager(
-                    urlCacheMisses,
-                    new ImageDiskTaskManagerListener(imageServiceListener, cacheBitmaps),
-                    sTargetWidth
-            );
-        } catch (IllegalArgumentException e) {
-            MoPubLog.d("Unable to initialize ImageDiskTaskManager", e);
-            imageServiceListener.onFail();
-            return;
-        }
-
-        imageDiskTaskManager.execute();
-    }
-
-
-
-    static void putBitmapInCache(final String key, final Bitmap bitmap) {
-        CacheService.putToBitmapCache(key, bitmap);
-    }
-
-    static void putDataInCache(final String key, final Bitmap bitmap, final byte[] byteData) {
-        CacheService.putToBitmapCache(key, bitmap);
-        CacheService.putToDiskCacheAsync(key, byteData);
-    }
-
-    static List<String> getBitmapsFromMemoryCache(final List<String> urls, final Map<String, Bitmap> hits) {
-        final List<String> cacheMisses = new ArrayList<String>();
-        for (final String url : urls) {
-            final Bitmap bitmap = getBitmapFromMemoryCache(url);
-
-            if (bitmap != null) {
-                hits.put(url, bitmap);
-            } else {
-                cacheMisses.add(url);
-            }
-        }
-
-        return cacheMisses;
-    }
-
-    static Bitmap getBitmapFromMemoryCache(final String key) {
-        return CacheService.getFromBitmapCache(key);
-    }
-
-    private static class ImageDiskTaskManagerListener implements TaskManagerListener<Bitmap> {
-        final private ImageServiceListener mImageServiceListener;
-        final private Map<String, Bitmap> mBitmaps;
-
-        ImageDiskTaskManagerListener(final ImageServiceListener imageServiceListener,
-                final Map<String, Bitmap> bitmaps) {
-            mImageServiceListener = imageServiceListener;
-            mBitmaps = bitmaps;
-        }
-
-        @Override
-        public void onSuccess(final Map<String, Bitmap> diskBitmaps) {
-            final List<String> urlDiskMisses = new ArrayList<String>();
-            for (final Entry <String, Bitmap> entry : diskBitmaps.entrySet()) {
-                if (entry.getValue() == null) {
-                    urlDiskMisses.add(entry.getKey());
-                } else {
-                    putBitmapInCache(entry.getKey(), entry.getValue());
-                    mBitmaps.put(entry.getKey(), entry.getValue());
-                }
-            }
-
-            if (urlDiskMisses.isEmpty()) {
-                mImageServiceListener.onSuccess(mBitmaps);
-            } else {
-
-                final ImageDownloadTaskManager imageDownloadTaskManager;
-                try {
-                    imageDownloadTaskManager = new ImageDownloadTaskManager(
-                            urlDiskMisses,
-                            new ImageDownloadResponseListener(mImageServiceListener, mBitmaps),
-                            sTargetWidth
-                    );
-                } catch (IllegalArgumentException e) {
-                    MoPubLog.d("Unable to initialize ImageDownloadTaskManager", e);
-                    mImageServiceListener.onFail();
-                    return;
-                }
-
-                imageDownloadTaskManager.execute();
-            }
-        }
-
-        @Override
-        public void onFail() {
-            mImageServiceListener.onFail();
-        }
-    }
-
-    private static class ImageDownloadResponseListener implements TaskManagerListener<DownloadResponse> {
-        private final ImageServiceListener mImageServiceListener;
-        private final Map<String, Bitmap> mBitmaps;
-
-        ImageDownloadResponseListener(final ImageServiceListener imageServiceListener,
-                final Map<String, Bitmap> bitmaps) {
-            mImageServiceListener = imageServiceListener;
-            mBitmaps = bitmaps;
-        }
-
-        @Override
-        public void onSuccess(final Map<String, DownloadResponse> responses) {
-            for (final Entry<String, DownloadResponse> entry : responses.entrySet()) {
-                final Bitmap bitmap = asBitmap(entry.getValue(), sTargetWidth);
-                final String key = entry.getKey();
-                if (bitmap == null) {
-                    MoPubLog.d("Error decoding image for url: " + entry.getKey());
-                    onFail();
-                    return;
-                }
-
-                putDataInCache(key, bitmap, entry.getValue().getByteArray());
-                mBitmaps.put(key, bitmap);
-            }
-            mImageServiceListener.onSuccess(mBitmaps);
-        }
-
-        @Override
-        public void onFail() {
-            mImageServiceListener.onFail();
-        }
-    }
-
-    public static Bitmap asBitmap(final DownloadResponse downloadResponse, final int requestedWidth) {
-        if (downloadResponse == null) {
-            return null;
-        }
-
-        final byte[] bytes = downloadResponse.getByteArray();
-        return byteArrayToBitmap(bytes, requestedWidth);
-    }
-
-    public static Bitmap byteArrayToBitmap(final byte[] bytes, final int requestedWidth) {
-        if (requestedWidth <= 0) {
-            return null;
-        }
-
-        Options options = new Options();
-        options.inJustDecodeBounds = true;
-        decodeByteArray(bytes, 0, bytes.length, options);
-        options.inSampleSize = calculateInSampleSize(options.outWidth, requestedWidth);
-
-        // If the bitmap will be very large, downsample more to avoid blowing up the heap.
-        while (getMemBytes(options) > TWO_MEGABYTES) {
-            options.inSampleSize *= 2;
-        }
-
-        options.inJustDecodeBounds = false;
-        Bitmap bitmap = decodeByteArray(bytes, 0, bytes.length, options);
-        if (bitmap == null) {
-            return null;
-        }
-
-        final int subsampleWidth = bitmap.getWidth();
-
-        // If needed, scale the bitmap so it's exactly the requested width.
-        if (subsampleWidth > requestedWidth) {
-            final int requestedHeight = (int)(bitmap.getHeight() * (double) requestedWidth / bitmap.getWidth());
-            Bitmap subsampledBitmap = bitmap;
-            bitmap = Bitmap.createScaledBitmap(subsampledBitmap, requestedWidth, requestedHeight, true);
-            subsampledBitmap.recycle();
-        }
-        
-        return bitmap;
-    }
-
-    /**
-     * Returns the size of the byte array that the bitmap described by the options object will consume.
-     */
-    public static long getMemBytes(Options options) {
-        long memBytes = 4 * (long) options.outWidth * (long) options.outHeight / options.inSampleSize / options.inSampleSize;
-        return memBytes;
-    }
-
-    /**
-     * Calculate the largest inSampleSize value that is a power of 2 and keeps the
-     * width greater than or equal to the requested width.
-     */
-    public static int calculateInSampleSize(final int nativeWidth, int requestedWidth) {
-        int inSampleSize = 1;
-
-        if (nativeWidth > requestedWidth) {
-            final int halfWidth = nativeWidth / 2;
-
-            while ((halfWidth / inSampleSize) >= requestedWidth) {
-                inSampleSize *= 2;
-            }
-        }
-
-        return inSampleSize;
-    }
-
-    // Testing, also performs disk IO
-    @Deprecated
-    static Bitmap getBitmapFromDiskCache(final String key) {
-        Bitmap bitmap = null;
-        byte[] bytes = CacheService.getFromDiskCache(key);
-        if (bytes != null) {
-            bitmap = byteArrayToBitmap(bytes, sTargetWidth);
-        }
-        return bitmap;
-    }
-
-    @VisibleForTesting
-    static void clear() {
-        sTargetWidth = -1;
-    }
-
-    @VisibleForTesting
-    static int getTargetWidth() {
-        return sTargetWidth;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
deleted file mode 100644
index ef337e0c..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.mopub.nativeads;
-
-import android.graphics.Bitmap;
-import android.widget.ImageView;
-
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Utils;
-
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.WeakHashMap;
-
-import static com.mopub.nativeads.ImageService.ImageServiceListener;
-
-class ImageViewService {
-    // This is used instead of View.setTag, which causes a memory leak in 2.3
-    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
-    private static final WeakHashMap<ImageView, Long> sImageViewRequestIds =
-            new WeakHashMap<ImageView, Long>();
-
-    private ImageViewService(){}
-
-    static void loadImageView(final String url, final ImageView imageView) {
-        if (imageView == null) {
-            MoPubLog.d("Attempted to load an image into a null ImageView");
-            return;
-        }
-
-        // Blank out previous image content while waiting for request to return
-        imageView.setImageDrawable(null);
-
-        if (url != null) {
-            // Unique id to identify this async image request
-            long uniqueId = Utils.generateUniqueId();
-            sImageViewRequestIds.put(imageView, uniqueId);
-
-            // Async call to get image from memory cache, disk and then network
-            ImageService.get(
-                    Arrays.asList(url),
-                    new MyImageViewServiceListener(url, imageView, uniqueId)
-            );
-        }
-    }
-
-    private static class MyImageViewServiceListener implements ImageServiceListener {
-        private final WeakReference<ImageView> mImageView;
-        private final String mUrl;
-        private final long mUniqueId;
-
-        MyImageViewServiceListener(final String url, final ImageView imageView, final long uniqueId) {
-            mUrl = url;
-            mImageView = new WeakReference<ImageView>(imageView);
-            mUniqueId = uniqueId;
-        }
-
-        @Override
-        public void onSuccess(final Map<String, Bitmap> bitmaps) {
-            final ImageView imageView = mImageView.get();
-            if (imageView == null || bitmaps == null || !bitmaps.containsKey(mUrl)) {
-                return;
-            }
-            final Long uniqueId = sImageViewRequestIds.get(imageView);
-            if (uniqueId != null && mUniqueId == uniqueId) {
-                imageView.setImageBitmap(bitmaps.get(mUrl));
-            }
-        }
-
-        @Override
-        public void onFail() {
-            MoPubLog.d("Failed to load image for ImageView");
-        }
-    }
-
-    @VisibleForTesting
-    @Deprecated
-    static Long getImageViewUniqueId(final ImageView imageView) {
-        return sImageViewRequestIds.get(imageView);
-    }
-
-    @VisibleForTesting
-    @Deprecated
-    static void setImageViewUniqueId(final ImageView imageView, final long uniqueId) {
-        sImageViewRequestIds.put(imageView, uniqueId);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
index 35508618..176f0e65 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 import com.mopub.common.VisibleForTesting;
@@ -19,27 +21,27 @@
     private static final int PERIOD = 250;
 
     // Object tracking visibility of added views
-    private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
 
     // All views and responses being tracked for impressions
-    private final Map<View, NativeResponse> mTrackedViews;
+    @NonNull private final Map<View, NativeResponse> mTrackedViews;
 
     // Visible views being polled for time on screen before tracking impression
-    private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
+    @NonNull private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
 
     // Handler for polling visible views
-    private final Handler mPollHandler;
+    @NonNull private final Handler mPollHandler;
 
     // Runnable to run on each visibility loop
-    private final PollingRunnable mPollingRunnable;
+    @NonNull private final PollingRunnable mPollingRunnable;
 
     // Object to check actual visibility
-    private final VisibilityChecker mVisibilityChecker;
+    @NonNull private final VisibilityChecker mVisibilityChecker;
 
     // Listener for when a view becomes visible or non visible
-    private VisibilityTrackerListener mVisibilityTrackerListener;
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
-    ImpressionTracker(final Context context) {
+    ImpressionTracker(@NonNull final Context context) {
         this(new WeakHashMap<View, NativeResponse>(),
                 new WeakHashMap<View, TimestampWrapper<NativeResponse>>(),
                 new VisibilityChecker(),
@@ -48,11 +50,11 @@
     }
 
     @VisibleForTesting
-    ImpressionTracker(final Map<View, NativeResponse> trackedViews,
-                      final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
-                      final VisibilityChecker visibilityChecker,
-                      final VisibilityTracker visibilityTracker,
-                      final Handler handler) {
+    ImpressionTracker(@NonNull final Map<View, NativeResponse> trackedViews,
+            @NonNull final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final VisibilityTracker visibilityTracker,
+            @NonNull final Handler handler) {
         mTrackedViews = trackedViews;
         mPollingViews = pollingViews;
         mVisibilityChecker = visibilityChecker;
@@ -60,7 +62,7 @@
 
         mVisibilityTrackerListener = new VisibilityTrackerListener() {
             @Override
-            public void onVisibilityChanged(final List<View> visibleViews, final List<View> invisibleViews) {
+            public void onVisibilityChanged(@NonNull final List<View> visibleViews, @NonNull final List<View> invisibleViews) {
                 for (final View view : visibleViews) {
                     // It's possible for native response to be null if the view was GC'd from this class
                     // but not from VisibilityTracker
@@ -96,7 +98,7 @@ public void onVisibilityChanged(final List<View> visibleViews, final List<View>
     /**
      * Tracks the given view for impressions.
      */
-    void addView(final View view, final NativeResponse nativeResponse) {
+    void addView(final View view, @NonNull final NativeResponse nativeResponse) {
         // View is already associated with same native response
         if (mTrackedViews.get(view) == nativeResponse) {
             return;
@@ -153,7 +155,7 @@ private void removePollingView(final View view) {
     class PollingRunnable implements Runnable {
         // Create this once to avoid excessive garbage collection observed when calculating
         // these on each pass.
-        private final ArrayList<View> mRemovedViews;
+        @NonNull private final ArrayList<View> mRemovedViews;
 
         PollingRunnable() {
             mRemovedViews = new ArrayList<View>();
@@ -189,6 +191,7 @@ public void run() {
         }
     }
 
+    @Nullable
     @Deprecated
     @VisibleForTesting
     VisibilityTrackerListener getVisibilityTrackerListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
index ddd2aac8..de938aa9 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.database.DataSetObserver;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Adapter;
@@ -9,12 +11,15 @@
 import android.widget.BaseAdapter;
 import android.widget.ListAdapter;
 import android.widget.ListView;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 
-import java.util.*;
+import java.util.List;
+import java.util.WeakHashMap;
 
 import static android.widget.AdapterView.OnItemClickListener;
 import static android.widget.AdapterView.OnItemLongClickListener;
@@ -32,12 +37,12 @@
  * wish to avoid wrapping your original adapter, you can use {@code MoPubStreamAdPlacer} directly.
  */
 public class MoPubAdAdapter extends BaseAdapter {
-    private final WeakHashMap<View, Integer> mViewPositionMap;
-    private final Adapter mOriginalAdapter;
-    private final MoPubStreamAdPlacer mStreamAdPlacer;
-    private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final WeakHashMap<View, Integer> mViewPositionMap;
+    @NonNull private final Adapter mOriginalAdapter;
+    @NonNull private final MoPubStreamAdPlacer mStreamAdPlacer;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
 
-    private MoPubNativeAdLoadedListener mAdLoadedListener;
+    @Nullable private MoPubNativeAdLoadedListener mAdLoadedListener;
 
     /**
      * Creates a new MoPubAdAdapter object.
@@ -49,7 +54,7 @@
      * @param context The activity context.
      * @param originalAdapter Your original adapter.
      */
-    public MoPubAdAdapter(final Context context, final Adapter originalAdapter) {
+    public MoPubAdAdapter(@NonNull final Context context, @NonNull final Adapter originalAdapter) {
         this(context, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
     }
 
@@ -61,9 +66,9 @@ public MoPubAdAdapter(final Context context, final Adapter originalAdapter) {
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubAdAdapter(final Context context,
-            final Adapter originalAdapter,
-            final MoPubServerPositioning adPositioning) {
+    public MoPubAdAdapter(@NonNull final Context context,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final MoPubServerPositioning adPositioning) {
         this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
                 new VisibilityTracker(context));
     }
@@ -76,17 +81,17 @@ public MoPubAdAdapter(final Context context,
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubAdAdapter(final Context context,
-            final Adapter originalAdapter,
-            final MoPubClientPositioning adPositioning) {
+    public MoPubAdAdapter(@NonNull final Context context,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final MoPubClientPositioning adPositioning) {
         this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
                 new VisibilityTracker(context));
     }
 
     @VisibleForTesting
-    MoPubAdAdapter(final MoPubStreamAdPlacer streamAdPlacer,
-            final Adapter originalAdapter,
-            final VisibilityTracker visibilityTracker) {
+    MoPubAdAdapter(@NonNull final MoPubStreamAdPlacer streamAdPlacer,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final VisibilityTracker visibilityTracker) {
         mOriginalAdapter = originalAdapter;
         mStreamAdPlacer = streamAdPlacer;
         mViewPositionMap = new WeakHashMap<View, Integer>();
@@ -94,7 +99,7 @@ public MoPubAdAdapter(final Context context,
         mVisibilityTracker = visibilityTracker;
         mVisibilityTracker.setVisibilityTrackerListener(new VisibilityTrackerListener() {
             @Override
-            public void onVisibilityChanged(final List<View> visibleViews,
+            public void onVisibilityChanged(@NonNull final List<View> visibleViews,
                     final List<View> invisibleViews) {
                 handleVisibilityChange(visibleViews);
             }
@@ -152,15 +157,35 @@ void handleAdRemoved(final int position) {
      * subject to change in a future SDK version.
      *
      * @param adRenderer The ad renderer.
+     *
+     * @deprecated in version 3.9.0, use {@link #registerViewBinder(ViewBinder)} instead.
      */
-    public final void registerAdRenderer(final MoPubAdRenderer adRenderer) {
-        if (adRenderer == null) {
-            MoPubLog.w("Tried to set a null ad renderer on the placer.");
+    @Deprecated
+    public final void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        if (!Preconditions.NoThrow.checkNotNull(
+                adRenderer, "Tried to set a null ad renderer on the placer.")) {
             return;
         }
         mStreamAdPlacer.registerAdRenderer(adRenderer);
     }
 
+    /**
+     * Registers a {@link ViewBinder} to use when displaying ads in your stream.
+     *
+     * This binder will be used automatically to create and render your view when you call
+     * {@link #getView}. If you register a second {@link ViewBinder}, it will replace the first,
+     * although this behavior is subject to change in a future SDK version.
+     *
+     * @param viewBinder The view binder
+     */
+    public final void registerViewBinder(@NonNull final ViewBinder viewBinder) {
+        if (!Preconditions.NoThrow.checkNotNull(
+                viewBinder, "Tried to set a null view binder on the placer.")) {
+            return;
+        }
+        mStreamAdPlacer.registerAdRenderer(new MoPubNativeAdRenderer(viewBinder));
+    }
+
     /**
      * Sets a listener that will be called after the SDK loads new ads from the server and places
      * them into your stream.
@@ -173,7 +198,7 @@ public final void registerAdRenderer(final MoPubAdRenderer adRenderer) {
      *
      * @param listener The listener.
      */
-    public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
+    public final void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
         mAdLoadedListener = listener;
     }
 
@@ -185,7 +210,7 @@ public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void loadAds(final String adUnitId) {
+    public void loadAds(@NonNull final String adUnitId) {
         mStreamAdPlacer.loadAds(adUnitId);
     }
 
@@ -203,8 +228,8 @@ public void loadAds(final String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void loadAds(final String adUnitId,
-            final RequestParameters requestParameters) {
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
         mStreamAdPlacer.loadAds(adUnitId, requestParameters);
     }
 
@@ -280,6 +305,7 @@ public int getCount() {
      *
      * @inheritDoc
      */
+    @Nullable
     @Override
     public Object getItem(final int position) {
         final Object ad = mStreamAdPlacer.getAdData(position);
@@ -302,7 +328,7 @@ public Object getItem(final int position) {
     public long getItemId(final int position) {
         final Object adData = mStreamAdPlacer.getAdData(position);
         if (adData != null) {
-            return ~System.identityHashCode(adData) + 1;
+            return -System.identityHashCode(adData);
         }
         return mOriginalAdapter.getItemId(mStreamAdPlacer.getOriginalPosition(position));
     }
@@ -323,6 +349,7 @@ public boolean hasStableIds() {
      *
      * @inheritDoc
      */
+    @Nullable
     @Override
     public View getView(final int position, final View view, final ViewGroup viewGroup) {
         final View resultView;
@@ -377,7 +404,7 @@ public boolean isEmpty() {
         return mOriginalAdapter.isEmpty() && mStreamAdPlacer.getAdjustedCount(0) == 0;
     }
 
-    private void handleVisibilityChange(final List<View> visibleViews) {
+    private void handleVisibilityChange(@NonNull final List<View> visibleViews) {
         // Loop through all visible positions in order to build a max and min range, and then
         // place ads into that range.
         int min = Integer.MAX_VALUE;
@@ -451,7 +478,6 @@ public void removeItem(final int originalPosition) {
         mStreamAdPlacer.removeItem(originalPosition);
     }
 
-
     /**
      * Sets an on click listener for the given ListView, automatically adjusting the listener
      * callback positions based on ads in the adapter.
@@ -461,8 +487,17 @@ public void removeItem(final int originalPosition) {
      * @param listView The ListView for this adapter.
      * @param listener An on click listener.
      */
-    public void setOnClickListener(final ListView listView,
-            final OnItemClickListener listener) {
+    public void setOnClickListener(@NonNull final ListView listView,
+            @Nullable final OnItemClickListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setOnClickListener with a" +
+                " null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemClickListener(null);
+            return;
+        }
+
         listView.setOnItemClickListener(new OnItemClickListener() {
             @Override
             public void onItemClick(final AdapterView<?> adapterView, final View view,
@@ -484,8 +519,17 @@ public void onItemClick(final AdapterView<?> adapterView, final View view,
      * @param listView The ListView for this adapter.
      * @param listener An an long click listener.
      */
-    public void setOnItemLongClickListener(final ListView listView,
-            final OnItemLongClickListener listener) {
+    public void setOnItemLongClickListener(@NonNull final ListView listView,
+            @Nullable final OnItemLongClickListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter." +
+                "setOnItemLongClickListener with a null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemLongClickListener(null);
+            return;
+        }
+
         listView.setOnItemLongClickListener(new OnItemLongClickListener() {
             @Override
             public boolean onItemLongClick(final AdapterView<?> adapterView,
@@ -503,8 +547,17 @@ public boolean onItemLongClick(final AdapterView<?> adapterView,
      * @param listView The ListView for this adapter.
      * @param listener An an item selected listener.
      */
-    public void setOnItemSelectedListener(final ListView listView,
-            final OnItemSelectedListener listener) {
+    public void setOnItemSelectedListener(@NonNull final ListView listView,
+            @Nullable final OnItemSelectedListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setOnItemSelectedListener" +
+                " with a null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemSelectedListener(null);
+            return;
+        }
+
         listView.setOnItemSelectedListener(new OnItemSelectedListener() {
             @Override
             public void onItemSelected(final AdapterView<?> adapterView,
@@ -529,7 +582,12 @@ public void onNothingSelected(final AdapterView<?> adapterView) {
      * @param listView The ListView for this adapter.
      * @param originalPosition The original content position before loading ads.
      */
-    public void setSelection(final ListView listView, final int originalPosition) {
+    public void setSelection(@NonNull final ListView listView, final int originalPosition) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setSelection with a null " +
+                "ListView")) {
+            return;
+        }
+
         listView.setSelection(mStreamAdPlacer.getAdjustedPosition(originalPosition));
     }
 
@@ -540,7 +598,13 @@ public void setSelection(final ListView listView, final int originalPosition) {
      * @param listView The ListView for this adapter.
      * @param originalPosition The original content position before loading ads.
      */
-    public void smoothScrollToPosition(final ListView listView, final int originalPosition) {
+    public void smoothScrollToPosition(@NonNull final ListView listView,
+            final int originalPosition) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.smoothScrollToPosition " +
+                "with a null ListView")) {
+            return;
+        }
+
         listView.smoothScrollToPosition(mStreamAdPlacer.getAdjustedPosition(originalPosition));
     }
 
@@ -552,7 +616,7 @@ public void smoothScrollToPosition(final ListView listView, final int originalPo
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void refreshAds(final ListView listView, String adUnitId) {
+    public void refreshAds(@NonNull final ListView listView, @NonNull String adUnitId) {
         refreshAds(listView, adUnitId, null);
     }
 
@@ -565,10 +629,10 @@ public void refreshAds(final ListView listView, String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void refreshAds(final ListView listView,
-            String adUnitId, RequestParameters requestParameters) {
-        if (listView.getAdapter() != this) {
-            MoPubLog.w("You called refreshAds on a ListView whose adapter is not an ad placer");
+    public void refreshAds(@NonNull final ListView listView,
+            @NonNull String adUnitId, @Nullable RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.refreshAds with a null " +
+                "ListView")) {
             return;
         }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
index 87542fb1..686b3c52 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
@@ -1,6 +1,8 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
@@ -9,8 +11,8 @@
  *
  * Normally you will use the subclass {@link com.mopub.nativeads.MoPubNativeAdRenderer} with {@link
  * com.mopub.nativeads.ViewBinder} to customize your ad view with your own layout. However, if you
- * wish to programmatically create or manage your ad view, you can implement {@code
- * }MoPubAdRenderer} directly.
+ * wish to programmatically create or manage your ad view, you can implement {@code MoPubAdRenderer}
+ * directly.
  *
  * @param <T> The ad payload type.
  */
@@ -19,21 +21,22 @@
      * Creates a new view to be used as an ad.
      *
      * This method is called when you call {@link com.mopub.nativeads.MoPubStreamAdPlacer#getAdView}
-     * when the convertView is null. You must return a valid view.
+     * and the convertView is null. You must return a valid view.
      *
+     * @param context The context. Useful for creating a view.
      * @param parent The parent that the view will eventually be attached to. You might use the
      * parent to determine layout parameters, but should return the view without attaching it to the
      * parent.
-     * @param context The context. Useful for creating a view.
      * @return A new ad view.
      */
-    View createAdView(Context context, ViewGroup parent);
+    @NonNull
+    View createAdView(@NonNull Context context, @Nullable ViewGroup parent);
 
     /**
      * Renders a view created by {@link #createAdView} by filling it with ad data.
      *
-     * @param view The ad View
+     * @param view The ad {@link View}
      * @param ad The ad data that should be bound to the view.
      */
-    void renderAdView(View view, T ad);
+    void renderAdView(@NonNull View view, @NonNull T ad);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
index 93f1ad45..6c71875d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
@@ -1,87 +1,87 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.mopub.common.event.ErrorEvent;
+import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import org.json.JSONTokener;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
 import static com.mopub.common.util.Numbers.parseDouble;
-import static com.mopub.nativeads.CustomEventNativeAdapter.RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.JSON_BODY_KEY;
 import static com.mopub.nativeads.NativeResponse.Parameter;
 
 public class MoPubCustomEventNative extends CustomEventNative {
 
     @Override
-    protected void loadNativeAd(final Context context,
-            final CustomEventNativeListener customEventNativeListener,
-            final Map<String, Object> localExtras,
-            final Map<String, String> serverExtras) {
+    protected void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) {
+
+        Object json = localExtras.get(JSON_BODY_KEY);
+        // null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
+        if (!(json instanceof JSONObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
+            return;
+        }
 
         final MoPubForwardingNativeAd moPubForwardingNativeAd =
                 new MoPubForwardingNativeAd(context.getApplicationContext(),
-                        serverExtras.get(RESPONSE_BODY_KEY),
+                        (JSONObject) json,
                         customEventNativeListener);
 
         try {
             moPubForwardingNativeAd.loadAd();
         } catch (IllegalArgumentException e) {
             customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
-            return;
-        } catch (JSONException e) {
-            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
-            return;
         }
     }
 
     static class MoPubForwardingNativeAd extends BaseForwardingNativeAd {
-        private final Context mContext;
-        private final String mJsonString;
-        private final CustomEventNativeListener mCustomEventNativeListener;
-
-        MoPubForwardingNativeAd(final Context context,
-                final String jsonString,
-                final CustomEventNativeListener customEventNativeListener) {
+        @NonNull private final Context mContext;
+        @NonNull private final CustomEventNativeListener mCustomEventNativeListener;
+        @NonNull private final JSONObject mJsonObject;
+
+        MoPubForwardingNativeAd(@NonNull final Context context,
+                @NonNull final JSONObject jsonBody,
+                @NonNull final CustomEventNativeListener customEventNativeListener) {
+            mJsonObject = jsonBody;
             mContext = context;
-            mJsonString = jsonString;
             mCustomEventNativeListener = customEventNativeListener;
         }
 
-        void loadAd() throws IllegalArgumentException, JSONException {
-            if (mJsonString == null) {
-                throw new IllegalArgumentException("Json String cannot be null");
-            }
-
-            final JSONTokener jsonTokener = new JSONTokener(mJsonString);
-            final JSONObject jsonObject = new JSONObject(jsonTokener);
-
-            if (!containsRequiredKeys(jsonObject)) {
+        void loadAd() throws IllegalArgumentException {
+            if (!containsRequiredKeys(mJsonObject)) {
                 throw new IllegalArgumentException("JSONObject did not contain required keys.");
             }
 
-            final Iterator<String> keys = jsonObject.keys();
+            final Iterator<String> keys = mJsonObject.keys();
             while (keys.hasNext()) {
                 final String key = keys.next();
                 final Parameter parameter = Parameter.from(key);
 
                 if (parameter != null) {
                     try {
-                        addInstanceVariable(parameter, jsonObject.opt(key));
+                        addInstanceVariable(parameter, mJsonObject.opt(key));
                     } catch (ClassCastException e) {
                         throw new IllegalArgumentException("JSONObject key (" + key + ") contained unexpected value.");
                     }
                 } else {
-                    addExtra(key, jsonObject.opt(key));
+                    addExtra(key, mJsonObject.opt(key));
                 }
             }
 
@@ -98,9 +98,8 @@ public void onImagesFailedToCache(final NativeErrorCode errorCode) {
             });
         }
 
-        private boolean containsRequiredKeys(final JSONObject jsonObject) {
+        private boolean containsRequiredKeys(@NonNull final JSONObject jsonObject) {
             final Set<String> keys = new HashSet<String>();
-
             final Iterator<String> jsonKeys = jsonObject.keys();
             while (jsonKeys.hasNext()) {
                 keys.add(jsonKeys.next());
@@ -109,7 +108,8 @@ private boolean containsRequiredKeys(final JSONObject jsonObject) {
             return keys.containsAll(Parameter.requiredKeys);
         }
 
-        private void addInstanceVariable(final Parameter key, final Object value) throws ClassCastException {
+        private void addInstanceVariable(@NonNull final Parameter key,
+                @Nullable final Object value) throws ClassCastException {
             try {
                 switch (key) {
                     case MAIN_IMAGE:
@@ -167,10 +167,11 @@ private void addImpressionTrackers(final Object impressionTrackers) throws Class
             }
         }
 
-        private boolean isImageKey(final String name) {
-            return name != null && name.toLowerCase().endsWith("image");
+        private boolean isImageKey(@Nullable final String name) {
+            return name != null && name.toLowerCase(Locale.US).endsWith("image");
         }
 
+        @NonNull
         List<String> getExtrasImageUrls() {
             final List<String> extrasBitmapUrls = new ArrayList<String>(getExtras().size());
             for (final Map.Entry<String, Object> entry : getExtras().entrySet()) {
@@ -182,6 +183,7 @@ private boolean isImageKey(final String name) {
             return extrasBitmapUrls;
         }
 
+        @NonNull
         List<String> getAllImageUrls() {
             final List<String> imageUrls = new ArrayList<String>();
             if (getMainImageUrl() != null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
index 8c718eb4..04123976 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -1,35 +1,41 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.HttpClient;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.ManifestUtils;
-import com.mopub.common.util.ResponseHeader;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpUriRequest;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
 
 import java.lang.ref.WeakReference;
-import java.util.*;
+import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.common.GpsHelper.GpsHelperListener;
 import static com.mopub.common.GpsHelper.fetchAdvertisingInfoAsync;
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.NativeErrorCode.CONNECTION_ERROR;
 import static com.mopub.nativeads.NativeErrorCode.EMPTY_AD_RESPONSE;
+import static com.mopub.nativeads.NativeErrorCode.INVALID_JSON;
 import static com.mopub.nativeads.NativeErrorCode.INVALID_REQUEST_URL;
 import static com.mopub.nativeads.NativeErrorCode.SERVER_ERROR_RESPONSE_CODE;
-import static com.mopub.nativeads.NativeErrorCode.UNEXPECTED_RESPONSE_CODE;
 import static com.mopub.nativeads.NativeErrorCode.UNSPECIFIED;
 
 public class MoPubNative {
+
     public interface MoPubNativeNetworkListener {
         public void onNativeLoad(final NativeResponse nativeResponse);
         public void onNativeFail(final NativeErrorCode errorCode);
@@ -38,7 +44,7 @@
     static final MoPubNativeNetworkListener EMPTY_NETWORK_LISTENER = new
             MoPubNativeNetworkListener() {
         @Override
-        public void onNativeLoad(final NativeResponse nativeResponse) {
+        public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
             // If this listener is invoked, it means that MoPubNative instance has been destroyed
             // so destroy any leftover incoming NativeResponses
             nativeResponse.destroy();
@@ -51,10 +57,10 @@ public void onNativeFail(final NativeErrorCode errorCode) {
     static final MoPubNativeEventListener EMPTY_EVENT_LISTENER = new
             MoPubNativeEventListener() {
         @Override
-        public void onNativeImpression(final View view) {
+        public void onNativeImpression(@Nullable final View view) {
         }
         @Override
-        public void onNativeClick(final View view) {
+        public void onNativeClick(@Nullable final View view) {
         }
     };
 
@@ -72,11 +78,15 @@ public void onNativeClick(final View view) {
     }
 
     // must be an activity context since 3rd party networks need it
-    private final WeakReference<Context> mContext;
-    private final String mAdUnitId;
-    private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
-    private MoPubNativeEventListener mMoPubNativeEventListener;
-    private Map<String, Object> mLocalExtras;
+    @NonNull private final WeakReference<Context> mContext;
+    @NonNull private final String mAdUnitId;
+    @NonNull private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
+
+    // For small sets TreeMap, takes up less memory than HashMap
+    @NonNull private Map<String, Object> mLocalExtras = new TreeMap<String, Object>();
+    @NonNull private final AdRequest.Listener mVolleyListener;
+    @Nullable private AdRequest mNativeRequest;
 
     /**
      * @deprecated As of release 2.4, use {@link MoPubNative(Context, String,
@@ -84,23 +94,19 @@ public void onNativeClick(final View view) {
      * instead.
      */
     @Deprecated
-    public MoPubNative(final Context context,
-            final String adUnitId,
-            final MoPubNativeListener moPubNativeListener) {
-        this(context, adUnitId, (MoPubNativeNetworkListener)moPubNativeListener);
+    public MoPubNative(@NonNull final Context context,
+            @NonNull final String adUnitId,
+            @NonNull final MoPubNativeListener moPubNativeListener) {
+        this(context, adUnitId, (MoPubNativeNetworkListener) moPubNativeListener);
         setNativeEventListener(moPubNativeListener);
     }
 
-    public MoPubNative(final Context context,
-                final String adUnitId,
-                final MoPubNativeNetworkListener moPubNativeNetworkListener) {
-        if (context == null) {
-            throw new IllegalArgumentException("Context may not be null.");
-        } else if (adUnitId == null) {
-            throw new IllegalArgumentException("AdUnitId may not be null.");
-        } else if (moPubNativeNetworkListener == null) {
-            throw new IllegalArgumentException("MoPubNativeNetworkListener may not be null.");
-        }
+    public MoPubNative(@NonNull final Context context,
+                @NonNull final String adUnitId,
+                @NonNull final MoPubNativeNetworkListener moPubNativeNetworkListener) {
+        Preconditions.checkNotNull(context, "Context may not be null.");
+        Preconditions.checkNotNull(adUnitId, "AdUnitId may not be null.");
+        Preconditions.checkNotNull(moPubNativeNetworkListener, "MoPubNativeNetworkListener may not be null.");
 
         ManifestUtils.checkNativeActivitiesDeclared(context);
 
@@ -108,40 +114,55 @@ public MoPubNative(final Context context,
         mAdUnitId = adUnitId;
         mMoPubNativeNetworkListener = moPubNativeNetworkListener;
         mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
+        mVolleyListener = new AdRequest.Listener() {
+            @Override
+            public void onSuccess(@NonNull final AdResponse response) {
+                onAdLoad(response);
+            }
+
+            @Override
+            public void onErrorResponse(@NonNull final VolleyError volleyError) {
+                onAdError(volleyError);
+            }
+        };
 
         // warm up cache for google play services info
         fetchAdvertisingInfoAsync(context, null);
     }
 
-    public void setNativeEventListener(final MoPubNativeEventListener nativeEventListener) {
+    public void setNativeEventListener(@Nullable final MoPubNativeEventListener nativeEventListener) {
         mMoPubNativeEventListener = (nativeEventListener == null)
                 ? EMPTY_EVENT_LISTENER : nativeEventListener;
     }
 
     public void destroy() {
         mContext.clear();
+        if (mNativeRequest != null) {
+            mNativeRequest.cancel();
+            mNativeRequest = null;
+        }
         mMoPubNativeNetworkListener = EMPTY_NETWORK_LISTENER;
         mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
     }
 
-    public void setLocalExtras(final Map<String, Object> localExtras) {
-        mLocalExtras = new HashMap<String, Object>(localExtras);
+    public void setLocalExtras(@Nullable final Map<String, Object> localExtras) {
+        if (localExtras == null) {
+            mLocalExtras = new TreeMap<String, Object>();
+        } else {
+            mLocalExtras = new TreeMap<String, Object>(localExtras);
+        }
     }
 
     public void makeRequest() {
         makeRequest((RequestParameters)null);
     }
 
-    public void makeRequest(final RequestParameters requestParameters) {
+    public void makeRequest(@Nullable final RequestParameters requestParameters) {
         makeRequest(requestParameters, null);
     }
 
-    public void makeRequest(final RequestParameters requestParameters,
-            Integer sequenceNumber) {
-        makeRequest(new NativeGpsHelperListener(requestParameters, sequenceNumber));
-    }
-
-    void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
+    public void makeRequest(@Nullable final RequestParameters requestParameters,
+            @Nullable Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -152,18 +173,12 @@ void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
             return;
         }
 
-        // If we have access to Google Play Services (GPS) but the advertising info
-        // is not cached then guarantee we get it before building the ad request url
-        // in the callback, this is a requirement from Google
-        GpsHelper.fetchAdvertisingInfoAsync(
-                context,
-                nativeGpsHelperListener
-        );
+        loadNativeAd(requestParameters, sequenceNumber);
     }
 
-
-    private void loadNativeAd(final RequestParameters requestParameters,
-            final Integer sequenceNumber) {
+    private void loadNativeAd(
+            @Nullable final RequestParameters requestParameters,
+            @Nullable final Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -177,7 +192,7 @@ private void loadNativeAd(final RequestParameters requestParameters,
             generator.withSequenceNumber(sequenceNumber);
         }
 
-        final String endpointUrl = generator.generateUrlString(Constants.NATIVE_HOST);
+        final String endpointUrl = generator.generateUrlString(Constants.HOST);
 
         if (endpointUrl != null) {
             MoPubLog.d("Loading ad from: " + endpointUrl);
@@ -186,11 +201,7 @@ private void loadNativeAd(final RequestParameters requestParameters,
         requestNativeAd(endpointUrl);
     }
 
-    void loadNativeAd(final RequestParameters requestParameters) {
-        loadNativeAd(requestParameters, null);
-    }
-
-    void requestNativeAd(final String endpointUrl) {
+    void requestNativeAd(@Nullable final String endpointUrl) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -201,70 +212,86 @@ void requestNativeAd(final String endpointUrl) {
             return;
         }
 
-        final HttpGet httpGet;
-        try {
-            httpGet = HttpClient.initializeHttpGet(endpointUrl, context);
-        } catch (IllegalArgumentException e) {
-            mMoPubNativeNetworkListener.onNativeFail(INVALID_REQUEST_URL);
-            return;
-        }
-
-        downloadJson(httpGet);
+        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, context, mVolleyListener);
+        RequestQueue requestQueue = Networking.getRequestQueue(context);
+        requestQueue.add(mNativeRequest);
     }
 
-    private void downloadJson(final HttpUriRequest httpUriRequest) {
-        final DownloadTask jsonDownloadTask = new DownloadTask(new DownloadTask.DownloadTaskListener() {
-            @Override
-            public void onComplete(final String url, final DownloadResponse downloadResponse) {
-                if (downloadResponse == null) {
-                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
-                } else if (downloadResponse.getStatusCode() >= 500 &&
-                        downloadResponse.getStatusCode() < 600) {
-                    mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
-                } else if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    mMoPubNativeNetworkListener.onNativeFail(UNEXPECTED_RESPONSE_CODE);
-                } else if (downloadResponse.getContentLength() == 0) {
-                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
-                } else {
-                    final CustomEventNativeListener customEventNativeListener = new CustomEventNativeListener() {
-                        @Override
-                        public void onNativeAdLoaded(final NativeAdInterface nativeAd) {
-                            final Context context = getContextOrDestroy();
-                            if (context == null) {
-                                return;
-                            }
-                            mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context, downloadResponse, mAdUnitId, nativeAd, mMoPubNativeEventListener));
-                        }
-
-                        @Override
-                        public void onNativeAdFailed(final NativeErrorCode errorCode) {
-                            requestNativeAd(downloadResponse.getFirstHeader(ResponseHeader.FAIL_URL));
+    private void onAdLoad(@NonNull final AdResponse response) {
+        final Context context = getContextOrDestroy();
+        if (context == null) {
+            return;
+        }
+        final CustomEventNativeListener customEventNativeListener =
+                new CustomEventNativeListener() {
+                    @Override
+                    public void onNativeAdLoaded(@NonNull final NativeAdInterface nativeAd) {
+                        final Context context = getContextOrDestroy();
+                        if (context == null) {
+                            return;
                         }
-                    };
+                        mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context,
+                                response.getImpressionTrackingUrl(),
+                                response.getClickTrackingUrl(),
+                                mAdUnitId,
+                                nativeAd,
+                                mMoPubNativeEventListener));
+                    }
 
-                    final Context context = getContextOrDestroy();
-                    if (context == null) {
-                        return;
+                    @Override
+                    public void onNativeAdFailed(final NativeErrorCode errorCode) {
+                        requestNativeAd(response.getFailoverUrl());
                     }
+                };
 
-                    CustomEventNativeAdapter.loadNativeAd(
-                            context,
-                            mLocalExtras,
-                            downloadResponse,
-                            customEventNativeListener
-                    );
-                }
-            }
-        });
 
-        try {
-            AsyncTasks.safeExecuteOnExecutor(jsonDownloadTask, httpUriRequest);
-        } catch (Exception e) {
-            MoPubLog.d("Failed to download json", e);
 
-            mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
-        }
+        CustomEventNativeAdapter.loadNativeAd(
+                context,
+                mLocalExtras,
+                response,
+                customEventNativeListener
+        );
+    }
 
+    @VisibleForTesting
+    void onAdError(@NonNull final VolleyError volleyError) {
+        MoPubLog.d("Native ad request failed.", volleyError);
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError error = (MoPubNetworkError) volleyError;
+            switch (error.getReason()) {
+                case BAD_BODY:
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    return;
+                case BAD_HEADER_DATA:
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    return;
+                case WARMING_UP:
+                    // Used for the sample app to signal a toast.
+                    // This is not customer-facing except in the sample app.
+                    MoPubLog.c(MoPubErrorCode.WARMUP.toString());
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
+                case NO_FILL:
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
+                case UNSPECIFIED:
+                default:
+                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
+                    return;
+            }
+        } else {
+            // Process our other status code errors.
+            NetworkResponse response = volleyError.networkResponse;
+            if (response != null && response.statusCode >= 500 && response.statusCode < 600) {
+                mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
+            } else if (response == null && !DeviceUtils.isNetworkAvailable(mContext.get())) {
+                MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
+            } else {
+                mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
+            }
+        }
     }
 
     Context getContextOrDestroy() {
@@ -277,33 +304,14 @@ Context getContextOrDestroy() {
         return context;
     }
 
-    // Do not store this class as a member of MoPubNative; will result in circular reference
-    class NativeGpsHelperListener implements GpsHelperListener {
-        private final RequestParameters mRequestParameters;
-        private final Integer mSequenceNumber;
-
-        NativeGpsHelperListener(RequestParameters requestParameters, Integer sequenceNumber) {
-            mRequestParameters = requestParameters;
-            mSequenceNumber = sequenceNumber;
-        }
-
-        NativeGpsHelperListener(RequestParameters requestParameters) {
-            this(requestParameters, null);
-        }
-
-        @Override
-        public void onFetchAdInfoCompleted() {
-
-            loadNativeAd(mRequestParameters, mSequenceNumber);
-        }
-    }
-
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
         return mMoPubNativeNetworkListener;
     }
 
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeEventListener getMoPubNativeEventListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
index 593439ee..d3e1b6c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 import com.mopub.common.Preconditions;
 
 import java.util.ArrayList;
@@ -38,7 +40,7 @@
          */
         public static final int NO_REPEAT = Integer.MAX_VALUE;
 
-        private final ArrayList<Integer> mFixedPositions = new ArrayList<Integer>();
+        @NonNull private final ArrayList<Integer> mFixedPositions = new ArrayList<Integer>();
         private int mRepeatInterval = NO_REPEAT;
 
         public MoPubClientPositioning() {
@@ -50,6 +52,7 @@ public MoPubClientPositioning() {
          * @param position The ad position.
          * @return This object for easy use in chained setters.
          */
+        @NonNull
         public MoPubClientPositioning addFixedPosition(final int position) {
             if (!Preconditions.NoThrow.checkArgument(position >= 0)) {
                 return this;
@@ -68,6 +71,7 @@ public MoPubClientPositioning addFixedPosition(final int position) {
          *
          * @return Fixed ad positions.
          */
+        @NonNull
         List<Integer> getFixedPositions() {
             return mFixedPositions;
         }
@@ -79,6 +83,7 @@ public MoPubClientPositioning addFixedPosition(final int position) {
          * the constant NO_REPEAT.
          * @return This object for easy use in chained setters.
          */
+        @NonNull
         public MoPubClientPositioning enableRepeatingPositions(final int interval) {
             if (!Preconditions.NoThrow.checkArgument(
                     interval > 1, "Repeating interval must be greater than 1")) {
@@ -102,7 +107,10 @@ int getRepeatingInterval() {
         }
     }
 
-    static MoPubClientPositioning clone(MoPubClientPositioning positioning) {
+    @NonNull
+    static MoPubClientPositioning clone(@NonNull MoPubClientPositioning positioning) {
+        Preconditions.checkNotNull(positioning);
+
         MoPubClientPositioning clone = new MoPubClientPositioning();
         clone.mFixedPositions.addAll(positioning.mFixedPositions);
         clone.mRepeatInterval = positioning.mRepeatInterval;
@@ -113,6 +121,7 @@ static MoPubClientPositioning clone(MoPubClientPositioning positioning) {
      * Creates and returns a {@link MoPubClientPositioning} object.
      * @return A new positioning object.
      */
+    @NonNull
     public static MoPubClientPositioning clientPositioning() {
         return new MoPubClientPositioning();
     }
@@ -121,6 +130,7 @@ public static MoPubClientPositioning clientPositioning() {
      * Creates and returns a {@link MoPubServerPositioning} object.
      * @return A new positioning object.
      */
+    @NonNull
     public static MoPubServerPositioning serverPositioning() {
         return new MoPubServerPositioning();
     }
@@ -133,6 +143,7 @@ public static MoPubServerPositioning serverPositioning() {
      * the MoPub UI. If you still want to hard-code positioning information in your app,
      * use {@link #clientPositioning} instead of this builder.
      */
+    @NonNull
     @Deprecated
     public static Builder newBuilder() {
         return new Builder();
@@ -143,12 +154,14 @@ public static Builder newBuilder() {
      */
     @Deprecated
     public static final class Builder extends MoPubClientPositioning {
+        @NonNull
         @Override
         public Builder addFixedPosition(final int position) {
             super.addFixedPosition(position);
             return this;
         }
 
+        @NonNull
         @Override
         public Builder enableRepeatingPositions(final int interval) {
             super.enableRepeatingPositions(interval);
@@ -160,6 +173,7 @@ public Builder enableRepeatingPositions(final int interval) {
          *
          * @return A new positioning object.
          */
+        @NonNull
         @Deprecated
         public MoPubClientPositioning build() {
             return this;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
index e33dd2c6..e48869ef 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
@@ -16,60 +17,41 @@
  * An implementation of {@link com.mopub.nativeads.MoPubAdRenderer} for rendering native ads.
  */
 public class MoPubNativeAdRenderer implements MoPubAdRenderer<NativeResponse> {
-
-    private final ViewBinder mViewBinder;
+    @NonNull private final ViewBinder mViewBinder;
 
     // This is used instead of View.setTag, which causes a memory leak in 2.3
     // and earlier: https://code.google.com/p/android/issues/detail?id=18273
-    private final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
+    @VisibleForTesting @NonNull final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
 
     /**
      * Constructs a native ad renderer with a view binder.
      *
      * @param viewBinder The view binder to use when inflating and rendering an ad.
      */
-    public MoPubNativeAdRenderer(final ViewBinder viewBinder) {
+    public MoPubNativeAdRenderer(@NonNull final ViewBinder viewBinder) {
         mViewBinder = viewBinder;
         mViewHolderMap = new WeakHashMap<View, NativeViewHolder>();
     }
 
     @Override
-    public View createAdView(final Context context, final ViewGroup parent) {
+    @NonNull
+    public View createAdView(@NonNull final Context context, @Nullable final ViewGroup parent) {
         return LayoutInflater
                 .from(context)
                 .inflate(mViewBinder.layoutId, parent, false);
     }
 
     @Override
-    public void renderAdView(final View view, final NativeResponse nativeResponse) {
-        final NativeViewHolder nativeViewHolder = getOrCreateNativeViewHolder(view, mViewBinder);
-
-        if (nativeViewHolder == null) {
-            MoPubLog.d("Could not create NativeViewHolder.");
-            return;
-        }
-
-        populateConvertViewSubViews(view, nativeViewHolder, nativeResponse, mViewBinder);
-        view.setVisibility(VISIBLE);
-    }
-
-    @VisibleForTesting
-    NativeViewHolder getOrCreateNativeViewHolder(final View view, final ViewBinder viewBinder) {
-        // Create view holder and put it in the view tag
+    public void renderAdView(@NonNull final View view,
+            @NonNull final NativeResponse nativeResponse) {
         NativeViewHolder nativeViewHolder = mViewHolderMap.get(view);
         if (nativeViewHolder == null) {
-            nativeViewHolder = NativeViewHolder.fromViewBinder(view, viewBinder);
+            nativeViewHolder = NativeViewHolder.fromViewBinder(view, mViewBinder);
             mViewHolderMap.put(view, nativeViewHolder);
-            return nativeViewHolder;
         }
-        return nativeViewHolder;
-    }
 
-    private void populateConvertViewSubViews(final View view,
-            final NativeViewHolder nativeViewHolder,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder) {
         nativeViewHolder.update(nativeResponse);
-        nativeViewHolder.updateExtras(view, nativeResponse, viewBinder);
+        nativeViewHolder.updateExtras(nativeResponse, mViewBinder);
+        nativeViewHolder.setViewVisibility(VISIBLE);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java
new file mode 100644
index 00000000..df999462
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java
@@ -0,0 +1,559 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
+
+import java.util.List;
+import java.util.WeakHashMap;
+
+import static com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy.INSERT_AT_END;
+import static com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy.KEEP_ADS_FIXED;
+
+
+public final class MoPubRecyclerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
+    // RecyclerView ad views will have negative types to avoid colliding with original view types.
+    static final int NATIVE_AD_VIEW_TYPE_BASE = -56;
+
+    public enum ContentChangeStrategy {
+        INSERT_AT_END, MOVE_ALL_ADS_WITH_CONTENT, KEEP_ADS_FIXED
+    }
+
+    @NonNull private final RecyclerView.AdapterDataObserver mAdapterDataObserver;
+    @Nullable private RecyclerView mRecyclerView;
+    @NonNull private final MoPubStreamAdPlacer mStreamAdPlacer;
+    @NonNull private final RecyclerView.Adapter mOriginalAdapter;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final WeakHashMap<View, Integer> mViewPositionMap;
+
+    @NonNull private ContentChangeStrategy mStrategy = INSERT_AT_END;
+    @Nullable private MoPubNativeAdLoadedListener mAdLoadedListener;
+
+    public MoPubRecyclerAdapter(@NonNull Context context,
+            @NonNull RecyclerView.Adapter originalAdapter) {
+        this(context, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
+    }
+
+    public MoPubRecyclerAdapter(@NonNull Context context,
+            @NonNull RecyclerView.Adapter originalAdapter,
+            @NonNull MoPubServerPositioning adPositioning) {
+        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
+                new VisibilityTracker(context));
+    }
+
+    public MoPubRecyclerAdapter(@NonNull Context context,
+            @NonNull RecyclerView.Adapter originalAdapter,
+            @NonNull MoPubClientPositioning adPositioning) {
+        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
+                new VisibilityTracker(context));
+    }
+
+    @VisibleForTesting
+    MoPubRecyclerAdapter(@NonNull final MoPubStreamAdPlacer streamAdPlacer,
+            @NonNull final RecyclerView.Adapter originalAdapter,
+            @NonNull final VisibilityTracker visibilityTracker) {
+        mViewPositionMap = new WeakHashMap<>();
+        mOriginalAdapter = originalAdapter;
+        mVisibilityTracker = visibilityTracker;
+        mVisibilityTracker.setVisibilityTrackerListener(new VisibilityTracker.VisibilityTrackerListener() {
+            @Override
+            public void onVisibilityChanged(final List<View> visibleViews,
+                    final List<View> invisibleViews) {
+                handleVisibilityChanged(visibleViews, invisibleViews);
+            }
+        });
+
+        setHasStableIdsInternal(mOriginalAdapter.hasStableIds());
+
+        mStreamAdPlacer = streamAdPlacer;
+        mStreamAdPlacer.setAdLoadedListener(new MoPubNativeAdLoadedListener() {
+            @Override
+            public void onAdLoaded(final int position) {
+                handleAdLoaded(position);
+            }
+
+            @Override
+            public void onAdRemoved(final int position) {
+                handleAdRemoved(position);
+            }
+        });
+        mStreamAdPlacer.setItemCount(mOriginalAdapter.getItemCount());
+
+        mAdapterDataObserver = new RecyclerView.AdapterDataObserver() {
+            @Override
+            public void onChanged() {
+                mStreamAdPlacer.setItemCount(mOriginalAdapter.getItemCount());
+                notifyDataSetChanged();
+            }
+
+            @Override
+            public void onItemRangeChanged(final int positionStart, final int itemCount) {
+                int adjustedEndPosition = mStreamAdPlacer.getAdjustedPosition(positionStart + itemCount - 1);
+                int adjustedStartPosition = mStreamAdPlacer.getAdjustedPosition(positionStart);
+                int adjustedCount = adjustedEndPosition - adjustedStartPosition + 1;
+                notifyItemRangeChanged(adjustedStartPosition, adjustedCount);
+            }
+
+            @Override
+            public void onItemRangeInserted(final int positionStart, final int itemCount) {
+                final int adjustedStartPosition = mStreamAdPlacer.getAdjustedPosition(positionStart);
+                final int newOriginalCount = mOriginalAdapter.getItemCount();
+                mStreamAdPlacer.setItemCount(newOriginalCount);
+                final boolean addingToEnd = positionStart + itemCount >= newOriginalCount;
+                if (KEEP_ADS_FIXED == mStrategy
+                        || (INSERT_AT_END == mStrategy
+                        && addingToEnd)) {
+                    notifyDataSetChanged();
+                } else {
+                    for (int i = 0; i < itemCount; i++) {
+                        // We insert itemCount items at the original position, moving ads downstream.
+                        mStreamAdPlacer.insertItem(positionStart);
+                    }
+                    notifyItemRangeInserted(adjustedStartPosition, itemCount);
+                }
+            }
+
+            @Override
+            public void onItemRangeRemoved(final int positionStart, final int itemsRemoved) {
+                int adjustedStartPosition = mStreamAdPlacer.getAdjustedPosition(positionStart);
+                final int newOriginalCount = mOriginalAdapter.getItemCount();
+                mStreamAdPlacer.setItemCount(newOriginalCount);
+                final boolean removingFromEnd = positionStart + itemsRemoved >= newOriginalCount;
+                if (KEEP_ADS_FIXED == mStrategy
+                        || (INSERT_AT_END == mStrategy
+                        && removingFromEnd)) {
+                    notifyDataSetChanged();
+                } else {
+                    final int oldAdjustedCount = mStreamAdPlacer.getAdjustedCount(newOriginalCount + itemsRemoved);
+                    for (int i = 0; i < itemsRemoved; i++) {
+                        // We remove itemsRemoved items at the original position.
+                        mStreamAdPlacer.removeItem(positionStart);
+                    }
+
+                    final int itemsRemovedIncludingAds = oldAdjustedCount - mStreamAdPlacer.getAdjustedCount(newOriginalCount);
+                    // Need to move the start position back by the # of ads removed.
+                    adjustedStartPosition -= itemsRemovedIncludingAds - itemsRemoved;
+                    notifyItemRangeRemoved(adjustedStartPosition, itemsRemovedIncludingAds);
+                }
+            }
+
+            @Override
+            public void onItemRangeMoved(final int fromPosition, final int toPosition,
+                    final int itemCount) {
+                notifyDataSetChanged();
+            }
+        };
+
+        mOriginalAdapter.registerAdapterDataObserver(mAdapterDataObserver);
+    }
+
+    @Override
+    public void onAttachedToRecyclerView(final RecyclerView recyclerView) {
+        super.onAttachedToRecyclerView(recyclerView);
+        mRecyclerView = recyclerView;
+    }
+
+    @Override
+    public void onDetachedFromRecyclerView(final RecyclerView recyclerView) {
+        super.onDetachedFromRecyclerView(recyclerView);
+        mRecyclerView = null;
+    }
+
+    /**
+     * Sets a listener that will be called after the SDK loads new ads from the server and places
+     * them into your stream.
+     *
+     * The listener will be active between when you call {@link #loadAds} and when you call
+     * destroy(). You can also set the listener to {@code null} to remove the listener.
+     *
+     * Note that there is not a one to one correspondence between calls to {@link #loadAds} and this
+     * listener. The SDK will call the listener every time an ad loads.
+     *
+     * @param listener The listener.
+     */
+    public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = listener;
+    }
+
+    /**
+     * Registers a view binder for rendering "static" native ads with images.
+     */
+    public void registerViewBinder(@NonNull ViewBinder viewBinder) {
+        mStreamAdPlacer.registerAdRenderer(new MoPubNativeAdRenderer(viewBinder), NATIVE_AD_VIEW_TYPE_BASE + 1);
+    }
+
+    /**
+     * Start loading ads from the MoPub server.
+     *
+     * We recommend using {@link #loadAds(String, RequestParameters)} instead of this method, in
+     * order to pass targeting information to the server.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     */
+    public void loadAds(@NonNull String adUnitId) {
+        mStreamAdPlacer.loadAds(adUnitId);
+    }
+
+    /**
+     * Start loading ads from the MoPub server, using the given request targeting information.
+     *
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for each
+     * ad that is added to the stream.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     * @param requestParameters Targeting information to pass to the ad server.
+     */
+    public void loadAds(@NonNull String adUnitId, @Nullable RequestParameters requestParameters) {
+        mStreamAdPlacer.loadAds(adUnitId, requestParameters);
+    }
+
+    public static int computeScrollOffset(@NonNull final LinearLayoutManager linearLayoutManager,
+            @Nullable final RecyclerView.ViewHolder holder) {
+        if (holder == null) {
+            return 0;
+        }
+        final View view = holder.itemView;
+
+        int offset = 0;
+        if (linearLayoutManager.canScrollVertically()) {
+            if (linearLayoutManager.getStackFromEnd()) {
+                offset = view.getBottom();
+            } else {
+                offset = view.getTop();
+            }
+        } else if (linearLayoutManager.canScrollHorizontally()) {
+            if (linearLayoutManager.getStackFromEnd()) {
+                offset = view.getRight();
+            } else {
+                offset = view.getLeft();
+            }
+        }
+
+        return offset;
+    }
+
+    /**
+     * Refreshes ads in the adapter while preserving the scroll position.
+     *
+     * Call this instead of {@link #loadAds(String, RequestParameters)} in order to preserve the
+     * scroll position in your view. Only usable with LinearLayoutManager or GridLayoutManager.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     */
+    public void refreshAds(@NonNull String adUnitId) {
+        refreshAds(adUnitId, null);
+    }
+
+    /**
+     * Refreshes ads in the adapter while preserving the scroll position.
+     *
+     * Call this instead of {@link #loadAds(String, RequestParameters)} in order to preserve the
+     * scroll position in your view. Only usable with LinearLayoutManager or GridLayoutManager.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     * @param requestParameters Targeting information to pass to the ad server.
+     */
+    public void refreshAds(@NonNull String adUnitId,
+            @Nullable RequestParameters requestParameters) {
+        if (mRecyclerView == null) {
+            MoPubLog.w("This adapter is not attached to a RecyclerView and cannot be refreshed.");
+            return;
+        }
+
+        final RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager();
+        if (layoutManager == null) {
+            MoPubLog.w("Can't refresh ads when there is no layout manager on a RecyclerView.");
+            return;
+        }
+
+        if (layoutManager instanceof LinearLayoutManager) {
+            // Includes GridLayoutManager
+
+            // Get the range & offset of scroll position.
+            LinearLayoutManager linearLayoutManager = (LinearLayoutManager) layoutManager;
+            final int firstPosition = linearLayoutManager.findFirstVisibleItemPosition();
+            RecyclerView.ViewHolder holder = mRecyclerView.findViewHolderForLayoutPosition(firstPosition);
+            final int scrollOffset = computeScrollOffset(linearLayoutManager, holder);
+
+            // Calculate the range of ads not to remove ads from.
+            int startOfRange = Math.max(0, firstPosition - 1);
+            while (mStreamAdPlacer.isAd(startOfRange) && startOfRange > 0) {
+                startOfRange--;
+            }
+
+
+            final int itemCount = getItemCount();
+            int endOfRange = linearLayoutManager.findLastVisibleItemPosition();
+            while (mStreamAdPlacer.isAd(endOfRange) && endOfRange < itemCount - 1) {
+                endOfRange++;
+            }
+
+            final int originalStartOfRange = mStreamAdPlacer.getOriginalPosition(startOfRange);
+            final int originalEndOfRange = mStreamAdPlacer.getOriginalPosition(endOfRange);
+            final int endCount = mOriginalAdapter.getItemCount();
+
+            mStreamAdPlacer.removeAdsInRange(originalEndOfRange, endCount);
+            final int numAdsRemoved = mStreamAdPlacer.removeAdsInRange(0, originalStartOfRange);
+
+            if (numAdsRemoved > 0) {
+                linearLayoutManager.scrollToPositionWithOffset(firstPosition - numAdsRemoved, scrollOffset);
+            }
+
+            loadAds(adUnitId, requestParameters);
+        } else {
+            MoPubLog.w("This LayoutManager can't be refreshed.");
+            return;
+        }
+    }
+
+    /**
+     * Stops loading ads, immediately clearing any ads currently in the stream.
+     *
+     * This method also stops ads from loading as the user moves through the stream. When ads
+     * are cleared, {@link MoPubNativeAdLoadedListener#onAdRemoved} will be called for each ad
+     * that is removed from the stream.
+     */
+    public void clearAds() {
+        mStreamAdPlacer.clearAds();
+    }
+
+    /**
+     * Whether the given position is an ad.
+     *
+     * This will return {@code true} only if there is an ad loaded for this position. You can also
+     * listen for ads to load using {@link MoPubNativeAdLoadedListener#onAdLoaded(int)}.
+     *
+     * @param position The position to check for an ad, expressed in terms of the position in the
+     * stream including ads.
+     * @return Whether there is an ad at the given position.
+     */
+    public boolean isAd(final int position) {
+        return mStreamAdPlacer.isAd(position);
+    }
+
+    /**
+     * Returns the position of an item considering ads in the stream.
+     *
+     * @see {@link MoPubStreamAdPlacer#getAdjustedPosition(int)}
+     * @param originalPosition The original position.
+     * @return The position adjusted by placing ads.
+     */
+    public int getAdjustedPosition(final int originalPosition) {
+        return mStreamAdPlacer.getAdjustedPosition(originalPosition);
+    }
+
+    /**
+     * Returns the original position of an item considering ads in the stream.
+     *
+     * @see {@link MoPubStreamAdPlacer#getOriginalPosition(int)}
+     * @param position The adjusted position.
+     * @return The original position before placing ads.
+     */
+    public int getOriginalPosition(final int position) {
+        return mStreamAdPlacer.getOriginalPosition(position);
+    }
+
+    /**
+     * Sets the strategy this adapter should use for moving ads when content is added or removed
+     * from the wrapped original adapter. This strategy can be set at any time to change the
+     * behavior of the adapter.
+     * <ul>
+     * <li>{@link com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy#INSERT_AT_END}
+     *     will insert ads when content is added to the end of the stream. This is the default behavior
+     *     and the recommended strategy.</li>
+     * <li>{@link com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy#MOVE_ALL_ADS_WITH_CONTENT}
+     *     will cause all ad positions after an insertion or deletion to be adjusted. New
+     *     ads will not be displayed when items are added to the end of the stream.</li>
+     * <li>{@link com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy#KEEP_ADS_FIXED}
+     *     will never adjust ad positions when items are inserted or removed.</li>
+     * </ul>
+     */
+    public void setContentChangeStrategy(@NonNull ContentChangeStrategy strategy) {
+        if (!Preconditions.NoThrow.checkNotNull(strategy)) {
+            return;
+        }
+        mStrategy = strategy;
+    }
+
+    @Override
+    public int getItemCount() {
+        return mStreamAdPlacer.getAdjustedCount(mOriginalAdapter.getItemCount());
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(final ViewGroup parent, final int viewType) {
+        if (viewType >= NATIVE_AD_VIEW_TYPE_BASE && viewType <= NATIVE_AD_VIEW_TYPE_BASE + mStreamAdPlacer.getAdViewTypeCount()) {
+            // Create the view and a view holder.
+            final MoPubAdRenderer adRenderer = mStreamAdPlacer.getAdRendererForViewType(viewType);
+            if (adRenderer == null) {
+                MoPubLog.w("No view binder was registered for ads in MoPubRecyclerAdapter.");
+                // This will cause a null pointer exception.
+                return null;
+            }
+            return new MoPubRecyclerViewHolder(adRenderer.createAdView(parent.getContext(), parent));
+        }
+
+        return mOriginalAdapter.onCreateViewHolder(parent, viewType);
+    }
+
+    @Override
+    public void onBindViewHolder(final RecyclerView.ViewHolder holder, final int position) {
+        Object adData = mStreamAdPlacer.getAdData(position);
+        if (adData != null) {
+            mStreamAdPlacer.bindAdView((NativeAdData) adData, holder.itemView);
+            return;
+        }
+
+        mViewPositionMap.put(holder.itemView, position);
+        mVisibilityTracker.addView(holder.itemView, 0);
+
+        //noinspection unchecked
+        mOriginalAdapter.onBindViewHolder(holder, mStreamAdPlacer.getOriginalPosition(position));
+    }
+
+    @Override
+    public int getItemViewType(final int position) {
+        int type = mStreamAdPlacer.getAdViewType(position);
+        if (type != MoPubStreamAdPlacer.CONTENT_VIEW_TYPE) {
+            return NATIVE_AD_VIEW_TYPE_BASE + type;
+        }
+
+        return mOriginalAdapter.getItemViewType(mStreamAdPlacer.getOriginalPosition(position));
+    }
+
+    @Override
+    public void setHasStableIds(final boolean hasStableIds) {
+        setHasStableIdsInternal(hasStableIds);
+
+        // We can only setHasStableIds when there are no observers on the adapter.
+        mOriginalAdapter.unregisterAdapterDataObserver(mAdapterDataObserver);
+        mOriginalAdapter.setHasStableIds(hasStableIds);
+        mOriginalAdapter.registerAdapterDataObserver(mAdapterDataObserver);
+    }
+
+    public void destroy() {
+        mOriginalAdapter.unregisterAdapterDataObserver(mAdapterDataObserver);
+        mStreamAdPlacer.destroy();
+        mVisibilityTracker.destroy();
+    }
+
+    /**
+     * Returns a stable negative item ID for ad items & calls getItemId on your original adapter for
+     * non-ad items.
+     *
+     * Returns {@link android.support.v7.widget.RecyclerView#NO_ID} if your original adapter does
+     * not have stable IDs.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public long getItemId(final int position) {
+        if (!mOriginalAdapter.hasStableIds()) {
+            return RecyclerView.NO_ID;
+        }
+
+        final Object adData = mStreamAdPlacer.getAdData(position);
+        if (adData != null) {
+            return -System.identityHashCode(adData);
+        }
+
+        return mOriginalAdapter.getItemId(mStreamAdPlacer.getOriginalPosition(position));
+    }
+
+    // Notification methods to forward to the original adapter.
+    @Override
+    public boolean onFailedToRecycleView(final RecyclerView.ViewHolder holder) {
+        if (holder instanceof MoPubRecyclerViewHolder) {
+            return super.onFailedToRecycleView(holder);
+        }
+
+        // noinspection unchecked
+        return mOriginalAdapter.onFailedToRecycleView(holder);
+    }
+
+    @Override
+    public void onViewAttachedToWindow(final RecyclerView.ViewHolder holder) {
+        if (holder instanceof MoPubRecyclerViewHolder) {
+            super.onViewAttachedToWindow(holder);
+            return;
+        }
+
+        // noinspection unchecked
+        mOriginalAdapter.onViewAttachedToWindow(holder);
+    }
+
+    @Override
+    public void onViewDetachedFromWindow(final RecyclerView.ViewHolder holder) {
+        if (holder instanceof MoPubRecyclerViewHolder) {
+            super.onViewDetachedFromWindow(holder);
+            return;
+        }
+
+        // noinspection unchecked
+        mOriginalAdapter.onViewDetachedFromWindow(holder);
+    }
+
+    @Override
+    public void onViewRecycled(final RecyclerView.ViewHolder holder) {
+        if (holder instanceof MoPubRecyclerViewHolder) {
+            super.onViewRecycled(holder);
+            return;
+        }
+
+        // noinspection unchecked
+        mOriginalAdapter.onViewRecycled(holder);
+    }
+    // End forwarded methods.
+
+    @VisibleForTesting
+    void handleAdLoaded(final int position) {
+        if (mAdLoadedListener != null) {
+            mAdLoadedListener.onAdLoaded(position);
+        }
+
+        notifyItemInserted(position);
+    }
+
+    @VisibleForTesting
+    void handleAdRemoved(final int position) {
+        if (mAdLoadedListener != null) {
+            mAdLoadedListener.onAdRemoved(position);
+        }
+
+        notifyItemRemoved(position);
+    }
+
+    private void handleVisibilityChanged(final List<View> visibleViews,
+            final List<View> invisibleViews) {
+        // Loop through all visible positions in order to build a max and min range, and then
+        // place ads into that range.
+        int min = Integer.MAX_VALUE;
+        int max = 0;
+        for (final View view : visibleViews) {
+            final Integer pos = mViewPositionMap.get(view);
+            if (pos == null) {
+                continue;
+            }
+            min = Math.min(pos, min);
+            max = Math.max(pos, max);
+        }
+        mStreamAdPlacer.placeAdsInRange(min, max + 1);
+    }
+
+    /**
+     * Sets the hasStableIds value on this adapter only, not also on the wrapped adapter.
+     */
+    private void setHasStableIdsInternal(final boolean hasStableIds) {
+        super.setHasStableIds(hasStableIds);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerViewHolder.java
new file mode 100644
index 00000000..963f2ce5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerViewHolder.java
@@ -0,0 +1,11 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+
+public class MoPubRecyclerViewHolder extends RecyclerView.ViewHolder {
+    public MoPubRecyclerViewHolder(@NonNull final View itemView) {
+        super(itemView);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
index 0234a56b..eeec32ee 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -2,17 +2,26 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
 
-import java.util.*;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.WeakHashMap;
 
 /**
- * @code MoPubStreamAdPlacer facilitates loading ads and placing them into a content stream.
+ * {@code MoPubStreamAdPlacer} facilitates loading ads and placing them into a content stream.
  *
  * If you are inserting ads into a ListView, we recommend that you use a {@link MoPubAdAdapter}
  * instead of this class.
@@ -29,25 +38,41 @@
      * instead of an ad.
      */
     public static final int CONTENT_VIEW_TYPE = 0;
+    private static final int DEFAULT_AD_VIEW_TYPE = -1;
+    private final static MoPubNativeAdLoadedListener EMPTY_NATIVE_AD_LOADED_LISTENER =
+            new MoPubNativeAdLoadedListener() {
+                @Override
+                public void onAdLoaded(final int position) {
+                }
+
+                @Override
+                public void onAdRemoved(final int position) {
+                }
+            };
 
-    private final Context mContext;
-    private final Handler mPlacementHandler;
-    private final Runnable mPlacementRunnable;
-    private final PositioningSource mPositioningSource;
-    private final NativeAdSource mAdSource;
-    private final ImpressionTracker mImpressionTracker;
-    private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
+    @NonNull private final Context mContext;
+    @NonNull private final Handler mPlacementHandler;
+    @NonNull private final Runnable mPlacementRunnable;
+    @NonNull private final PositioningSource mPositioningSource;
+    @NonNull private final NativeAdSource mAdSource;
+    @NonNull private final ImpressionTracker mImpressionTracker;
+
+    @NonNull private final HashMap<NativeResponse, WeakReference<View>> mViewMap;
+    @NonNull private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
 
     private boolean mHasReceivedPositions;
-    private PlacementData mPendingPlacementData;
+    @Nullable private PlacementData mPendingPlacementData;
     private boolean mHasReceivedAds;
     private boolean mHasPlacedAds;
-    private PlacementData mPlacementData;
-    
-    private MoPubAdRenderer mAdRenderer;
-    private String mAdUnitId;
+    @NonNull private PlacementData mPlacementData;
+
+    private int adViewType = DEFAULT_AD_VIEW_TYPE;
+    @Nullable private MoPubAdRenderer mAdRenderer;
+    @Nullable private String mAdUnitId;
+
+    @NonNull private MoPubNativeAdLoadedListener mAdLoadedListener =
+            EMPTY_NATIVE_AD_LOADED_LISTENER;
 
-    private MoPubNativeAdLoadedListener mAdLoadedListener;
     // The visible range is the range of items which we believe are visible, inclusive.
     // Placing ads near this range makes for a smoother user experience when scrolling up
     // or down.
@@ -69,7 +94,7 @@
      *
      * @param context The activity context.
      */
-    public MoPubStreamAdPlacer(final Context context) {
+    public MoPubStreamAdPlacer(@NonNull final Context context) {
         // MoPubClientPositioning is mutable, so we must take care not to hold a
         // reference to it that might be subsequently modified by the caller.
         this(context, MoPubNativeAdPositioning.serverPositioning());
@@ -82,7 +107,8 @@ public MoPubStreamAdPlacer(final Context context) {
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubStreamAdPlacer(final Context context, final MoPubServerPositioning adPositioning) {
+    public MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final MoPubServerPositioning adPositioning) {
         this(context,
                 new NativeAdSource(),
                 new ImpressionTracker(context),
@@ -96,7 +122,8 @@ public MoPubStreamAdPlacer(final Context context, final MoPubServerPositioning a
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubStreamAdPlacer(final Context context, final MoPubClientPositioning adPositioning) {
+    public MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final MoPubClientPositioning adPositioning) {
         // MoPubClientPositioning is mutable, so we must take care not to hold a
         // reference to it that might be subsequently modified by the caller.
         this(context,
@@ -106,16 +133,25 @@ public MoPubStreamAdPlacer(final Context context, final MoPubClientPositioning a
     }
 
     @VisibleForTesting
-    MoPubStreamAdPlacer(final Context context,
-            final NativeAdSource adSource,
-            final ImpressionTracker impressionTracker,
-            final PositioningSource positioningSource) {
+    MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final NativeAdSource adSource,
+            @NonNull final ImpressionTracker impressionTracker,
+            @NonNull final PositioningSource positioningSource) {
+        Preconditions.checkNotNull(context, "context is not allowed to be null");
+        Preconditions.checkNotNull(adSource, "adSource is not allowed to be null");
+        Preconditions.checkNotNull(impressionTracker, "impressionTracker is not allowed to be " +
+                "null");
+        Preconditions.checkNotNull(positioningSource, "positioningSource is not allowed to be " +
+                "null");
+
         mContext = context;
         mImpressionTracker = impressionTracker;
         mPositioningSource = positioningSource;
         mAdSource = adSource;
         mPlacementData = PlacementData.empty();
-        mNativeResponseMap = new WeakHashMap<View, NativeResponse>();
+
+        mNativeResponseMap = new WeakHashMap<>();
+        mViewMap = new HashMap<>();
 
         mPlacementHandler = new Handler();
         mPlacementRunnable = new Runnable() {
@@ -142,10 +178,27 @@ public void run() {
      *
      * @param adRenderer The ad renderer.
      */
-    public void registerAdRenderer(final MoPubAdRenderer adRenderer) {
+    public void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        registerAdRenderer(adRenderer, -1);
+    }
+
+    public void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer, int viewType) {
+        if (!NoThrow.checkNotNull(adRenderer, "Cannot register a null adRenderer")) {
+            return;
+        }
+        adViewType = viewType;
         mAdRenderer = adRenderer;
     }
 
+    @Nullable
+    public MoPubAdRenderer getAdRendererForViewType(int viewType) {
+        if (viewType == adViewType) {
+            return mAdRenderer;
+        }
+
+        return null;
+    }
+
     /**
      * Sets a listener that will be called after the SDK loads new ads from the server and places
      * them into your stream.
@@ -158,8 +211,8 @@ public void registerAdRenderer(final MoPubAdRenderer adRenderer) {
      *
      * @param listener The listener.
      */
-    public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
-        mAdLoadedListener = listener;
+    public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = (listener == null) ? EMPTY_NATIVE_AD_LOADED_LISTENER : listener;
     }
 
     /**
@@ -170,14 +223,14 @@ public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void loadAds(final String adUnitId) {
+    public void loadAds(@NonNull final String adUnitId) {
         loadAds(adUnitId, /* requestParameters */ null);
     }
 
     /**
      * Start loading ads from the MoPub server, using the given request targeting information.
      *
-     * When loading ads, use {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
      * each ad that is added to the stream.
      *
      * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
@@ -188,8 +241,17 @@ public void loadAds(final String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void loadAds(final String adUnitId,
-            final RequestParameters requestParameters) {
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(adUnitId, "Cannot load ads with a null ad unit ID")) {
+            return;
+        }
+
+        if (mAdRenderer == null) {
+            MoPubLog.w("You must call registerAdRenderer before loading ads");
+            return;
+        }
+
         mAdUnitId = adUnitId;
 
         mHasPlacedAds = false;
@@ -198,12 +260,15 @@ public void loadAds(final String adUnitId,
 
         mPositioningSource.loadPositions(adUnitId, new PositioningListener() {
             @Override
-            public void onLoad(final MoPubClientPositioning positioning) {
+            public void onLoad(@NonNull final MoPubClientPositioning positioning) {
                 handlePositioningLoad(positioning);
             }
 
             @Override
             public void onFailed() {
+                // This will happen only if positions couldn't be loaded after several tries
+                MoPubLog.d("Unable to show ads because ad positions could not be loaded from " +
+                        "the MoPub ad server.");
             }
         });
 
@@ -218,7 +283,7 @@ public void onAdsAvailable() {
     }
 
     @VisibleForTesting
-    void handlePositioningLoad(final MoPubClientPositioning positioning) {
+    void handlePositioningLoad(@NonNull final MoPubClientPositioning positioning) {
         PlacementData placementData = PlacementData.fromAdPositioning(positioning);
         if (mHasReceivedAds) {
             placeInitialAds(placementData);
@@ -257,7 +322,7 @@ private void placeInitialAds(PlacementData placementData) {
      * Inserts ads that should appear in the given range.
      *
      * By default, the ad placer will place ads withing the first 10 positions in your stream,
-     * according the positions you've specified. You can should use this method as your user scrolls
+     * according to the positions you've specified. You can use this method as your user scrolls
      * through your stream to place ads into the currently visible range.
      *
      * This method takes advantage of a short-lived in memory ad cache, and will immediately place
@@ -333,6 +398,7 @@ public void destroy() {
      * @param position The position where to place an ad.
      * @return An object representing ad data.
      */
+    @Nullable
     public Object getAdData(final int position) {
         return mPlacementData.getPlacedAd(position);
     }
@@ -343,36 +409,52 @@ public Object getAdData(final int position) {
      * This method will attempt to reuse the convertView if it is not {@code null}, and will
      * otherwise create it. See {@link MoPubAdRenderer#createAdView(Context, ViewGroup)}.
      *
-     * @param position The position where to place an ad.
+     * @param position The position to place an ad into.
      * @param convertView A recycled view into which to render data, or {@code null}.
      * @param parent The parent that the view will eventually be attached to.
      * @return The newly placed ad view.
      */
-    public View getAdView(final int position, final View convertView, final ViewGroup parent) {
-        if (!isAd(position)) {
+    @Nullable
+    public View getAdView(final int position, @Nullable final View convertView,
+            @Nullable final ViewGroup parent) {
+        final NativeAdData adData = mPlacementData.getPlacedAd(position);
+        if (adData == null) {
             return null;
         }
 
-        final NativeAdData adData = mPlacementData.getPlacedAd(position);
-        final MoPubAdRenderer adRenderer = adData.getAdRenderer();
         final View view = (convertView != null) ?
-                convertView : adRenderer.createAdView(mContext, parent);
+                convertView : adData.getAdRenderer().createAdView(mContext, parent);
+        bindAdView(adData, view);
+        return view;
+    }
 
+    /**
+     * Given an ad and a view, attaches the ad data to the view and prepares the ad for display.
+     * @param adData the ad to bind.
+     * @param adView the view to bind it to.
+     */
+    public void bindAdView(@NonNull NativeAdData adData, @NonNull View adView) {
         NativeResponse nativeResponse = adData.getAd();
-        if (!nativeResponse.equals(mNativeResponseMap.get(view))) {
-            clearNativeResponse(view);
-            prepareNativeResponse(nativeResponse, view);
-            adRenderer.renderAdView(view, nativeResponse);
+        WeakReference<View> mappedViewRef = mViewMap.get(nativeResponse);
+        View mappedView = null;
+        if (mappedViewRef != null) {
+            mappedView = mappedViewRef.get();
+        }
+        if (!adView.equals(mappedView)) {
+            clearNativeResponse(mappedView);
+            clearNativeResponse(adView);
+            prepareNativeResponse(nativeResponse, adView);
+            //noinspection unchecked
+            adData.getAdRenderer().renderAdView(adView, nativeResponse);
         }
-        return view;
     }
 
     /**
-     * Removes ads in the given range from [startRange, endRange).
+     * Removes ads in the given range from [originalStartPosition, originalEndPosition).
      *
-     * @param originalStartPosition The start position to clear, expressed as the original content
+     * @param originalStartPosition The start position to clear (inclusive), expressed as the original content
      * position before ads were inserted.
-     * @param originalEndPosition The position after end position to clear, expressed as the
+     * @param originalEndPosition The position after end position to clear (exclusive), expressed as the
      * original content position before ads were inserted.
      * @return The number of ads removed.
      */
@@ -382,7 +464,7 @@ public int removeAdsInRange(int originalStartPosition, int originalEndPosition)
         int adjustedStartRange = mPlacementData.getAdjustedPosition(originalStartPosition);
         int adjustedEndRange = mPlacementData.getAdjustedPosition(originalEndPosition);
 
-        ArrayList<Integer> removedPositions = new ArrayList<Integer>();
+        ArrayList<Integer> removedPositions = new ArrayList<>();
         // Traverse in reverse order to make this less error-prone for developers who are removing
         // views directly from their UI.
         for (int i = positions.length - 1; i >= 0; --i) {
@@ -487,14 +569,17 @@ public int getAdjustedCount(final int originalCount) {
      *
      * You must call this method so that the placer knows where valid positions are to place ads.
      * After calling this method, the ad placer will call {@link
-     * MoPubNativeAdLoadedListener#onAdLoaded
-     * (int)} each time an ad is loaded in the stream.
+     * MoPubNativeAdLoadedListener#onAdLoaded (int)} each time an ad is loaded in the stream.
      *
      * @param originalCount The original number of items.
      */
     public void setItemCount(final int originalCount) {
         mItemCount = mPlacementData.getAdjustedCount(originalCount);
-        notifyNeedsPlacement();
+
+        // If we haven't already placed ads, we'll let ads get placed by the normal loadAds call
+        if (mHasPlacedAds) {
+            notifyNeedsPlacement();
+        }
     }
 
     /**
@@ -509,7 +594,7 @@ public void setItemCount(final int originalCount) {
      *
      * and you insert an item at position 2, your new stream will look like:
      *
-     * {@code Item0 Ad Item1 Item2 New Item Ad Item3}
+     * {@code Item0 Ad Item1 Item2 NewItem Ad Item3}
      *
      * @param originalPosition The position at which to add an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
@@ -545,6 +630,14 @@ public void removeItem(final int originalPosition) {
      * Use this method if you are moving an item in your stream and want to have ad positions move
      * as well.
      *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you move item at position 2 to position 3, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3 Item2}
+     *
      * @param originalPosition The position from which to move an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
      * @param newPosition The new position, also expressed in terms of the original position.
@@ -580,8 +673,12 @@ private void placeAds() {
     }
 
     /**
-     * Attempts to place ads in the range (start, end], returning false if there is no ad available
+     * Attempts to place ads in the range [start, end], returning false if there is no ad available
      * to be placed.
+     *
+     * @param start The start of the range in which to place ads, inclusive.
+     * @param end The end of the range in which to place ads, exclusive.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAdsInRange(final int start, final int end) {
         int position = start;
@@ -604,6 +701,9 @@ private boolean tryPlaceAdsInRange(final int start, final int end) {
     /**
      * Attempts to place an ad at the given position, returning false if there is no ad available to
      * be placed.
+     *
+     * @param position The position to place the ad at.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAd(final int position) {
         final NativeResponse adResponse = mAdSource.dequeueAd();
@@ -611,29 +711,45 @@ private boolean tryPlaceAd(final int position) {
             return false;
         }
 
-        final NativeAdData adData = createAdData(position, adResponse);
+        final NativeAdData adData = createAdData(adResponse);
         mPlacementData.placeAd(position, adData);
         mItemCount++;
 
-        if (mAdLoadedListener != null) {
-            mAdLoadedListener.onAdLoaded(position);
-        }
+        mAdLoadedListener.onAdLoaded(position);
         return true;
     }
 
-    private NativeAdData createAdData(final int position, final NativeResponse adResponse) {
+    @NonNull
+    private NativeAdData createAdData(@NonNull final NativeResponse adResponse) {
+        Preconditions.checkNotNull(mAdUnitId);
+        Preconditions.checkNotNull(mAdRenderer);
+
+        //noinspection ConstantConditions
         return new NativeAdData(mAdUnitId, mAdRenderer, adResponse);
     }
 
-    private void clearNativeResponse(final View view) {
+    /**
+     * Clears any native response click trackers and impression tracking are set up for this view.
+     */
+    private void clearNativeResponse(@Nullable final View view) {
+        if (view == null) {
+            return;
+        }
         mImpressionTracker.removeView(view);
         final NativeResponse lastNativeResponse = mNativeResponseMap.get(view);
         if (lastNativeResponse != null) {
             lastNativeResponse.clear(view);
+            mNativeResponseMap.remove(view);
+            mViewMap.remove(lastNativeResponse);
         }
     }
 
-    private void prepareNativeResponse(final NativeResponse nativeResponse, final View view) {
+    /**
+     * Prepares a view and nativeresponse for display by attaching click handlers
+     * and setting up impression tracking.
+     */
+    private void prepareNativeResponse(@NonNull final NativeResponse nativeResponse, @NonNull final View view) {
+        mViewMap.put(nativeResponse, new WeakReference<View>(view));
         mNativeResponseMap.put(view, nativeResponse);
         if (!nativeResponse.isOverridingImpressionTracker()) {
             mImpressionTracker.addView(view, nativeResponse);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
index d4623a35..1f110083 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
@@ -1,29 +1,34 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 /**
  * An object that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer}
  */
 class NativeAdData {
-    private final String adUnitId;
-    private final MoPubAdRenderer adRenderer;
-    private final NativeResponse adResponse;
+    @NonNull private final String adUnitId;
+    @NonNull private final MoPubAdRenderer adRenderer;
+    @NonNull private final NativeResponse adResponse;
 
-    NativeAdData(final String adUnitId,
-            final MoPubAdRenderer adRenderer,
-            final NativeResponse adResponse) {
+    NativeAdData(@NonNull final String adUnitId,
+            @NonNull final MoPubAdRenderer adRenderer,
+            @NonNull final NativeResponse adResponse) {
         this.adUnitId = adUnitId;
         this.adRenderer = adRenderer;
         this.adResponse = adResponse;
     }
 
+    @NonNull
     String getAdUnitId() {
         return adUnitId;
     }
 
+    @NonNull
     MoPubAdRenderer getAdRenderer() {
         return adRenderer;
     }
 
+    @NonNull
     NativeResponse getAd() {
         return adResponse;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
index d748a681..2b52e576 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 import java.util.Map;
@@ -9,32 +11,52 @@
 
 interface NativeAdInterface {
     // Getters
+    @Nullable
     String getMainImageUrl();
+
+    @Nullable
     String getIconImageUrl();
+
+    @Nullable
     String getClickDestinationUrl();
+
+    @Nullable
     String getCallToAction();
+
+    @Nullable
     String getTitle();
+
+    @Nullable
     String getText();
+
+    @Nullable
     Double getStarRating();
 
+    @NonNull
     Set<String> getImpressionTrackers();
+
     int getImpressionMinPercentageViewed();
+
     int getImpressionMinTimeViewed();
 
     boolean isOverridingClickTracker();
+
     boolean isOverridingImpressionTracker();
 
     // Extras Getters
+    @Nullable
     Object getExtra(final String key);
+
+    @NonNull
     Map<String, Object> getExtras();
 
     // Setters
-    void setNativeEventListener(final NativeEventListener nativeEventListener);
+    void setNativeEventListener(@Nullable final NativeEventListener nativeEventListener);
 
     // Event Handlers
-    void prepare(final View view);
+    void prepare(@NonNull final View view);
     void recordImpression();
-    void handleClick(final View view);
-    void clear(final View view);
+    void handleClick(@Nullable final View view);
+    void clear(@NonNull final View view);
     void destroy();
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
index 29d8fda9..6e6a4fd8 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
@@ -3,6 +3,8 @@
 import android.content.Context;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.VisibleForTesting;
 
@@ -34,21 +36,21 @@
     private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
     private static final double EXPONENTIAL_BACKOFF_FACTOR = 2.0;
 
-    private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
-    private final Handler mReplenishCacheHandler;
-    private final Runnable mReplenishCacheRunnable;
-    private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    @NonNull private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
+    @NonNull private final Handler mReplenishCacheHandler;
+    @NonNull private final Runnable mReplenishCacheRunnable;
+    @NonNull private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
 
     @VisibleForTesting boolean mRequestInFlight;
     @VisibleForTesting boolean mRetryInFlight;
     @VisibleForTesting int mSequenceNumber;
     @VisibleForTesting int mRetryTimeMilliseconds;
 
-    private AdSourceListener mAdSourceListener;
+    @Nullable private AdSourceListener mAdSourceListener;
 
     // We will need collections of these when we support multiple ad units.
-    private RequestParameters mRequestParameters;
-    private MoPubNative mMoPubNative;
+    @Nullable private RequestParameters mRequestParameters;
+    @Nullable private MoPubNative mMoPubNative;
 
     /**
      * A listener for when ads are available for dequeueing.
@@ -65,8 +67,8 @@
     }
 
     @VisibleForTesting
-    NativeAdSource(final List<TimestampWrapper<NativeResponse>> nativeAdCache,
-            final Handler replenishCacheHandler) {
+    NativeAdSource(@NonNull final List<TimestampWrapper<NativeResponse>> nativeAdCache,
+            @NonNull final Handler replenishCacheHandler) {
         mNativeAdCache = nativeAdCache;
         mReplenishCacheHandler = replenishCacheHandler;
         mReplenishCacheRunnable = new Runnable() {
@@ -80,7 +82,7 @@ public void run() {
         // Construct native URL and start filling the cache
         mMoPubNativeNetworkListener = new MoPubNativeNetworkListener() {
             @Override
-            public void onNativeLoad(final NativeResponse nativeResponse) {
+            public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
                 // This can be null if the ad source was cleared as the AsyncTask is posting
                 // back to the UI handler. Drop this response.
                 if (mMoPubNative == null) {
@@ -125,12 +127,12 @@ public void onNativeFail(final NativeErrorCode errorCode) {
      * Sets a adSourceListener for determining when ads are available.
      * @param adSourceListener An AdSourceListener.
      */
-    void setAdSourceListener(final AdSourceListener adSourceListener) {
+    void setAdSourceListener(@Nullable final AdSourceListener adSourceListener) {
         mAdSourceListener = adSourceListener;
     }
 
-    void loadAds(final Context context,
-            final String adUnitId,
+    void loadAds(@NonNull final Context context,
+            @NonNull final String adUnitId,
             final RequestParameters requestParameters) {
         loadAds(requestParameters, new MoPubNative(context, adUnitId, mMoPubNativeNetworkListener));
     }
@@ -179,6 +181,7 @@ void clear() {
      *
      * @return Ad ad item that should be rendered into a view.
      */
+    @Nullable
     NativeResponse dequeueAd() {
         final long now = SystemClock.uptimeMillis();
 
@@ -231,6 +234,7 @@ void setMoPubNative(final MoPubNative moPubNative) {
         mMoPubNative = moPubNative;
     }
 
+    @NonNull
     @Deprecated
     @VisibleForTesting
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
index 969d27d6..2f1c838c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -1,23 +1,30 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
-import static android.view.View.GONE;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-
 /**
  * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubNativeAdRenderer} instead
  */
 @Deprecated
 class NativeAdViewHelper {
-    private NativeAdViewHelper() {}
+    private NativeAdViewHelper() {
+    }
+
+    @VisibleForTesting
+    enum ViewType {
+        EMPTY,
+        AD
+    }
 
     // Because the impression tracker requires tracking drawing views,
     // each context requires a separate impression tracker. To avoid leaking, keep weak references.
@@ -31,33 +38,34 @@ private NativeAdViewHelper() {}
             new WeakHashMap<View, NativeResponse>();
 
     @Deprecated
-    static View getAdView(View convertView,
-                          final ViewGroup parent,
-                          final Context context,
-                          final NativeResponse nativeResponse,
-                          final ViewBinder viewBinder,
-                          final MoPubNativeListener moPubNativeListener) {
+    @NonNull
+    static View getAdView(@Nullable View convertView,
+            @Nullable final ViewGroup parent,
+            @NonNull final Context context,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder) {
 
-        if (viewBinder == null) {
-            MoPubLog.d("ViewBinder is null, returning empty view.");
-            return new View(context);
-        }
+        Preconditions.NoThrow.checkNotNull(viewBinder, "ViewBinder is null.");
 
-        final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
-        if (convertView == null) {
-            convertView = moPubNativeAdRenderer.createAdView(context, parent);
+        if (convertView != null) {
+            clearNativeResponse(context, convertView);
         }
 
-        clearNativeResponse(context, convertView);
-
-        if (nativeResponse == null) {
-            // If we don't have content for the view, then hide the view for now
-            MoPubLog.d("NativeResponse is null, returning hidden view.");
-            convertView.setVisibility(GONE);
-        } else if (nativeResponse.isDestroyed()) {
-            MoPubLog.d("NativeResponse is destroyed, returning hidden view.");
-            convertView.setVisibility(GONE);
+        if (nativeResponse == null || nativeResponse.isDestroyed() || viewBinder == null) {
+            MoPubLog.d("nativeResponse or viewBinder null or invalid. Returning empty view");
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.EMPTY.equals(convertView.getTag())) {
+                convertView = new View(context);
+                convertView.setTag(ViewType.EMPTY);
+                convertView.setVisibility(View.GONE);
+            }
         } else {
+            final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.AD.equals(convertView.getTag())) {
+                convertView = moPubNativeAdRenderer.createAdView(context, parent);
+                convertView.setTag(ViewType.AD);
+            }
             prepareNativeResponse(context, convertView, nativeResponse);
             moPubNativeAdRenderer.renderAdView(convertView, nativeResponse);
         }
@@ -65,7 +73,8 @@ static View getAdView(View convertView,
         return convertView;
     }
 
-    private static void clearNativeResponse(final Context context, final View view) {
+    private static void clearNativeResponse(@NonNull final Context context,
+            @NonNull final View view) {
         getImpressionTracker(context).removeView(view);
         final NativeResponse nativeResponse = sNativeResponseMap.get(view);
         if (nativeResponse != null) {
@@ -73,9 +82,9 @@ private static void clearNativeResponse(final Context context, final View view)
         }
     }
 
-    private static void prepareNativeResponse(final Context context,
-            final View view,
-            final NativeResponse nativeResponse) {
+    private static void prepareNativeResponse(@NonNull final Context context,
+            @NonNull final View view,
+            @NonNull final NativeResponse nativeResponse) {
         sNativeResponseMap.put(view, nativeResponse);
         if (!nativeResponse.isOverridingImpressionTracker()) {
             getImpressionTracker(context).addView(view, nativeResponse);
@@ -83,7 +92,7 @@ private static void prepareNativeResponse(final Context context,
         nativeResponse.prepare(view);
     }
 
-    private static ImpressionTracker getImpressionTracker(final Context context) {
+    private static ImpressionTracker getImpressionTracker(@NonNull final Context context) {
         ImpressionTracker impressionTracker = sImpressionTrackerMap.get(context);
         if (impressionTracker == null) {
             impressionTracker = new ImpressionTracker(context);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
index 7999f22f..0dd85382 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 public enum NativeErrorCode {
     EMPTY_AD_RESPONSE("Server returned empty response."),
     INVALID_JSON("Unable to parse JSON response from server."),
@@ -24,6 +26,7 @@ private NativeErrorCode(String message) {
         this.message = message;
     }
 
+    @NonNull
     @Override
     public final String toString() {
         return message;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
index c0eeb9ed..9191d354 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
@@ -1,26 +1,26 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.HttpClient;
-import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
-import java.lang.ref.SoftReference;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -36,8 +36,6 @@
 import static com.mopub.nativeads.NativeResponse.Parameter.STAR_RATING;
 import static com.mopub.nativeads.NativeResponse.Parameter.TEXT;
 import static com.mopub.nativeads.NativeResponse.Parameter.TITLE;
-import static com.mopub.nativeads.UrlResolutionTask.UrlResolutionListener;
-import static com.mopub.nativeads.UrlResolutionTask.getResolvedUrl;
 
 public class NativeResponse {
     enum Parameter {
@@ -54,15 +52,16 @@
         CALL_TO_ACTION("ctatext", false),
         STAR_RATING("starrating", false);
 
-        final String name;
+        @NonNull final String name;
         final boolean required;
 
-        Parameter(final String name, boolean required) {
+        Parameter(@NonNull final String name, boolean required) {
             this.name = name;
             this.required = required;
         }
 
-        static Parameter from(final String name) {
+        @Nullable
+        static Parameter from(@NonNull final String name) {
             for (final Parameter parameter : values()) {
                 if (parameter.name.equals(name)) {
                     return parameter;
@@ -72,6 +71,7 @@ static Parameter from(final String name) {
             return null;
         }
 
+        @NonNull
         @VisibleForTesting
         static final Set<String> requiredKeys = new HashSet<String>();
         static {
@@ -83,24 +83,26 @@ static Parameter from(final String name) {
         }
     }
 
-    private final Context mContext;
-    private MoPubNativeEventListener mMoPubNativeEventListener;
-    private final NativeAdInterface mNativeAd;
+    @NonNull private final Context mContext;
+    @NonNull private final ImageLoader mImageLoader;
+    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
+    @NonNull private final NativeAdInterface mNativeAd;
 
     // Impression and click trackers for the MoPub adserver
-    private final Set<String> mMoPubImpressionTrackers;
-    private final String mMoPubClickTracker;
-    private final String mAdUnitId;
+    @NonNull private final Set<String> mMoPubImpressionTrackers;
+    @NonNull private final String mMoPubClickTracker;
+    @NonNull private final String mAdUnitId;
 
     private boolean mRecordedImpression;
     private boolean mIsClicked;
     private boolean mIsDestroyed;
 
-    public NativeResponse(final Context context,
-            final DownloadResponse downloadResponse,
-            final String adUnitId,
-            final NativeAdInterface nativeAd,
-            final MoPubNativeEventListener moPubNativeEventListener) {
+    public NativeResponse(@NonNull final Context context,
+            @NonNull final String impressionUrl,
+            @NonNull final String clickUrl,
+            @NonNull final String adUnitId,
+            @NonNull final NativeAdInterface nativeAd,
+            @NonNull final MoPubNativeEventListener moPubNativeEventListener) {
         mContext = context.getApplicationContext();
         mAdUnitId = adUnitId;
         mMoPubNativeEventListener = moPubNativeEventListener;
@@ -118,8 +120,9 @@ public void onAdClicked() {
         });
 
         mMoPubImpressionTrackers = new HashSet<String>();
-        mMoPubImpressionTrackers.add(downloadResponse.getFirstHeader(ResponseHeader.IMPRESSION_URL));
-        mMoPubClickTracker = downloadResponse.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL);
+        mMoPubImpressionTrackers.add(impressionUrl);
+        mMoPubClickTracker = clickUrl;
+        mImageLoader = Networking.getImageLoader(context);
     }
 
     @Override
@@ -141,36 +144,44 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+   @NonNull
    public String getAdUnitId() {
        return mAdUnitId;
    }
 
     // Interface Methods
     // Getters
+    @Nullable
     public String getMainImageUrl() {
         return mNativeAd.getMainImageUrl();
     }
 
+    @Nullable
     public String getIconImageUrl() {
         return mNativeAd.getIconImageUrl();
     }
 
+    @Nullable
     public String getClickDestinationUrl() {
         return mNativeAd.getClickDestinationUrl();
     }
 
+    @Nullable
     public String getCallToAction() {
         return mNativeAd.getCallToAction();
     }
 
+    @Nullable
     public String getTitle() {
         return mNativeAd.getTitle();
     }
 
+    @Nullable
     public String getText() {
         return mNativeAd.getText();
     }
 
+    @NonNull
     public List<String> getImpressionTrackers() {
         final Set<String> allImpressionTrackers = new HashSet<String>();
         allImpressionTrackers.addAll(mMoPubImpressionTrackers);
@@ -178,10 +189,12 @@ public String getText() {
         return new ArrayList<String>(allImpressionTrackers);
     }
 
+    @NonNull
     public String getClickTracker() {
         return mMoPubClickTracker;
     }
 
+    @Nullable
     public Double getStarRating() {
         return mNativeAd.getStarRating();
     }
@@ -195,10 +208,12 @@ public int getImpressionMinPercentageViewed() {
     }
 
     // Extras Getters
+    @Nullable
     public Object getExtra(final String key) {
         return mNativeAd.getExtra(key);
     }
 
+    @NonNull
     public Map<String, Object> getExtras() {
         return mNativeAd.getExtras();
     }
@@ -212,7 +227,7 @@ public boolean isOverridingClickTracker() {
     }
 
     // Event Handlers
-    public void prepare(final View view) {
+    public void prepare(@NonNull final View view) {
         if (isDestroyed()) {
             return;
         }
@@ -224,13 +239,14 @@ public void prepare(final View view) {
         mNativeAd.prepare(view);
     }
 
-    public void recordImpression(final View view) {
+    public void recordImpression(@Nullable final View view) {
         if (getRecordedImpression() || isDestroyed()) {
             return;
         }
 
         for (final String impressionTracker : getImpressionTrackers()) {
-            HttpClient.makeTrackingHttpRequest(impressionTracker, mContext);
+            TrackingRequest.makeTrackingHttpRequest(
+                    impressionTracker, mContext, BaseEvent.Name.IMPRESSION_REQUEST);
         }
 
         mNativeAd.recordImpression();
@@ -239,23 +255,32 @@ public void recordImpression(final View view) {
         mMoPubNativeEventListener.onNativeImpression(view);
     }
 
-    public void handleClick(final View view) {
+    public void handleClick(@Nullable final View view) {
+        handleClick(view, new SpinningProgressView(mContext));
+    }
+
+    @VisibleForTesting
+    void handleClick(@Nullable final View view,
+            @NonNull final SpinningProgressView spinningProgressView) {
+        Preconditions.checkNotNull(spinningProgressView);
+
         if (isDestroyed()) {
             return;
         }
 
         if (!isClicked()) {
-            HttpClient.makeTrackingHttpRequest(mMoPubClickTracker, mContext);
+            TrackingRequest.makeTrackingHttpRequest(
+                    mMoPubClickTracker, mContext, BaseEvent.Name.CLICK_REQUEST);
         }
 
-        openClickDestinationUrl(view);
+        openClickDestinationUrl(view, spinningProgressView);
         mNativeAd.handleClick(view);
         mIsClicked = true;
 
         mMoPubNativeEventListener.onNativeClick(view);
     }
 
-    public void clear(final View view) {
+    public void clear(@NonNull final View view) {
         setOnClickListener(view, null);
 
         mNativeAd.clear(view);
@@ -273,11 +298,11 @@ public void destroy() {
     }
 
     // Non Interface Public Methods
-    public void loadMainImage(final ImageView imageView) {
+    public void loadMainImage(@Nullable final ImageView imageView) {
         loadImageView(getMainImageUrl(), imageView);
     }
 
-    public void loadIconImage(final ImageView imageView) {
+    public void loadIconImage(@Nullable final ImageView imageView) {
         loadImageView(getIconImageUrl(), imageView);
     }
 
@@ -301,32 +326,78 @@ public boolean isDestroyed() {
     }
 
     // Helpers
-    private void loadImageView(final String url, final ImageView imageView) {
-        ImageViewService.loadImageView(url, imageView);
+    private void loadImageView(@Nullable final String url, @Nullable final ImageView imageView) {
+        if (imageView == null) {
+            return;
+        }
+
+        if (url == null) {
+            imageView.setImageDrawable(null);
+        } else {
+            mImageLoader.get(url, new ImageLoader.ImageListener() {
+                @Override
+                public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                        final boolean isImmediate) {
+                    if (!isImmediate) {
+                        MoPubLog.d("Image was not loaded immediately into your ad view. You should call preCacheImages as part of your custom event loading process.");
+                    }
+                    imageView.setImageBitmap(imageContainer.getBitmap());
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) {
+                    MoPubLog.d("Failed to load image.", volleyError);
+                    imageView.setImageDrawable(null);
+                }
+            });
+        }
     }
 
-    private void openClickDestinationUrl(final View view) {
+    private void openClickDestinationUrl(@Nullable final View view,
+            @NonNull final SpinningProgressView spinningProgressView) {
+        Preconditions.checkNotNull(spinningProgressView);
+
         if (getClickDestinationUrl() == null) {
             return;
         }
 
-        SpinningProgressView spinningProgressView = null;
         if (view != null) {
-            spinningProgressView = new SpinningProgressView(mContext);
             spinningProgressView.addToRoot(view);
         }
 
-        final Iterator<String> urlIterator = Arrays.asList(getClickDestinationUrl()).iterator();
-        final ClickDestinationUrlResolutionListener urlResolutionListener = new ClickDestinationUrlResolutionListener(
-                mContext,
-                urlIterator,
-                spinningProgressView
-        );
-
-        getResolvedUrl(urlIterator.next(), urlResolutionListener);
-    }
-
-    private void setOnClickListener(final View view, final OnClickListener onClickListener) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        removeSpinningProgressView();
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                        removeSpinningProgressView();
+                    }
+
+                    private void removeSpinningProgressView() {
+                        if (view != null) {
+                            spinningProgressView.removeFromRoot();
+                        }
+                    }
+                })
+                .build().handleUrl(mContext, getClickDestinationUrl());
+    }
+
+    private void setOnClickListener(@NonNull final View view,
+            @Nullable final OnClickListener onClickListener) {
         view.setOnClickListener(onClickListener);
         if ((view instanceof ViewGroup)) {
             ViewGroup viewGroup = (ViewGroup)view;
@@ -335,68 +406,21 @@ private void setOnClickListener(final View view, final OnClickListener onClickLi
         }
     }
 
-    private static class ClickDestinationUrlResolutionListener implements UrlResolutionListener {
-        private final Context mContext;
-        private final Iterator<String> mUrlIterator;
-        private final SoftReference<SpinningProgressView> mSpinningProgressView;
-
-        public ClickDestinationUrlResolutionListener(final Context context,
-                final Iterator<String> urlIterator,
-                final SpinningProgressView spinningProgressView) {
-            mContext = context.getApplicationContext();
-            mUrlIterator = urlIterator;
-            mSpinningProgressView = new SoftReference<SpinningProgressView>(spinningProgressView);
-        }
-
-        @Override
-        public void onSuccess(final String resolvedUrl) {
-            final Intent intent = new Intent(Intent.ACTION_VIEW);
-            intent.setData(Uri.parse(resolvedUrl));
-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-            if (IntentUtils.isDeepLink(resolvedUrl) && IntentUtils.deviceCanHandleIntent(mContext, intent)) {
-                // Open another Android app from deep link
-                mContext.startActivity(intent);
-            } else if (mUrlIterator.hasNext()) {
-                // If we can't handle a deep link then try the fallback url
-                getResolvedUrl(mUrlIterator.next(), this);
-                return;
-            } else {
-                // If we can't open the deep link and there are no backup links
-                // Or the link is a browser link then handle it here
-                MoPubBrowser.open(mContext, resolvedUrl);
-            }
-
-            removeSpinningProgressView();
-        }
-
-        @Override
-        public void onFailure() {
-            MoPubLog.d("Failed to resolve URL for click.");
-            removeSpinningProgressView();
-        }
-
-        private void removeSpinningProgressView() {
-            final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
-            if (spinningProgressView != null) {
-                spinningProgressView.removeFromRoot();
-            }
-        }
-    }
-
     @VisibleForTesting
     class NativeViewClickListener implements OnClickListener {
         @Override
-        public void onClick(final View view) {
+        public void onClick(@NonNull final View view) {
             handleClick(view);
         }
     }
 
+    @Nullable
     @Deprecated
     public String getSubtitle() {
         return mNativeAd.getText();
     }
 
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeEventListener getMoPubNativeEventListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
index 3957024a..bb9e97b1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
@@ -1,30 +1,31 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.location.Location;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
+
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-import com.mopub.common.util.Strings;
+import com.mopub.common.Constants;
 
 class NativeUrlGenerator extends AdUrlGenerator {
-    private String mDesiredAssets;
-    private String mSequenceNumber;
+    @Nullable private String mDesiredAssets;
+    @Nullable private String mSequenceNumber;
 
     NativeUrlGenerator(Context context) {
         super(context);
     }
 
+    @NonNull
     @Override
     public NativeUrlGenerator withAdUnitId(final String adUnitId) {
         mAdUnitId = adUnitId;
         return this;
     }
 
-    NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
+    @NonNull
+    NativeUrlGenerator withRequest(@Nullable final RequestParameters requestParameters) {
         if (requestParameters != null) {
             mKeywords = requestParameters.getKeywords();
             mLocation = requestParameters.getLocation();
@@ -33,6 +34,7 @@ NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
         return this;
     }
 
+    @NonNull
     NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
         mSequenceNumber = String.valueOf(sequenceNumber);
         return this;
@@ -40,49 +42,10 @@ NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
 
     @Override
     public String generateUrlString(final String serverHostname) {
-        initUrlString(serverHostname, Constants.NATIVE_HANDLER);
-
-        setAdUnitId(mAdUnitId);
-
-        setKeywords(mKeywords);
-
-        Location location = mLocation;
-        if (location == null) {
-            location = LocationService.getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-        setLocation(location);
+        initUrlString(serverHostname, Constants.AD_HANDLER);
 
         ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setUdid(clientMetadata.getAdvertisingId());
-
-        setDoNotTrack(clientMetadata.isDoNotTrackSet());
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        String networkOperator = clientMetadata.getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
-
-        setTwitterAppInstalledFlag();
+        addBaseParams(clientMetadata);
 
         setDesiredAssets();
 
@@ -98,7 +61,7 @@ private void setSequenceNumber() {
     }
 
     private void setDesiredAssets() {
-        if (mDesiredAssets != null && !Strings.isEmpty(mDesiredAssets)) {
+        if (!TextUtils.isEmpty(mDesiredAssets)) {
             addParam("assets", mDesiredAssets);
         }
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
index 0ca2dc4a..c6d09ca5 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
@@ -1,53 +1,63 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 class NativeViewHolder {
-    TextView titleView;
-    TextView textView;
-    TextView callToActionView;
-    ImageView mainImageView;
-    ImageView iconImageView;
+    @Nullable View mainView;
+    @Nullable TextView titleView;
+    @Nullable TextView textView;
+    @Nullable TextView callToActionView;
+    @Nullable ImageView mainImageView;
+    @Nullable ImageView iconImageView;
+
+    @VisibleForTesting
+    static final NativeViewHolder EMPTY_VIEW_HOLDER = new NativeViewHolder();
 
     // Use fromViewBinder instead of a constructor
     private NativeViewHolder() {}
 
-    static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBinder) {
+    @NonNull
+    static NativeViewHolder fromViewBinder(@NonNull final View view,
+            @NonNull final ViewBinder viewBinder) {
         final NativeViewHolder nativeViewHolder = new NativeViewHolder();
-
+        nativeViewHolder.mainView = view;
         try {
             nativeViewHolder.titleView = (TextView) view.findViewById(viewBinder.titleId);
             nativeViewHolder.textView = (TextView) view.findViewById(viewBinder.textId);
             nativeViewHolder.callToActionView = (TextView) view.findViewById(viewBinder.callToActionId);
             nativeViewHolder.mainImageView = (ImageView) view.findViewById(viewBinder.mainImageId);
             nativeViewHolder.iconImageView = (ImageView) view.findViewById(viewBinder.iconImageId);
-        } catch (ClassCastException e) {
-            MoPubLog.d("Could not cast View from id in ViewBinder to expected View type", e);
-            return null;
+            return nativeViewHolder;
+        } catch (ClassCastException exception) {
+            MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
+            return EMPTY_VIEW_HOLDER;
         }
-
-        return nativeViewHolder;
     }
 
-    void update(final NativeResponse nativeResponse) {
+    void update(@NonNull final NativeResponse nativeResponse) {
         addTextView(titleView, nativeResponse.getTitle());
         addTextView(textView, nativeResponse.getText());
         addTextView(callToActionView, nativeResponse.getCallToAction());
-
         nativeResponse.loadMainImage(mainImageView);
         nativeResponse.loadIconImage(iconImageView);
     }
 
-    void updateExtras(final View outerView,
-                      final NativeResponse nativeResponse,
-                      final ViewBinder viewBinder) {
+    void updateExtras(@NonNull final NativeResponse nativeResponse,
+                      @NonNull final ViewBinder viewBinder) {
+        if (mainView == null) {
+            MoPubLog.w("Attempted to bind extras on a null main view.");
+            return;
+        }
         for (final String key : viewBinder.extras.keySet()) {
             final int resourceId = viewBinder.extras.get(key);
-            final View view = outerView.findViewById(resourceId);
+            final View view = mainView.findViewById(resourceId);
             final Object content = nativeResponse.getExtra(key);
 
             if (view instanceof ImageView) {
@@ -66,7 +76,7 @@ void updateExtras(final View outerView,
         }
     }
 
-    private void addTextView(final TextView textView, final String contents) {
+    private void addTextView(@Nullable final TextView textView, @Nullable final String contents) {
         if (textView == null) {
             MoPubLog.d("Attempted to add text (" + contents + ") to null TextView.");
             return;
@@ -81,4 +91,10 @@ private void addTextView(final TextView textView, final String contents) {
             textView.setText(contents);
         }
     }
+
+    public void setViewVisibility(final int visibility) {
+        if (mainView != null) {
+            mainView.setVisibility(visibility);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
index cb4e21df..bba220d6 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
@@ -1,5 +1,8 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
@@ -127,24 +130,25 @@
 
     // Initialize all of these to their max capacity. This prevents garbage collection when
     // reallocating the list, which causes noticeable stuttering when scrolling on some devices.
-    private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
-    private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
     private int mDesiredCount = 0;
-    private final int[] mOriginalAdPositions = new int[MAX_ADS];
-    private final int[] mAdjustedAdPositions = new int[MAX_ADS];
-    private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
+    @NonNull private final int[] mOriginalAdPositions = new int[MAX_ADS];
+    @NonNull private final int[] mAdjustedAdPositions = new int[MAX_ADS];
+    @NonNull private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
     private int mPlacedCount = 0;
 
     /**
      * @param desiredInsertionPositions Insertion positions, expressed as original positions
      */
-    private PlacementData(final int[] desiredInsertionPositions) {
+    private PlacementData(@NonNull final int[] desiredInsertionPositions) {
         mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
         System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
         System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
     }
 
-    static PlacementData fromAdPositioning(final MoPubClientPositioning adPositioning) {
+    @NonNull
+    static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
         final List<Integer> fixed = adPositioning.getFixedPositions();
         final int interval = adPositioning.getRepeatingInterval();
 
@@ -168,6 +172,7 @@ static PlacementData fromAdPositioning(final MoPubClientPositioning adPositionin
         return new PlacementData(desiredInsertionPositions);
     }
 
+    @NonNull
     static PlacementData empty() {
         return new PlacementData(new int[] {});
     }
@@ -265,6 +270,7 @@ boolean isPlacedAd(final int position) {
      * Returns the ad data associated with the given ad position, or {@code null} if there is
      * no ad at this position.
      */
+    @Nullable
     NativeAdData getPlacedAd(final int position) {
         final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
         if (index < 0) {
@@ -277,6 +283,7 @@ NativeAdData getPlacedAd(final int position) {
      * Returns all placed ad positions. This method allocates new memory on every invocation. Do
      * not call it from performance critical code.
      */
+    @NonNull
     int[] getPlacedAdPositions() {
         int[] positions = new int[mPlacedCount];
         System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java
new file mode 100644
index 00000000..9446d7a5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java
@@ -0,0 +1,127 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+import com.mopub.volley.toolbox.JsonRequest;
+
+import org.apache.http.HttpStatus;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+
+import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+
+public class PositioningRequest extends JsonRequest<MoPubClientPositioning> {
+    private static final String FIXED_KEY = "fixed";
+    private static final String SECTION_KEY = "section";
+    private static final String POSITION_KEY = "position";
+    private static final String REPEATING_KEY = "repeating";
+    private static final String INTERVAL_KEY = "interval";
+
+    // Max value to avoid bad integer math calculations. This is 2 ^ 16.
+    private static final int MAX_VALUE = 1 << 16;
+
+    public PositioningRequest(final String url,
+            final Response.Listener<MoPubClientPositioning> listener,
+            final Response.ErrorListener errorListener) {
+        super(Method.GET, url, null, listener, errorListener);
+    }
+
+    // This is done just for unit testing visibolity.
+    @Override
+    protected void deliverResponse(final MoPubClientPositioning response) {
+        super.deliverResponse(response);
+    }
+
+    @Override
+    protected Response<MoPubClientPositioning> parseNetworkResponse(final NetworkResponse response) {
+        if (response.statusCode != HttpStatus.SC_OK) {
+            return Response.error(new VolleyError(response));
+        }
+
+        if (response.data.length == 0) {
+            return Response.error(new VolleyError("Empty positioning response", new JSONException("Empty response")));
+        }
+
+        try {
+            String jsonString = new String(response.data,
+                    HttpHeaderParser.parseCharset(response.headers));
+
+            return Response.success(parseJson(jsonString), HttpHeaderParser.parseCacheHeaders(response));
+        } catch (UnsupportedEncodingException e) {
+            return Response.error(new VolleyError("Couldn't parse JSON from Charset", e));
+        } catch (JSONException e) {
+            return Response.error(new VolleyError("JSON Parsing Error", e));
+        } catch (MoPubNetworkError e) {
+            return Response.error(e);
+        }
+    }
+
+    @NonNull
+    @VisibleForTesting
+    MoPubClientPositioning parseJson(@NonNull String jsonString) throws  JSONException, MoPubNetworkError {
+        JSONObject jsonObject = new JSONObject(jsonString);
+
+        // If the server returns an error explicitly, throw an exception with the message.
+        String error = jsonObject.optString("error", null);
+        if (error != null) {
+            if (error.equalsIgnoreCase("WARMING_UP")) {
+                throw new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP);
+            }
+            throw new JSONException(error);
+        }
+
+        // Parse fixed and repeating rules.
+        JSONArray fixed = jsonObject.optJSONArray(FIXED_KEY);
+        JSONObject repeating = jsonObject.optJSONObject(REPEATING_KEY);
+        if (fixed == null && repeating == null) {
+            throw new JSONException("Must contain fixed or repeating positions");
+        }
+
+        MoPubClientPositioning positioning = new MoPubClientPositioning();
+        if (fixed != null) {
+            parseFixedJson(fixed, positioning);
+        }
+        if (repeating != null) {
+            parseRepeatingJson(repeating, positioning);
+        }
+        return positioning;
+    }
+
+    private void parseFixedJson(@NonNull final JSONArray fixed,
+            @NonNull final MoPubClientPositioning positioning) throws JSONException {
+        for (int i = 0; i < fixed.length(); ++i) {
+            JSONObject positionObject = fixed.getJSONObject(i);
+            int section = positionObject.optInt(SECTION_KEY, 0);
+            if (section < 0) {
+                throw new JSONException("Invalid section " + section + " in JSON response");
+            }
+            if (section > 0) {
+                // Ignore sections > 0.
+                continue;
+            }
+            int position = positionObject.getInt(POSITION_KEY);
+            if (position < 0 || position > MAX_VALUE) {
+                throw new JSONException("Invalid position " + position + " in JSON response");
+            }
+            positioning.addFixedPosition(position);
+        }
+    }
+
+    private void parseRepeatingJson(@NonNull final JSONObject repeatingObject,
+            @NonNull final MoPubClientPositioning positioning) throws JSONException {
+        int interval = repeatingObject.getInt(INTERVAL_KEY);
+        if (interval < 2 || interval > MAX_VALUE) {
+            throw new JSONException("Invalid interval " + interval + " in JSON response");
+        }
+        positioning.enableRepeatingPositions(interval);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
index 354ea6df..c26b1e33 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
@@ -1,8 +1,7 @@
 package com.mopub.nativeads;
 
-import android.os.Handler;
+import android.support.annotation.NonNull;
 
-import com.mopub.common.VisibleForTesting;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
 /**
@@ -11,11 +10,11 @@
 interface PositioningSource {
 
     interface PositioningListener {
-        void onLoad(MoPubClientPositioning positioning);
+        void onLoad(@NonNull MoPubClientPositioning positioning);
 
         void onFailed();
     }
 
-    void loadPositions(String adUnitId, PositioningListener listener);
+    void loadPositions(@NonNull String adUnitId, @NonNull PositioningListener listener);
 
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
index e1a1ad6e..f9b0fafb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
@@ -1,27 +1,30 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
 
 class PositioningUrlGenerator extends BaseUrlGenerator {
     private static final String POSITIONING_API_VERSION = "1";
 
-    private final Context mContext;
-    private String mAdUnitId;
+    @NonNull private final Context mContext;
+    @NonNull private String mAdUnitId;
 
-    public PositioningUrlGenerator(Context context) {
+    public PositioningUrlGenerator(@NonNull Context context) {
         mContext = context;
     }
 
-    public PositioningUrlGenerator withAdUnitId(final String adUnitId) {
+    @NonNull
+    public PositioningUrlGenerator withAdUnitId(@NonNull final String adUnitId) {
         mAdUnitId = adUnitId;
         return this;
     }
 
     @Override
-    public String generateUrlString(final String serverHostname) {
+    public String generateUrlString(@NonNull final String serverHostname) {
         initUrlString(serverHostname, Constants.POSITIONING_HANDLER);
 
         setAdUnitId(mAdUnitId);
@@ -36,18 +39,18 @@ public String generateUrlString(final String serverHostname) {
                 clientMetadata.getDeviceModel(),
                 clientMetadata.getDeviceProduct());
 
-        setUdid(clientMetadata.getAdvertisingId());
-
         setAppVersion(clientMetadata.getAppVersion());
 
+        appendAdvertisingInfoTemplates();
+
         return getFinalUrlString();
     }
 
-    private void setAdUnitId(String adUnitId) {
+    private void setAdUnitId(@NonNull String adUnitId) {
         addParam("id", adUnitId);
     }
 
-    private void setSdkVersion(String sdkVersion) {
+    private void setSdkVersion(@NonNull String sdkVersion) {
         addParam("nsv", sdkVersion);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
index fea4fb4c..d6edb69c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
@@ -1,11 +1,13 @@
 package com.mopub.nativeads;
 
 import android.location.Location;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
 import java.util.EnumSet;
 
-public final class RequestParameters {
+public class RequestParameters {
 
     public enum NativeAdAsset {
         TITLE("title"),
@@ -17,56 +19,63 @@
 
         private final String mAssetName;
 
-        private NativeAdAsset(String assetName) {
+        private NativeAdAsset(@NonNull String assetName) {
             mAssetName = assetName;
         }
 
+        @NonNull
         @Override
         public String toString() {
             return mAssetName;
         }
     }
 
-    private final String mKeywords;
-    private final Location mLocation;
-    private final EnumSet<NativeAdAsset> mDesiredAssets;
+    @Nullable private final String mKeywords;
+    @Nullable private final Location mLocation;
+    @Nullable private final EnumSet<NativeAdAsset> mDesiredAssets;
 
     public final static class Builder {
         private String keywords;
         private Location location;
         private EnumSet<NativeAdAsset> desiredAssets;
 
+        @NonNull
         public final Builder keywords(String keywords) {
             this.keywords = keywords;
             return this;
         }
 
+        @NonNull
         public final Builder location(Location location) {
             this.location = location;
             return this;
         }
 
         // Specify set of assets used by this ad request. If not set, this defaults to all assets
+        @NonNull
         public final Builder desiredAssets(final EnumSet<NativeAdAsset> desiredAssets) {
             this.desiredAssets = EnumSet.copyOf(desiredAssets);
             return this;
         }
 
+        @NonNull
         public final RequestParameters build() {
             return new RequestParameters(this);
         }
     }
 
-    private RequestParameters(Builder builder) {
+    private RequestParameters(@NonNull Builder builder) {
         mKeywords = builder.keywords;
         mLocation = builder.location;
         mDesiredAssets = builder.desiredAssets;
     }
 
+    @Nullable
     public final String getKeywords() {
         return mKeywords;
     }
 
+    @Nullable
     public final Location getLocation() {
         return mLocation;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
index 55049bd4..60f49171 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
@@ -2,23 +2,20 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.DownloadTask.DownloadTaskListener;
-import com.mopub.common.HttpClient;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.Preconditions;
+import com.mopub.common.Constants;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
-
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
 
 /**
  * Requests positioning information from the MoPub ad server.
@@ -52,42 +49,27 @@
     private static final double DEFAULT_RETRY_TIME_MILLISECONDS = 1000; // 1 second
     private static final double EXPONENTIAL_BACKOFF_FACTOR = 2;
 
-    @VisibleForTesting
-    static int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
-
-    private static final String FIXED_KEY = "fixed";
-    private static final String SECTION_KEY = "section";
-    private static final String POSITION_KEY = "position";
-    private static final String REPEATING_KEY = "repeating";
-    private static final String INTERVAL_KEY = "interval";
-
-    // Max value to avoid bad integer math calculations. This is 2 ^ 16.
-    private static final int MAX_VALUE = 1 << 16;
+    // We allow the retry limit to be set per-instance for testing, but it is always initialized
+    // to this default.
+    private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
+    private int mMaximumRetryTimeMillis = MAXIMUM_RETRY_TIME_MILLISECONDS;
 
-    private final Context mContext;
-
-    private final DownloadTaskProvider mDownloadTaskProvider;
+    @NonNull private final Context mContext;
 
     // Handler and runnable for retrying after a failed response.
-    private final Handler mRetryHandler;
-    private final Runnable mRetryRunnable;
-
-    // Only exists while a request is in flight.
-    private DownloadTask mDownloadTask;
+    @NonNull private final Handler mRetryHandler;
+    @NonNull private final Runnable mRetryRunnable;
+    private final Response.Listener<MoPubClientPositioning> mPositioningListener;
+    private final Response.ErrorListener mErrorListener;
 
-    private PositioningListener mListener;
+    @Nullable private PositioningListener mListener;
     private int mRetryCount;
-    private String mRetryUrl;
+    @Nullable private String mRetryUrl;
+    @Nullable private PositioningRequest mRequest;
 
-    ServerPositioningSource(final Context context) {
-        this(context, new DownloadTaskProvider());
-    }
-
-    @VisibleForTesting
-    ServerPositioningSource(final Context context,
-            final DownloadTaskProvider downloadTaskProvider) {
+    ServerPositioningSource(@NonNull final Context context) {
         mContext = context.getApplicationContext();
-        mDownloadTaskProvider = downloadTaskProvider;
+
         mRetryHandler = new Handler();
         mRetryRunnable = new Runnable() {
             @Override
@@ -95,14 +77,37 @@ public void run() {
                 requestPositioningInternal();
             }
         };
+
+        mPositioningListener = new Response.Listener<MoPubClientPositioning>() {
+            @Override
+            public void onResponse(final MoPubClientPositioning clientPositioning) {
+                handleSuccess(clientPositioning);
+            }
+        };
+
+        mErrorListener = new Response.ErrorListener() {
+            @Override
+            public void onErrorResponse(final VolleyError error) {
+                // Don't log a stack trace when we're just warming up.
+                if (!(error instanceof MoPubNetworkError) ||
+                        ((MoPubNetworkError) error).getReason().equals(MoPubNetworkError.Reason.WARMING_UP)) {
+                    MoPubLog.e("Failed to load positioning data", error);
+                    if (error.networkResponse == null && !DeviceUtils.isNetworkAvailable(mContext)) {
+                        MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                    }
+                }
+
+                handleFailure();
+            }
+        };
     }
 
     @Override
-    public void loadPositions(String adUnitId, PositioningListener listener) {
+    public void loadPositions(@NonNull String adUnitId, @NonNull PositioningListener listener) {
         // If a request is in flight, remove it.
-        if (mDownloadTask != null) {
-            mDownloadTask.cancel(true);
-            mDownloadTask = null;
+        if (mRequest != null) {
+            mRequest.cancel();
+            mRequest = null;
         }
 
         // If a retry is pending remove it.
@@ -114,55 +119,22 @@ public void loadPositions(String adUnitId, PositioningListener listener) {
         mListener = listener;
         mRetryUrl = new PositioningUrlGenerator(mContext)
                 .withAdUnitId(adUnitId)
-                .generateUrlString(Constants.POSITIONING_HOST);
+                .generateUrlString(Constants.HOST);
         requestPositioningInternal();
     }
 
     private void requestPositioningInternal() {
         MoPubLog.d("Loading positioning from: " + mRetryUrl);
-        mDownloadTask = mDownloadTaskProvider.get(mTaskListener);
-        final HttpGet httpGet = HttpClient.initializeHttpGet(mRetryUrl, mContext);
-        AsyncTasks.safeExecuteOnExecutor(mDownloadTask, httpGet);
-    }
-
-    private DownloadTaskListener mTaskListener = new DownloadTask.DownloadTaskListener() {
-        @Override
-        public void onComplete(final String url, final DownloadResponse downloadResponse) {
-            // Will be null only if cancelled.
-            if (downloadResponse == null) {
-                return;
-            }
-
-            mDownloadTask = null;
-            if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.e("Invalid positioning download response ");
-                handleFailure();
-                return;
-            }
 
-            String responseText = HttpResponses.asResponseString(downloadResponse);
-            MoPubClientPositioning positioning;
-            try {
-                positioning = parseJsonResponse(responseText);
-            } catch (JSONException exception) {
-                MoPubLog.e("Error parsing JSON: ", exception);
-                handleFailure();
-                return;
-            }
-
-            handleSuccess(positioning);
-        }
-    };
-
-    @VisibleForTesting
-    static class DownloadTaskProvider {
-        DownloadTask get(DownloadTaskListener listener) {
-            return new DownloadTask(listener);
-        }
+        mRequest = new PositioningRequest(mRetryUrl, mPositioningListener, mErrorListener);
+        final RequestQueue requestQueue = Networking.getRequestQueue(mContext);
+        requestQueue.add(mRequest);
     }
 
-    private void handleSuccess(MoPubClientPositioning positioning) {
-        mListener.onLoad(positioning);
+    private void handleSuccess(@NonNull MoPubClientPositioning positioning) {
+        if (mListener != null) {
+            mListener.onLoad(positioning);
+        }
         mListener = null;
         mRetryCount = 0;
     }
@@ -170,9 +142,11 @@ private void handleSuccess(MoPubClientPositioning positioning) {
     private void handleFailure() {
         double multiplier = Math.pow(EXPONENTIAL_BACKOFF_FACTOR, mRetryCount + 1);
         int delay = (int) (DEFAULT_RETRY_TIME_MILLISECONDS * multiplier);
-        if (delay >= MAXIMUM_RETRY_TIME_MILLISECONDS) {
+        if (delay >= mMaximumRetryTimeMillis) {
             MoPubLog.d("Error downloading positioning information");
-            mListener.onFailed();
+            if (mListener != null) {
+                mListener.onFailed();
+            }
             mListener = null;
             return;
         }
@@ -181,61 +155,9 @@ private void handleFailure() {
         mRetryHandler.postDelayed(mRetryRunnable, delay);
     }
 
+    @Deprecated
     @VisibleForTesting
-    MoPubClientPositioning parseJsonResponse(String json) throws JSONException {
-        if (json == null || json.equals("")) {
-            throw new JSONException("Empty response");
-        }
-
-        // If the server returns an error explicitly, throw an error with the message.
-        JSONObject jsonObject = new JSONObject(json);
-        String error = jsonObject.optString("error", null);
-        if (error != null) {
-            throw new JSONException(error);
-        }
-
-        // Parse fixed and repeating rules.
-        JSONArray fixed = jsonObject.optJSONArray(FIXED_KEY);
-        JSONObject repeating = jsonObject.optJSONObject(REPEATING_KEY);
-        MoPubClientPositioning positioning = new MoPubClientPositioning();
-        if (fixed == null && repeating == null) {
-            throw new JSONException("Must contain fixed or repeating positions");
-        }
-        if (fixed != null) {
-            parseFixedJson(fixed, positioning);
-        }
-        if (repeating != null) {
-            parseRepeatingJson(repeating, positioning);
-        }
-        return positioning;
-    }
-
-    private void parseFixedJson(final JSONArray fixed,
-            final MoPubClientPositioning positioning) throws JSONException {
-        for (int i = 0; i < fixed.length(); ++i) {
-            JSONObject positionObject = fixed.getJSONObject(i);
-            int section = positionObject.optInt(SECTION_KEY, 0);
-            if (section < 0) {
-                throw new JSONException("Invalid section " + section + " in JSON response");
-            }
-            if (section > 0) {
-                // Ignore sections > 0.
-                continue;
-            }
-            int position = positionObject.getInt(POSITION_KEY);
-            if (position < 0 || position > MAX_VALUE) {
-                throw new JSONException("Invalid position " + position + " in JSON response");
-            }
-            positioning.addFixedPosition(position);
-        }
-    }
-
-    private void parseRepeatingJson(final JSONObject repeatingObject,
-            final MoPubClientPositioning positioning) throws JSONException {
-        int interval = repeatingObject.getInt(INTERVAL_KEY);
-        if (interval < 2 || interval > MAX_VALUE) {
-            throw new JSONException("Invalid interval " + interval + " in JSON response");
-        }
-        positioning.enableRepeatingPositions(interval);
+    void setMaximumRetryTimeMilliseconds(int millis) {
+        mMaximumRetryTimeMillis = millis;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
index 2b442392..9fa5d9ff 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
@@ -2,22 +2,25 @@
 
 import android.content.Context;
 import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.Gravity;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.LinearLayout;
 import android.widget.ProgressBar;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Views;
 
 import static android.widget.RelativeLayout.LayoutParams.MATCH_PARENT;
 
 class SpinningProgressView extends ViewGroup {
-    private final ProgressBar mProgressBar;
+    @NonNull private final ProgressBar mProgressBar;
     private int mProgressIndicatorRadius;
 
-    SpinningProgressView(final Context context) {
+    SpinningProgressView(@NonNull final Context context) {
         super(context);
 
         final LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
@@ -49,10 +52,8 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
 
     }
 
-    boolean addToRoot(final View view) {
-        if (view == null) {
-            return false;
-        }
+    boolean addToRoot(@NonNull final View view) {
+        Preconditions.checkNotNull(view);
 
         final View rootView = view.getRootView();
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
index 443a9875..a13163c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
@@ -1,5 +1,11 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
+
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -8,27 +14,24 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 abstract class TaskManager<T> {
-    protected final TaskManagerListener<T> mImageTaskManagerListener;
+    @NonNull protected final TaskManagerListener<T> mImageTaskManagerListener;
     protected final int mSize;
-    protected final Map<String, T> mResults;
+    @NonNull protected final Map<String, T> mResults;
 
-    protected final AtomicInteger mCompletedCount;
-    protected final AtomicBoolean mFailed;
+    @NonNull protected final AtomicInteger mCompletedCount;
+    @NonNull protected final AtomicBoolean mFailed;
 
     interface TaskManagerListener<T> {
-        void onSuccess(final Map<String, T> images);
+        void onSuccess(@NonNull final Map<String, T> images);
         void onFail();
     }
 
-    TaskManager(final List<String> urls, final TaskManagerListener<T> imageTaskManagerListener)
+    TaskManager(@NonNull final List<String> urls,
+            @NonNull final TaskManagerListener<T> imageTaskManagerListener)
             throws IllegalArgumentException {
-        if (urls == null) {
-            throw new IllegalArgumentException("Urls list cannot be null");
-        } else if (urls.contains(null)) {
-            throw new IllegalArgumentException("Urls list cannot contain null");
-        } else if (imageTaskManagerListener == null) {
-            throw new IllegalArgumentException("ImageTaskManagerListener cannot be null");
-        }
+        Preconditions.checkNotNull(urls, "Urls list cannot be null");
+        Preconditions.checkNotNull(imageTaskManagerListener, "ImageTaskManagerListener cannot be null");
+        Preconditions.checkState(!urls.contains(null), "Urls list cannot contain null");
 
         mSize = urls.size();
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
index 3bed271a..9d4d588b 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 
 class TimestampWrapper<T> {
-    final T mInstance;
+    @NonNull final T mInstance;
     long mCreatedTimestamp;
 
-    TimestampWrapper(final T instance) {
+    TimestampWrapper(@NonNull final T instance) {
         mInstance = instance;
         mCreatedTimestamp = SystemClock.uptimeMillis();
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
index e8309c70..0fe30f84 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
@@ -1,9 +1,12 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
-public final class ViewBinder {
+public class ViewBinder {
     public final static class Builder {
         private final int layoutId;
         private int titleId;
@@ -11,48 +14,56 @@
         private int callToActionId;
         private int mainImageId;
         private int iconImageId;
-        private Map<String, Integer> extras;
+        @NonNull private Map<String, Integer> extras = Collections.emptyMap();
 
         public Builder(final int layoutId) {
             this.layoutId = layoutId;
             this.extras = new HashMap<String, Integer>();
         }
 
+        @NonNull
         public final Builder titleId(final int titleId) {
             this.titleId = titleId;
             return this;
         }
 
+        @NonNull
         public final Builder textId(final int textId) {
             this.textId = textId;
             return this;
         }
 
+        @NonNull
         public final Builder callToActionId(final int callToActionId) {
             this.callToActionId = callToActionId;
             return this;
         }
 
+        @NonNull
         public final Builder mainImageId(final int mainImageId) {
             this.mainImageId = mainImageId;
             return this;
         }
 
+        @NonNull
         public final Builder iconImageId(final int iconImageId) {
             this.iconImageId = iconImageId;
             return this;
         }
 
+        @NonNull
         public final Builder addExtras(final Map<String, Integer> resourceIds) {
             this.extras = new HashMap<String, Integer>(resourceIds);
             return this;
         }
 
+        @NonNull
         public final Builder addExtra(final String key, final int resourceId) {
             this.extras.put(key, resourceId);
             return this;
         }
 
+        @NonNull
         public final ViewBinder build() {
             return new ViewBinder(this);
         }
@@ -64,9 +75,9 @@ public final ViewBinder build() {
     final int callToActionId;
     final int mainImageId;
     final int iconImageId;
-    final Map<String, Integer> extras;
+    @NonNull final Map<String, Integer> extras;
 
-    private ViewBinder(final Builder builder) {
+    private ViewBinder(@NonNull final Builder builder) {
         this.layoutId = builder.layoutId;
         this.titleId = builder.titleId;
         this.textId = builder.textId;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
index 7ff0842a..b98a4481 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
@@ -5,6 +5,8 @@
 import android.graphics.Rect;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewTreeObserver;
 
@@ -33,7 +35,7 @@
     @VisibleForTesting static final int NUM_ACCESSES_BEFORE_TRIMMING = 50;
 
     // Temporary array of trimmed views so that we don't allocate this on every trim.
-    private final ArrayList<View> mTrimmedViews;
+    @NonNull private final ArrayList<View> mTrimmedViews;
 
     // Incrementing access counter. Use a long to support very long-lived apps.
     private long mAccessCounter = 0;
@@ -43,8 +45,8 @@
         void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews);
     }
 
-    @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
-    @VisibleForTesting final WeakReference<View> mRootView;
+    @Nullable @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
+    @NonNull @VisibleForTesting final WeakReference<View> mRootView;
 
     static class TrackingInfo {
         int mMinViewablePercent;
@@ -52,24 +54,24 @@
     }
 
     // Views that are being tracked, mapped to the min viewable percentage
-    private final Map<View, TrackingInfo> mTrackedViews;
+    @NonNull private final Map<View, TrackingInfo> mTrackedViews;
 
     // Object to check actual visibility
-    private final VisibilityChecker mVisibilityChecker;
+    @NonNull private final VisibilityChecker mVisibilityChecker;
 
     // Callback listener
-    private VisibilityTrackerListener mVisibilityTrackerListener;
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
     // Runnable to run on each visibility loop
-    private final VisibilityRunnable mVisibilityRunnable;
+    @NonNull private final VisibilityRunnable mVisibilityRunnable;
 
     // Handler for visibility
-    private final Handler mVisibilityHandler;
+    @NonNull private final Handler mVisibilityHandler;
 
     // Whether the visibility runnable is scheduled
     private boolean mIsVisibilityScheduled;
 
-    public VisibilityTracker(final Context context) {
+    public VisibilityTracker(@NonNull final Context context) {
         this(context,
                 new WeakHashMap<View, TrackingInfo>(10),
                 new VisibilityChecker(),
@@ -77,10 +79,10 @@ public VisibilityTracker(final Context context) {
     }
 
     @VisibleForTesting
-    VisibilityTracker(final Context context,
-            final Map<View, TrackingInfo> trackedViews,
-            final VisibilityChecker visibilityChecker,
-            final Handler visibilityHandler) {
+    VisibilityTracker(@NonNull final Context context,
+            @NonNull final Map<View, TrackingInfo> trackedViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final Handler visibilityHandler) {
         mTrackedViews = trackedViews;
         mVisibilityChecker = visibilityChecker;
         mVisibilityHandler = visibilityHandler;
@@ -105,14 +107,15 @@ public boolean onPreDraw() {
         }
     }
 
-    void setVisibilityTrackerListener(final VisibilityTrackerListener visibilityTrackerListener) {
+    void setVisibilityTrackerListener(
+            @Nullable final VisibilityTrackerListener visibilityTrackerListener) {
         mVisibilityTrackerListener = visibilityTrackerListener;
     }
 
     /**
      * Tracks the given view for visibility.
      */
-    void addView(final View view, final int minPercentageViewed) {
+    void addView(@NonNull final View view, final int minPercentageViewed) {
         // Find the view if already tracked
         TrackingInfo trackingInfo = mTrackedViews.get(view);
         if (trackingInfo == null) {
@@ -147,7 +150,7 @@ private void trimTrackedViews(long minAccessOrder) {
     /**
      * Stops tracking a view, cleaning any pending tracking
      */
-    void removeView(final View view) {
+    void removeView(@NonNull final View view) {
         mTrackedViews.remove(view);
     }
 
@@ -190,8 +193,8 @@ void scheduleVisibilityCheck() {
     class VisibilityRunnable implements Runnable {
         // Set of views that are visible or invisible. We create these once to avoid excessive
         // garbage collection observed when calculating these on each pass.
-        private final ArrayList<View> mVisibleViews;
-        private final ArrayList<View> mInvisibleViews;
+        @NonNull private final ArrayList<View> mVisibleViews;
+        @NonNull private final ArrayList<View> mInvisibleViews;
 
         VisibilityRunnable() {
             mInvisibleViews = new ArrayList<View>();
@@ -236,7 +239,7 @@ boolean hasRequiredTimeElapsed(final long startTimeMillis, final int minTimeView
         /**
          * Whether the view is at least certain % visible
          */
-        boolean isVisible(final View view, final int minPercentageViewed) {
+        boolean isVisible(@Nullable final View view, final int minPercentageViewed) {
             // ListView & GridView both call detachFromParent() for views that can be recycled for
             // new data. This is one of the rare instances where a view will have a null parent for
             // an extended period of time and will not be the main window.
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java b/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
index 019b5338..92fec2e1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
@@ -1,5 +1,9 @@
 package com.mopub.nativeads.factories;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
 import com.mopub.nativeads.CustomEventNative;
 import com.mopub.nativeads.MoPubCustomEventNative;
 
@@ -8,7 +12,7 @@
 public class CustomEventNativeFactory {
     protected static CustomEventNativeFactory instance = new CustomEventNativeFactory();
 
-    public static CustomEventNative create(final String className) throws Exception {
+    public static CustomEventNative create(@Nullable final String className) throws Exception {
         if (className != null) {
             final Class<? extends CustomEventNative> nativeClass = Class.forName(className)
                     .asSubclass(CustomEventNative.class);
@@ -19,11 +23,18 @@ public static CustomEventNative create(final String className) throws Exception
     }
 
     @Deprecated // for testing
-    public static void setInstance(final CustomEventNativeFactory customEventNativeFactory) {
+    public static void setInstance(
+            @NonNull final CustomEventNativeFactory customEventNativeFactory) {
+        Preconditions.checkNotNull(customEventNativeFactory);
+
         instance = customEventNativeFactory;
     }
 
-    protected CustomEventNative internalCreate(final Class<? extends CustomEventNative> nativeClass) throws Exception {
+    @NonNull
+    protected CustomEventNative internalCreate(
+            @NonNull final Class<? extends CustomEventNative> nativeClass) throws Exception {
+        Preconditions.checkNotNull(nativeClass);
+
         final Constructor<?> nativeConstructor = nativeClass.getDeclaredConstructor((Class[]) null);
         nativeConstructor.setAccessible(true);
         return (CustomEventNative) nativeConstructor.newInstance();
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
new file mode 100644
index 00000000..53fdbc30
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
@@ -0,0 +1,296 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.location.Location;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MoPub;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.AdTypeTranslator;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static com.mopub.network.HeaderUtils.extractBooleanHeader;
+import static com.mopub.network.HeaderUtils.extractHeader;
+import static com.mopub.network.HeaderUtils.extractIntegerHeader;
+
+public class AdRequest extends Request<AdResponse> {
+
+    @NonNull private final AdRequest.Listener mListener;
+    @NonNull private final AdFormat mAdFormat;
+    @Nullable private final String mAdUnitId;
+    @NonNull private final Context mContext;
+
+    public interface Listener extends Response.ErrorListener {
+        public void onSuccess(AdResponse response);
+    }
+
+    public AdRequest(@NonNull final String url,
+            @NonNull final AdFormat adFormat,
+            @Nullable final String adUnitId,
+            @NonNull Context context,
+            @NonNull final Listener listener) {
+        super(Method.GET, url, listener);
+        Preconditions.checkNotNull(adFormat);
+        Preconditions.checkNotNull(listener);
+        mAdUnitId = adUnitId;
+        mListener = listener;
+        mAdFormat = adFormat;
+        mContext = context.getApplicationContext();
+        DefaultRetryPolicy retryPolicy = new DefaultRetryPolicy(
+                DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
+                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
+                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
+        setRetryPolicy(retryPolicy);
+        setShouldCache(false);
+    }
+
+    @NonNull
+    public Listener getListener() {
+        return mListener;
+    }
+
+    @Override
+    public Map<String, String> getHeaders() {
+        TreeMap<String, String> headers = new TreeMap<String, String>();
+
+        // Use default locale first for language code
+        String languageCode = Locale.getDefault().getLanguage();
+
+        // If user's preferred locale is different from default locale, override language code
+        Locale userLocale = mContext.getResources().getConfiguration().locale;
+        if (userLocale != null) {
+            if (! userLocale.getLanguage().trim().isEmpty()) {
+                languageCode = userLocale.getLanguage().trim();
+            }
+        }
+
+        // Do not add header if language is empty
+        if (! languageCode.isEmpty()) {
+            headers.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), languageCode);
+        }
+
+        return headers;
+    }
+
+    @Override
+    protected Response<AdResponse> parseNetworkResponse(final NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+
+        Map<String, String> headers = networkResponse.headers;
+        if (extractBooleanHeader(headers, ResponseHeader.WARMUP, false)) {
+            return Response.error(new MoPubNetworkError("Ad Unit is warming up.", MoPubNetworkError.Reason.WARMING_UP));
+        }
+
+
+        Location location = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
+
+        AdResponse.Builder builder = new AdResponse.Builder();
+        builder.setAdUnitId(mAdUnitId);
+
+        String adTypeString = extractHeader(headers, ResponseHeader.AD_TYPE);
+        String fullAdTypeString = extractHeader(headers, ResponseHeader.FULL_AD_TYPE);
+        builder.setAdType(adTypeString);
+        builder.setFullAdType(fullAdTypeString);
+
+        // In the case of a CLEAR response, the REFRESH_TIME header must still be respected. Ensure
+        // that it is parsed and passed along to the MoPubNetworkError.
+        final Integer refreshTimeSeconds = extractIntegerHeader(headers, ResponseHeader.REFRESH_TIME);
+        final Integer refreshTimeMilliseconds = refreshTimeSeconds == null
+                ? null
+                : refreshTimeSeconds * 1000;
+        builder.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+
+        if (AdType.CLEAR.equals(adTypeString)) {
+            final AdResponse adResponse = builder.build();
+            logScribeEvent(adResponse, networkResponse, location);
+            return Response.error(
+                    new MoPubNetworkError(
+                            "No ads found for ad unit.",
+                            MoPubNetworkError.Reason.NO_FILL,
+                            refreshTimeMilliseconds
+                    )
+            );
+        }
+
+        builder.setNetworkType(extractHeader(headers, ResponseHeader.NETWORK_TYPE));
+
+        String redirectUrl = extractHeader(headers, ResponseHeader.REDIRECT_URL);
+        builder.setRedirectUrl(redirectUrl);
+
+        String clickTrackingUrl = extractHeader(headers, ResponseHeader.CLICK_TRACKING_URL);
+        builder.setClickTrackingUrl(clickTrackingUrl);
+
+        builder.setImpressionTrackingUrl(extractHeader(headers, ResponseHeader.IMPRESSION_URL));
+
+        String failUrl = extractHeader(headers, ResponseHeader.FAIL_URL);
+        builder.setFailoverUrl(failUrl);
+
+        String requestId = getRequestId(failUrl);
+        builder.setRequestId(requestId);
+
+        boolean isScrollable = extractBooleanHeader(headers, ResponseHeader.SCROLLABLE, false);
+        builder.setScrollable(isScrollable);
+
+        builder.setDimensions(extractIntegerHeader(headers, ResponseHeader.WIDTH),
+                extractIntegerHeader(headers, ResponseHeader.HEIGHT));
+
+        Integer adTimeoutDelaySeconds = extractIntegerHeader(headers, ResponseHeader.AD_TIMEOUT);
+        builder.setAdTimeoutDelayMilliseconds(
+                adTimeoutDelaySeconds == null
+                        ? null
+                        : adTimeoutDelaySeconds * 1000);
+
+        // Response Body encoding / decoding
+        String responseBody = parseStringBody(networkResponse);
+        builder.setResponseBody(responseBody);
+        if (AdType.NATIVE.equals(adTypeString)) {
+            try {
+                builder.setJsonBody(new JSONObject(responseBody));
+            } catch (JSONException e) {
+                return Response.error(
+                        new MoPubNetworkError("Failed to decode body JSON for native ad format",
+                                e, MoPubNetworkError.Reason.BAD_BODY));
+            }
+        }
+
+        // Derive custom event fields
+        String customEventClassName = AdTypeTranslator.getCustomEventName(mAdFormat, adTypeString,
+                fullAdTypeString, headers);
+        builder.setCustomEventClassName(customEventClassName);
+
+        // Process server extras if they are present:
+        String customEventData = extractHeader(headers, ResponseHeader.CUSTOM_EVENT_DATA);
+
+        // Some server-supported custom events (like Millennial banners) use a different header field
+        if (TextUtils.isEmpty(customEventData)) {
+            customEventData = extractHeader(headers, ResponseHeader.NATIVE_PARAMS);
+        }
+        try {
+            builder.setServerExtras(Json.jsonStringToMap(customEventData));
+        } catch (JSONException e) {
+            return Response.error(
+                    new MoPubNetworkError("Failed to decode server extras for custom event data.",
+                            e, MoPubNetworkError.Reason.BAD_HEADER_DATA));
+        }
+
+        // Some MoPub-specific custom events get their serverExtras from the response itself:
+        if (eventDataIsInResponseBody(adTypeString, fullAdTypeString)) {
+            Map<String, String> eventDataMap = new TreeMap<String, String>();
+            eventDataMap.put(DataKeys.HTML_RESPONSE_BODY_KEY, responseBody);
+            eventDataMap.put(DataKeys.SCROLLABLE_KEY, Boolean.toString(isScrollable));
+            eventDataMap.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
+            if (redirectUrl != null) {
+                eventDataMap.put(DataKeys.REDIRECT_URL_KEY, redirectUrl);
+            }
+            if (clickTrackingUrl != null) {
+                eventDataMap.put(DataKeys.CLICKTHROUGH_URL_KEY, clickTrackingUrl);
+            }
+            builder.setServerExtras(eventDataMap);
+        }
+
+        AdResponse adResponse = builder.build();
+        logScribeEvent(adResponse, networkResponse, location);
+
+        return Response.success(builder.build(),  // Cast needed for Response generic.
+                HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    private boolean eventDataIsInResponseBody(@Nullable String adType,
+            @Nullable String fullAdType) {
+        return "mraid".equals(adType) || "html".equals(adType) ||
+                ("interstitial".equals(adType) && "vast".equals(fullAdType));
+    }
+
+    // Based on Volley's StringResponse class.
+    protected String parseStringBody(NetworkResponse response) {
+        String parsed;
+        try {
+            parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));
+        } catch (UnsupportedEncodingException e) {
+            parsed = new String(response.data);
+        }
+        return parsed;
+    }
+
+    @Override
+    protected void deliverResponse(final AdResponse adResponse) {
+        mListener.onSuccess(adResponse);
+    }
+
+    @Nullable
+    @VisibleForTesting
+    String getRequestId(@Nullable String failUrl) {
+        if (failUrl == null) {
+            return null;
+        }
+
+        String requestId = null;
+        Uri uri = Uri.parse(failUrl);
+        try {
+            requestId = uri.getQueryParameter("request_id");
+        } catch (UnsupportedOperationException e) {
+            MoPubLog.d("Unable to obtain request id from fail url.");
+        }
+
+        return requestId;
+    }
+
+    @VisibleForTesting
+    void logScribeEvent(@NonNull AdResponse adResponse, @NonNull NetworkResponse networkResponse,
+            @Nullable Location location) {
+        Preconditions.checkNotNull(adResponse);
+        Preconditions.checkNotNull(networkResponse);
+
+        MoPubEvents.log(
+                new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS,
+                        BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate())
+                        .withAdUnitId(mAdUnitId)
+                        .withAdCreativeId(adResponse.getDspCreativeId())
+                        .withAdType(adResponse.getAdType())
+                        .withAdNetworkType(adResponse.getNetworkType())
+                        .withAdWidthPx(adResponse.getWidth() != null
+                                ? adResponse.getWidth().doubleValue()
+                                : null)
+                        .withAdHeightPx(adResponse.getHeight() != null
+                                ? adResponse.getHeight().doubleValue()
+                                : null)
+                        .withGeoLat(location != null ? location.getLatitude() : null)
+                        .withGeoLon(location != null ? location.getLongitude() : null)
+                        .withGeoAccuracy(location != null ? (double) location.getAccuracy() : null)
+                        .withPerformanceDurationMs((double) networkResponse.networkTimeMs)
+                        .withRequestId(adResponse.getRequestId())
+                        .withRequestStatusCode(networkResponse.statusCode)
+                        .withRequestUri(getUrl())
+                        .build()
+        );
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
new file mode 100644
index 00000000..8c7bc330
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
@@ -0,0 +1,336 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.DateAndTime;
+
+import org.json.JSONObject;
+
+import java.io.Serializable;
+import java.util.Map;
+import java.util.TreeMap;
+
+public class AdResponse implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    @Nullable
+    private final String mAdType;
+
+    @Nullable
+    private final String mAdUnitId;
+
+    @Nullable
+    private final String mFullAdType;
+    @Nullable
+    private final String mNetworkType;
+
+    @Nullable
+    private final String mRedirectUrl;
+    @Nullable
+    private final String mClickTrackingUrl;
+    @Nullable
+    private final String mImpressionTrackingUrl;
+    @Nullable
+    private final String mFailoverUrl;
+    @Nullable
+    private final String mRequestId;
+
+    @Nullable
+    private final Integer mWidth;
+    @Nullable
+    private final Integer mHeight;
+    @Nullable
+    private final Integer mAdTimeoutDelayMillis;
+    @Nullable
+    private final Integer mRefreshTimeMillis;
+    @Nullable
+    private final String mDspCreativeId;
+
+    private final boolean mScrollable;
+
+    @Nullable
+    private final String mResponseBody;
+    @Nullable
+    private final JSONObject mJsonBody;
+
+    @Nullable
+    private final String mCustomEventClassName;
+    @NonNull
+    private final Map<String, String> mServerExtras;
+
+    private final long mTimestamp;
+
+    private AdResponse(@NonNull Builder builder) {
+
+        mAdType = builder.adType;
+        mAdUnitId = builder.adUnitId;
+        mFullAdType = builder.fullAdType;
+        mNetworkType = builder.networkType;
+        mRedirectUrl = builder.redirectUrl;
+        mClickTrackingUrl = builder.clickTrackingUrl;
+        mImpressionTrackingUrl = builder.impressionTrackingUrl;
+        mFailoverUrl = builder.failoverUrl;
+        mRequestId = builder.requestId;
+        mWidth = builder.width;
+        mHeight = builder.height;
+        mAdTimeoutDelayMillis = builder.adTimeoutDelayMillis;
+        mRefreshTimeMillis = builder.refreshTimeMillis;
+        mDspCreativeId = builder.dspCreativeId;
+        mScrollable = builder.scrollable;
+        mResponseBody = builder.responseBody;
+        mJsonBody = builder.jsonBody;
+        mCustomEventClassName = builder.customEventClassName;
+        mServerExtras = builder.serverExtras;
+        mTimestamp = DateAndTime.now().getTime();
+    }
+
+    public boolean hasJson() {
+        return mJsonBody != null;
+    }
+
+    @Nullable
+    public JSONObject getJsonBody() {
+        return mJsonBody;
+    }
+
+    @Nullable
+    public String getStringBody() {
+        return mResponseBody;
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mAdType;
+    }
+
+    @Nullable
+    public String getFullAdType() {
+        return mFullAdType;
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    @Nullable
+    public String getNetworkType() {
+        return mNetworkType;
+    }
+
+    @Nullable
+    public String getRedirectUrl() {
+        return mRedirectUrl;
+    }
+
+    @Nullable
+    public String getClickTrackingUrl() {
+        return mClickTrackingUrl;
+    }
+
+    @Nullable
+    public String getImpressionTrackingUrl() {
+        return mImpressionTrackingUrl;
+    }
+
+    @Nullable
+    public String getFailoverUrl() {
+        return mFailoverUrl;
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
+    public boolean isScrollable() {
+        return mScrollable;
+    }
+
+    @Nullable
+    public Integer getWidth() {
+        return mWidth;
+    }
+
+    @Nullable
+    public Integer getHeight() {
+        return mHeight;
+    }
+
+    @Nullable
+    public Integer getAdTimeoutMillis() {
+        return mAdTimeoutDelayMillis;
+    }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+
+    @Nullable
+    public String getDspCreativeId() {
+        return mDspCreativeId;
+    }
+
+    @Nullable
+    public String getCustomEventClassName() {
+        return mCustomEventClassName;
+    }
+
+    @NonNull
+    public Map<String, String> getServerExtras() {
+        // Strings are immutable, so this works as a "deep" copy.
+        return new TreeMap<String, String>(mServerExtras);
+    }
+
+    public long getTimestamp() {
+        return mTimestamp;
+    }
+
+    public Builder toBuilder() {
+        return new Builder()
+                .setAdType(mAdType)
+                .setNetworkType(mNetworkType)
+                .setRedirectUrl(mRedirectUrl)
+                .setClickTrackingUrl(mClickTrackingUrl)
+                .setImpressionTrackingUrl(mImpressionTrackingUrl)
+                .setFailoverUrl(mFailoverUrl)
+                .setDimensions(mWidth, mHeight)
+                .setAdTimeoutDelayMilliseconds(mAdTimeoutDelayMillis)
+                .setRefreshTimeMilliseconds(mRefreshTimeMillis)
+                .setDspCreativeId(mDspCreativeId)
+                .setScrollable(mScrollable)
+                .setResponseBody(mResponseBody)
+                .setJsonBody(mJsonBody)
+                .setCustomEventClassName(mCustomEventClassName)
+                .setServerExtras(mServerExtras);
+    }
+
+    public static class Builder {
+        private String adType;
+        private String adUnitId;
+        private String fullAdType;
+        private String networkType;
+
+        private String redirectUrl;
+        private String clickTrackingUrl;
+        private String impressionTrackingUrl;
+        private String failoverUrl;
+        private String requestId;
+
+        private Integer width;
+        private Integer height;
+        private Integer adTimeoutDelayMillis;
+        private Integer refreshTimeMillis;
+        private String dspCreativeId;
+
+        private boolean scrollable = false;
+
+        private String responseBody;
+        private JSONObject jsonBody;
+
+        private String customEventClassName;
+        private Map<String, String> serverExtras = new TreeMap<String, String>();
+
+        public Builder setAdType(@Nullable final String adType) {
+            this.adType = adType;
+            return this;
+        }
+
+        public Builder setAdUnitId(@Nullable final String adUnitId) {
+            this.adUnitId = adUnitId;
+            return this;
+        }
+
+        public Builder setFullAdType(@Nullable final String fullAdType) {
+            this.fullAdType = fullAdType;
+            return this;
+        }
+
+        public Builder setNetworkType(@Nullable final String networkType) {
+            this.networkType = networkType;
+            return this;
+        }
+
+        public Builder setRedirectUrl(@Nullable final String redirectUrl) {
+            this.redirectUrl = redirectUrl;
+            return this;
+        }
+
+        public Builder setClickTrackingUrl(@Nullable final String clickTrackingUrl) {
+            this.clickTrackingUrl = clickTrackingUrl;
+            return this;
+        }
+
+        public Builder setImpressionTrackingUrl(@Nullable final String impressionTrackingUrl) {
+            this.impressionTrackingUrl = impressionTrackingUrl;
+            return this;
+        }
+
+        public Builder setFailoverUrl(@Nullable final String failoverUrl) {
+            this.failoverUrl = failoverUrl;
+            return this;
+        }
+
+        public Builder setRequestId(@Nullable final String requestId) {
+            this.requestId = requestId;
+            return this;
+        }
+
+        public Builder setDimensions(@Nullable final Integer width,
+                @Nullable final Integer height) {
+            this.width = width;
+            this.height = height;
+            return this;
+        }
+
+        public Builder setAdTimeoutDelayMilliseconds(@Nullable final Integer adTimeoutDelayMilliseconds) {
+            this.adTimeoutDelayMillis = adTimeoutDelayMilliseconds;
+            return this;
+        }
+
+        public Builder setRefreshTimeMilliseconds(@Nullable final Integer refreshTimeMilliseconds) {
+            this.refreshTimeMillis = refreshTimeMilliseconds;
+            return this;
+        }
+
+        public Builder setScrollable(@Nullable final Boolean scrollable) {
+            this.scrollable = scrollable == null ? this.scrollable : scrollable;
+            return this;
+        }
+
+        public Builder setDspCreativeId(@Nullable final String dspCreativeId) {
+            this.dspCreativeId = dspCreativeId;
+            return this;
+        }
+
+        public Builder setResponseBody(@Nullable final String responseBody) {
+            this.responseBody = responseBody;
+            return this;
+        }
+
+        public Builder setJsonBody(@Nullable final JSONObject jsonBody) {
+            this.jsonBody = jsonBody;
+            return this;
+        }
+
+        public Builder setCustomEventClassName(@Nullable final String customEventClassName) {
+            this.customEventClassName = customEventClassName;
+            return this;
+        }
+
+        public Builder setServerExtras(@Nullable final Map<String, String> serverExtras) {
+            if (serverExtras == null) {
+                this.serverExtras = new TreeMap<String, String>();
+            } else {
+                this.serverExtras = new TreeMap<String, String>(serverExtras);
+            }
+            return this;
+        }
+
+        public AdResponse build() {
+            return new AdResponse(this);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
new file mode 100644
index 00000000..fa17fee8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
@@ -0,0 +1,43 @@
+package com.mopub.network;
+
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for a request.
+ */
+public abstract class BackoffPolicy {
+    protected int mBackoffMs;
+    protected int mBackoffMultiplier;
+    protected int mDefaultBackoffTimeMs;
+    protected int mMaxBackoffTimeMs;
+    protected int mRetryCount;
+    protected int mMaxRetries;
+
+    /**
+     * Prepares for the next request attempt by updating the backoff time.
+     *
+     * @param volleyError The error code of the last request attempt.
+     */
+    public abstract void backoff(VolleyError volleyError) throws VolleyError;
+
+    /**
+     * Returns the current backoff time in ms.
+     */
+    public int getBackoffMs() {
+        return mBackoffMs;
+    }
+
+    /**
+     * Returns the current retry count.
+     */
+    public int getRetryCount() {
+        return mRetryCount;
+    }
+
+    /**
+     * Returns true if this policy has attempts remaining, false otherwise.
+     */
+    public boolean hasAttemptRemaining() {
+        return mRetryCount < mMaxRetries;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
new file mode 100644
index 00000000..21c48ac1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
@@ -0,0 +1,95 @@
+package com.mopub.network;
+
+import android.net.SSLCertificateSocketFactory;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An {@link javax.net.ssl.SSLSocketFactory} that supports TLS settings for the MoPub ad servers.
+ */
+public class CustomSSLSocketFactory extends SSLSocketFactory {
+
+    private SSLSocketFactory mCertificateSocketFactory;
+
+    private CustomSSLSocketFactory() {}
+
+    public static CustomSSLSocketFactory getDefault(final int handshakeTimeoutMillis) {
+        CustomSSLSocketFactory factory = new CustomSSLSocketFactory();
+        factory.mCertificateSocketFactory = SSLCertificateSocketFactory.getDefault(handshakeTimeoutMillis, null);
+
+        return factory;
+    }
+
+    // Forward all methods. Enable TLS 1.1 and 1.2 before returning.
+
+    // SocketFactory overrides
+    @Override
+    public Socket createSocket() throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket();
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int i) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, i);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int port, final InetAddress localhost, final int localPort) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port, final InetAddress localhost, final int localPort) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    // SSLSocketFactory overrides
+
+    @Override
+    public String[] getDefaultCipherSuites() {
+        return mCertificateSocketFactory.getDefaultCipherSuites();
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return mCertificateSocketFactory.getSupportedCipherSuites();
+    }
+
+    @Override
+    public Socket createSocket(final Socket socketParam, final String host, final int port, final boolean autoClose) throws IOException {
+        Socket socket = mCertificateSocketFactory.createSocket(socketParam, host, port, autoClose);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    private void enableTlsIfAvailable(Socket socket) {
+        if (socket instanceof SSLSocket) {
+            SSLSocket sslSocket = (SSLSocket) socket;
+            String[] supportedProtocols = sslSocket.getSupportedProtocols();
+            // Make sure all supported protocols are enabled. Android does not enable TLSv1.1 or
+            // TLSv1.2 by default.
+            sslSocket.setEnabledProtocols(supportedProtocols);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpResponses.java b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
similarity index 55%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpResponses.java
rename to mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
index 3167787d..27eb863f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpResponses.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
@@ -1,4 +1,6 @@
-package com.mopub.mobileads.util;
+package com.mopub.network;
+
+import android.support.annotation.Nullable;
 
 import com.mopub.common.util.ResponseHeader;
 
@@ -7,32 +9,34 @@
 
 import java.text.NumberFormat;
 import java.util.Locale;
+import java.util.Map;
+
+public class HeaderUtils {
+    @Nullable
+    public static String extractHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return headers.get(responseHeader.getKey());
+    }
+
+    public static Integer extractIntegerHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return formatIntHeader(extractHeader(headers, responseHeader));
+    }
+
+    public static boolean extractBooleanHeader(Map<String, String> headers, ResponseHeader responseHeader, boolean defaultValue) {
+        return formatBooleanHeader(extractHeader(headers, responseHeader), defaultValue);
+    }
 
-public class HttpResponses {
     public static String extractHeader(HttpResponse response, ResponseHeader responseHeader) {
         Header header = response.getFirstHeader(responseHeader.getKey());
         return header != null ? header.getValue() : null;
     }
 
     public static boolean extractBooleanHeader(HttpResponse response, ResponseHeader responseHeader, boolean defaultValue) {
-        String header = extractHeader(response, responseHeader);
-        if (header == null) {
-            return defaultValue;
-        }
-        return header.equals("1");
+        return formatBooleanHeader(extractHeader(response, responseHeader), defaultValue);
     }
 
     public static Integer extractIntegerHeader(HttpResponse response, ResponseHeader responseHeader) {
-        NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
-        numberFormat.setParseIntegerOnly(true);
-
         String headerValue = extractHeader(response, responseHeader);
-        try {
-            Number value = numberFormat.parse(headerValue.trim());
-            return value.intValue();
-        } catch (Exception e) {
-            return null;
-        }
+        return formatIntHeader(headerValue);
     }
 
     public static int extractIntHeader(HttpResponse response, ResponseHeader responseHeader, int defaultValue) {
@@ -43,4 +47,23 @@ public static int extractIntHeader(HttpResponse response, ResponseHeader respons
 
         return headerValue;
     }
+
+    private static boolean formatBooleanHeader(@Nullable String headerValue, boolean defaultValue) {
+        if (headerValue == null) {
+            return defaultValue;
+        }
+        return headerValue.equals("1");
+    }
+
+    private static Integer formatIntHeader(String headerValue) {
+        NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
+        numberFormat.setParseIntegerOnly(true);
+
+        try {
+            Number value = numberFormat.parse(headerValue.trim());
+            return value.intValue();
+        } catch (Exception e) {
+            return null;
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java b/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java
new file mode 100644
index 00000000..6927dd96
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java
@@ -0,0 +1,38 @@
+package com.mopub.network;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Point;
+import android.os.Build;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.volley.RequestQueue;
+
+public class MaxWidthImageLoader extends com.mopub.volley.toolbox.ImageLoader {
+    private final int mMaxImageWidth;
+
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    public MaxWidthImageLoader(final RequestQueue queue, final Context context, final ImageCache imageCache) {
+        super(queue, imageCache);
+
+        // Get Display Options
+        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        Point size = new Point();
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB_MR2) {
+            size.set(display.getWidth(), display.getHeight());
+        } else {
+            display.getSize(size);
+        }
+
+        // Make our images no wider than the skinny side of the display.
+        mMaxImageWidth = Math.min(size.x, size.y);
+    }
+
+    @Override
+    public ImageContainer get(final String requestUrl, final ImageListener listener) {
+        return super.get(requestUrl, listener, mMaxImageWidth, 0 /* no height limit */);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
new file mode 100644
index 00000000..43becf67
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
@@ -0,0 +1,66 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.VolleyError;
+
+public class MoPubNetworkError extends VolleyError {
+    public enum Reason {
+        WARMING_UP,
+        NO_FILL,
+        BAD_HEADER_DATA,
+        BAD_BODY,
+        TRACKING_FAILURE,
+        UNSPECIFIED
+    }
+
+    @NonNull private final Reason mReason;
+    @Nullable private final Integer mRefreshTimeMillis;
+
+    public MoPubNetworkError(@NonNull Reason reason) {
+        super();
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull NetworkResponse networkResponse, @NonNull Reason reason) {
+        super(networkResponse);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull Throwable cause, @NonNull Reason reason) {
+        super(cause);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason) {
+        this(message, reason, null);
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Throwable cause, @NonNull Reason reason) {
+        super(message, cause);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason,
+            @Nullable Integer refreshTimeMillis) {
+        super(message);
+        mReason = reason;
+        mRefreshTimeMillis = refreshTimeMillis;
+    }
+
+    @NonNull
+    public Reason getReason() {
+        return mReason;
+    }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
new file mode 100644
index 00000000..9b5d4592
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
@@ -0,0 +1,166 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.ResponseDelivery;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * MoPub's custom implementation of the Google Volley RequestQueue.
+ * This subclass provides convenience methods for adding a delayed request to run at a time in
+ * the future. This is useful for our backoff policy architecture.
+ *
+ * We've overridden certain implementation methods but have kept the contract of the
+ * original method consistent.
+ */
+public class MoPubRequestQueue extends RequestQueue {
+
+    private static final int CAPACITY = 10;
+
+    @NonNull
+    private final Map<Request<?>, DelayedRequestHelper> mDelayedRequests;
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) {
+        super(cache, network, threadPoolSize, delivery);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize) {
+        super(cache, network, threadPoolSize);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network) {
+        super(cache, network);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    /**
+     * Convenience method for adding a request with a time delay to the request queue.
+     *
+     * @param request The request.
+     * @param delayMs The delay in ms for adding the request to the request queue.
+     */
+    public void addDelayedRequest(@NonNull Request<?> request, int delayMs) {
+        Preconditions.checkNotNull(request);
+        addDelayedRequest(request, new DelayedRequestHelper(request, delayMs));
+    }
+
+    @VisibleForTesting
+    void addDelayedRequest(@NonNull Request<?> request, @NonNull DelayedRequestHelper delayedRequestHelper) {
+        Preconditions.checkNotNull(delayedRequestHelper);
+
+        if (mDelayedRequests.containsKey(request)) {
+            cancel(request);
+        }
+
+        delayedRequestHelper.start();
+        mDelayedRequests.put(request, delayedRequestHelper);
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull RequestFilter filter) {
+        Preconditions.checkNotNull(filter);
+
+        super.cancelAll(filter);
+
+        Iterator<Map.Entry<Request<?>, DelayedRequestHelper>> iterator = mDelayedRequests.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<Request<?>, DelayedRequestHelper> entry = iterator.next();
+            if (filter.apply(entry.getKey())) {
+                // Here we cancel both the request and the handler from posting the delayed runnable
+                entry.getKey().cancel();
+                entry.getValue().cancel();
+                iterator.remove();
+            }
+        }
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull final Object tag) {
+        Preconditions.checkNotNull(tag);
+
+        super.cancelAll(tag);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request.getTag() == tag;
+            }
+        });
+    }
+
+    /**
+     * Convenience method to cancel a single request.
+     *
+     * @param request The request to cancel.
+     */
+    public void cancel(@NonNull final Request<?> request) {
+        Preconditions.checkNotNull(request);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> _request) {
+                return request == _request;
+            }
+        });
+    }
+
+    /**
+     * This helper class is used to package the supporting objects a request needs to
+     * run at a delayed time and cancel if needed.
+     */
+    class DelayedRequestHelper {
+        final int mDelayMs;
+        @NonNull final Handler mHandler;
+        @NonNull final Runnable mDelayedRunnable;
+
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs) {
+            this(request, delayMs, new Handler());
+        }
+
+        @VisibleForTesting
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs, @NonNull Handler handler) {
+            mDelayMs = delayMs;
+            mHandler = handler;
+            mDelayedRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    mDelayedRequests.remove(request);
+                    MoPubRequestQueue.this.add(request);
+                }
+            };
+        }
+
+        void start() {
+            mHandler.postDelayed(mDelayedRunnable, mDelayMs);
+        }
+
+        void cancel() {
+            mHandler.removeCallbacks(mDelayedRunnable);
+        }
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    Map<Request<?>, DelayedRequestHelper> getDelayedRequests() {
+        return mDelayedRequests;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/Networking.java b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
new file mode 100644
index 00000000..e820a0a5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
@@ -0,0 +1,193 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.util.LruCache;
+import android.webkit.WebView;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.BasicNetwork;
+import com.mopub.volley.toolbox.DiskBasedCache;
+import com.mopub.volley.toolbox.HttpStack;
+import com.mopub.volley.toolbox.HurlStack;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import java.io.File;
+
+import javax.net.ssl.SSLSocketFactory;
+
+public class Networking {
+    @VisibleForTesting
+    static final String CACHE_DIRECTORY_NAME = "mopub-volley-cache";
+    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
+
+    // These are volatile so that double-checked locking works.
+    // See http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
+    // for more information.
+    private volatile static MoPubRequestQueue sRequestQueue;
+    private volatile static String sUserAgent;
+    private volatile static MaxWidthImageLoader sMaxWidthImageLoader;
+    public static boolean sUseHttps = false;
+
+    @Nullable
+    public static MoPubRequestQueue getRequestQueue() {
+        return sRequestQueue;
+    }
+
+    @NonNull
+    public static MoPubRequestQueue getRequestQueue(@NonNull Context context) {
+        MoPubRequestQueue requestQueue = sRequestQueue;
+        // Double-check locking to initialize.
+        if (requestQueue == null) {
+            synchronized (Networking.class) {
+                requestQueue = sRequestQueue;
+                if (requestQueue == null) {
+
+                    // Guarantee ClientMetadata is set up.
+                    final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+                    final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), context);
+                    final SSLSocketFactory socketFactory = CustomSSLSocketFactory.getDefault(Constants.TEN_SECONDS_MILLIS);
+
+                    final String userAgent = Networking.getUserAgent(context.getApplicationContext());
+                    HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter, socketFactory);
+
+                    Network network = new BasicNetwork(httpStack);
+                    File volleyCacheDir = new File(context.getCacheDir().getPath() + File.separator
+                            + CACHE_DIRECTORY_NAME);
+                    Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+                    requestQueue = new MoPubRequestQueue(cache, network);
+                    sRequestQueue = requestQueue;
+                    requestQueue.start();
+                }
+            }
+        }
+
+        return requestQueue;
+    }
+
+    @NonNull
+    public static ImageLoader getImageLoader(@NonNull Context context) {
+        MaxWidthImageLoader imageLoader = sMaxWidthImageLoader;
+        // Double-check locking to initialize.
+        if (imageLoader == null) {
+            synchronized (Networking.class) {
+                imageLoader = sMaxWidthImageLoader;
+                if (imageLoader == null) {
+                    RequestQueue queue = getRequestQueue(context);
+                    int cacheSize = DeviceUtils.memoryCacheSizeBytes(context);
+                    final LruCache<String, Bitmap> imageCache = new LruCache<String, Bitmap>(cacheSize) {
+                        @Override
+                        protected int sizeOf(String key, Bitmap value) {
+                            if (value != null) {
+                                return value.getRowBytes() * value.getHeight();
+                            }
+
+                            return super.sizeOf(key, value);
+                        }
+                    };
+                    imageLoader = new MaxWidthImageLoader(queue, context, new MaxWidthImageLoader.ImageCache() {
+                        @Override
+                        public Bitmap getBitmap(final String key) {
+                            return imageCache.get(key);
+                        }
+
+                        @Override
+                        public void putBitmap(final String key, final Bitmap bitmap) {
+                            imageCache.put(key, bitmap);
+                        }
+                    });
+                    sMaxWidthImageLoader = imageLoader;
+                }
+            }
+        }
+        return imageLoader;
+    }
+
+    /**
+     * Caches and returns the WebView user agent to be used across all SDK requests. This is
+     * important because advertisers expect the same user agent across all request, impression, and
+     * click events.
+     */
+    @NonNull
+    public static String getUserAgent(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        String userAgent = sUserAgent;
+        if (userAgent == null) {
+            synchronized (Networking.class) {
+                userAgent = sUserAgent;
+                if (userAgent == null) {
+                    // As of Android 4.4, WebViews may only be instantiated on the UI thread
+                    if (Looper.myLooper() == Looper.getMainLooper()) {
+                        userAgent = new WebView(context).getSettings().getUserAgentString();
+                    } else {
+                        // In the exceptional case where we can't access the WebView user agent,
+                        // fall back to the System-specific user agent.
+                        userAgent = DEFAULT_USER_AGENT;
+                    }
+                    sUserAgent = userAgent;
+                }
+            }
+        }
+
+        return userAgent;
+    }
+
+    /**
+     * Gets the previously cached WebView user agent. This returns the default userAgent if the
+     * WebView user agent has not been initialized yet.
+     *
+     * @return Best-effort String WebView user agent.
+     */
+    @NonNull
+    public static String getCachedUserAgent() {
+        final String userAgent = sUserAgent;
+        if (userAgent == null) {
+            return DEFAULT_USER_AGENT;
+        }
+        return userAgent;
+    }
+
+    @VisibleForTesting
+    public static synchronized void clearForTesting() {
+        sRequestQueue = null;
+        sMaxWidthImageLoader = null;
+        sUserAgent = null;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setRequestQueueForTesting(MoPubRequestQueue queue) {
+        sRequestQueue = queue;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setImageLoaderForTesting(MaxWidthImageLoader imageLoader) {
+        sMaxWidthImageLoader = imageLoader;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setUserAgentForTesting(String userAgent) {
+        sUserAgent = userAgent;
+    }
+
+    /**
+     * Set whether to use HTTPS for communication with MoPub ad servers.
+     */
+    public static void useHttps(boolean useHttps) {
+        sUseHttps = useHttps;
+    }
+
+    public static boolean useHttps() {
+        return sUseHttps;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java b/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java
new file mode 100644
index 00000000..42438bbd
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java
@@ -0,0 +1,51 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.volley.toolbox.HurlStack;
+
+/**
+ * Url Rewriter that replaces MoPub templates for Google Advertising ID and Do Not Track settings
+ * when a request is queued for dispatch by the HurlStack in Volley.
+ */
+public class PlayServicesUrlRewriter implements HurlStack.UrlRewriter {
+    private static final String IFA_PREFIX = "ifa:";
+
+    public static final String UDID_TEMPLATE = "mp_tmpl_advertising_id";
+    public static final String DO_NOT_TRACK_TEMPLATE = "mp_tmpl_do_not_track";
+
+    private final String deviceIdentifier;
+    private final Context applicationContext;
+
+    public PlayServicesUrlRewriter(String deviceId, Context context) {
+        deviceIdentifier = deviceId;
+        applicationContext = context.getApplicationContext();
+    }
+
+    @Override
+    public String rewriteUrl(final String url) {
+        if (!url.contains(UDID_TEMPLATE) && !url.contains(DO_NOT_TRACK_TEMPLATE)) {
+            return url;
+        }
+
+        String prefix = "";
+        GpsHelper.AdvertisingInfo advertisingInfo = new GpsHelper.AdvertisingInfo(deviceIdentifier, false);
+
+        // Attempt to fetch the Google Play Services fields
+        if (GpsHelper.isPlayServicesAvailable(applicationContext)) {
+            // We can do this synchronously because urlRewrite happens in a background thread.
+            GpsHelper.AdvertisingInfo playServicesAdInfo = GpsHelper.fetchAdvertisingInfoSync(applicationContext);
+            if (playServicesAdInfo != null) {
+                prefix = IFA_PREFIX;
+                advertisingInfo = playServicesAdInfo;
+            }
+        }
+
+        // Fill in the templates
+        String toReturn = url.replace(UDID_TEMPLATE, Uri.encode(prefix + advertisingInfo.advertisingId));
+        toReturn = toReturn.replace(DO_NOT_TRACK_TEMPLATE, advertisingInfo.limitAdTracking ? "1" : "0");
+        return toReturn;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
new file mode 100644
index 00000000..ba535bf8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
@@ -0,0 +1,104 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+
+/**
+ * This class is responsible for managing the lifecycle of a request with a backoff policy. This
+ * class currently manages a single request at a time. The API allows for it to support multiple
+ * simultaneous requests in the future.
+ *
+ * Subclasses are responsible for implementing the createRequest method that will create a new
+ * instance of subclass's specific request type.
+ * The subclass is also responsible for listening to success and error responses from its specific
+ * request type.
+ *
+ * @param <T> The type of request factory to generate new requests for each retry.
+ */
+public abstract class RequestManager<T extends RequestManager.RequestFactory> {
+
+    // This interface is used to bound type T of the RequestManager
+    public interface RequestFactory{}
+
+    @Nullable protected Request<?> mCurrentRequest;
+    @Nullable protected T mRequestFactory;
+    @Nullable protected BackoffPolicy mBackoffPolicy;
+    @NonNull protected Handler mHandler;
+
+    public RequestManager(@NonNull Looper looper) {
+        mHandler = new Handler(looper);
+    }
+
+    @NonNull
+    abstract Request<?> createRequest();
+
+    public boolean isAtCapacity() {
+        return mCurrentRequest != null;
+    }
+
+    /**
+     * This method first cancels existing requests in flight and then begins the request
+     * lifecycle for the new request.
+     *
+     * @param requestFactory Factory that constructs a new request for each request retry from the
+     *                       backoff policy.
+     * @param backoffPolicy The request to cancel.
+     */
+    public void makeRequest(@NonNull T requestFactory, @NonNull BackoffPolicy backoffPolicy) {
+        Preconditions.checkNotNull(requestFactory);
+        Preconditions.checkNotNull(backoffPolicy);
+
+        cancelRequest();
+        mRequestFactory = requestFactory;
+        mBackoffPolicy = backoffPolicy;
+        makeRequestInternal();
+    }
+
+    /**
+     * Cancels the request in flight.
+     */
+    public void cancelRequest() {
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue != null && mCurrentRequest != null) {
+            requestQueue.cancel(mCurrentRequest);
+        }
+        clearRequest();
+    }
+
+    @VisibleForTesting
+    void makeRequestInternal() {
+        mCurrentRequest = createRequest();
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue == null) {
+            MoPubLog.d("MoPubRequest queue is null. Clearing request.");
+            clearRequest();
+            return;
+        }
+
+        if (mBackoffPolicy.getRetryCount() == 0) {
+            requestQueue.add(mCurrentRequest);
+        } else {
+            requestQueue.addDelayedRequest(mCurrentRequest, mBackoffPolicy.getBackoffMs());
+        }
+    }
+
+    @VisibleForTesting
+    void clearRequest() {
+        mCurrentRequest = null;
+        mRequestFactory = null;
+        mBackoffPolicy = null;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    Request<?> getCurrentRequest() {
+        return mCurrentRequest;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java b/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java
new file mode 100644
index 00000000..f2df816c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.volley.AuthFailureError;
+import com.mopub.volley.Request;
+import com.mopub.volley.toolbox.HurlStack;
+
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.TreeMap;
+
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * Modified Volley HurlStack with explicitly specified User-Agent.
+ *
+ * Used by Networking's singleton RequestQueue to ensure all network requests use WebView's
+ * User-Agent.
+ */
+public class RequestQueueHttpStack extends HurlStack {
+    @NonNull private final String mUserAgent;
+
+    public RequestQueueHttpStack(@NonNull final String userAgent) {
+        this(userAgent, null);
+    }
+
+    public RequestQueueHttpStack(@NonNull final String userAgent, @Nullable final UrlRewriter urlRewriter) {
+        this(userAgent, urlRewriter, null);
+    }
+
+    public RequestQueueHttpStack(@NonNull final String userAgent, @Nullable final UrlRewriter urlRewriter,
+                                 @Nullable final SSLSocketFactory sslSocketFactory) {
+        super(urlRewriter, sslSocketFactory);
+
+        mUserAgent = userAgent;
+    }
+
+    @Override
+    public HttpResponse performRequest(@NonNull final Request<?> request,
+            @Nullable Map<String, String> additionalHeaders) throws IOException, AuthFailureError {
+        if (additionalHeaders == null) {
+            additionalHeaders = new TreeMap<String, String>();
+        }
+
+        additionalHeaders.put(ResponseHeader.USER_AGENT.getKey(), mUserAgent);
+
+        return super.performRequest(request, additionalHeaders);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
new file mode 100644
index 00000000..5b5b3732
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for making requests to the Scribe service.
+ */
+public class ScribeBackoffPolicy extends BackoffPolicy {
+    private static final int DEFAULT_BACKOFF_TIME_MS = 60 * 1000;
+    private static final int MAX_RETRIES = 5;
+    private static final int BACKOFF_MULTIPLIER = 2;
+
+    public ScribeBackoffPolicy() {
+        this(DEFAULT_BACKOFF_TIME_MS, MAX_RETRIES, BACKOFF_MULTIPLIER);
+    }
+
+    @VisibleForTesting
+    ScribeBackoffPolicy(int defaultBackoffTimeMs, int maxRetries, int backoffMultiplier) {
+        mDefaultBackoffTimeMs = defaultBackoffTimeMs;
+        mMaxRetries = maxRetries;
+        mBackoffMultiplier = backoffMultiplier;
+    }
+
+    @Override
+    public void backoff(VolleyError volleyError) throws VolleyError {
+        if (!hasAttemptRemaining()) {
+            throw volleyError;
+        }
+
+        if (volleyError instanceof NoConnectionError) {
+            updateBackoffTime();
+            return;
+        }
+
+        NetworkResponse networkResponse = volleyError.networkResponse;
+        if (networkResponse != null &&
+                (networkResponse.statusCode == 503  || networkResponse.statusCode == 504)) {
+            updateBackoffTime();
+            return;
+        }
+
+        throw volleyError;
+    }
+
+    private void updateBackoffTime() {
+        double multiplier = Math.pow(mBackoffMultiplier, mRetryCount);
+        mBackoffMs = (int) (mDefaultBackoffTimeMs * multiplier);
+        mRetryCount++;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
new file mode 100644
index 00000000..f04bcdf0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONArray;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A POST request for logging custom events to the Scribe service.
+ */
+public class ScribeRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse();
+    }
+
+    public interface ScribeRequestFactory extends RequestManager.RequestFactory {
+        public ScribeRequest createRequest(ScribeRequest.Listener listener);
+    }
+
+    @NonNull private final List<BaseEvent> mEvents;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequest.Listener mListener;
+
+    public ScribeRequest(@NonNull String url,
+            @NonNull List<BaseEvent> events,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull Listener listener) {
+        super(Method.POST, url, listener);
+
+        mEvents = events;
+        mEventSerializer = eventSerializer;
+        mListener = listener;
+
+        setShouldCache(false);
+
+        // This retry policy applies to socket timeouts only
+        setRetryPolicy(new DefaultRetryPolicy());
+    }
+
+    /**
+     * This is method runs on the background thread
+     */
+    @Override
+    protected Map<String,String> getParams() {
+        JSONArray jsonArray = mEventSerializer.serializeAsJson(mEvents);
+        Map<String,String> params = new HashMap<String, String>();
+        params.put("log", jsonArray.toString());
+        return params;
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    protected void deliverResponse(Void aVoid) {
+        mListener.onResponse();
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    public List<BaseEvent> getEvents() {
+        return mEvents;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
new file mode 100644
index 00000000..e1b3fc45
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
@@ -0,0 +1,59 @@
+package com.mopub.network;
+
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import static com.mopub.network.ScribeRequest.ScribeRequestFactory;
+
+/**
+ * Request manager to manage scribe requests. This class implements the specific Scribe
+ * request listener.
+ */
+public class ScribeRequestManager extends RequestManager<ScribeRequestFactory> implements ScribeRequest.Listener {
+
+    public ScribeRequestManager(final Looper looper) {
+        super(looper);
+    }
+
+    // RequestManager
+    @NonNull
+    @Override
+    Request<?> createRequest() {
+        return mRequestFactory.createRequest(this);
+    }
+
+    // ScribeRequest.Listener
+    @Override
+    public void onResponse() {
+        MoPubLog.d("Successfully scribed events");
+        // Get back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                clearRequest();
+            }
+        });
+    }
+
+    @Override
+    public void onErrorResponse(final VolleyError volleyError) {
+        // Post back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    mBackoffPolicy.backoff(volleyError);
+                    makeRequestInternal();
+                } catch (VolleyError e) {
+                    MoPubLog.d("Failed to Scribe events: " + volleyError);
+                    clearRequest();
+                }
+            }
+        });
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
new file mode 100644
index 00000000..e2e93b04
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
@@ -0,0 +1,166 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.VastErrorCode;
+import com.mopub.mobileads.VastMacroHelper;
+import com.mopub.mobileads.VastTracker;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class TrackingRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse(@NonNull String url);
+    }
+
+    @Nullable private final TrackingRequest.Listener mListener;
+
+    private TrackingRequest(@NonNull final String url, @Nullable final Listener listener) {
+        super(Method.GET, url, listener);
+        mListener = listener;
+        setShouldCache(false);
+        setRetryPolicy(new DefaultRetryPolicy(
+                DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
+                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
+                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(final NetworkResponse networkResponse) {
+        if (networkResponse.statusCode != 200) {
+            return Response.error(
+                    new MoPubNetworkError("Failed to log tracking request. Response code: "
+                            + networkResponse.statusCode + " for url: " + getUrl(),
+                            MoPubNetworkError.Reason.TRACKING_FAILURE));
+        }
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    public void deliverResponse(final Void aVoid) {
+        if (mListener != null) {
+            mListener.onResponse(getUrl());
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////
+    // Static helper methods that can be used as utilities:
+    //////////////////////////////////////////////////////////////
+
+    public static void makeVastTrackingHttpRequest(
+            @NonNull final List<VastTracker> vastTrackers,
+            @Nullable final VastErrorCode vastErrorCode,
+            @Nullable final Integer contentPlayHead,
+            @Nullable final String assetUri,
+            @Nullable final Context context) {
+        Preconditions.checkNotNull(vastTrackers);
+
+        List<String> trackers = new ArrayList<String>(vastTrackers.size());
+        for (VastTracker vastTracker : vastTrackers) {
+            if (vastTracker == null) {
+                continue;
+            }
+            if (vastTracker.isTracked() && !vastTracker.isRepeatable()) {
+                continue;
+            }
+            trackers.add(vastTracker.getTrackingUrl());
+            vastTracker.setTracked();
+        }
+
+        makeTrackingHttpRequest(
+                new VastMacroHelper(trackers)
+                        .withErrorCode(vastErrorCode)
+                        .withContentPlayHead(contentPlayHead)
+                        .withAssetUri(assetUri)
+                        .getUris(),
+                context
+        );
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
+            @Nullable final Context context) {
+        makeTrackingHttpRequest(urls, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
+            @Nullable final Context context,
+            final BaseEvent.Name name) {
+        makeTrackingHttpRequest(urls, context, null, name);
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
+            @Nullable final Context context,
+            @Nullable final Listener listener,
+            final BaseEvent.Name name) {
+        if (urls == null || context == null) {
+            return;
+        }
+
+        final RequestQueue requestQueue = Networking.getRequestQueue(context);
+        for (final String url : urls) {
+            if (TextUtils.isEmpty(url)) {
+                continue;
+            }
+
+            final TrackingRequest.Listener internalListener = new TrackingRequest.Listener() {
+                @Override
+                public void onResponse(@NonNull String url) {
+                    MoPubLog.d("Successfully hit tracking endpoint: " + url);
+                    if (listener != null) {
+                        listener.onResponse(url);
+                    }
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) {
+                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
+                    if (listener != null) {
+                        listener.onErrorResponse(volleyError);
+                    }
+                }
+            };
+            final TrackingRequest trackingRequest = new TrackingRequest(url, internalListener);
+            requestQueue.add(trackingRequest);
+        }
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final String url,
+            @Nullable final Context context) {
+        makeTrackingHttpRequest(url, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final String url,
+            @Nullable final Context context, @Nullable Listener listener) {
+        makeTrackingHttpRequest(url, context, listener, null);
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final String url,
+            @Nullable final Context context, final BaseEvent.Name name) {
+        makeTrackingHttpRequest(url, context, null, name);
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final String url,
+            @Nullable final Context context,
+            @Nullable Listener listener,
+            final BaseEvent.Name name) {
+        if (url != null) {
+            makeTrackingHttpRequest(Arrays.asList(url), context, listener, name);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
new file mode 100644
index 00000000..16a8fd16
--- /dev/null
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -0,0 +1,3 @@
+fabric-identifier=com.mopub.sdk.android:mopub
+fabric-version=3.11.0+kit
+fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java b/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
new file mode 100644
index 00000000..6bdefe59
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
@@ -0,0 +1,104 @@
+package com.mopub.common;
+
+import android.os.Build;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.TestDateAndTime;
+import com.mopub.network.AdResponse;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.stub;
+
+@RunWith(SdkTestRunner.class)
+public class AdReportTest {
+
+    public AdReport subject;
+    @Mock
+    ClientMetadata mockClientMetadata;
+    @Mock
+    AdResponse mockAdResponse;
+    private Date now;
+
+    @Before
+    public void setup() {
+        now = new Date();
+        TestDateAndTime.getInstance().setNow(now);
+    }
+
+    @Test
+    public void testToString_shouldProperlyConstructParametersTextFile() throws Exception {
+        String expectedParameters =
+                "sdk_version : 1.15.2.2\n" +
+                        "creative_id : \n" +
+                        "platform_version : "+ Integer.toString(Build.VERSION.SDK_INT) +"\n" +
+                        "device_model : android\n" +
+                        "ad_unit_id : testAdUnit\n" +
+                        "device_locale : en_US\n" +
+                        "device_id : UDID\n" +
+                        "network_type : unknown\n" +
+                        "platform : android\n" +
+                        "timestamp : " + getCurrentDateTime() + "\n" +
+                        "ad_type : interstitial\n" +
+                        "ad_size : {480, 320}\n";
+
+        stub(mockClientMetadata.getSdkVersion()).toReturn("1.15.2.2");
+        stub(mockAdResponse.getDspCreativeId()).toReturn("");
+        stub(mockClientMetadata.getDeviceModel()).toReturn("android");
+        stub(mockClientMetadata.getDeviceLocale()).toReturn(Locale.US);
+        stub(mockClientMetadata.getDeviceId()).toReturn("UDID");
+        stub(mockAdResponse.getNetworkType()).toReturn("unknown");
+
+        stub(mockAdResponse.getTimestamp()).toReturn(now.getTime());
+        stub(mockAdResponse.getAdType()).toReturn("interstitial");
+        stub(mockAdResponse.getWidth()).toReturn(480);
+        stub(mockAdResponse.getHeight()).toReturn(320);
+
+        subject = new AdReport("testAdUnit", mockClientMetadata, mockAdResponse);
+        assertThat(subject.toString()).isEqualTo(expectedParameters);
+    }
+
+    @Test
+    public void constructor_shouldHandleInvalidAdConfigurationValues() throws Exception {
+        String expectedParameters =
+                "sdk_version : null\n" +
+                        "creative_id : null\n" +
+                        "platform_version : "+ Integer.toString(Build.VERSION.SDK_INT) +"\n" +
+                        "device_model : null\n" +
+                        "ad_unit_id : testAdUnit\n" +
+                        "device_locale : null\n" +
+                        "device_id : null\n" +
+                        "network_type : null\n" +
+                        "platform : android\n" +
+                        "timestamp : null" + "\n" +
+                        "ad_type : null\n" +
+                        "ad_size : {0, 0}\n";
+
+        stub(mockClientMetadata.getSdkVersion()).toReturn(null);
+        stub(mockAdResponse.getDspCreativeId()).toReturn(null);
+        stub(mockClientMetadata.getDeviceLocale()).toReturn(null);
+        stub(mockClientMetadata.getDeviceId()).toReturn(null);
+        stub(mockAdResponse.getNetworkType()).toReturn(null);
+
+        stub(mockAdResponse.getTimestamp()).toReturn(-1L);
+        stub(mockAdResponse.getAdType()).toReturn(null);
+        stub(mockAdResponse.getWidth()).toReturn(null);
+        stub(mockAdResponse.getHeight()).toReturn(null);
+
+        subject = new AdReport("testAdUnit", mockClientMetadata, mockAdResponse);
+        assertThat(subject.toString()).isEqualTo(expectedParameters);
+    }
+
+    private String getCurrentDateTime() {
+        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z", Locale.US);
+        return dateFormat.format(now);
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java
new file mode 100644
index 00000000..08917adb
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java
@@ -0,0 +1,171 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doCallRealMethod;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class BrowserWebViewClientTest {
+
+    private final WebView MOOT_WEB_VIEW = null;
+
+    private BrowserWebViewClient subject;
+    private Context context;
+    private MoPubBrowser mockMoPubBrowser;
+    private WebView mockWebView;
+
+    @Before
+    public void setUp() {
+        mockMoPubBrowser = mock(MoPubBrowser.class);
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+        mockWebView = mock(WebView.class);
+
+        doCallRealMethod().when(mockMoPubBrowser).setWebView(mockWebView);
+        doCallRealMethod().when(mockMoPubBrowser).getWebView();
+        when(mockMoPubBrowser.getApplicationContext()).thenReturn(context);
+
+        mockMoPubBrowser.setWebView(mockWebView);
+        subject = new BrowserWebViewClient(mockMoPubBrowser);
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withHTTPUrl_shouldReturnTrue_shouldLoadUrl() {
+        final String url = "http://twitter.com";
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView).loadUrl(url);
+        verify(mockMoPubBrowser, never()).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withTelUrl_shouldReturnTrue_shouldFinish() {
+        final String url = "tel:123456789";
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeeplinkUrl_shouldReturnTrue_shouldFinish() {
+        final String url = "twitter://timeline";
+
+        makeDeeplinkResolvable(url);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeeplinkPlusUrl_withSuccessfulPrimaryUrl_shouldReturnTrue_shouldFinish() {
+        final String primaryUrl = "twitter://timeline";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl);
+
+        makeDeeplinkResolvable(primaryUrl);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeeplinkPlusUrl_withFailedPrimaryUrl_withHTTPFallbackUrl_shouldReturnTrue_shouldLoadFallbackUrl_shouldNotFinish() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "https://twitter.com/";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView).loadUrl(fallbackUrl);
+        verify(mockMoPubBrowser, never()).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeeplinkPlusUrl_withFailedPrimaryUrl_withTelFallbackUrl_shouldReturnTrue_shouldFinish() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "tel:123456789";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser, times(1)).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeeplinkPlusUrl_withFailedPrimaryUrl_withDeeplinkFallbackUrl_shouldReturnTrue_shouldFinish() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "twitter://timeline";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl);
+
+        makeDeeplinkResolvable(fallbackUrl);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser, times(1)).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeeplinkPlusUrl_withEncodedQueryString_shouldReturnTrue_shouldFinish() {
+        final String primaryUrl = "ebay://launch?nav=home&referrer=http%3A%2F%2Frover.ebay.com%2Frover%2F1%2F711-212056-53654-1%2F4%3Fmpt%3Dcache_buster%26ff6%3Dclick_id%26ff7%3Difa%26ff9%3Dsegment_name%26ff18%3Dcreative_name%26siteid%3D0%26ipn%3Dadmain2%26placement%3D418737%26ck%3D23932_main%26mpvc%3D";
+        final String fallbackUrl = "http://ebay.com";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl);
+
+        makeDeeplinkResolvable(primaryUrl);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isTrue();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser, times(1)).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withEmptyUrl_shouldReturnFalse_shouldDoNothing() {
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, "")).isFalse();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser, never()).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNullUrl_shouldReturnFalse_shouldDoNothing() {
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, null)).isFalse();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser, never()).finish();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withoutMatchingSupporedUrl_shouldReturnFalse_shouldDoNothing() {
+        final String url = "mopubscheme://close";
+        subject = new BrowserWebViewClient(mockMoPubBrowser);
+
+        assertThat(subject.shouldOverrideUrlLoading(MOOT_WEB_VIEW, url)).isFalse();
+        verify(mockWebView, never()).loadUrl(anyString());
+        verify(mockMoPubBrowser, never()).finish();
+    }
+
+    private void makeDeeplinkResolvable(String deeplink) {
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deeplink)), new ResolveInfo());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
index f7f5abd4..ce7282a3 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
@@ -1,17 +1,15 @@
 package com.mopub.common;
 
 import android.app.Activity;
-import android.graphics.Bitmap;
-import android.support.v4.util.LruCache;
 
 import com.mopub.common.test.support.SdkTestRunner;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -25,6 +23,7 @@
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class CacheServiceTest {
@@ -39,9 +38,7 @@
 
     @Before
     public void setUp() throws Exception {
-        CacheService.clearAndNullCaches();
-
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         key1 = "http://www.mopub.com/";
         data1 = "image_data_1";
 
@@ -59,24 +56,24 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         }).when(diskCacheGetListener).onComplete(anyString(), any(byte[].class));
     }
 
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
+    @Test
+    public void initializeDiskCache_withNullCacheDirectory_shouldNotThrowNpe_shouldReturnFalse() {
+        Activity mockContext = mock(Activity.class);
+        when(mockContext.getCacheDir()).thenReturn(null);
+
+        assertThat(CacheService.initializeDiskCache(mockContext)).isFalse();
     }
 
     @Test
-    public void initializeCaches_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
+    public void initializeCache_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
         assertThat(CacheService.getDiskLruCache()).isNull();
 
         CacheService.initialize(context);
         DiskLruCache diskLruCache = CacheService.getDiskLruCache();
         assertThat(diskLruCache).isNotNull();
-        LruCache<String, Bitmap> memoryLruCache = CacheService.getBitmapLruCache();
-        assertThat(memoryLruCache).isNotNull();
 
         CacheService.initialize(context);
         assertThat(diskLruCache).isEqualTo(CacheService.getDiskLruCache());
-        assertThat(memoryLruCache).isEqualTo(CacheService.getBitmapLruCache());
     }
     
     @Test
@@ -165,8 +162,6 @@ public static void assertDiskCacheIsEmpty() {
     }
 
     public static void assertCachesAreEmpty() {
-        assertThat(CacheService.getBitmapLruCache()).isNotNull();
-        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
         assertDiskCacheIsEmpty();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
index 44c6fedb..ba6fcd75 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
@@ -62,11 +62,11 @@ public void testCachedData_shouldBeAvailable() {
 
         final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
         // Telephony manager data.
-        assertThat(clientMetadata.getNetworkOperator()).isEqualTo("testNetworkOperator");
+        assertThat(clientMetadata.getNetworkOperatorForUrl()).isEqualTo("testNetworkOperator");
         assertThat(clientMetadata.getNetworkOperatorName()).isEqualTo("testNetworkOperatorName");
         assertThat(clientMetadata.getIsoCountryCode()).isEqualTo("1");
 
         // Other cached data.
-        assertThat(clientMetadata.getAdvertisingId()).isNotNull().isNotEmpty();
+        assertThat(clientMetadata.getDeviceId()).isNotNull().isNotEmpty();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
new file mode 100644
index 00000000..5c5f35e1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
@@ -0,0 +1,222 @@
+package com.mopub.common;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.os.Build.VERSION_CODES;
+import android.view.MotionEvent;
+
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class CloseableLayoutTest {
+    private CloseableLayout subject;
+
+    @Mock private OnCloseListener mockCloseListener;
+
+    private MotionEvent closeRegionDown;
+    private MotionEvent closeRegionUp;
+    private MotionEvent closeRegionCancel;
+    private MotionEvent contentRegionDown;
+    private MotionEvent contentRegionUp;
+    private MotionEvent contentRegionCancel;
+
+    @Before
+    public void setup() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new CloseableLayout(activity);
+        subject.setClosePosition(ClosePosition.TOP_RIGHT);
+
+        // Fake the close bounds, which allows us to set up close regions
+        subject.setCloseBounds(new Rect(100, 10, 110, 20));
+        closeRegionDown = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_DOWN, 100, 10, 0);
+        closeRegionUp = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_UP, 100, 10, 0);
+        closeRegionCancel = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_CANCEL, 100, 10, 0);
+        contentRegionDown = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_DOWN, 0, 0, 0);
+        contentRegionUp = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_UP, 0, 0, 0);
+        contentRegionCancel = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_CANCEL, 0, 0, 0);
+    }
+
+    @Test
+    public void setOnCloseListener_thenTouchCloseRegion_shouldCallOnClick() {
+        subject.setOnCloseListener(mockCloseListener);
+        subject.onTouchEvent(closeRegionDown);
+        subject.onTouchEvent(closeRegionUp);
+
+        verify(mockCloseListener).onClose();
+    }
+
+    @Test
+    public void setOnCloseListener_thenTouchContentRegion_shouldNotCallCloseListener() {
+        subject.setOnCloseListener(mockCloseListener);
+        subject.onTouchEvent(contentRegionDown);
+        subject.onTouchEvent(contentRegionUp);
+
+        verify(mockCloseListener, never()).onClose();
+    }
+
+    @Test
+    public void setCloseVisible_shouldToggleCloseDrawable() {
+        subject.setCloseVisible(false);
+        assertThat(subject.isCloseVisible()).isFalse();
+
+        subject.setCloseVisible(true);
+        assertThat(subject.isCloseVisible()).isTrue();
+    }
+
+    // setLeft, setTop, setRight, and setBottom, are not available before honeycomb. This
+    // annotation just supresses a warning.
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    @Test
+    public void draw_shouldUpdateCloseBounds() {
+        subject.setLeft(0);
+        subject.setTop(0);
+        subject.setRight(100);
+        subject.setBottom(200);
+        subject.onSizeChanged(100, 200, 0, 0);
+
+        int expectedTop = 0;
+        int expectedLeft = (int) (100 - CloseableLayout.CLOSE_REGION_SIZE_DP);
+        Canvas canvas = new Canvas();
+        subject.draw(canvas);
+        Rect closeBounds = subject.getCloseBounds();
+        assertThat(closeBounds.top).isEqualTo(expectedTop);
+        assertThat(closeBounds.bottom).isEqualTo(
+                (int) (expectedTop + CloseableLayout.CLOSE_REGION_SIZE_DP));
+        assertThat(closeBounds.left).isEqualTo(expectedLeft);
+        assertThat(closeBounds.right).isEqualTo(
+                (int) (expectedLeft + CloseableLayout.CLOSE_REGION_SIZE_DP));
+    }
+
+    @Test
+    public void draw_withoutCloseBoundsChanged_shouldNotUpdateCloseBounds() {
+        Canvas canvas = new Canvas();
+        subject.draw(canvas);
+        Rect originalCloseBounds = subject.getCloseBounds();
+
+        subject.setCloseBounds(new Rect(40, 41, 42, 43));
+        subject.setCloseBoundChanged(false);
+        subject.draw(canvas);
+
+        assertThat(subject.getCloseBounds()).isEqualTo(originalCloseBounds);
+    }
+
+    @Test
+    public void onInterceptTouchEvent_closeRegionDown_shouldReturnTrue() {
+        boolean intercepted = subject.onInterceptTouchEvent(closeRegionDown);
+        assertThat(intercepted).isTrue();
+    }
+
+    @Test public void onInterceptTouchEvent_contentRegionDown_returnsTrue() {
+        boolean intercepted = subject.onInterceptTouchEvent(contentRegionDown);
+        assertThat(intercepted).isFalse();
+    }
+
+    @Test
+    public void
+    onTouchEvent_closeRegionDown_thenCloseRegionUp_shouldTogglePressedStateAfterDelay() {
+        assertThat(subject.isClosePressed()).isFalse();
+
+        subject.onTouchEvent(closeRegionDown);
+        assertThat(subject.isClosePressed()).isTrue();
+
+        subject.onTouchEvent(closeRegionUp);
+        assertThat(subject.isClosePressed()).isTrue();
+
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        assertThat(subject.isClosePressed()).isFalse();
+    }
+
+    @Test
+    public void onTouchEvent_closeRegionDown_thenCloseRegionCancel_shouldTogglePressedState() {
+        subject.onTouchEvent(closeRegionDown);
+        subject.onTouchEvent(closeRegionCancel);
+        assertThat(subject.isClosePressed()).isFalse();
+    }
+
+    @Test
+    public void onTouchEvent_closeRegionDown_thenContentRegionCancel_shouldTogglePressedState() {
+        subject.onTouchEvent(closeRegionDown);
+        subject.onTouchEvent(contentRegionCancel);
+        assertThat(subject.isClosePressed()).isFalse();
+    }
+
+    @Test
+    public void pointInCloseBounds_noSlop_shouldReturnValidValues() {
+        Rect bounds = new Rect();
+        bounds.left = 10;
+        bounds.right = 20;
+        bounds.top = 100;
+        bounds.bottom = 200;
+        subject.setCloseBounds(bounds);
+
+        assertThat(subject.pointInCloseBounds(9, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 100, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 199, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 200, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 100, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 199, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 200, 0)).isFalse();
+
+        assertThat(subject.pointInCloseBounds(19, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(19, 100, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 199, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 200, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 100, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 199, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 200, 0)).isFalse();
+
+    }
+
+    @Test
+    public void pointInCloseBounds_slop_shouldReturnValidValues() {
+        int slop = 3;
+
+        // Same as above, but adjust given 3 px slop
+        Rect bounds = new Rect();
+        bounds.left = 13;
+        bounds.right = 17;
+        bounds.top = 103;
+        bounds.bottom = 197;
+        subject.setCloseBounds(bounds);
+
+        assertThat(subject.pointInCloseBounds(9, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 100, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 199, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 200, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 100, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 199, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 200, slop)).isFalse();
+
+        assertThat(subject.pointInCloseBounds(19, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(19, 100, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 199, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 200, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 100, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 199, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 200, slop)).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java b/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java
new file mode 100644
index 00000000..0ea85803
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java
@@ -0,0 +1,43 @@
+package com.mopub.common;
+
+import org.junit.Test;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class CreativeOrientationTest {
+
+    @Test
+    public void fromHeader_nullParam_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader(null)).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_emptyParam_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader("")).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_withGarbage_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader("p0rtr41t")).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_lParam_shouldBeLandscape() {
+        assertThat(CreativeOrientation.fromHeader("l")).isEqualTo(CreativeOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void fromHeader_uppercaseL_shouldBeLandscape() {
+        assertThat(CreativeOrientation.fromHeader("L")).isEqualTo(CreativeOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void fromHeader_pParam_shouldBePortrait() {
+        assertThat(CreativeOrientation.fromHeader("p")).isEqualTo(CreativeOrientation.PORTRAIT);
+    }
+
+    @Test
+    public void fromHeader_uppercaseP_shouldBePortrait() {
+        assertThat(CreativeOrientation.fromHeader("P")).isEqualTo(CreativeOrientation.PORTRAIT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
index 741db09f..b0de5153 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
@@ -4,29 +4,44 @@
 import com.mopub.common.util.ResponseHeader;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
+import org.apache.http.HttpResponse;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.util.Locale;
 
+import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class DownloadResponseTest {
 
     DownloadResponse subject;
-    TestHttpResponseWithHeaders mockHttpResponse;
+    TestHttpResponseWithHeaders testHttpResponse;
 
     @Before
     public void setup() throws Exception {
-        mockHttpResponse = new TestHttpResponseWithHeaders(200, "abcde".getBytes());
-        mockHttpResponse.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "testCustomEvent");
-        mockHttpResponse.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey().toLowerCase(Locale.US), "http://example.com/");
-        mockHttpResponse.addHeader(ResponseHeader.FAIL_URL.getKey().toUpperCase(Locale.US), "http://mopub.com/");
-        subject = new DownloadResponse(mockHttpResponse);
+        testHttpResponse = new TestHttpResponseWithHeaders(200, "abcde".getBytes());
+        testHttpResponse.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "testCustomEvent");
+        testHttpResponse.addHeader(ResponseHeader.CLICK_TRACKING_URL.getKey().toLowerCase(Locale.US), "http://example.com/");
+        testHttpResponse.addHeader(ResponseHeader.FAIL_URL.getKey().toUpperCase(Locale.US), "http://mopub.com/");
+        subject = new DownloadResponse(testHttpResponse);
+    }
+
+    @Test
+    public void constructor_withNullHttpEntity_shouldNotThrowNullPointerException() throws Exception {
+        HttpResponse mockHttpResponse = mock(HttpResponse.class);
+        when(mockHttpResponse.getEntity()).thenReturn(null);
+        when(mockHttpResponse.getStatusLine()).thenReturn(testHttpResponse.new TestStatusLine());
+
+        DownloadResponse downloadResponse = new DownloadResponse(mockHttpResponse);
+        assertThat(downloadResponse.getContentLength()).isEqualTo(0);
+        assertThat(downloadResponse.getByteArray()).isEmpty();
     }
 
     @Test
@@ -47,7 +62,7 @@ public void testGetContentLength() throws Exception {
     @Test
     public void testGetFirstHeader_caseInsensitive() throws Exception {
         assertEquals("testCustomEvent", subject.getFirstHeader(ResponseHeader.CUSTOM_EVENT_NAME));
-        assertEquals("http://example.com/", subject.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL));
+        assertEquals("http://example.com/", subject.getFirstHeader(ResponseHeader.CLICK_TRACKING_URL));
         assertEquals("http://mopub.com/", subject.getFirstHeader(ResponseHeader.FAIL_URL));
         assertNull(subject.getFirstHeader(ResponseHeader.CUSTOM_EVENT_DATA));
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
index cfa1702f..bbe1b484 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
@@ -18,7 +18,9 @@
 
 import static junit.framework.Assert.fail;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
@@ -45,27 +47,26 @@ public void setUp() {
         mTestResponse = "TEST RESPONSE";
         mTestHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, mTestResponse);
         mTestHttpResponseWithHeaders.addHeader(ResponseHeader.IMPRESSION_URL.getKey(), "moPubImpressionTrackerUrl");
-        mTestHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "moPubClickTrackerUrl");
+        mTestHttpResponseWithHeaders.addHeader(ResponseHeader.CLICK_TRACKING_URL.getKey(), "moPubClickTrackerUrl");
 
         mFakeHttpLayer = Robolectric.getFakeHttpLayer();
     }
 
     @Test
-    public void execute_whenDownloadTaskAndHttpClientCompleteSuccessfully_shouldReturn200HttpResponse() {
+    public void whenDownloadTaskAndHttpClientCompleteSuccessfully_shouldReturn200HttpResponse() {
         mFakeHttpLayer.addPendingHttpResponse(mTestHttpResponseWithHeaders);
         mDownloadTask.execute(httpGet);
 
-        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()),
-                responseCaptor.capture());
+        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()), responseCaptor.capture());
         DownloadResponse response = responseCaptor.getValue();
         assertThat(response.getStatusCode()).isEqualTo(200);
         assertThat(response.getFirstHeader(ResponseHeader.IMPRESSION_URL)).isEqualTo("moPubImpressionTrackerUrl");
-        assertThat(response.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL)).isEqualTo("moPubClickTrackerUrl");
+        assertThat(response.getFirstHeader(ResponseHeader.CLICK_TRACKING_URL)).isEqualTo("moPubClickTrackerUrl");
         assertThat(HttpResponses.asResponseString(response)).isEqualTo(mTestResponse);
     }
 
     @Test
-    public void execute_whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_shouldReturn599HttpResponse() {
+    public void whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_shouldReturn599HttpResponse() {
         mFakeHttpLayer.addPendingHttpResponse(599, "");
         mDownloadTask.execute(httpGet);
 
@@ -77,40 +78,35 @@ public void execute_whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_s
     }
 
     @Test
-    public void execute_whenDownloadTaskIsCancelledBeforeExecute_shouldReturnNullHttpReponseAndNullUrl() {
+    public void whenDownloadTaskIsCancelledBeforeExecute_shouldNotCallOnComplete() {
         mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
         mDownloadTask.cancel(true);
         mDownloadTask.execute(httpGet);
 
-        verify(mockDownloadTaskListener).onComplete(null, null);
+        verify(mockDownloadTaskListener, never()).onComplete(
+                any(String.class), any(DownloadResponse.class));
     }
 
     @Ignore("pending")
     @Test
-        // need a way to reliably cancel task during doInBackground
-    public void execute_whenDownloadTaskIsCancelledDuringDoInBackground_shouldReturnNullHttpReponse() {
-    }
-
-    @Ignore("pending")
-    @Test
-    public void execute_whenHttpUriRequestThrowsIOException_shouldCancelTaskAndReturnNullHttpResponse() {
+    public void whenHttpUriRequestThrowsIOException_shouldCancelTaskAndReturnNullHttpResponse() {
         // need a way to force HttpUriRequest to throw on execute
     }
 
     @Test
-    public void execute_whenHttpUriRequestIsNull_shouldReturnNullHttpReponseAndNullUrl() {
+    public void whenHttpUriRequestIsNull_shouldReturnNullHttpReponseAndNullUrl() {
         mDownloadTask.execute((HttpUriRequest) null);
         verify(mockDownloadTaskListener).onComplete(null, null);
     }
 
     @Test
-    public void execute_whenHttpUriRequestIsNullArray_shouldReturnNullHttpReponseAndNullUrl() {
+    public void whenHttpUriRequestIsNullArray_shouldReturnNullHttpReponseAndNullUrl() {
         mDownloadTask.execute((HttpUriRequest[]) null);
         verify(mockDownloadTaskListener).onComplete(null, null);
     }
 
     @Test
-    public void execute_whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
+    public void whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
         mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
         mFakeHttpLayer.addPendingHttpResponse(500, "");
         mDownloadTask.execute(httpGet, new HttpGet("http://www.twitter.com/"));
@@ -123,13 +119,8 @@ public void execute_whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
         assertThat(HttpResponses.asResponseString(response)).isEqualTo(mTestResponse);
     }
 
-    @Test
-    public void downLoadTask_whenConstructedWithNullListener_shouldThrowIllegalArgumentException() {
-        try {
-            new DownloadTask(null);
-            fail("DownloadTask didn't throw IllegalArgumentException when constructed with null");
-        } catch (IllegalArgumentException e) {
-            // passed
-        }
+    @Test(expected = IllegalArgumentException.class)
+    public void constructor_withNullListener_shouldThrowIllegalArgumentException() {
+        new DownloadTask(null);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
index a35aa96f..25ce4ba3 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
@@ -53,7 +53,7 @@ public boolean isLimitAdTrackingEnabled() {
 
     @Before
     public void setup() {
-    	context = new Activity();
+    	context = Robolectric.buildActivity(Activity.class).create().get();
         adInfo = new TestAdInfo();
 
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
@@ -300,7 +300,7 @@ private void safeAcquireSemaphore() throws Exception {
 
     static public void verifyClientMetadata(Context context, TestAdInfo adInfo) {
         ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-        assertThat(clientMetadata.getAdvertisingId()).isEqualTo("ifa:" + adInfo.getId());
+        assertThat(clientMetadata.getDeviceId()).isEqualTo("ifa:" + adInfo.getId());
         assertThat(clientMetadata.isDoNotTrackSet()).isEqualTo(adInfo.isLimitAdTrackingEnabled());
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java b/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
index 48f721bb..497bbbbb 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
@@ -4,7 +4,7 @@
 import android.webkit.WebView;
 
 import com.mopub.common.util.ResponseHeader;
-import com.mopub.common.util.test.support.CommonUtils;
+import com.mopub.network.Networking;
 
 import org.apache.http.HttpRequest;
 import org.apache.http.client.methods.HttpGet;
@@ -18,7 +18,7 @@
 import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
 import static com.mopub.common.HttpClient.initializeHttpGet;
-import static junit.framework.Assert.fail;
+import static com.mopub.common.HttpClient.urlEncode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(RobolectricTestRunner.class)
@@ -29,7 +29,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         userAgent = new WebView(context).getSettings().getUserAgentString();
 
         Robolectric.addHttpResponseRule(new RequestMatcher() {
@@ -39,80 +39,107 @@ public boolean matches(HttpRequest request) {
             }
         }, new TestHttpResponse(200, "body"));
 
-        HttpClient.setWebViewUserAgent(null);
         Robolectric.getBackgroundScheduler().pause();
         Robolectric.clearPendingHttpResponses();
     }
 
     @After
     public void tearDown() throws Exception {
-        HttpClient.setWebViewUserAgent(null);
         Robolectric.getBackgroundScheduler().reset();
         Robolectric.clearPendingHttpResponses();
     }
 
     @Test
     public void initializeHttpGet_shouldReturnHttpGetWithWebViewUserAgent() throws Exception {
+        Networking.setUserAgentForTesting(null);
         HttpGet httpGet = initializeHttpGet(url, context);
 
         assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
-        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(userAgent);
+        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(
+                userAgent);
     }
 
     @Test
-    public void initializeHttpGet_shouldPopulateStaticWebViewUserAgent() throws Exception {
-        assertThat(HttpClient.getWebViewUserAgent()).isNull();
+    public void initializeHttpGet_withNullContext_shouldUseCachedUserAgent() throws Exception {
+        Networking.setUserAgentForTesting("cached");
+        HttpGet httpGet = initializeHttpGet("http://www.mopub.com/");
+        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(
+                "cached");
+    }
 
-        HttpGet httpGet = initializeHttpGet(url, context);
+    @Test
+    public void initializeHttpGet_shouldProperlyEncodeUrl() throws Exception {
+        HttpGet httpGet = initializeHttpGet("http://host:80/doc|search?q=green robots#over 6\"");
+        assertThat(httpGet.getURI().toString())
+                .isEqualTo("http://host:80/doc%7Csearch?q=green%20robots#over%206%22");
+    }
 
-        assertThat(HttpClient.getWebViewUserAgent()).isEqualTo(userAgent);
+    @Test(expected = IllegalArgumentException.class)
+    public void initializeHttpGet_withImproperlyEncodedUrl_shouldThrowIllegalArgumentException() throws Exception {
+        initializeHttpGet("http://user:passwrd@host:80/doc%7ZZZC");
     }
 
-    @Test
-    public void initializeHttpGet_withNullUrl_shouldThrowNullPointerException() throws Exception {
-        try {
-            HttpGet httpGet = initializeHttpGet(null, context);
-            fail("Expecting null pointer expection to be thrown");
-        } catch (NullPointerException e) {
-            // pass
-        }
+    @Test(expected = IllegalArgumentException.class)
+    public void initializeHttpGet_withMalformedUrl_shouldThrowIllegalArgumentException() throws Exception {
+        initializeHttpGet("bad://host:80/doc|search?q=green robots#over 6\"");
     }
 
     @Test
-    public void initializeHttpGet_withNullContext_shouldNotPopulateUserAgentHeader() throws Exception {
-        HttpGet httpGet = initializeHttpGet(url, null);
+    public void urlEncode_shouldProperlyEncodeUrls() throws Exception {
+        // Example url borrowed from: http://developer.android.com/reference/java/net/URI.html
+        assertThat(urlEncode("http://user:passwrd@host:80/doc|search?q=green robots#over 6\""))
+                .isEqualTo("http://user:passwrd@host:80/doc%7Csearch?q=green%20robots#over%206%22");
 
-        assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
-        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey())).isNull();
+        assertThat(urlEncode("http://www.example.com/?key=value\"\"&key2=value2?"))
+                .isEqualTo("http://www.example.com/?key=value%22%22&key2=value2?");
+
+        assertThat(urlEncode("http://user:passwrd@host:80/doc?q=green#robots"))
+                .isEqualTo("http://user:passwrd@host:80/doc?q=green#robots");
+
+        assertThat(urlEncode("http://rtr.innovid.com/r1.5460f51c393410.96367393;cb=[timestamp]"))
+                .isEqualTo("http://rtr.innovid.com/r1.5460f51c393410.96367393;cb=%5Btimestamp%5D");
     }
 
     @Test
-    public void makeTrackingHttpRequest_shouldMakeTrackingHttpRequestWithWebViewUserAgent() throws Exception {
-        HttpClient.makeTrackingHttpRequest(url, context);
+    public void urlEncode_withProperlyEncodedUrl_shouldReturnUrlWithSameEncoding() throws Exception {
+        assertThat(urlEncode("http://user:passwrd@host:80/doc%7Csearch?q=green%20robots#over%206%22"))
+                .isEqualTo("http://user:passwrd@host:80/doc%7Csearch?q=green%20robots#over%206%22");
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
+        assertThat(urlEncode("https://www.mywebsite.com%2Fd+ocs%2Fenglish%2Fsite%2Fmybook.do%3Fkey%3Dvalue%3B%23fragment"))
+                .isEqualTo(
+                        "https://www.mywebsite.com%2Fd+ocs%2Fenglish%2Fsite%2Fmybook.do%3Fkey%3Dvalue%3B%23fragment");
+    }
 
-        CommonUtils.assertHttpRequestsMade(userAgent, url);
+    @Test(expected = Exception.class)
+    public void urlEncode_withImproperlyEncodedUrl_shouldThowException() throws Exception {
+        urlEncode("http://user:passwrd@host:80/doc%7ZZZC");
     }
 
-    @Test
-    public void makeTrackingHttpRequest_withNullUrl_shouldNotMakeTrackingHttpRequest() throws Exception {
-        HttpClient.makeTrackingHttpRequest((String) null, context);
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
+    @Test(expected = Exception.class)
+    public void urlEncode_withImproperlyEncodedUrlScheme_shouldThowException() throws Exception {
+        // From: http://developer.android.com/reference/java/net/URI.html
+        // A URI's host, port and scheme are not eligible for encoding and must not contain illegal characters.
+        urlEncode("https%3A%2F%2Fwww.mywebsite.com%2Fdocs%2Fenglish%2Fsite%2Fmybook.do%3Fkey%3Dvalue%3B%23fragment");
+    }
 
-        CommonUtils.assertHttpRequestsMade(null);
+    @Test(expected = Exception.class)
+    public void urlEncode_withMalformedUrl_shouldThrowException() throws Exception {
+        urlEncode("derp://www.mopub.com/");
     }
 
-    @Test
-    public void makeTrackingHttpRequest_withNullContext_shouldNotMakeTrackingHttpRequest() throws Exception {
-        HttpClient.makeTrackingHttpRequest(url, null);
+    @Test(expected = NullPointerException.class)
+    public void initializeHttpGet_withNullUrl_shouldThrowNullPointerException() throws Exception {
+        initializeHttpGet(null, context);
+    }
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
+    @Test
+    public void initializeHttpGet_withNullContext_shouldPopulateUserAgentHeaderWithCachedValue() throws Exception {
+        Networking.setUserAgentForTesting("cached");
+        HttpGet httpGet = initializeHttpGet(url, null);
 
-        CommonUtils.assertHttpRequestsMade(null);
+        assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
+        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(
+                "cached");
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
new file mode 100644
index 00000000..41e8f54c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
@@ -0,0 +1,72 @@
+package com.mopub.common;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.webkit.CookieSyncManager;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubBrowserTest {
+
+    private MoPubBrowser subject;
+    private WebView mockWebView;
+
+    @Before
+    public void setUp() {
+        subject = Robolectric.buildActivity(MoPubBrowser.class).create().get();
+        CookieSyncManager.createInstance(subject);
+
+        mockWebView = mock(WebView.class);
+        subject.setWebView(mockWebView);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onPause_withIsFinishingTrue_shouldStopLoading_shouldLoadBlankUrl_shouldPauseWebView() throws Exception {
+        // We have to manually call #onPause here after #finish since the activity is not being managed by Android
+        // Even if the activity was being managed by Android we would likely have to call onPause since the test would
+        // complete before the UI thread had a chance to invoke the lifecycle events
+        subject.finish();
+        subject.onPause();
+
+        verify(mockWebView).stopLoading();
+        verify(mockWebView).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onPause_withIsFinishingFalse_shouldPauseWebView() throws Exception {
+        subject.onPause();
+
+        verify(mockWebView, never()).stopLoading();
+        verify(mockWebView, never()).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onResume_shouldResumeWebView() throws Exception {
+        subject.onResume();
+
+        verify(mockWebView).onResume();
+    }
+
+    @Test
+    public void onDestroy_shouldDestroyWebView() throws Exception {
+        subject.onDestroy();
+
+        verify(mockWebView).destroy();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
new file mode 100644
index 00000000..d70faa57
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
@@ -0,0 +1,889 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK;
+import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK;
+import static com.mopub.common.UrlAction.HANDLE_MOPUB_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_PHONE_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_SHARE_TWEET;
+import static com.mopub.common.UrlAction.IGNORE_ABOUT_SCHEME;
+import static com.mopub.common.UrlAction.NOOP;
+import static com.mopub.common.UrlAction.OPEN_APP_MARKET;
+import static com.mopub.common.UrlAction.OPEN_IN_APP_BROWSER;
+import static com.mopub.common.UrlAction.OPEN_NATIVE_BROWSER;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class UrlHandlerTest {
+    private Context context;
+    @Mock private UrlHandler.ResultActions mockResultActions;
+    @Mock private UrlHandler.MoPubSchemeListener mockMoPubSchemeListener;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubBrowser_shouldCallOnClickSuccessButNotStartActivity() {
+        final String url = "http://www.mopub.com/";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(OPEN_IN_APP_BROWSER)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .withoutMoPubBrowser()
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeFinishLoad_shouldCallOnFinishLoad() {
+        final String url = "mopub://finishLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockMoPubSchemeListener).onFinishLoad();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeClose_shouldCallOnClose() {
+        final String url = "mopub://close";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockMoPubSchemeListener).onClose();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeFailLoad_shouldCallOnFailLoad() {
+        final String url = "mopub://failLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockMoPubSchemeListener).onFailLoad();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingAboutSchemeUrl_shouldIgnoreClick() {
+        final String url = "about:blank";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        HANDLE_MOPUB_SCHEME,
+                        IGNORE_ABOUT_SCHEME,
+                        HANDLE_PHONE_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeTelUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("tel:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeVoicemailUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("voicemail:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeSMSUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("sms:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeMailToUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("mailto:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeGeoUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("geo:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeStreetViewUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("google.streetview:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeUrl_shouldStartActivity() {
+        final String url = "tel:1234567890";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(url));
+    }
+
+    @Test
+    public void urlHandler_withValidNativeBrowserUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String urlToLoad = "http://www.mopub.com/";
+        final String url = "mopubnativebrowser://navigate?url=" + urlToLoad;
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_NATIVE_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(urlToLoad));
+    }
+
+    @Test
+    public void urlHandler_withMatchingInAppBrowserHttpUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String url = "http://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+    }
+
+    @Test
+    public void urlHandler_withMatchingInAppBrowserHttpsUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String url = "https://www.mopub.com/";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+    }
+
+    @Test
+    public void urlHandler_withMatchingShareUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String shareTweetUrl = "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, shareTweetUrl, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(shareTweetUrl, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
+    }
+
+    @Test
+    public void urlHandler_withMatchingDeepLinkUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String deepLinkUrl = "appscheme://host";
+        makeDeeplinkResolvable(deepLinkUrl);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, deepLinkUrl, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(deepLinkUrl, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(deepLinkUrl));
+    }
+
+    @Test
+    public void urlHandler_withMatchingDeeplinkPlus_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String primaryUrl = "twitter://timeline";
+        final String deeplinkPlusUrl = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl);
+        makeDeeplinkResolvable("twitter://timeline");
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, deeplinkPlusUrl, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(deeplinkPlusUrl, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(primaryUrl));
+    }
+
+    @Test
+    public void urlHandler_withMatchingUnresolvableDeeplinkPlus_withResolvableFallback_shouldResolveRedirects_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "http://www.twitter.com";
+        final String fallbackUrlAfterRedirects = "https://twitter.com/";
+        final String deeplinkPlusUrl = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK, OPEN_IN_APP_BROWSER)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, deeplinkPlusUrl);
+
+        Robolectric.runBackgroundTasks();
+        verify(mockResultActions).urlHandlingSucceeded(fallbackUrlAfterRedirects,
+                OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
+                .isEqualTo(fallbackUrlAfterRedirects);
+    }
+
+    @Test
+    public void urlHandler_withMatchingUnresolvableDeeplinkPlus_withUnresolvableFallback_shouldDoNothing() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "unresolvableUrl";
+        final String deeplinkPlusUrl = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, deeplinkPlusUrl, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(fallbackUrl, NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_shouldTriggerPrimaryTracker() {
+        final String primaryUrl = "twitter://timeline";
+        final String primaryTracker = "http://ads.twitter.com/tracking?pubId=1234&userId=5678";
+        final String fallbackUrl = "http://twitter.com";
+        final String fallbackTracker =
+                "http://ads.twitter.com/fallbackTracking?pubId=1234&userId=5678";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&primaryTrackingUrl=" + Uri.encode(primaryTracker)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl)
+                + "&fallbackTrackingUrl=" + Uri.encode(fallbackTracker);
+        makeDeeplinkResolvable(primaryUrl);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockRequestQueue).add(argThat(isUrl(primaryTracker)));
+        verify(mockRequestQueue, never()).add(argThat(isUrl(fallbackTracker)));
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_shouldTriggerMultiplePrimaryTrackers() {
+        final String primaryUrl = "twitter://timeline";
+        final String primaryTracker1 = "http://ads.twitter.com/tracking?pubId=1234&userId=5678";
+        final String primaryTracker2 = "http://ads.mopub.com/tracking?pubId=4321&userId=8765";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&primaryTrackingUrl=" + Uri.encode(primaryTracker1)
+                + "&primaryTrackingUrl=" + Uri.encode(primaryTracker2);
+        makeDeeplinkResolvable(primaryUrl);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockRequestQueue).add(argThat(isUrl(primaryTracker1)));
+        verify(mockRequestQueue).add(argThat(isUrl(primaryTracker2)));
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_withResolvableFallback_shouldTriggerFallbackTracker() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "http://twitter.com";
+        final String primaryTracker = "http://ads.twitter.com/tracking?pubId=1234&userId=5678";
+        final String fallbackTracker =
+                "http://ads.twitter.com/fallbackTracking?pubId=1234&userId=5678";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&primaryTrackingUrl=" + Uri.encode(primaryTracker)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl)
+                + "&fallbackTrackingUrl=" + Uri.encode(fallbackTracker);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK, OPEN_IN_APP_BROWSER)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockRequestQueue).add(argThat(isUrl(fallbackTracker)));
+        verify(mockRequestQueue, never()).add(argThat(isUrl(primaryTracker)));
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_withResolvableFallback_shouldTriggerMultiplePrimaryTrackers() {
+        final String primaryUrl = "missingApp://somePath";
+        final String fallbackUrl = "http://twitter.com";
+        final String fallbackTracker1 = "http://ads.twitter.com/tracking?pubId=1234&userId=5678";
+        final String fallbackTracker2 = "http://ads.mopub.com/tracking?pubId=4321&userId=8765";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(primaryUrl)
+                + "&fallbackUrl=" + Uri.encode(fallbackUrl)
+                + "&fallbackTrackingUrl=" + Uri.encode(fallbackTracker1)
+                + "&fallbackTrackingUrl=" + Uri.encode(fallbackTracker2);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK, OPEN_IN_APP_BROWSER)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockRequestQueue).add(argThat(isUrl(fallbackTracker1)));
+        verify(mockRequestQueue).add(argThat(isUrl(fallbackTracker2)));
+    }
+
+    @Test
+    public void urlHandler_withUppercasedDeeplinkPlus_shouldBeHandled() {
+        final String primaryUrl = "twitter://timeline";
+        final String url = "DeEpLiNk+://navigate?primaryUrl=" + Uri.encode(primaryUrl);
+        makeDeeplinkResolvable(primaryUrl);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+    }
+
+    @Test
+    public void urlHandler_withdDeeplinkPlus_withUppercasedNavigate_shouldBeHandled() {
+        final String primaryUrl = "twitter://timeline";
+        final String url = "deeplink+://NaViGaTe?primaryUrl=" + Uri.encode(primaryUrl);
+        makeDeeplinkResolvable(primaryUrl);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeeplinkPlus_shouldDoNothing() {
+        final String url = "NOTdeeplink+://navigate?primaryUrl=twitter%3A%2F%2Ftimeline";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_withoutNavigate_shouldDoNothing() {
+        final String url = "deeplink+://NOTnavigate?primaryUrl=twitter%3A%2F%2Ftimeline";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withNestedDeeplinkPlus_shouldDoNothing() {
+        final String deeplink = "deeplink+://navigate?primaryUrl=twitter%3A%2F%2Ftimeline";
+        final String url = "deeplink+://navigate?primaryUrl=" + Uri.encode(deeplink);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_withDeeplinkPlusAsFallback_shouldDoNothing() {
+        final String deeplink = "deeplink+://navigate?primaryUrl=twitter%3A%2F%2Ftimeline";
+        final String url = "deeplink+://navigate?primaryUrl=missingApp%3A%2F%2FsomePath"
+                + "&fallbackUrl=" + Uri.encode(deeplink);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_withInvalidPrimaryUrl_shouldDoNothing() {
+        final String url = "deeplink+://navigate?primaryUrl=INVALID";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withDeeplinkPlus_withDecodedPrimaryUrl_shouldDoNothing() {
+        final String url = "deeplink+://navigate?primaryUrl=twitter://timeline";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK_WITH_FALLBACK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK_WITH_FALLBACK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withDualMatchingUnresolvableUrlActions_shouldCallOnClickFailOnLastMatchedAction() {
+        final String url = "mopub://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withShareTweetAndDeepLink_shouldCallOnClickFailOnLastMatchedDeepLink() {
+        final String url = "mopubshare://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withNoConfiguration_shouldDoNothing() {
+        new UrlHandler.Builder().build().handleResolvedUrl(context, "", true, null);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutDestinationUrl_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, "", true, null);
+
+        verify(mockResultActions).urlHandlingFailed("", NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutSupportedUrlActions_shouldNotError() {
+        new UrlHandler.Builder()
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, "about:blank", true, null);
+
+        verify(mockResultActions).urlHandlingFailed("about:blank", NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutClickListener_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, "about:blank", true, null);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubSchemeListener_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, "about:blank", true, null);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubBrowser_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .withoutMoPubBrowser()
+                .build().handleResolvedUrl(context, "about:blank", true, null);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingAboutSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(IGNORE_ABOUT_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingMoPubSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_MOPUB_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeepLinkUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(FOLLOW_DEEP_LINK);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingInAppBrowserUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(OPEN_IN_APP_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingPhoneSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_PHONE_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingNativeBrowserUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(OPEN_NATIVE_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingShareTweetUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_SHARE_TWEET);
+    }
+
+    /**
+     * For the next few unit tests urlHandler_withoutMatching[some]UrlAction_shouldCallOnClickFail,
+     * do not include FOLLOW_DEEP_LINK, since it would be a catch-all and trigger urlHandlingSucceeded.
+     */
+
+    @Test
+    public void urlHandler_withoutMatchingAboutSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("about:blank", HANDLE_MOPUB_SCHEME,
+                OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingMoPubSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("mopub://close", IGNORE_ABOUT_SCHEME,
+                OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeepLinkUrlAction_shouldCallUrlHandlingFailed() {
+        final String deepLinkUrl = "appscheme://host";
+        makeDeeplinkResolvable(deepLinkUrl);
+        assertCallbackWithoutMatchingSupportedUrlAction(deepLinkUrl, IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER,
+                HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingInAppBrowserUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("https://some_url", IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingPhoneSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("tel:1234567890", IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingNativeBrowserUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("mopubnativebrowser://navigate?url=some_url",
+                IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME,
+                HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingShareTweetUrlAction_shouldCallUrlHandlingFailed() {
+        final String shareTweetUrl = "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802";
+        assertCallbackWithoutMatchingSupportedUrlAction(shareTweetUrl, HANDLE_MOPUB_SCHEME,
+                IGNORE_ABOUT_SCHEME, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, OPEN_APP_MARKET,
+                OPEN_IN_APP_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withNullDestinationURL_shouldDoNothing() {
+        final String nullUrl = null;
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, nullUrl, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(nullUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withEmptyDestinationURL_shouldDoNothing() {
+        final String emptyUrl = "";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, emptyUrl, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(emptyUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withInvalidDestinationURL_shouldDoNothing() {
+        final String invalidUrl = "some_invalid_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, invalidUrl, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(invalidUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeWithoutMoPubSchemeListener_shouldDoNothing() {
+        final String url = "mopub://finishLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withInvalidMoPubSchemeCustom_shouldNotError() {
+        final String url = "mopub://custom?INVALID";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_MOPUB_SCHEME);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withInvalidNativeBrowserUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubnativebrowser://INVALID";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(OPEN_NATIVE_BROWSER)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, OPEN_NATIVE_BROWSER);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withInvalidHostInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMissingQueryParametersInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://tweet?x=1&y=2";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withEmptyQueryParametersInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://tweet?screen_name=&tweet_id=";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingUnresolvableDeepLinkUrl_shouldCallUrlHandlingFailed() {
+        final String deepLinkUrl = "appscheme://host";
+        // The following code would make this url resolvable, so avoiding it to test for an
+        // unresolvable url (yet included for documentation purposes).
+        //makeDeeplinkResolvable(deepLinkUrl);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, deepLinkUrl, true, null);
+
+        verify(mockResultActions).urlHandlingFailed(deepLinkUrl, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    private void assertPhoneSchemeCallback(@NonNull final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_PHONE_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, HANDLE_PHONE_SCHEME);
+        verifyNoMoreCallbacks();
+    }
+
+    private void assertCallbackWithoutMatchingUrl(@NonNull final UrlAction urlAction) {
+        final String url = "non://matching_url";
+        UrlAction expectedFailUrlAction = NOOP;
+
+        if (urlAction.equals(FOLLOW_DEEP_LINK)) {
+            expectedFailUrlAction = FOLLOW_DEEP_LINK;
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(urlAction)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+        verify(mockResultActions).urlHandlingFailed(url, expectedFailUrlAction);
+        verifyNoMoreCallbacks();
+    }
+
+    private void assertCallbackWithoutMatchingSupportedUrlAction(@NonNull final String url,
+            @NonNull final UrlAction... otherTypes) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(NOOP, otherTypes)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleResolvedUrl(context, url, true, null);
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    private void verifyNoMoreCallbacks() {
+        verifyNoMoreInteractions(mockResultActions);
+        verifyNoMoreInteractions(mockMoPubSchemeListener);
+    }
+
+    private void verifyNoStartedActivity() {
+        assertThat(Robolectric.getShadowApplication().peekNextStartedActivity()).isNull();
+    }
+
+    private void makeDeeplinkResolvable(String deeplink) {
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deeplink)), new ResolveInfo());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/VolleyRequestMatcher.java b/mopub-sdk/src/test/java/com/mopub/common/VolleyRequestMatcher.java
new file mode 100644
index 00000000..8afeb57d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/VolleyRequestMatcher.java
@@ -0,0 +1,33 @@
+package com.mopub.common;
+
+import android.support.annotation.Nullable;
+
+import com.mopub.volley.Request;
+
+import org.mockito.ArgumentMatcher;
+
+/**
+ * A Mockito Request Matcher, used in tests to allow verifying that Volley Requests match a given
+ * url.
+ *
+ * "verify(mock).add(argThat(VolleyRequestMatcher.isUrl("testUrl")));"
+ */
+public class VolleyRequestMatcher extends ArgumentMatcher<Request> {
+
+     @Nullable private final String mUrl;
+
+     private VolleyRequestMatcher(@Nullable final String url) {
+         mUrl = url;
+     }
+
+     public static VolleyRequestMatcher isUrl(@Nullable String url) {
+         return new VolleyRequestMatcher(url);
+     }
+
+     @Override
+     public boolean matches(final Object that) {
+         return that instanceof Request
+                 && ((this.mUrl == null && ((Request) that).getUrl() == null)
+                    || ((Request) that).getUrl().equals(mUrl));
+     }
+ }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
new file mode 100644
index 00000000..55a087f4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
@@ -0,0 +1,244 @@
+package com.mopub.common.event;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class BaseEventTest {
+
+    private BaseEvent subject;
+    @Mock private ClientMetadata mockClientMetaData;
+
+    @Before
+    public void setUp() {
+        when(mockClientMetaData.getSdkVersion()).thenReturn("sdk_version");
+        when(mockClientMetaData.getAppName()).thenReturn("app_name");
+        when(mockClientMetaData.getAppPackageName()).thenReturn("app_package_name");
+        when(mockClientMetaData.getAppVersion()).thenReturn("app_version");
+        when(mockClientMetaData.getDeviceId()).thenReturn("client_device_id");
+        when(mockClientMetaData.isDoNotTrackSet()).thenReturn(true);
+        when(mockClientMetaData.getDeviceManufacturer()).thenReturn("device_manufacturer");
+        when(mockClientMetaData.getDeviceModel()).thenReturn("device_model");
+        when(mockClientMetaData.getDeviceProduct()).thenReturn("device_product");
+        when(mockClientMetaData.getDeviceOsVersion()).thenReturn("device_os_version");
+        when(mockClientMetaData.getDeviceScreenWidthDip()).thenReturn(1337);
+        when(mockClientMetaData.getDeviceScreenHeightDip()).thenReturn(70707);
+        when(mockClientMetaData.getActiveNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockClientMetaData.getNetworkOperator()).thenReturn("network_operator");
+        when(mockClientMetaData.getNetworkOperatorName()).thenReturn("network_operator_name");
+        when(mockClientMetaData.getIsoCountryCode()).thenReturn("network_iso_country_code");
+        when(mockClientMetaData.getSimOperator()).thenReturn("network_sim_operator");
+        when(mockClientMetaData.getSimOperatorName()).thenReturn("network_sim_operator_name");
+        when(mockClientMetaData.getSimIsoCountryCode()).thenReturn("network_sim_iso_country_code");
+        ClientMetadata.setInstance(mockClientMetaData);
+
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withSdkProduct(BaseEvent.SdkProduct.NATIVE)
+                .withAdUnitId("8cf00598d3664adaaeccd800e46afaca")
+                .withAdCreativeId("3c2b887e2c2a4cd0ae6a925440a62f0d")
+                .withAdType("html")
+                .withAdNetworkType("admob")
+                .withAdWidthPx(320.0)
+                .withAdHeightPx(50.0)
+                .withGeoLat(37.7833)
+                .withGeoLon(-122.4183333)
+                .withGeoAccuracy(10.0)
+                .withPerformanceDurationMs(100.0)
+                .withRequestId("b550796074da4559a27c5072dcba2b27")
+                .withRequestStatusCode(200)
+                .withRequestUri("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")
+                .withRequestRetries(0)
+                .build();
+    }
+
+    @After
+    public void tearDown() {
+        ClientMetadata.setInstance(null);
+    }
+
+    @Test
+    public void ScribeCategory_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT.getCategory())
+                .isEqualTo("exchange_client_event");
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR.getCategory())
+                .isEqualTo("exchange_client_error");
+    }
+
+    @Test
+    public void SdkProduct_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SdkProduct.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.SdkProduct.WEB_VIEW.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.SdkProduct.NATIVE.getType())
+                .isEqualTo(2);
+    }
+
+    @Test
+    public void AppPlatform_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.AppPlatform.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.AppPlatform.IOS.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.AppPlatform.ANDROID.getType())
+                .isEqualTo(2);
+        assertThat(BaseEvent.AppPlatform.MOBILE_WEB.getType())
+                .isEqualTo(3);
+    }
+
+    @Test
+    public void Name_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Name.AD_REQUEST.getName())
+                .isEqualTo("ad_request");
+        assertThat(BaseEvent.Name.IMPRESSION_REQUEST.getName())
+                .isEqualTo("impression_request");
+        assertThat(BaseEvent.Name.CLICK_REQUEST.getName())
+                .isEqualTo("click_request");
+    }
+
+    @Test
+    public void Category_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Category.REQUESTS.getCategory())
+                .isEqualTo("requests");
+    }
+
+    @Test
+    public void SamplingRate_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate()).isEqualTo(0.1);
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
+        assertThat(subject.getSdkProduct()).isEqualTo(BaseEvent.SdkProduct.NATIVE);
+        assertThat(subject.getAdUnitId()).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
+        assertThat(subject.getAdCreativeId()).isEqualTo("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        assertThat(subject.getAdType()).isEqualTo("html");
+        assertThat(subject.getAdNetworkType()).isEqualTo("admob");
+        assertThat(subject.getAdWidthPx()).isEqualTo(320.0);
+        assertThat(subject.getAdHeightPx()).isEqualTo(50.0);
+        assertThat(subject.getGeoLat()).isEqualTo(37.7833);
+        assertThat(subject.getGeoLon()).isEqualTo(-122.4183333);
+        assertThat(subject.getGeoAccuracy()).isEqualTo(10.0);
+        assertThat(subject.getPerformanceDurationMs()).isEqualTo(100.0);
+        assertThat(subject.getRequestId()).isEqualTo("b550796074da4559a27c5072dcba2b27");
+        assertThat(subject.getRequestStatusCode()).isEqualTo(200);
+        assertThat(subject.getRequestUri()).isEqualTo("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        assertThat(subject.getRequestRetries()).isEqualTo(0);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+    }
+
+    @Test
+    public void getSdkVersion_shouldReturnClientMetaDataSdkVersion() throws Exception {
+        assertThat(subject.getSdkVersion()).isEqualTo("sdk_version");
+    }
+
+    @Test
+    public void getAppName_shouldReturnClientMetaDataAppName() throws Exception {
+        assertThat(subject.getAppName()).isEqualTo("app_name");
+    }
+
+    @Test
+    public void getAppPackageName_shouldReturnClientMetaDataAppPackageName() throws Exception {
+        assertThat(subject.getAppPackageName()).isEqualTo("app_package_name");
+    }
+
+    @Test
+    public void getAppVersion_shouldReturnClientMetaDataAppVersion() throws Exception {
+        assertThat(subject.getAppVersion()).isEqualTo("app_version");
+    }
+
+    @Test
+    public void getClientAdvertisingId_shouldReturnClientMetaDataDeviceId() throws Exception {
+        assertThat(subject.getClientAdvertisingId()).isEqualTo("client_device_id");
+    }
+
+    @Test
+    public void getObfuscatedClientAdvertisingId_shouldReturnObfuscatedDeviceId() throws Exception {
+        assertThat(subject.getObfuscatedClientAdvertisingId()).isEqualTo("ifa:XXXX");
+    }
+
+    @Test
+    public void getClientDoNotTrack_shouldReturnClientMetaDataDoNotTrack() throws Exception {
+        assertThat(subject.getClientDoNotTrack()).isEqualTo(true);
+    }
+
+    @Test
+    public void getDeviceManufacturer_shouldReturnClientMetaDataDeviceManufacturer() throws Exception {
+        assertThat(subject.getDeviceManufacturer()).isEqualTo("device_manufacturer");
+    }
+
+    @Test
+    public void getDeviceModel_shouldReturnClientMetaDataDeviceModel() throws Exception {
+        assertThat(subject.getDeviceModel()).isEqualTo("device_model");
+    }
+
+    @Test
+    public void getDeviceProduct_shouldReturnClientMetaDataDeviceProduct() throws Exception {
+        assertThat(subject.getDeviceProduct()).isEqualTo("device_product");
+    }
+
+    @Test
+    public void getDeviceOsVersion_shouldReturnClientMetaDataDeviceOsVersion() throws Exception {
+        assertThat(subject.getDeviceOsVersion()).isEqualTo("device_os_version");
+    }
+
+    @Test
+    public void getDeviceScreenWidthDip_shouldReturnClientMetaDataDeviceScreenWidthDip() throws Exception {
+        assertThat(subject.getDeviceScreenWidthDip()).isEqualTo(1337);
+    }
+
+    @Test
+    public void getDeviceScreenHeightDip_shouldReturnClientMetaDataDeviceScreenHeightDip() throws Exception {
+        assertThat(subject.getDeviceScreenHeightDip()).isEqualTo(70707);
+    }
+
+    @Test
+    public void getNetworkType_shouldReturnClientMetaDataActiveNetworkType() throws Exception {
+        assertThat(subject.getNetworkType()).isEqualTo(ClientMetadata.MoPubNetworkType.WIFI);
+    }
+
+    @Test
+    public void getNetworkOperatorCode_shouldReturnClientMetaDataNetworkOperator() throws Exception {
+        assertThat(subject.getNetworkOperatorCode()).isEqualTo("network_operator");
+    }
+
+    @Test
+    public void getNetworkOperatorName_shouldReturnClientMetaDataNetworkOperatorName() throws Exception {
+        assertThat(subject.getNetworkOperatorName()).isEqualTo("network_operator_name");
+    }
+
+    @Test
+    public void getNetworkIsoCountryCode_shouldReturnClientMetaDataNetworkIsoCountryCode() throws Exception {
+        assertThat(subject.getNetworkIsoCountryCode()).isEqualTo("network_iso_country_code");
+    }
+
+    @Test
+    public void getNetworkSimCode_shouldReturnClientMetaDataNetworkSimOperator() throws Exception {
+        assertThat(subject.getNetworkSimCode()).isEqualTo("network_sim_operator");
+    }
+
+    @Test
+    public void getNetworkSimOperatorName_shouldReturnClientMetaDataNetworkSimOperatorName() throws Exception {
+        assertThat(subject.getNetworkSimOperatorName()).isEqualTo("network_sim_operator_name");
+    }
+
+    @Test
+    public void getNetworkSimIsoCountryCode_shouldReturnClientMetaDataNetworkSimIsoCountryCode() throws Exception {
+        assertThat(subject.getNetworkSimIsoCountryCode()).isEqualTo("network_sim_iso_country_code");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
new file mode 100644
index 00000000..05cd07f6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
@@ -0,0 +1,74 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class ErrorEventTest {
+
+    private ErrorEvent subject;
+
+    @Before
+    public void setUp() {
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withErrorExceptionClassName("error_exception_class_name")
+                .withErrorMessage("error_message")
+                .withErrorStackTrace("error_stack_trace")
+                .withErrorFileName("error_file_name")
+                .withErrorClassName("error_class_name")
+                .withErrorMethodName("error_method_name")
+                .withErrorLineNumber(123)
+                .build();
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
+        assertThat(subject.getErrorExceptionClassName()).isEqualTo("error_exception_class_name");
+        assertThat(subject.getErrorMessage()).isEqualTo("error_message");
+        assertThat(subject.getErrorStackTrace()).isEqualTo("error_stack_trace");
+        assertThat(subject.getErrorFileName()).isEqualTo("error_file_name");
+        assertThat(subject.getErrorClassName()).isEqualTo("error_class_name");
+        assertThat(subject.getErrorMethodName()).isEqualTo("error_method_name");
+        assertThat(subject.getErrorLineNumber()).isEqualTo(123);
+    }
+
+    @Test
+    public void builder_withException_shouldCorrectlyPopulateErrorFields() throws Exception {
+        Exception exception;
+        try {
+            throw new ClassCastException("bad cast");
+        } catch (Exception e)  {
+            exception = e;
+        }
+
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withException(exception)
+                .build();
+
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
+        assertThat(subject.getErrorExceptionClassName()).isEqualTo("java.lang.ClassCastException");
+        assertThat(subject.getErrorMessage()).isEqualTo("bad cast");
+
+        // We can't reliably check the stack trace since it changes from one run to another
+//        assertThat(subject.getErrorStackTrace()).isEqualTo();
+
+        assertThat(subject.getErrorFileName()).isEqualTo("ErrorEventTest.java");
+        assertThat(subject.getErrorClassName()).isEqualTo("com.mopub.common.event.ErrorEventTest");
+        assertThat(subject.getErrorMethodName()).isEqualTo("builder_withException_shouldCorrectlyPopulateErrorFields");
+
+        // Ideally we check the actual line number here, but since this file is continuously
+        // changing, it makes the test brittle to do so
+        assertThat(subject.getErrorLineNumber()).isNotNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
new file mode 100644
index 00000000..1c32fd16
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
@@ -0,0 +1,64 @@
+package com.mopub.common.event;
+
+import android.app.Activity;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+
+@RunWith(SdkTestRunner.class)
+public class EventDispatcherTest {
+
+    private EventDispatcher subject;
+    private List<EventRecorder> recorders;
+    @Mock private EventRecorder mockEventRecorder1;
+    @Mock private EventRecorder mockEventRecorder2;
+    @Mock private HandlerThread mockHandlerThread;
+
+    @Before
+    public void setUp() {
+        recorders = new ArrayList<EventRecorder>();
+        recorders.add(mockEventRecorder1);
+        recorders.add(mockEventRecorder2);
+    }
+
+    @Test
+    public void handler_handleMessage_shouldCallRecordOnAllRecorders() throws Exception {
+        Message message = new Message();
+        message.obj = mock(Event.class);
+
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
+        subject.getHandlerCallback().handleMessage(message);
+
+        verify(mockEventRecorder1).record(eq((Event) message.obj));
+        verify(mockEventRecorder2).record(eq((Event) message.obj));
+    }
+
+    @Test
+    public void handler_handleMessage_withNonBaseEventTypeMessageShouldNotRecordOnAnyRecorders() throws Exception {
+        Message message = new Message();
+        message.obj = mock(Activity.class);
+
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
+        subject.getHandlerCallback().handleMessage(message);
+
+        verify(mockEventRecorder1, never()).record(any(BaseEvent.class));
+        verify(mockEventRecorder2, never()).record(any(BaseEvent.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventHandlerTest.java
deleted file mode 100644
index 8c2d338c..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventHandlerTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.mopub.common.event;
-
-import android.os.HandlerThread;
-import android.os.Message;
-
-import com.mopub.common.ClientMetadata;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.apache.http.HttpStatus;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-
-@RunWith(SdkTestRunner.class)
-public class EventHandlerTest {
-
-    private EventRecorder testRecorder;
-    private MoPubEvents.EventDispatcher subject;
-    private HandlerThread testHandlerThread;
-
-    @Before
-    public void setup() {
-        // Set up test event recorders and test handler thread.
-        List<EventRecorder> recorders = new ArrayList<EventRecorder>();
-        testRecorder = mock(EventRecorder.class);
-        recorders.add(testRecorder);
-        testHandlerThread = new HandlerThread("mopub-test-events");
-        subject = new MoPubEvents.EventDispatcher(recorders, testHandlerThread);
-        // The test runner uses a mock dispatcher that does nothing.
-        MoPubEvents.setEventDispatcher(subject);
-    }
-
-    @Test
-    public void createEvent_testCallbackCallsHandler() throws Exception {
-        Message message = new Message();
-        message.obj = new Event(BaseEvent.Type.DATA_ERROR, "Test URL", ClientMetadata.getInstance());
-        subject.mHandlerCallback.handleMessage(message);
-        verify(testRecorder).recordEvent(eq((Event) message.obj));
-    }
-
-    @Test
-    public void createTimedEvent_testCallbackCallsHandler() throws Exception {
-        Message message = new Message();
-        message.obj = new TimedEvent(BaseEvent.Type.DATA_ERROR, "Test URL", ClientMetadata.getInstance(), null);
-        ((TimedEvent) message.obj).stop(HttpStatus.SC_OK);
-        subject.mHandlerCallback.handleMessage(message);
-        verify(testRecorder).recordTimedEvent((TimedEvent) eq(message.obj));
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
new file mode 100644
index 00000000..d6494a11
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
@@ -0,0 +1,45 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.Random;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class EventSamplerTest {
+
+    private EventSampler subject;
+    @Mock Random mockRandom;
+    @Mock BaseEvent mockBaseEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSampler(mockRandom);
+        when(mockBaseEvent.getSamplingRate()).thenReturn(0.10);
+    }
+
+    @Test
+    public void sample_withRandomNumberLessThan10Percent_shouldReturnTrue() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void sample_withRandomNumberGreaterOrEqualTo10Percent_shouldReturnFalse() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.10);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
new file mode 100644
index 00000000..22a6bebc
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
@@ -0,0 +1,211 @@
+package com.mopub.common.event;
+
+import android.app.Activity;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class EventSerializerTest {
+
+    private EventSerializer subject;
+    private Activity context;
+
+    @Mock private Event mockEvent;
+    @Mock private ErrorEvent mockErrorEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSerializer();
+
+        // initialize client meta data with context
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        ClientMetadata.getInstance(context);
+
+        populateBaseEventFields(mockEvent);
+        populateBaseEventFields(mockErrorEvent);
+
+        when(mockErrorEvent.getErrorExceptionClassName()).thenReturn("error_exception_class_name");
+        when(mockErrorEvent.getErrorMessage()).thenReturn("error_message");
+        when(mockErrorEvent.getErrorStackTrace()).thenReturn("error_stack_trace");
+        when(mockErrorEvent.getErrorFileName()).thenReturn("error_file_name");
+        when(mockErrorEvent.getErrorClassName()).thenReturn("error_class_name");
+        when(mockErrorEvent.getErrorMethodName()).thenReturn("error_method_name");
+        when(mockErrorEvent.getErrorLineNumber()).thenReturn(123);
+    }
+
+    @Test
+    public void serializeAsJson_withAllEventFieldsPopulated_shouldCorrectJsonRepresentation() throws Exception {
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockEvent);
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(1);
+
+        JSONObject jsonObject = jsonArray.getJSONObject(0);
+        validateBaseEventFields(jsonObject);
+    }
+
+    @Test
+    public void serializeAsJson_withAllErrorEventFieldsPopulated_shouldCorrectJsonRepresentation() throws Exception {
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockErrorEvent);
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(1);
+
+        JSONObject jsonObject = jsonArray.getJSONObject(0);
+        validateBaseEventFields(jsonObject);
+
+        assertThat(jsonObject.getString("error_exception_class_name")).isEqualTo("error_exception_class_name");
+        assertThat(jsonObject.getString("error_message")).isEqualTo("error_message");
+        assertThat(jsonObject.getString("error_stack_trace")).isEqualTo("error_stack_trace");
+        assertThat(jsonObject.getString("error_file_name")).isEqualTo("error_file_name");
+        assertThat(jsonObject.getString("error_class_name")).isEqualTo("error_class_name");
+        assertThat(jsonObject.getString("error_method_name")).isEqualTo("error_method_name");
+        assertThat(jsonObject.getInt("error_line_number")).isEqualTo(123);
+    }
+
+    @Test
+    public void serializeAsJson_shouldReturnJsonArrayOfEvents() throws Exception {
+        when(mockEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockErrorEvent.getName()).thenReturn(BaseEvent.Name.IMPRESSION_REQUEST);
+        when(mockErrorEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockEvent);
+        events.add(mockErrorEvent);
+
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(2);
+
+        JSONObject jsonObject1 = jsonArray.getJSONObject(0);
+        assertThat(jsonObject1.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject1.getString("name_category")).isEqualTo("requests");
+
+        JSONObject jsonObject2 = jsonArray.getJSONObject(1);
+        assertThat(jsonObject2.getString("name")).isEqualTo("impression_request");
+        assertThat(jsonObject2.getString("name_category")).isEqualTo("requests");
+    }
+
+    private void populateBaseEventFields(BaseEvent mockBaseEvent) {
+        when(mockBaseEvent.getScribeCategory()).thenReturn(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
+        when(mockBaseEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockBaseEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockBaseEvent.getSdkProduct()).thenReturn(BaseEvent.SdkProduct.NATIVE);
+        when(mockBaseEvent.getSdkVersion()).thenReturn("3.5.0");
+        when(mockBaseEvent.getAdUnitId()).thenReturn("8cf00598d3664adaaeccd800e46afaca");
+        when(mockBaseEvent.getAdCreativeId()).thenReturn("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        when(mockBaseEvent.getAdType()).thenReturn("html");
+        when(mockBaseEvent.getAdNetworkType()).thenReturn("admob");
+        when(mockBaseEvent.getAdWidthPx()).thenReturn(320.0);
+        when(mockBaseEvent.getAdHeightPx()).thenReturn(50.0);
+        when(mockBaseEvent.getAppPlatform()).thenReturn(BaseEvent.AppPlatform.ANDROID);
+        when(mockBaseEvent.getAppName()).thenReturn("MoPub Sample App");
+        when(mockBaseEvent.getAppPackageName()).thenReturn("com.mopub.simpleadsdemo");
+        when(mockBaseEvent.getAppVersion()).thenReturn("1.0");
+        when(mockBaseEvent.getObfuscatedClientAdvertisingId()).thenCallRealMethod();
+        when(mockBaseEvent.getClientAdvertisingId()).thenReturn("38400000-8cf0-11bd-b23e-10b96e40000d");
+        when(mockBaseEvent.getClientDoNotTrack()).thenReturn(false);
+        when(mockBaseEvent.getDeviceManufacturer()).thenReturn("LGE");
+        when(mockBaseEvent.getDeviceModel()).thenReturn("Nexus 5");
+        when(mockBaseEvent.getDeviceProduct()).thenReturn("hammerhead");
+        when(mockBaseEvent.getDeviceOsVersion()).thenReturn("5.0");
+        when(mockBaseEvent.getDeviceScreenWidthDip()).thenReturn(1080);
+        when(mockBaseEvent.getDeviceScreenHeightDip()).thenReturn(1920);
+        when(mockBaseEvent.getGeoLat()).thenReturn(37.7833);
+        when(mockBaseEvent.getGeoLon()).thenReturn(-122.4183333);
+        when(mockBaseEvent.getGeoAccuracy()).thenReturn(10.0);
+        when(mockBaseEvent.getPerformanceDurationMs()).thenReturn(100.0);
+        when(mockBaseEvent.getNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockBaseEvent.getNetworkOperatorCode()).thenReturn("310410");
+        when(mockBaseEvent.getNetworkOperatorName()).thenReturn("AT&T");
+        when(mockBaseEvent.getNetworkIsoCountryCode()).thenReturn("US");
+        when(mockBaseEvent.getNetworkSimCode()).thenReturn("network_sim_code");
+        when(mockBaseEvent.getNetworkSimOperatorName()).thenReturn("network_operator_name");
+        when(mockBaseEvent.getNetworkSimIsoCountryCode()).thenReturn("US");
+        when(mockBaseEvent.getRequestId()).thenReturn("b550796074da4559a27c5072dcba2b27");
+        when(mockBaseEvent.getRequestStatusCode()).thenReturn(200);
+        when(mockBaseEvent.getRequestUri()).thenReturn("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        when(mockBaseEvent.getRequestRetries()).thenReturn(0);
+        when(mockBaseEvent.getTimestampUtcMs()).thenReturn(1416447053472L);
+    }
+
+    private void validateBaseEventFields(JSONObject jsonObject) throws Exception {
+        assertThat(jsonObject.getString("_category_")).isEqualTo("exchange_client_event");
+        assertThat(jsonObject.getLong("ts")).isEqualTo(1416447053472L);
+
+        // Name Details
+        assertThat(jsonObject.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject.getString("name_category")).isEqualTo(BaseEvent.Category.REQUESTS.getCategory());
+
+        // SDK Details
+        assertThat(jsonObject.getInt("sdk_product")).isEqualTo(BaseEvent.SdkProduct.NATIVE.getType());
+        assertThat(jsonObject.getString("sdk_version")).isEqualTo("3.5.0");
+
+        // Ad Details
+        assertThat(jsonObject.getString("ad_unit_id")).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
+        assertThat(jsonObject.getString("ad_creative_id")).isEqualTo("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        assertThat(jsonObject.getString("ad_type")).isEqualTo("html");
+        assertThat(jsonObject.getString("ad_network_type")).isEqualTo("admob");
+        assertThat(jsonObject.getDouble("ad_width_px")).isEqualTo(320.0);
+        assertThat(jsonObject.getDouble("ad_height_px")).isEqualTo(50.0);
+
+        // App Details
+        assertThat(jsonObject.getInt("app_platform")).isEqualTo(2);
+        assertThat(jsonObject.getString("app_name")).isEqualTo("MoPub Sample App");
+        assertThat(jsonObject.getString("app_package_name")).isEqualTo("com.mopub.simpleadsdemo");
+        assertThat(jsonObject.getString("app_version")).isEqualTo("1.0");
+
+        // Client Details
+        assertThat(jsonObject.getString("client_advertising_id")).isEqualTo("ifa:XXXX");
+        assertThat(jsonObject.getBoolean("client_do_not_track")).isEqualTo(false);
+
+        // Device Details
+        assertThat(jsonObject.getString("device_manufacturer")).isEqualTo("LGE");
+        assertThat(jsonObject.getString("device_model")).isEqualTo("Nexus 5");
+        assertThat(jsonObject.getString("device_product")).isEqualTo("hammerhead");
+        assertThat(jsonObject.getString("device_os_version")).isEqualTo("5.0");
+        assertThat(jsonObject.getInt("device_screen_width_px")).isEqualTo(1080);
+        assertThat(jsonObject.getInt("device_screen_height_px")).isEqualTo(1920);
+
+        // Geo Details
+        assertThat(jsonObject.getDouble("geo_lat")).isEqualTo(37.7833);
+        assertThat(jsonObject.getDouble("geo_lon")).isEqualTo(-122.4183333);
+        assertThat(jsonObject.getDouble("geo_accuracy_radius_meters")).isEqualTo(10.0);
+
+        // Performance Details
+        assertThat(jsonObject.getDouble("perf_duration_ms")).isEqualTo(100.0);
+
+        // Network Details
+        assertThat(jsonObject.getInt("network_type")).isEqualTo(ClientMetadata.MoPubNetworkType.WIFI.getId());
+        assertThat(jsonObject.getString("network_operator_code")).isEqualTo("310410");
+        assertThat(jsonObject.getString("network_operator_name")).isEqualTo("AT&T");
+        assertThat(jsonObject.getString("network_iso_country_code")).isEqualTo("US");
+        assertThat(jsonObject.getString("network_sim_code")).isEqualTo("network_sim_code");
+        assertThat(jsonObject.getString("network_sim_operator_name")).isEqualTo("network_operator_name");
+        assertThat(jsonObject.getString("network_sim_iso_country_code")).isEqualTo("US");
+
+        // Request Details
+        assertThat(jsonObject.getString("req_id")).isEqualTo("b550796074da4559a27c5072dcba2b27");
+        assertThat(jsonObject.getInt("req_status_code")).isEqualTo(200);
+        assertThat(jsonObject.getString("req_uri")).isEqualTo("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        assertThat(jsonObject.getInt("req_retries")).isEqualTo(0);
+
+        // Timestamp Details
+        assertThat(jsonObject.getLong("timestamp_client")).isEqualTo(1416447053472L);
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
new file mode 100644
index 00000000..6a3e58f2
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
@@ -0,0 +1,28 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class EventTest {
+
+    private Event subject;
+
+    @Before
+    public void setUp() {
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123).build();
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignScribeCategoryFromBuilder() {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
new file mode 100644
index 00000000..d555f34e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
@@ -0,0 +1,51 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+
+@RunWith(SdkTestRunner.class)
+public class MoPubEventsTest {
+
+    @Before
+    public void setUp() {
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void getDispatcher_shouldReturnSingletonEventDispatcherWithScribeEventRecorder() throws Exception {
+        EventDispatcher eventDispatcher = MoPubEvents.getDispatcher();
+        EventDispatcher eventDispatcher2 = MoPubEvents.getDispatcher();
+
+        assertThat(eventDispatcher).isEqualTo(eventDispatcher2);
+
+        Iterable<EventRecorder> eventRecorderIterable = eventDispatcher.getEventRecorders();
+        ArrayList<EventRecorder> eventRecorders = new ArrayList<EventRecorder>();
+        for (EventRecorder recorder : eventRecorderIterable) {
+            eventRecorders.add(recorder);
+        }
+
+        assertThat(eventRecorders.size()).isEqualTo(1);
+        assertThat(eventRecorders.get(0)).isInstanceOf(ScribeEventRecorder.class);
+    }
+
+    @Test
+    public void log_shouldDispatchEvent() throws Exception {
+        EventDispatcher mockEventDispatcher = mock(EventDispatcher.class);
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+
+        Event mockEvent = mock(Event.class);
+        MoPubEvents.log(mockEvent);
+
+        verify(mockEventDispatcher).dispatch(mockEvent);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
new file mode 100644
index 00000000..5681be25
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
@@ -0,0 +1,210 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.util.List;
+import java.util.Queue;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeEventRecorderTest {
+
+    private ScribeEventRecorder subject;
+    @Mock private EventSampler mockEventSampler;
+    @Mock private Queue<BaseEvent> mockQueue;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequestManager mockScribeRequestManager;
+    @Mock private Handler mockHandler;
+    @Mock private Event mockEvent;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeEventRecorder(
+                mockEventSampler,
+                mockQueue,
+                mockEventSerializer,
+                mockScribeRequestManager,
+                mockHandler
+        );
+
+        when(mockEventSampler.sample(any(Event.class))).thenReturn(true);
+    }
+
+    @Test
+    public void record_shouldSampleEvent() throws Exception {
+        subject.record(mockEvent);
+        verify(mockEventSampler).sample(mockEvent);
+    }
+
+    @Test
+    public void record_withQueueSizeBelowSendThreshold_shouldQueueEvent_shouldNotSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtSendThreshold_shouldQueueEvent_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtQueueLimit_shouldNotQueueEvent_shouldNotSendEvents_shouldNotScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(500);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue, never()).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void sendEvents_shouldDequeueEvents_shouldAddRequestToScribeRequestManager() throws Exception {
+        when(mockQueue.size()).thenReturn(1);
+        when(mockQueue.peek()).thenReturn(mockEvent).thenReturn(null);
+        when(mockQueue.poll()).thenReturn(mockEvent).thenReturn(null);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                ScribeRequest scribeRequest = ((ScribeRequest.ScribeRequestFactory) invocation.getArguments()[0]).createRequest(null);
+                assertThat(scribeRequest.getUrl()).isEqualTo("https://analytics.mopub.com/i/jot/exchange_client_event");
+                assertThat(scribeRequest.getEvents()).containsOnly(mockEvent);
+                return null;
+            }
+        }).when(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+
+        subject.sendEvents();
+
+        verify(mockQueue, times(2)).peek();
+        verify(mockQueue, times(1)).poll();
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+
+    @Test
+    public void sendEvents_withRequestInFlightShouldReturnFast() throws Exception {
+        when(mockScribeRequestManager.isAtCapacity()).thenReturn(true);
+
+        subject.sendEvents();
+
+        verify(mockQueue, never()).poll();
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+    
+    @Test
+    public void dequeEvents_withQueueSizeGreaterThanEventSendThreshhold_shouldDequeueUpToEventSendThreshhold() throws Exception {
+        when(mockQueue.size()).thenReturn(101);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(101)).peek();
+        verify(mockQueue, times(100)).poll();
+        assertThat(events.size()).isEqualTo(100);
+    }
+
+    @Test
+    public void dequeEvents_withQueueSizeLessThanEventSendThreshhold_shouldDequeueQueueSize() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        when(mockQueue.peek()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        when(mockQueue.poll()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(100)).peek();
+        verify(mockQueue, times(99)).poll();
+        assertThat(events.size()).isEqualTo(99);
+    }
+
+    @Test
+    public void scheduleNextPoll_shouldPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void scheduleNextPoll_withPollScheduled_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(true);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void scheduleNextPoll_withEmptyRequestQueue_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(true);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void PollingRunnable_run_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        ScribeEventRecorder.PollingRunnable pollingRunnable = subject.new PollingRunnable();
+        pollingRunnable.run();
+
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
index d17a79d8..7c03ac03 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
@@ -1,7 +1,9 @@
 package com.mopub.common.test.support;
 
+import com.mopub.common.CacheService;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.MoPub;
+import com.mopub.common.event.EventDispatcher;
 import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.util.AsyncTasks;
@@ -9,7 +11,6 @@
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestDateAndTime;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-import com.mopub.mobileads.factories.AdFetcherFactory;
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
@@ -19,11 +20,9 @@
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.factories.MoPubViewFactory;
-import com.mopub.mobileads.factories.MraidViewFactory;
+import com.mopub.mobileads.factories.MraidControllerFactory;
 import com.mopub.mobileads.factories.VastManagerFactory;
 import com.mopub.mobileads.factories.VastVideoDownloadTaskFactory;
-import com.mopub.mobileads.factories.ViewGestureDetectorFactory;
-import com.mopub.mobileads.test.support.TestAdFetcherFactory;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerFactory;
@@ -33,24 +32,22 @@
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
 import com.mopub.mobileads.test.support.TestHttpClientFactory;
 import com.mopub.mobileads.test.support.TestMoPubViewFactory;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
+import com.mopub.mobileads.test.support.TestMraidControllerFactory;
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
 import com.mopub.mobileads.test.support.TestVastVideoDownloadTaskFactory;
-import com.mopub.mobileads.test.support.TestViewGestureDetectorFactory;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
 import com.mopub.nativeads.test.support.TestCustomEventNativeFactory;
 
 import org.junit.runners.model.InitializationError;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.DefaultTestLifecycle;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.TestLifecycle;
 import org.robolectric.bytecode.ClassInfo;
 import org.robolectric.bytecode.Setup;
 import org.robolectric.util.RobolectricBackgroundExecutorService;
 
-import java.lang.reflect.Method;
-
 import static com.mopub.common.MoPub.LocationAwareness;
 import static org.mockito.Mockito.mock;
 
@@ -79,36 +76,34 @@ public boolean shouldInstrument(ClassInfo classInfo) {
     public static class TestLifeCycleWithInjection extends DefaultTestLifecycle {
         @Override
         public void prepareTest(Object test) {
-            AdFetcherFactory.setInstance(new TestAdFetcherFactory());
+            ClientMetadata.clearForTesting();
+
             HttpClientFactory.setInstance(new TestHttpClientFactory());
             DateAndTime.setInstance(new TestDateAndTime());
             CustomEventBannerFactory.setInstance(new TestCustomEventBannerFactory());
             CustomEventInterstitialFactory.setInstance(new TestCustomEventInterstitialFactory());
             CustomEventBannerAdapterFactory.setInstance(new TestCustomEventBannerAdapterFactory());
-            MraidViewFactory.setInstance(new TestMraidViewFactory());
             MoPubViewFactory.setInstance(new TestMoPubViewFactory());
             CustomEventInterstitialAdapterFactory.setInstance(new TestCustomEventInterstitialAdapterFactory());
             HtmlBannerWebViewFactory.setInstance(new TestHtmlBannerWebViewFactory());
             HtmlInterstitialWebViewFactory.setInstance(new TestHtmlInterstitialWebViewFactory());
             AdViewControllerFactory.setInstance(new TestAdViewControllerFactory());
-            ViewGestureDetectorFactory.setInstance(new TestViewGestureDetectorFactory());
             VastManagerFactory.setInstance(new TestVastManagerFactory());
             VastVideoDownloadTaskFactory.setInstance(new TestVastVideoDownloadTaskFactory());
             MethodBuilderFactory.setInstance(new TestMethodBuilderFactory());
             CustomEventNativeFactory.setInstance(new TestCustomEventNativeFactory());
+            MraidControllerFactory.setInstance(new TestMraidControllerFactory());
+
             ShadowAsyncTasks.reset();
-            MoPubEvents.setEventDispatcher(mock(MoPubEvents.EventDispatcher.class));
+            MoPubEvents.setEventDispatcher(mock(EventDispatcher.class));
             MoPub.setLocationAwareness(LocationAwareness.NORMAL);
             MoPub.setLocationPrecision(6);
 
             MockitoAnnotations.initMocks(test);
 
             AsyncTasks.setExecutor(new RobolectricBackgroundExecutorService());
-        }
-
-        @Override
-        public void afterTest(final Method method) {
-            ClientMetadata.clearForTesting();
+            CacheService.clearAndNullCaches();
+            Robolectric.getFakeHttpLayer().clearPendingHttpResponses();
         }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
index 89473924..2bfebb20 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
@@ -1,7 +1,6 @@
 package com.mopub.common.util;
 
 import android.os.AsyncTask;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.os.Looper;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
new file mode 100644
index 00000000..4a7bf40a
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
@@ -0,0 +1,135 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.pm.ActivityInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.view.Surface;
+
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.test.support.MoPubShadowDisplay;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class DeviceUtilsTest {
+
+    private Activity testActivity;
+    private Resources testResources;
+
+    @Before
+    public void setup() {
+        testActivity = Robolectric.buildActivity(Activity.class).create().get();
+        testResources = testActivity.getResources();
+    }
+
+    @Test
+    public void getOrientation_whenReverseLandscape_shouldReturnReverseLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_270);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+    }
+
+    @Test
+    public void getOrientation_whenLandscape_shouldReturnLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void getOrientation_whenPortrait_shouldReturnPortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void getOrientation_whenAlsoPortrait_shouldReturnPortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_270);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void getOrientation_whenReversePortrait_shouldReturnReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+
+    @Test
+    public void getOrientation_whenAlsoReversePortrait_shouldReturnReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+    
+    @Test
+    public void lockOrientation_toLandscapeWhenLandscape_shouldRemainTheSame() throws Exception {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toLandscapeWhenReverseLandscape_shouldBeReverseLandscape() {
+
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);  // Reverse landscape
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toLandscapeWhenPortrait_shouldBeLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);  // Reverse portrait
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenPortrait_shouldRemainPortrait() {
+
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenReversePortrait_shouldRemainReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenLandscape_shouldBeLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);  // Reverse landscape
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
new file mode 100644
index 00000000..c0d46973
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
@@ -0,0 +1,42 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.res.Resources;
+import android.util.DisplayMetrics;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class DipsTest {
+
+    @Mock private Activity activity;
+    @Mock private Resources resources;
+
+    @Before
+    public void setUp() {
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        displayMetrics.widthPixels = 480;
+        displayMetrics.heightPixels = 800;
+        displayMetrics.density = 2;
+        when(activity.getResources()).thenReturn(resources);
+        when(resources.getDisplayMetrics()).thenReturn(displayMetrics);
+    }
+
+    @Test
+    public void screenWidthAsIntDips_shouldReturnTheWidthAsDips() throws Exception {
+        assertThat(Dips.screenWidthAsIntDips(activity)).isEqualTo(240);
+    }
+
+    @Test
+    public void screenHeightAsIntDips_shouldReturnTheHeightAsDips() throws Exception {
+        assertThat(Dips.screenHeightAsIntDips(activity)).isEqualTo(400);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
index 269b6577..3c8af8cd 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
@@ -11,8 +11,14 @@
 @RunWith(RobolectricTestRunner.class)
 public class DrawablesTest {
     @Test
-    public void decodeImage_shouldCacheDrawables() throws Exception {
-        assertThat(Drawables.BACKGROUND.decodeImage(new Activity()))
-                .isSameAs(Drawables.BACKGROUND.decodeImage(new Activity()));
+    public void createDrawable_shouldNotCacheDrawables() throws Exception {
+        assertThat(Drawables.BACKGROUND.createDrawable(new Activity()))
+                .isNotSameAs(Drawables.BACKGROUND.createDrawable(new Activity()));
+    }
+
+    @Test
+    public void getBitmap_shouldCacheBitmap() throws Exception {
+        assertThat(Drawables.BACKGROUND.getBitmap())
+                .isSameAs(Drawables.BACKGROUND.getBitmap());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
index ca2e55c0..0b65e22e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
@@ -8,7 +8,7 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 
-import java.io.*;
+import java.io.File;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
deleted file mode 100644
index 2630da5e..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.os.Bundle;
-
-import com.mopub.common.MoPubBrowser;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(RobolectricTestRunner.class)
-public class IntentUtilsTest {
-    @Test
-    public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithoutNewTaskFlag() throws Exception {
-        Context context = new Activity();
-
-        final Intent intent = IntentUtils.getStartActivityIntent(context, MoPubBrowser.class, null);
-
-        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
-        assertThat(intent.getExtras()).isNull();
-    }
-
-    @Test
-    public void getStartActivityIntent_withApplicationContext_shouldReturnIntentWithNewTaskFlag() throws Exception {
-        Context context = new Activity().getApplicationContext();
-
-        final Intent intent = IntentUtils.getStartActivityIntent(context, MoPubBrowser.class, null);
-
-        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isTrue();
-        assertThat(intent.getExtras()).isNull();
-    }
-
-    @Test
-    public void getStartActivityIntent_withBundle_shouldReturnIntentWithExtras() throws Exception {
-        Context context = new Activity();
-        Bundle bundle = new Bundle();
-        bundle.putString("arbitrary key", "even more arbitrary value");
-
-        final Intent intent = IntentUtils.getStartActivityIntent(context, MoPubBrowser.class, bundle);
-
-        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
-        assertThat(intent.getExtras()).isEqualTo(bundle);
-    }
-
-    @Test
-    public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue() throws Exception {
-        Context context = mock(Context.class);
-        PackageManager packageManager = mock(PackageManager.class);
-
-        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
-        resolveInfos.add(new ResolveInfo());
-
-        stub(context.getPackageManager()).toReturn(packageManager);
-        Intent specificIntent = new Intent();
-        specificIntent.setData(Uri.parse("specificIntent:"));
-
-        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
-
-        assertThat(IntentUtils.deviceCanHandleIntent(context, specificIntent)).isTrue();
-    }
-
-    @Test
-    public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFalse() throws Exception {
-        Context context = mock(Context.class);
-        PackageManager packageManager = mock(PackageManager.class);
-
-        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
-        resolveInfos.add(new ResolveInfo());
-
-        stub(context.getPackageManager()).toReturn(packageManager);
-        Intent specificIntent = new Intent();
-        specificIntent.setData(Uri.parse("specificIntent:"));
-
-        Intent otherIntent = new Intent();
-        otherIntent.setData(Uri.parse("other:"));
-        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
-
-        assertThat(IntentUtils.deviceCanHandleIntent(context, otherIntent)).isFalse();
-    }
-
-    @Test
-    public void generateUniqueId_withMultipleInvocations_shouldReturnUniqueValues() throws Exception {
-        final int expectedIdCount = 100;
-
-        Set<Long> ids = new HashSet<Long>(expectedIdCount);
-        for (int i = 0; i < expectedIdCount; i++) {
-            final long id = Utils.generateUniqueId();
-            ids.add(id);
-        }
-
-        assertThat(ids).hasSize(expectedIdCount);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
new file mode 100644
index 00000000..94aa1180
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
@@ -0,0 +1,205 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.stub;
+
+@RunWith(RobolectricTestRunner.class)
+public class IntentsTest {
+    private Activity activityContext;
+    private Context applicationContext;
+
+    @Before
+    public void setUp() {
+        activityContext = Robolectric.buildActivity(Activity.class).create().get();
+        applicationContext = activityContext.getApplicationContext();
+    }
+
+    @Test
+    public void startActivity_withActivityContext_shouldStartActivityWithNoNewFlags() throws IntentNotResolvableException {
+        Intents.startActivity(activityContext, new Intent());
+
+        final Intent intent = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+    }
+
+    @Test
+    public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithoutNewTaskFlag() throws Exception {
+        Context context = new Activity();
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+        assertThat(intent.getExtras()).isNull();
+    }
+
+    @Test
+    public void getStartActivityIntent_withApplicationContext_shouldReturnIntentWithNewTaskFlag() throws Exception {
+        Context context = new Activity().getApplicationContext();
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(intent.getExtras()).isNull();
+    }
+
+    @Test
+    public void getStartActivityIntent_withBundle_shouldReturnIntentWithExtras() throws Exception {
+        Context context = new Activity();
+        Bundle bundle = new Bundle();
+        bundle.putString("arbitrary key", "even more arbitrary value");
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, bundle);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+        assertThat(intent.getExtras()).isEqualTo(bundle);
+    }
+
+    @Test
+    public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue() throws Exception {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+        Intent specificIntent = new Intent();
+        specificIntent.setData(Uri.parse("specificIntent:"));
+
+        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
+
+        assertThat(Intents.deviceCanHandleIntent(context, specificIntent)).isTrue();
+    }
+
+    @Test
+    public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFalse() throws Exception {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+        Intent specificIntent = new Intent();
+        specificIntent.setData(Uri.parse("specificIntent:"));
+
+        Intent otherIntent = new Intent();
+        otherIntent.setData(Uri.parse("other:"));
+        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
+
+        assertThat(Intents.deviceCanHandleIntent(context, otherIntent)).isFalse();
+    }
+
+    @Test
+    public void intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls() throws UrlParseException {
+        Intent intent;
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http://www.example.com/?query=1&two=2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1&two=2");
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotMoPubNativeBrowser_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mailto://navigate?url=http://www.example.com"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://getout?url=http://www.example.com"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate"));
+    }
+
+    @Test
+    public void intentForShareTweetScheme_whenValidUri_shouldReturnShareTweetIntent() throws UrlParseException {
+        Intent intent;
+        final String shareMessage = "Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802";
+
+        intent = Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_SEND);
+        assertThat(intent.getType()).isEqualTo("text/plain");
+        assertThat(intent.getStringExtra(Intent.EXTRA_SUBJECT)).isEqualTo(shareMessage);
+        assertThat(intent.getStringExtra(Intent.EXTRA_TEXT)).isEqualTo(shareMessage);
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongScheme_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mailto://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongHost_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://twat?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?foo=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&bar=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id="));
+    }
+
+    @Test
+    public void launchIntentForUserClick_shouldStartActivity() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get()
+                .getApplicationContext();
+        Intent intent = mock(Intent.class);
+
+        Intents.launchIntentForUserClick(context, intent, null);
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+
+        assertThat(startedActivity).isNotNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
index d40ac3d2..9bfa41ec 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
@@ -1,10 +1,13 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.ResolveInfo;
+import android.os.Build;
 
 import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.MoPubActivity;
@@ -15,14 +18,22 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLog;
 import org.robolectric.shadows.ShadowToast;
 
 import java.util.List;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
@@ -30,14 +41,14 @@
 @RunWith(RobolectricTestRunner.class)
 public class ManifestUtilsTest {
     private Context context;
-    private ResolveInfo resolveInfo;
     private List<Class<? extends Activity>> requiredWebViewSdkActivities;
     private List<Class<? extends Activity>> requiredNativeSdkActivities;
 
+    @Mock private ResolveInfo mockResolveInfo;
+
     @Before
     public void setUp() throws Exception {
-        context = spy(new Activity());
-        resolveInfo = mock(ResolveInfo.class);
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
 
         requiredWebViewSdkActivities = ManifestUtils.getRequiredWebViewSdkActivities();
         requiredNativeSdkActivities = ManifestUtils.getRequiredNativeSdkActivities();
@@ -48,6 +59,8 @@ public void setUp() throws Exception {
     @After
     public void tearDown() throws Exception {
         setDebugMode(false);
+        // This may have been set to a mock during testing. Reset this class back to normal
+        ManifestUtils.setFlagCheckUtil(new ManifestUtils.FlagCheckUtil());
     }
 
     @Test
@@ -80,10 +93,10 @@ public void checkNativeSdkActivitiesDeclared_shouldIncludeOneActivityDeclaration
 
     @Test
     public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), resolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
         setDebugMode(true);
@@ -96,9 +109,9 @@ public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldN
 
     @Test
      public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogOnlyThatOne() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), resolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
         // Here, we leave out MoPubBrowser on purpose
 
         ShadowLog.setupLogging();
@@ -113,6 +126,23 @@ public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogO
         );
     }
 
+    @Test
+    public void displayWarningForMissingActivities_withAllMissingActivities_shouldLogMessage() throws Exception {
+        setDebugMode(true);
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
+
+        assertLogIncludes(
+                "com.mopub.mobileads.MoPubActivity",
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity",
+                "com.mopub.common.MoPubBrowser"
+        );
+    }
+
     @Test
     public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldShowToast() throws Exception {
         setDebugMode(true);
@@ -121,7 +151,7 @@ public void displayWarningForMissingActivities_withMissingActivities_withDebugTr
 
         assertThat(ShadowToast.getLatestToast()).isNotNull();
         final String toastText = ShadowToast.getTextOfLatestToast();
-        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities.");
+        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
     }
 
     @Test
@@ -132,22 +162,178 @@ public void displayWarningForMissingActivities_withMissingActivities_withDebugFa
 
         assertThat(ShadowToast.getLatestToast()).isNull();
     }
-    
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
     @Test
-    public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldLogMessage() throws Exception {
-        setDebugMode(true);
+    public void displayWarningForMisconfiguredActivities_withAllActivitiesConfigured_shouldNotLogOrShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
         ShadowLog.setupLogging();
+        setDebugMode(true);
 
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
 
-        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
 
-        assertLogIncludes(
-                "com.mopub.mobileads.MoPubActivity",
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_shouldLogOnlyThatOne() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+
+        // Misconfigure the first activity; only return false if the activity is MoPubActivity
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                return MoPubActivity.class != args[0];
+            }
+        }).when(mockActivitiyConfigCheck).hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN));
+
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("com.mopub.mobileads.MoPubActivity");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
+        assertLogDoesntInclude(
                 "com.mopub.mobileads.MraidActivity",
                 "com.mopub.mobileads.MraidVideoPlayerActivity",
                 "com.mopub.common.MoPubBrowser"
         );
+        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
+        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_withMissingAllConfigChangesValues_shouldLogAllConfigChangesValues() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withTargetApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        // Set target API to < 13
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        applicationInfo.targetSdkVersion = Build.VERSION_CODES.HONEYCOMB_MR1;
+        when(context.getApplicationInfo()).thenReturn(applicationInfo);
+
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugTrue_shouldShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNotNull();
+        final String toastText = ShadowToast.getTextOfLatestToast();
+        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugFalse_shouldNotShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        setDebugMode(false);
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
     }
 
     @Test
@@ -164,6 +350,7 @@ public void isDebuggable_whenApplicationIsNotDebuggable_shouldReturnFalse() thro
         assertThat(ManifestUtils.isDebuggable(context)).isFalse();
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() throws Exception {
         assertThat(requiredWebViewSdkActivities).containsOnly(
@@ -174,6 +361,7 @@ public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() th
         );
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void getRequiredNativeSdkActivities_shouldIncludeRequiredActivities() throws Exception {
         assertThat(requiredNativeSdkActivities).containsOnly(
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/NumbersTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/NumbersTest.java
index 93d8fb1f..f58f8c37 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/NumbersTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/NumbersTest.java
@@ -56,4 +56,16 @@ public void parseDouble_withInvalidObjectType_shouldThrowClassCastException() th
             // pass
         }
     }
-}
\ No newline at end of file
+
+    @Test
+    public void convertMillisecondsToSecondsRoundedUp_shouldReturnLongMillisecondsAsRoundedUpLongSeconds() throws Exception {
+        assertThat(Numbers.convertMillisecondsToSecondsRoundedUp(0)).isEqualTo(0);
+
+        assertThat(Numbers.convertMillisecondsToSecondsRoundedUp(1)).isEqualTo(1);
+        assertThat(Numbers.convertMillisecondsToSecondsRoundedUp(999)).isEqualTo(1);
+        assertThat(Numbers.convertMillisecondsToSecondsRoundedUp(1000)).isEqualTo(1);
+
+        assertThat(Numbers.convertMillisecondsToSecondsRoundedUp(1001)).isEqualTo(2);
+        assertThat(Numbers.convertMillisecondsToSecondsRoundedUp(100000)).isEqualTo(100);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
index 2b73cf80..b36ae026 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
@@ -2,9 +2,11 @@
 
 import android.app.Activity;
 import android.view.View;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 
 import static com.mopub.common.util.Reflection.MethodBuilder;
@@ -21,7 +23,7 @@
 
     @Before
     public void setup(){
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         view = new View(activity);
         string = "goat";
     }
@@ -145,14 +147,15 @@ public void execute_withStaticMethod_shouldPass() throws Exception {
         assertThat(methodBuilder.execute()).isEqualTo("20");
     }
 
-//    @Test
-//    public void execute_withAccessibility_shouldRunPrivateMethods() throws Exception {
-//        methodBuilder = new MethodBuilder(string, "foldCase");
-//        methodBuilder.addParam(char.class, 'a');
-//        methodBuilder.setAccessible();
-//
-//        char result = (Character) methodBuilder.execute();
-//
-//        assertThat(result).isEqualTo('a');
-//    }
+    @Test
+    public void execute_withAccessibility_shouldRunPrivateMethods() throws Exception {
+        methodBuilder = new MethodBuilder(string, "indexOfSupplementary");
+        methodBuilder.addParam(int.class, (int)'a');
+        methodBuilder.addParam(int.class, 0);
+        methodBuilder.setAccessible();
+
+        int result = (Integer) methodBuilder.execute();
+
+        assertThat(result).isEqualTo(-1);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
deleted file mode 100644
index 1f2279c6..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.mopub.common.util;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@RunWith(RobolectricTestRunner.class)
-public class StringsTest {
-    @Test
-    public void isEmpty_shouldReturnValidResponse() throws Exception {
-        assertThat(Strings.isEmpty("")).isTrue();
-
-        assertThat(Strings.isEmpty("test")).isFalse();
-
-        assertThat(Strings.isEmpty(null)).isFalse();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
new file mode 100644
index 00000000..384e40b8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
@@ -0,0 +1,27 @@
+package com.mopub.common.util;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class UtilsTest {
+    @Test
+    public void generateUniqueId_withMultipleInvocations_shouldReturnUniqueValues() throws Exception {
+        final int expectedIdCount = 100;
+
+        Set<Long> ids = new HashSet<Long>(expectedIdCount);
+        for (int i = 0; i < expectedIdCount; i++) {
+            final long id = Utils.generateUniqueId();
+            ids.add(id);
+        }
+
+        assertThat(ids).hasSize(expectedIdCount);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
index 7f09ebcc..48fa3198 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
 import android.view.View;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
@@ -9,6 +10,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -18,12 +20,15 @@
     private Context context;
     private View subject;
     private RelativeLayout parent;
+    private Activity testActivity;
+    private Resources testResources;
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         subject = new View(context);
         parent = new RelativeLayout(context);
+
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/test/support/CommonUtils.java b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/CommonUtils.java
deleted file mode 100644
index b83bf83d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/util/test/support/CommonUtils.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package com.mopub.common.util.test.support;
-
-import org.apache.http.HttpRequest;
-import org.robolectric.Robolectric;
-
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class CommonUtils {
-    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
-        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
-        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
-
-        for (final String url : urls) {
-            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
-        }
-
-        if (userAgent != null) {
-            while (true) {
-                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
-                if (httpRequest == null) {
-                    break;
-                }
-
-                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
-                        .isEqualTo(userAgent);
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
index 961ee9c0..09ae4f1d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
@@ -4,12 +4,14 @@
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.GestureUtils;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.FAILED;
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.FINISHED;
@@ -17,13 +19,14 @@
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.GOING_RIGHT;
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.UNSET;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.stub;
 
 @RunWith(SdkTestRunner.class)
 public class AdAlertGestureListenerTest {
-
-    private View view;
+    @Mock
+    private View mockView;
+    @Mock
+    private AdReport mockAdReport;
     private AdAlertGestureListener subject;
     private float threshold;
     private static final float INITIAL_X = 20;
@@ -31,17 +34,14 @@
     private float savedX;
     private float savedY;
     private MotionEvent actionDown;
-    private AdConfiguration adConfiguration;
-    private Context context;
+    @Mock
+    private Context mockContext;
 
     @Before
     public void setup() {
-        view = mock(View.class);
-        adConfiguration = mock(AdConfiguration.class);
-        context = mock(Context.class);
-        stub(view.getContext()).toReturn(context);
+        stub(mockView.getContext()).toReturn(mockContext);
 
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
 
         savedX = INITIAL_X;
         savedY = INITIAL_Y;
@@ -52,22 +52,22 @@ public void setup() {
 
     @Test
     public void constructor_shouldSetThresholdToOneThirdOfViewsWidth() throws Exception {
-        stub(view.getWidth()).toReturn(150);
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        stub(mockView.getWidth()).toReturn(150);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
         assertThat(subject.getMinimumDipsInZigZag()).isEqualTo(50);
     }
 
     @Test
     public void constructor_whenViewWidthIsWiderThanThreeTimesMaxThreshold_shouldSetThresholdTo100() throws Exception {
-        stub(view.getWidth()).toReturn(500);
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        stub(mockView.getWidth()).toReturn(500);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
         assertThat(subject.getMinimumDipsInZigZag()).isEqualTo(100);
     }
 
     @Test
     public void constructor_whenViewWidthIs0_shouldSetThresholdTo100() throws Exception {
-        stub(view.getWidth()).toReturn(0);
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        stub(mockView.getWidth()).toReturn(0);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
         assertThat(subject.getMinimumDipsInZigZag()).isEqualTo(100);
     }
 
@@ -114,7 +114,7 @@ public void onScroll_withInitialLeftThenRightMovement_BeforeZigCompletes_MovesOu
         assertZigZagState(GOING_RIGHT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(0);
 
-        simulateScroll(savedX, INITIAL_Y + 52);
+        simulateScroll(savedX, INITIAL_Y + 102);
         assertZigZagState(FAILED);
     }
 
@@ -130,7 +130,7 @@ public void onScroll_withInitialLeftThenRightMovement_BeforeZigCompletes_MovesOu
         assertZigZagState(GOING_RIGHT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(0);
 
-        simulateScroll(savedX, INITIAL_Y - 51);
+        simulateScroll(savedX, INITIAL_Y - 101);
         assertZigZagState(FAILED);
     }
 
@@ -145,7 +145,7 @@ public void onScroll_withZigZagZigZagZigZagZig_BeforeNextZagCompletes_MovesOutOf
         assertZigZagState(GOING_RIGHT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(3);
 
-        simulateScroll(savedX, INITIAL_Y + 51);
+        simulateScroll(savedX, INITIAL_Y + 101);
         assertZigZagState(FAILED);
     }
 
@@ -160,14 +160,14 @@ public void onScroll_withZigZagZigZagZigZagZig_BeforeNextZagCompletes_MovesOutOf
         assertZigZagState(GOING_LEFT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(3);
 
-        simulateScroll(savedX, INITIAL_Y - 51);
+        simulateScroll(savedX, INITIAL_Y - 101);
         assertZigZagState(FAILED);
     }
 
     @Test
     public void onScroll_withStateFailed_withAnyMotion_shouldStayFailed() throws Exception {
         simulateScroll(savedX, INITIAL_Y + 49);
-        simulateScroll(savedX, INITIAL_Y + 51);
+        simulateScroll(savedX, INITIAL_Y + 101);
         assertZigZagState(FAILED);
 
         performZigZag();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index ce36a6e8..d199d9f8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -8,12 +8,15 @@
 import android.view.View;
 import android.widget.TextView;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.TestDateAndTime;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 
 import java.io.File;
@@ -26,15 +29,21 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
 public class AdAlertReporterTest {
     private final static String EMAIL_ADDRESS = "creative-review@mopub.com";
     private AdAlertReporter subject;
-    private Context context;
-    private View view;
-    private AdConfiguration adConfiguration;
+    @Mock
+    private AdReport mockAdReport;
+    @Mock
+    private Context mockContext;
+    @Mock
+    private View mockView;
     private Intent emailIntent;
     private Bitmap bitmap;
     private ArrayList<Uri> emailAttachments;
@@ -42,15 +51,10 @@
 
     @Before
     public void setup() {
-        context = mock(Context.class);
-
         bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
 
-        view = mock(View.class);
-        stub(view.getRootView()).toReturn(view);
-        stub(view.getDrawingCache()).toReturn(bitmap);
-
-        adConfiguration = mock(AdConfiguration.class);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.getDrawingCache()).toReturn(bitmap);
 
         now = new Date();
         TestDateAndTime.getInstance().setNow(now);
@@ -58,18 +62,18 @@ public void setup() {
 
     @Test
     public void constructor_shouldCreateSendToIntentWithEmailAddress() throws Exception {
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
         emailIntent = subject.getEmailIntent();
 
         assertThat(emailIntent.getAction()).isEqualTo(Intent.ACTION_SEND_MULTIPLE);
         assertThat(emailIntent.getType()).isEqualTo("plain/text");
-        assertThat(emailIntent.getDataString()).isEqualTo("mailto:");
+        assertThat(emailIntent.getData().toString()).isEqualTo("mailto:");
         assertThat(emailIntent.getStringArrayExtra(Intent.EXTRA_EMAIL)[0]).isEqualTo(EMAIL_ADDRESS);
     }
 
     @Test
     public void constructor_shouldCreateIntentWithDatestampInSubject() throws Exception {
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
         emailIntent = subject.getEmailIntent();
 
         String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_SUBJECT);
@@ -79,7 +83,7 @@ public void constructor_shouldCreateIntentWithDatestampInSubject() throws Except
         assertThat(title).isEqualTo("New creative violation report");
 
         String dateTimeString = subjectParts[1];
-        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z");
+        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z", Locale.US);
 
         Date date = dateFormat.parse(dateTimeString);
 
@@ -91,23 +95,11 @@ public void constructor_shouldCreateIntentWithImageStringAndParametersAndRespons
         TextView textView = mock(TextView.class);
         Bitmap sampleBitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ALPHA_8);
         stub(textView.getDrawingCache()).toReturn(sampleBitmap);
-        stub(view.getRootView()).toReturn(textView);
-
-        stub(adConfiguration.getResponseString()).toReturn("<html>a valid response</html>");
-        stub(adConfiguration.getDspCreativeId()).toReturn("");
-        stub(adConfiguration.getPlatformVersion()).toReturn(1);
-        stub(adConfiguration.getDeviceModel()).toReturn("android");
-        stub(adConfiguration.getAdUnitId()).toReturn("abc");
-        stub(adConfiguration.getDeviceLocale()).toReturn("US");
-        stub(adConfiguration.getHashedUdid()).toReturn("UDID");
-        stub(adConfiguration.getNetworkType()).toReturn("unknown");
-        stub(adConfiguration.getPlatform()).toReturn("android");
-        stub(adConfiguration.getTimeStamp()).toReturn(now.getTime());
-        stub(adConfiguration.getAdType()).toReturn("interstitial");
-        stub(adConfiguration.getWidth()).toReturn(480);
-        stub(adConfiguration.getHeight()).toReturn(320);
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockView.getRootView()).toReturn(textView);
+
+        stub(mockAdReport.toString()).toReturn("Ad Report data - this is a long list of newlined params.");
+        stub(mockAdReport.getResponseString()).toReturn("Test ad string.");
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailIntent = subject.getEmailIntent();
         String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_TEXT);
@@ -125,9 +117,9 @@ public void constructor_shouldCreateIntentWithImageStringAndParametersAndRespons
 
     @Test
     public void constructor_shouldAddBitmapToAttachmentArray() throws Exception {
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailAttachments = subject.getEmailAttachments();
         Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_screenshot.png"));
@@ -137,9 +129,9 @@ public void constructor_shouldAddBitmapToAttachmentArray() throws Exception {
 
     @Test
     public void constructor_shouldAddParametersTextFileToAttachmentArray() throws Exception {
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailAttachments = subject.getEmailAttachments();
         Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_parameters.txt"));
@@ -148,100 +140,29 @@ public void constructor_shouldAddParametersTextFileToAttachmentArray() throws Ex
     }
 
     @Test
-    public void constructor_shouldProperlyConstructParametersTextFile() throws Exception {
-        String expectedParameters =
-                "sdk_version : 1.15.2.2\n" +
-                "creative_id : \n" +
-                "platform_version : 1\n" +
-                "device_model : android\n" +
-                "ad_unit_id : abc\n" +
-                "device_locale : US\n" +
-                "device_id : UDID\n" +
-                "network_type : unknown\n" +
-                "platform : android\n" +
-                "timestamp : " + getCurrentDateTime() + "\n" +
-                "ad_type : interstitial\n" +
-                "ad_size : {480, 320}\n";
-
-        stub(adConfiguration.getSdkVersion()).toReturn("1.15.2.2");
-        stub(adConfiguration.getDspCreativeId()).toReturn("");
-        stub(adConfiguration.getPlatformVersion()).toReturn(1);
-        stub(adConfiguration.getDeviceModel()).toReturn("android");
-        stub(adConfiguration.getAdUnitId()).toReturn("abc");
-        stub(adConfiguration.getDeviceLocale()).toReturn("US");
-        stub(adConfiguration.getHashedUdid()).toReturn("UDID");
-        stub(adConfiguration.getNetworkType()).toReturn("unknown");
-        stub(adConfiguration.getPlatform()).toReturn("android");
-        stub(adConfiguration.getTimeStamp()).toReturn(now.getTime());
-        stub(adConfiguration.getAdType()).toReturn("interstitial");
-        stub(adConfiguration.getWidth()).toReturn(480);
-        stub(adConfiguration.getHeight()).toReturn(320);
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
-
-        assertThat(subject.getParameters()).isEqualTo(expectedParameters);
-    }
-
-    @Test
-    public void constructor_withInvalidAdConfigurationValues_shouldReturnSomethingSensible() throws Exception {
-        String expectedParameters =
-                "sdk_version : null\n" +
-                "creative_id : null\n" +
-                "platform_version : -1\n" +
-                "device_model : null\n" +
-                "ad_unit_id : null\n" +
-                "device_locale : null\n" +
-                "device_id : null\n" +
-                "network_type : null\n" +
-                "platform : null\n" +
-                "timestamp : null" + "\n" +
-                "ad_type : null\n" +
-                "ad_size : {-1, -1}\n";
-
-        stub(adConfiguration.getSdkVersion()).toReturn(null);
-        stub(adConfiguration.getDspCreativeId()).toReturn(null);
-        stub(adConfiguration.getPlatformVersion()).toReturn(-1);
-        stub(adConfiguration.getDeviceModel()).toReturn(null);
-        stub(adConfiguration.getAdUnitId()).toReturn(null);
-        stub(adConfiguration.getDeviceLocale()).toReturn(null);
-        stub(adConfiguration.getHashedUdid()).toReturn(null);
-        stub(adConfiguration.getNetworkType()).toReturn(null);
-        stub(adConfiguration.getPlatform()).toReturn(null);
-        stub(adConfiguration.getTimeStamp()).toReturn(-1l);
-        stub(adConfiguration.getAdType()).toReturn(null);
-        stub(adConfiguration.getWidth()).toReturn(-1);
-        stub(adConfiguration.getHeight()).toReturn(-1);
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
-
-        assertThat(subject.getParameters()).isEqualTo(expectedParameters);
-    }
-
-    @Test
-    public void constructor_whenAdConfigurationIsNull_shouldReturnEmptyString() throws Exception {
-        subject = new AdAlertReporter(context, view, null);
+    public void constructor_whenAdReportIsNull_shouldReturnEmptyString() throws Exception {
+        subject = new AdAlertReporter(mockContext, mockView, null);
 
         assertThat(subject.getParameters()).isEmpty();
         assertThat(subject.getResponse()).isEmpty();
     }
 
     @Test
-    public void constructor_shouldReturnCorrectResponseString() throws Exception {
+    public void constructor_shouldSetCorrectResponseString() throws Exception {
         String expectedResponse = "response";
 
-        stub(adConfiguration.getResponseString()).toReturn(expectedResponse);
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockAdReport.getResponseString()).toReturn(expectedResponse);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         assertThat(subject.getResponse()).isEqualTo(expectedResponse);
     }
 
     @Test
     public void constructor_shouldAddMarkupTextFileToAttachmentArray() throws Exception {
-        stub(adConfiguration.getResponseString()).toReturn(" ");
-
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockAdReport.getResponseString()).toReturn("anything!");
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailAttachments = subject.getEmailAttachments();
         Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_markup.html"));
@@ -251,11 +172,10 @@ public void constructor_shouldAddMarkupTextFileToAttachmentArray() throws Except
 
     @Test
     public void send_shouldAddAttachmentsToIntent() throws Exception {
-        stub(adConfiguration.getResponseString()).toReturn("response!");
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        stub(mockAdReport.getResponseString()).toReturn("anything!");
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
         subject.send();
 
         emailIntent = subject.getEmailIntent();
@@ -269,9 +189,8 @@ public void send_shouldAddAttachmentsToIntent() throws Exception {
 
     @Test
     public void send_shouldCreateEmailChooserIntent() throws Exception {
-        stub(adConfiguration.getResponseString()).toReturn("response!");
 
-        subject = new AdAlertReporter(new Activity(), view, adConfiguration);
+        subject = new AdAlertReporter(Robolectric.buildActivity(Activity.class).create().get(), mockView, mockAdReport);
         subject.send();
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
@@ -280,56 +199,52 @@ public void send_shouldCreateEmailChooserIntent() throws Exception {
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
     }
 
+    @Ignore("pending")
     @Test
     public void getScreenshot_whenIsDrawingCacheEnabled_shouldKeepDrawingCacheEnabled() throws Exception {
-//        reset(view);
-//        stub(view.getRootView()).toReturn(view);
-//        stub(view.isDrawingCacheEnabled()).toReturn(true);
-//
-//        subject = new AdAlertReporter(context, view, adConfiguration);
-//
-//        verify(view, never()).setDrawingCacheEnabled(false);
+        reset(mockView);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.isDrawingCacheEnabled()).toReturn(true);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        verify(mockView, never()).setDrawingCacheEnabled(false);
     }
 
+    @Ignore("pending")
     @Test
     public void getScreenshot_whenIsDrawingCacheDisabled_shouldKeepDrawingCacheDisabled() throws Exception {
-//        reset(view);
-//        stub(view.getRootView()).toReturn(view);
-//        stub(view.isDrawingCacheEnabled()).toReturn(false);
-//
-//        subject = new AdAlertReporter(context, view, adConfiguration);
-//
-//        verify(view).setDrawingCacheEnabled(false);
+        reset(mockView);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.isDrawingCacheEnabled()).toReturn(false);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        verify(mockView).setDrawingCacheEnabled(false);
     }
 
     @Test
     public void getScreenshot_whenViewIsNull_shouldPass() throws Exception {
-        subject = new AdAlertReporter(context, null, adConfiguration);
+        subject = new AdAlertReporter(mockContext, null, mockAdReport);
 
         // pass
     }
 
     @Test
     public void getScreenshot_whenRootViewIsNull_shouldPass() throws Exception {
-        stub(view.getRootView()).toReturn(null);
+        stub(mockView.getRootView()).toReturn(null);
 
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         // pass
     }
 
     @Test
     public void getScreenshot_whenRootViewDrawingCacheIsNull_shouldPass() throws Exception {
-        stub(view.getDrawingCache()).toReturn(null);
+        stub(mockView.getDrawingCache()).toReturn(null);
 
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         // pass
     }
-
-    private String getCurrentDateTime() {
-        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z");
-        return dateFormat.format(now);
-    }
 }
-
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
deleted file mode 100644
index f238ba05..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
+++ /dev/null
@@ -1,277 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.Build;
-
-import com.mopub.common.MoPub;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.TestDateAndTime;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import java.util.*;
-
-import static com.mopub.mobileads.AdViewController.MINIMUM_REFRESH_TIME_MILLISECONDS;
-import static com.mopub.common.util.ResponseHeader.AD_TIMEOUT;
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.DSP_CREATIVE_ID;
-import static com.mopub.common.util.ResponseHeader.FAIL_URL;
-import static com.mopub.common.util.ResponseHeader.HEIGHT;
-import static com.mopub.common.util.ResponseHeader.IMPRESSION_URL;
-import static com.mopub.common.util.ResponseHeader.NETWORK_TYPE;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.REFRESH_TIME;
-import static com.mopub.common.util.ResponseHeader.WIDTH;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@RunWith(SdkTestRunner.class)
-public class AdConfigurationTest {
-    private AdConfiguration subject;
-    private Context context;
-    private TestHttpResponseWithHeaders httpResponse;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-
-        subject = new AdConfiguration(context);
-
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-    }
-
-    @Test
-    public void constructor_shouldSetDefaults() throws Exception {
-        assertThat(subject.getAdUnitId()).isNull();
-        assertThat(subject.getResponseString()).isNull();
-        assertThat(subject.getAdType()).isNull();
-        assertThat(subject.getNetworkType()).isNull();
-        assertThat(subject.getRedirectUrl()).isNull();
-        assertThat(subject.getClickthroughUrl()).isNull();
-        assertThat(subject.getImpressionUrl()).isNull();
-        assertThat(subject.getTimeStamp()).isEqualTo(TestDateAndTime.now().getTime());
-        assertThat(subject.getWidth()).isEqualTo(0);
-        assertThat(subject.getHeight()).isEqualTo(0);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(60000);
-        assertThat(subject.getFailUrl()).isNull();
-        assertThat(subject.getDspCreativeId()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetHashedUdid() throws Exception {
-        // this is sha1 of null
-        assertThat(subject.getHashedUdid()).isEqualTo("da39a3ee5e6b4b0d3255bfef95601890afd80709");
-    }
-
-    @Test
-    public void constructor_withNullContext_shouldNotSetHashedUdid() throws Exception {
-        subject = new AdConfiguration(null);
-
-        assertThat(subject.getHashedUdid()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetUserAgent() throws Exception {
-        assertThat(subject.getUserAgent()).isEqualTo("Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30");
-    }
-
-    @Test
-    public void constructor_withNullContext_shouldSetUserAgent() throws Exception {
-        subject = new AdConfiguration(null);
-
-        assertThat(subject.getUserAgent()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetDeviceLocale() throws Exception {
-        Robolectric.getShadowApplication().getResources().getConfiguration().locale = Locale.FRANCE;
-
-        subject = new AdConfiguration(context);
-
-        assertThat(subject.getDeviceLocale()).isEqualTo("fr_FR");
-    }
-
-    @Test
-    public void constructor_withNullContext_shouldNotSetDeviceLocale() throws Exception {
-        Robolectric.getShadowApplication().getResources().getConfiguration().locale = Locale.FRANCE;
-
-        subject = new AdConfiguration(null);
-
-        assertThat(subject.getDeviceLocale()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetDeviceModelAndPlatformVersionAndSdkVersion() throws Exception {
-        assertThat(subject.getDeviceModel()).isNotNull();
-        assertThat(subject.getPlatformVersion()).isEqualTo(Build.VERSION.SDK_INT);
-        assertThat(subject.getSdkVersion()).isEqualTo(MoPub.SDK_VERSION);
-    }
-
-    @Test
-    public void constructor_shouldSetBroadcastIdentifier() throws Exception {
-        assertThat(subject.getBroadcastIdentifier()).isGreaterThan(0);
-    }
-
-    @Test
-    public void addHttpResponse_shouldSetFields() throws Exception {
-        Date now = new Date();
-        TestDateAndTime.getInstance().setNow(now);
-
-        httpResponse.addHeader(AD_TYPE.getKey(), "this is an ad type");
-        httpResponse.addHeader(NETWORK_TYPE.getKey(), "network type!");
-        httpResponse.addHeader(REDIRECT_URL.getKey(), "redirect url");
-        httpResponse.addHeader(CLICKTHROUGH_URL.getKey(), "clickthrough url");
-        httpResponse.addHeader(FAIL_URL.getKey(), "fail url");
-        httpResponse.addHeader(IMPRESSION_URL.getKey(), "impression url");
-        httpResponse.addHeader(WIDTH.getKey(), "320  ");
-        httpResponse.addHeader(HEIGHT.getKey(), "  50");
-        httpResponse.addHeader(AD_TIMEOUT.getKey(), "  12  ");
-        httpResponse.addHeader(REFRESH_TIME.getKey(), "70");
-        httpResponse.addHeader(DSP_CREATIVE_ID.getKey(), "1534363");
-
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getAdType()).isEqualTo("this is an ad type");
-        assertThat(subject.getNetworkType()).isEqualTo("network type!");
-        assertThat(subject.getRedirectUrl()).isEqualTo("redirect url");
-        assertThat(subject.getClickthroughUrl()).isEqualTo("clickthrough url");
-        assertThat(subject.getFailUrl()).isEqualTo("fail url");
-        assertThat(subject.getImpressionUrl()).isEqualTo("impression url");
-        assertThat(subject.getTimeStamp()).isEqualTo(now.getTime());
-        assertThat(subject.getWidth()).isEqualTo(320);
-        assertThat(subject.getHeight()).isEqualTo(50);
-        assertThat(subject.getAdTimeoutDelay()).isEqualTo(12);
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(70000);
-        assertThat(subject.getDspCreativeId()).isEqualTo("1534363");
-    }
-
-    @Test
-    public void addHttpResponse_withMissingWidthHeader_shouldSetWidthTo0() throws Exception {
-        httpResponse.addHeader(HEIGHT.getKey(), "25");
-
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getWidth()).isEqualTo(0);
-    }
-
-    @Test
-    public void addHttpResponse_withMissingHeightHeader_shouldSetHeightTo0() throws Exception {
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getHeight()).isEqualTo(0);
-    }
-
-    @Test
-    public void addHttpResponse_withFloatTimeoutDelay_shouldTruncateTimeoutDelay() throws Exception {
-        httpResponse.addHeader("X-AdTimeout", "3.14");
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isEqualTo(3);
-
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        httpResponse.addHeader("X-AdTimeout", "-3.14");
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isEqualTo(-3);
-    }
-
-    @Test
-    public void addHttpResponse_withInvalidTimeoutDelay_shouldSetAdTimeoutDelayToNull() throws Exception {
-        // no X-AdTimeout header
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        httpResponse.addHeader("X-AdTimeout", "not a number, i promise");
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-    }
-
-    @Test
-    public void addHttpResponse_shouldSetRefreshTimeToMinimumOf10Seconds() throws Exception {
-        httpResponse.addHeader("X-Refreshtime", "0");
-
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(MINIMUM_REFRESH_TIME_MILLISECONDS);
-    }
-
-    @Test
-    public void addHttpResponse_whenRefreshTimeNotSpecified_shouldResetRefreshTimeTo0Seconds() throws Exception {
-        httpResponse.addHeader("X-Refreshtime", "5");
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(MINIMUM_REFRESH_TIME_MILLISECONDS);
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        // no X-Refreshtime header
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(0);
-    }
-
-    @Test
-    public void cleanup_shouldClearAllFields() throws Exception {
-        Date now = new Date();
-        TestDateAndTime.getInstance().setNow(now);
-
-        httpResponse.addHeader(AD_TYPE.getKey(), "this is an ad type");
-        httpResponse.addHeader(NETWORK_TYPE.getKey(), "network type!");
-        httpResponse.addHeader(REDIRECT_URL.getKey(), "redirect url");
-        httpResponse.addHeader(CLICKTHROUGH_URL.getKey(), "clickthrough url");
-        httpResponse.addHeader(FAIL_URL.getKey(), "fail url");
-        httpResponse.addHeader(IMPRESSION_URL.getKey(), "impression url");
-        httpResponse.addHeader(WIDTH.getKey(), "320  ");
-        httpResponse.addHeader(HEIGHT.getKey(), "  50");
-        httpResponse.addHeader(AD_TIMEOUT.getKey(), "  12  ");
-        httpResponse.addHeader(REFRESH_TIME.getKey(), "70");
-        httpResponse.addHeader(DSP_CREATIVE_ID.getKey(), "1534363");
-
-        subject.addHttpResponse(httpResponse);
-        subject.cleanup();
-
-        assertThat(subject.getBroadcastIdentifier()).isEqualTo(0);
-        assertThat(subject.getAdUnitId()).isNull();
-        assertThat(subject.getResponseString()).isNull();
-        assertThat(subject.getAdType()).isNull();
-        assertThat(subject.getNetworkType()).isNull();
-        assertThat(subject.getRedirectUrl()).isNull();
-        assertThat(subject.getClickthroughUrl()).isNull();
-        assertThat(subject.getImpressionUrl()).isNull();
-        assertThat(subject.getTimeStamp()).isEqualTo(TestDateAndTime.now().getTime());
-        assertThat(subject.getWidth()).isEqualTo(0);
-        assertThat(subject.getHeight()).isEqualTo(0);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(60000);
-        assertThat(subject.getFailUrl()).isNull();
-        assertThat(subject.getDspCreativeId()).isNull();
-    }
-
-    @Test
-    public void extractFromMap_shouldReturnValidAdConfiguration() throws Exception {
-        Map<String, Object> map = new HashMap<String, Object>();
-        map.put(AdFetcher.AD_CONFIGURATION_KEY, subject);
-
-        AdConfiguration returnValue = AdConfiguration.extractFromMap(map);
-
-        assertThat(returnValue).isEqualTo(subject);
-    }
-
-    @Test
-    public void extractFromMap_withNullMap_shouldReturnNull() throws Exception {
-        AdConfiguration returnValue = AdConfiguration.extractFromMap(null);
-
-        assertThat(returnValue).isEqualTo(null);
-    }
-
-    @Test
-    public void extractFromMap_withNonAdConfigurationObjectInMap_shouldReturnNull() throws Exception {
-        Map<String, Object> map = new HashMap<String, Object>();
-        map.put(AdFetcher.AD_CONFIGURATION_KEY, "not_an_ad_configuration");
-
-        AdConfiguration returnValue = AdConfiguration.extractFromMap(map);
-
-        assertThat(returnValue).isEqualTo(null);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
deleted file mode 100644
index 22cf06bc..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package com.mopub.mobileads;
-
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.factories.AdFetchTaskFactory;
-import com.mopub.mobileads.test.support.TestAdFetchTaskFactory;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-
-import org.apache.http.HttpResponse;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Executor;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
-import static com.mopub.common.util.ResponseHeader.FULL_AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.common.util.VersionCode.GINGERBREAD;
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class AdFetcherTest {
-    private AdFetcher subject;
-    private AdViewController adViewController;
-    private MoPubView moPubView;
-    private HttpResponse response;
-
-    @Before
-    public void setup() {
-        adViewController = mock(AdViewController.class);
-        moPubView = mock(MoPubView.class);
-        stub(adViewController.getMoPubView()).toReturn(moPubView);
-
-        subject = new AdFetcher(adViewController, "expected userAgent");
-        response = new TestHttpResponseWithHeaders(200, "yahoo!!!");
-    }
-
-    @Test
-    public void shouldSendResponseToAdView() {
-        Robolectric.addPendingHttpResponse(response);
-
-        subject.fetchAdForUrl("url");
-
-        verify(adViewController).configureUsingHttpResponse(eq(response));
-    }
-
-    @Test
-    public void fetchAdForUrl_shouldRouteMillennialBannerToCustomEventHandling() throws Exception {
-        String json = "{\"adWidth\": 320, \"adHeight\": 50, \"adUnitID\": \"44310\"}";
-        stub(adViewController.getAdConfiguration()).toReturn(mock(AdConfiguration.class));
-        response.addHeader(AD_TYPE.getKey(), "millennial_native");
-        response.addHeader(NATIVE_PARAMS.getKey(), json);
-        Robolectric.addPendingHttpResponse(response);
-
-        subject.fetchAdForUrl("ignored_url");
-
-        Map<String, String> paramsMap = new HashMap<String, String>();
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "com.mopub.mobileads.MillennialBanner");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), json);
-
-        verify(moPubView).loadCustomEvent(eq(paramsMap));
-    }
-
-    @Test
-    public void fetchAdForUrl_shouldRouteMillennialInterstitialToCustomEventHandling() throws Exception {
-        AdViewController interstitialAdViewController = mock(AdViewController.class);
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
-        stub(interstitialAdViewController.getMoPubView()).toReturn(moPubInterstitialView);
-        stub(interstitialAdViewController.getAdConfiguration()).toReturn(mock(AdConfiguration.class));
-        subject = new AdFetcher(interstitialAdViewController, "expected userAgent");
-
-        String json = "{\"adWidth\": 320, \"adHeight\": 480, \"adUnitID\": \"44310\"}";
-        response.addHeader(AD_TYPE.getKey(), "interstitial");
-        response.addHeader(FULL_AD_TYPE.getKey(), "millennial_full");
-        response.addHeader(NATIVE_PARAMS.getKey(), json);
-        Robolectric.addPendingHttpResponse(response);
-
-        subject.fetchAdForUrl("ignored_url");
-
-        Map<String, String> paramsMap = new HashMap<String, String>();
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "com.mopub.mobileads.MillennialInterstitial");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), json);
-
-        verify(moPubInterstitialView).loadCustomEvent(eq(paramsMap));
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void fetchAdForUrl_atLeastIcs_shouldExecuteUsingAnExecutor() throws Exception {
-        AdFetchTaskFactory.setInstance(new TestAdFetchTaskFactory());
-        AdFetchTask adFetchTask = TestAdFetchTaskFactory.getSingletonMock();
-
-        subject.fetchAdForUrl("some url");
-
-        verify(adFetchTask).executeOnExecutor(any(Executor.class), eq("some url"));
-        verify(adFetchTask, never()).execute(anyString());
-    }
-
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
-    @Test
-    public void fetchAdForUrl_beforeHoneycomb_shouldExecuteWithoutAnExecutor() throws Exception {
-        AdFetchTaskFactory.setInstance(new TestAdFetchTaskFactory());
-        AdFetchTask adFetchTask = TestAdFetchTaskFactory.getSingletonMock();
-
-        subject.fetchAdForUrl("some url");
-
-        verify(adFetchTask, never()).executeOnExecutor(any(Executor.class), anyString());
-        verify(adFetchTask).execute(eq("some url"));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoadTaskTest.java
deleted file mode 100644
index a14bf614..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoadTaskTest.java
+++ /dev/null
@@ -1,193 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.JsonUtils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_SELECTOR;
-import static com.mopub.common.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.SCROLLABLE;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.GOOGLE_PLAY_SERVICES_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.HTML_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.HTML_INTERSTITIAL;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.MRAID_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.MRAID_INTERSTITIAL;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(SdkTestRunner.class)
-public class AdLoadTaskTest {
-
-    private AdViewController adViewController;
-    private HttpResponse response;
-    private String standardExpectedJson;
-
-    @Before
-    public void setup() {
-        adViewController = mock(AdViewController.class);
-        AdConfiguration adConfiguration = mock(AdConfiguration.class);
-        stub(adViewController.getAdConfiguration()).toReturn(adConfiguration);
-        response = new TestHttpResponseWithHeaders(200, "");
-        standardExpectedJson = "{\"Scrollable\":\"false\",\"Redirect-Url\":\"redirect\",\"Clickthrough-Url\":\"clickthrough\",\"Html-Response-Body\":\"%3Chtml%3E%3C%2Fhtml%3E\"}";
-    }
-
-    @Test
-    public void fromHttpResponse_whenCustomEvent_shouldGetNameAndData() throws Exception {
-        String expectedCustomData = "Custom data";
-        response.addHeader(AD_TYPE.getKey(), "custom");
-        String expectedCustomEventName = "custom event name";
-        response.addHeader(CUSTOM_EVENT_NAME.getKey(), expectedCustomEventName);
-        response.addHeader(CUSTOM_EVENT_DATA.getKey(), expectedCustomData);
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(expectedCustomEventName);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey())).isEqualTo(expectedCustomData);
-    }
-
-    @Test
-    public void fromHttpResponse_whenNoCustomEventName_shouldCreateLegacyCustomEventAdLoadTaskWithAHeader() throws Exception {
-        String expectedCustomData = "Custom data";
-        String expectedHeaderValue = "some stuff";
-        response.addHeader(AD_TYPE.getKey(), "custom");
-        response.addHeader(CUSTOM_EVENT_DATA.getKey(), expectedCustomData);
-        response.addHeader(CUSTOM_SELECTOR.getKey(), expectedHeaderValue);
-
-        AdLoadTask.LegacyCustomEventAdLoadTask customEventTask = (AdLoadTask.LegacyCustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        Header taskHeader = customEventTask.getHeader();
-        assertThat(taskHeader).isNotNull();
-        assertThat(taskHeader.getName()).isEqualTo(CUSTOM_SELECTOR.getKey());
-        assertThat(taskHeader.getValue()).isEqualTo(expectedHeaderValue);
-    }
-
-    @Test
-    public void fromHttpResponse_whenMraidBanner_shouldCreateAnEncodedJsonString() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("mraid");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(MRAID_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenMraidInterstitial_shouldCreateAnEncodedJsonString() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("mraid");
-        stub(adViewController.getMoPubView()).toReturn(mock(MoPubInterstitial.MoPubInterstitialView.class));
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(MRAID_INTERSTITIAL.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenCustomEventDelegate_shouldConvertAdMobToCustomEvent() throws Exception {
-        String expectedNativeParams = "{\"this is a json\":\"map\",\"whee\":\"look at me\"}";
-        response.addHeader(AD_TYPE.getKey(), "admob_native");
-        response.addHeader(NATIVE_PARAMS.getKey(), expectedNativeParams);
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(GOOGLE_PLAY_SERVICES_BANNER.toString());
-
-        String actualNativeParams = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualNativeParams, expectedNativeParams);
-    }
-
-    @Test
-    public void fromHttpResponse_whenHtmlBanner_shouldConvertToCustomEventBanner() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("html");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenHtmlInterstitial_shouldConvertToCustomEventInterstitial() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("html");
-        stub(adViewController.getMoPubView()).toReturn(mock(MoPubInterstitial.MoPubInterstitialView.class));
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_INTERSTITIAL.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenEntityIsNull_shouldCreateMinimumJsonString() throws Exception {
-        String htmlData = "<html></html>";
-        String expectedJson = "{\"Scrollable\":\"false\",\"Html-Response-Body\":\"\"}";
-        response = new TestHttpResponseWithHeaders(200, htmlData) {
-            @Override
-            public HttpEntity getEntity() {
-                return null;
-            }
-        };
-        response.addHeader(AD_TYPE.getKey(), "html");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, expectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenScrollableIsOne_shouldBeReflectedInJson() throws Exception {
-        String expectedJson = "{\"Scrollable\":\"true\",\"Html-Response-Body\":\"\"}";
-        response.addHeader(SCROLLABLE.getKey(), "1");
-        response.addHeader(AD_TYPE.getKey(), "html");
-
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, expectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenScrollableIsNotSpecified_shouldDefaultToFalseInJson() throws Exception {
-        String expectedJson = "{\"Scrollable\":\"false\",\"Html-Response-Body\":\"\"}";
-        response.addHeader(AD_TYPE.getKey(), "html");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, expectedJson);
-    }
-
-    private void addExpectedResponseHeaders(String adType) {
-        response.addHeader(SCROLLABLE.getKey(), "0");
-        response.addHeader(AD_TYPE.getKey(), adType);
-        response.addHeader(REDIRECT_URL.getKey(), "redirect");
-        response.addHeader(CLICKTHROUGH_URL.getKey(), "clickthrough");
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
new file mode 100644
index 00000000..8f8639da
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
@@ -0,0 +1,140 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.AdResponse;
+
+import org.fest.assertions.core.Condition;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyMapOf;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class AdLoaderTest {
+
+    @Mock
+    private AdViewController adViewController;
+    @Mock
+    private MoPubView moPubView;
+    private AdResponse adResponse;
+    private Map<String, String> serverExtras;
+
+    @Before
+    public void setup() {
+        adResponse = new AdResponse.Builder()
+                .setResponseBody("<html></html>")
+                .setClickTrackingUrl("clickthrough")
+                .setRedirectUrl("redirect")
+                .setScrollable(false)
+                .build();
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("test", "hi");
+        when(adViewController.getMoPubView()).thenReturn(moPubView);
+    }
+
+    @Test
+    public void fromAdResponse_whenCustomEvent_shouldCreateAdLoadTask() throws Exception {
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+        assertThat(customEventTask).isNotNull();
+        assertThat(customEventTask.getServerExtras()).isEqualTo(serverExtras);
+    }
+
+
+    @Test
+    public void fromAdResponse_whenHtml_shouldBeModernAdLoadTask() {
+        adResponse = adResponse.toBuilder()
+                .setAdType("html")
+                .setCustomEventClassName("com.mopub.mobileads.HtmlBanner")
+                .setServerExtras(serverExtras)
+                .build();
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+        assertThat(customEventTask).isNotNull();
+        assertThat(customEventTask.getServerExtras()).has(new Condition<Map<String, String>>() {
+            @Override
+            public boolean matches(final Map<String, String> stringStringMap) {
+                return stringStringMap.containsKey("test");
+            }
+        });
+    }
+
+    @Test
+    public void fromAdResponse_whenCustomMethod_shouldReturnNull() {
+        adResponse = adResponse.toBuilder()
+                .setCustomEventClassName(null)
+                .build();
+
+        assertThat(AdLoader.fromAdResponse(adResponse, adViewController)).isNull();
+    }
+
+    @Test
+    public void load_shouldCallAdViewController() {
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+
+        customEventTask.load();
+        verify(adViewController).getMoPubView();
+        verify(moPubView).loadCustomEvent(eq("custom event name"), anyMapOf(String.class, String.class));
+    }
+
+    @Test
+    public void load_controllerDestroyed_shouldDoNothing() {
+        when(adViewController.isDestroyed()).thenReturn(true);
+
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+
+        customEventTask.load();
+        verify(adViewController).isDestroyed();
+        verifyNoMoreInteractions(adViewController);
+        verifyZeroInteractions(moPubView);
+    }
+
+    @Test
+    public void load_withNullMoPubView_shouldDoNothing() throws Exception {
+        when(adViewController.getMoPubView()).thenReturn(null);
+
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+
+        customEventTask.load();
+
+        verify(adViewController).getMoPubView();
+        verifyZeroInteractions(moPubView);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
new file mode 100644
index 00000000..b82dcbe8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
@@ -0,0 +1,127 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class AdRequestStatusMappingTest {
+    private AdRequestStatusMapping subject;
+    private String key1;
+
+    @Before
+    public void setUp() {
+        subject = new AdRequestStatusMapping();
+        key1 = "adUnitId1";
+    }
+
+    @Test
+    public void markFail_shouldNullOutAllValues() {
+        subject.markFail(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markLoading_shouldNotUpdateUrls_shouldSetIsLoadingTrue() {
+        subject.markLoading(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isTrue();
+    }
+
+    @Test
+    public void markLoaded_shouldUpdateUrls_shouldSetCanPlayTrue() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+
+        assertThat(subject.canPlay(key1)).isTrue();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markLoaded_withNullValues_shouldUpdateUrls_shouldSetCanPlayTrue() {
+        subject.markLoaded(key1, null, null, null);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isTrue();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markPlayed_afterLoaded_shouldKeepExistingUrls_shouldSetCanPlayFalse() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.markPlayed(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markPlayed_beforeLoaded_shouldSetUrlsNull_shouldSetCanPlayFalse() {
+        subject.markPlayed(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void clearImpression_shouldResetImpressionUrl() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.clearImpressionUrl(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+    }
+
+    @Test
+    public void clearclick_shouldResetClickurl() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.clearClickUrl(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+    }
+
+    @Test
+    public void allAccessors_withInvalidKey_shouldReturnDefaultsAndNotThrowExceptions() {
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+
+        subject.clearImpressionUrl(key1);
+        subject.clearClickUrl(key1);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
index fb137103..2d782a64 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
@@ -3,11 +3,17 @@
 import android.app.Activity;
 import android.content.Context;
 
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import java.util.HashMap;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -18,85 +24,109 @@
     private String customEventName;
     private MoPubView moPubView;
     private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
-    private Context context;
+    HashMap<String, String> headers;
 
     @Before
     public void setUp() throws Exception {
         moPubView = mock(MoPubView.class);
         moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
 
-        context = new Activity();
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
         stub(moPubView.getContext()).toReturn(context);
         stub(moPubInterstitialView.getContext()).toReturn(context);
+
+        headers = new HashMap<String, String>();
     }
 
     @Test
-    public void getAdMobBannerReturnsGooglePlayServicesBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "admob_native", null);
+    public void getCustomEventName_shouldBeGoogleBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "admob_native", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesBanner");
     }
 
     @Test
-    public void getAdMobInterstitialReturnsGooglePlayServicesInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "interstitial", "admob_full");
+    public void getCustomEventName_shouldBeGoogleInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "interstitial", "admob_full", headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesInterstitial");
     }
 
     @Test
-    public void getMillennialBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "millennial_native", null);
+    public void getCustomEventName_shouldBeMillenialBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "millennial_native", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialBanner");
     }
 
     @Test
-    public void getMillennnialInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "interstitial", "millennial_full");
+    public void getCustomEventName_shouldBeMillennialIntersitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "millennial_full", headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialInterstitial");
     }
 
     @Test
-    public void getMraidBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "mraid", null);
+    public void getCustomEventName_shouldBeMraidBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.MRAID, null, headers);
 
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MraidBanner");
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidBanner");
     }
 
     @Test
-    public void getMraidInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "mraid", null);
+    public void getCustomEventName_shouldBeMraidInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, AdType.MRAID, null, headers);
 
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MraidInterstitial");
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidInterstitial");
     }
 
     @Test
-    public void getHtmlBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "html", null);
+    public void getCustomEventName_shouldBeHtmlBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "html", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlBanner");
     }
 
     @Test
-    public void getHtmlInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "html", null);
+    public void getCustomEventName_shouldBeHtmlInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "html", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlInterstitial");
     }
 
     @Test
-    public void getVastInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "interstitial", "vast");
+    public void getCustomEventName_shouldBeVastInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "vast", headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.VastVideoInterstitial");
     }
 
     @Test
-    public void getCustomEventNameForAdType_whenSendingNonsense_shouldReturnNull() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(null, null, null);
+    public void getCustomEventName_shouldBeCustomClassName() {
+        headers.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.example.CustomClass");
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.example.CustomClass");
+    }
+
+    @Test
+    public void getCustomEventName_whenNameNotInHeaders_shouldBeNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isNull();
+    }
+
+    @Test
+    public void getCustomEventName_withNativeFormat_shouldBeMoPubNative() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.NATIVE, null, headers);
 
+        assertThat(customEventName).isEqualTo("com.mopub.nativeads.MoPubCustomEventNative");
+    }
+
+    @Test
+    public void getCustomEventName_whenInvalidAdTypeAndInvalidFullAdType_shouldReturnNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "garbage", "garbage",
+                headers);
         assertThat(customEventName).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index e6473af7..aad6cc28 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -1,84 +1,94 @@
 package com.mopub.mobileads;
 
+import android.Manifest;
 import android.app.Activity;
 import android.content.Context;
-import android.location.Location;
 import android.net.ConnectivityManager;
-import android.os.Build;
 import android.view.Gravity;
 import android.view.View;
-import android.webkit.WebView;
 import android.widget.FrameLayout;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
-import com.mopub.common.MoPub;
-import com.mopub.common.SharedPreferencesHelper;
+
+import com.mopub.common.AdFormat;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Reflection;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.test.support.TestAdFetcherFactory;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.ThreadUtils;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.conn.ClientConnectionManager;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
 
-import java.lang.reflect.InvocationTargetException;
+import java.util.Collections;
 
-import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.common.util.Reflection.MethodBuilder;
-import static com.mopub.mobileads.AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS;
-import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NO_FILL;
-import static com.mopub.mobileads.test.support.ThreadUtils.NETWORK_DELAY;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Fail.fail;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class AdViewControllerTest {
+
+    private static final int[] HTML_ERROR_CODES = new int[]{400, 401, 402, 403, 404, 405, 407, 408,
+            409, 410, 411, 412, 413, 414, 415, 416, 417, 500, 501, 502, 503, 504, 505};
+
     private AdViewController subject;
-    private MoPubView moPubView;
-    private HttpResponse response;
-    private HttpClient httpClient;
-    private AdFetcher adFetcher;
-    private MethodBuilder methodBuilder;
-    private Activity context;
+    @Mock
+    private MoPubView mockMoPubView;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    private Reflection.MethodBuilder methodBuilder;
+
+    private AdResponse response;
+    private Activity activity;
 
     @Before
     public void setup() {
-        context = new Activity();
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        shadowOf(activity).grantPermissions(android.Manifest.permission.ACCESS_NETWORK_STATE);
 
-        moPubView = mock(MoPubView.class);
-        stub(moPubView.getContext()).toReturn(context);
+        when(mockMoPubView.getAdFormat()).thenReturn(AdFormat.BANNER);
+        when(mockMoPubView.getContext()).thenReturn(activity);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
 
-        httpClient = HttpClientFactory.create();
+        subject = new AdViewController(activity, mockMoPubView);
 
-        subject = new AdViewController(context, moPubView);
-        response = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        adFetcher = TestAdFetcherFactory.getSingletonMock();
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
         reset(methodBuilder);
+        response = new AdResponse.Builder()
+                .setCustomEventClassName("customEvent")
+                .setClickTrackingUrl("clickUrl")
+                .setImpressionTrackingUrl("impressionUrl")
+                .setRedirectUrl("redirectUrl")
+                .setScrollable(false)
+                .setDimensions(320, 50)
+                .setAdType("html")
+                .setFailoverUrl("failUrl")
+                .setResponseBody("testResponseBody")
+                .setServerExtras(Collections.<String, String>emptyMap())
+                .build();
     }
 
     @After
@@ -87,64 +97,108 @@ public void tearDown() throws Exception {
     }
 
     @Test
-    public void scheduleRefreshTimerIfEnabled_shouldCancelOldRefreshAndScheduleANewOne() throws Exception {
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
+    public void cleanup_shouldNotHoldViewOrUrlGenerator() {
+        subject.cleanup();
+
+        assertThat(subject.getMoPubView()).isNull();
+        assertThat(subject.generateAdUrl()).isNull();
+    }
+
+    @Test
+    public void adDidFail_shouldScheduleRefreshTimer_shouldCallMoPubViewAdFailed() throws Exception {
         Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
-        subject.scheduleRefreshTimerIfEnabled();
+        subject.adDidFail(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
 
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        verify(mockMoPubView).adFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+    }
 
-        subject.scheduleRefreshTimerIfEnabled();
+    @Test
+    public void adDidFail_withNullMoPubView_shouldNotScheduleRefreshTimer_shouldNotCallMoPubViewAdFailed() throws Exception {
+        Robolectric.pauseMainLooper();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        // This sets the MoPubView to null
+        subject.cleanup();
+        subject.adDidFail(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        verify(mockMoPubView, never()).adFailed(any(MoPubErrorCode.class));
     }
 
-    @Test
-    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutorefreshIsOff() throws Exception {
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
 
+    @Test
+    public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsNull() throws Exception {
+        response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
+        subject.onAdLoadSuccess(response);
         Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
-        subject.forceSetAutorefreshEnabled(false);
-
         subject.scheduleRefreshTimerIfEnabled();
 
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
     }
 
     @Test
-    public void scheduleRefreshTimer_whenAdViewControllerNotConfiguredByResponse_shouldHaveDefaultRefreshTime() throws Exception {
+    public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsZero() {
+        response = response.toBuilder().setRefreshTimeMilliseconds(0).build();
+        subject.onAdLoadSuccess(response);
         Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void scheduleRefreshTimerIfEnabled_shouldCancelOldRefreshAndScheduleANewOne() throws Exception {
+        response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
+        subject.onAdLoadSuccess(response);
+        Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
-        Robolectric.idleMainLooper(DEFAULT_REFRESH_TIME_MILLISECONDS - 1);
+        subject.scheduleRefreshTimerIfEnabled();
+
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
-        Robolectric.idleMainLooper(1);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        subject.scheduleRefreshTimerIfEnabled();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
     }
 
     @Test
-    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfRefreshTimeIsZero() throws Exception {
-//        response.addHeader("X-Refreshtime", "0");
-        subject.configureUsingHttpResponse(response);
+    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutorefreshIsOff() throws Exception {
+        response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
+        subject.onAdLoadSuccess(response);
+
         Robolectric.pauseMainLooper();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        subject.forceSetAutorefreshEnabled(false);
 
+        subject.scheduleRefreshTimerIfEnabled();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void scheduleRefreshTimer_whenAdViewControllerNotConfiguredByResponse_shouldHaveDefaultRefreshTime() throws Exception {
+        Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
+        Robolectric.idleMainLooper(AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS - 1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        Robolectric.idleMainLooper(1);
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
     }
-    
+
     @Test
     public void forceSetAutoRefreshEnabled_shouldSetAutoRefreshSetting() throws Exception {
         assertThat(subject.getAutorefreshEnabled()).isTrue();
@@ -167,7 +221,7 @@ public void pauseRefresh_shouldDisableAutorefresh() throws Exception {
     @Test
     public void unpauseRefresh_afterUnpauseRefresh_shouldEnableRefresh() throws Exception {
         subject.pauseRefresh();
-        
+
         subject.unpauseRefresh();
         assertThat(subject.getAutorefreshEnabled()).isTrue();
     }
@@ -186,6 +240,7 @@ public void pauseAndUnpauseRefresh_withRefreshForceDisabled_shouldAlwaysHaveRefr
 
     @Test
     public void enablingAutoRefresh_afterLoadAd_shouldScheduleNewRefreshTimer() throws Exception {
+
         final AdViewController adViewControllerSpy = spy(subject);
 
         adViewControllerSpy.loadAd();
@@ -203,9 +258,8 @@ public void enablingAutoRefresh_withoutCallingLoadAd_shouldNotScheduleNewRefresh
 
     @Test
     public void disablingAutoRefresh_shouldCancelRefreshTimers() throws Exception {
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
-
+        response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
+        subject.onAdLoadSuccess(response);
         Robolectric.pauseMainLooper();
 
         subject.loadAd();
@@ -217,208 +271,55 @@ public void disablingAutoRefresh_shouldCancelRefreshTimers() throws Exception {
     }
 
     @Test
-    public void trackImpression_shouldHttpGetTheImpressionUrl() throws Exception {
-        response.addHeader("X-Imptracker", "http://trackingUrl");
-        subject.configureUsingHttpResponse(response);
-        String expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
-        assertThat(expectedUserAgent).isNotNull();
-
+    public void trackImpression_shouldAddToRequestQueue() throws Exception {
+        subject.onAdLoadSuccess(response);
         subject.trackImpression();
-        ThreadUtils.pause(NETWORK_DELAY); // does this make the test flaky?
-
-        HttpRequest request = fakeHttpLayer.getLastSentHttpRequestInfo().getHttpRequest();
-        assertThat(request.getFirstHeader("User-Agent").getValue()).isEqualTo(expectedUserAgent);
-        assertThat(request.getRequestLine().getUri()).isEqualTo("http://trackingUrl");
-
-        ClientConnectionManager connectionManager = httpClient.getConnectionManager();
-        try {
-            new MethodBuilder(connectionManager, "assertStillUp").setAccessible().execute();
-            fail("should have thrown an exception");
-        } catch (InvocationTargetException expected) {
-            assertThat(expected.getCause()).isInstanceOf(IllegalStateException.class);
-        }
+
+        verify(mockRequestQueue).add(argThat(isUrl("impressionUrl")));
     }
 
-    // this test for impressionUrl is unnecessary (since we're catching the NullPointerException)
     @Test
-    public void trackImpression_shouldDoNothingIfImpressionUrlNotSpecified() throws Exception {
-        subject.configureUsingHttpResponse(response);
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
+    public void trackImpression_noAdResponse_shouldNotAddToQueue() {
         subject.trackImpression();
-        Thread.sleep(300); // does this make the test flaky?
 
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
     public void registerClick_shouldHttpGetTheClickthroughUrl() throws Exception {
-        response.addHeader("X-Clickthrough", "http://clickUrl");
-        subject.configureUsingHttpResponse(response);
-        String expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
-        assertThat(expectedUserAgent).isNotNull();
+        subject.onAdLoadSuccess(response);
 
         subject.registerClick();
-        Thread.sleep(200); // does this make the test flaky?
-
-        HttpRequest request = fakeHttpLayer.getLastSentHttpRequestInfo().getHttpRequest();
-        assertThat(request.getFirstHeader("User-Agent").getValue()).isEqualTo(expectedUserAgent);
-        assertThat(request.getRequestLine().getUri()).isEqualTo("http://clickUrl");
-
-        ClientConnectionManager connectionManager = httpClient.getConnectionManager();
-        try {
-            new MethodBuilder(connectionManager, "assertStillUp").setAccessible().execute();
-            fail("should have thrown an exception");
-        } catch (InvocationTargetException expected) {
-            assertThat(expected.getCause()).isInstanceOf(IllegalStateException.class);
-        }
+        verify(mockRequestQueue).add(argThat(isUrl("clickUrl")));
     }
 
-    // this test for clickthroughUrl is unnecessary (since we're catching the NullPointerException)
     @Test
-    public void trackImpression_shouldDoNothingIfClickthroughUrlNotSpecified() throws Exception {
-        subject.configureUsingHttpResponse(response);
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
+    public void registerClick_NoAdResponse_shouldNotAddToQueue() {
         subject.registerClick();
-        Thread.sleep(50); // does this make the test flaky?
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void generateAdUrl_shouldIncludeMinFields() throws Exception {
-        String expectedAdUrl = "http://ads.mopub.com/m/ad" +
-                "?v=6" +
-                "&nv=" + MoPub.SDK_VERSION +
-                "&dn=" + Build.MANUFACTURER +
-                "%2C" + Build.MODEL +
-                "%2C" + Build.PRODUCT +
-                "&udid=sha%3A" +
-                "&z=-0700" +
-                "&o=u" +
-                "&sc_a=1.0" +
-                "&mr=1" +
-                "&ct=3" +
-                "&av=1.0" +
-                "&android_perms_ext_storage=0";
-
-        String adUrl = subject.generateAdUrl();
-
-        assertThat(adUrl).isEqualTo(expectedAdUrl);
-    }
-
-    @Test
-    public void loadAd_shouldNotLoadUrlIfAdUnitIdIsNull() throws Exception {
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-
-        subject.loadAd();
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+    public void fetchAd_withNullMoPubView_shouldNotMakeRequest() throws Exception {
+        subject.cleanup();
+        subject.fetchAd("adUrl");
+        verify(mockRequestQueue, never()).add(any(AdRequest.class));
     }
 
     @Test
-    public void loadAd_shouldScheduleRefreshIfNoNetworkConnectivity() throws Exception {
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        Robolectric.pauseMainLooper();
-        ConnectivityManager connectivityManager = (ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE);
+    public void loadAd_shouldNotLoadWithoutConnectivity() throws Exception {
+        ConnectivityManager connectivityManager = (ConnectivityManager) Robolectric.application.getSystemService(Context.CONNECTIVITY_SERVICE);
         shadowOf(connectivityManager.getActiveNetworkInfo()).setConnectionStatus(false);
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
-        subject.setAdUnitId("adUnitId");
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        subject.loadAd();
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-    }
-
-    @Test
-    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
-        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
-        GpsHelperTest.verifyCleanClientMetadata(context);
 
-        GpsHelper.setClassNamesForTesting();
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.ADVERTISING_ID,
-                adInfo.LIMIT_AD_TRACKING_ENABLED
-        );
-
-        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
-                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
-        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
-        subject.setAdUnitId("adUnitId");
-        subject.setLocation(new Location(""));
-        subject.loadAd();
-        Thread.sleep(500);
-
-        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void loadAd_whenGooglePlayServicesIsNotLinked_shouldFetchAdFast() throws Exception {
-        GpsHelperTest.verifyCleanClientMetadata(context);
-
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        // return error code so it fails
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-
-        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
-                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
-        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
-        subject.setAdUnitId("adUnitId");
-        subject.setLocation(new Location(""));
         subject.loadAd();
-        // no need to sleep since it run the callback without an async task
-
-        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyCleanClientMetadata(context);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFetchAdFast() throws Exception {
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        GpsHelperTest.populateAndVerifyClientMetadata(context, adInfo);
-        GpsHelper.setClassNamesForTesting();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled
-        );
-
-        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
-                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
-        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
-        subject.setAdUnitId("adUnitId");
-        subject.setLocation(new Location(""));
+    public void loadAd_shouldNotLoadUrlIfAdUnitIdIsNull() throws Exception {
         subject.loadAd();
-        // no need to sleep since it run the callback without an async task
 
-        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
@@ -426,28 +327,17 @@ public void loadNonJavascript_shouldFetchAd() throws Exception {
         String url = "http://www.guy.com";
         subject.loadNonJavascript(url);
 
-        verify(adFetcher).fetchAdForUrl(eq(url));
+        verify(mockRequestQueue).add(argThat(isUrl(url)));
     }
 
     @Test
     public void loadNonJavascript_whenAlreadyLoading_shouldNotFetchAd() throws Exception {
         String url = "http://www.guy.com";
         subject.loadNonJavascript(url);
-        reset(adFetcher);
+        reset(mockRequestQueue);
         subject.loadNonJavascript(url);
 
-        verify(adFetcher, never()).fetchAdForUrl(anyString());
-    }
-
-    @Test
-    public void loadNonJavascript_shouldClearTheFailUrl() throws Exception {
-        subject.setFailUrl("blarg:");
-        subject.loadNonJavascript("http://www.goodness.com");
-        reset(adFetcher);
-        subject.loadFailUrl(null);
-
-        verify(adFetcher, never()).fetchAdForUrl(anyString());
-        verify(moPubView).adFailed(eq(NO_FILL));
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
     @Test
@@ -461,20 +351,19 @@ public void reload_shouldReuseOldUrl() throws Exception {
         String url = "http://www.guy.com";
         subject.loadNonJavascript(url);
         subject.setNotLoading();
-        reset(adFetcher);
+        reset(mockRequestQueue);
         subject.reload();
 
-        verify(adFetcher).fetchAdForUrl(eq(url));
+        verify(mockRequestQueue).add(argThat(isUrl(url)));
     }
 
     @Test
     public void loadFailUrl_shouldLoadFailUrl() throws Exception {
-        String failUrl = "http://www.bad.man";
-        subject.setFailUrl(failUrl);
-        subject.loadFailUrl(INTERNAL_ERROR);
+        subject.onAdLoadSuccess(response);
+        subject.loadFailUrl(MoPubErrorCode.INTERNAL_ERROR);
 
-        verify(adFetcher).fetchAdForUrl(eq(failUrl));
-        verify(moPubView, never()).adFailed(any(MoPubErrorCode.class));
+        verify(mockRequestQueue).add(argThat(isUrl("failUrl")));
+        verify(mockMoPubView, never()).adFailed(any(MoPubErrorCode.class));
     }
 
     @Test
@@ -485,20 +374,18 @@ public void loadFailUrl_shouldAcceptNullErrorCode() throws Exception {
 
     @Test
     public void loadFailUrl_whenFailUrlIsNull_shouldCallAdDidFail() throws Exception {
-        subject.setFailUrl(null);
-        subject.loadFailUrl(INTERNAL_ERROR);
+        response.toBuilder().setFailoverUrl(null).build();
+        subject.loadFailUrl(MoPubErrorCode.INTERNAL_ERROR);
 
-        verify(moPubView).adFailed(eq(NO_FILL));
-        verify(adFetcher, never()).fetchAdForUrl(anyString());
+        verify(mockMoPubView).adFailed(eq(MoPubErrorCode.NO_FILL));
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
     public void setAdContentView_whenCalledFromWrongUiThread_shouldStillSetContentView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
         final View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         new Thread(new Runnable() {
             @Override
@@ -509,9 +396,9 @@ public void run() {
         ThreadUtils.pause(100);
         Robolectric.runUiThreadTasks();
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(320);
@@ -521,11 +408,9 @@ public void run() {
 
     @Test
     public void setAdContentView_whenCalledAfterCleanUp_shouldNotRemoveViewsAndAddView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
         final View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         subject.cleanup();
         new Thread(new Runnable() {
@@ -537,23 +422,21 @@ public void run() {
         ThreadUtils.pause(10);
         Robolectric.runUiThreadTasks();
 
-        verify(moPubView, never()).removeAllViews();
-        verify(moPubView, never()).addView(any(View.class), any(FrameLayout.LayoutParams.class));
+        verify(mockMoPubView, never()).removeAllViews();
+        verify(mockMoPubView, never()).addView(any(View.class), any(FrameLayout.LayoutParams.class));
     }
 
     @Test
     public void setAdContentView_whenHonorServerDimensionsAndHasDimensions_shouldSizeAndCenterView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
         View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         subject.setAdContentView(view);
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(320);
@@ -563,15 +446,16 @@ public void setAdContentView_whenHonorServerDimensionsAndHasDimensions_shouldSiz
 
     @Test
     public void setAdContentView_whenHonorServerDimensionsAndDoesntHaveDimensions_shouldWrapAndCenterView() throws Exception {
+        response = response.toBuilder().setDimensions(null, null).build();
         View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         subject.setAdContentView(view);
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
@@ -581,20 +465,172 @@ public void setAdContentView_whenHonorServerDimensionsAndDoesntHaveDimensions_sh
 
     @Test
     public void setAdContentView_whenNotServerDimensions_shouldWrapAndCenterView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
         View view = mock(View.class);
 
         subject.setAdContentView(view);
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
         assertThat(layoutParams.height).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
         assertThat(layoutParams.gravity).isEqualTo(Gravity.CENTER);
     }
+
+    @Test
+    public void onAdLoadSuccess_withResponseContainingRefreshTime_shouldSetNewRefreshTime() {
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(60000);
+
+        response = response.toBuilder().setRefreshTimeMilliseconds(100000).build();
+        subject.onAdLoadSuccess(response);
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(100000);
+    }
+
+    @Test
+    public void onAdLoadSuccess_withResponseNotContainingRefreshTime_shoulSetRefreshTimeToNull() {
+        response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
+        subject.onAdLoadSuccess(response);
+
+        assertThat(subject.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void onAdLoadError_withMoPubNetworkErrorIncludingRefreshTime_shouldSetNewRefreshTime() {
+        subject.setRefreshTimeMillis(54321);
+
+        subject.onAdLoadError(
+                new MoPubNetworkError(
+                        "network error with specified refresh time",
+                        MoPubNetworkError.Reason.NO_FILL,
+                        1000)
+        );
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(1000);
+    }
+
+    @Test
+    public void onAdLoadError_withMoPubNetworkErrorNotIncludingRefreshTime_shouldNotModifyRefreshTime() {
+        subject.setRefreshTimeMillis(12345);
+
+        subject.onAdLoadError(
+                new MoPubNetworkError(
+                        "network error that does not specify refresh time",
+                        MoPubNetworkError.Reason.UNSPECIFIED)
+        );
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(12345);
+    }
+
+    @Test
+    public void onAdLoadError_withVolleyErrorThatIsNotAnInstanceOfMoPubNetworkError_shouldNotModifyRefreshTime() {
+        subject.onAdLoadError(new VolleyError("message"));
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(60000);
+    }
+
+    @Test
+    public void onAdLoadError_withErrorReasonWarmingUp_shouldReturnErrorCodeWarmup_shouldCallMoPubViewAdFailed() {
+        final VolleyError expectedInternalError = new MoPubNetworkError(
+                MoPubNetworkError.Reason.WARMING_UP);
+
+        subject.onAdLoadError(expectedInternalError);
+
+        verify(mockMoPubView).adFailed(MoPubErrorCode.WARMUP);
+    }
+
+    @Test
+    public void onAdLoadError_whenNoNetworkConnection_shouldReturnErrorCodeNoConnection_shouldCallMoPubViewAdFailed() {
+        subject.onAdLoadError(new NoConnectionError());
+
+        // DeviceUtils#isNetworkAvailable conveniently returns false due to
+        // not having the network permission.
+        verify(mockMoPubView).adFailed(MoPubErrorCode.NO_CONNECTION);
+    }
+
+    @Test
+    public void onAdLoadError_withInvalidServerResponse_shouldReturnErrorCodeServerError_shouldCallMoPubViewAdFailed_shouldIncrementBackoffPower() {
+        for (int htmlErrorCode : HTML_ERROR_CODES) {
+            final int oldBackoffPower = subject.mBackoffPower;
+            final NetworkResponse errorNetworkResponse = new NetworkResponse(htmlErrorCode, null,
+                    null, true, 0);
+            final VolleyError volleyError = new VolleyError(errorNetworkResponse);
+
+            subject.onAdLoadError(volleyError);
+
+            assertThat(subject.mBackoffPower).isEqualTo(oldBackoffPower + 1);
+        }
+        verify(mockMoPubView, times(HTML_ERROR_CODES.length)).adFailed(MoPubErrorCode.SERVER_ERROR);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_whenNoConnection_shouldReturnErrorCodeNoConnection() {
+        final VolleyError noConnectionError = new NoConnectionError();
+
+        // DeviceUtils#isNetworkAvailable conveniently returns false due to
+        // not having the internet permission.
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                noConnectionError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.NO_CONNECTION);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withNullResponse_whenConnectionValid_shouldReturnErrorCodeUnspecified() {
+        final VolleyError noConnectionError = new NoConnectionError();
+
+        shadowOf(activity).grantPermissions(Manifest.permission.INTERNET);
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                noConnectionError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.UNSPECIFIED);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withInvalidServerResponse_shouldReturnErrorCodeServerError() {
+        for (int htmlErrorCode : HTML_ERROR_CODES) {
+            final NetworkResponse errorNetworkResponse = new NetworkResponse(htmlErrorCode, null,
+                    null, true, 0);
+            final VolleyError volleyError = new VolleyError(errorNetworkResponse);
+
+            final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                    volleyError, activity);
+
+            assertThat(errorCode).isEqualTo(MoPubErrorCode.SERVER_ERROR);
+        }
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonWarmingUp_shouldReturnErrorCodeWarmingUp() {
+        final VolleyError networkError = new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.WARMUP);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonNoFill_shouldReturnErrorCodeNoFill() {
+        final VolleyError networkError = new MoPubNetworkError(MoPubNetworkError.Reason.NO_FILL);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.NO_FILL);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonBadHeaderData_shouldReturnErrorCodeUnspecified() {
+        final VolleyError networkError = new MoPubNetworkError(
+                MoPubNetworkError.Reason.BAD_HEADER_DATA);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.UNSPECIFIED);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
index 0453e1bb..18e64903 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
@@ -1,24 +1,23 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
 import static android.webkit.WebSettings.PluginState;
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
@@ -28,15 +27,15 @@
 @RunWith(SdkTestRunner.class)
 public class BaseHtmlWebViewTest {
 
+    @Mock
+    AdReport mockAdReport;
     private BaseHtmlWebView subject;
     private MotionEvent touchDown;
     private MotionEvent touchUp;
-    private AdConfiguration adConfiguration;
 
     @Before
     public void setUp() throws Exception {
-        adConfiguration = mock(AdConfiguration.class);
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
 
         touchDown = createMotionEvent(MotionEvent.ACTION_DOWN);
         touchUp = createMotionEvent(MotionEvent.ACTION_UP);
@@ -45,7 +44,7 @@ public void setUp() throws Exception {
     @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR2)
     @Test
     public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnabled()  {
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
 
         subject.enablePlugins(true);
@@ -55,7 +54,7 @@ public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnab
     @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldAllowToggling() {
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.ON);
 
         subject.enablePlugins(false);
@@ -68,7 +67,7 @@ public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldA
     @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void pluginState_beforeIcs_shouldDefaultToOff_shouldAllowToggling() {
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
 
         subject.enablePlugins(true);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
index cf7d6c34..f5eefa09 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
@@ -1,160 +1,86 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.drawable.StateListDrawable;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.RelativeLayout;
-import org.fest.assertions.api.ANDROID;
-import org.junit.Ignore;
+import android.widget.FrameLayout;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
-
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@Ignore
-public class BaseInterstitialActivityTest {
-    public static final String EXPECTED_SOURCE = "expected source";
 
-    protected BaseInterstitialActivity subject;
-    protected BroadcastReceiver broadcastReceiver;
-    protected AdConfiguration adConfiguration;
-    protected long testBroadcastIdentifier;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static org.fest.assertions.api.Assertions.assertThat;
 
-    public void setup() {
-        broadcastReceiver = mock(BroadcastReceiver.class);
-        testBroadcastIdentifier = 2222;
+@RunWith(SdkTestRunner.class)
+public class BaseInterstitialActivityTest {
+    private BaseInterstitialActivity subject;
+    private long broadcastIdentifier;
+
+    // Make a concrete version of the abstract class for testing purposes.
+    private static class TestInterstitialActivity extends BaseInterstitialActivity {
+        View view;
+
+        @Override
+        public View getAdView() {
+            if (view == null) {
+                view = new View(this);
+            }
+            return view;
+        }
     }
 
-    @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    @Before
+    public void setup() {
+        broadcastIdentifier = 2222;
     }
 
     @Test
     public void onCreate_shouldCreateView() throws Exception {
-        subject.onCreate(null);
-
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class).create().get();
         View adView = getContentView(subject).getChildAt(0);
 
         assertThat(adView).isNotNull();
     }
 
-    @Test
-    public void onCreate_shouldShowInterstitialCloseButton() throws Exception {
-        subject.onCreate(null);
-
-        ImageButton closeButton = getCloseButton();
-
-        Robolectric.clickOn(closeButton);
-
-        ANDROID.assertThat(subject).isFinishing();
-    }
-
-    @Test
-    public void onCreate_shouldMakeCloseButtonVisible() throws Exception {
-        subject.onCreate(null);
-
-        ImageButton closeButton = getCloseButton();
-
-        ANDROID.assertThat(closeButton).isVisible();
-        StateListDrawable states = (StateListDrawable) closeButton.getDrawable();
-
-        int[] unpressedState = new int[] {-android.R.attr.state_pressed};
-        assertThat(shadowOf(states).getDrawableForState(unpressedState))
-                .isEqualTo(INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(new Activity()));
-        int[] pressedState = new int[] {android.R.attr.state_pressed};
-        assertThat(shadowOf(states).getDrawableForState(pressedState))
-                .isEqualTo(INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(new Activity()));
-    }
-
-    @Test
-    public void canShowAndHideTheCloseButton() throws Exception {
-        subject.onCreate(null);
-        ANDROID.assertThat(getCloseButton()).isVisible();
-
-        subject.hideInterstitialCloseButton();
-        ANDROID.assertThat(getCloseButton()).isInvisible();
-
-        subject.showInterstitialCloseButton();
-        ANDROID.assertThat(getCloseButton()).isVisible();
-    }
-
     @Test
     public void onDestroy_shouldCleanUpContentView() throws Exception {
-        subject.onCreate(null);
-        subject.onDestroy();
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class).create().destroy().get();
 
         assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
     }
 
     @Test
-    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
-        subject.onDestroy();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void getAdConfiguration_shouldReturnAdConfigurationFromIntent() throws Exception {
-        Intent intent = new Intent();
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
-
-        subject.onCreate(null);
-        subject.setIntent(intent);
-
-        assertThat(subject.getAdConfiguration()).isNotNull();
+    public void getBroadcastIdentifier_shouldReturnBroadcastIdFromIntent() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent intent = new Intent(context, TestInterstitialActivity.class);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class)
+                .withIntent(intent)
+                .create().get();
+        assertThat(subject.getBroadcastIdentifier()).isEqualTo(2222L);
     }
 
     @Test
-    public void getAdConfiguration_withMissingOrWrongAdConfiguration_shouldReturnNull() throws Exception {
-        Intent intent = new Intent();
-        // This intent is missing an AdConfiguration extra.
-
-        subject.onCreate(null);
-        subject.setIntent(intent);
+    public void getBroadcastIdentifier_withMissingBroadCastId_shouldReturnNull() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent intent = new Intent(context, TestInterstitialActivity.class);
+        // This intent is missing a broadcastidentifier extra.
 
-        assertThat(subject.getAdConfiguration()).isNull();
-    }
-
-    protected ImageButton getCloseButton() {
-        return (ImageButton) getContentView(subject).getChildAt(1);
-    }
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class)
+                .withIntent(intent)
+                .create().get();
 
-    protected RelativeLayout getContentView(BaseInterstitialActivity subject) {
-        return (RelativeLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+        assertThat(subject.getBroadcastIdentifier()).isNull();
     }
 
-    protected void resetMockedView(View view) {
-        reset(view);
-        stub(view.getLayoutParams()).toReturn(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT));
+    protected FrameLayout getContentView(BaseInterstitialActivity subject) {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivitiyTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivitiyTest.java
deleted file mode 100644
index 5663115e..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivitiyTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Intent;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.startMraid;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.startVast;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
-
-@RunWith(SdkTestRunner.class)
-public class BaseVideoPlayerActivitiyTest {
-    private static final String MRAID_VIDEO_URL = "http://mraidVideo";
-
-    private AdConfiguration adConfiguration;
-    private long testBroadcastIdentifier;
-    private VastVideoConfiguration vastVideoConfiguration;
-
-    @Before
-    public void setup() throws Exception {
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        vastVideoConfiguration = mock(VastVideoConfiguration.class, withSettings().serializable());
-
-        testBroadcastIdentifier = 1234;
-        when(adConfiguration.getBroadcastIdentifier()).thenReturn(testBroadcastIdentifier);
-    }
-
-    @Test
-    public void startMraid_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startMraid(new Activity(), MRAID_VIDEO_URL, adConfiguration);
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL, adConfiguration);
-    }
-
-    @Test
-    public void startVast_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startVast(new Activity(), vastVideoConfiguration, adConfiguration);
-        assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, vastVideoConfiguration, adConfiguration);
-    }
-
-    static void assertVastVideoPlayerActivityStarted(final Class clazz,
-            final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
-        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertIntentAndAdConfigurationAreCorrect(intent, clazz, adConfiguration);
-
-        final VastVideoConfiguration expectedVastVideoConfiguration =
-                (VastVideoConfiguration) intent.getSerializableExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION);
-        assertThat(expectedVastVideoConfiguration).isEqualsToByComparingFields(vastVideoConfiguration);
-    }
-
-    static void assertMraidVideoPlayerActivityStarted(final Class clazz,
-            final String url,
-            final AdConfiguration adConfiguration) {
-        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertIntentAndAdConfigurationAreCorrect(intent, clazz, adConfiguration);
-
-        assertThat(intent.getStringExtra(VIDEO_URL)).isEqualTo(url);
-    }
-
-    static void assertIntentAndAdConfigurationAreCorrect(final Intent intent,
-            final Class clazz,
-            final AdConfiguration adConfiguration) {
-        assertThat(intent.getComponent().getClassName()).isEqualTo(clazz.getCanonicalName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
-
-        final AdConfiguration expectedAdConfiguration = (AdConfiguration) intent.getSerializableExtra(AD_CONFIGURATION_KEY);
-        assertThat(expectedAdConfiguration).isEqualsToByComparingFields(adConfiguration);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
new file mode 100644
index 00000000..940f9f07
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
@@ -0,0 +1,76 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Intent;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.startMraid;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.startVast;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.withSettings;
+
+@RunWith(SdkTestRunner.class)
+public class BaseVideoPlayerActivityTest {
+    private static final String MRAID_VIDEO_URL = "http://mraidVideo";
+
+    private long testBroadcastIdentifier;
+    private VastVideoConfig mVastVideoConfig;
+
+    @Before
+    public void setup() throws Exception {
+        mVastVideoConfig = mock(VastVideoConfig.class, withSettings().serializable());
+        testBroadcastIdentifier = 1234;
+    }
+
+    @Test
+    public void startMraid_shouldStartMraidVideoPlayerActivity() throws Exception {
+        startMraid(Robolectric.buildActivity(Activity.class).create().get(), MRAID_VIDEO_URL);
+        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL);
+    }
+
+    @Test
+    public void startVast_shouldStartMraidVideoPlayerActivity() throws Exception {
+        startVast(Robolectric.buildActivity(Activity.class).create().get(), mVastVideoConfig, testBroadcastIdentifier);
+        assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, mVastVideoConfig, testBroadcastIdentifier);
+    }
+
+    static void assertVastVideoPlayerActivityStarted(final Class clazz,
+            final VastVideoConfig vastVideoConfig,
+            final long broadcastIdentifier) {
+        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, broadcastIdentifier);
+
+        final VastVideoConfig expectedVastVideoConfig =
+                (VastVideoConfig) intent.getSerializableExtra(VastVideoViewController.VAST_VIDEO_CONFIG);
+        assertThat(expectedVastVideoConfig).isEqualsToByComparingFields(vastVideoConfig);
+    }
+
+    public static void assertMraidVideoPlayerActivityStarted(final Class clazz, final String url) {
+        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, null);
+
+        assertThat(intent.getStringExtra(VIDEO_URL)).isEqualTo(url);
+    }
+
+    static void assertIntentAndBroadcastIdentifierAreCorrect(final Intent intent,
+            final Class clazz,
+            final Long expectedBroadcastId) {
+        assertThat(intent.getComponent().getClassName()).isEqualTo(clazz.getCanonicalName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
+
+        if (expectedBroadcastId != null) {
+            final long actualBroadcastId = (Long) intent.getSerializableExtra(BROADCAST_IDENTIFIER_KEY);
+            assertThat(actualBroadcastId).isEqualTo(expectedBroadcastId);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
index a6c36a4d..d9415f2d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
@@ -2,7 +2,6 @@
 
 
 import android.app.Activity;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.view.ViewGroup;
 import android.webkit.WebSettings;
@@ -16,8 +15,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
-import static com.mopub.common.util.VersionCode.JELLY_BEAN_MR1;
-import static com.mopub.common.util.VersionCode.JELLY_BEAN_MR2;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
@@ -31,7 +28,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
     }
 
     @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR1)
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
similarity index 52%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoadTaskTest.java
rename to mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
index 944e8378..c3dbf03d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
@@ -16,11 +16,12 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
-public class CustomEventAdLoadTaskTest {
+public class CustomEventAdLoaderTest {
 
     private AdViewController adViewController;
-    private AdLoadTask.CustomEventAdLoadTask subject;
-    private Map<String, String> paramsMap;
+    private AdLoader.CustomEventAdLoader subject;
+    private String customEventName;
+    private Map<String, String> serverExtras;
     private MoPubView moPubView;
 
     @Before
@@ -28,23 +29,25 @@ public void setup() {
         moPubView = mock(MoPubView.class);
         adViewController = mock(AdViewController.class);
         stub(adViewController.getMoPubView()).toReturn(moPubView);
-        paramsMap = new HashMap<String, String>();
-        subject = new AdLoadTask.CustomEventAdLoadTask(adViewController, paramsMap);
+        customEventName = "testCustomEvent";
+        serverExtras = new HashMap<String, String>();
+        subject = new AdLoader.CustomEventAdLoader(adViewController,
+                customEventName, serverExtras);
     }
 
     @Test
     public void execute_shouldCallLoadCustomEvent() throws Exception {
-        subject.execute();
+        subject.load();
 
         verify(adViewController).setNotLoading();
-        verify(moPubView).loadCustomEvent(eq(paramsMap));
+        verify(moPubView).loadCustomEvent(eq(customEventName), eq(serverExtras));
     }
 
     @Test
     public void execute_whenAdViewControllerIsNull_shouldDoNothing() throws Exception {
-        subject = new AdLoadTask.CustomEventAdLoadTask(null, paramsMap);
+        subject = new AdLoader.CustomEventAdLoader(null, customEventName, serverExtras);
 
-        subject.execute();
+        subject.load();
         // pass
     }
 
@@ -52,28 +55,29 @@ public void execute_whenAdViewControllerIsNull_shouldDoNothing() throws Exceptio
     public void execute_whenAdViewControllerIsDestroyed_shouldDoNothing() throws Exception {
         stub(adViewController.isDestroyed()).toReturn(true);
 
-        subject.execute();
+        subject.load();
 
         verify(adViewController, never()).setNotLoading();
-        verify(moPubView, never()).loadCustomEvent(eq(paramsMap));
+        verify(moPubView, never()).loadCustomEvent(eq(customEventName), eq(serverExtras));
     }
 
     @Test
-    public void execute_whenParamsMapIsNull_shouldLoadNullParamsMap() throws Exception {
-        subject = new AdLoadTask.CustomEventAdLoadTask(adViewController, null);
+    public void execute_whenCustomEventIsNull_shouldDoNothing() {
+        subject = new AdLoader.CustomEventAdLoader(adViewController, null, serverExtras);
 
-        subject.execute();
+        subject.load();
 
-        verify(adViewController).setNotLoading();
-        verify(moPubView).loadCustomEvent((Map<String, String>) eq(null));
+        verify(adViewController, never()).setNotLoading();
+        verify(moPubView, never()).loadCustomEvent((String) eq(null), eq(serverExtras));
     }
 
     @Test
-    public void execute_afterCleanup_shouldLoadNullParamsMap() throws Exception {
-        subject.cleanup();
-        subject.execute();
+    public void execute_whenParamsMapIsNull_shouldLoadNullParamsMap() throws Exception {
+        subject = new AdLoader.CustomEventAdLoader(adViewController, customEventName, null);
+
+        subject.load();
 
         verify(adViewController).setNotLoading();
-        verify(moPubView).loadCustomEvent((Map<String, String>) eq(null));
+        verify(moPubView).loadCustomEvent(eq(customEventName), (Map<String, String>) eq(null));
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
index d99e6508..ed91f90b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
@@ -5,12 +5,15 @@
 import android.location.Location;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -18,7 +21,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
@@ -30,33 +32,56 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class CustomEventBannerAdapterTest {
     private CustomEventBannerAdapter subject;
+    @Mock
     private MoPubView moPubView;
+    @Mock
+    private AdReport mockAdReport;
     private static final String CLASS_NAME = "arbitrary_banner_adapter_class_name";
-    private static final String JSON_PARAMS = "{\"key\":\"value\",\"a different key\":\"a different value\"}";
+    private static final long BROADCAST_IDENTIFIER = 123;
+    private Map<String, String> serverExtras;
     private CustomEventBanner banner;
+    private Map<String,Object> localExtras;
     private Map<String,Object> expectedLocalExtras;
     private HashMap<String,String> expectedServerExtras;
 
     @Before
     public void setUp() throws Exception {
-        moPubView = mock(MoPubView.class);
-        stub(moPubView.getAdTimeoutDelay()).toReturn(null);
 
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, JSON_PARAMS);
+        when(moPubView.getAdTimeoutDelay()).thenReturn(null);
+        when(moPubView.getAdWidth()).thenReturn(320);
+        when(moPubView.getAdHeight()).thenReturn(50);
+
+        localExtras = new HashMap<String, Object>();
+        when(moPubView.getLocalExtras()).thenReturn(localExtras);
+
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("key", "value");
+        serverExtras.put("another_key", "another_value");
+        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, serverExtras, BROADCAST_IDENTIFIER, mockAdReport);
 
         expectedLocalExtras = new HashMap<String, Object>();
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFIER);
+        expectedLocalExtras.put(DataKeys.AD_WIDTH, 320);
+        expectedLocalExtras.put(DataKeys.AD_HEIGHT, 50);
+
         expectedServerExtras = new HashMap<String, String>();
 
         banner = CustomEventBannerFactory.create(CLASS_NAME);
     }
 
+    @Test
+    public void constructor_shouldPopulateLocalExtrasWithAdWidthAndHeight() throws Exception {
+        assertThat(localExtras.get("com_mopub_ad_width")).isEqualTo(320);
+        assertThat(localExtras.get("com_mopub_ad_height")).isEqualTo(50);
+    }
+
     @Test
     public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
         subject.loadAd();
@@ -72,7 +97,7 @@ public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Ex
 
     @Test
     public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
-        stub(moPubView.getAdTimeoutDelay()).toReturn(-1);
+        when(moPubView.getAdTimeoutDelay()).thenReturn(-1);
 
         subject.loadAd();
 
@@ -87,7 +112,7 @@ public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateW
 
     @Test
     public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWithCustomDelay() throws Exception {
-        stub(moPubView.getAdTimeoutDelay()).toReturn(77);
+       when(moPubView.getAdTimeoutDelay()).thenReturn(77);
 
         subject.loadAd();
 
@@ -100,18 +125,6 @@ public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWi
         assertThat(subject.isInvalidated()).isTrue();
     }
 
-    @Test
-    public void loadAd_shouldHaveEmptyServerExtrasOnInvalidJsonParams() throws Exception {
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, "{this is terrible JSON");
-        subject.loadAd();
-
-        verify(banner).loadBanner(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
 
     @Test
     public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
@@ -119,8 +132,8 @@ public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
         expectedLocation.setLongitude(10.0);
         expectedLocation.setLongitude(20.1);
 
-        stub(moPubView.getLocation()).toReturn(expectedLocation);
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, null);
+        when(moPubView.getLocation()).thenReturn(expectedLocation);
+        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, new HashMap<String, String>(), BROADCAST_IDENTIFIER, mockAdReport);
         subject.loadAd();
 
         expectedLocalExtras.put("location", moPubView.getLocation());
@@ -134,11 +147,11 @@ public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
     }
 
     @Test
-    public void loadAd_shouldPropagateJsonParamsInServerExtras() throws Exception {
+    public void loadAd_shouldPropagateServerExtrasToLoadBanner() throws Exception {
         subject.loadAd();
 
         expectedServerExtras.put("key", "value");
-        expectedServerExtras.put("a different key", "a different value");
+        expectedServerExtras.put("another_key", "another_value");
 
         verify(banner).loadBanner(
                 any(Context.class),
@@ -212,7 +225,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                 .when(banner)
                 .loadBanner(
                         any(Context.class),
-                        any(CustomEventBanner.CustomEventBannerListener.class),
+                        any(CustomEventBannerListener.class),
                         any(Map.class),
                         any(Map.class)
                 );
@@ -224,9 +237,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     @Test
     public void onBannerLoaded_shouldSignalMoPubView() throws Exception {
-        View view = new View(new Activity());
+        View view = new View(Robolectric.buildActivity(Activity.class).create().get());
         subject.onBannerLoaded(view);
-        
+
         verify(moPubView).nativeAdLoaded();
         verify(moPubView).setAdContentView(eq(view));
         verify(moPubView).trackNativeImpression();
@@ -266,14 +279,14 @@ public void onBannerExpanded_shouldPauseRefreshAndCallAdPresentOverlay() throws
 
     @Test
     public void onBannerCollapsed_shouldRestoreRefreshSettingAndCallAdClosed() throws Exception {
-        stub(moPubView.getAutorefreshEnabled()).toReturn(true);
+        when(moPubView.getAutorefreshEnabled()).thenReturn(true);
         subject.onBannerExpanded();
         reset(moPubView);
         subject.onBannerCollapsed();
         verify(moPubView).setAutorefreshEnabled(eq(true));
         verify(moPubView).adClosed();
 
-        stub(moPubView.getAutorefreshEnabled()).toReturn(false);
+        when(moPubView.getAutorefreshEnabled()).thenReturn(false);
         subject.onBannerExpanded();
         reset(moPubView);
         subject.onBannerCollapsed();
@@ -328,19 +341,4 @@ public void invalidate_shouldCauseBannerListenerMethodsToDoNothing() throws Exce
         verify(moPubView, never()).adClosed();
         verify(moPubView, never()).registerClick();
     }
-
-    @Test
-    public void init_whenPassedHtmlData_shouldPutItInLocalExtras() throws Exception {
-        String expectedHtmlData = "expected html data";
-        expectedServerExtras.put(HTML_RESPONSE_BODY_KEY, expectedHtmlData);
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, "{\"Html-Response-Body\":\"expected html data\"}");
-        subject.loadAd();
-
-        verify(banner).loadBanner(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
index cdf1ad36..3649c405 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
@@ -3,17 +3,22 @@
 import android.content.Context;
 import android.location.Location;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
@@ -29,30 +34,37 @@
 import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
 
-
 @RunWith(SdkTestRunner.class)
 public class CustomEventInterstitialAdapterTest {
+    private static long BROADCAST_IDENTIFER = 123;
     private CustomEventInterstitialAdapter subject;
-    private MoPubInterstitial moPubInterstitial;
+    @Mock
+    private MoPubInterstitial mockMoPubInterstitial;
     private CustomEventInterstitial interstitial;
     private Map<String, Object> expectedLocalExtras;
     private HashMap<String, String> expectedServerExtras;
-    private AdViewController adViewController;
+    @Mock
+    private AdViewController mockAdViewController;
+    @Mock
+    private AdReport mockAdReport;
     private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
     private static final String CLASS_NAME = "arbitrary_interstitial_adapter_class_name";
-    private static final String JSON_PARAMS = "{\"key\":\"value\",\"a different key\":\"a different value\"}";
+    private Map<String, String> serverExtras;
     private CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener interstitialAdapterListener;
 
     @Before
     public void setUp() throws Exception {
-        moPubInterstitial = mock(MoPubInterstitial.class);
-        stub(moPubInterstitial.getAdTimeoutDelay()).toReturn(null);
+
+        stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(null);
         moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
-        adViewController = mock(AdViewController.class);
-        stub(moPubInterstitialView.getAdViewController()).toReturn(adViewController);
-        stub(moPubInterstitial.getMoPubInterstitialView()).toReturn(moPubInterstitialView);
+        stub(moPubInterstitialView.getAdViewController()).toReturn(mockAdViewController);
+        stub(mockAdViewController.getAdReport()).toReturn(mockAdReport);
+        stub(mockMoPubInterstitial.getMoPubInterstitialView()).toReturn(moPubInterstitialView);
 
-        subject = new CustomEventInterstitialAdapter(moPubInterstitial, CLASS_NAME, JSON_PARAMS);
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("key", "value");
+
+        subject = new CustomEventInterstitialAdapter(mockMoPubInterstitial, CLASS_NAME, serverExtras, BROADCAST_IDENTIFER, mockAdViewController.getAdReport());
 
         expectedLocalExtras = new HashMap<String, Object>();
         expectedServerExtras = new HashMap<String, String>();
@@ -68,8 +80,8 @@ public void constructor_withInvalidClassName_shouldCallOnCustomEventInterstitial
         // Remove testing mock and use the real thing
         CustomEventInterstitialFactory.setInstance(new CustomEventInterstitialFactory());
 
-        new CustomEventInterstitialAdapter(moPubInterstitial, "bad_class_name_11i234jb", null);
-        verify(moPubInterstitial).onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
+        new CustomEventInterstitialAdapter(mockMoPubInterstitial, "bad_class_name_11i234jb", new TreeMap<String, String>(), BROADCAST_IDENTIFER, mockAdViewController.getAdReport());
+        verify(mockMoPubInterstitial).onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
     }
 
     @Test
@@ -86,7 +98,7 @@ public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Ex
 
     @Test
     public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
-        stub(moPubInterstitial.getAdTimeoutDelay()).toReturn(-1);
+        stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(-1);
 
         subject.loadInterstitial();
         Robolectric.idleMainLooper(CustomEventInterstitialAdapter.DEFAULT_INTERSTITIAL_TIMEOUT_DELAY - 1);
@@ -100,7 +112,7 @@ public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateW
 
     @Test
     public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWithCustomDelay() throws Exception {
-        stub(moPubInterstitial.getAdTimeoutDelay()).toReturn(77);
+        stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(77);
 
         subject.loadInterstitial();
         Robolectric.idleMainLooper(77000 - 1);
@@ -112,31 +124,18 @@ public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWi
         assertThat(subject.isInvalidated()).isTrue();
     }
 
-    @Test
-    public void loadInterstitial_shouldHaveEmptyServerExtrasOnInvalidJsonParams() throws Exception {
-        subject = new CustomEventInterstitialAdapter(moPubInterstitial, CLASS_NAME, "{this is terrible JSON");
-        subject.loadInterstitial();
-        expectedLocalExtras.put("Ad-Configuration", null);
-
-        verify(interstitial).loadInterstitial(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
-
     @Test
     public void loadInterstitial_shouldPropagateLocationInLocalExtras() throws Exception {
         Location expectedLocation = new Location("");
         expectedLocation.setLongitude(10.0);
         expectedLocation.setLongitude(20.1);
-        stub(moPubInterstitial.getLocation()).toReturn(expectedLocation);
-        subject = new CustomEventInterstitialAdapter(moPubInterstitial, CLASS_NAME, null);
+        stub(mockMoPubInterstitial.getLocation()).toReturn(expectedLocation);
+        subject = new CustomEventInterstitialAdapter(mockMoPubInterstitial, CLASS_NAME, new HashMap<String, String>(), BROADCAST_IDENTIFER, mockAdViewController.getAdReport());
         subject.loadInterstitial();
 
-        expectedLocalExtras.put("Ad-Configuration", null);
-        expectedLocalExtras.put("location", moPubInterstitial.getLocation());
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFER);
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
+        expectedLocalExtras.put("location", mockMoPubInterstitial.getLocation());
 
         verify(interstitial).loadInterstitial(
                 any(Context.class),
@@ -147,11 +146,11 @@ public void loadInterstitial_shouldPropagateLocationInLocalExtras() throws Excep
     }
 
     @Test
-    public void loadInterstitial_shouldPropagateJsonParamsInServerExtras() throws Exception {
+    public void loadInterstitial_shouldPropagateServerExtrasToInterstitial() throws Exception {
         subject.loadInterstitial();
-        expectedLocalExtras.put("Ad-Configuration", null);
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFER);
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
         expectedServerExtras.put("key", "value");
-        expectedServerExtras.put("a different key", "a different value");
 
         verify(interstitial).loadInterstitial(
                 any(Context.class),
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
index d0dfea10..e028844b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
@@ -5,6 +5,7 @@
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
 
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
@@ -15,9 +16,11 @@
 import org.junit.runner.RunWith;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
@@ -48,7 +51,7 @@ public void setUp() throws Exception {
         context = new Activity();
     }
 
-    @Ignore("pending")
+    @Ignore("Difficult with the number of test factories and mocking involved.")
     @Test
     public void twoDifferentInterstitials_shouldNotHearEachOthersBroadcasts() throws Exception {
         final MoPubInterstitial interstitialA = new MoPubInterstitial(context, "adunitid");
@@ -59,11 +62,14 @@ public void twoDifferentInterstitials_shouldNotHearEachOthersBroadcasts() throws
         final InterstitialAdListener listenerB = mock(InterstitialAdListener.class);
         interstitialB.setInterstitialAdListener(listenerB);
 
+        Map<String, String> serverExtras = new HashMap<String, String>();
+        serverExtras.put(DataKeys.HTML_RESPONSE_BODY_KEY, "response");
         final CustomEventInterstitialAdapter customEventInterstitialAdapter =
                 CustomEventInterstitialAdapterFactory.create(
                         interstitialA,
                         "com.mopub.mobileads.HtmlInterstitial",
-                        "{" + HTML_RESPONSE_BODY_KEY + ":response}");
+                        serverExtras, broadcastIdentifier, null);
+
 
         customEventInterstitialAdapter.loadInterstitial();
         verify(listenerA).onInterstitialLoaded(interstitialA);
@@ -205,7 +211,7 @@ public void unregister_shouldNotLeakTheContext() throws Exception {
         verify(customEventInterstitialListener).onInterstitialShown();
     }
 
-    static Intent getIntentForActionAndIdentifier(final String action, final long broadcastIdentifier) {
+    public static Intent getIntentForActionAndIdentifier(final String action, final long broadcastIdentifier) {
         final Intent intent = new Intent(action);
         intent.putExtra("broadcastIdentifier", broadcastIdentifier);
         return intent;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
index d541d73d..4b7f81c9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
@@ -1,16 +1,14 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.net.Uri;
 import android.view.Gravity;
 import android.widget.FrameLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlBannerWebViewFactory;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.TestMoPubViewFactory;
+import com.mopub.network.AdResponse;
 
-import org.apache.http.HttpResponse;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,10 +17,10 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyString;
@@ -52,7 +50,7 @@ public void setup() {
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
         responseBody = "expected response body";
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, Uri.encode(responseBody));
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, responseBody);
         serverExtras.put(SCROLLABLE_KEY, "false");
     }
 
@@ -109,10 +107,9 @@ public void loadBanner_shouldCauseServerDimensionsToBeHonoredWhenLayingOutView()
         stub(moPubView.getContext()).toReturn(context);
         AdViewController adViewController = new AdViewController(context, moPubView);
 
-        HttpResponse response = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
-        adViewController.configureUsingHttpResponse(response);
+
+        AdResponse adResponse = new AdResponse.Builder().setDimensions(320, 50).build();
+        adViewController.onAdLoadSuccess(adResponse);
 
         adViewController.setAdContentView(htmlBannerWebView);
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
index aaf8a188..aea2d409 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
@@ -3,11 +3,14 @@
 import android.app.Activity;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
@@ -19,17 +22,17 @@
 
 @RunWith(SdkTestRunner.class)
 public class HtmlBannerWebViewTest {
-
-    private AdConfiguration adConfiguration;
     private HtmlBannerWebView subject;
+    @Mock
+    private AdReport mockAdReport;
     private CustomEventBannerListener customEventBannerListener;
     private String clickthroughUrl;
     private String redirectUrl;
 
     @Before
     public void setup() throws Exception {
-        adConfiguration = mock(AdConfiguration.class);
-        subject = new HtmlBannerWebView(new Activity(), adConfiguration);
+        subject = new HtmlBannerWebView(Robolectric.buildActivity(Activity.class).create().get(),
+                mockAdReport);
         customEventBannerListener = mock(CustomEventBannerListener.class);
         clickthroughUrl = "clickthroughUrl";
         redirectUrl = "redirectUrl";
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
index 6d606330..19d7184e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
@@ -2,12 +2,12 @@
 
 import android.app.Activity;
 import android.content.Intent;
-import android.net.Uri;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -16,23 +16,21 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlInterstitialTest extends ResponseBodyInterstitialTest {
@@ -54,14 +52,13 @@ public void setUp() throws Exception {
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, Uri.encode(expectedResponse));
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, expectedResponse);
 
         broadcastIdentifier = 2222;
-        final AdConfiguration adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(broadcastIdentifier);
-        localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
+        localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
     }
 
+    @Ignore("pending")
     @Test
     public void loadInterstitial_shouldNotifyCustomEventInterstitialListenerOnLoaded() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
@@ -119,12 +116,12 @@ public void showInterstitial_shouldStartMoPubActivityWithAllExtras() throws Exce
     public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
 
-        Intent intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, subject.mAdConfiguration.getBroadcastIdentifier());
+        Intent intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, broadcastIdentifier);
         ShadowLocalBroadcastManager.getInstance(context).sendBroadcast(intent);
 
         verify(customEventInterstitialListener).onInterstitialShown();
 
-        intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, subject.mAdConfiguration.getBroadcastIdentifier());
+        intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, broadcastIdentifier);
         ShadowLocalBroadcastManager.getInstance(context).sendBroadcast(intent);
 
         verify(customEventInterstitialListener).onInterstitialDismissed();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
index ebd3b8f8..4d1763d8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
@@ -1,48 +1,40 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-
-import java.lang.reflect.Method;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.HtmlInterstitialWebView.HtmlInterstitialWebViewListener;
-import static com.mopub.mobileads.HtmlInterstitialWebView.MOPUB_JS_INTERFACE_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.common.util.VersionCode.GINGERBREAD_MR1;
-import static com.mopub.common.util.VersionCode.HONEYCOMB;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlInterstitialWebViewTest {
 
+    @Mock AdReport mockAdReport;
     private HtmlInterstitialWebView subject;
     private CustomEventInterstitialListener customEventInterstitialListener;
     private String clickthroughUrl;
     private boolean isScrollable;
     private String redirectUrl;
-    private AdConfiguration adConfiguration;
 
     @Before
     public void setUp() throws Exception {
-        adConfiguration = mock(AdConfiguration.class);
-        subject = new HtmlInterstitialWebView(new Activity(), adConfiguration);
+        subject = new HtmlInterstitialWebView(Robolectric.buildActivity(Activity.class).create().get(),
+                mockAdReport);
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         isScrollable = false;
         clickthroughUrl = "clickthroughUrl";
@@ -69,56 +61,4 @@ public void htmlBannerWebViewListener_shouldForwardCalls() throws Exception {
         listenerSubject.onClicked();
         verify(customEventInterstitialListener).onInterstitialClicked();
     }
-
-    @Test
-    public void init_shouldAddJavascriptInterface() throws Exception {
-        subject.init(customEventInterstitialListener, isScrollable, clickthroughUrl, redirectUrl);
-
-        Object javascriptInterface = shadowOf(subject).getJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        assertThat(javascriptInterface).isNotNull();
-
-        Method fireFinishLoad = javascriptInterface.getClass().getDeclaredMethod("fireFinishLoad");
-        Robolectric.pauseMainLooper();
-        boolean returnValue = (Boolean) fireFinishLoad.invoke(javascriptInterface);
-        assertThat(returnValue).isTrue();
-        verify(customEventInterstitialListener, never()).onInterstitialShown();
-
-        Robolectric.unPauseMainLooper();
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-    }
-
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB)
-    @Test
-    public void destroy_atLeastHoneycomb_shouldRemoveJavascriptInterface() {
-        HtmlInterstitialWebView spySubject = spy(subject);
-
-        spySubject.destroy();
-
-        verify(spySubject).removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
-    @Test
-    public void destroy_beforeHoneycomb_shouldNotRemoveJavascriptInterface() {
-        HtmlInterstitialWebView spySubject = spy(subject);
-
-        spySubject.destroy();
-
-        verify(spySubject, never()).removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @Test
-    public void destroy_shouldPreventJavascriptInterfaceFromNotifyingListener() throws Exception{
-        subject.init(customEventInterstitialListener, isScrollable, clickthroughUrl, redirectUrl);
-
-        Object javascriptInterface = shadowOf(subject).getJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        assertThat(javascriptInterface).isNotNull();
-
-        subject.setIsDestroyed(true);
-
-        Method fireFinishLoad = javascriptInterface.getClass().getDeclaredMethod("fireFinishLoad");
-        fireFinishLoad.invoke(javascriptInterface);
-
-        verify(customEventInterstitialListener, never()).onInterstitialLoaded();
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index 7f395a4c..d2db93fd 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -7,6 +7,7 @@
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
 import android.webkit.WebView;
+
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
 
@@ -25,22 +26,27 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlWebViewClientTest {
 
+    private static final String CLICKTHROUGH_URL = "http://clickthrough";
+
     private HtmlWebViewClient subject;
     private HtmlWebViewListener htmlWebViewListener;
     private BaseHtmlWebView htmlWebView;
+    private Context context;
 
     @Before
     public void setUp() throws Exception {
         htmlWebViewListener = mock(HtmlWebViewListener.class);
         htmlWebView = mock(BaseHtmlWebView.class);
-        stub(htmlWebView.getContext()).toReturn(new Activity());
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, "clickthrough", "redirect");
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+        when(htmlWebView.getContext()).thenReturn(context);
+        when(htmlWebView.wasClicked()).thenReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
     }
 
     @Test
@@ -67,60 +73,6 @@ public void shouldOverrideUrlLoading_withMoPubFailLoad_shouldCallLoadFailUrl() t
         verify(htmlWebViewListener).onFailed(UNSPECIFIED);
     }
 
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustom_withUserClick_shouldStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc&data=myData");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getAction()).isEqualTo("myFnc");
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedActivity.getStringExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA)).isEqualTo("myData");
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustom_withoutUserClick_shouldNotStartActivity() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc&data=myData");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustomAndNullData_withUserClick_shouldStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getAction()).isEqualTo("myFnc");
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedActivity.getStringExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA)).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustomAndNullData_withoutUserClick_shouldNotStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
     @Test
     public void shouldOverrideUrlLoading_withPhoneIntent_shouldStartDefaultIntent() throws Exception {
         assertPhoneUrlStartedCorrectIntent("tel:");
@@ -142,7 +94,8 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_a
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
-        assertActivityStarted();
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent).isNotNull();
     }
 
     @Test
@@ -155,11 +108,12 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClic
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldDefaultToMoPubBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldFailSilently() throws Exception {
         String customUrl = "myintent://something";
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
@@ -167,10 +121,10 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_b
         boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
 
         assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedIntent).isNull();
     }
 
     @Test
@@ -183,7 +137,7 @@ public void shouldOverrideUrlLoading_withHttpUrl_withUserClick_shouldOpenBrowser
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
 
-        Intent startedActivity = assertActivityStarted();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
         assertThat(startedActivity.getData()).isNull();
@@ -198,7 +152,7 @@ public void shouldOverrideUrlLoading_withHttpUrl_withoutUserClick_shouldNotOpenB
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
-
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
@@ -209,7 +163,7 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withUserClick_sho
 
         subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
 
-        Intent startedActivity = assertActivityStarted();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
     }
 
@@ -224,16 +178,14 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withoutUserClick_
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldLoadAboutBlank() throws Exception {
+    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldFailSilently() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
         subject.shouldOverrideUrlLoading(htmlWebView, "");
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("about:blank");
-        assertThat(startedActivity.getData()).isNull();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
     }
 
     @Test
@@ -251,12 +203,15 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withUserClick_shoul
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "mopubnativebrowser://navigate?url=http://mopub.com");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(isWebsiteUrl(startedActivity.getData().toString()));
-        assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
+        assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
+        verify(htmlWebView).onResetUserClick();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
+        assertThat(startedActivity.getData().toString()).isEqualTo("http://www.mopub.com");
     }
 
     @Test
@@ -264,48 +219,58 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_sh
         stub(htmlWebView.wasClicked()).toReturn(false);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "mopubnativebrowser://navigate?url=http://mopub.com");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
 
+        assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
     public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUserClick_shouldNotBeHandledByNativeBrowser() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
-        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http://mopub.com";
+        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(opaqueNativeBrowserUriString);
-        assertThat(startedActivity.getData()).isNull();
-        verify(htmlWebViewListener).onClicked();
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
     }
 
     @Test
     public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withoutUserClick_shouldNotLoad() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(false);
-        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http://mopub.com";
+        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
 
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldNotInvokeNativeBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldFailSilently() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getAction()).isNotEqualTo("android.intent.action.VIEW");
-        verify(htmlWebViewListener).onClicked();
+        assertThat(shouldOverrideUrl).isTrue();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
     }
 
     @Test
@@ -313,13 +278,68 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSche
         stub(htmlWebView.wasClicked()).toReturn(false);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
 
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
-    private boolean isWebsiteUrl(String url){
-        return url.startsWith("http://") || url.startsWith("https://");
+    @Test
+    public void shouldOverrideUrlLoading_withAboutBlankUrl_shouldFailSilently() {
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, "about:blank");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFinishLoad_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://finishLoad");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubClose_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://close");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFailLoad_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://fail");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withAboutScheme_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("about:blank");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withPhoneScheme_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("tel:");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMarketUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("http://play.google.com/");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopubnativebrowser://");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withInAppBrowserUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("http://twitter.com");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeepLinkUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("myapp://view");
     }
 
     @Test
@@ -368,7 +388,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
 
     @Test
     public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withoutUserClick_shouldNotOpenInBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
+        when(htmlWebView.wasClicked()).thenReturn(false);
         String url = "redirectUrlToLoad";
         WebView view = mock(WebView.class);
         subject.onPageStarted(view, url, null);
@@ -379,7 +399,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
     }
 
     @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldOpenInNativeBrowser() throws Exception {
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldFailSilently() throws Exception {
         Context mockContext = mock(Context.class);
         stub(htmlWebView.wasClicked()).toReturn(true);
         stub(htmlWebView.getContext()).toReturn(mockContext);
@@ -390,17 +410,16 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
                 .doNothing()
                 .when(mockContext).startActivity(any(Intent.class));
 
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, "clickthrough", "redirect");
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
         subject.onPageStarted(htmlWebView, url, null);
 
         ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(mockContext, times(2)).startActivity(intentArgumentCaptor.capture());
+        verify(mockContext).startActivity(intentArgumentCaptor.capture());
 
-        Intent intent = intentArgumentCaptor.getAllValues().get(1);
-        assertThat(intent.getAction()).isEqualTo("android.intent.action.VIEW");
-        assertThat(intent.getData().toString()).isEqualTo("about:blank");
-        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        verify(htmlWebViewListener, times(1)).onClicked();
+        Intent intent = intentArgumentCaptor.getValue();
+        assertThat(intent.getData()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
     }
 
     @Test
@@ -413,82 +432,38 @@ public void onPageStarted_whenLoadedUrlDoesntStartWithRedirect_shouldDoNothing()
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
-    @Test
-    public void launchIntentForUserClick_shouldStartActivityAndResetClickStatusAndReturnTrue() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(context).startActivity(eq(intent));
-        verify(htmlWebView).onResetUserClick();
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenUserHasNotClicked_shouldNotStartActivityAndReturnFalse() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(context, never()).startActivity(any(Intent.class));
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenNoMatchingActivity_shouldNotStartActivityAndReturnFalse() throws Exception {
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        doThrow(new ActivityNotFoundException()).when(context).startActivity(any(Intent.class));
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenContextIsNull_shouldNotStartActivityAndReturnFalse() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        Intent intent = new Intent();
-
-        boolean result = subject.launchIntentForUserClick(null, intent, null);
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
     private void assertPhoneUrlStartedCorrectIntent(String url) {
         boolean didOverrideUrl;
 
         stub(htmlWebView.wasClicked()).toReturn(true);
         didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
-        Intent startedActivity = assertActivityStarted();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData().toString()).isEqualTo(url);
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
+        verify(htmlWebView).onResetUserClick();
         reset(htmlWebViewListener);
+        reset(htmlWebView);
 
         stub(htmlWebView.wasClicked()).toReturn(false);
         didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         reset(htmlWebViewListener);
+        reset(htmlWebView);
     }
 
-    private Intent assertActivityStarted() {
+    private void assertNothingHappensWithoutClick(final String url) {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, url);
+
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        return startedActivity;
+        assertThat(startedActivity).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index 0903b56d..4dd42595 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -4,28 +4,38 @@
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.view.View;
+import android.view.ViewGroup;
 import android.webkit.WebViewClient;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.util.ActivityController;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.HtmlInterstitialWebView.MoPubUriJavascriptFireFinishLoadListener;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -33,54 +43,65 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-public class MoPubActivityTest extends BaseInterstitialActivityTest {
-    public static final String EXPECTED_HTML_DATA = "htmlData";
-    public static final boolean EXPECTED_IS_SCROLLABLE = true;
-    public static final String EXPECTED_REDIRECT_URL = "redirectUrl";
-    public static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
+public class MoPubActivityTest {
+    private static final String EXPECTED_HTML_DATA = "htmlData";
+    private static final boolean EXPECTED_IS_SCROLLABLE = true;
+    @Mock private AdReport mockAdReport;
+    private static final String EXPECTED_REDIRECT_URL = "redirectUrl";
+    private static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
+    private static final CreativeOrientation EXPECTED_ORIENTATION = CreativeOrientation.PORTRAIT;
+
+    @Mock private BroadcastReceiver broadcastReceiver;
+    private long testBroadcastIdentifier = 2222;
 
     private HtmlInterstitialWebView htmlInterstitialWebView;
-    private Activity context;
     private CustomEventInterstitialListener customEventInterstitialListener;
 
+    private MoPubActivity subject;
+
     @Before
     public void setUp() throws Exception {
-        super.setup();
-
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-
-        Intent moPubActivityIntent = createMoPubActivityIntent(EXPECTED_HTML_DATA, EXPECTED_IS_SCROLLABLE, EXPECTED_REDIRECT_URL, EXPECTED_CLICKTHROUGH_URL, adConfiguration);
         htmlInterstitialWebView = TestHtmlInterstitialWebViewFactory.getSingletonMock();
         resetMockedView(htmlInterstitialWebView);
-        subject = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent).create().get();
 
-        context = new Activity();
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent moPubActivityIntent = MoPubActivity.createIntent(context,
+                EXPECTED_HTML_DATA, mockAdReport, EXPECTED_IS_SCROLLABLE,
+                EXPECTED_REDIRECT_URL,
+                EXPECTED_CLICKTHROUGH_URL, EXPECTED_ORIENTATION, testBroadcastIdentifier);
+
+        final ActivityController<MoPubActivity> subjectController = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent);
+        subject = subjectController.get();
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        subjectController.create();
+
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
+    }
 
-        reset(htmlInterstitialWebView);
-        resetMockedView(htmlInterstitialWebView);
+    @Test
+    public void onCreate_shouldHaveLockedOrientation() {
+        // Since robolectric doesn't set a requested orientation, verifying that we have a value tells us that one was set.
+        assertThat(subject.getRequestedOrientation()).isIn(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
+                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
     }
 
     @Test
     public void preRenderHtml_shouldPreloadTheHtml() throws Exception {
         String htmlData = "this is nonsense";
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, htmlData);
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, htmlData);
 
         verify(htmlInterstitialWebView).enablePlugins(eq(false));
-        verify(htmlInterstitialWebView).addMoPubUriJavascriptInterface(any(MoPubUriJavascriptFireFinishLoadListener.class));
         verify(htmlInterstitialWebView).loadHtmlResponse(htmlData);
     }
 
     @Test
     public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFinishLoad() throws Exception {
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, null);
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
 
         ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
         verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
@@ -94,7 +115,7 @@ public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFinishLoad() throw
 
     @Test
     public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws Exception {
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, null);
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
 
         ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
         verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
@@ -106,40 +127,29 @@ public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws
         verify(customEventInterstitialListener).onInterstitialFailed(any(MoPubErrorCode.class));
     }
 
-    @Test
-    public void preRenderHtml_shouldHaveAMoPubUriInterfaceThatForwardsOnInterstitialLoaded() throws Exception {
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, null);
-
-        ArgumentCaptor<MoPubUriJavascriptFireFinishLoadListener> moPubUriJavascriptFireFinishLoadListenerCaptor = ArgumentCaptor.forClass(MoPubUriJavascriptFireFinishLoadListener.class);
-        verify(htmlInterstitialWebView).addMoPubUriJavascriptInterface(moPubUriJavascriptFireFinishLoadListenerCaptor.capture());
-        MoPubUriJavascriptFireFinishLoadListener moPubUriJavascriptFireFinishLoadListener = moPubUriJavascriptFireFinishLoadListenerCaptor.getValue();
-
-        moPubUriJavascriptFireFinishLoadListener.onInterstitialLoaded();
-
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-    }
-
     @Test
     public void onCreate_shouldSetContentView() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called above in #setup
 
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(2);
+        assertThat(getContentView().getChildCount()).isEqualTo(1);
     }
 
     @Test
     public void onCreate_shouldLayoutWebView() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called in #setup
 
-        ArgumentCaptor<RelativeLayout.LayoutParams> captor = ArgumentCaptor.forClass(RelativeLayout.LayoutParams.class);
+        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
         verify(htmlInterstitialWebView).setLayoutParams(captor.capture());
-        RelativeLayout.LayoutParams actualLayoutParams = captor.getValue();
+        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
 
-        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
     }
 
     @Test
     public void getAdView_shouldReturnPopulatedHtmlWebView() throws Exception {
+        // This is needed because we preload in onCreate and the mock gets triggered.
+        resetMockedView(htmlInterstitialWebView);
         View adView = subject.getAdView();
 
         assertThat(adView).isSameAs(htmlInterstitialWebView);
@@ -152,16 +162,16 @@ public void getAdView_shouldReturnPopulatedHtmlWebView() throws Exception {
 
     @Test
     public void onDestroy_shouldDestroyMoPubView() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called in #setup
         subject.onDestroy();
 
         verify(htmlInterstitialWebView).destroy();
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
+        assertThat(getContentView().getChildCount()).isEqualTo(0);
     }
 
     @Test
     public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called in #setup
         subject.onDestroy();
 
         verify(htmlInterstitialWebView).loadUrl(eq("javascript:webviewDidClose();"));
@@ -169,19 +179,22 @@ public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
 
     @Test
     public void start_shouldStartMoPubActivityWithCorrectParameters() throws Exception {
-        MoPubActivity.start(subject, "expectedResponse", true, "redirectUrl", "clickthroughUrl", adConfiguration);
+        MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", CreativeOrientation.PORTRAIT, testBroadcastIdentifier);
 
         Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo("expectedResponse");
         assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
         assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
         assertThat(nextStartedActivity.getStringExtra(CLICKTHROUGH_URL_KEY)).isEqualTo("clickthroughUrl");
+        assertThat(nextStartedActivity.getSerializableExtra(CREATIVE_ORIENTATION_KEY)).isEqualTo(CreativeOrientation.PORTRAIT);
         assertThat(nextStartedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MoPubActivity");
     }
 
     @Test
     public void getAdView_shouldCreateHtmlInterstitialWebViewAndLoadResponse() throws Exception {
+        // This is needed because we preload in onCreate and the mock gets triggered.
+        resetMockedView(htmlInterstitialWebView);
         subject.getAdView();
 
         assertThat(TestHtmlInterstitialWebViewFactory.getLatestListener()).isNotNull();
@@ -233,7 +246,6 @@ public void broadcastingInterstitialListener_onInterstitialLoaded_shouldCallJava
     @Test
     public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcastFailAndFinish() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
 
         MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
         broadcastingInterstitialListener.onInterstitialFailed(null);
@@ -245,7 +257,6 @@ public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcas
     @Test
     public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadcastClick() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
 
         MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
         broadcastingInterstitialListener.onInterstitialClicked();
@@ -253,8 +264,31 @@ public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadca
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
-    private Intent createMoPubActivityIntent(String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
-        return MoPubActivity.createIntent(new Activity(), htmlData, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+
+        subject.onDestroy();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    private FrameLayout getContentView() {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+    }
+
+    protected void resetMockedView(View view) {
+        reset(view);
+        when(view.getLayoutParams()).thenReturn(
+                new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
+                        FrameLayout.LayoutParams.WRAP_CONTENT));
     }
 }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
deleted file mode 100644
index 4f685a00..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubBrowserControllerTest {
-    private MoPubBrowserController subject;
-    private MraidView mraidView;
-    private Context context;
-    private MraidView.MraidListener mraidListener;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        mraidView = new MraidView(context, null);
-        mraidListener = mock(MraidView.MraidListener.class);
-        mraidView.setMraidListener(mraidListener);
-
-        subject = new MoPubBrowserController(mraidView);
-    }
-
-    @Test
-    public void open_withApplicationUrl_shouldStartNewIntent() throws Exception {
-        String applicationUrl = "amzn://blah";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(applicationUrl)), new ResolveInfo());
-
-        subject.open(applicationUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent()).isNull();
-    }
-
-    @Test
-    public void open_withHttpApplicationUrl_shouldStartMoPubBrowser() throws Exception {
-        String applicationUrl = "http://blah";
-
-        subject.open(applicationUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-    }
-
-    @Test
-    public void open_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubBrowser() throws Exception {
-        String applicationUrl = "canthandleme://blah";
-
-        subject.open(applicationUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedIntent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(applicationUrl);
-    }
-
-    @Test
-    public void open_withHttpApplicationUrl_shouldCallMraidListenerOnOpenCallback() throws Exception {
-        String applicationUrl = "http://blah";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(applicationUrl)), new ResolveInfo());
-
-        subject.open(applicationUrl);
-
-        verify(mraidListener).onOpen(eq(mraidView));
-    }
-
-    @Test
-    public void open_withApplicationUrl_shouldCallMraidListenerOnOpenCallback() throws Exception {
-        String applicationUrl = "app://blah";
-
-        subject.open(applicationUrl);
-
-        verify(mraidListener).onOpen(eq(mraidView));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
index 3ca84fce..6052109a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
@@ -1,37 +1,35 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.provider.Settings;
 
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Reflection.MethodBuilder;
-import com.mopub.common.util.Utils;
-import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
 
-import org.apache.http.HttpRequest;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-import org.robolectric.tester.org.apache.http.HttpRequestInfo;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
 
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
+import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
 public class MoPubConversionTrackerTest {
     private MoPubConversionTracker subject;
     private Activity context;
-    private FakeHttpLayer fakeHttpLayer;
-    private MethodBuilder methodBuilder;
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Captor
+    ArgumentCaptor<TrackingRequest> requestCaptor;
+
     private String expectedUdid;
     private boolean dnt = false;
     private static final String TEST_UDID = "20b013c721c";
@@ -40,101 +38,31 @@
     public void setUp() throws Exception {
         subject = new MoPubConversionTracker();
         context = new Activity();
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
-        expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        reset(methodBuilder);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
     }
 
     @Test
-    public void reportAppOpen_onValidHttpResponse_isIdempotent() throws Exception {
-        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
-        subject.reportAppOpen(context);
-        assertRequestMade(true);
-
-        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
+    public void reportAppOpen_Twice_shouldCallOnlyOnce() {
         subject.reportAppOpen(context);
-        assertRequestMade(false);
-    }
+        verify(mockRequestQueue).add(requestCaptor.capture());
 
-    @Test
-    public void reportAppOpen_onInvalidStatusCode_shouldMakeSecondRequest() throws Exception {
-        fakeHttpLayer.addPendingHttpResponse(404, "doesn't matter what this is as long as it's not nothing");
-        subject.reportAppOpen(context);
-        assertRequestMade(true);
+        reset(mockRequestQueue);
+        requestCaptor.getValue().deliverResponse(null);
 
-        fakeHttpLayer.addPendingHttpResponse(404, "doesn't matter what this is as long as it's not nothing");
         subject.reportAppOpen(context);
-        assertRequestMade(true);
+        verify(mockRequestQueue, never()).add(any(TrackingRequest.class));
     }
 
     @Test
-    public void reportAppOpen_onEmptyResponse_shouldMakeSecondRequest() throws Exception {
-        fakeHttpLayer.addPendingHttpResponse(200, "");
+    public void reportAppOpen_fails_shouldCallAgain() {
         subject.reportAppOpen(context);
-        assertRequestMade(true);
+        verify(mockRequestQueue).add(requestCaptor.capture());
 
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        subject.reportAppOpen(context);
-        assertRequestMade(true);
-    }
+        reset(mockRequestQueue);
+        requestCaptor.getValue().deliverError(new VolleyError());
 
-    @Test
-    public void reportAppOpen_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldUseAdInfoParams() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled,
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
-        );
-
-        expectedUdid = "ifa%3A" + adInfo.mAdId;
-        dnt = true;
-
-        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
         subject.reportAppOpen(context);
-        Thread.sleep(500); // extra sleep since there are 2 async tasks
-        assertRequestMade(true);
-    }
-
-    private void assertRequestMade(boolean shouldRequestBeMade) throws Exception {
-        StringBuilder stringBuilder = new StringBuilder("http://ads.mopub.com/m/open")
-                .append("?v=6")
-                .append("&id=").append("com.mopub.mobileads")
-                .append("&udid=").append(expectedUdid);
-
-        if (dnt) {
-            stringBuilder.append("&dnt=1");
-        }
-
-        String expectedUrl = stringBuilder.append("&av=")
-                .append("1.0")
-                .toString();
-
-        Thread.sleep(500);
-        HttpRequestInfo lastSentHttpRequestInfo = fakeHttpLayer.getLastSentHttpRequestInfo();
-        if (lastSentHttpRequestInfo == null) {
-            if (shouldRequestBeMade) {
-                fail("No request info in the http layer");
-            }
-            return;
-        }
-        HttpRequest request = lastSentHttpRequestInfo.getHttpRequest();
-        fakeHttpLayer.clearRequestInfos();
-        String actualUrl = request.getRequestLine().getUri();
-        assertThat(actualUrl).isEqualTo(expectedUrl);
+        verify(mockRequestQueue).add(any(TrackingRequest.class));
     }
 }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index 9bc34a61..67e4752b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -7,16 +7,18 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
+
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
 import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
@@ -37,24 +39,25 @@
     private static final String CLICKTHROUGH_URL_VALUE = "expected_clickthrough_url";
     private Activity activity;
     private MoPubInterstitial subject;
-    private Map<String, String> paramsMap;
+    private Map<String, String> serverExtras;
     private CustomEventInterstitialAdapter customEventInterstitialAdapter;
     private MoPubInterstitial.InterstitialAdListener interstitialAdListener;
     private MoPubInterstitial.MoPubInterstitialView interstitialView;
     private AdViewController adViewController;
+    private String customEventClassName;
 
     @Before
     public void setUp() throws Exception {
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         subject = new MoPubInterstitial(activity, AD_UNIT_ID_VALUE);
         interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
         subject.setInterstitialAdListener(interstitialAdListener);
 
         interstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
 
-        paramsMap = new HashMap<String, String>();
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "class name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "class data");
+        customEventClassName = "class name";
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("testExtra", "class data");
 
         customEventInterstitialAdapter = TestCustomEventInterstitialAdapterFactory.getSingletonMock();
         reset(customEventInterstitialAdapter);
@@ -131,11 +134,11 @@ public void setLocalExtrasTest() throws Exception {
     @Test
     public void loadCustomEvent_shouldCreateAndLoadCustomEventInterstitialAdapter() throws Exception {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
 
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isSameAs(subject);
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("class name");
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassData()).isEqualTo("class data");
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("class data");
     }
 
     @Test
@@ -276,6 +279,7 @@ public void loadingCustomEventInterstitial_shouldBecomeReadyToShowCustomEventAd(
         assertShowsCustomEventInterstitial(true);
     }
 
+    @Ignore("pending")
     @Test
     public void dismissingHtmlInterstitial_shouldNotBecomeReadyToShowHtmlAd() throws Exception {
 //        EventForwardingBroadcastReceiver broadcastReceiver = new EventForwardingBroadcastReceiver(subject.mInterstitialAdListener);
@@ -303,17 +307,15 @@ public void dismissingCustomEventInterstitial_shouldNotBecomeReadyToShowCustomEv
     }
 
     @Test
-    public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
+    public void loadCustomEvent_shouldInitializeCustomEventInterstitialAdapter() throws Exception {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        paramsMap.put(CUSTOM_EVENT_HTML_DATA.getKey(), "html");
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        serverExtras.put("testExtra", "data");
+        moPubInterstitialView.loadCustomEvent("name", serverExtras);
 
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isEqualTo(subject);
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassData()).isEqualTo("data");
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("data");
 
         verify(customEventInterstitialAdapter).setAdapterListener(eq(subject));
         verify(customEventInterstitialAdapter).loadInterstitial();
@@ -323,7 +325,7 @@ public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Ex
     public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
-        moPubInterstitialView.loadCustomEvent(null);
+        moPubInterstitialView.loadCustomEvent(null, null);
 
         verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
         verify(customEventInterstitialAdapter, never()).invalidate();
@@ -341,15 +343,13 @@ public void adFailed_shouldNotifyInterstitialAdListener() throws Exception {
     private void loadCustomEvent() {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        paramsMap.put(CUSTOM_EVENT_HTML_DATA.getKey(), "html");
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        serverExtras.put(CUSTOM_EVENT_DATA.getKey(), "data");
+        moPubInterstitialView.loadCustomEvent("name", serverExtras);
     }
 
     private void assertShowsCustomEventInterstitial(boolean shouldBeReady) {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
 
         assertThat(subject.isReady()).isEqualTo(shouldBeReady);
         assertThat(subject.show()).isEqualTo(shouldBeReady);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
new file mode 100644
index 00000000..9ffe543d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -0,0 +1,294 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdType;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class
+        MoPubRewardedVideoManagerTest {
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MoPubRewardedVideoListener mockVideoListener;
+
+    AdRequest.Listener requestListener;
+    private AdRequest request;
+    private Activity mActivity;
+
+    @Before
+    public void setup() {
+        mActivity = Robolectric.buildActivity(Activity.class).create().get();
+        MoPubRewardedVideoManager.init(mActivity);
+        MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
+
+        when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
+            @Override
+            public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                request = ((AdRequest) invocationOnMock.getArguments()[0]);
+                requestListener = request.getListener();
+                return null;
+            }
+        });
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @After
+    public void tearDown() {
+        // Unpause the main looper in case a test terminated while the looper was paused.
+        Robolectric.unPauseMainLooper();
+    }
+
+    @Test
+    public void callbackMethods_withNullListener_shouldNotError() {
+        // Clients can set RVM null.
+        MoPubRewardedVideoManager.setVideoListener(null);
+
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, "id!", MoPubReward.success("test", 111));
+
+        // The test passed because none of the above calls thew an exception even though the listener is null.
+    }
+
+    @Test
+    public void onAdSuccess_noActivityFound_shouldNotCallFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.updateActivity(null);
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        verify(mockRequestQueue).add(any(AdRequest.class));
+        verifyNoMoreInteractions(mockRequestQueue);
+
+        // Clean up the static state we screwed up:
+        MoPubRewardedVideoManager.updateActivity(mActivity);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        requestListener.onSuccess(testResponse);
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onSuccess(testResponse);
+        assertThat(request.getUrl()).isEqualTo("fail.url");
+        // Clear up the static state :(
+        requestListener.onErrorResponse(new VolleyError("reset"));
+    }
+
+    @Test
+    public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void playVideo_shouldSetHasVideoFalse() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
+    }
+    
+    @Test
+    public void playVideo_whenNotHasVideo_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$NoVideoCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
+    }
+
+    @Test
+    public void onAdFailure_shouldCallFailCallback() {
+        VolleyError e = new VolleyError("testError!");
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onErrorResponse(e);
+        verify(mockVideoListener).onRewardedVideoLoadFailure(anyString(), any(MoPubErrorCode.class));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    public static class TestCustomEvent extends CustomEventRewardedVideo {
+        protected boolean mPlayable = false;
+
+        @Nullable
+        @Override
+        protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
+            return null;
+        }
+
+        @Nullable
+        @Override
+        protected LifecycleListener getLifecycleListener() {
+            return null;
+        }
+
+        @NonNull
+        @Override
+        protected String getAdNetworkId() {
+            return "id!";
+        }
+
+        @Override
+        protected void onInvalidate() {
+            mPlayable = false;
+        }
+
+        @Override
+        protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            return false;
+        }
+
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            // Do nothing because robolectric handlers execute immediately.
+            mPlayable = true;
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class, "id!");
+        }
+
+        @Override
+        protected boolean hasVideoAvailable() {
+            return mPlayable;
+        }
+
+        @Override
+        protected void showVideo() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        }
+    }
+
+    public static class NoVideoCustomEvent extends TestCustomEvent {
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            mPlayable = false;
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, "id!", MoPubErrorCode.NETWORK_NO_FILL);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index 57095db9..4bab198e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -21,9 +21,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
@@ -41,7 +38,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         subject = new MoPubView(context);
         customEventBannerAdapter = TestCustomEventBannerAdapterFactory.getSingletonMock();
         reset(customEventBannerAdapter);
@@ -176,21 +173,18 @@ public void nativeAdLoaded_shouldScheduleRefreshTimer() throws Exception {
 
     @Test
     public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        paramsMap.put(CUSTOM_EVENT_HTML_DATA.getKey(), "html");
-        subject.loadCustomEvent(paramsMap);
+        subject.loadCustomEvent("name", paramsMap);
 
         assertThat(TestCustomEventBannerAdapterFactory.getLatestMoPubView()).isEqualTo(subject);
         assertThat(TestCustomEventBannerAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo("data");
+        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo(paramsMap);
 
         verify(customEventBannerAdapter).loadAd();
     }
 
     @Test
     public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
-        subject.loadCustomEvent(null);
+        subject.loadCustomEvent(null, null);
 
         verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
         verify(customEventBannerAdapter, never()).invalidate();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
index cbe31354..84737b46 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
@@ -1,125 +1,146 @@
 package com.mopub.mobileads;
 
-import android.app.Activity;
+import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Color;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.WindowManager;
 import android.webkit.WebViewClient;
-import android.widget.Button;
-import android.widget.ImageButton;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Dips;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
+import com.mopub.mraid.MraidBridge;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.MraidController.MraidListener;
 
 import org.fest.assertions.api.ANDROID;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.util.ActivityController;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.MraidView.MraidListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-public class MraidActivityTest extends BaseInterstitialActivityTest {
+public class MraidActivityTest {
+    static final String EXPECTED_SOURCE = "expected source";
 
-    private MraidView mraidView;
-    private CustomEventInterstitial.CustomEventInterstitialListener customEventInterstitialListener;
-    private Activity context;
+    @Mock MraidWebView mraidWebView;
+    @Mock MraidBridge mraidBridge;
+    @Mock MraidController mraidController;
+    @Mock CustomEventInterstitial.CustomEventInterstitialListener
+            customEventInterstitialListener;
+    @Mock BroadcastReceiver broadcastReceiver;
+
+    long testBroadcastIdentifier = 2222;
+
+    ActivityController<TestMraidActivity> activityController;
+    TestMraidActivity subject;
+
+    // Make a concrete version of the abstract class for testing purposes.
+    private static class TestMraidActivity extends MraidActivity {
+        View mraidWebView;
+
+        @Override
+        public View getAdView() {
+            return mraidWebView;
+        }
+    }
 
     @Before
     public void setUp() throws Exception {
-        super.setup();
-        context = new Activity();
-        Intent mraidActivityIntent = createMraidActivityIntent(EXPECTED_SOURCE);
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        resetMockedView(mraidView);
-        subject = Robolectric.buildActivity(MraidActivity.class).withIntent(mraidActivityIntent).create().get();
-        resetMockedView(mraidView);
-        customEventInterstitialListener = mock(CustomEventInterstitial.CustomEventInterstitialListener.class);
+        activityController = Robolectric.buildActivity(TestMraidActivity.class).start();
+        subject = activityController.get();
+        subject.mraidWebView = mraidWebView;
+        activityController.create();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldDisablePluginsSetListenersAndLoadHtml() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "3:27");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "3:27");
 
-        verify(mraidView).enablePlugins(eq(false));
-        verify(mraidView).setMraidListener(any(MraidListener.class));
-        verify(mraidView).setWebViewClient(any(WebViewClient.class));
-        verify(mraidView).loadHtmlData(eq("3:27"));
+        verify(mraidWebView).enablePlugins(eq(false));
+        verify(mraidController).setMraidListener(any(MraidListener.class));
+        verify(mraidWebView).setWebViewClient(any(WebViewClient.class));
+        verify(mraidBridge).setContentHtml(eq("3:27"));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_whenMraidListenerOnReady() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<MraidListener> mraidListenerArgumentCaptorr = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidView).setMraidListener(mraidListenerArgumentCaptorr.capture());
+        verify(mraidController).setMraidListener(mraidListenerArgumentCaptorr.capture());
         MraidListener mraidListener = mraidListenerArgumentCaptorr.getValue();
 
-        mraidListener.onReady(null);
+        mraidListener.onLoaded(null);
 
         verify(customEventInterstitialListener).onInterstitialLoaded();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialFailed_whenMraidListenerOnFailure() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<MraidListener> mraidListenerArgumentCaptorr = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidView).setMraidListener(mraidListenerArgumentCaptorr.capture());
+        verify(mraidController).setMraidListener(mraidListenerArgumentCaptorr.capture());
         MraidListener mraidListener = mraidListenerArgumentCaptorr.getValue();
 
-        mraidListener.onFailure(null);
+        mraidListener.onFailedToLoad();
 
         verify(customEventInterstitialListener).onInterstitialFailed(null);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_whenWebViewClientShouldOverrideUrlLoading_shouldReturnTrue() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<WebViewClient> webViewClientArgumentCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(mraidView).setWebViewClient(webViewClientArgumentCaptor.capture());
+        verify(mraidWebView).setWebViewClient(webViewClientArgumentCaptor.capture());
         WebViewClient webViewClient = webViewClientArgumentCaptor.getValue();
 
         boolean consumeUrlLoading = webViewClient.shouldOverrideUrlLoading(null, null);
 
         assertThat(consumeUrlLoading).isTrue();
         verify(customEventInterstitialListener, never()).onInterstitialLoaded();
-        verify(customEventInterstitialListener, never()).onInterstitialFailed(any(MoPubErrorCode.class));
+        verify(customEventInterstitialListener, never()).onInterstitialFailed(
+                any(MoPubErrorCode.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_whenWebViewClientOnPageFinished() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<WebViewClient> webViewClientArgumentCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(mraidView).setWebViewClient(webViewClientArgumentCaptor.capture());
+        verify(mraidWebView).setWebViewClient(webViewClientArgumentCaptor.capture());
         WebViewClient webViewClient = webViewClientArgumentCaptor.getValue();
 
         webViewClient.onPageFinished(null, null);
@@ -127,52 +148,41 @@ public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_
         verify(customEventInterstitialListener).onInterstitialLoaded();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_shouldSetContentView() throws Exception {
         subject.onCreate(null);
 
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(3);
+        assertThat(getContentView().getChildCount()).isEqualTo(1);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_shouldSetupAnMraidView() throws Exception {
         subject.onCreate(null);
 
-        assertThat(getContentView(subject).getChildAt(0)).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(any(MraidListener.class));
-        verify(mraidView).setOnCloseButtonStateChange(any(MraidView.OnCloseButtonStateChangeListener.class));
+        assertThat(getContentView().getChildAt(0)).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(any(MraidListener.class));
 
-        verify(mraidView).loadHtmlData(EXPECTED_SOURCE);
+        verify(mraidBridge).setContentHtml(EXPECTED_SOURCE);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_shouldSetLayoutOfMraidView() throws Exception {
         subject.onCreate(null);
 
-        ArgumentCaptor<RelativeLayout.LayoutParams> captor = ArgumentCaptor.forClass(RelativeLayout.LayoutParams.class);
-        verify(mraidView).setLayoutParams(captor.capture());
-        RelativeLayout.LayoutParams actualLayoutParams = captor.getValue();
+        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(
+                FrameLayout.LayoutParams.class);
+        verify(mraidWebView).setLayoutParams(captor.capture());
+        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
 
-        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
-    }
-
-    @Test
-    public void onCreate_shouldAddCloseEventRegion() throws Exception {
-        subject.onCreate(null);
-
-        final Button closeEventRegion = (Button) getContentView(subject).getChildAt(2);
-        assertThat(closeEventRegion.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(closeEventRegion).getBackgroundColor()).isEqualTo(Color.TRANSPARENT);
-        assertThat(Dips.pixelsToIntDips((float) closeEventRegion.getLayoutParams().width, context)).isEqualTo(50);
-        assertThat(Dips.pixelsToIntDips((float) closeEventRegion.getLayoutParams().height, context)).isEqualTo(50);
-        assertThat(((RelativeLayout.LayoutParams)closeEventRegion.getLayoutParams()).getRules()[RelativeLayout.ALIGN_PARENT_TOP])
-                .isEqualTo(RelativeLayout.TRUE);
-        assertThat(((RelativeLayout.LayoutParams)closeEventRegion.getLayoutParams()).getRules()[RelativeLayout.ALIGN_PARENT_RIGHT])
-                .isEqualTo(RelativeLayout.TRUE);
+        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
     }
 
     @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_atLeastIcs_shouldSetHardwareAcceleratedFlag() throws Exception {
         subject.onCreate(null);
@@ -182,6 +192,7 @@ public void onCreate_atLeastIcs_shouldSetHardwareAcceleratedFlag() throws Except
     }
 
     @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_beforeIcs_shouldNotSetHardwareAcceleratedFlag() throws Exception {
         subject.onCreate(null);
@@ -190,146 +201,117 @@ public void onCreate_beforeIcs_shouldNotSetHardwareAcceleratedFlag() throws Exce
         assertThat(hardwareAccelerated).isFalse();
     }
 
-    @Test
-    public void closeEventRegion_shouldFinishActivityWhenClicked() throws Exception {
-        subject.onCreate(null);
-
-        final Button closeEventRegion = (Button) getContentView(subject).getChildAt(2);
-        assertThat(closeEventRegion.performClick()).isTrue();
-        assertThat(subject.isFinishing()).isTrue();
-    }
-
+    @Ignore("Mraid 2.0")
     @Test
     public void onDestroy_DestroyMraidView() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, subject.getBroadcastIdentifier());
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
+                getHtmlInterstitialIntentFilter());
 
-        subject.onCreate(null);
         subject.onDestroy();
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        verify(mraidView).destroy();
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
+        verify(mraidWebView).destroy();
+        assertThat(getContentView().getChildCount()).isEqualTo(0);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void getAdView_shouldSetupOnReadyListener() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         subject.hideInterstitialCloseButton();
-        captor.getValue().onReady(null);
-        ImageButton closeButton = (ImageButton) getContentView(subject).getChildAt(1);
-        assertThat(closeButton).isNotNull();
+        captor.getValue().onLoaded(null);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void baseMraidListenerOnReady_shouldFireJavascriptWebViewDidAppear() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onReady(null);
+        baseMraidListener.onLoaded(null);
 
-        verify(mraidView).loadUrl(eq("javascript:webviewDidAppear();"));
+        verify(mraidWebView).loadUrl(eq("javascript:webviewDidAppear();"));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void baseMraidListenerOnClose_shouldFireJavascriptWebViewDidClose() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onClose(null, null);
+        baseMraidListener.onClose();
 
-        verify(mraidView).loadUrl(eq("javascript:webviewDidClose();"));
+        verify(mraidWebView).loadUrl(eq("javascript:webviewDidClose();"));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void baseMraidListenerOnOpen_shouldBroadcastClickEvent() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
+                getHtmlInterstitialIntentFilter());
 
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
 
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onOpen(null);
+        baseMraidListener.onOpen();
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
-    @Test
-    public void getAdView_shouldSetupOnCloseButtonStateChangeListener() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
-        ArgumentCaptor<MraidView.OnCloseButtonStateChangeListener> captor = ArgumentCaptor.forClass(MraidView.OnCloseButtonStateChangeListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setOnCloseButtonStateChange(captor.capture());
-        MraidView.OnCloseButtonStateChangeListener listener = captor.getValue();
-
-        ANDROID.assertThat(getCloseButton()).isVisible();
-
-        listener.onCloseButtonStateChange(null, false);
-        ANDROID.assertThat(getCloseButton()).isNotVisible();
-
-        listener.onCloseButtonStateChange(null, true);
-        ANDROID.assertThat(getCloseButton()).isVisible();
-    }
-
+    @Ignore("Mraid 2.0")
     @Test
     public void getAdView_shouldSetupOnCloseListener() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
-        captor.getValue().onClose(null, null);
+        captor.getValue().onClose();
 
         ANDROID.assertThat(subject).isFinishing();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onPause_shouldOnPauseMraidView() throws Exception {
-        subject.onCreate(null);
-        ((MraidActivity)subject).onPause();
+        activityController.pause();
 
-        verify(mraidView).onPause();
+        verify(mraidWebView).onPause();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onResume_shouldResumeMraidView() throws Exception {
         subject.onCreate(null);
-        ((MraidActivity)subject).onPause();
-        ((MraidActivity)subject).onResume();
+        Robolectric.shadowOf(subject).pauseAndThenResume();
 
-        verify(mraidView).onResume();
+        verify(mraidWebView).onResume();
     }
 
     private Intent createMraidActivityIntent(String expectedSource) {
@@ -337,10 +319,32 @@ private Intent createMraidActivityIntent(String expectedSource) {
         mraidActivityIntent.setComponent(new ComponentName("", ""));
         mraidActivityIntent.putExtra(HTML_RESPONSE_BODY_KEY, expectedSource);
 
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-        mraidActivityIntent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        mraidActivityIntent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
 
         return mraidActivityIntent;
     }
+
+    @Ignore("Mraid 2.0")
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Ignore("Mraid 2.0")
+    @Test
+    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        subject.onDestroy();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    private FrameLayout getContentView() {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBannerTest.java
deleted file mode 100644
index 05aa59de..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBannerTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
-import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
-import static com.mopub.mobileads.MraidView.MraidListener;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MraidBannerTest {
-    private MraidBanner subject;
-    private MraidView mraidView;
-    private Activity context;
-    private Map<String, Object> localExtras;
-    private Map<String, String> serverExtras;
-    private CustomEventBannerListener bannerListener;
-    private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
-    private static final String EXPECTED_HTML_DATA = "<html></html>";
-
-    @Before
-    public void setUp() throws Exception {
-        subject = new MraidBanner();
-        mraidView = TestMraidViewFactory.getSingletonMock();
-
-        context = new Activity();
-        bannerListener = mock(CustomEventBanner.CustomEventBannerListener.class);
-        localExtras = new HashMap<String, Object>();
-        serverExtras = new HashMap<String, String>();
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, INPUT_HTML_DATA);
-    }
-
-    @Test
-    public void loadBanner_whenExtrasAreMalformed_shouldNotifyBannerListenerAndReturn() throws Exception {
-        serverExtras.remove(HTML_RESPONSE_BODY_KEY);
-
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-
-        verify(bannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
-        verify(mraidView, never()).loadHtmlData(any(String.class));
-        verify(mraidView, never()).setMraidListener(any(MraidListener.class));
-    }
-
-    @Test
-    public void loadBanner_shouldLoadHtmlDataAndInitializeListeners() throws Exception {
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-
-        verify(mraidView).loadHtmlData(EXPECTED_HTML_DATA);
-
-        verify(mraidView).setMraidListener(any(MraidListener.class));
-    }
-
-    @Test
-    public void invalidate_shouldDestroyMraidView() throws Exception {
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-        subject.onInvalidate();
-
-        verify(mraidView).destroy();
-    }
-
-    @Test
-    public void bannerMraidListener_onReady_shouldNotifyBannerLoaded() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onReady(null);
-
-        verify(bannerListener).onBannerLoaded(eq(mraidView));
-    }
-
-    @Test
-    public void bannerMraidListener_onFailure_shouldNotifyBannerFailed() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onFailure(null);
-
-        verify(bannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
-    }
-
-    @Test
-    public void bannerMraidListener_onExpand_shouldNotifyBannerExpandedAndClicked() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onExpand(null);
-
-        verify(bannerListener).onBannerExpanded();
-        verify(bannerListener).onBannerClicked();
-    }
-
-    @Test
-    public void bannerMraidListener_onOpen_shouldNotifyBannerClicked() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onOpen(null);
-
-        verify(bannerListener).onBannerClicked();
-    }
-
-    @Test
-    public void bannerMraidListener_onClose_shouldNotifyBannerCollapsed() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onClose(null, null);
-
-        verify(bannerListener).onBannerCollapsed();
-    }
-
-    private MraidListener captureMraidListener() {
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-        ArgumentCaptor<MraidListener> listenerCaptor = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidView).setMraidListener(listenerCaptor.capture());
-
-        return listenerCaptor.getValue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandFactoryTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandFactoryTest.java
deleted file mode 100644
index 8a164b71..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandFactoryTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.Map;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandFactoryTest {
-    private MraidCommandFactory subject;
-    private Map params;
-    private MraidView mraidView;
-
-    @Before
-    public void setUp() throws Exception {
-        subject = new MraidCommandFactory();
-        params = mock(Map.class);
-        mraidView = mock(MraidView.class);
-
-    }
-
-    @Test
-    public void create_withCommandName_shouldInstantiateCorrectSubclass() throws Exception {
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("close", MraidCommandClose.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("expand", MraidCommandExpand.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("usecustomclose", MraidCommandUseCustomClose.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("open", MraidCommandOpen.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("resize", MraidCommandResize.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getResizeProperties", MraidCommandGetResizeProperties.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("setResizeProperties", MraidCommandSetResizeProperties.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("playVideo", MraidCommandPlayVideo.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("storePicture", MraidCommandStorePicture.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getCurrentPosition", MraidCommandGetCurrentPosition.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getDefaultPosition", MraidCommandGetDefaultPosition.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getMaxSize", MraidCommandGetMaxSize.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getScreenSize", MraidCommandGetScreenSize.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("createCalendarEvent", MraidCommandCreateCalendarEvent.class);
-    }
-
-    @Test
-    public void create_withInvalidCommandString_shouldReturnNull() throws Exception {
-        MraidCommand command = MraidCommandFactory.create("dog", params, mraidView);
-
-        assertThat(command).isNull();
-    }
-
-    @Test
-    public void create_withNullCommandString_shouldReturnNull() throws Exception {
-        MraidCommand command = MraidCommandFactory.create(null, params, mraidView);
-
-        assertThat(command).isNull();
-    }
-
-    @Test
-    public void create_withNullParams_shouldNotBlowUp() throws Exception {
-        MraidCommand command = MraidCommandFactory.create("close", null, mraidView);
-
-        // pass
-    }
-
-    @Test
-    public void create_withNullMraidView_shouldNotBlowUp() throws Exception {
-        MraidCommand command = MraidCommandFactory.create("close", params, null);
-
-        // pass
-    }
-
-    private void assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass(String command, Class type) {
-        MraidCommand mraidCommand = MraidCommandFactory.create(command, params, mraidView);
-
-        assertThat(mraidCommand).isNotNull();
-        assertThat(mraidCommand).isInstanceOf(type);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandPlayVideoTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandPlayVideoTest.java
deleted file mode 100644
index 44908b00..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandPlayVideoTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.BaseVideoPlayerActivitiyTest.assertMraidVideoPlayerActivityStarted;
-import static com.mopub.mobileads.MraidCommandPlayVideo.URI_KEY;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.withSettings;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandPlayVideoTest {
-    public static final String EXPECTED_URI = "http://expected.uri";
-
-    private MraidCommandPlayVideo subject;
-    private MraidView mraidView;
-    private long testBroadcastIdentifier;
-    private AdConfiguration adConfiguration;
-
-    @Before
-    public void setup() {
-        Map<String, String> params = new HashMap<String, String>();
-
-        params.put(URI_KEY, EXPECTED_URI);
-
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        stub(mraidView.getContext()).toReturn(new Activity());
-        MraidDisplayController displayController = new MraidDisplayController(mraidView, null, null);
-        stub(mraidView.getDisplayController()).toReturn(displayController);
-        subject = new MraidCommandPlayVideo(params, mraidView);
-
-        testBroadcastIdentifier = 2121;
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-        stub(mraidView.getAdConfiguration()).toReturn(adConfiguration);
-    }
-
-    @Test
-    public void execute_shouldPlayVideo() throws Exception {
-        subject.execute();
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, EXPECTED_URI, adConfiguration);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandResizeTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandResizeTest.java
deleted file mode 100644
index 1a9063c3..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandResizeTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.RESIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.SET_RESIZE_PROPERTIES;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandResizeTest {
-    private MraidCommandResize subjectResize;
-    private MraidCommandGetResizeProperties subjectGetResizeProperties;
-    private MraidCommandSetResizeProperties subjectSetResizeProperties;
-    private MraidView mraidView;
-    @Before
-    public void setup() {
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        subjectResize = new MraidCommandResize(new HashMap<String, String>(), mraidView);
-        subjectGetResizeProperties = new MraidCommandGetResizeProperties(new HashMap<String, String>(), mraidView);
-        subjectSetResizeProperties = new MraidCommandSetResizeProperties(new HashMap<String, String>(), mraidView);
-    }
-
-    @Test
-    public void mraidCommandResizeExecute_shouldFireErrorEvent() throws Exception {
-        reset(mraidView);
-        subjectResize.execute();
-        verify(mraidView).fireErrorEvent(eq(RESIZE), any(String.class));
-    }
-
-    @Test
-    public void mraidCommandSetResizePropertiesExecute_shouldFireErrorEvent() throws Exception {
-        reset(mraidView);
-        subjectSetResizeProperties.execute();
-        verify(mraidView).fireErrorEvent(eq(SET_RESIZE_PROPERTIES), any(String.class));
-    }
-
-    @Test
-    public void mraidCommandGetResizePropertiesExecute_shouldFireErrorEvent() throws Exception {
-        reset(mraidView);
-        subjectGetResizeProperties.execute();
-        verify(mraidView).fireErrorEvent(eq(GET_RESIZE_PROPERTIES), any(String.class));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandStorePictureTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandStorePictureTest.java
deleted file mode 100644
index 3fad21a5..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandStorePictureTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.FileUtils;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.MraidCommand.URI_KEY;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandStorePictureTest {
-
-    public static final String EXPECTED_FILE = "file://tmp/expectedFile.jpg";
-    private MraidCommandStorePicture subject;
-    private MraidView mraidView;
-    private Map<String,String> params;
-    private MraidDisplayController mraidDisplayController;
-
-    @Before
-    public void setUp() {
-        FileUtils.copyFile("etc/expectedFile.jpg", "/tmp/expectedFile.jpg");
-
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        mraidDisplayController = mock(MraidDisplayController.class);
-        stub(mraidView.getDisplayController()).toReturn(mraidDisplayController);
-
-        params = new HashMap<String, String>();
-        subject = new MraidCommandStorePicture(params, mraidView);
-    }
-
-    @Test
-    public void execute_withImageUri_shouldShowUserDownloadImageAlert() throws Exception {
-        params.put(URI_KEY, EXPECTED_FILE);
-
-        subject.execute();
-
-        verify(mraidDisplayController).showUserDownloadImageAlert(eq(EXPECTED_FILE));
-    }
-
-    @Test
-    public void execute_withEmptyUriKey_shouldFireErrorEvent() throws Exception {
-        params.put(URI_KEY, "");
-
-        subject.execute();
-
-        verify(mraidView).fireErrorEvent(
-                eq(STORE_PICTURE),
-                anyString());
-        verify(mraidDisplayController, never()).showUserDownloadImageAlert(anyString());
-    }
-
-    @Test
-     public void execute_withMissingUriKey_shouldFireErrorEvent() throws Exception {
-        // don't add URI_KEY to params
-
-        subject.execute();
-
-        verify(mraidView).fireErrorEvent(
-                eq(STORE_PICTURE),
-                anyString());
-        verify(mraidDisplayController, never()).showUserDownloadImageAlert(anyString());
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
deleted file mode 100644
index e4b7682e..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Test;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CLOSE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.EXPAND;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_CURRENT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_DEFAULT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_MAX_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_SCREEN_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.OPEN;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.PLAY_VIDEO;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.RESIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.SET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.USECUSTOMCLOSE;
-import static com.mopub.mobileads.MraidCommandFactory.create;
-import static com.mopub.mobileads.MraidView.PlacementType;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-public class MraidCommandTest {
-    @Test
-    public void createCommand_shouldReturnTheRightKindOfCommand() throws Exception {
-        assertThat(create("bogus", null, null)).isNull();
-
-        assertThat(create(CLOSE.getCommand(), null, null)).isInstanceOf(MraidCommandClose.class);
-        assertThat(create(CLOSE.getCommand(), null, null)).isNotSameAs(create("close", null, null));
-
-        assertThat(create(EXPAND.getCommand(), null, null)).isInstanceOf(MraidCommandExpand.class);
-        assertThat(create(USECUSTOMCLOSE.getCommand(), null, null)).isInstanceOf(MraidCommandUseCustomClose.class);
-        assertThat(create(OPEN.getCommand(), null, null)).isInstanceOf(MraidCommandOpen.class);
-        assertThat(create(RESIZE.getCommand(), null, null)).isInstanceOf(MraidCommandResize.class);
-        assertThat(create(SET_RESIZE_PROPERTIES.getCommand(), null, null)).isInstanceOf(MraidCommandSetResizeProperties.class);
-        assertThat(create(GET_RESIZE_PROPERTIES.getCommand(), null, null)).isInstanceOf(MraidCommandGetResizeProperties.class);
-        assertThat(create(PLAY_VIDEO.getCommand(), null, null)).isInstanceOf(MraidCommandPlayVideo.class);
-        assertThat(create(STORE_PICTURE.getCommand(), null, null)).isInstanceOf(MraidCommandStorePicture.class);
-        assertThat(create(GET_CURRENT_POSITION.getCommand(), null, null)).isInstanceOf(MraidCommandGetCurrentPosition.class);
-        assertThat(create(GET_DEFAULT_POSITION.getCommand(), null, null)).isInstanceOf(MraidCommandGetDefaultPosition.class);
-        assertThat(create(GET_MAX_SIZE.getCommand(), null, null)).isInstanceOf(MraidCommandGetMaxSize.class);
-        assertThat(create(GET_SCREEN_SIZE.getCommand(), null, null)).isInstanceOf(MraidCommandGetScreenSize.class);
-        assertThat(create(CREATE_CALENDAR_EVENT.getCommand(), null, null)).isInstanceOf(MraidCommandCreateCalendarEvent.class);
-    }
-
-    @Test
-    public void createCommand_shouldPassParameters() throws Exception {
-        MraidView expectedView = mock(MraidView.class);
-        Map<String, String> expectedMap = mock(Map.class);
-
-        MraidCommand command = create(EXPAND.getCommand(), expectedMap, expectedView);
-        assertThat(command.mParams).isEqualTo(expectedMap);
-        assertThat(command.mView).isEqualTo(expectedView);
-    }
-
-
-    @Test
-    public void createCommand_close_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(CLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(CLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_expand_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(EXPAND.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(EXPAND.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_useCustomClose_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(USECUSTOMCLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(USECUSTOMCLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_open_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(OPEN.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(OPEN.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isTrue();
-    }
-
-    @Test
-    public void createCommand_resize_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(RESIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(RESIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_setResizeProperties_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(SET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(SET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getResizeProperties_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_playVideo_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(PLAY_VIDEO.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(PLAY_VIDEO.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_storePicture_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(STORE_PICTURE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(STORE_PICTURE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isTrue();
-    }
-
-    @Test
-    public void createCommand_getCurrentPosition_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_CURRENT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_CURRENT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getDefaultPosition_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_DEFAULT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_DEFAULT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getMaxSize_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_MAX_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_MAX_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getScreenSize_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_SCREEN_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_SCREEN_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_createCalendarEvent_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(CREATE_CALENDAR_EVENT.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(CREATE_CALENDAR_EVENT.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isTrue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidSupportsPropertyTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidSupportsPropertyTest.java
deleted file mode 100644
index 56ab537d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidSupportsPropertyTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class MraidSupportsPropertyTest {
-
-    @Test
-    public void MraidSupportsProperty_toJsonPair_should_returnTheSupportsJsonObject() throws Exception {
-        MraidSupportsProperty property =
-                new MraidSupportsProperty()
-                        .withSms(true)
-                        .withTel(true)
-                        .withCalendar(false)
-                        .withStorePicture(false)
-                        .withInlineVideo(false);
-        assertThat(property.toJsonPair()).isEqualTo("supports: {" +
-                "sms: true, " +
-                "tel: true, " +
-                "calendar: false, " +
-                "storePicture: false, " +
-                "inlineVideo: false}");
-    }
-
-    @Test
-    public void MraidSupportsProperty_toJSONPair_should_returnAllDefaultPairValuesAsFalse() throws Exception {
-        MraidSupportsProperty property =
-                new MraidSupportsProperty().withCalendar(true).withInlineVideo(true);
-        assertThat(property.toJsonPair()).isEqualTo("supports: {" +
-                "sms: false, " +
-                "tel: false, " +
-                "calendar: true, " +
-                "storePicture: false, " +
-                "inlineVideo: true}");
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
index d8a9ca17..9a3e3090 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
@@ -10,7 +10,7 @@
 
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.mraid.MraidVideoViewController;
 
 import org.junit.Before;
 import org.junit.Ignore;
@@ -19,12 +19,11 @@
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowActivity;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
@@ -40,14 +39,11 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         intent = new Intent(context, MraidVideoPlayerActivity.class);
 
         testBroadcastIdentifier = 1001;
-        AdConfiguration adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        when(adConfiguration.getBroadcastIdentifier()).thenReturn(testBroadcastIdentifier);
-        intent.putExtra(AdFetcher.AD_CONFIGURATION_KEY, adConfiguration);
-
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
         baseVideoViewController = mock(BaseVideoViewController.class);
     }
 
@@ -180,9 +176,9 @@ private void initializeSubjectForMraid() {
 
     private void initializeSubjectForVast() {
         intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "vast");
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("video_path");
-        intent.putExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("video_path");
+        intent.putExtra(VastVideoViewController.VAST_VIDEO_CONFIG, vastVideoConfig);
 
         subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
                 .withIntent(intent)
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidViewTest.java
deleted file mode 100644
index b8e54fe5..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidViewTest.java
+++ /dev/null
@@ -1,345 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.webkit.WebViewClient;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.resource.MraidJavascript;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowWebView;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class MraidViewTest {
-    private Context context;
-    private AdConfiguration adConfiguration;
-    private MraidDisplayController mraidDisplayController;
-
-    private MraidView bannerSubject;
-    private MraidView interstitialSubject;
-    private WebViewClient bannerWebViewClient;
-    private WebViewClient interstitialWebViewClient;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        adConfiguration = mock(AdConfiguration.class);
-        mraidDisplayController = mock(MraidDisplayController.class);
-
-        bannerSubject = new MraidView(context, adConfiguration);
-        bannerSubject.setMraidDisplayController(mraidDisplayController);
-        bannerWebViewClient = bannerSubject.getMraidWebViewClient();
-
-        interstitialSubject = new MraidView(context, adConfiguration, MraidView.ExpansionStyle.ENABLED, MraidView.NativeCloseButtonStyle.ALWAYS_VISIBLE, MraidView.PlacementType.INTERSTITIAL);
-        interstitialSubject.setMraidDisplayController(mraidDisplayController);
-        interstitialWebViewClient = interstitialSubject.getMraidWebViewClient();
-    }
-
-    @Test
-    public void viewSetToVisibleBeforeReady_shouldNotTriggerMRAIDEvent() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(false);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isTrue();
-
-        verify(mraidViewSpy, never()).fireChangeEventForProperty(any(MraidViewableProperty.class));
-    }
-
-    @Test
-    public void viewSetToVisibleAfterReady_shouldTriggerMRAIDEvent() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isTrue();
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-    }
-
-    @Test
-    public void viewSetToVisibleAndThenInvisibleAfterReady_shouldTriggerTwoMRAIDEvents() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isFalse();
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: false");
-    }
-
-    @Test
-    public void viewSetToVisibleAndThenGoneAfterReady_shouldTriggerTwoMRAIDEvents() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.GONE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isFalse();
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: false");
-    }
-
-    @Test
-    public void viewSetToVisibleAndThenInvisibleAndThenVisibleAfterReady_shouldTriggerThreeMRAIDEvents() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: false");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isTrue();
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-    }
-
-    @Test
-    public void loadHtmlData_whenDataIsNull_shouldNotBlowUp() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-
-        mraidViewSpy.loadHtmlData(null);
-
-        // pass
-
-        verify(mraidViewSpy, never()).loadDataWithBaseURL(anyString(), anyString(), anyString(), anyString(), anyString());
-    }
-
-    @Test
-    public void loadHtmlData_shouldSendSimpleHtmlToLoadDataWithBaseUrl() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        String htmlData = "<html></html>";
-
-        mraidViewSpy.loadHtmlData(htmlData);
-
-        verify(mraidViewSpy).loadDataWithBaseURL(anyString(), eq(htmlData), eq("text/html"), eq("UTF-8"), anyString());
-    }
-
-
-    @Test
-    public void loadHtmlData_whenHtmlContainsHeadTag_shouldIncludeMraidJs() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        String htmlData = "<html><head></head></html>";
-        String expectedResult = "<html><head><script>" + MraidJavascript.JAVASCRIPT_SOURCE + "</script></head></html>";
-
-        mraidViewSpy.loadHtmlData(htmlData);
-
-        verify(mraidViewSpy).loadDataWithBaseURL(anyString(), eq(expectedResult), eq("text/html"), eq("UTF-8"), anyString());
-    }
-
-    @Test
-    public void loadHtmlData_whenMissingHtmlBoilerplate_shouldAddItAndIncludeMraidJs() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        String htmlData = "<a href='www.goat.com'>CLICK THIS LINK</a>";
-        String expectedResult = "<html><head><script>" + MraidJavascript.JAVASCRIPT_SOURCE + "</script></head>" +
-                "<body style='margin:0;padding:0;'><a href='www.goat.com'>CLICK THIS LINK</a></body></html>";
-
-        mraidViewSpy.loadHtmlData(htmlData);
-
-        verify(mraidViewSpy).loadDataWithBaseURL(anyString(), eq(expectedResult), eq("text/html"), eq("UTF-8"), anyString());
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forBanners_withUserClick_shouldOpenNewCalendarIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=hi&start=1";
-        Map<String, String> expectedParams = new HashMap<String, String>(2);
-        expectedParams.put("description", "hi");
-        expectedParams.put("start", "1");
-
-        bannerSubject.onUserClick();
-
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).createCalendarEvent(eq(expectedParams));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forInterstitials_withUserClick_shouldOpenNewCalendarIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=hi&start=1";
-        Map<String, String> expectedParams = new HashMap<String, String>(2);
-        expectedParams.put("description", "hi");
-        expectedParams.put("start", "1");
-
-        interstitialSubject.onUserClick();
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).createCalendarEvent(eq(expectedParams));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forBanners_withoutUserClick_shouldNotOpenNewIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=Mayan%20Apocalypse%2FEnd%20of%20World&start=2013-08-16T20%3A00-04%3A00&interval=1&frequency=daily";
-
-        assertThat(bannerSubject.wasClicked()).isFalse();
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController, never()).createCalendarEvent(any(Map.class));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forInterstitials_withoutUserClick_shouldNotOpenNewIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=Mayan%20Apocalypse%2FEnd%20of%20World&start=2013-08-16T20%3A00-04%3A00&interval=1&frequency=daily";
-
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController, never()).createCalendarEvent(any(Map.class));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandPlayVideo_forBanners_withOutUserClick_shouldNotOpenNewIntent() throws Exception {
-        String url = "mraid://playVideo?uri=something";
-
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController, never()).showVideo(anyString());
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandPlayVideo_forBanners_withUserClick_shouldOpenNewIntent() throws Exception {
-        String url = "mraid://playVideo?uri=something";
-
-        bannerSubject.onUserClick();
-
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).showVideo(eq("something"));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandPlayVideo_forInterstitials_shouldOpenNewIntent() throws Exception {
-        String url = "mraid://playVideo?uri=something";
-
-        assertThat(interstitialSubject.wasClicked()).isFalse();
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).showVideo(eq("something"));
-
-        reset(mraidDisplayController);
-        interstitialSubject.onUserClick();
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).showVideo(eq("something"));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRedirectUrl_withoutUserClick_shouldNotOpenNewIntentAndReturnFalse() throws Exception {
-        String url = "http://www.blah.com";
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNull();
-        assertThat(consumeUrlLoading).isFalse();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRedirectUrl_withUserClick_shouldOpenNewIntent() throws Exception {
-        String url = "http://www.blah.com";
-        bannerSubject.onUserClick();
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(consumeUrlLoading).isTrue();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRelativeUrl_andUserClick_shouldReturnTrue() throws Exception {
-        String relativeUrl = "www.blah.com";
-        bannerSubject.onUserClick();
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, relativeUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(consumeUrlLoading).isTrue();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRelativeUrl_andNoUserClick_shouldReturnFalse() throws Exception {
-        String relativeUrl = "www.blah.com";
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, relativeUrl);
-
-        assertThat(consumeUrlLoading).isFalse();
-    }
-
-    @Test
-    public void destroy_shouldRemoveSelfFromParent_beforeCallingDestroy() throws Exception {
-        ViewGroup parent = mock(ViewGroup.class);
-        ShadowWebView shadow = shadowOf(bannerSubject);
-        shadow.setMyParent(parent);
-
-        bannerSubject.destroy();
-
-        verify(parent).removeView(eq(bannerSubject));
-        assertThat(shadow.wasDestroyCalled()).isTrue();
-    }
-
-    private MraidViewableProperty captureAndVerifyViewablePropertyChangeEventFired(MraidView mraidView) {
-        ArgumentCaptor<MraidViewableProperty> mraidViewablePropertyCaptor = ArgumentCaptor.forClass(MraidViewableProperty.class);
-        verify(mraidView).fireChangeEventForProperty(mraidViewablePropertyCaptor.capture());
-        return mraidViewablePropertyCaptor.getValue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
new file mode 100644
index 00000000..3c51f6f7
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
@@ -0,0 +1,88 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class RepeatingHandlerRunnableTest {
+
+    @Mock Handler mockHandler;
+    RepeatingHandlerRunnable subject;
+
+    @Before
+    public void setup() {
+      subject = new NoopRepeatingHandlerRunnable(mockHandler);
+    }
+
+    @Test
+    public void startTracking_whenRunning_shouldScheduleSelf() {
+        subject.startRepeating(100);
+        reset(mockHandler);
+        subject.run();
+
+        verify(mockHandler).postDelayed(eq(subject), eq(100l));
+    }
+
+    @Test
+    public void start_whenRunning_shouldNotScheduleAndRunShouldScheduleWithNewInterval() {
+        subject.startRepeating(100l);
+        reset(mockHandler);
+
+        subject.startRepeating(200l);
+
+        verifyZeroInteractions(mockHandler);
+
+        subject.run();
+
+        verify(mockHandler).postDelayed(eq(subject), eq(200l));
+    }
+
+    @Test
+    public void run_whenNotRunning_shouldNotSchedule() {
+        subject.stop();
+        reset(mockHandler);
+
+        subject.run();
+
+        verifyZeroInteractions(mockHandler);
+    }
+
+    @Test
+    public void stopTracking_whenRunning_shouldPreventNextScheduling() {
+        subject.startRepeating(100l);
+        verify(mockHandler).post(eq(subject));
+
+        subject.run();
+        verify(mockHandler).postDelayed(eq(subject), eq(100l));
+
+        reset(mockHandler);
+        subject.stop();
+
+        subject.run();
+        verifyZeroInteractions(mockHandler);
+    }
+
+    private static class NoopRepeatingHandlerRunnable extends RepeatingHandlerRunnable {
+
+        NoopRepeatingHandlerRunnable(@NonNull final Handler handler) {
+            super(handler);
+        }
+
+        @Override
+        public void doWork() {
+            // pass
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java
deleted file mode 100644
index 604fed40..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class TaskTrackerTest {
-
-    private TaskTracker taskTracker;
-
-    @Before
-    public void setUp() throws Exception {
-        taskTracker = new TaskTracker();
-    }
-
-    @Test
-    public void newTaskStarted_shouldIncrementIdsFromNegativeOne() throws Exception {
-        assertThat(taskTracker.getCurrentTaskId()).isEqualTo(-1);
-
-        taskTracker.newTaskStarted();
-
-        assertThat(taskTracker.getCurrentTaskId()).isEqualTo(0);
-    }
-
-    @Test
-    public void isMostCurrentTask_onFirstTask_whenSecondTaskIsCompleted_shouldBeFalse() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(taskTracker.getCurrentTaskId());
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-    }
-
-    @Test
-    public void isMostCurrentTask_onFirstTask_whenSecondTaskIsNotCompleted_shouldBeTrue() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isTrue();
-    }
-
-    @Test
-    public void mostCurrentTaskIsLastCompletedTaskOrLater() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(1);
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-        assertThat(taskTracker.isMostCurrentTask(1)).isTrue();
-        assertThat(taskTracker.isMostCurrentTask(2)).isTrue();
-    }
-
-    @Test
-    public void markTaskCompleted_shouldKeepTrackOfMostCurrentTaskRegardlessOfCompletionOrder() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(1);
-        taskTracker.markTaskCompleted(0);
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-        assertThat(taskTracker.isMostCurrentTask(1)).isTrue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java
new file mode 100644
index 00000000..0b20146d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java
@@ -0,0 +1,172 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastAdXmlManagerTest {
+
+    private VastAdXmlManager subject;
+
+    @Test
+    public void getInLineXmlManager_shouldReturnInLineXmlManager() throws Exception {
+        String adXml = "<Ad id=\"223626102\">" +
+                "    <InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inline]]>" +
+                "          </Impression>" +
+                "    </InLine>" +
+                "    <Wrapper>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/wrapper]]>" +
+                "          </Impression>" +
+                "    </Wrapper>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        VastInLineXmlManager vastInLineXmlManager = subject.getInLineXmlManager();
+        assertThat(VastUtils.vastTrackersToStrings(vastInLineXmlManager.getImpressionTrackers()))
+                .containsOnly("http://impression/m/inline");
+    }
+
+    @Test
+    public void getInLineXmlManager_withMultipleInLineNodes_shouldReturnFirstInLineXmlManager() throws Exception {
+        String adXml = "<Ad id=\"223626102\">" +
+                "    <InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "    </InLine>" +
+                "    <InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "    </InLine>" +
+                "    <Wrapper>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/wrapper]]>" +
+                "          </Impression>" +
+                "    </Wrapper>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        VastInLineXmlManager vastInLineXmlManager = subject.getInLineXmlManager();
+        assertThat(VastUtils.vastTrackersToStrings(vastInLineXmlManager.getImpressionTrackers()))
+                .containsOnly("http://impression/m/inlineOne");
+    }
+
+    @Test
+    public void getInLineXmlManager_withNoInLineNodes_shouldReturnNull() throws Exception {
+        String adXml = "<Ad id=\"223626102\">" +
+                "    <Wrapper>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/wrapper]]>" +
+                "          </Impression>" +
+                "    </Wrapper>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        assertThat(subject.getInLineXmlManager()).isNull();
+    }
+
+    @Test
+    public void getWrapperXmlManager_shouldReturnWrapperXmlManager() throws Exception {
+        String adXml = "<Ad id=\"223626102\">" +
+                "    <InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inline]]>" +
+                "          </Impression>" +
+                "    </InLine>" +
+                "    <Wrapper>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/wrapper]]>" +
+                "          </Impression>" +
+                "    </Wrapper>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        VastWrapperXmlManager vastWrapperXmlManager = subject.getWrapperXmlManager();
+        assertThat(VastUtils.vastTrackersToStrings(vastWrapperXmlManager.getImpressionTrackers()))
+                .containsOnly("http://impression/m/wrapper");
+    }
+
+    @Test
+    public void getWrapperXmlManager_withMultipleWrapperNodes_shouldReturnFirstWrapperXmlManager() throws Exception {
+        String adXml = "<Ad id=\"223626102\">" +
+                "    <InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "    </InLine>" +
+                "    <Wrapper>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/wrapperOne]]>" +
+                "          </Impression>" +
+                "    </Wrapper>" +
+                "    <Wrapper>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/wrapperTwo]]>" +
+                "          </Impression>" +
+                "    </Wrapper>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        VastWrapperXmlManager vastWrapperXmlManager = subject.getWrapperXmlManager();
+        assertThat(VastUtils.vastTrackersToStrings(vastWrapperXmlManager.getImpressionTrackers()))
+                .containsOnly("http://impression/m/wrapperOne");
+    }
+
+    @Test
+    public void getWrapperXmlManager_withNoWrapperNodes_shouldReturnNull() throws Exception {
+        String adXml = "<Ad id=\"223626102\">" +
+                "    <InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inline]]>" +
+                "          </Impression>" +
+                "    </InLine>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        assertThat(subject.getWrapperXmlManager()).isNull();
+    }
+
+    @Test
+    public void getSequence_shouldReturnSequence() throws Exception {
+        String adXml = "<Ad id=\"223626102\" sequence=\"42\">" +
+                "    <InLine>" +
+                "        <Impression id=\"DART\">" +
+                "            <![CDATA[http://impression/m/inline]]>" +
+                "        </Impression>" +
+                "    </InLine>" +
+                "    <Wrapper>" +
+                "        <Impression id=\"DART\">" +
+                "            <![CDATA[http://impression/m/wrapper]]>" +
+                "        </Impression>" +
+                "    </Wrapper>" +
+                "</Ad>";
+
+        Node adNode = createNode(adXml);
+        subject = new VastAdXmlManager(adNode);
+
+        assertThat(subject.getSequence()).isEqualTo("42");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java
new file mode 100644
index 00000000..143b211a
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java
@@ -0,0 +1,334 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import java.util.List;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastBaseInLineWrapperXmlManagerTest {
+
+    private VastBaseInLineWrapperXmlManager subject;
+
+    @Test
+    public void getImpressionTrackers_shouldReturnImpressionTrackers() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "          <Creatives>" +
+                "                 <Creative>" +
+                "                       <Linear>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/close]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </Linear>" +
+                "                 </Creative>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(VastUtils.vastTrackersToStrings(subject.getImpressionTrackers()))
+                .containsOnly("http://impression/m/inlineOne", "http://impression/m/inlineTwo");
+    }
+
+    @Test
+    public void getImpressionTrackers_withNoImpressionTrackers_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getImpressionTrackers()).isEmpty();
+    }
+
+    @Test
+    public void getLinearXmlManagers_shouldReturnLinearXmlManagers() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "          <Creatives>" +
+                "                 <Creative>" +
+                "                       <Linear>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/closeOne]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </Linear>" +
+                "                       <!-- There should only be a single Linear, CompanionAds, or NonLinearAds element per Creative -->" +
+                "                       <Linear>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/ignored]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </Linear>" +
+                "                 </Creative>" +
+                "                 <Creative>" +
+                "                       <NonLinearAds>" +
+                "                       </NonLinearAds>" +
+                "                 </Creative>" +
+                "                 <Creative>" +
+                "                       <Linear>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/closeTwo]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </Linear>" +
+                "                 </Creative>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        List<VastLinearXmlManager> linearXmlManagers = subject.getLinearXmlManagers();
+        assertThat(linearXmlManagers).hasSize(2);
+        assertThat(VastUtils.vastTrackersToStrings(linearXmlManagers.get(0).getVideoCloseTrackers()))
+                .containsOnly("http://tracking/m/closeOne");
+        assertThat(VastUtils.vastTrackersToStrings(linearXmlManagers.get(1).getVideoCloseTrackers()))
+                .containsOnly("http://tracking/m/closeTwo");
+    }
+
+    @Test
+    public void getLinearXmlManagers_withNoLinearNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "          <Creatives>" +
+                "                 <Creative>" +
+                "                       <NonLinearAds>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/close]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </NonLinearAds>" +
+                "                 </Creative>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getLinearXmlManagers_withNoCreativeNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "          <Creatives>" +
+                "                       <Linear>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/closeTwo]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </Linear>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getLinearXmlManagers_withNoCreativesNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "                 <Creative>" +
+                "                       <Linear>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/closeTwo]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </Linear>" +
+                "                 </Creative>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getCompanionAdXmlManagers_shouldReturnCompanionAdXmlManagers() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineOne]]>" +
+                "          </Impression>" +
+                "          <Impression id=\"DART\">" +
+                "                 <![CDATA[http://impression/m/inlineTwo]]>" +
+                "          </Impression>" +
+                "          <Creatives>" +
+                "                 <Creative>" +
+                "                       <NonLinearAds>" +
+                "                           <TrackingEvents>" +
+                "                               <Tracking event=\"close\">" +
+                "                                   <![CDATA[http://tracking/m/closeOne]]>" +
+                "                               </Tracking>" +
+                "                           </TrackingEvents>" +
+                "                       </NonLinearAds>" +
+                "                 </Creative>" +
+                "                 <Creative>" +
+                "                     <CompanionAds>" +
+                "                         <Companion>" +
+                "                             <TrackingEvents>" +
+                "                                 <Tracking event=\"creativeView\">" +
+                "                                     <![CDATA[http://tracking/m/closeTwo]]>" +
+                "                                 </Tracking>" +
+                "                             </TrackingEvents>" +
+                "                             <CompanionClickTracking>" +
+                "                                 <![CDATA[http://clicktrackingOne]]>" +
+                "                             </CompanionClickTracking>" +
+                "                         </Companion>"+
+                "                         <Companion>" +
+                "                             <CompanionClickTracking>" +
+                "                                 <![CDATA[http://clicktrackingTwo]]>" +
+                "                             </CompanionClickTracking>" +
+                "                             <TrackingEvents>" +
+                "                                 <Tracking event=\"creativeView\">" +
+                "                                     <![CDATA[http://tracking/m/closeThree]]>" +
+                "                                 </Tracking>" +
+                "                             </TrackingEvents>" +
+                "                         </Companion>"+
+                "                     </CompanionAds>" +
+                "                 </Creative>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getCompanionAdXmlManagers()).hasSize(2);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getCompanionAdXmlManagers().get(0).getClickTrackers()))
+                .containsOnly("http://clicktrackingOne");
+        assertThat(VastUtils.vastTrackersToStrings(subject.getCompanionAdXmlManagers().get(1).getClickTrackers()))
+                .containsOnly("http://clicktrackingTwo");
+    }
+
+    @Test
+    public void getCompanionAdXmlManagers_withNoCompanionNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Creatives>" +
+                "                 <Creative>" +
+                "                     <CompanionAds>" +
+                "                         <NotACompanion>" +
+                "                         </NotACompanion>"+
+                "                     </CompanionAds>" +
+                "                 </Creative>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getCompanionAdXmlManagers_withNoCompanionAdsNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Creatives>" +
+                "                 <Creative>" +
+                "                         <Companion>" +
+                "                             <TrackingEvents>" +
+                "                                 <Tracking event=\"creativeView\">" +
+                "                                     <![CDATA[http://tracking/m/closeThree]]>" +
+                "                                 </Tracking>" +
+                "                             </TrackingEvents>" +
+                "                         </Companion>"+
+                "                 </Creative>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getCompanionAdXmlManagers_withNoCreativeNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "          <Creatives>" +
+                "                     <CompanionAds>" +
+                "                         <Companion>" +
+                "                             <TrackingEvents>" +
+                "                                 <Tracking event=\"creativeView\">" +
+                "                                     <![CDATA[http://tracking/m/closeThree]]>" +
+                "                                 </Tracking>" +
+                "                             </TrackingEvents>" +
+                "                         </Companion>"+
+                "                     </CompanionAds>" +
+                "          </Creatives>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getCompanionAdXmlManagers_withNoCreativesNodes_shouldReturnEmptyList() throws Exception {
+        String inLineXml = "<InLine>" +
+                "                 <Creative>" +
+                "                     <CompanionAds>" +
+                "                         <Companion>" +
+                "                             <TrackingEvents>" +
+                "                                 <Tracking event=\"creativeView\">" +
+                "                                     <![CDATA[http://tracking/m/closeThree]]>" +
+                "                                 </Tracking>" +
+                "                             </TrackingEvents>" +
+                "                         </Companion>"+
+                "                     </CompanionAds>" +
+                "                 </Creative>" +
+                "</InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getLinearXmlManagers()).isEmpty();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java
new file mode 100644
index 00000000..ffbe32f0
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java
@@ -0,0 +1,94 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class VastCompanionAdConfigTest {
+
+    private static final String RESOLVED_CLICKTHROUGH_URL = "http://www.mopub.com/";
+    private static final String CLICKTHROUGH_URL = "deeplink+://navigate?" +
+            "&primaryUrl=bogus%3A%2F%2Furl" +
+            "&fallbackUrl=" + Uri.encode(RESOLVED_CLICKTHROUGH_URL);
+
+    private VastCompanionAdConfig subject;
+    private Context context;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setup() {
+        subject = new VastCompanionAdConfig(123, 456,
+                new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                        .CreativeType.IMAGE, 123, 456),
+                CLICKTHROUGH_URL,
+                VastUtils.stringsToVastTrackers("clickTrackerOne", "clickTrackerTwo"),
+                VastUtils.stringsToVastTrackers("viewTrackerOne", "viewTrackerTwo")
+        );
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void constructor_shouldSetParamsCorrectly() throws Exception {
+        assertThat(subject.getWidth()).isEqualTo(123);
+        assertThat(subject.getHeight()).isEqualTo(456);
+        assertThat(subject.getVastResource().getResource()).isEqualTo("resource");
+        assertThat(subject.getVastResource().getType()).isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(subject.getVastResource().getCreativeType())
+                .isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(subject.getClickThroughUrl()).isEqualTo(CLICKTHROUGH_URL);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getClickTrackers()))
+                .containsOnly("clickTrackerOne", "clickTrackerTwo");
+        assertThat(VastUtils.vastTrackersToStrings(subject.getCreativeViewTrackers()))
+                .containsOnly("viewTrackerOne", "viewTrackerTwo");
+    }
+
+    @Test
+    public void handleImpression_shouldTrackImpression() throws Exception {
+        subject.handleImpression(context, 123);
+
+        verify(mockRequestQueue).add(argThat(isUrl("viewTrackerOne")));
+        verify(mockRequestQueue).add(argThat(isUrl("viewTrackerTwo")));
+    }
+
+    @Test
+    public void handleClick_shouldNotTrackClick() throws Exception {
+        subject.handleClick(context, 1, null);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+
+    @Test
+    public void handleClick_shouldOpenMoPubBrowser() throws Exception {
+        subject.handleClick(context, 1, null);
+
+        Robolectric.runBackgroundTasks();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
+                .isEqualTo(RESOLVED_CLICKTHROUGH_URL);
+        assertThat(startedActivity.getData()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java
new file mode 100644
index 00000000..a199dbf9
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java
@@ -0,0 +1,94 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastCompanionAdConfigXmlManagerTest {
+
+    private VastCompanionAdXmlManager subject;
+    private Node companionNode;
+
+    @Before
+    public void setup() throws Exception {
+        String companionXml = "<Companion id=\"valid\" height=\"250\" width=\"300\">" +
+                "    <StaticResource creativeType=\"image/png\">http://pngimage</StaticResource>" +
+                "    <TrackingEvents>" +
+                "        <Tracking event=\"creativeView\">http://tracking/creativeView1</Tracking>" +
+                "        <Tracking event=\"creativeView\">http://tracking/creativeView2</Tracking>" +
+                "        <Tracking event=\"creativeView\">http://tracking/creativeView3</Tracking>" +
+                "    </TrackingEvents>" +
+                "    <CompanionClickThrough>http://clickthrough</CompanionClickThrough>" +
+                "    <CompanionClickThrough>http://second_clickthrough</CompanionClickThrough>" +
+                "    <CompanionClickTracking>" +
+                "        <![CDATA[http://clicktrackingOne]]>" +
+                "    </CompanionClickTracking>" +
+                "    <CompanionClickTracking>" +
+                "        <![CDATA[http://clicktrackingTwo]]>" +
+                "    </CompanionClickTracking>" +
+                "    <RandomUnusedTag>This_is_unused</RandomUnusedTag>" +
+                "</Companion>";
+
+        companionNode = createNode(companionXml);
+        subject = new VastCompanionAdXmlManager(companionNode);
+    }
+
+    @Test
+    public void getWidth_shouldReturnWidthAttributes() {
+        assertThat(subject.getWidth()).isEqualTo(300);
+    }
+
+    @Test
+    public void getWidth_withNoWidthAttribute_shouldReturnNull() throws Exception {
+        String companionXml = "<Companion id=\"valid\" height=\"250\">" +
+                "</Companion>";
+
+        companionNode = createNode(companionXml);
+        subject = new VastCompanionAdXmlManager(companionNode);
+
+        assertThat(subject.getWidth()).isNull();
+    }
+
+    @Test
+    public void getHeight_shouldReturnHeightAttributes() {
+        assertThat(subject.getHeight()).isEqualTo(250);
+    }
+
+    @Test
+    public void getHeight_withNoHeightAttribute_shouldReturnNull() throws Exception {
+        String companionXml = "<Companion id=\"valid\" width=\"300\">" +
+                "</Companion>";
+
+        companionNode = createNode(companionXml);
+        subject = new VastCompanionAdXmlManager(companionNode);
+
+        assertThat(subject.getHeight()).isNull();
+    }
+
+    @Test
+    public void getResourceXmlManager_shouldReturnVastResourceXmlManager() throws Exception {
+        VastResourceXmlManager resourceXmlManager = subject.getResourceXmlManager();
+        assertThat(resourceXmlManager.getStaticResource()).isEqualTo("http://pngimage");
+        assertThat(resourceXmlManager.getStaticResourceType()).isEqualTo("image/png");
+    }
+
+    @Test
+    public void getClickThroughUrl_shouldReturnFirstStringUrl() {
+        assertThat(subject.getClickThroughUrl()).isEqualTo("http://clickthrough");
+    }
+
+    @Test
+    public void getClickTrackers_shouldReturnAllUrls() {
+        assertThat(VastUtils.vastTrackersToStrings(subject.getClickTrackers()))
+                .containsOnly("http://clicktrackingOne",
+                        "http://clicktrackingTwo");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java
new file mode 100644
index 00000000..7833472d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java
@@ -0,0 +1,103 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class VastIconConfigTest {
+
+    private VastIconConfig subject;
+    private Context context;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setup() {
+        subject = new VastIconConfig(123, 456, 789, 101,
+                new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                        .CreativeType.IMAGE, 123, 456),
+                VastUtils.stringsToVastTrackers("clickTrackerOne", "clickTrackerTwo"),
+                "http://www.mopub.com/",
+                VastUtils.stringsToVastTrackers("viewTrackerOne", "viewTrackerTwo")
+        );
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void constructor_shouldSetParamsCorrectly() throws Exception {
+        assertThat(subject.getWidth()).isEqualTo(123);
+        assertThat(subject.getHeight()).isEqualTo(456);
+        assertThat(subject.getOffsetMS()).isEqualTo(789);
+        assertThat(subject.getDurationMS()).isEqualTo(101);
+        assertThat(subject.getVastResource().getResource()).isEqualTo("resource");
+        assertThat(subject.getVastResource().getType()).isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(subject.getVastResource().getCreativeType())
+                .isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getClickTrackingUris()))
+                .containsOnly("clickTrackerOne", "clickTrackerTwo");
+        assertThat(subject.getClickThroughUri()).isEqualTo("http://www.mopub.com/");
+        assertThat(VastUtils.vastTrackersToStrings(subject.getViewTrackingUris()))
+                .containsOnly("viewTrackerOne", "viewTrackerTwo");
+    }
+
+    @Test
+    public void constructor_withNullOffset_shouldSetOffsetTo0() throws Exception {
+        subject = new VastIconConfig(123, 456, null, 101,
+                new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                        .CreativeType.IMAGE, 123, 456),
+                VastUtils.stringsToVastTrackers("clickTrackerOne", "clickTrackerTwo"),
+                "clickThroughUri",
+                VastUtils.stringsToVastTrackers("viewTrackerOne", "viewTrackerTwo")
+        );
+
+        assertThat(subject.getOffsetMS()).isEqualTo(0);
+    }
+
+    @Test
+    public void handleImpression_shouldTrackImpression() throws Exception {
+        subject.handleImpression(context, 123, "uri");
+
+        verify(mockRequestQueue).add(argThat(isUrl("viewTrackerOne")));
+        verify(mockRequestQueue).add(argThat(isUrl("viewTrackerTwo")));
+    }
+
+    @Test
+    public void handleClick_shouldNotTrackClick() throws Exception {
+        subject.handleClick(context, null);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+
+    @Test
+    public void handleClick_shouldOpenMoPubBrowser() throws Exception {
+        subject.handleClick(context, null);
+
+        Robolectric.runBackgroundTasks();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
+                .isEqualTo("http://www.mopub.com/");
+        assertThat(startedActivity.getData()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java
new file mode 100644
index 00000000..e0e501ab
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java
@@ -0,0 +1,214 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastIconConfigXmlManagerTest {
+
+    private VastIconXmlManager subject;
+    private Node iconNode;
+
+    @Before
+    public void setup() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"01:02:03.456\">" +
+                    "<StaticResource creativeType=\"ImAge/JpEg\">" +
+                        "<![CDATA[imageJpeg]]>" +
+                    "</StaticResource>" +
+                    "<IconClicks>" +
+                        "<IconClickThrough>" +
+                            "<![CDATA[clickThroughUri]]>" +
+                        "</IconClickThrough>" +
+                        "<IconClickTracking>" +
+                            "<![CDATA[clickTrackingUri1]]>" +
+                        "</IconClickTracking>" +
+                        "<IconClickTracking>" +
+                            "<![CDATA[clickTrackingUri2]]>" +
+                        "</IconClickTracking>" +
+                    "</IconClicks>" +
+                    "<IconViewTracking>" +
+                        "<![CDATA[viewTrackingUri1]]>" +
+                    "</IconViewTracking>" +
+                    "<IconViewTracking>" +
+                        "<![CDATA[viewTrackingUri2]]>" +
+                    "</IconViewTracking>" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+    }
+
+    @Test
+    public void getWidth_shouldReturnWidth() throws Exception {
+        assertThat(subject.getWidth()).isEqualTo(123);
+    }
+
+    @Test
+    public void getWidth_withNoWidth_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"01:02:03.456\">" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getWidth()).isNull();
+    }
+
+    @Test
+    public void getHeight_shouldReturnHeight() throws Exception {
+        assertThat(subject.getHeight()).isEqualTo(456);
+    }
+
+    @Test
+    public void getHeight_withNoHeight_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"01:02:03.456\">" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getHeight()).isNull();
+    }
+
+    @Test
+    public void getOffsetMS_shouldReturnOffset() throws Exception {
+        assertThat(subject.getOffsetMS()).isEqualTo(3723000);
+    }
+
+    @Test
+    public void getOffsetMS_withNoOffset_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" " +
+                "duration=\"01:02:03.456\">" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getOffsetMS()).isNull();
+    }
+
+    @Test
+    public void getOffsetMS_withMalformedOffset_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"malformed\" " +
+                "duration=\"01:02:03.456\">" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getOffsetMS()).isNull();
+    }
+
+    @Test
+    public void getDurationMS_shouldReturnDuration() throws Exception {
+        assertThat(subject.getDurationMS()).isEqualTo(3723456);
+    }
+
+    @Test
+    public void getDurationMS_withNoDuration_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" >" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getDurationMS()).isNull();
+    }
+
+    @Test
+    public void getDurationMS_withMalformedDuration_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"malformed\">" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getDurationMS()).isNull();
+    }
+
+    @Test
+    public void getResourceXmlManager_shouldReturnVastResourceXmlManager() throws Exception {
+        VastResourceXmlManager resourceXmlManager = subject.getResourceXmlManager();
+        assertThat(resourceXmlManager.getStaticResource()).isEqualTo("imageJpeg");
+        assertThat(resourceXmlManager.getStaticResourceType()).isEqualTo("image/jpeg");
+    }
+
+    @Test
+    public void getClickTrackingUris_shouldReturnClickTrackingUris() throws Exception {
+        assertThat(VastUtils.vastTrackersToStrings(subject.getClickTrackingUris()))
+                .containsOnly("clickTrackingUri1", "clickTrackingUri2");
+    }
+
+    @Test
+    public void getClickTrackingUris_withNoClickTrackingUris_shouldReturnEmptyList() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"01:02:03.456\">" +
+                    "<IconClicks>" +
+                        "<IconClickThrough>" +
+                            "<![CDATA[clickThroughUri]]>" +
+                        "</IconClickThrough>" +
+                    "</IconClicks>" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getClickTrackingUris()).isEmpty();
+    }
+
+    @Test
+    public void getClickThroughUri_shouldReturnClickThroughUri() throws Exception {
+        assertThat(subject.getClickThroughUri()).isEqualTo("clickThroughUri");
+    }
+
+    @Test
+    public void getClickThroughUri_withNoClickThroughUri_shouldReturnNull() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"01:02:03.456\">" +
+                "<IconClicks>" +
+                    "<IconClickTracking>" +
+                        "<![CDATA[clickTrackingUri1]]>" +
+                    "</IconClickTracking>" +
+                    "<IconClickTracking>" +
+                        "<![CDATA[clickTrackingUri2]]>" +
+                    "</IconClickTracking>" +
+                "</IconClicks>" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getClickThroughUri()).isNull();
+    }
+
+    @Test
+    public void getViewTrackingUris_shouldReturnViewTrackingUris() throws Exception {
+        assertThat(VastUtils.vastTrackersToStrings(subject.getViewTrackingUris()))
+                .containsOnly("viewTrackingUri1", "viewTrackingUri2");
+    }
+
+    @Test
+    public void getViewTrackingUris_withNoViewTrackingUris_shouldReturnEmptyList() throws Exception {
+        String iconXml = "<Icon program=\"program\" width=\"123\" height=\"456\" xPosition=\"789\" " +
+                "yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "duration=\"01:02:03.456\">" +
+                "</Icon>";
+
+        iconNode = createNode(iconXml);
+        subject = new VastIconXmlManager(iconNode);
+        assertThat(subject.getViewTrackingUris()).isEmpty();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
new file mode 100644
index 00000000..57d5625e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
@@ -0,0 +1,474 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import java.util.List;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastLinearXmlManagerTest {
+
+    private VastLinearXmlManager subject;
+    private Node linearNode;
+
+    @Before
+    public void setup() throws Exception {
+        String linearXml = "<Linear skipoffset=\"25%\">" +
+                "<Duration>00:00:58</Duration>" +
+                "<TrackingEvents>" +
+                "    <Tracking event=\"creativeView\">" +
+                "        <![CDATA[" +
+                "        http://creativeView/one" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"creativeView\">" +
+                "        <![CDATA[" +
+                "        http://creativeView/two" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"start\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"progress\" offset=\"13%\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"progress\" offset=\"01:01:10.300\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                // Invalid tracking due to ambiguous offset.
+                "    <Tracking event=\"progress\" offset=\"01:01\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                // Invalid tracking due to a too-high percentage offset.
+                "    <Tracking event=\"progress\" offset=\"113%\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                // Invalid tracking due to a negative percentage offset.
+                "    <Tracking event=\"progress\" offset=\"-113%\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                // Invalid tracking due to a non-number offset
+                "    <Tracking event=\"progress\" offset=\"ten seconds\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"midpoint\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"midpoint\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"firstQuartile\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"firstQuartile\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"thirdQuartile\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"thirdQuartile\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"complete\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"complete\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"close\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/close?q=ignatius" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"close\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/close?q=j3" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"closeLinear\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/closeLinear" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"skip\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/skip?q=ignatius" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"skip\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/skip?q=j3" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"mute\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=16;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"pause\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/pause?num=1" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"pause\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/pause?num=2" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"resume\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/resume?num=1" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"resume\">" +
+                "        <![CDATA[" +
+                "        http://www.mopub.com/resume?num=2" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"fullscreen\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=19;ecn1=1;etm1=0;" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "    <Tracking event=\"fullscreen\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.6;sz=1x1;ord=2922389?" +
+                "        ]]>" +
+                "    </Tracking>" +
+                "</TrackingEvents>" +
+                "<AdParameters/>" +
+                "<VideoClicks>" +
+                "    <ClickThrough>" +
+                "        <![CDATA[ http://www.google.com/support/richmedia ]]>" +
+                "    </ClickThrough>" +
+                "    <ClickTracking id=\"DART\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/click%3Bh%3Dv8/3e1b/3/0/%2a/z%3B223626102%3B0-0%3B0%3B47414672%3B255-0/0%3B30477563/30495440/1%3B%3B%7Eaopt%3D0/0/ff/0%3B%7Esscs%3D%3fhttp://s0.2mdn.net/dot.gif" +
+                "        ]]>" +
+                "    </ClickTracking>" +
+                "    <ClickTracking id=\"ThirdParty\">" +
+                "        <![CDATA[" +
+                "        http://ad.doubleclick.net/clk;212442087;33815766;i?http://www.google.com/support/richmedia" +
+                "        ]]>" +
+                "    </ClickTracking>" +
+                "</VideoClicks>" +
+                "<MediaFiles>" +
+                "    <MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" bitrate=\"457\"" +
+                "               width=\"300\" height=\"225\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
+                "        ]]>" +
+                "    </MediaFile>" +
+                "    <MediaFile id=\"2\" delivery=\"progressive\" type=\"video/quicktime\" bitrate=\"457\"" +
+                "               width=\"300\" height=\"225\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny_2.mp4" +
+                "        ]]>" +
+                "    </MediaFile>" +
+                "</MediaFiles>" +
+                "<Icons>" +
+                "    <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
+                "    yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "    duration=\"01:02:03.456\">" +
+                "        <StaticResource creativeType=\"ImAge/JpEg\">" +
+                "           <![CDATA[staticResource1]]>" +
+                "        </StaticResource>" +
+                "    </Icon>" +
+                "    <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
+                "    yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "    duration=\"01:02:03.456\">" +
+                "        <StaticResource creativeType=\"ImAge/JpEg\">" +
+                "           <![CDATA[staticResource2]]>" +
+                "        </StaticResource>" +
+                "    </Icon>" +
+                "</Icons>" +
+                "</Linear>";
+
+        linearNode = createNode(linearXml);
+    }
+
+    @Test
+    public void getFractionalTrackers_shouldReturnCorrectValues() {
+        subject = new VastLinearXmlManager(linearNode);
+        List<VastFractionalProgressTracker> trackers = subject.getFractionalProgressTrackers();
+
+        assertThat(trackers.size()).isEqualTo(7);
+
+        VastFractionalProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.trackingFraction()).isEqualTo(0.13f);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker2 = trackers.get(2);
+        assertThat(tracker2.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker2.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
+
+        VastFractionalProgressTracker tracker3 = trackers.get(3);
+        assertThat(tracker3.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker3.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker4 = trackers.get(4);
+        assertThat(tracker4.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker4.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+
+        VastFractionalProgressTracker tracker5 = trackers.get(5);
+        assertThat(tracker5.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker5.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker6 = trackers.get(6);
+        assertThat(tracker6.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker6.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
+    }
+
+    @Test
+    public void getAbsoluteProgressTrackers_shouldReturnCorrectValues() {
+        subject = new VastLinearXmlManager(linearNode);
+        List<VastAbsoluteProgressTracker> trackers = subject.getAbsoluteProgressTrackers();
+
+        assertThat(trackers.size()).isEqualTo(4);
+
+        VastAbsoluteProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.getTrackingMilliseconds()).isEqualTo(0);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://creativeView/one");
+
+        VastAbsoluteProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.getTrackingMilliseconds()).isEqualTo(0);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://creativeView/two");
+
+        VastAbsoluteProgressTracker tracker2 = trackers.get(2);
+        assertThat(tracker2.getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(tracker2.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+
+        VastAbsoluteProgressTracker tracker3 = trackers.get(3);
+        assertThat(tracker3.getTrackingMilliseconds()).isEqualTo(3670300);
+        assertThat(tracker3.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;" +
+                "src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;" +
+                "rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+    }
+
+    @Test
+    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
+        subject = new VastLinearXmlManager(linearNode);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getVideoCompleteTrackers()))
+                .containsOnly("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;",
+                        "http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
+    }
+
+    @Test
+    public void getVideoCloseTrackers_shouldReturnTheCorrectValue() {
+        subject = new VastLinearXmlManager(linearNode);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getVideoCloseTrackers()))
+                .containsOnly("http://www.mopub.com/close?q=ignatius",
+                        "http://www.mopub.com/close?q=j3",
+                        "http://www.mopub.com/closeLinear");
+    }
+
+    @Test
+    public void getPauseTrackers_shouldReturnRepeatableVastTrackers() {
+        subject = new VastLinearXmlManager(linearNode);
+        for (VastTracker vastTracker : subject.getPauseTrackers()) {
+            assertThat(vastTracker.isRepeatable());
+        }
+        assertThat(VastUtils.vastTrackersToStrings(subject.getPauseTrackers()))
+                .containsOnly("http://www.mopub.com/pause?num=1",
+                        "http://www.mopub.com/pause?num=2");
+    }
+
+    @Test
+    public void getResumeTrackers_shouldReturnRepeatableVastTrackers() {
+        subject = new VastLinearXmlManager(linearNode);
+        for (VastTracker vastTracker : subject.getResumeTrackers()) {
+            assertThat(vastTracker.isRepeatable());
+        }
+        assertThat(VastUtils.vastTrackersToStrings(subject.getResumeTrackers()))
+                .containsOnly("http://www.mopub.com/resume?num=1",
+                        "http://www.mopub.com/resume?num=2");
+    }
+
+    @Test
+    public void getVideoSkipTrackers_shouldReturnTheCorrectValue() {
+        subject = new VastLinearXmlManager(linearNode);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getVideoSkipTrackers()))
+                .containsOnly("http://www.mopub.com/skip?q=ignatius",
+                        "http://www.mopub.com/skip?q=j3");
+    }
+
+    @Test
+    public void getClickThroughUrl_shouldReturnTheCorrectValue() {
+        subject = new VastLinearXmlManager(linearNode);
+        String url = subject.getClickThroughUrl();
+
+        assertThat(url).isEqualTo("http://www.google.com/support/richmedia");
+    }
+
+    @Test
+    public void getClickTrackers_shouldReturnTheCorrectValue() {
+        subject = new VastLinearXmlManager(linearNode);
+        assertThat(VastUtils.vastTrackersToStrings(subject.getClickTrackers()))
+                .containsOnly("http://ad.doubleclick" +
+                                ".net/click%3Bh%3Dv8/3e1b/3/0/%2a/z%3B223626102%3B0-0%3B0" +
+                                "%3B47414672%3B255-0/0%3B30477563/30495440/1%3B%3B%7Eaopt%3D0/0" +
+                                "/ff/0%3B%7Esscs%3D%3fhttp://s0.2mdn.net/dot.gif",
+                        "http://ad.doubleclick.net/clk;212442087;33815766;i?http://www.google" +
+                                ".com/support/richmedia");
+    }
+
+    @Test
+    public void getSkipOffset_shouldReturnTheCorrectValue() {
+        subject = new VastLinearXmlManager(linearNode);
+        String skipOffset = subject.getSkipOffset();
+
+        assertThat(skipOffset).isEqualTo("25%");
+    }
+
+    @Test
+    public void getSkipOffset_withNoSkipOffsetAttribute_shouldReturnNull() throws Exception {
+        String linearXml = "<Linear>" +
+                "</Linear>";
+
+        Node linearNode = createNode(linearXml);
+        subject = new VastLinearXmlManager(linearNode);
+
+        assertThat(subject.getSkipOffset()).isNull();
+    }
+
+    @Test
+    public void getSkipOffset_withNoSkipOffsetAttributeValue_shouldReturnNull() throws Exception {
+        String linearXml = "<Linear skipoffset=\"\">" +
+                "</Linear>";
+
+        Node linearNode = createNode(linearXml);
+        subject = new VastLinearXmlManager(linearNode);
+
+        assertThat(subject.getSkipOffset()).isNull();
+    }
+
+    @Test
+    public void getMediaXmlManagers_shouldReturnMediaXmlManagers() {
+        subject = new VastLinearXmlManager(linearNode);
+        List<VastMediaXmlManager> mediaXmlManagers = subject.getMediaXmlManagers();
+
+        assertThat(mediaXmlManagers.size()).isEqualTo(2);
+
+        assertThat(mediaXmlManagers.get(0).getMediaUrl()).isEqualTo("http://s3.amazonaws" +
+                ".com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
+        assertThat(mediaXmlManagers.get(1).getMediaUrl()).isEqualTo("http://s3.amazonaws" +
+                ".com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny_2.mp4");
+    }
+
+    @Test
+    public void getMediaXmlManagers_withNoMediaFileNode_shouldReturnEmptyList() throws Exception {
+        String linearXml = "<Linear skipoffset=\"25%\">" +
+                "    <MediaFiles>" +
+                "    </MediaFiles>" +
+                "</Linear>";
+
+        Node linearNode = createNode(linearXml);
+        subject = new VastLinearXmlManager(linearNode);
+
+        List<VastMediaXmlManager> mediaXmlManagers = subject.getMediaXmlManagers();
+        assertThat(mediaXmlManagers).isEmpty();
+    }
+
+    @Test
+    public void getMediaXmlManagers_withNoMediaFilesNode_shouldReturnEmptyList() throws Exception {
+        String linearXml = "<Linear skipoffset=\"25%\">" +
+                "    <MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" bitrate=\"457\"" +
+                "               width=\"300\" height=\"225\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
+                "        ]]>" +
+                "    </MediaFile>" +
+                "</Linear>";
+
+        Node linearNode = createNode(linearXml);
+        subject = new VastLinearXmlManager(linearNode);
+
+        List<VastMediaXmlManager> mediaXmlManagers = subject.getMediaXmlManagers();
+        assertThat(mediaXmlManagers).isEmpty();
+    }
+
+    @Test
+    public void getIconXmlManagers_shouldReturnIconXmlManagers() throws Exception {
+        subject = new VastLinearXmlManager(linearNode);
+        List<VastIconXmlManager> iconXmlManagers = subject.getIconXmlManagers();
+
+        assertThat(iconXmlManagers).hasSize(2);
+        assertThat(iconXmlManagers.get(0).getResourceXmlManager().getStaticResource())
+                .isEqualTo("staticResource1");
+        assertThat(iconXmlManagers.get(1).getResourceXmlManager().getStaticResource())
+                .isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getIconXmlManagers_withNoIconNode_shouldReturnEmptyList() throws Exception {
+        String linearXml = "<Linear skipoffset=\"25%\">" +
+                "    <Icons>" +
+                "    </Icons>" +
+                "</Linear>";
+
+        Node linearNode = createNode(linearXml);
+        subject = new VastLinearXmlManager(linearNode);
+
+        assertThat(subject.getIconXmlManagers()).isEmpty();
+    }
+
+    @Test
+    public void getIconXmlManagers_withNoIconsNode_shouldReturnEmptyList() throws Exception {
+        String linearXml = "<Linear skipoffset=\"25%\">" +
+                "    <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
+                "    yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+                "    duration=\"01:02:03.456\">" +
+                "        <StaticResource creativeType=\"ImAge/JpEg\">" +
+                "           <![CDATA[staticResource1]]>" +
+                "        </StaticResource>" +
+                "    </Icon>" +
+                "</Linear>";
+
+        Node linearNode = createNode(linearXml);
+        subject = new VastLinearXmlManager(linearNode);
+
+        assertThat(subject.getIconXmlManagers()).isEmpty();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java
new file mode 100644
index 00000000..89005ec6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java
@@ -0,0 +1,225 @@
+package com.mopub.mobileads;
+
+import android.net.Uri;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastMacroHelperTest {
+
+    private static final String ERROR_CODE = "errorcode";
+    private static final String CONTENT_PLAY_HEAD = "contentplayhead";
+    private static final String CACHE_BUSTING = "cachebusting";
+    private static final String ASSET_URI = "asseturi";
+
+    private VastMacroHelper subject;
+    private String defaultUri;
+
+    @Before
+    @SuppressWarnings("unchecked")
+    public void setup() {
+        defaultUri = "http://www.derp.com/herp?errorcode=[ERRORCODE]&contentplayhead=[CONTENTPLAYHEAD]&asseturi=[ASSETURI]&cachebusting=[CACHEBUSTING]";
+        // Suppressing unchecked cast to List<String> with Collections#singletonList(Object)
+        subject = new VastMacroHelper(Collections.singletonList(defaultUri));
+    }
+
+    @Test
+    public void constructor_shouldSetCacheBusting() throws Exception {
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void constructor_shouldCreateRandomCacheBustingValues() throws Exception {
+        VastMacroHelper vastMacroHelper = new VastMacroHelper(Collections.singletonList(defaultUri));
+
+        String uriStr = subject.getUris().get(0);
+        String uriStr2 = vastMacroHelper.getUris().get(0);
+
+        Uri uri = Uri.parse(uriStr);
+        Uri uri2 = Uri.parse(uriStr2);
+
+        String cacheBusting = uri.getQueryParameter(CACHE_BUSTING);
+        String cacheBusting2 = uri2.getQueryParameter(CACHE_BUSTING);
+
+        assertThat(cacheBusting).isNotEqualTo(cacheBusting2);
+    }
+
+    @Test
+    public void withErrorCode_shouldSetErrorCode() throws Exception {
+        subject.withErrorCode(VastErrorCode.XML_PARSING_ERROR);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=100&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withErrorCode(VastErrorCode.WRAPPER_TIMEOUT);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=301&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withErrorCode(VastErrorCode.NO_ADS_VAST_RESPONSE);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=303&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withErrorCode(VastErrorCode.GENERAL_LINEAR_AD_ERROR);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=400&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withErrorCode(VastErrorCode.GENERAL_COMPANION_AD_ERROR);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=600&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withErrorCode(VastErrorCode.UNDEFINED_ERROR);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=900&contentplayhead=&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+    }
+
+    @Test
+    public void withContentPlayHead_shouldFormatTime_shouldSetContentPlayHead() throws Exception {
+        subject.withContentPlayHead(3600000);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=01:00:00.000&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withContentPlayHead(360000000);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=100:00:00.000&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withContentPlayHead(3599999);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=00:59:59.999&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withContentPlayHead(59999);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=00:00:59.999&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withContentPlayHead(999);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=00:00:00.999&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+
+        subject.withContentPlayHead(45296789);
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=12:34:56.789&asseturi=&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+    }
+
+    @Test
+    public void withAssetUri_shouldSetAssetUri() throws Exception {
+        final String expectedAssetUri = "http://thisIsAnAsset.Uri";
+        subject.withAssetUri(expectedAssetUri);
+
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.derp.com/herp?errorcode=&contentplayhead=&asseturi=http%3A%2F%2FthisIsAnAsset.Uri&cachebusting=" +
+                        getAndCheckCachebusting(subject.getUris().get(0)));
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void withManyMacros_shouldReplaceAllOfThem() throws Exception {
+        final String multiUrl = "http://www.someurl.com/dosomething?[ERRORCODE][ERRORCODE][CONTENTPLAYHEAD][ERRORCODE][ASSETURI][CONTENTPLAYHEAD][ERRORCODE]";
+        subject = new VastMacroHelper(Collections.singletonList(multiUrl))
+                .withAssetUri("asset")
+                .withContentPlayHead(100000)
+                .withErrorCode(VastErrorCode.UNDEFINED_ERROR);
+
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.someurl.com/dosomething?90090000:01:40.000900asset00:01:40.000900");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void withSpecialCharactersInAsseturi_shouldUrlEncode() {
+        final String specialUrl = "http://www.someurl.com/somedirectory/somemethod?errorcode=[ERRORCODE]&asseturi=[ASSETURI]";
+        subject = new VastMacroHelper(Collections.singletonList(specialUrl))
+                .withErrorCode(VastErrorCode.UNDEFINED_ERROR)
+                .withAssetUri(
+                        "http://aaddss.mmooppuubb.ccoomm:123/method?args=one~`!@#$%^&*()_+-[]{}|:,.<>/");
+
+        assertThat(subject.getUris()).containsOnly(
+                "http://www.someurl.com/somedirectory/somemethod?errorcode=900&asseturi=" +
+                        "http%3A%2F%2Faaddss.mmooppuubb.ccoomm%3A123%2Fmethod%3Fargs%3Done" +
+                        "%7E%60%21%40%23%24%25%5E%26*%28%29_%2B-%5B%5D%7B%7D%7C%3A%2C.%3C%3E%2F");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void withManyUrls_shouldReturnListOfUrls() {
+        final String uriWithNoCacheBusting = defaultUri.replace("&cachebusting=[CACHEBUSTING]", "");
+        final String uriWithTwoAssetUri = uriWithNoCacheBusting + "&asset2=[ASSETURI]";
+        final String uriWithTwoContentPlayHead = uriWithNoCacheBusting + "&cph2=[CONTENTPLAYHEAD]";
+        subject = new VastMacroHelper(Arrays.asList(
+                new String[]{uriWithNoCacheBusting, uriWithTwoAssetUri, uriWithTwoContentPlayHead}));
+        subject.withAssetUri("https://a.ss.et");
+        subject.withErrorCode(VastErrorCode.UNDEFINED_ERROR);
+        subject.withContentPlayHead(500);
+
+        assertThat(subject.getUris().size()).isEqualTo(3);
+        assertThat(subject.getUris().get(0)).isEqualTo(
+                "http://www.derp.com/herp?errorcode=900&contentplayhead=00:00:00.500&asseturi=https%3A%2F%2Fa.ss.et");
+        assertThat(subject.getUris().get(1)).isEqualTo(
+                "http://www.derp.com/herp?errorcode=900&contentplayhead=00:00:00.500&asseturi=https%3A%2F%2Fa.ss.et&asset2=https%3A%2F%2Fa.ss.et");
+        assertThat(subject.getUris().get(2)).isEqualTo(
+                "http://www.derp.com/herp?errorcode=900&contentplayhead=00:00:00.500&asseturi=https%3A%2F%2Fa.ss.et&cph2=00:00:00.500");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void withMalformedUrl_shouldNotAttemptToUrlEncode() {
+        final String malformedUri = "htttttt:////oops [CONTENTPLAYHEAD]this [ERRORCODE]is not [ASSETURI]a url";
+        subject = new VastMacroHelper(Collections.singletonList(malformedUri));
+        subject.withAssetUri("asset").withErrorCode(
+                VastErrorCode.UNDEFINED_ERROR).withContentPlayHead(1);
+
+        assertThat(subject.getUris()).containsOnly(
+                "htttttt:////oops 00:00:00.001this 900is not asseta url");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void withDeeplink_shouldNotAttemptToReformat() {
+        final String deeplink = "thisisadeeplink://reallyreallydeep";
+        subject = new VastMacroHelper(Collections.singletonList(deeplink));
+
+        assertThat(subject.getUris()).containsOnly(deeplink);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void withNormalUri_shouldReturnUnchangedUri() {
+        final String normalUri = "http://www.thisisanormal.uri/with?some=query";
+        subject = new VastMacroHelper(Collections.singletonList(normalUri));
+
+        assertThat(subject.getUris()).containsOnly(normalUri);
+    }
+
+    private String getAndCheckCachebusting(final String uriStr) {
+        Uri uri = Uri.parse(uriStr);
+        String cacheBusting = uri.getQueryParameter(CACHE_BUSTING);
+        assertThat(cacheBusting).isNotEmpty();
+        assertThat(cacheBusting.length()).isEqualTo(8);
+
+        // Will throw if not an int
+        Integer.parseInt(cacheBusting);
+
+        return cacheBusting;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
new file mode 100644
index 00000000..357e0ec7
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
@@ -0,0 +1,593 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+
+import com.mopub.common.CacheService;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.mobileads.VastManager.VastManagerListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class VastManagerTest {
+    static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
+    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='progress' offset='00:00:03.100'>http://myTrackingURL/wrapper/progress</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='close'>http://myTrackingURL/wrapper/close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/skip</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]><Error><![CDATA[http://wrapperErrorTracker]]></Error></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><TrackingEvents><Tracking event='close'>http://myTrackingURL/wrapper/nested_close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/nested_skip</Tracking></TrackingEvents><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough><CompanionClickTracking><![CDATA[http://companionClickTracking1]]></CompanionClickTracking><CompanionClickTracking><![CDATA[http://companionClickTracking2]]></CompanionClickTracking></Companion></CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]><Error><![CDATA[http://inLineErrorTracker]]></Error></InLine></Ad></VAST>";
+    static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+
+    private VastManager subject;
+    private FakeHttpLayer mFakeHttpLayer;
+    private VastManagerListener vastManagerListener;
+    private Activity context;
+    private VastVideoConfig mVastVideoConfig;
+    private Semaphore semaphore;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        CacheService.initializeDiskCache(context);
+        subject = new VastManager(context);
+        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
+
+        semaphore = new Semaphore(0);
+        vastManagerListener = mock(VastManagerListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                VastManagerTest.this.mVastVideoConfig = (VastVideoConfig) args[0];
+                semaphore.release();
+                return null;
+            }
+        }).when(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+    }
+
+    private void prepareVastVideoConfiguration() {
+        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener, context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCorrectVastValues() throws Exception {
+        // Vast redirect responses
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
+
+        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(mVastVideoConfig.getNetworkMediaFileUrl());
+        assertThat(mVastVideoConfig.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
+
+        assertThat(mVastVideoConfig.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
+        assertThat(mVastVideoConfig.getImpressionTrackers().size()).isEqualTo(5);
+
+        // Verify quartile trackers
+        assertThat(mVastVideoConfig.getFractionalTrackers().size()).isEqualTo(3);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.5f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.75f);
+
+        // Verify start tracker.
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().size()).isEqualTo(3);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(0).getTrackingMilliseconds())
+                .isEqualTo(0);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(1).getTrackingMilliseconds())
+                .isEqualTo(2000);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(2).getTrackingMilliseconds())
+                .isEqualTo(3100);
+
+        assertThat(mVastVideoConfig.getCompleteTrackers().size()).isEqualTo(1);
+
+        // We specifically added a close tracker and a skip tracker to the nested vast test case as well,
+        // therefore there are two expected trackers total for each type.
+        assertThat(mVastVideoConfig.getCloseTrackers().size()).isEqualTo(2);
+        assertThat(mVastVideoConfig.getSkipTrackers().size()).isEqualTo(2);
+        assertThat(mVastVideoConfig.getClickTrackers().size()).isEqualTo(1);
+
+        final VastCompanionAdConfig vastCompanionAdConfig = mVastVideoConfig.getVastCompanionAd(
+                context.getResources().getConfiguration().orientation);
+        assertThat(vastCompanionAdConfig.getWidth()).isEqualTo(300);
+        assertThat(vastCompanionAdConfig.getHeight()).isEqualTo(250);
+        assertThat(vastCompanionAdConfig.getVastResource().getResource())
+                .isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
+        assertThat(vastCompanionAdConfig.getVastResource().getType())
+                .isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(vastCompanionAdConfig.getVastResource().getCreativeType())
+                .isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(vastCompanionAdConfig.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+
+        assertThat(VastUtils.vastTrackersToStrings(vastCompanionAdConfig.getClickTrackers()))
+                .containsOnly("http://companionClickTracking1",
+                        "http://companionClickTracking2");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws Exception {
+        // Vast redirect responses
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig
+                .class));
+
+        // at this point it should have 3 sets of data from TEST_VAST_XML_STRING and one set from TEST_NESTED_VAST_XML_STRING
+        assertThat(mVastVideoConfig.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
+        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(mVastVideoConfig.getNetworkMediaFileUrl());
+        assertThat(mVastVideoConfig.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
+
+        assertThat(mVastVideoConfig.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
+        assertThat(mVastVideoConfig.getImpressionTrackers().size()).isEqualTo(13);
+
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().size()).isEqualTo(9);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(0);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(0);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(2).getTrackingMilliseconds()).isEqualTo(0);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(3).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(4).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(5).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(6).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(7).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(mVastVideoConfig.getAbsoluteTrackers().get(8).getTrackingMilliseconds()).isEqualTo(3100);
+
+
+        assertThat(mVastVideoConfig.getFractionalTrackers().size()).isEqualTo(9);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.25f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.25f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(3).trackingFraction()).isEqualTo(0.5f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(4).trackingFraction()).isEqualTo(0.5f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(5).trackingFraction()).isEqualTo(0.5f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(6).trackingFraction()).isEqualTo(0.75f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(7).trackingFraction()).isEqualTo(0.75f);
+        assertThat(mVastVideoConfig.getFractionalTrackers().get(8).trackingFraction()).isEqualTo(0.75f);
+
+        assertThat(mVastVideoConfig.getCompleteTrackers().size()).isEqualTo(3);
+        assertThat(mVastVideoConfig.getCloseTrackers().size()).isEqualTo(4);
+        assertThat(mVastVideoConfig.getSkipTrackers().size()).isEqualTo(4);
+        assertThat(mVastVideoConfig.getClickTrackers().size()).isEqualTo(3);
+        assertThat(mVastVideoConfig.getErrorTrackers().size()).isEqualTo(4);
+
+        final VastCompanionAdConfig vastCompanionAdConfig = mVastVideoConfig.getVastCompanionAd(
+                context.getResources().getConfiguration().orientation);
+        assertThat(vastCompanionAdConfig.getWidth()).isEqualTo(300);
+        assertThat(vastCompanionAdConfig.getHeight()).isEqualTo(250);
+        assertThat(vastCompanionAdConfig.getVastResource().getResource())
+                .isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
+        assertThat(vastCompanionAdConfig.getVastResource().getType())
+                .isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(vastCompanionAdConfig.getVastResource().getCreativeType())
+                .isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(vastCompanionAdConfig.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+        assertThat(VastUtils.vastTrackersToStrings(vastCompanionAdConfig.getClickTrackers()))
+                .containsOnly("http://companionClickTracking1",
+                        "http://companionClickTracking2");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(404, "");
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorrectDefaultExtensionValues() throws Exception {
+        // Vast redirect response to XML without VAST extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig.getCustomCtaText()).isNull();
+        assertThat(mVastVideoConfig.getCustomSkipText()).isNull();
+        assertThat(mVastVideoConfig.getCustomCloseIconUrl()).isNull();
+        assertThat(mVastVideoConfig.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML without extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener,
+                context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        // Verify custom extensions
+        assertThat(mVastVideoConfig.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(mVastVideoConfig.getCustomSkipText()).isEqualTo("skip");
+        assertThat(mVastVideoConfig.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(mVastVideoConfig.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        // Verify custom extensions
+        assertThat(mVastVideoConfig.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(mVastVideoConfig.getCustomSkipText()).isEqualTo("skip");
+        assertThat(mVastVideoConfig.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(mVastVideoConfig.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInline_shouldContainLastParsedCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element in TEST_NESTED_VAST_XML_STRING, will be parsed last
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 2</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 2</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>landscape</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 1</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 1</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device orientation</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener,
+                context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        // Verify custom extension values are the ones last parsed in TEST_NESTED_VAST_XML_STRING
+        assertThat(mVastVideoConfig.getCustomCtaText()).isEqualTo("CTA 2");
+        assertThat(mVastVideoConfig.getCustomSkipText()).isEqualTo("skip 2");
+        assertThat(mVastVideoConfig.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png");
+        assertThat(mVastVideoConfig.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldReturnEmptyString() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText> </MoPubCtaText>" +     // single space, i.e. no text
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+        assertThat(mVastVideoConfig.getCustomCtaText()).isEmpty();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>1234567890123456</MoPubCtaText>" +     // 16 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+        assertThat(mVastVideoConfig.getCustomCtaText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubSkipText>123456789</MoPubSkipText>" +     // 9 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+        assertThat(mVastVideoConfig.getCustomSkipText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shouldReturnDefaultForceLandscapeOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation>abcd</MoPubForceOrientation>" +   // invalid value
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+        assertThat(mVastVideoConfig.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseAndUntrimmed_shouldReturnCustomForceOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation> PortRAIT  </MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+        assertThat(mVastVideoConfig.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_PORTRAIT);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig.getSkipOffsetString()).isEqualTo("25%");
+    }
+
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig.getSkipOffsetString()).isEqualTo("00:03:14");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSpace_shouldReturnCorrectTrimmedValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig.getSkipOffsetString()).isEqualTo("00:03:14.159");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsedValue() throws Exception {
+        // Vast redirect response with skipoffset in percent format
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add a skipoffset in absolute format
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='00:03:14'>"),
+                vastManagerListener,
+                context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        // Verify that the last parsed skipoffset value is returned
+        assertThat(mVastVideoConfig.getSkipOffsetString()).isEqualTo("25%");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withEmptySkipOffset_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+
+        assertThat(mVastVideoConfig.getSkipOffsetString()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNoMediaUrlInXml_shouldReturnNull() throws Exception {
+        subject.prepareVastVideoConfiguration(TEST_VAST_BAD_NEST_URL_XML_STRING,
+                vastManagerListener, context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(mVastVideoConfig).isEqualTo(null);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNullXml_shouldReturnNull() throws Exception {
+        subject.prepareVastVideoConfiguration(null, vastManagerListener, context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(mVastVideoConfig).isEqualTo(null);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withEmptyXml_shouldReturnNull() throws Exception {
+        subject.prepareVastVideoConfiguration("", vastManagerListener, context);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(mVastVideoConfig).isEqualTo(null);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownloadVideo() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        CacheService.putToDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4", "video_data".getBytes());
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        assertThat(mFakeHttpLayer.getSentHttpRequestInfos().size()).isEqualTo(1);
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
+        assertThat(mVastVideoConfig.getDiskMediaFileUrl())
+                .isEqualTo(CacheService.getFilePathDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4"));
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldReturnNull() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(mVastVideoConfig).isEqualTo(null);
+    }
+
+    @Test
+    public void cancel_shouldCancelBackgroundProcessingAndNotNotifyListenerWithNull() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        Robolectric.getBackgroundScheduler().pause();
+
+        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener, context);
+
+        subject.cancel();
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(mVastVideoConfig).isEqualTo(null);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java
new file mode 100644
index 00000000..729b2ace
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java
@@ -0,0 +1,114 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastMediaXmlManagerTest {
+
+    private VastMediaXmlManager subject;
+    private Node mediaNode;
+
+    @Before
+    public void setup() throws Exception {
+        String mediaXml = "<MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" " +
+                "bitrate=\"457\"" +
+                "               width=\"300\" height=\"225\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat" +
+                ".com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
+                "        ]]>" +
+                "</MediaFile>";
+
+        mediaNode = createNode(mediaXml);
+        subject = new VastMediaXmlManager(mediaNode);
+    }
+
+    @Test
+    public void getWidth_shouldReturnWidthAttribute() {
+        assertThat(subject.getWidth()).isEqualTo(300);
+    }
+
+    @Test
+    public void getWidth_withNoWidthAttribute_shouldReturnNull() throws Exception {
+        String mediaXml = "<MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" " +
+                "bitrate=\"457\" height=\"225\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat" +
+                ".com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
+                "        ]]>" +
+                "</MediaFile>";
+
+        mediaNode = createNode(mediaXml);
+        subject = new VastMediaXmlManager(mediaNode);
+
+        assertThat(subject.getWidth()).isNull();
+    }
+
+    @Test
+    public void getHeight_shouldReturnHeightAttribute() {
+        assertThat(subject.getHeight()).isEqualTo(225);
+    }
+
+    @Test
+    public void getHeight_withNoHeightAttribute_shouldReturnNull() throws Exception {
+        String mediaXml = "<MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" " +
+                "bitrate=\"457\" width=\"300\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat" +
+                ".com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
+                "        ]]>" +
+                "</MediaFile>";
+
+        mediaNode = createNode(mediaXml);
+        subject = new VastMediaXmlManager(mediaNode);
+
+        assertThat(subject.getHeight()).isNull();
+    }
+
+    @Test
+    public void getType_shouldReturnMediaFileType() {
+        assertThat(subject.getType()).isEqualTo("video/quicktime");
+    }
+
+    @Test
+    public void getType_withNoTypeAttribute_shouldReturnNull() throws Exception {
+        String mediaXml = "<MediaFile id=\"1\" delivery=\"progressive\" " +
+                "bitrate=\"457\" width=\"300\" height=\"225\">" +
+                "        <![CDATA[" +
+                "        http://s3.amazonaws.com/uploads.hipchat" +
+                ".com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
+                "        ]]>" +
+                "</MediaFile>";
+
+        mediaNode = createNode(mediaXml);
+        subject = new VastMediaXmlManager(mediaNode);
+
+        assertThat(subject.getType()).isNull();
+    }
+
+    @Test
+    public void getMediaUrl_shouldReturnMediaFileUrl() {
+        assertThat(subject.getMediaUrl()).isEqualTo("http://s3.amazonaws.com/uploads.hipchat" +
+                ".com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
+    }
+
+    @Test
+    public void getMediaUrl_withNoMediaUrl_shouldReturnNull() throws Exception {
+        String mediaXml = "<MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" " +
+                "bitrate=\"457\" width=\"300\" height=\"225\">" +
+                "</MediaFile>";
+
+        mediaNode = createNode(mediaXml);
+        subject = new VastMediaXmlManager(mediaNode);
+
+        assertThat(subject.getMediaUrl()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java
new file mode 100644
index 00000000..322a98a6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java
@@ -0,0 +1,200 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static com.mopub.mobileads.VastResource.fromVastResourceXmlManager;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class VastResourceTest {
+
+    private VastResource subject;
+    @Mock private VastWebView mockVastWebView;
+
+    @Before
+    public void setup() {
+        subject = new VastResource("resource", VastResource.Type.STATIC_RESOURCE,
+                VastResource.CreativeType.IMAGE, 50, 100);
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withIFrameType_shouldSetIFrameResource() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        "StaticResource", "image/jpeg", "IFrameResource", "HTMLResource");
+
+        VastResource vastResource =
+                fromVastResourceXmlManager(resourceXmlManager, VastResource.Type.IFRAME_RESOURCE,
+                        50, 100);
+
+        assertThat(vastResource.getResource()).isEqualTo("IFrameResource");
+        assertThat(vastResource.getType())
+                .isEqualTo(VastResource.Type.IFRAME_RESOURCE);
+        assertThat(vastResource.getCreativeType())
+                .isEqualTo(VastResource.CreativeType.NONE);
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withHTMLType_shouldSetHTMLResource() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        "StaticResource", "image/jpeg", "IFrameResource", "HTMLResource");
+
+        VastResource vastResource =
+                fromVastResourceXmlManager(resourceXmlManager, VastResource.Type.HTML_RESOURCE, 50,
+                        100);
+
+        assertThat(vastResource.getResource()).isEqualTo("HTMLResource");
+        assertThat(vastResource.getType())
+                .isEqualTo(VastResource.Type.HTML_RESOURCE);
+        assertThat(vastResource.getCreativeType())
+                .isEqualTo(VastResource.CreativeType.NONE);
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withStaticType_withImageCreativeType_shouldSetImageCreativeType() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        "StaticResource", "image/jpeg", "IFrameResource", "HTMLResource");
+
+        VastResource vastResource = fromVastResourceXmlManager(resourceXmlManager,
+                VastResource.Type.STATIC_RESOURCE, 50, 100);
+
+        assertThat(vastResource.getResource()).isEqualTo("StaticResource");
+        assertThat(vastResource.getType())
+                .isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(vastResource.getCreativeType())
+                .isEqualTo(VastResource.CreativeType.IMAGE);
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withStaticType_withJavaScriptCreativeType_shouldSetJavascriptCreativeType() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        "StaticResource", "application/x-javascript", "IFrameResource", "HTMLResource");
+
+        VastResource vastResource = fromVastResourceXmlManager(resourceXmlManager,
+                VastResource.Type.STATIC_RESOURCE, 50, 100);
+
+        assertThat(vastResource.getResource()).isEqualTo("StaticResource");
+        assertThat(vastResource.getType())
+                .isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(vastResource.getCreativeType())
+                .isEqualTo(VastResource.CreativeType.JAVASCRIPT);
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withStaticType_withMissingCreativeType_shouldReturnNull() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        "StaticResource", null, "IFrameResource", "HTMLResource");
+
+        assertThat(fromVastResourceXmlManager(
+                resourceXmlManager, VastResource.Type.STATIC_RESOURCE, 50, 100)).isNull();
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withStaticType_withInvalidCreativeType_shouldReturnNull() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        "StaticResource", "INVALID_CREATIVE_TYPE", "IFrameResource", "HTMLResource");
+
+        assertThat(fromVastResourceXmlManager(
+                resourceXmlManager, VastResource.Type.STATIC_RESOURCE, 50, 100)).isNull();
+    }
+
+    @Test
+    public void fromVastResourceXmlManager_withNoResource_shouldReturnNull() throws Exception {
+        final VastResourceXmlManager resourceXmlManager =
+                VastXmlManagerAggregatorTest.initializeVastResourceXmlManagerMock(
+                        null, null, null, null);
+
+        assertThat(fromVastResourceXmlManager(
+                resourceXmlManager, VastResource.Type.STATIC_RESOURCE, 50, 100)).isNull();
+    }
+
+    @Test
+    public void constructor_shouldInitializeFieldsCorrectly() throws Exception {
+        assertThat(subject.getResource()).isEqualTo("resource");
+        assertThat(subject.getType()).isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(subject.getCreativeType()).isEqualTo(VastResource.CreativeType.IMAGE);
+    }
+
+    @Test
+    public void initializeWebView_withIFrameResource_shouldLoadData() throws Exception {
+        subject = new VastResource("resource", VastResource.Type.IFRAME_RESOURCE, VastResource
+                .CreativeType.NONE, 50, 100);
+        subject.initializeWebView(mockVastWebView);
+
+        verify(mockVastWebView).loadData(
+                "<iframe frameborder=\"0\" scrolling=\"no\" marginheight=\"0\" " +
+                        "marginwidth=\"0\" style=\"border: 0px; margin: 0px;\" width=\"50\" " +
+                        "height=\"100\" src=\"resource\"></iframe>");
+    }
+
+    @Test
+    public void initializeWebView_withHTMLResource_shouldLoadData() throws Exception {
+        subject = new VastResource("resource", VastResource.Type.HTML_RESOURCE, VastResource
+                .CreativeType.NONE, 50, 100);
+        subject.initializeWebView(mockVastWebView);
+
+        verify(mockVastWebView).loadData("resource");
+    }
+
+    @Test
+    public void initializeWebView_withStaticResource_withImageCreativeType_shouldLoadData() throws Exception {
+        subject = new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                .CreativeType.IMAGE, 50, 100);
+        subject.initializeWebView(mockVastWebView);
+
+        verify(mockVastWebView).loadData("<html><head></head><body style=\"margin:0;padding:0\">" +
+                "<img src=\"resource\" width=\"100%\" style=\"max-width:100%;max-height:100%;\" />" +
+                "</body></html>");
+    }
+
+    @Test
+    public void initializeWebView_withStaticResource_withJavascriptCreativeType_shouldLoadData() throws Exception {
+        subject = new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                .CreativeType.JAVASCRIPT, 50, 100);
+        subject.initializeWebView(mockVastWebView);
+
+        verify(mockVastWebView).loadData("<script src=\"resource\"></script>");
+    }
+
+    @Test
+    public void getCorrectClickThroughUrl_shouldReturnCorrectClickThroughUrl() throws Exception {
+        subject = new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                .CreativeType.IMAGE, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", "web")).isEqualTo("xml");
+
+        subject = new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                .CreativeType.JAVASCRIPT, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", "web")).isEqualTo("web");
+
+        subject = new VastResource("resource", VastResource.Type.HTML_RESOURCE, VastResource
+                .CreativeType.NONE, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", "web")).isEqualTo("web");
+
+        subject = new VastResource("resource", VastResource.Type.IFRAME_RESOURCE, VastResource
+                .CreativeType.NONE, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", "web")).isEqualTo("web");
+
+        subject = new VastResource("resource", VastResource.Type.HTML_RESOURCE, VastResource
+                .CreativeType.NONE, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", null)).isNull();
+
+        subject = new VastResource("resource", VastResource.Type.IFRAME_RESOURCE, VastResource
+                .CreativeType.NONE, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", null)).isNull();
+
+        subject = new VastResource("resource", VastResource.Type.STATIC_RESOURCE, VastResource
+                .CreativeType.IMAGE, 50, 100);
+        assertThat(subject.getCorrectClickThroughUrl("xml", null)).isEqualTo("xml");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java
new file mode 100644
index 00000000..78f08b22
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java
@@ -0,0 +1,125 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastResourceXmlManagerTest {
+
+    private VastResourceXmlManager subject;
+    private Node resourceNode;
+
+    @Before
+    public void setup() throws Exception {
+        String resourceXml =
+                "<root>" +
+                    "<StaticResource creativeType=\"ImAge/JpEg\">" +
+                        "<![CDATA[StaticResource]]>" +
+                    "</StaticResource>" +
+                    "<IFrameResource>" +
+                        "<![CDATA[IFrameResource]]>" +
+                    "</IFrameResource>" +
+                    "<HTMLResource>" +
+                        "<![CDATA[HTMLResource]]>" +
+                    "</HTMLResource>" +
+                "</root>";
+
+        resourceNode = createNode(resourceXml);
+        subject = new VastResourceXmlManager(resourceNode);
+    }
+
+    @Test
+    public void getStaticResource_shouldReturnStaticResource() throws Exception {
+        assertThat(subject.getStaticResource()).isEqualTo("StaticResource");
+    }
+
+    @Test
+    public void getStaticResource_withNoStaticResource_shouldReturnNull() throws Exception {
+        String iconXml = "<root>" +
+                    "<IFrameResource>" +
+                        "<![CDATA[IFrameResource]]>" +
+                    "</IFrameResource>" +
+                    "<HTMLResource>" +
+                        "<![CDATA[HTMLResource]]>" +
+                    "</HTMLResource>" +
+                "</root>";
+
+        resourceNode = createNode(iconXml);
+        subject = new VastResourceXmlManager(resourceNode);
+        assertThat(subject.getStaticResource()).isNull();
+    }
+
+    @Test
+    public void getStaticResourceType_shouldReturnLowerCaseStaticResourceType() throws Exception {
+        assertThat(subject.getStaticResourceType()).isEqualTo("image/jpeg");
+    }
+
+    @Test
+    public void getStaticResourceType_withNoStaticCreativeType_shouldReturnNull() throws Exception {
+        String resourceXml = "<root>" +
+                    "<StaticResource>" +
+                        "<![CDATA[StaticResource]]>" +
+                    "</StaticResource>" +
+                    "<IFrameResource>" +
+                        "<![CDATA[IFrameResource]]>" +
+                    "</IFrameResource>" +
+                    "<HTMLResource>" +
+                        "<![CDATA[HTMLResource]]>" +
+                    "</HTMLResource>" +
+                "</root>";
+
+        resourceNode = createNode(resourceXml);
+        subject = new VastResourceXmlManager(resourceNode);
+        assertThat(subject.getStaticResourceType()).isNull();
+    }
+
+    @Test
+    public void getIFrameResource_shouldReturnIFrameResource() throws Exception {
+        assertThat(subject.getIFrameResource()).isEqualTo("IFrameResource");
+    }
+
+    @Test
+    public void getIFrameResource_withNoIFrameResouce_shouldReturnNull() throws Exception {
+        String resourceXml = "<root>" +
+                    "<StaticResource creativeType=\"ImAge/JpEg\">" +
+                        "<![CDATA[StaticResource]]>" +
+                    "</StaticResource>" +
+                    "<HTMLResource>" +
+                        "<![CDATA[HTMLResource]]>" +
+                    "</HTMLResource>" +
+                "</root>";
+
+        resourceNode = createNode(resourceXml);
+        subject = new VastResourceXmlManager(resourceNode);
+        assertThat(subject.getIFrameResource()).isNull();
+    }
+
+    @Test
+    public void getHTMLResource_shouldReturnHTMLResource() throws Exception {
+        assertThat(subject.getHTMLResource()).isEqualTo("HTMLResource");
+    }
+
+    @Test
+    public void getHTMLResource_withNoHTMLResource_shouldReturnNull() throws Exception {
+        String resourceXml = "<root>" +
+                    "<StaticResource creativeType=\"ImAge/JpEg\">" +
+                        "<![CDATA[StaticResource]]>" +
+                    "</StaticResource>" +
+                    "<IFrameResource>" +
+                        "<![CDATA[IFrameResource]]>" +
+                    "</IFrameResource>" +
+                "</root>";
+
+        resourceNode = createNode(resourceXml);
+        subject = new VastResourceXmlManager(resourceNode);
+        assertThat(subject.getHTMLResource()).isNull();
+    }
+
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java
new file mode 100644
index 00000000..b711a3de
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java
@@ -0,0 +1,140 @@
+package com.mopub.mobileads;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.widget.ImageView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoBlurLastVideoFrameTaskTest {
+    @Mock private MediaMetadataRetriever mockMediaMetadataRetriever;
+    @Mock private ImageView mockBlurredLastVideoFrameImageView;
+    @Mock private Bitmap mockBitmap;
+
+    private VastVideoBlurLastVideoFrameTask subject;
+    private String videoPath;
+    private int videoDuration;
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Before
+    public void setUp() throws Exception {
+        videoPath = "disk_video_path";
+        videoDuration = 10000;
+
+        when(mockMediaMetadataRetriever.getFrameAtTime(anyLong(), anyInt())).thenReturn(mockBitmap);
+
+        subject = new VastVideoBlurLastVideoFrameTask(mockMediaMetadataRetriever,
+                mockBlurredLastVideoFrameImageView, videoDuration);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD)
+    @Test
+    public void doInBackground_beforeGingerbreadMr1_shouldReturnFalse() throws Exception {
+        assertThat(subject.doInBackground(videoPath)).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Test
+    public void doInBackground_atLeastGingerbreadMr1_shouldReturnTrue() throws Exception {
+        assertThat(subject.doInBackground(videoPath)).isTrue();
+        assertThat(subject.getBlurredLastVideoFrame()).isEqualTo(mockBitmap);
+    }
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Test
+    public void doInBackground_whenSetDataSourceThrowsRuntimeException_shouldCatchExceptionAndReturnFalse() throws Exception {
+        doThrow(new RuntimeException()).when(mockMediaMetadataRetriever).setDataSource(anyString());
+
+        assertThat(subject.doInBackground(videoPath)).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Test
+    public void doInBackground_whenGetLastFrameReturnsNull_shouldReturnFalse() throws Exception {
+        when(mockMediaMetadataRetriever.getFrameAtTime(anyLong(), anyInt())).thenReturn(null);
+
+        assertThat(subject.doInBackground(videoPath)).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+    
+    @Test
+    public void doInBackground_whenVideoPathIsNull_shouldReturnFalse() throws Exception {
+        assertThat(subject.doInBackground((String) null)).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+
+    @Test
+    public void doInBackground_whenVideoPathsArrayIsNull_shouldReturnFalse() throws Exception {
+        assertThat(subject.doInBackground((String[]) null)).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+
+    @Test
+    public void doInBackground_whenVideoPathsArrayIsEmpty_shouldReturnFalse() throws Exception {
+        assertThat(subject.doInBackground(new String[0])).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+
+    @Test
+    public void doInBackground_whenVideoPathsArrayHasMultipleElements_shouldParseFirstElement() throws Exception {
+        assertThat(subject.doInBackground(videoPath, null)).isTrue();
+        assertThat(subject.getBlurredLastVideoFrame()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void doInBackground_whenFirstElementOfVideoPathsArrayIsNull_shouldReturnFalse() throws Exception {
+        assertThat(subject.doInBackground(null, videoPath)).isFalse();
+        assertThat(subject.getBlurredLastVideoFrame()).isNull();
+    }
+
+    @Test
+    public void onPostExecute_whenBlurringSucceeded_shouldSetImageBitmap() throws Exception {
+        subject.onPostExecute(true);
+
+        verify(mockBlurredLastVideoFrameImageView).setImageBitmap(subject.getBlurredLastVideoFrame());
+    }
+
+    @Test
+    public void onPostExecute_whenBlurringFailed_shouldNotSetImageBitmap() throws Exception {
+        subject.onPostExecute(false);
+
+        verify(mockBlurredLastVideoFrameImageView, never()).setImageBitmap(any(Bitmap.class));
+    }
+
+    @Test
+    public void onPostExecute_whenResultIsNull_shouldNotSetImageBitmap() throws Exception {
+        subject.onPostExecute(null);
+
+        verify(mockBlurredLastVideoFrameImageView, never()).setImageBitmap(any(Bitmap.class));
+    }
+
+    @Test
+    public void onPostExecute_whenTaskIsAlreadyCancelled_shouldNotSetImageBitmap() throws Exception {
+        subject.cancel(true);
+
+        subject.onPostExecute(true);
+
+        verify(mockBlurredLastVideoFrameImageView, never()).setImageBitmap(any(Bitmap.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java
new file mode 100644
index 00000000..c7c825c1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java
@@ -0,0 +1,100 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.widget.ImageView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoCloseButtonWidgetTest {
+    private Context context;
+    private VastVideoCloseButtonWidget subject;
+
+    private static final String ICON_IMAGE_URL = "iconimageurl";
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> imageCaptor;
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new VastVideoCloseButtonWidget(context);
+    }
+
+    @Test
+    public void updateCloseButtonIcon_imageListenerOnResponse_shouldUseImageBitmap() throws Exception {
+        when(mockImageContainer.getBitmap()).thenReturn(mockBitmap);
+
+        subject.updateCloseButtonIcon(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        assertThat(((BitmapDrawable) subject.getImageView().getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponseWhenReturnedBitMapIsNull_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        when(mockImageContainer.getBitmap()).thenReturn(null);
+
+        subject.updateCloseButtonIcon(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageView().getDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnErrorResponse_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        subject.updateCloseButtonIcon(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onErrorResponse(new VolleyError());
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageView().getDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java
new file mode 100644
index 00000000..b41ec047
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java
@@ -0,0 +1,193 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Intent;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoConfigTest {
+
+    @Mock MoPubRequestQueue mockRequestQueue;
+    private Activity activity;
+    private VastVideoConfig subject;
+
+    @Before
+    public void setup() {
+        activity = spy(Robolectric.buildActivity(Activity.class).create().get());
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        subject = new VastVideoConfig();
+        subject.setNetworkMediaFileUrl("video_url");
+    }
+
+    @Test
+    public void addFractionalTrackers_multipleTimes_shouldBeSorted() throws Exception {
+        ArrayList<VastFractionalProgressTracker> testSet1 = new ArrayList<VastFractionalProgressTracker>();
+        testSet1.add(new VastFractionalProgressTracker("test1a", 0.24f));
+        testSet1.add(new VastFractionalProgressTracker("test1b", 0.5f));
+        testSet1.add(new VastFractionalProgressTracker("test1c", 0.91f));
+
+        ArrayList<VastFractionalProgressTracker> testSet2 = new ArrayList<VastFractionalProgressTracker>();
+        testSet2.add(new VastFractionalProgressTracker("test2a", 0.14f));
+        testSet2.add(new VastFractionalProgressTracker("test2b", 0.6f));
+        testSet2.add(new VastFractionalProgressTracker("test2c", 0.71f));
+
+        VastVideoConfig subject = new VastVideoConfig();
+
+        subject.addFractionalTrackers(testSet1);
+        subject.addFractionalTrackers(testSet2);
+
+        assertThat(subject.getFractionalTrackers()).isSorted();
+    }
+
+    @Test
+    public void addAbsoluteTrackers_multipleTimes_shouldBesSorted() throws Exception {
+        ArrayList<VastAbsoluteProgressTracker> testSet1 = new ArrayList<VastAbsoluteProgressTracker>();
+        testSet1.add(new VastAbsoluteProgressTracker("test1a", 1000));
+        testSet1.add(new VastAbsoluteProgressTracker("test1b", 10000));
+        testSet1.add(new VastAbsoluteProgressTracker("test1c", 50000));
+
+        ArrayList<VastAbsoluteProgressTracker> testSet2 = new ArrayList<VastAbsoluteProgressTracker>();
+        testSet2.add(new VastAbsoluteProgressTracker("test2a", 1100));
+        testSet2.add(new VastAbsoluteProgressTracker("test2b", 9000));
+        testSet2.add(new VastAbsoluteProgressTracker("test2c", 62000));
+
+        VastVideoConfig subject = new VastVideoConfig();
+
+        subject.addAbsoluteTrackers(testSet1);
+        subject.addAbsoluteTrackers(testSet2);
+
+        assertThat(subject.getAbsoluteTrackers()).isSorted();
+    }
+
+
+    @Test
+    public void getUntriggeredTrackersBefore_withTriggeredTrackers_shouldNotReturnTriggered() throws Exception {
+        VastVideoConfig subject = new VastVideoConfig();
+        subject.setDiskMediaFileUrl("disk_video_path");
+        subject.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                        new VastFractionalProgressTracker("second", 0.5f),
+                        new VastFractionalProgressTracker("third", 0.75f)));
+        subject.addAbsoluteTrackers(
+                Arrays.asList(new VastAbsoluteProgressTracker("5secs", 5000),
+                        new VastAbsoluteProgressTracker("10secs", 10000)));
+
+        final List<VastTracker> untriggeredTrackers = subject.getUntriggeredTrackersBefore(11000,
+                11000);
+        assertThat(untriggeredTrackers).hasSize(5);
+        untriggeredTrackers.get(0).setTracked();
+
+        final List<VastTracker> secondTrackersList = subject.getUntriggeredTrackersBefore(11000,
+                11000);
+        assertThat(secondTrackersList).hasSize(4);
+    }
+
+    @Test
+    public void getUntriggeredTrackersBefore_shouldReturnAllTrackersSorted() throws Exception {
+        VastVideoConfig subject = new VastVideoConfig();
+        subject.setDiskMediaFileUrl("disk_video_path");
+        subject.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                        new VastFractionalProgressTracker("second", 0.5f),
+                        new VastFractionalProgressTracker("third", 0.75f)));
+        subject.addAbsoluteTrackers(
+                Arrays.asList(new VastAbsoluteProgressTracker("1secs", 1000),
+                        new VastAbsoluteProgressTracker("10secs", 10000)));
+
+        final List<VastTracker> untriggeredTrackers = subject.getUntriggeredTrackersBefore(11000,
+                11000);
+        assertThat(untriggeredTrackers).hasSize(5);
+
+        // Sorted absolute trackers, followed by sorted fractional trackers
+        final VastTracker tracker0 = untriggeredTrackers.get(0);
+        assertThat(tracker0).isExactlyInstanceOf(VastAbsoluteProgressTracker.class);
+        assertThat(((VastAbsoluteProgressTracker) tracker0).getTrackingMilliseconds()).isEqualTo(
+                1000);
+
+        final VastTracker tracker1 = untriggeredTrackers.get(1);
+        assertThat(tracker1).isExactlyInstanceOf(VastAbsoluteProgressTracker.class);
+        assertThat(((VastAbsoluteProgressTracker) tracker1).getTrackingMilliseconds()).isEqualTo(
+                10000);
+
+
+        final VastTracker tracker2 = untriggeredTrackers.get(2);
+        assertThat(tracker2).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker2).trackingFraction()).isEqualTo(0.25f);
+
+        final VastTracker tracker3 = untriggeredTrackers.get(3);
+        assertThat(tracker3).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker3).trackingFraction()).isEqualTo(0.5f);
+
+        final VastTracker tracker4 = untriggeredTrackers.get(4);
+        assertThat(tracker4).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker4).trackingFraction()).isEqualTo(0.75f);
+    }
+
+    @Test
+    public void handleClick_withNullClickThroughUrl_shouldNotOpenNewActivity() throws Exception {
+        subject.handleClick(activity, 1234, 1);
+
+        Robolectric.getUiThreadScheduler().unPause();
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser_shouldMakeTrackingHttpRequest() throws Exception {
+        subject.setClickThroughUrl(
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com%2F");
+        subject.addClickTrackers(
+                Arrays.asList(new VastTracker("http://trackerone+content=[CONTENTPLAYHEAD]"),
+                        new VastTracker("http://trackertwo+error=[ERRORCODE]&asset=[ASSETURI]")));
+
+        subject.handleClick(activity, 2345, 1234);
+
+        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.runBackgroundTasks();
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("http://www.mopub.com/");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        verify(mockRequestQueue).add(argThat(isUrl("http://trackerone+content=00:00:02.345")));
+        verify(mockRequestQueue).add(argThat(isUrl("http://trackertwo+error=&asset=video_url")));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() throws Exception {
+        // url2 is an invalid query parameter
+        subject.setClickThroughUrl(
+                "mopubnativebrowser://navigate?url2=http%3A%2F%2Fwww.mopub.com%2F");
+
+        subject.handleClick(activity, 3456, 1);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withAboutBlankClickThroughUrl_shouldFailSilently() throws Exception {
+        subject.setClickThroughUrl("about:blank");
+
+        subject.handleClick(activity, 4567, 1);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java
new file mode 100644
index 00000000..988d36b1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java
@@ -0,0 +1,226 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.view.View;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoCtaButtonWidgetTest {
+    private Context context;
+    private VastVideoCtaButtonWidget subject;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    @Test
+    public void constructor_withCompanionAd_shouldBeInvisibleAndNotSetLayoutParams() throws Exception {
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    @Test
+    public void constructor_withoutCompanionAd_shouldBeInvisibleAndNotSetLayoutParams() throws Exception {
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    @Test
+    public void constructor_withCompanionAd_withNoClickthroughUrl_shouldBeGoneAndNotSetLayoutParams() throws Exception {
+        subject = new VastVideoCtaButtonWidget(context, 0, true, false);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    @Test
+    public void constructor_withoutCompanionAd_withNoClickthroughUrl_shouldBeGoneAndNotSetLayoutParams() throws Exception {
+        subject = new VastVideoCtaButtonWidget(context, 0, false, false);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    // Video is skippable, has companion ad, has clickthrough url, CTA button initially invisible
+
+    @Test
+    public void notifyVideoSkippable_withCompanionAdAndInPortrait_shouldBeVisibleAndSetPortraitLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasPortraitLayoutParams()).isTrue();
+    }
+
+    @Test
+    public void notifyVideoSkippable_withCompanionAdAndInLandscape_shouldBeVisibleAndSetLandscapeLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasLandscapeLayoutParams()).isTrue();
+    }
+
+    @Test
+    public void notifyVideoSkippable_withCompanionAdAndOrientationUndefined_shouldBeVisibleAndSetPortraitLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasPortraitLayoutParams()).isTrue();
+    }
+
+    // Video is skippable, no companion ad, has clickthrough url, CTA button initially invisible
+
+    @Test
+    public void notifyVideoSkippable_withoutCompanionAdAndInPortrait_shouldBeVisibleAndSetPortraitLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasPortraitLayoutParams()).isTrue();
+    }
+
+    @Test
+    public void notifyVideoSkippable_withoutCompanionAdAndInLandscape_shouldBeVisibleAndSetLandscapeLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasLandscapeLayoutParams()).isTrue();
+    }
+
+    @Test
+    public void notifyVideoSkippable_withoutCompanionAdAndOrientationUndefined_shouldBeVisibleAndSetPortraitLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasPortraitLayoutParams()).isTrue();
+    }
+
+    // Video is complete, has companion ad, CTA button already visible
+
+    @Test
+    public void notifyVideoComplete_withCompanionAdAndInPortrait_shouldBeGoneAndNotChangeLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    @Test
+    public void notifyVideoComplete_withCompanionAdAndInLandscape_shouldBeGoneAndNotChangeLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    @Test
+    public void notifyVideoComplete_withCompanionAdAndOrientationUndefined_shouldBeGoneAndNotChangeLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getLayoutParams()).isNull();
+    }
+
+    // Video is complete, no companion ad, has clickthrough url, CTA button already visible
+
+    @Test
+    public void notifyVideoComplete_withoutCompanionAdAndInPortrait_shouldBeVisibleAndSetPortraitLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasPortraitLayoutParams()).isTrue();
+    }
+
+    @Test
+    public void notifyVideoComplete_withoutCompanionAdAndInLandscape_shouldBeVisibleAndSetLandscapeLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasLandscapeLayoutParams()).isTrue();
+    }
+
+    @Test
+    public void notifyVideoComplete_withoutCompanionAdAndOrientationUndefined_shouldBeVisibleAndSetPortraitLayoutParams() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+        subject = new VastVideoCtaButtonWidget(context, 0, false, true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.hasPortraitLayoutParams()).isTrue();
+    }
+
+    // No clickthrough url means never show cta button
+
+    @Test
+    public void notifyVideoSkippable_withoutClickthroughUrl_shouldBeGone() throws Exception {
+        subject = new VastVideoCtaButtonWidget(context, 0, true, false);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoSkippable();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+    }
+
+    @Test
+    public void notifyVideoComplete_withoutClickthroughUrl_shouldBeGone() throws Exception {
+        subject = new VastVideoCtaButtonWidget(context, 0, true, false);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
index aa9f1786..9fdafe8d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
@@ -7,7 +7,6 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -55,11 +54,6 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         subject = new VastVideoDownloadTask(mVastVideoDownloadTaskListener);
     }
 
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
     @Test
     public void execute_shouldAddToCacheAndSignalDownloadSuccess() throws Exception {
         subject.execute(videoUrl);
@@ -91,6 +85,14 @@ public void execute_whenUrlArrayIsNull_shouldSignalDownloadFailed() throws Excep
         verify(mVastVideoDownloadTaskListener).onComplete(false);
     }
 
+    @Test
+    public void execute_whenUrlArrayIsEmpty_shouldSignalDownloadFailed() throws Exception {
+        subject.execute(new String[0]);
+
+        semaphore.acquire();
+        verify(mVastVideoDownloadTaskListener).onComplete(false);
+    }
+
     @Test
     public void execute_whenFirstElementOfUrlArrayIsNull_shouldSignalDownloadFailed() throws Exception {
         subject.execute(null, "ignored");
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java
new file mode 100644
index 00000000..f4b3c240
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java
@@ -0,0 +1,247 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.drawable.GradientDrawable;
+import android.view.View;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoGradientStripWidgetTest {
+    private Context context;
+    private VastVideoGradientStripWidget subject;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    @Test
+    public void constructor_whenForcePortrait_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_PORTRAIT, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void constructor_whenForceLandscape_shouldBeVisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_LANDSCAPE, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void constructor_whenUseDeviceOrientation_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.DEVICE_ORIENTATION, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+
+        // If not forcing orientation, visibility depends on device orientation,
+        // which is initially ORIENTATION_UNDEFINED in tests
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void constructor_whenForceOrientationUndefined_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.UNDEFINED, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+
+        // If force orientation undefined, visibility depends on device orientation,
+        // which is initially ORIENTATION_UNDEFINED in tests
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    // Video is still playing, forcing portrait orientation
+
+    @Test
+    public void onConfigurationChanged_whenForcePortraitAndDeviceInPortrait_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_PORTRAIT, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenForcePortraitAndDeviceInLandscape_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_PORTRAIT, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenForcePortraitAndDeviceOrientationUndefined_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_PORTRAIT, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    // Video is still playing, forcing landscape orientation
+
+    @Test
+    public void onConfigurationChanged_whenForceLandscapeAndDeviceInPortrait_shouldBeVisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_LANDSCAPE, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenForceLandscapeAndDeviceInLandscape_shouldBeVisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_LANDSCAPE, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenForceLandscapeAndDeviceOrientationUndefined_shouldBeVisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_LANDSCAPE, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    // Video is still playing, use device orientation
+
+    @Test
+    public void onConfigurationChanged_whenUseDeviceOrientationAndDeviceInPortrait_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.DEVICE_ORIENTATION, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenUseDeviceOrientationAndDeviceInLandscape_shouldBeVisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.DEVICE_ORIENTATION, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenUseDeviceOrientationAndDeviceOrientationUndefined_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.DEVICE_ORIENTATION, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    // Video is still playing, force orientation undefined
+
+    @Test
+    public void onConfigurationChanged_whenForceOrientationUndefinedAndDeviceInPortrait_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.UNDEFINED, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenForceOrientationUndefinedAndDeviceInLandscape_shouldBeVisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.UNDEFINED, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenForceOrientationUndefinedAndDeviceOrientationUndefined_shouldBeInvisible() throws Exception {
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.UNDEFINED, true, View.VISIBLE,
+                RelativeLayout.ALIGN_TOP, 0);
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+
+        subject.onConfigurationChanged(context.getResources().getConfiguration());
+
+        assertThat(subject.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    // Video is complete
+
+    @Test
+    public void notifyVideoComplete_withCompanionAd_shouldSetVisibilityForCompanionAd() throws Exception {
+        final int visibilityForCompanionAd = View.VISIBLE;
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_PORTRAIT, true, visibilityForCompanionAd,
+                RelativeLayout.ALIGN_TOP, 0);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void notifyVideoComplete_withoutCompanionAd_shouldBeGone() throws Exception {
+        final int visibilityForCompanionAd = View.VISIBLE;
+        subject = new VastVideoGradientStripWidget(context, GradientDrawable.Orientation.TOP_BOTTOM,
+                DeviceUtils.ForceOrientation.FORCE_PORTRAIT, false, visibilityForCompanionAd,
+                RelativeLayout.ALIGN_TOP, 0);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
index ba4a9454..4a17ff8c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
@@ -3,17 +3,14 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
-import android.net.Uri;
 
-import com.mopub.common.CacheService;
 import com.mopub.common.CacheServiceTest;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
 import com.mopub.mobileads.test.support.TestVastVideoDownloadTaskFactory;
-import com.mopub.mobileads.util.vast.VastCompanionAd;
-import com.mopub.mobileads.util.vast.VastManager;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.mobileads.test.support.VastUtils;
 
 import org.junit.After;
 import org.junit.Before;
@@ -26,14 +23,14 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.mobileads.util.vast.VastManager.VastManagerListener;
+import static com.mopub.mobileads.VastManager.VastManagerListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyString;
@@ -41,7 +38,6 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.withSettings;
 
@@ -57,7 +53,6 @@
     private String videoUrl;
     private VastVideoDownloadTask vastVideoDownloadTask;
     private long broadcastIdentifier;
-    private AdConfiguration adConfiguration;
 
     @Before
     public void setUp() throws Exception {
@@ -72,20 +67,17 @@ public void setUp() throws Exception {
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
-        serverExtras.put(AdFetcher.HTML_RESPONSE_BODY_KEY, Uri.encode(expectedResponse));
+        serverExtras.put(DataKeys.HTML_RESPONSE_BODY_KEY, expectedResponse);
 
         response = new TestHttpResponseWithHeaders(200, expectedResponse);
 
         broadcastIdentifier = 2222;
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(broadcastIdentifier);
-        localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
+        localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
     }
 
     @After
     public void tearDown() throws Exception {
         reset(vastVideoDownloadTask);
-        CacheService.clearAndNullCaches();
     }
 
     @Test
@@ -94,8 +86,10 @@ public void preRenderHtml_whenCreatingVideoCache_butItHasInitializationErrors_sh
 
         subject.preRenderHtml(customEventInterstitialListener);
 
-        verify(customEventInterstitialListener).onInterstitialFailed(eq(MoPubErrorCode.VIDEO_CACHE_ERROR));
-        verify(vastManager, never()).prepareVastVideoConfiguration(anyString(), any(VastManagerListener.class));
+        verify(customEventInterstitialListener).onInterstitialFailed(
+                eq(MoPubErrorCode.VIDEO_CACHE_ERROR));
+        verify(vastManager, never()).prepareVastVideoConfiguration(anyString(),
+                any(VastManagerListener.class), any(Context.class));
     }
 
     @Test
@@ -118,7 +112,8 @@ public void loadInterstitial_shouldInitializeDiskCache() throws Exception {
     public void loadInterstitial_shouldCreateVastManagerAndProcessVast() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
 
-        verify(vastManager).prepareVastVideoConfiguration(eq(expectedResponse), eq((VastVideoInterstitial) subject));
+        verify(vastManager).prepareVastVideoConfiguration(eq(expectedResponse),
+                eq((VastVideoInterstitial) subject), eq(context));
     }
 
     @Test
@@ -128,7 +123,8 @@ public void loadInterstitial_whenServerExtrasDoesNotContainResponse_shouldSignal
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
 
         verify(customEventInterstitialListener).onInterstitialFailed(NETWORK_INVALID_STATE);
-        verify(vastManager, never()).prepareVastVideoConfiguration(anyString(), any(VastManagerListener.class));
+        verify(vastManager, never()).prepareVastVideoConfiguration(anyString(),
+                any(VastManagerListener.class), any(Context.class));
     }
 
     @Test
@@ -148,27 +144,29 @@ public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws E
 
     @Test
     public void showInterstitial_shouldStartVideoPlayerActivityWithAllValidTrackers() throws Exception {
-        VastCompanionAd vastCompanionAd = mock(VastCompanionAd.class, withSettings().serializable());
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setNetworkMediaFileUrl(videoUrl);
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("mid"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
-        vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        vastVideoConfiguration.setClickThroughUrl("clickThrough");
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click"));
-        vastVideoConfiguration.setVastCompanionAd(vastCompanionAd);
+        VastCompanionAdConfig vastCompanionAdConfig = mock(VastCompanionAdConfig.class, withSettings().serializable());
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl(videoUrl);
+        vastVideoConfig.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker
+                ("start", 2000)));
+        vastVideoConfig.addFractionalTrackers(Arrays.asList(new
+                        VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("mid", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+        vastVideoConfig.addCompleteTrackers(VastUtils.stringsToVastTrackers("complete"));
+        vastVideoConfig.addImpressionTrackers(VastUtils.stringsToVastTrackers("imp"));
+        vastVideoConfig.setClickThroughUrl("clickThrough");
+        vastVideoConfig.addClickTrackers(VastUtils.stringsToVastTrackers("click"));
+        vastVideoConfig.setVastCompanionAd(vastCompanionAdConfig, vastCompanionAdConfig);
 
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
-        ((VastVideoInterstitial) subject).onVastVideoConfigurationPrepared(vastVideoConfiguration);
+        ((VastVideoInterstitial) subject).onVastVideoConfigurationPrepared(vastVideoConfig);
 
         subject.showInterstitial();
-        BaseVideoPlayerActivitiyTest.assertVastVideoPlayerActivityStarted(
+        BaseVideoPlayerActivityTest.assertVastVideoPlayerActivityStarted(
                 MraidVideoPlayerActivity.class,
-                vastVideoConfiguration,
-                adConfiguration
+                vastVideoConfig,
+                broadcastIdentifier
                 );
     }
 
@@ -211,7 +209,7 @@ public void onInvalidate_shouldDisconnectListenerToBroadcastReceiver() throws Ex
     @Test
     public void onVastVideoConfigurationPrepared_withVastVideoConfiguration_shouldSignalOnInterstitialLoaded() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
-        ((VastVideoInterstitial) subject).onVastVideoConfigurationPrepared(mock(VastVideoConfiguration.class));
+        ((VastVideoInterstitial) subject).onVastVideoConfigurationPrepared(mock(VastVideoConfig.class));
 
         verify(customEventInterstitialListener).onInterstitialLoaded();
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java
new file mode 100644
index 00000000..9b857699
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java
@@ -0,0 +1,106 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.View;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.resource.ProgressBarDrawable;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoProgressBarWidgetTest {
+    private Context context;
+    private VastVideoProgressBarWidget subject;
+    private ProgressBarDrawable progressBarDrawableSpy;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new VastVideoProgressBarWidget(context, 0);
+        progressBarDrawableSpy = spy(subject.getImageViewDrawable());
+        subject.setImageViewDrawable(progressBarDrawableSpy);
+    }
+
+    @Test
+    public void calibrateAndMakeVisible_shouldSetDurationAndSkipOffsetAndMakeVisible() throws Exception {
+        subject.setVisibility(View.INVISIBLE);
+
+        subject.calibrateAndMakeVisible(10000, 5000);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(progressBarDrawableSpy).setDurationAndSkipOffset(10000, 5000);
+        assertThat(progressBarDrawableSpy.getSkipRatio()).isEqualTo(0.5f);
+    }
+
+    @Test
+    public void updateProgress_shouldUpdateDrawable() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+
+        subject.updateProgress(1000);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(progressBarDrawableSpy).setProgress(1000);
+        assertThat(progressBarDrawableSpy.getCurrentProgress()).isEqualTo(1000);
+    }
+
+    @Test
+    public void updateProgress_whenCurrentProgressGreaterThanPreviousProgress_shouldUpdateDrawable() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+
+        // Set mLastProgress to 1000
+        subject.updateProgress(1000);
+        reset(progressBarDrawableSpy);
+
+        subject.updateProgress(1001);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(progressBarDrawableSpy).setProgress(1001);
+        verify(progressBarDrawableSpy, never()).forceCompletion();
+        assertThat(progressBarDrawableSpy.getCurrentProgress()).isEqualTo(1001);
+    }
+
+    @Test
+    public void updateProgress_whenCurrentProgressLessThanPreviousProgressButNotZero_shouldForceProgressCompletionAndNotChangeVisibility() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+        subject.calibrateAndMakeVisible(10000, 5000);
+
+        // Set mLastProgress to 1000
+        subject.updateProgress(1000);
+        reset(progressBarDrawableSpy);
+
+        subject.updateProgress(999);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(progressBarDrawableSpy).setProgress(999);
+        verify(progressBarDrawableSpy).forceCompletion();
+        assertThat(progressBarDrawableSpy.getCurrentProgress()).isEqualTo(10000);
+    }
+
+    @Test
+    public void updateProgress_whenCurrentProgressLessThanPreviousProgressAndIsZero_shouldNotForceProgressCompletionAndNotChangeVisibility() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+        subject.calibrateAndMakeVisible(10000, 5000);
+
+        // Set mLastProgress to 1000
+        subject.updateProgress(1000);
+        reset(progressBarDrawableSpy);
+
+        subject.updateProgress(0);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(progressBarDrawableSpy).setProgress(0);
+        verify(progressBarDrawableSpy, never()).forceCompletion();
+        assertThat(progressBarDrawableSpy.getCurrentProgress()).isEqualTo(1000);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java
new file mode 100644
index 00000000..841f5c0d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java
@@ -0,0 +1,96 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.View;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.resource.RadialCountdownDrawable;
+
+import junit.framework.TestCase;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoRadialCountdownWidgetTest {
+    private Context context;
+    private VastVideoRadialCountdownWidget subject;
+    private RadialCountdownDrawable radialCountdownDrawableSpy;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new VastVideoRadialCountdownWidget(context);
+        radialCountdownDrawableSpy = spy(subject.getImageViewDrawable());
+        subject.setImageViewDrawable(radialCountdownDrawableSpy);
+    }
+
+    @Test
+    public void calibrateAndMakeVisible_shouldSetInitialCountdownAndMakeVisible() throws Exception {
+        subject.setVisibility(View.INVISIBLE);
+
+        subject.calibrateAndMakeVisible(10000);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(radialCountdownDrawableSpy).setInitialCountdown(10000);
+        assertThat(radialCountdownDrawableSpy.getInitialCountdownMilliseconds()).isEqualTo(10000);
+    }
+
+    @Test
+    public void updateCountdownProgress_shouldUpdateDrawable() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+
+        subject.updateCountdownProgress(10000, 1000);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(radialCountdownDrawableSpy).updateCountdownProgress(1000);
+    }
+
+    @Test
+    public void updateCountdownProgress_whenProgressIsGreaterThanInitialCountdown_shouldHideAndNotUpdateDrawable() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+
+        subject.updateCountdownProgress(10000, 10001);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.GONE);
+        verify(radialCountdownDrawableSpy, never()).updateCountdownProgress(anyInt());
+    }
+
+    @Test
+    public void updateCountdownProgress_whenCurrentProgressGreaterThanPreviousProgress_shouldUpdateDrawable() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+
+        // Set mLastProgressMilliseconds to 1000
+        subject.updateCountdownProgress(10000, 1000);
+        reset(radialCountdownDrawableSpy);
+
+        subject.updateCountdownProgress(10000, 1001);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(radialCountdownDrawableSpy).updateCountdownProgress(1001);
+    }
+
+    @Test
+    public void updateCountdownProgress_whenCurrentProgressLessThanPreviousProgress_shouldNotChangeVisibilityOrUpdateDrawable() throws Exception {
+        subject.setVisibility(View.VISIBLE);
+
+        // Set mLastProgressMilliseconds to 1000
+        subject.updateCountdownProgress(10000, 1000);
+        reset(radialCountdownDrawableSpy);
+
+        subject.updateCountdownProgress(10000, 999);
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(radialCountdownDrawableSpy, never()).updateCountdownProgress(anyInt());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
deleted file mode 100644
index f29f0a54..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
+++ /dev/null
@@ -1,186 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.view.View;
-import android.widget.TextView;
-
-import com.mopub.mobileads.resource.TextDrawable;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class VastVideoToolbarTest {
-    private Context context;
-    private VastVideoToolbar subject;
-    private View.OnTouchListener onTouchListener;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        subject = new VastVideoToolbar(context);
-
-        onTouchListener = mock(View.OnTouchListener.class);
-    }
-
-    @Test
-    public void constructor_shouldSetOnTouchListenerThatConsumesAllTouchEvents() throws Exception {
-        final View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
-
-        assertThat(onTouchListener).isNotNull();
-        assertThat(onTouchListener.onTouch(null, null)).isTrue();
-    }
-
-    @Test
-    public void constructor_shouldAddWidgetsToToolbar() throws Exception {
-        assertThat(subject.getChildCount()).isEqualTo(4);
-
-        assertThat(subject.getDurationWidget().getParent()).isEqualTo(subject);
-        assertThat(subject.getLearnMoreWidget().getParent()).isEqualTo(subject);
-        assertThat(subject.getCountdownWidget().getParent()).isEqualTo(subject);
-        assertThat(subject.getCloseButtonWidget().getParent()).isEqualTo(subject);
-    }
-    
-    @Test
-    public void constructor_shouldOnlyStartWithDurationWidgetsVisible() throws Exception {
-        assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getLearnMoreWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.GONE);
-    }
-
-    @Test
-    public void makeInteractable_shouldHideCountdownWidgetAndShowLearnMoreAndCloseButtonWidgets() throws Exception {
-        subject.makeInteractable();
-
-        assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getLearnMoreWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.GONE);
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.VISIBLE);
-    }
-
-    @Test
-    public void setCloseButtonOnTouchListener_shouldPropagateToCloseButtonWidget() throws Exception {
-        subject.setCloseButtonOnTouchListener(onTouchListener);
-
-        assertThat(shadowOf(subject.getCloseButtonWidget()).getOnTouchListener()).isEqualTo(onTouchListener);
-    }
-
-    @Test
-    public void setLearnButtonOnTouchListener_shouldPropagateToLearnButtonWidget() throws Exception {
-        subject.setLearnMoreButtonOnTouchListener(onTouchListener);
-
-        assertThat(shadowOf(subject.getLearnMoreWidget()).getOnTouchListener()).isEqualTo(onTouchListener);
-    }
-
-    @Test
-    public void getDisplaySeconds_shouldReturnLongMillisecondsAsRoundedUpStringSeconds() throws Exception {
-        assertThat(subject.getDisplaySeconds(0)).isEqualTo("0");
-
-        assertThat(subject.getDisplaySeconds(1)).isEqualTo("1");
-        assertThat(subject.getDisplaySeconds(999)).isEqualTo("1");
-        assertThat(subject.getDisplaySeconds(1000)).isEqualTo("1");
-
-        assertThat(subject.getDisplaySeconds(1001)).isEqualTo("2");
-        assertThat(subject.getDisplaySeconds(100000)).isEqualTo("100");
-    }
-    
-    @Test
-    public void updateCountdownWidget_shouldUpdateTextDrawablesDisplayNumber() throws Exception {
-        final TextDrawable countdownImageSpy = spy(subject.getCountdownWidget().getImageViewDrawable());
-        subject.getCountdownWidget().setImageViewDrawable(countdownImageSpy);
-
-        subject.updateCountdownWidget(1002);
-
-        verify(countdownImageSpy).updateText("2");
-    }
-
-    @Test
-    public void updateCountdownWidget_shouldHideCloseButtonAndShowCountdown() throws Exception {
-        subject.getCloseButtonWidget().setVisibility(View.INVISIBLE);
-        subject.getCountdownWidget().setVisibility(View.INVISIBLE);
-
-        subject.updateCountdownWidget(1);
-
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.GONE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.VISIBLE);
-    }
-
-    @Test
-    public void updateCountdownWidget_whenRemainingTimeIsNegative_shouldNotModifyWidgetVisibility() throws Exception {
-        subject.getCloseButtonWidget().setVisibility(View.INVISIBLE);
-        subject.getCountdownWidget().setVisibility(View.INVISIBLE);
-
-        subject.updateCountdownWidget(-1);
-
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-    }
-
-    @Test
-    public void updateDurationWidget_shouldShowWhenVideoEnds() throws Exception {
-        final TextView durationWidgetTextView = getDurationWidgetTextView();
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-
-        subject.updateDurationWidget(100000);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 100 seconds");
-
-        subject.updateDurationWidget(99000);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 99 seconds");
-    }
-
-    @Test
-    public void updateDurationWidget_whenBelowThresholdForHidingVideoDuration_shouldShowThanksForWatching() throws Exception {
-        final TextView durationWidgetTextView = getDurationWidgetTextView();
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-
-        subject.updateDurationWidget(50000);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 50 seconds");
-
-        // 200ms of remaining video is the cut off for switching to "Thanks for watching"
-        subject.updateDurationWidget(200);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 seconds");
-
-        subject.updateDurationWidget(199);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Thanks for watching");
-    }
-
-    @Test
-    public void updateDurationWidget_whenRemainingTimeIsNegative_shouldDoNothing() throws Exception {
-        final TextView durationWidgetTextView = getDurationWidgetTextView();
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-
-        subject.updateDurationWidget(-1);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-    }
-
-    private TextView getDurationWidgetTextView() {
-        final ToolbarWidget durationWidget = subject.getDurationWidget();
-        final int childCount = durationWidget.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            final View child = durationWidget.getChildAt(i);
-            if (child instanceof TextView) {
-                return (TextView) child;
-            }
-        }
-        return null;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
index 0b414074..773e6e1b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
@@ -1,113 +1,208 @@
 package com.mopub.mobileads;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.GradientDrawable;
-import android.graphics.drawable.LayerDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.media.MediaMetadataRetriever;
 import android.media.MediaPlayer;
+import android.net.Uri;
+import android.os.AsyncTask;
 import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
 import android.view.View;
-import android.view.ViewGroup;
 import android.webkit.WebView;
 import android.widget.ImageView;
 import android.widget.VideoView;
+
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Drawables;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
 import com.mopub.mobileads.test.support.GestureUtils;
-import com.mopub.mobileads.util.vast.VastCompanionAd;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.mobileads.test.support.ShadowVastVideoView;
+import com.mopub.mobileads.test.support.VastUtils;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
 import org.apache.http.HttpRequest;
 import org.apache.maven.artifact.ant.shaded.ReflectionUtils;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowImageView;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.shadows.ShadowRelativeLayout;
+import org.robolectric.shadows.ShadowTextView;
 import org.robolectric.shadows.ShadowVideoView;
 import org.robolectric.tester.org.apache.http.RequestMatcher;
 import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
-import java.io.*;
-import java.util.*;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
 
-import static android.media.MediaPlayer.OnPreparedListener;
-import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
-import static com.mopub.common.MoPubBrowser.DESTINATION_URL_KEY;
-import static com.mopub.common.util.test.support.CommonUtils.assertHttpRequestsMade;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.mobileads.VastVideoViewController.CURRENT_POSITION;
 import static com.mopub.mobileads.VastVideoViewController.DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
-import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
+import static com.mopub.mobileads.VastVideoViewController.RESUMED_VAST_CONFIG;
+import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIG;
+import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.shadowOf;
+import static org.robolectric.Robolectric.shadowOf_;
 
 @RunWith(SdkTestRunner.class)
+@Config(shadows = {ShadowVastVideoView.class})
 public class VastVideoViewControllerTest {
-    public static final int NETWORK_DELAY = 500;
-    private MediaPlayer mediaPlayer;
+    public static final int NETWORK_DELAY = 100;
+
+    private static final String COMPANION_IMAGE_URL = "companion_image_url";
+    private static final String COMPANION_CLICK_TRACKING_URL_1 = "companion_click_tracking_url_1";
+    private static final String COMPANION_CLICK_TRACKING_URL_2 = "companion_click_tracking_url_2";
+    private static final String COMPANION_CLICK_TRACKING_URL_3 = "companion_click_tracking_url_3";
+    private static final String COMPANION_CLICK_DESTINATION_URL = "http://companion_click_destination_url";
+    private static final String COMPANION_CREATIVE_VIEW_URL_1 = "companion_creative_view_url_1";
+    private static final String COMPANION_CREATIVE_VIEW_URL_2 = "companion_creative_view_url_2";
+    private static final String COMPANION_CREATIVE_VIEW_URL_3 = "companion_creative_view_url_3";
+    private static final String RESOLVED_CLICKTHROUGH_URL = "http://www.mopub.com/";
+    private static final String CLICKTHROUGH_URL = "deeplink+://navigate?" +
+            "&primaryUrl=bogus%3A%2F%2Furl" +
+            "&fallbackUrl=" + Uri.encode(RESOLVED_CLICKTHROUGH_URL);
+
+    /**
+     * A list of macros to include in all trackers
+     */
+    private static final String MACRO_TAGS = "?errorcode=[ERRORCODE]&asseturi=[ASSETURI]&contentplayhead=[CONTENTPLAYHEAD]";
+
     private Context context;
     private Bundle bundle;
+    private Bundle savedInstanceState;
     private long testBroadcastIdentifier;
     private VastVideoViewController subject;
-    private BaseVideoViewControllerListener baseVideoViewControllerListener;
-    private EventForwardingBroadcastReceiver broadcastReceiver;
     private int expectedBrowserRequestCode;
     private String expectedUserAgent;
 
+    @Mock private BaseVideoViewControllerListener baseVideoViewControllerListener;
+    @Mock private EventForwardingBroadcastReceiver broadcastReceiver;
+    @Mock MoPubRequestQueue mockRequestQueue;
+    @Mock MaxWidthImageLoader mockImageLoader;
+    @Mock private VastIconConfig mMockVastIconConfig;
+    @Mock private MediaMetadataRetriever mockMediaMetadataRetriever;
+    @Mock private Bitmap mockBitmap;
+
+    private VastVideoViewCountdownRunnable spyCountdownRunnable;
+    private VastVideoViewProgressRunnable spyProgressRunnable;
+    private VideoView spyVideoView;
+
+    @TargetApi(VERSION_CODES.GINGERBREAD_MR1)
     @Before
     public void setUp() throws Exception {
-        mediaPlayer = mock(MediaPlayer.class);
-        context = new Activity();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         bundle = new Bundle();
+        savedInstanceState = new Bundle();
         testBroadcastIdentifier = 1111;
-        broadcastReceiver = mock(EventForwardingBroadcastReceiver.class);
-        baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setNetworkMediaFileUrl("video_url");
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("mid"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
-        vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        vastVideoConfiguration.setClickThroughUrl("clickThrough");
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
-
-        VastCompanionAd vastCompanionAd = new VastCompanionAd(
+
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addAbsoluteTrackers(
+                Arrays.asList(new VastAbsoluteProgressTracker("start" + MACRO_TAGS, 2000)));
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f),
+                        new VastFractionalProgressTracker("mid" + MACRO_TAGS, 0.5f),
+                        new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
+        vastVideoConfig.addPauseTrackers(
+                Arrays.asList(new VastTracker("pause" + MACRO_TAGS, true)));
+        vastVideoConfig.addResumeTrackers(
+                Arrays.asList(new VastTracker("resume" + MACRO_TAGS, true)));
+        vastVideoConfig.addCompleteTrackers(
+                VastUtils.stringsToVastTrackers("complete" + MACRO_TAGS));
+        vastVideoConfig.addCloseTrackers(
+                VastUtils.stringsToVastTrackers("close" + MACRO_TAGS));
+        vastVideoConfig.addSkipTrackers(VastUtils.stringsToVastTrackers("skip" + MACRO_TAGS));
+        vastVideoConfig.addImpressionTrackers(
+                VastUtils.stringsToVastTrackers("imp" + MACRO_TAGS));
+        vastVideoConfig.addErrorTrackers(
+                Collections.singletonList(new VastTracker("error" + MACRO_TAGS)));
+        vastVideoConfig.setClickThroughUrl(CLICKTHROUGH_URL);
+        vastVideoConfig.addClickTrackers(
+                VastUtils.stringsToVastTrackers("click_1" + MACRO_TAGS, "click_2" + MACRO_TAGS));
+
+        VastCompanionAdConfig landscapeVastCompanionAdConfig = new VastCompanionAdConfig(
                 300,
                 250,
-                "companion_image_url",
-                "companion_click_destination_url",
-                new ArrayList<String>(Arrays.asList("companion_click_tracking_url_1", "companion_click_tracking_url_2"))
+                new VastResource(COMPANION_IMAGE_URL,
+                        VastResource.Type.STATIC_RESOURCE,
+                        VastResource.CreativeType.IMAGE, 300, 250),
+                COMPANION_CLICK_DESTINATION_URL,
+                VastUtils.stringsToVastTrackers(COMPANION_CLICK_TRACKING_URL_1, COMPANION_CLICK_TRACKING_URL_2),
+                VastUtils.stringsToVastTrackers(COMPANION_CREATIVE_VIEW_URL_1, COMPANION_CREATIVE_VIEW_URL_2)
+        );
+        VastCompanionAdConfig portraitVastCompanionAdConfig = new VastCompanionAdConfig(
+                250,
+                300,
+                new VastResource(COMPANION_IMAGE_URL,
+                        VastResource.Type.STATIC_RESOURCE,
+                        VastResource.CreativeType.IMAGE, 250, 300),
+                COMPANION_CLICK_DESTINATION_URL,
+                VastUtils.stringsToVastTrackers(COMPANION_CLICK_TRACKING_URL_3),
+                VastUtils.stringsToVastTrackers(COMPANION_CREATIVE_VIEW_URL_3)
         );
-        vastVideoConfiguration.setVastCompanionAd(vastCompanionAd);
+        vastVideoConfig.setVastCompanionAd(landscapeVastCompanionAdConfig,
+                portraitVastCompanionAdConfig);
+
+        when(mMockVastIconConfig.getWidth()).thenReturn(40);
+        when(mMockVastIconConfig.getHeight()).thenReturn(40);
+        VastResource vastResource = mock(VastResource.class);
+        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
+        when(vastResource.getResource()).thenReturn("static");
+        when(vastResource.getCreativeType()).thenReturn(VastResource.CreativeType.IMAGE);
+        when(mMockVastIconConfig.getVastResource()).thenReturn(vastResource);
+        vastVideoConfig.setVastIconConfig(mMockVastIconConfig);
 
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        when(mockMediaMetadataRetriever.getFrameAtTime(anyLong(), anyInt())).thenReturn(mockBitmap);
+
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         expectedBrowserRequestCode = 1;
 
@@ -115,6 +210,7 @@ public void setUp() throws Exception {
         Robolectric.getBackgroundScheduler().pause();
         Robolectric.clearPendingHttpResponses();
 
+        // Used to give responses to Vast Download Tasks.
         Robolectric.addHttpResponseRule(new RequestMatcher() {
             @Override
             public boolean matches(HttpRequest request) {
@@ -131,44 +227,94 @@ public boolean matches(HttpRequest request) {
     public void tearDown() throws Exception {
         Robolectric.getUiThreadScheduler().reset();
         Robolectric.getBackgroundScheduler().reset();
-        Robolectric.clearPendingHttpResponses();
 
         ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
     }
 
     @Test
-    public void constructor_shouldPingImpressionTrackers() throws Exception {
-        // XXX this test needs to be at the top of the constructor tests since it checks for async
-        // http requests. If it's below any other constructor tests, there is a chance outstanding
-        // async requests will not run until this tests starts, thus polluting the http requests
+    public void constructor_shouldAddCtaButtonWidgetToLayoutAndSetInvisibleWithOnTouchListeners() throws Exception {
+        initializeSubject();
 
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        VastVideoCtaButtonWidget ctaButtonWidget = subject.getCtaButtonWidget();
+        assertThat(ctaButtonWidget.getParent()).isEqualTo(subject.getLayout());
+        assertThat(ctaButtonWidget.getVisibility()).isEqualTo(View.INVISIBLE);
+        ShadowImageView ctaButtonWidgetShadow = shadowOf(ctaButtonWidget);
+        assertThat(ctaButtonWidgetShadow.getOnTouchListener()).isNotNull();
+        assertThat(ctaButtonWidgetShadow.getOnTouchListener()).isEqualTo(
+                getShadowVideoView().getOnTouchListener());
+    }
 
+    @Test
+    public void constructor_shouldAddProgressBarWidgetToLayoutAndSetInvisibleWithNoListeners() throws Exception {
         initializeSubject();
 
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+        VastVideoProgressBarWidget progressBarWidget = subject.getProgressBarWidget();
+        assertThat(progressBarWidget.getParent()).isEqualTo(subject.getLayout());
+        assertThat(progressBarWidget.getVisibility()).isEqualTo(View.INVISIBLE);
+        ShadowImageView progressBarWidgetShadow = shadowOf(progressBarWidget);
+        assertThat(progressBarWidgetShadow.getOnTouchListener()).isNull();
+    }
+
+    @Test
+    public void constructor_shouldAddRadialCountdownWidgetToLayoutAndSetInvisibleWithNoListeners() throws Exception {
+        initializeSubject();
+
+        VastVideoRadialCountdownWidget radialCountdownWidget = subject.getRadialCountdownWidget();
+        assertThat(radialCountdownWidget.getParent()).isEqualTo(subject.getLayout());
+        assertThat(radialCountdownWidget.getVisibility()).isEqualTo(View.INVISIBLE);
+        ShadowImageView radialCountdownWidgetShadow = shadowOf(radialCountdownWidget);
+        assertThat(radialCountdownWidgetShadow.getOnTouchListener()).isNull();
+    }
+
+    @Test
+    public void constructor_shouldAddCloseButtonWidgetToLayoutAndSetToGoneWithOnTouchListeners() throws Exception {
+        initializeSubject();
+
+        VastVideoCloseButtonWidget closeButtonWidget = subject.getCloseButtonWidget();
+        assertThat(closeButtonWidget.getParent()).isEqualTo(subject.getLayout());
+        assertThat(closeButtonWidget.getVisibility()).isEqualTo(View.GONE);
+
+        ShadowRelativeLayout closeButtonWidgetShadow = (ShadowRelativeLayout) shadowOf(closeButtonWidget);
+        assertThat(closeButtonWidgetShadow.getOnTouchListener()).isNull();
+
+        ShadowImageView closeButtonImageViewShadow = shadowOf(closeButtonWidget.getImageView());
+        assertThat(closeButtonImageViewShadow.getOnTouchListener()).isNotNull();
+
+        ShadowTextView closeButtonTextViewShadow = shadowOf(closeButtonWidget.getTextView());
+        assertThat(closeButtonTextViewShadow.getOnTouchListener()).isNotNull();
+    }
 
-        assertHttpRequestsMade(expectedUserAgent, "imp");
+    @Test
+    public void constructor_shouldAddTopGradientStripWidgetToLayoutWithNoListeners() throws Exception {
+        initializeSubject();
+
+        VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
+        assertThat(topGradientStripWidget.getParent()).isEqualTo(subject.getLayout());
+
+        ShadowImageView topGradientStripWidgetShadow = shadowOf(topGradientStripWidget);
+        assertThat(topGradientStripWidgetShadow.getOnTouchListener()).isNull();
     }
 
     @Test
-    public void constructor_shouldAddVastVideoToolbarToLayout() throws Exception {
+    public void constructor_shouldAddBottomGradientStripWidgetToLayoutWithNoListeners() throws Exception {
         initializeSubject();
 
-        VastVideoToolbar vastVideoToolbar = getVastVideoToolbar();
-        final ViewGroup.LayoutParams layoutParams = vastVideoToolbar.getLayoutParams();
+        VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
+        assertThat(bottomGradientStripWidget.getParent()).isEqualTo(subject.getLayout());
 
-        assertThat(vastVideoToolbar.getParent()).isEqualTo(subject.getLayout());
-        assertThat(vastVideoToolbar.getVisibility()).isEqualTo(View.VISIBLE);
+        ShadowImageView bottomGradientStripWidgetShadow = shadowOf(bottomGradientStripWidget);
+        assertThat(bottomGradientStripWidgetShadow.getOnTouchListener()).isNull();
+    }
+
+    @Test
+    public void constructor_shouldAddBlurredLastVideoFrameWidgetToLayoutAndSetInvisibleWithNoListeners() throws Exception {
+        initializeSubject();
 
-        assertThat(layoutParams.width).isEqualTo(MATCH_PARENT);
-        assertThat(layoutParams.height).isEqualTo(Dips.dipsToIntPixels(44, context));
+        ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
+        assertThat(blurredLastVideoFrameImageView.getParent()).isEqualTo(subject.getLayout());
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+        ShadowImageView blurredLastVideoFrameImageViewShadow = shadowOf(blurredLastVideoFrameImageView);
+        assertThat(blurredLastVideoFrameImageViewShadow.getOnTouchListener()).isNull();
     }
 
     @Test
@@ -189,22 +335,19 @@ public void constructor_shouldSetVideoListenersAndVideoPath() throws Exception {
     public void constructor_shouldNotChangeCloseButtonDelay() throws Exception {
         initializeSubject();
 
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
     }
 
+    @TargetApi(VERSION_CODES.HONEYCOMB)
     @Test
-    public void constructor_shouldAddThatchedBackgroundWithGradientToLayout() throws Exception {
+    public void constructor_shouldAddBlackBackgroundToLayout() throws Exception {
         initializeSubject();
-        ViewGroup viewGroup = subject.getLayout();
-        LayerDrawable layerDrawable = (LayerDrawable) viewGroup.getBackground();
-        assertThat(layerDrawable.getDrawable(0)).isEqualTo(Drawables.THATCHED_BACKGROUND.decodeImage(context));
-        assertThat(layerDrawable.getDrawable(1)).isEqualTo(
-                new GradientDrawable(
-                        GradientDrawable.Orientation.TOP_BOTTOM,
-                        new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)})
-        );
+        Drawable background = subject.getLayout().getBackground();
+        assertThat(background).isInstanceOf(ColorDrawable.class);
+        assertThat(((ColorDrawable) background).getColor()).isEqualTo(Color.BLACK);
     }
-    
+
     @Test
     public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStateException() throws Exception {
         bundle.clear();
@@ -218,7 +361,7 @@ public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStat
 
     @Test
     public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThrowIllegalStateException() throws Exception {
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, new VastVideoConfiguration());
+        bundle.putSerializable(VAST_VIDEO_CONFIG, new VastVideoConfig());
         try {
             initializeSubject();
             fail("VastVideoViewController didn't throw IllegalStateException");
@@ -227,81 +370,250 @@ public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThr
         }
     }
 
+    @Test
+    public void constructor_whenCustomCtaTextNotSpecified_shouldUseDefaultCtaText() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        assertThat(subject.getCtaButtonWidget().getCtaText()).isEqualTo(
+                "Learn More");
+    }
+
+    @Test
+    public void constructor_whenCustomCtaTextSpecified_shouldUseCustomCtaText() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setCustomCtaText("custom CTA text");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        assertThat(subject.getCtaButtonWidget().getCtaText()).isEqualTo(
+                "custom CTA text");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextNotSpecified_shouldUseDefaultSkipText() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        assertThat(subject.getCloseButtonWidget().getTextView().getText().toString()).isEqualTo(
+                "");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextSpecified_shouldUseCustomSkipText() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setCustomSkipText("custom skip text");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        assertThat(subject.getCloseButtonWidget().getTextView().getText().toString()).isEqualTo(
+                "custom skip text");
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconNotSpecified_shouldUseDefaultCloseIcon() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        Drawable imageViewDrawable = subject.getCloseButtonWidget().getImageView().getDrawable();
+
+        // Default close icon is an instance of CloseButtonDrawable
+        assertThat(imageViewDrawable).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconSpecified_shouldUseCustomCloseIcon() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setCustomCloseIconUrl(
+                "http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        verify(mockImageLoader).get(
+                eq("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png"),
+                any(ImageListener.class));
+    }
+
+    @Test
+    public void constructor_withVastConfigurationInSavedInstanceState_shouldUseThatVastConfiguration() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setNetworkMediaFileUrl("resumed_network_media_url");
+        savedInstanceState.putSerializable(RESUMED_VAST_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        assertThat(subject.getNetworkMediaFileUrl()).isEqualTo("resumed_network_media_url");
+    }
+
+    @Test
+    public void constructor_withSavedVastConfiguration_shouldUseThatVastConfiguration() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setNetworkMediaFileUrl("resumed_network_media_url");
+        savedInstanceState.putSerializable(RESUMED_VAST_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        assertThat(subject.getNetworkMediaFileUrl()).isEqualTo("resumed_network_media_url");
+    }
+
+    @Test
+    public void constructor_withSavedVastConfiguration_withCurrentPositionSet_shouldResumeVideoFromCurrentPosition() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setNetworkMediaFileUrl("resumed_network_media_url");
+        savedInstanceState.putSerializable(RESUMED_VAST_CONFIG, vastVideoConfig);
+        savedInstanceState.putInt(CURRENT_POSITION, 123);
+
+        initializeSubject();
+        spyOnVideoView();
+
+        subject.onResume();
+
+        verify(spyVideoView).seekTo(eq(123));
+    }
+
+    @Test
+    public void onCreate_shouldFireImpressionTracker() throws Exception {
+        initializeSubject();
+
+        subject.onCreate();
+        verify(mockRequestQueue).add(
+                argThat(isUrl("imp?errorcode=&asseturi=video_url&contentplayhead=00:00:00.000")));
+    }
+
     @Test
     public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
 
         initializeSubject();
 
-        subject.onCreate();
         Robolectric.getUiThreadScheduler().unPause();
-
+        subject.onCreate();
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
     @Test
-    public void onCreate_withCompanionAd_shouldDownloadCompanionAd() throws Exception {
+    public void onCreate_whenCustomForceOrientationNotSpecified_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
         initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(
+                SCREEN_ORIENTATION_LANDSCAPE);
+    }
 
-        final ImageView imageView = subject.getCompanionAdImageView();
-        assertThat(imageView.getDrawable()).isNull();
+    @Test
+    public void onCreate_whenCustomForceOrientationIsDeviceOrientation_shouldNotForceLandscapeOrientation() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setCustomForceOrientation(ForceOrientation.DEVICE_ORIENTATION);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
+        initializeSubject();
         subject.onCreate();
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
+        verify(baseVideoViewControllerListener, never()).onSetRequestedOrientation(anyInt());
     }
 
     @Test
-    public void onComplete_withNullDownloadResponse_shouldNotSetCompanionAdImageBitmap() throws Exception {
+    public void onCreate_whenCustomForceOrientationIsPortraitOrientation_shouldForcePortraitOrientation() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setCustomForceOrientation(ForceOrientation.FORCE_PORTRAIT);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
         initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(
+                SCREEN_ORIENTATION_PORTRAIT);
+    }
 
-        final ImageView imageView = subject.getCompanionAdImageView();
-        assertThat(imageView.getDrawable()).isNull();
+    @Test
+    public void onCreate_whenCustomForceOrientationIsLandscapeOrientation_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setCustomForceOrientation(ForceOrientation.FORCE_LANDSCAPE);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        subject.onComplete("url", null);
+        initializeSubject();
+        subject.onCreate();
 
-        assertThat(imageView.getDrawable()).isNull();
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(
+                SCREEN_ORIENTATION_LANDSCAPE);
     }
 
     @Test
-    public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMoPubBrowser() throws Exception {
+    public void VastWebView_onVastWebViewClick_shouldCallVastCompanionAdHandleClick() throws Exception {
         initializeSubject();
 
-        final ImageView imageView = subject.getCompanionAdImageView();
-        assertThat(imageView.performClick()).isFalse();
-        subject.onCreate();
+        VastCompanionAdConfig vastCompanionAdConfig = mock(VastCompanionAdConfig.class);
+        when(vastCompanionAdConfig.getWidth()).thenReturn(300);
+        when(vastCompanionAdConfig.getHeight()).thenReturn(240);
+        VastResource vastResource = mock(VastResource.class);
+        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
+        when(vastResource.getResource()).thenReturn("static");
+        when(vastCompanionAdConfig.getVastResource()).thenReturn(vastResource);
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+        VastWebView view = (VastWebView) subject.createCompanionAdView(context,
+                vastCompanionAdConfig, View.INVISIBLE);
 
-        assertThat(imageView.performClick()).isTrue();
-        Thread.sleep(NETWORK_DELAY);
+        view.getVastWebViewClickListener().onVastWebViewClick();
+        verify(vastCompanionAdConfig).handleClick(any(Context.class), eq(1), anyString());
+    }
 
-        assertHttpRequestsMade(
-                expectedUserAgent,
-                "companion_image_url",
-                "imp",
-                "companion_click_tracking_url_1",
-                "companion_click_tracking_url_2"
-        );
+    @Test
+    public void createCompanionAdView_shouldLayoutAndReturnInvisibleVastIconView() throws Exception {
+        initializeSubject();
 
-        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
-        verify(baseVideoViewControllerListener).onStartActivityForResult(
-                eq(MoPubBrowser.class),
-                eq(expectedBrowserRequestCode),
-                bundleCaptor.capture()
-        );
+        VastCompanionAdConfig vastCompanionAdConfig = mock(VastCompanionAdConfig.class);
+        when(vastCompanionAdConfig.getWidth()).thenReturn(300);
+        when(vastCompanionAdConfig.getHeight()).thenReturn(240);
+        VastResource vastResource = mock(VastResource.class);
+        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
+        when(vastResource.getResource()).thenReturn("static");
+        when(vastCompanionAdConfig.getVastResource()).thenReturn(vastResource);
+
+        VastWebView view = (VastWebView) subject.createCompanionAdView(context,
+                vastCompanionAdConfig, View.INVISIBLE);
+
+        assertThat(view).isNotNull();
+        assertThat(view.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(view.getVastWebViewClickListener()).isNotNull();
+        assertThat(subject.getLayout().findViewById(view.getId())).isEqualTo(view);
+    }
+
+    @Test
+    public void createCompanionAdView_withNullCompanionAd_shouldReturnEmptyView() throws Exception {
+        initializeSubject();
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("companion_click_destination_url");
+        assertThat(subject.createCompanionAdView(context, null, View.INVISIBLE)).isNotNull();
     }
 
     @Test
     public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS,
+                testBroadcastIdentifier);
 
         initializeSubject();
 
@@ -311,6 +623,57 @@ public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
+    @Test
+    public void onDestroy_withBlurLastVideoFrameTaskStillRunning_shouldCancelTask() throws Exception {
+        initializeSubject();
+
+        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(VastVideoBlurLastVideoFrameTask.class);
+        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.RUNNING);
+        subject.getVastVideoView().setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
+
+        subject.onDestroy();
+
+        verify(mockBlurLastVideoFrameTask).cancel(true);
+    }
+
+    @Test
+    public void onDestroy_withBlurLastVideoFrameTaskStillPending_shouldCancelTask() throws Exception {
+        initializeSubject();
+
+        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(VastVideoBlurLastVideoFrameTask.class);
+        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.PENDING);
+        subject.getVastVideoView().setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
+
+        subject.onDestroy();
+
+        verify(mockBlurLastVideoFrameTask).cancel(true);
+    }
+
+    @Test
+    public void onDestroy_withBlurLastVideoFrameTaskFinished_shouldNotCancelTask() throws Exception {
+        initializeSubject();
+
+        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(VastVideoBlurLastVideoFrameTask.class);
+        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.FINISHED);
+        subject.getVastVideoView().setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
+
+        subject.onDestroy();
+
+        verify(mockBlurLastVideoFrameTask, never()).cancel(anyBoolean());
+    }
+
+    @Test
+    public void onSaveInstanceState_shouldSetCurrentPosition_shouldSetVastConfiguration() throws Exception {
+        initializeSubject();
+
+        Bundle bundle = mock(Bundle.class);
+        subject.onSaveInstanceState(bundle);
+
+        verify(bundle).putInt(eq(CURRENT_POSITION), anyInt());
+        verify(bundle).putSerializable(eq(RESUMED_VAST_CONFIG), any(VastVideoConfig
+                .class));
+    }
+
     @Test
     public void onActivityResult_shouldCallFinish() throws Exception {
         final int expectedResultCode = Activity.RESULT_OK;
@@ -345,14 +708,12 @@ public void onActivityResult_withIncorrectResultCode_shouldNotCallFinish() throw
         verify(baseVideoViewControllerListener, never()).onFinish();
     }
 
-
     @Test
     public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_shouldDoNothing() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(15999);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(15990);
-
         initializeSubject();
-        setMediaPlayer(mediaPlayer);
+        spyOnVideoView();
+        setVideoViewParams(15990, 15999);
+
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -364,39 +725,35 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_sho
     }
 
     @Test
-    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMoPubBrowser() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(15999);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(16000);
-
+    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldTrackClick_shouldStartMoPubBrowser() throws Exception {
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(15999, 15999);
         subject.onResume();
 
-        setMediaPlayer(mediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
-        verify(baseVideoViewControllerListener).onStartActivityForResult(
-                eq(MoPubBrowser.class),
-                eq(expectedBrowserRequestCode),
-                bundleCaptor.capture()
-        );
-
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("clickThrough");
+        Robolectric.runBackgroundTasks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(
+                RESOLVED_CLICKTHROUGH_URL);
+        verify((Activity) context).startActivityForResult(any(Intent.class),
+                eq(expectedBrowserRequestCode));
     }
 
     @Test
     public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seconds_shouldDoNothing() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(4999);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(4999, 100000);
         subject.onResume();
 
-        setMediaPlayer(mediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -409,71 +766,75 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seco
 
     @Test
     public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(5001);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(5001, 100000);
         subject.onResume();
 
-        setMediaPlayer(mediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
-        verify(baseVideoViewControllerListener).onStartActivityForResult(
-                eq(MoPubBrowser.class),
-                eq(expectedBrowserRequestCode),
-                bundleCaptor.capture()
-        );
-
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("clickThrough");
+        Robolectric.runBackgroundTasks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(
+                RESOLVED_CLICKTHROUGH_URL);
+        verify((Activity) context).startActivityForResult(any(Intent.class),
+                eq(expectedBrowserRequestCode));
     }
 
     @Test
     public void onTouch_whenCloseButtonVisible_shouldPingClickThroughTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addClickTrackers(
+                VastUtils.stringsToVastTrackers("click_1" + MACRO_TAGS, "click_2" + MACRO_TAGS));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        // Because it's almost never exactly 15 seconds
+        when(spyVideoView.getDuration()).thenReturn(15142);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
 
         subject.setCloseButtonVisible(true);
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        assertHttpRequestsMade(expectedUserAgent, "click_1", "click_2");
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "click_1?errorcode=&asseturi=video_url&contentplayhead=00:00:15.142")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "click_2?errorcode=&asseturi=video_url&contentplayhead=00:00:15.142")));
     }
 
     @Test
     public void onTouch_whenCloseButtonNotVisible_shouldNotPingClickThroughTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addClickTrackers(VastUtils.stringsToVastTrackers("click_1",
+                "click_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
 
         subject.setCloseButtonVisible(false);
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
         assertThat(Robolectric.httpRequestWasMade()).isFalse();
     }
 
     @Test
     public void onTouch_withNullBaseVideoViewListener_andActionTouchUp_shouldReturnTrueAndNotBlowUp() throws Exception {
-        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, null);
+        subject = new VastVideoViewController((Activity) context, bundle, null,
+                testBroadcastIdentifier, null);
 
-        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(
+                0, 0));
 
         // pass
 
@@ -484,7 +845,8 @@ public void onTouch_withNullBaseVideoViewListener_andActionTouchUp_shouldReturnT
     public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Exception {
         initializeSubject();
 
-        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionDown(0, 0));
+        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionDown(
+                0, 0));
 
         assertThat(result).isTrue();
     }
@@ -492,14 +854,10 @@ public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Except
     @Test
     public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shouldSetShowCloseButtonDelayToDuration() throws Exception {
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 1000);
 
-        stub(mediaPlayer.getDuration()).toReturn(1000);
-        setMediaPlayer(mediaPlayer);
-
-        // this callback is typically called when the media filed is loaded and ready to play
-        // invoke this manually since we are using a mock url and don't want to wait
-        final OnPreparedListener onPreparedListener = getShadowVideoView().getOnPreparedListener();
-        onPreparedListener.onPrepared(null);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         assertThat(subject.getShowCloseButtonDelay()).isEqualTo(1000);
     }
@@ -507,471 +865,920 @@ public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shou
     @Test
     public void onPrepared_whenDurationIsGreaterThanMaxVideoDurationForCloseButton_shouldNotSetShowCloseButtonDelay() throws Exception {
         initializeSubject();
-
-        stub(mediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMediaPlayer(mediaPlayer);
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
     }
 
     @Test
-    public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
+    public void onPrepared_whenPercentSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("25%");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
 
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(subject.isVideoFinishedPlaying()).isTrue();
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
     }
 
     @Test
-    public void onCompletion_shouldPingCompletionTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+    public void onPrepared_whenAbsoluteSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
 
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertHttpRequestsMade(expectedUserAgent, "complete_1", "complete_2");
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
     }
 
     @Test
-    public void onCompletion_shouldPreventOnResumeFromStartingVideo() throws Exception {
-        initializeSubject();
+    public void onPrepared_whenAbsoluteSkipOffsetWithMillisecondsSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:03.141");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
 
-        subject.onResume();
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(getShadowVideoView().isPlaying()).isFalse();
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3141);
+        assertThat(subject.getHasSkipOffset()).isTrue();
     }
 
     @Test
-    public void onCompletion_shouldStopProgressChecker() throws Exception {
-        initializeSubject();
-        subject.onResume();
+    public void onPrepared_whenSkipOffsetIsNull_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset(null);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
     @Test
-    public void onCompletion_shouldDisplayCompanionAdIfAvailable() throws Exception {
+    public void onPrepared_whenSkipOffsetHasInvalidAbsoluteFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("123:4:56.7");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
         initializeSubject();
-        subject.onCreate();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        final ImageView imageView = subject.getCompanionAdImageView();
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
 
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("101%");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.GONE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
     @Test
-    public void onCompletion_shouldShowThatchedBackground() throws Exception {
-        initializeSubject();
-
-        final ImageView imageView = subject.getCompanionAdImageView();
+    public void onPrepared_whenSkipOffsetHasInvalidFractionalPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("3.14%");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.GONE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
     @Test
-    public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
-        initializeSubject();
+    public void onPrepared_whenSkipOffsetIsNegative_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("-00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
-        boolean result = getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-        Robolectric.getUiThreadScheduler().unPause();
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(result).isFalse();
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
     @Test
-    public void onError_shouldStopProgressChecker() throws Exception {
-        initializeSubject();
-        subject.onResume();
+    public void onPrepared_whenSkipOffsetIsZero_shouldSetShowCloseButtonDelayToZero() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:00");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
-        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(0);
+        assertThat(subject.getHasSkipOffset()).isTrue();
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
     @Test
-    public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayingTheVideo() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForShortVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:11");   // 11s
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);    // 10s: short video
 
-        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(-1);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        getShadowVideoView().getOnErrorListener().onError(new MediaPlayer(), 1, Integer.MIN_VALUE);
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(10 * 1000);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
 
-        assertThat(getShadowVideoView().isPlaying()).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForLongVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:21");   // 21s
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        file.delete();
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 20000);    // 20s: long video
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
+                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
     @Test
-    public void retryMediaPlayer_withVideoFilePermissionErrorAndBelowJellyBean_shouldReturnTrue() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
+    public void onPrepared_shouldCalibrateAndMakeVisibleRadialCountdownWidget() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:05");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        final VastVideoRadialCountdownWidget radialCountdownWidgetSpy = spy(subject.getRadialCountdownWidget());
+        subject.setRadialCountdownWidget(radialCountdownWidgetSpy);
+
+        assertThat(subject.isCalibrationDone()).isFalse();
+        assertThat(radialCountdownWidgetSpy.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.isCalibrationDone()).isTrue();
+        assertThat(radialCountdownWidgetSpy.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(radialCountdownWidgetSpy).calibrateAndMakeVisible(5000);
+    }
 
+    @Test
+    public void onPrepared_shouldCalibrateAndMakeVisibleProgressBarWidget() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:05");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
 
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
+        final VastVideoProgressBarWidget progressBarWidgetSpy = spy(subject.getProgressBarWidget());
+        subject.setProgressBarWidget(progressBarWidgetSpy);
 
-        file.delete();
+        assertThat(subject.isCalibrationDone()).isFalse();
+        assertThat(progressBarWidgetSpy.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.isCalibrationDone()).isTrue();
+        assertThat(progressBarWidgetSpy.getVisibility()).isEqualTo(View.VISIBLE);
+        verify(progressBarWidgetSpy).calibrateAndMakeVisible(10000, 5000);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Config(reportSdk = VERSION_CODES.GINGERBREAD)
     @Test
-    public void retryMediaPlayer_shouldNotRunMoreThanOnce() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
+    public void onPrepared_beforeGingerbreadMr1_shouldNotSetBlurredLastVideoFrame() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
 
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
 
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
+        assertThat(subject.getBlurredLastVideoFrameImageView().getDrawable()).isNull();
 
-        file.delete();
+        ShadowImageView imageView = shadowOf(subject.getBlurredLastVideoFrameImageView());
+        assertThat(imageView.getOnTouchListener()).isNull();
     }
 
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN)
+    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
-    public void retryMediaPlayer_withAndroidVersionAboveJellyBean_shouldReturnFalse() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
+    public void onPrepared_atLeastGingerbreadMr1_shouldSetBlurredLastVideoFrame() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
 
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
 
-        file.delete();
+        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
+        assertThat(blurredLastVideoFrameImageView.getDrawable()).isInstanceOf(BitmapDrawable.class);
+        assertThat(
+                ((BitmapDrawable) blurredLastVideoFrameImageView.getDrawable()).getBitmap()).isNotNull();
+
+        ShadowImageView imageView = shadowOf(subject.getBlurredLastVideoFrameImageView());
+        assertThat(imageView.getOnTouchListener()).isNull();
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
-    public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
+    public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
+        initializeSubject();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.isVideoFinishedPlaying()).isTrue();
+    }
+
+    @Test
+    public void onCompletion_whenAllTrackersTracked_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker(
+                "testUrl" + MACRO_TAGS, 123);
+        vastVideoConfig.addAbsoluteTrackers(Arrays.asList(testTracker));
+        vastVideoConfig.addCompleteTrackers(
+                VastUtils.stringsToVastTrackers("complete_1" + MACRO_TAGS,
+                        "complete_2" + MACRO_TAGS));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        testTracker.setTracked();
+        spyOnVideoView();
+        setVideoViewParams(15000, 15000);
 
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 2, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "complete_1?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "complete_2?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
 
-        file.delete();
+        // Completion trackers should still only be hit once
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "complete_1?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "complete_2?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
-    public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRetryCount() throws Exception {
-        File file = new File("disk_video_path");
-        if (file.exists()){
-            assertThat(file.delete()).isTrue();
-        }
+    public void onCompletion_whenSomeTrackersRemain_shouldNotPingCompletionTrackers() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addCompleteTrackers(
+                VastUtils.stringsToVastTrackers("complete_1", "complete_2"));
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker(
+                "testUrl" + MACRO_TAGS, 123);
+        // Never track the testTracker, so completion trackers should not be fired.
+        vastVideoConfig.addAbsoluteTrackers(Arrays.asList(testTracker));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
 
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_shouldFireOffAllProgressTrackers() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(9001);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(9002);
+    public void onCompletion_whenPlaybackError_shouldNotPingCompletionTrackers() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addCompleteTrackers(
+                VastUtils.stringsToVastTrackers("complete_1", "complete_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+        subject.setVideoError();
+        spyOnVideoView();
+        setVideoViewParams(12345, 15000);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
+    }
+
+    @Test
+    public void onCompletion_shouldPreventOnResumeFromStartingVideo() throws Exception {
+        initializeSubject();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
 
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        subject.onResume();
+
+        assertThat(getShadowVideoView().isPlaying()).isFalse();
+    }
 
+    @Test
+    public void onCompletion_shouldStopProgressCheckerAndCountdown() throws Exception {
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
 
-        // this runs the videoProgressChecker
+        reset(spyCountdownRunnable, spyCountdownRunnable);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
+    }
+
+    @Test
+    public void onCompletion_whenCompanionAdAvailable_shouldShowCompanionAdAndHideBlurredLastVideoFrame() throws Exception {
+        initializeSubject();
+
+        final View companionView = subject.getLandscapeCompanionAdView();
+        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        Robolectric.getBackgroundScheduler().unPause();
         Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNull();
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void onCompletion_whenCompanionAdAvailable_shouldOnlyShowTopGradientStripWidget() throws Exception {
+        initializeSubject();
+
+        final VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
+        final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
         Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first", "second", "third");
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(topGradientStripWidget.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(0);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(100);
+    public void onCompletion_whenCompanionAdNotAvailable_shouldHideCompanionAdAndShowBlurredLastVideoFrame() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setVastCompanionAd(null, null);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        final View companionView = subject.getLandscapeCompanionAdView();
+        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
 
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNotNull();
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getDrawable()).isInstanceOf(BitmapDrawable.class);
+        assertThat(
+                ((BitmapDrawable) blurredLastVideoFrameImageView.getDrawable()).getBitmap()).isNotNull();
+    }
+
+    @Test
+    public void onCompletion_whenCompanionAdNotAvailable_shouldHideBothGradientStripWidgets() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setVastCompanionAd(null, null);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
-        setMediaPlayer(mediaPlayer);
-        subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().runOneTask();
-        // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        final VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
+        final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
 
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(topGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
+        assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
+    }
+
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    @Test
+    public void onCompletion_whenCompanionAdNotAvailableAndBlurredLastVideoFrameNotPrepared_shouldShowBlackBackground() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setVastCompanionAd(null, null);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        final View companionView = subject.getLandscapeCompanionAdView();
+        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNull();
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        Drawable background = subject.getLayout().getBackground();
+        assertThat(((ColorDrawable) background).getColor()).isEqualTo(Color.BLACK);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeLessThanOneSecond_shouldNotFireStartTracker() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+    public void onCompletion_whenCompanionAdNotAvailableAndBlurredLastVideoFrameNotPrepared_shouldHideBothGradientStripWidgets() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setVastCompanionAd(null, null);
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+
+        final VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
+        final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(topGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
+        assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
+    }
+
+    @Test
+    public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
+        initializeSubject();
 
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(999);
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
 
+        boolean result = getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(result).isFalse();
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(subject.getVideoError()).isTrue();
+    }
+
+    @Test
+    public void onError_shouldStopProgressChecker() throws Exception {
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().runOneTask();
-        // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        verify(spyProgressRunnable).startRepeating(anyLong());
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        reset(spyProgressRunnable, spyCountdownRunnable);
+        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
 
-        Thread.sleep(NETWORK_DELAY);
+        verify(spyProgressRunnable).stop();
+        verify(spyCountdownRunnable).stop();
+    }
 
-        // Since it has not yet been a second, we expect that the start tracker has not been fired
-        assertHttpRequestsMade(expectedUserAgent);
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayingTheVideo() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
 
-        // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        Robolectric.getUiThreadScheduler().runOneTask();
+        initializeSubject();
 
-        Thread.sleep(NETWORK_DELAY);
+        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(-1);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        assertThat(subject.getVastVideoView().getVideoRetries()).isEqualTo(0);
+        getShadowVideoView().getOnErrorListener().onError(new MediaPlayer(), 1, Integer.MIN_VALUE);
+
+        assertThat(getShadowVideoView().isPlaying()).isTrue();
+        assertThat(subject.getVastVideoView().getVideoRetries()).isEqualTo(1);
+
+        file.delete();
+    }
+
+    @Test
+    public void onError_shouldFireErrorTrackers() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addCompleteTrackers(
+                VastUtils.stringsToVastTrackers("complete_1", "complete_2"));
+        vastVideoConfig.addErrorTrackers(
+                Collections.singletonList(new VastTracker("error" + MACRO_TAGS)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+        subject.setVideoError();
+        spyOnVideoView();
+        setVideoViewParams(12345, 15000);
+
+        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "error?errorcode=400&asseturi=video_url&contentplayhead=00:00:12.345")));
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeGreaterThanOneSecond_shouldFireStartTracker() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+    public void onError_withMultipleCalls_shouldRepeatedlyFireErrorTrackers() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addErrorTrackers(
+                Collections.singletonList(new VastTracker("error" + MACRO_TAGS)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(1000);
+        initializeSubject();
+        subject.setVideoError();
+        spyOnVideoView();
+        setVideoViewParams(12345, 15000);
+
+        for(int i = 0; i < 10; i++) {
+            getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
+            verify(mockRequestQueue).add(argThat(isUrl(
+                    "error?errorcode=400&asseturi=video_url&contentplayhead=00:00:12.345")));
+        }
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_shouldFireOffAllProgressTrackers() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f),
+                        new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f),
+                        new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
+
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(9002, 9002);
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
+        // this runs the videoProgressChecker and countdown runnable
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
 
-        Thread.sleep(NETWORK_DELAY);
+        verify(mockRequestQueue).add(
+                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
+        verify(mockRequestQueue).add(
+                argThat(isUrl("third?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
+    }
 
-        assertHttpRequestsMade(expectedUserAgent, "start");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+    @Test
+    public void videoRunnablesRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        Robolectric.getUiThreadScheduler().runOneTask();
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 100);
 
-        Thread.sleep(NETWORK_DELAY);
+        subject.onResume();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        Robolectric.getUiThreadScheduler().runTasks(2);
+        // make sure the repeated task hasn't run yet
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(26);
+    public void videoRunnablesRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addAbsoluteTrackers(
+                Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(1999, 100000);
+        subject.onResume();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
+        // make sure the repeated task hasn't run yet
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        // Since it has not yet been a second, we expect that the start tracker has not been fired
+        verifyZeroInteractions(mockRequestQueue);
 
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        // run checker another time
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addAbsoluteTrackers(
+                Arrays.asList(new VastAbsoluteProgressTracker("start" + MACRO_TAGS, 2000)));
+        vastVideoConfig.addAbsoluteTrackers(
+                Arrays.asList(new VastAbsoluteProgressTracker("later" + MACRO_TAGS, 3000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2000, 100000);
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(
+                argThat(isUrl("start?errorcode=&asseturi=video_url&contentplayhead=00:00:02.000")));
 
         // run checker another time
-        Robolectric.getUiThreadScheduler().runOneTask();
-        Thread.sleep(NETWORK_DELAY);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(51);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+    public void videoRunnablesRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("don't call" + MACRO_TAGS, 0.28f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(26, 100);
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
+
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first", "second");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(
+                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.026")));
 
-        Robolectric.getUiThreadScheduler().runOneTask();
-        Thread.sleep(NETWORK_DELAY);
+        // run checker another time
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(76);
+    public void videoRunnablesRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
 
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(51, 100);
+
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first", "second", "third");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(
+                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051")));
 
-        Robolectric.getUiThreadScheduler().runOneTask();
-        Thread.sleep(NETWORK_DELAY);
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
+    public void videoRunnablesRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f)));
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(76, 100);
+
+        subject.onResume();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(mockRequestQueue).add(
+                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
+        verify(mockRequestQueue).add(
+                argThat(isUrl("third?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
+        //stub(mockMediaPlayer.getDuration()).toReturn(100);
+
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("video_url");
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.addFractionalTrackers(
+                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
+        vastVideoConfig.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f)));
+        vastVideoConfig.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        when(spyVideoView.getDuration()).thenReturn(100);
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
 
         // before any trackers are fired
-        fastForwardMediaPlayerAndAssertRequestMade(1);
+        seekToAndAssertRequestsMade(1);
 
-        fastForwardMediaPlayerAndAssertRequestMade(24);
+        seekToAndAssertRequestsMade(24);
 
         // after it hits first tracker
-        fastForwardMediaPlayerAndAssertRequestMade(26, "first");
+        seekToAndAssertRequestsMade(26,
+                "first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.026");
 
         // before mid quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(49);
+        seekToAndAssertRequestsMade(49);
 
         // after it hits mid trackers
-        fastForwardMediaPlayerAndAssertRequestMade(51, "second");
+        seekToAndAssertRequestsMade(51,
+                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051");
 
         // before third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(74);
+        seekToAndAssertRequestsMade(74);
 
         // after third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(76, "third");
+        seekToAndAssertRequestsMade(76,
+                "third?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076");
 
         // way after third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(99);
+        seekToAndAssertRequestsMade(99);
+    }
+
+    private void seekToAndAssertRequestsMade(int position, String... trackingUrls) {
+        when(spyVideoView.getCurrentPosition()).thenReturn(position);
+
+        for (String url : trackingUrls) {
+            Robolectric.getUiThreadScheduler().unPause();
+            verify(mockRequestQueue).add(argThat(isUrl(url)));
+        }
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(5001, 5002);
+        subject.onResume();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(5002);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(5001);
+    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldShowCloseButton() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("25%");    // skipoffset is at 2.5s
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2501, 10000); // duration is 10s, current position is 1ms after skipoffset
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
+
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
         Robolectric.getUiThreadScheduler().unPause();
@@ -980,34 +1787,70 @@ public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShow
     }
 
     @Test
-    public void onPause_shouldStopProgressChecker() throws Exception {
+    public void videoRunnablesRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotShowCloseButton() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setSkipOffset("00:00:03");   // skipoffset is at 3s
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2999, 10000); // duration is 10s, current position is 1ms before skipoffset
+        subject.onResume();
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+    }
+
+    @Test
+    public void onPause_shouldStopRunnables() throws Exception {
         initializeSubject();
 
         subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        verify(spyProgressRunnable).startRepeating(anyLong());
 
         subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
+    }
+
+    @Test
+    public void onPause_shouldFirePauseTrackers() throws Exception {
+        initializeSubject();
 
         subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        verify(mockRequestQueue).add(
+                argThat(isUrl("pause?errorcode=&asseturi=video_url&contentplayhead=00:00:00.000")));
     }
 
     @Test
-    public void onResume_shouldStartVideoProgressCheckerOnce() throws Exception {
+    public void onPause_withIsClosingFlagSet_shouldNotFirePauseTrackers() throws Exception {
         initializeSubject();
-
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        subject.setIsClosing(true);
 
         subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
 
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+    @Test
+    public void onResume_shouldStartRunnables() throws Exception {
+        initializeSubject();
+
+        subject.onPause();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
 
         subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        verify(spyProgressRunnable).startRepeating(anyLong());
     }
 
     @Test
@@ -1020,39 +1863,134 @@ public void onResume_shouldSetVideoViewStateToStarted() throws Exception {
         assertThat(getShadowVideoView().getPrevVideoState()).isNotEqualTo(ShadowVideoView.START);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
     @Test
-    public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
+    public void onResume_shouldSeekToPrePausedPosition() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(7000, 10000);
+
+        subject.onPause();
+
+        setVideoViewParams(1000, 10000);
 
+        subject.onResume();
+        verify(spyVideoView).seekTo(eq(7000));
+    }
+
+    @Test
+    public void onResume_multipleTimes_shouldFirePauseResumeTrackersMultipleTimes() throws Exception {
         initializeSubject();
+        spyOnVideoView();
 
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
+        setVideoViewParams(7000, 10000);
+        subject.onPause();
 
+        setVideoViewParams(1000, 10000);
         subject.onResume();
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
 
-        file.delete();
+        verify(mockRequestQueue).add(argThat(isUrl
+                ("pause?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
+        verify(mockRequestQueue).add(
+                argThat(isUrl("resume?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
+
+        subject.onPause();
+        subject.onResume();
+
+        verify(mockRequestQueue).add(
+                argThat(isUrl("pause?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
+        verify(mockRequestQueue).add(
+                argThat(isUrl("resume?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
     }
 
-    @Ignore("pending")
     @Test
-    public void onResume_shouldSeekToPrePausedPosition() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(10000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(7000);
+    public void onConfigurationChanged_withPortraitCompanionAdVisible_withDeviceLandscape_shouldMakeLandscapeCompanionAdVisible() throws Exception {
+        initializeSubject();
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        subject.getPortraitCompanionAdView().setVisibility(View.VISIBLE);
+
+        subject.onConfigurationChanged(null);
 
+        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.VISIBLE);
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_1)));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_2)));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void onConfigurationChanged_withLandscapeCompanionAdVisible_withDevicePortrait_shouldMakePortraitCompanionAdVisible() throws Exception {
         initializeSubject();
-        setMediaPlayer(mediaPlayer);
-        final VideoView videoView = spy(subject.getVideoView());
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        subject.getLandscapeCompanionAdView().setVisibility(View.VISIBLE);
 
-        subject.onPause();
+        subject.onConfigurationChanged(null);
 
-        stub(mediaPlayer.getCurrentPosition()).toReturn(1000);
+        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.VISIBLE);
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_3)));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
 
-        subject.onResume();
-        verify(videoView).seekTo(eq(7000));
+    @Test
+    public void onConfigurationChanged_withPortraitCompanionAdVisible_withDevicePortrait_shouldKeepPortraitCompanionAdVisible() throws Exception {
+        initializeSubject();
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        subject.getPortraitCompanionAdView().setVisibility(View.VISIBLE);
+
+        subject.onConfigurationChanged(null);
+
+        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_3)));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void onConfigurationChanged_withNoCompanionAdVisible_shouldDoNothing() throws Exception {
+        initializeSubject();
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+
+        subject.onConfigurationChanged(null);
+
+        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void onConfigurationChanged_whenCalledMultipleTimes_shouldOnlyEverFireEachCreativeViewTrackerOnce() throws Exception {
+        initializeSubject();
+        subject.getPortraitCompanionAdView().setVisibility(View.VISIBLE);
+
+        for(int i = 0; i < 10; i++) {
+            context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+            subject.onConfigurationChanged(null);
+            context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+            subject.onConfigurationChanged(null);
+        }
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_1)));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_2)));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_3)));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void onConfigurationChanged_withNoCompanionAd_shouldDoNothing() throws Exception {
+        VastVideoConfig vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfig.setNetworkMediaFileUrl("media_url");
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
+        initializeSubject();
+
+        subject.onConfigurationChanged(null);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getLandscapeCompanionAdView().getWidth()).isEqualTo(0);
+        assertThat(subject.getLandscapeCompanionAdView().getHeight()).isEqualTo(0);
+        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getPortraitCompanionAdView().getWidth()).isEqualTo(0);
+        assertThat(subject.getPortraitCompanionAdView().getHeight()).isEqualTo(0);
     }
 
     @Test
@@ -1071,49 +2009,195 @@ public void backButtonEnabled_whenCloseButtonIsVisible_shouldReturnTrue() throws
         assertThat(subject.backButtonEnabled()).isTrue();
     }
 
-    private void initializeSubject() {
-        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
+    @Test
+    public void onClickCloseButtonImageView_whenCloseButtonIsVisible_shouldFireCloseTrackers() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        // Because it's almost never exactly 15 seconds
+        when(spyVideoView.getDuration()).thenReturn(15094);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        subject.setCloseButtonVisible(true);
+
+        // We don't have direct access to the CloseButtonWidget icon's close event, so we manually
+        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
+        View.OnTouchListener closeButtonImageViewOnTouchListener =
+                shadowOf(subject.getCloseButtonWidget().getImageView()).getOnTouchListener();
+        closeButtonImageViewOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        verify(mockRequestQueue).add(
+                argThat(isUrl("close?errorcode=&asseturi=video_url&contentplayhead=00:00:15.094")));
+        verify(mockRequestQueue).add(
+                argThat(isUrl("skip?errorcode=&asseturi=video_url&contentplayhead=00:00:15.094")));
     }
 
-    private void setMediaPlayer(final MediaPlayer mediaPlayer) throws IllegalAccessException {
-        final VideoView videoView = subject.getVideoView();
-        ReflectionUtils.setVariableValueInObject(videoView, "mMediaPlayer", mediaPlayer);
+    @Test
+    public void onClickCloseButtonTextView_whenCloseButtonIsVisible_shouldFireCloseTrackers() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        // Because it's almost never exactly 15 seconds
+        when(spyVideoView.getDuration()).thenReturn(15203);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        subject.setCloseButtonVisible(true);
 
-        int state = (Integer) ReflectionUtils.getValueIncludingSuperclasses("STATE_PLAYING", videoView);
+        // We don't have direct access to the CloseButtonWidget text's close event, so we manually
+        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
+        View.OnTouchListener closeButtonTextViewOnTouchListener =
+                shadowOf(subject.getCloseButtonWidget().getTextView()).getOnTouchListener();
+        closeButtonTextViewOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        ReflectionUtils.setVariableValueInObject(videoView, "mCurrentState", state);
+        verify(mockRequestQueue).add(
+                argThat(isUrl("close?errorcode=&asseturi=video_url&contentplayhead=00:00:15.203")));
+        verify(mockRequestQueue).add(
+                argThat(isUrl("skip?errorcode=&asseturi=video_url&contentplayhead=00:00:15.203")));
     }
 
-    private void fastForwardMediaPlayerAndAssertRequestMade(int time, String... urls) throws Exception {
-        stub(mediaPlayer.getCurrentPosition()).toReturn(time);
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+    @Test
+    public void createIconView_shouldLayoutAndReturnInvisibleVastIconView() throws Exception {
+        initializeSubject();
 
-        if (urls == null) {
-            assertThat(Robolectric.getNextSentHttpRequest()).isNull();
-        } else {
-            assertHttpRequestsMade(expectedUserAgent, urls);
-        }
+        VastIconConfig vastIconConfig = mock(VastIconConfig.class);
+        when(vastIconConfig.getWidth()).thenReturn(40);
+        when(vastIconConfig.getHeight()).thenReturn(40);
+        VastResource vastResource = mock(VastResource.class);
+        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
+        when(vastResource.getResource()).thenReturn("static");
+        when(vastIconConfig.getVastResource()).thenReturn(vastResource);
+
+        VastWebView view = (VastWebView) subject.createIconView(context, vastIconConfig, View.INVISIBLE);
 
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        assertThat(view).isNotNull();
+        assertThat(view.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(view.getVastWebViewClickListener()).isNotNull();
+        assertThat(subject.getLayout().findViewById(view.getId())).isEqualTo(view);
     }
 
-    private VastVideoToolbar getVastVideoToolbar() {
-        final ViewGroup layout = subject.getLayout();
+    @Test
+    public void createIconView_withNullVastIcon_shouldReturnEmptyView() throws Exception {
+        initializeSubject();
 
-        for (int i = 0; i < layout.getChildCount(); i++) {
-            final View child = layout.getChildAt(i);
-            if (child instanceof VastVideoToolbar) {
-                return (VastVideoToolbar) child;
-            }
-        }
+        assertThat(subject.createIconView(context, null, View.INVISIBLE)).isNotNull();
+    }
+
+    @Test
+    public void VastWebView_onVastWebViewClick_shouldCallVastIconHandleClick() throws Exception {
+        initializeSubject();
+
+        VastIconConfig vastIconConfig = mock(VastIconConfig.class);
+        when(vastIconConfig.getWidth()).thenReturn(40);
+        when(vastIconConfig.getHeight()).thenReturn(40);
+        VastResource vastResource = mock(VastResource.class);
+        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
+        when(vastResource.getResource()).thenReturn("static");
+        when(vastIconConfig.getVastResource()).thenReturn(vastResource);
+
+        VastWebView view = (VastWebView) subject.createIconView(context, vastIconConfig, View.INVISIBLE);
+
+        view.getVastWebViewClickListener().onVastWebViewClick();
+        verify(vastIconConfig).handleClick(any(Context.class), anyString());
+    }
+
+    @Test
+    public void handleIconDisplay_withCurrentPositionGreaterThanOffset_shouldSetIconToVisible_shouldCallHandleImpression() throws Exception {
+        initializeSubject();
+
+        when(mMockVastIconConfig.getOffsetMS()).thenReturn(0);
+        when(mMockVastIconConfig.getDurationMS()).thenReturn(1);
+
+        subject.handleIconDisplay(0);
+
+        assertThat(subject.getIconView().getVisibility()).isEqualTo(View.VISIBLE);
+        verify(mMockVastIconConfig).handleImpression(any(Context.class), eq(0), eq("video_url"));
+    }
+
+    @Test
+    public void handleIconDisplay_withCurrentPositionLessThanOffset_shouldReturn() throws Exception {
+        initializeSubject();
+
+        when(mMockVastIconConfig.getOffsetMS()).thenReturn(1);
+
+        subject.handleIconDisplay(0);
+
+        assertThat(subject.getIconView().getVisibility()).isEqualTo(View.INVISIBLE);
+        verify(mMockVastIconConfig, never()).handleImpression(any(Context.class), eq(0),
+                eq("video_url"));
+    }
+
+    @Test
+    public void handleIconDisplay_withCurrentPositionGreaterThanOffsetPlusDuration_shouldSetIconToGone() throws Exception {
+        initializeSubject();
 
-        fail("Unable to find VastVideoToolbar in view hierarchy.");
-        return null;
+        when(mMockVastIconConfig.getOffsetMS()).thenReturn(0);
+        when(mMockVastIconConfig.getDurationMS()).thenReturn(1);
+
+        subject.handleIconDisplay(2);
+
+        assertThat(subject.getIconView().getVisibility()).isEqualTo(View.GONE);
+    }
+
+    @Test
+    public void makeInteractable_shouldHideCountdownWidgetAndShowCtaAndCloseButtonWidgets() throws Exception {
+        initializeSubject();
+
+        subject.makeVideoInteractable();
+
+        assertThat(subject.getRadialCountdownWidget().getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    private void initializeSubject() throws IllegalAccessException {
+        subject = new VastVideoViewController((Activity) context, bundle, savedInstanceState,
+                testBroadcastIdentifier, baseVideoViewControllerListener);
+        subject.getVastVideoView().setMediaMetadataRetriever(mockMediaMetadataRetriever);
+        spyOnRunnables();
+    }
+
+    private void spyOnVideoView() throws IllegalAccessException {
+        spyVideoView = spy(subject.getVideoView());
+        ReflectionUtils.setVariableValueInObject(subject, "mVideoView", spyVideoView);
+    }
+
+    private void spyOnRunnables() throws IllegalAccessException {
+        final VastVideoViewProgressRunnable progressCheckerRunnable = (VastVideoViewProgressRunnable) ReflectionUtils.getValueIncludingSuperclasses("mProgressCheckerRunnable", subject);
+        spyProgressRunnable = spy(progressCheckerRunnable);
+
+        final VastVideoViewCountdownRunnable countdownRunnable = (VastVideoViewCountdownRunnable) ReflectionUtils.getValueIncludingSuperclasses("mCountdownRunnable", subject);
+        spyCountdownRunnable = spy(countdownRunnable);
+
+        ReflectionUtils.setVariableValueInObject(subject, "mProgressCheckerRunnable", spyProgressRunnable);
+        ReflectionUtils.setVariableValueInObject(subject, "mCountdownRunnable", spyCountdownRunnable);
+    }
+
+    private void setVideoViewParams(int currentPosition, int duration) throws IllegalAccessException {
+        when(spyVideoView.getCurrentPosition()).thenReturn(currentPosition);
+        when(spyVideoView.getDuration()).thenReturn(duration);
+    }
+
+    private ShadowVastVideoView getShadowVideoView() {
+        return (ShadowVastVideoView) shadowOf_(subject.getVastVideoView());
     }
 
-    private ShadowVideoView getShadowVideoView() {
-        return shadowOf(subject.getVideoView());
+    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
+        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
+        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
+
+        for (final String url : urls) {
+            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
+        }
+
+        if (userAgent != null) {
+            while (true) {
+                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
+                if (httpRequest == null) {
+                    break;
+                }
+
+                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
+                        .isEqualTo(userAgent);
+            }
+        }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
new file mode 100644
index 00000000..7b17304c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
@@ -0,0 +1,48 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewCountdownRunnableTest {
+
+    @Mock VastVideoViewController mockVideoViewController;
+    @Mock Handler mockHandler;
+
+    VastVideoViewCountdownRunnable subject;
+
+    @Before
+    public void setup() {
+        subject = new VastVideoViewCountdownRunnable(mockVideoViewController, mockHandler);
+    }
+
+    @Test
+    public void doWork_whenShouldBeInteractable_shouldCallMakeVideoInteractable() {
+        when(mockVideoViewController.shouldBeInteractable()).thenReturn(true);
+
+        subject.doWork();
+
+        verify(mockVideoViewController).updateCountdown();
+        verify(mockVideoViewController).makeVideoInteractable();
+    }
+
+    @Test
+    public void doWork_whenShouldNotBeInteractable_shouldNotCallMakeVideoInteractable() {
+        when(mockVideoViewController.shouldBeInteractable()).thenReturn(false);
+
+        subject.doWork();
+
+        verify(mockVideoViewController).updateCountdown();
+        verify(mockVideoViewController, never()).makeVideoInteractable();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
new file mode 100644
index 00000000..1f5eabdb
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
@@ -0,0 +1,99 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewProgressRunnableTest {
+    @Mock VastVideoViewController mockVastVideoViewController;
+    @Mock Context mockContext;
+    @Mock Handler mockHandler;
+    @Mock MoPubRequestQueue mockRequestQueue;
+    @Mock VastVideoConfig mockVideoConfig;
+    @Captor ArgumentCaptor<TrackingRequest> requestCaptor;
+    VastVideoViewProgressRunnable subject;
+
+    @Before
+    public void setup() {
+        subject = new VastVideoViewProgressRunnable(mockVastVideoViewController, mockVideoConfig,
+                mockHandler);
+
+        // Request Queue needed to verify tracking requests made.
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void doWork_whenTrackersReturned_shouldMakeTrackingRequests() {
+        List<VastTracker> testTrackers = new ArrayList<VastTracker>();
+        testTrackers.add(new VastAbsoluteProgressTracker("http://example.com/", 1999));
+        testTrackers.add(new VastAbsoluteProgressTracker("http://example1.com/", 2000));
+
+        when(mockVideoConfig.getUntriggeredTrackersBefore(eq(3000), eq(4000)))
+                .thenReturn(testTrackers);
+        when(mockVastVideoViewController.getCurrentPosition()).thenReturn(3000);
+        when(mockVastVideoViewController.getDuration()).thenReturn(4000);
+        when(mockVastVideoViewController.getContext()).thenReturn(mockContext);
+
+        subject.doWork();
+
+        verify(mockVideoConfig).getUntriggeredTrackersBefore(eq(3000), eq(4000));
+        verify(mockVastVideoViewController).getCurrentPosition();
+        verify(mockVastVideoViewController).getDuration();
+        verify(mockVastVideoViewController).getContext();
+        verify(mockVastVideoViewController).getNetworkMediaFileUrl();
+        verify(mockVastVideoViewController).handleIconDisplay(eq(3000));
+        verify(mockVastVideoViewController).updateProgressBar();
+
+        // Capture request queue - should get two different trackers.
+        verify(mockRequestQueue, times(2)).add(requestCaptor.capture());
+        final List<TrackingRequest> allValues = requestCaptor.getAllValues();
+        assertThat(allValues).hasSize(2);
+        assertThat(allValues.get(0).getUrl()).isEqualTo("http://example.com/");
+        assertThat(allValues.get(1).getUrl()).isEqualTo("http://example1.com/");
+
+        verifyNoMoreInteractions(mockVastVideoViewController, mockRequestQueue);
+    }
+
+    @Test
+    public void doWork_whenNoTrackersReturned_shouldNotMakeTrackingRequests() {
+        List<VastTracker> testTrackers = new ArrayList<VastTracker>();
+
+        when(mockVideoConfig.getUntriggeredTrackersBefore(eq(3000), eq(4000)))
+                .thenReturn(testTrackers);
+        when(mockVastVideoViewController.getCurrentPosition()).thenReturn(3000);
+        when(mockVastVideoViewController.getDuration()).thenReturn(4000);
+        when(mockVastVideoViewController.getContext()).thenReturn(mockContext);
+
+        subject.doWork();
+
+        verify(mockVideoConfig).getUntriggeredTrackersBefore(eq(3000), eq(4000));
+        verify(mockVastVideoViewController).getCurrentPosition();
+        verify(mockVastVideoViewController).getDuration();
+        verify(mockVastVideoViewController).handleIconDisplay(eq(3000));
+        verify(mockVastVideoViewController).updateProgressBar();
+
+        verifyNoMoreInteractions(mockVastVideoViewController, mockRequestQueue);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
new file mode 100644
index 00000000..064b8b78
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
@@ -0,0 +1,194 @@
+package com.mopub.mobileads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.media.MediaPlayer;
+import android.os.AsyncTask;
+import android.os.Build;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.io.File;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewTest {
+
+    @Mock private MediaMetadataRetriever mockMediaMetadataRetriever;
+    @Mock private Bitmap mockBitmap;
+
+    private Context context;
+    private VastVideoView subject;
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new VastVideoView(context);
+        subject.setMediaMetadataRetriever(mockMediaMetadataRetriever);
+        when(mockMediaMetadataRetriever.getFrameAtTime(anyLong(), anyInt())).thenReturn(
+                mockBitmap);
+    }
+
+    @Test
+    public void onDestroy_withBlurLastVideoFrameTaskStillRunning_shouldCancelTask() throws Exception {
+        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(
+                VastVideoBlurLastVideoFrameTask.class);
+        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.RUNNING);
+        subject.setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
+
+        subject.onDestroy();
+
+        verify(mockBlurLastVideoFrameTask).cancel(true);
+    }
+
+    @Test
+    public void onDestroy_withBlurLastVideoFrameTaskStillPending_shouldCancelTask() throws Exception {
+        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(
+                VastVideoBlurLastVideoFrameTask.class);
+        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.PENDING);
+        subject.setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
+
+        subject.onDestroy();
+
+        verify(mockBlurLastVideoFrameTask).cancel(true);
+    }
+
+    @Test
+    public void onDestroy_withBlurLastVideoFrameTaskFinished_shouldNotCancelTask() throws Exception {
+        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(
+                VastVideoBlurLastVideoFrameTask.class);
+        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.FINISHED);
+        subject.setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
+
+        subject.onDestroy();
+
+        verify(mockBlurLastVideoFrameTask, never()).cancel(anyBoolean());
+    }
+
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void retryMediaPlayer_withVideoFilePermissionErrorAndBelowJellyBean_shouldReturnTrue() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1,
+                Integer.MIN_VALUE, "disk_video_path")).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void retryMediaPlayer_shouldNotRunMoreThanOnce() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1,
+                Integer.MIN_VALUE, "disk_video_path")).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1,
+                Integer.MIN_VALUE, "disk_video_path")).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN)
+    @Test
+    public void retryMediaPlayer_withAndroidVersionAboveJellyBean_shouldReturnFalse() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE,
+                "disk_video_path")).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 2, Integer.MIN_VALUE,
+                "disk_video_path")).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRetryCount() throws Exception {
+        File file = new File("disk_video_path");
+        if (file.exists()) {
+            assertThat(file.delete()).isTrue();
+        }
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE,
+                "disk_video_path")).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE,
+                "disk_video_path")).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        subject.onResume();
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD)
+    @Test
+    public void createMediaMetadataRetriever_beforeGingerbreadMr1_shouldReturnNull() throws Exception {
+        MediaMetadataRetriever mediaMetadataRetriever = subject.createMediaMetadataRetriever();
+
+        assertThat(mediaMetadataRetriever).isNull();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Test
+    public void createMediaMetadataRetriever_atLeastGingerbreadMr1_shouldReturnNewMediaMetadataRetriever() throws Exception {
+        MediaMetadataRetriever mediaMetadataRetriever = subject.createMediaMetadataRetriever();
+
+        assertThat(mediaMetadataRetriever).isNotNull();
+        assertThat(mediaMetadataRetriever).isInstanceOf(MediaMetadataRetriever.class);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java
new file mode 100644
index 00000000..3ee435f1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java
@@ -0,0 +1,120 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Build;
+import android.view.View;
+import android.webkit.WebSettings;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.GestureUtils;
+import com.mopub.mobileads.test.support.VastUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowWebView;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class VastWebViewTest {
+
+    private VastWebView subject;
+    private Context context;
+    @Mock VastWebView.VastWebViewClickListener mockVastWebViewClickListener;
+    @Mock private VastResource mockResource;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new VastWebView(context);
+        subject.setVastWebViewClickListener(mockVastWebViewClickListener);
+    }
+
+    @Test
+    public void constructor_shouldSetOnTouchListener() throws Exception {
+        assertThat(Robolectric.shadowOf(subject).getOnTouchListener())
+                .isInstanceOf(VastWebView.VastWebViewOnTouchListener.class);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    @Test
+    public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnabled()  {
+        subject = new VastWebView(Robolectric.buildActivity(Activity.class).create().get());
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
+
+        subject.enablePlugins(true);
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldAllowToggling() {
+        subject = new VastWebView(Robolectric.buildActivity(Activity.class).create().get());
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.ON);
+
+        subject.enablePlugins(false);
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
+
+        subject.enablePlugins(true);
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.ON);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD_MR1)
+    @Test
+    public void pluginState_beforeIcs_shouldDefaultToOff_shouldAllowToggling() {
+        subject = new VastWebView(Robolectric.buildActivity(Activity.class).create().get());
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
+
+        subject.enablePlugins(true);
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.ON);
+
+        subject.enablePlugins(false);
+        assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
+    }
+
+    @Test
+    public void loadData_shouldCallLoadDataWithBaseURL() throws Exception {
+        String data = "some random html response";
+        subject.loadData(data);
+
+        ShadowWebView.LoadDataWithBaseURL lastLoadData
+                = shadowOf(subject).getLastLoadDataWithBaseURL();
+        assertThat(lastLoadData.baseUrl).isEqualTo("http://ads.mopub.com/");
+        assertThat(lastLoadData.data).isEqualTo(data);
+        assertThat(lastLoadData.mimeType).isEqualTo("text/html");
+        assertThat(lastLoadData.encoding).isEqualTo("utf-8");
+        assertThat(lastLoadData.historyUrl).isNull();
+    }
+
+    @Test
+    public void VastWebViewOnTouchListener_withActionDown_withActionUp_shouldCallOnVastWebViewClick() throws Exception {
+        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        onTouchListener.onTouch(subject, GestureUtils.createActionDown(0, 0));
+        onTouchListener.onTouch(subject, GestureUtils.createActionUp(0, 0));
+
+        verify(mockVastWebViewClickListener).onVastWebViewClick();
+    }
+
+    @Test
+    public void createView_shouldInitializeAndReturnView() throws Exception {
+        VastIconConfig vastIconConfig = new VastIconConfig(123, 456, 789, 101,
+                mockResource,
+                VastUtils.stringsToVastTrackers("clickTrackerOne", "clickTrackerTwo"),
+                "clickThroughUri",
+                VastUtils.stringsToVastTrackers("viewTrackerOne", "viewTrackerTwo")
+        );
+
+        WebView webView = subject.createView(context, vastIconConfig.getVastResource());
+        assertThat(webView).isNotNull();
+        verify(mockResource).initializeWebView(any(VastWebView.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java
new file mode 100644
index 00000000..2d8d1aa4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java
@@ -0,0 +1,45 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Node;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VastWrapperXmlManagerTest {
+
+    private VastWrapperXmlManager subject;
+
+    @Test
+    public void getVastAdTagURI_shouldReturnStringURI() throws Exception {
+        String wrapperXml = "<Wrapper>" +
+                "    <Impression id=\"DART\">" +
+                "        <![CDATA[http://impression/m/wrapperOne]]>" +
+                "    </Impression>" +
+                "    <VASTAdTagURI>http://redirecturl/xml</VASTAdTagURI>" +
+                "</Wrapper>";
+
+        Node wrapperNode = createNode(wrapperXml);
+        subject = new VastWrapperXmlManager(wrapperNode);
+
+        assertThat(subject.getVastAdTagURI()).isEqualTo("http://redirecturl/xml");
+    }
+
+    @Test
+    public void getVastAdTagURI_withNoVastAdTagURI_shouldReturnNull() throws Exception {
+        String wrapperXml = "<Wrapper>" +
+                "    <Impression id=\"DART\">" +
+                "        <![CDATA[http://impression/m/wrapperOne]]>" +
+                "    </Impression>" +
+                "</Wrapper>";
+
+        Node wrapperNode = createNode(wrapperXml);
+        subject = new VastWrapperXmlManager(wrapperNode);
+
+        assertThat(subject.getVastAdTagURI()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
new file mode 100644
index 00000000..e74a94cc
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
@@ -0,0 +1,1343 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Point;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.common.HttpClient;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.VastUtils;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.mobileads.VastXmlManagerAggregator.VastXmlManagerAggregatorListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastXmlManagerAggregatorTest {
+    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'>" +
+            "    <Ad id='empty'>" +
+            "        <InLine>" +
+            "            <Impression><![CDATA[http:emptyimpression]]></Impression>" +
+            "            <Creatives>" +
+            "                <Creative>" +
+            "                    <Linear>" +
+            "                        <MediaFiles>" +
+            "                        </MediaFiles>" +
+            "                    </Linear>" +
+            "                </Creative>" +
+            "            </Creatives>" +
+            "            <Error><![CDATA[http://neverCallThisError]]></Error>" +
+            "        </InLine>" +
+            "    </Ad>" +
+            "    <Ad id='62833' sequence='1'>" +
+            "        <Wrapper>" +
+            "            <AdSystem>Tapad</AdSystem>" +
+            "            <VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI>" +
+            "            <Impression>http://myTrackingURL/wrapper/impression1</Impression>" +
+            "            <Impression>http://myTrackingURL/wrapper/impression2</Impression>" +
+            "            <Creatives>" +
+            "                <Creative AdID='62833'>" +
+            "                    <Linear>" +
+            "                        <TrackingEvents>" +
+            "                            <Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking>" +
+            "                            <Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking>" +
+            "                            <Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking>" +
+            "                            <Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking>" +
+            "                            <Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking>" +
+            "                            <Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking>" +
+            "                            <Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking>" +
+            "                            <Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking>" +
+            "                            <Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking>" +
+            "                            <Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking>" +
+            "                            <Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking>" +
+            "                        </TrackingEvents>" +
+            "                        <VideoClicks>" +
+            "                            <ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking>" +
+            "                        </VideoClicks>" +
+            "                        <MediaFiles>" +
+            "                            <MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'>" +
+            "                                <![CDATA[http://videosInWrappersShouldNeverBePlayed]]>" +
+            "                            </MediaFile>" +
+            "                        </MediaFiles>" +
+            "                    </Linear>" +
+            "                </Creative>" +
+            "                <Creative AdID=\"601364-Companion\">" +
+            "                    <CompanionAds>" +
+            "                        <Companion id=\"wrappercompanion\" height=\"250\" width=\"456\">" +
+            "                            <StaticResource creativeType=\"image/jpeg\">" +
+            "                                http://wrapperCompanionAdStaticResource" +
+            "                            </StaticResource>" +
+            "                            <TrackingEvents>" +
+            "                                <Tracking event=\"creativeView\">http://firstWrapperCompanionCreativeView</Tracking>" +
+            "                                <Tracking event=\"creativeView\">http://secondWrapperCompanionCreativeView</Tracking>" +
+            "                            </TrackingEvents>" +
+            "                            <CompanionClickThrough>http://wrapperCompanionClickThrough</CompanionClickThrough>" +
+            "                            <CompanionClickTracking><![CDATA[http://wrapperCompanionClickTracking]]></CompanionClickTracking>" +
+            "                        </Companion> " +
+            "                        <Companion id=\"noresource\" height=\"250\" width=\"456\">" +
+            "                            <TrackingEvents>" +
+            "                                <Tracking event=\"creativeView\">http://firstNoResourceWrapperCompanionCreativeView</Tracking>" +
+            "                                <Tracking event=\"creativeView\">http://secondNoResourceWrapperCompanionCreativeView</Tracking>" +
+            "                            </TrackingEvents>" +
+            "                            <CompanionClickThrough>http://noResourceWrapperCompanionClickThrough</CompanionClickThrough>" +
+            "                            <CompanionClickTracking><![CDATA[http://noResourceWrapperCompanionClickTracking1]]></CompanionClickTracking>" +
+            "                        </Companion> " +
+            "                    </CompanionAds>" +
+            "                </Creative>" +
+            "            </Creatives>" +
+            "            <Error><![CDATA[http://wrapperErrorOne?errorcode=[ERRORCODE]]]></Error>" +
+            "            <Error><![CDATA[http://wrapperErrorTwo?errorcode=[ERRORCODE]]]></Error>" +
+            "        </Wrapper>" +
+            "    </Ad>" +
+            "</VAST>" +
+            "<MP_TRACKING_URLS>" +
+            "    <MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL>" +
+            "    <MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL>" +
+            "</MP_TRACKING_URLS>";
+
+    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+            "<VAST version='2.0'>" +
+            "    <Ad id='57722'>" +
+            "        <InLine>" +
+            "            <AdSystem version='1.0'>Tapad</AdSystem>" +
+            "            <AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle>" +
+            "            <Description/>" +
+            "            <Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression>" +
+            "            <Creatives>" +
+            "                <Creative sequence='1' id='57722'>" +
+            "                    <Linear>" +
+            "                       <Icons>" +
+            "                           <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
+            "                           yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+            "                           duration=\"01:02:03.456\">" +
+            "                               <StaticResource creativeType=\"ImAge/JpEg\">" +
+            "                                   <![CDATA[imageJpeg]]>" +
+            "                               </StaticResource>" +
+            "                               <IconClicks>" +
+            "                                   <IconClickThrough>" +
+            "                                       <![CDATA[clickThroughUri]]>" +
+            "                                   </IconClickThrough>" +
+            "                                   <IconClickTracking>" +
+            "                                       <![CDATA[clickTrackingUri1]]>" +
+            "                                   </IconClickTracking>" +
+            "                                   <IconClickTracking>" +
+            "                                       <![CDATA[clickTrackingUri2]]>" +
+            "                                   </IconClickTracking>" +
+            "                               </IconClicks>" +
+            "                               <IconViewTracking>" +
+            "                                   <![CDATA[viewTrackingUri1]]>" +
+            "                               </IconViewTracking>" +
+            "                               <IconViewTracking>" +
+            "                                   <![CDATA[viewTrackingUri2]]>" +
+            "                               </IconViewTracking>" +
+            "                            </Icon>" +
+            "                        </Icons>" +
+            "                        <Duration>00:00:15</Duration>" +
+            "                        <VideoClicks>" +
+            "                            <ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough>" +
+            "                        </VideoClicks>" +
+            "                        <MediaFiles>" +
+            "                            <MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'>" +
+            "                                <![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]>" +
+            "                            </MediaFile>" +
+            "                        </MediaFiles>" +
+            "                    </Linear>" +
+            "                </Creative>" +
+            "                <Creative AdID=\"601364-Companion\">" +
+            "                    <CompanionAds>" +
+            "                        <Companion id=\"valid\" height=\"250\" width=\"300\">" +
+            "                            <StaticResource creativeType=\"image/jpeg\">" +
+            "                                http://demo.tremormedia.com/proddev/vast/Blistex1.jpg" +
+            "                            </StaticResource>" +
+            "                            <TrackingEvents>" +
+            "                                <Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking>" +
+            "                                <Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking>" +
+            "                            </TrackingEvents>" +
+            "                            <CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough>" +
+            "                            <CompanionClickTracking><![CDATA[http://companionClickTracking1]]></CompanionClickTracking>" +
+            "                            <CompanionClickTracking><![CDATA[http://companionClickTracking2]]></CompanionClickTracking>" +
+            "                        </Companion>" +
+            "                    </CompanionAds>" +
+            "                </Creative>" +
+            "            </Creatives>" +
+            "            <Error><![CDATA[http://nestedInLineErrorOne]]></Error>" +
+            "            <Error><![CDATA[http://nestedInLineErrorTwo]]></Error>" +
+            "        </InLine>" +
+            "    </Ad>" +
+            "</VAST>";
+
+    static final String TEST_NESTED_NO_COMPANION_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+            "<VAST version='2.0'>" +
+            "    <Ad id='57722'>" +
+            "        <InLine>" +
+            "            <AdSystem version='1.0'>Tapad</AdSystem>" +
+            "            <AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle>" +
+            "            <Description/>" +
+            "            <Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression>" +
+            "            <Creatives>" +
+            "                <Creative sequence='1' id='57722'>" +
+            "                    <Linear>" +
+            "                        <Duration>00:00:15</Duration>" +
+            "                        <VideoClicks>" +
+            "                            <ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough>" +
+            "                        </VideoClicks>" +
+            "                        <MediaFiles>" +
+            "                            <MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'>" +
+            "                                <![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]>" +
+            "                            </MediaFile>" +
+            "                        </MediaFiles>" +
+            "                    </Linear>" +
+            "                </Creative>" +
+            "            </Creatives>" +
+            "        </InLine>" +
+            "    </Ad>" +
+            "</VAST>";
+
+    static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives><Error>![CDATA[http://badNestedError]]</Error]</Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+
+    static final String TEST_JUST_ERROR_XML_STRING = "<VAST version='3.0'>" +
+            "<Error><![CDATA[http://justErrorTracking?errorcode=[ERRORCODE]]]></Error>" +
+            "</VAST>";
+
+    static final String TEST_INVALID_VAST_XML_STRING = "<VAST version='fail'>" +
+            "This is not vast." +
+            "</VAST>";
+
+    static final String TEST_INVALID_XML_STRING = "this is not xml at all<<<";
+
+    static final String TEST_VAST_WITH_NEGATIVE_SEQUENCE_NUMBER_XML_STRING = "<VAST version='3.0'>" +
+            "    <Ad id='sequenceTooHigh' sequence='42'>" +
+            "        <InLine>" +
+            "            <Impression><![CDATA[http:sequenceTooHighImp]]></Impression>" +
+            "            <Creatives>" +
+            "                <Creative>" +
+            "                    <Linear>" +
+            "                        <MediaFiles>" +
+            "                            <MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'>" +
+            "                                <![CDATA[http://sequenceTooHighVideo]]>" +
+            "                            </MediaFile>" +
+            "                        </MediaFiles>" +
+            "                    </Linear>" +
+            "                </Creative>" +
+            "            </Creatives>" +
+            "        </InLine>" +
+            "    </Ad>" +
+            "    <Ad id='negativeSequence' sequence='-2'>" +
+            "        <InLine>" +
+            "            <Impression><![CDATA[http://negativeSequence]]></Impression>" +
+            "            <Creatives>" +
+            "                <Creative>" +
+            "                    <Linear>" +
+            "                        <MediaFiles>" +
+            "                            <MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'>" +
+            "                                <![CDATA[http://negativeSequence]]>" +
+            "                            </MediaFile>" +
+            "                        </MediaFiles>" +
+            "                    </Linear>" +
+            "                </Creative>" +
+            "            </Creatives>" +
+            "        </InLine>" +
+            "    </Ad>" +
+            "</VAST>";
+
+    private Activity context;
+    private FakeHttpLayer mFakeHttpLayer;
+    private Semaphore semaphore;
+    private VastXmlManagerAggregatorListener vastXmlManagerAggregatorListener;
+    private VastXmlManagerAggregator subject;
+    private VastVideoConfig mVastVideoConfig;
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        semaphore = new Semaphore(0);
+        vastXmlManagerAggregatorListener = mock(VastXmlManagerAggregatorListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                VastXmlManagerAggregatorTest.this.mVastVideoConfig = (VastVideoConfig) args[0];
+                semaphore.release();
+                return null;
+            }
+        }).when(vastXmlManagerAggregatorListener).onAggregationComplete(any(VastVideoConfig.class));
+
+        // Always assume landscape (where width > height) since videos will always be played in this orientation
+        int screenWidth = 800;
+        int screenHeight = 480;
+        double screenAspectRatio = (double) screenWidth / screenHeight;
+        int screenArea = screenWidth * screenHeight;
+        subject = new VastXmlManagerAggregator(vastXmlManagerAggregatorListener, screenAspectRatio,
+                screenArea, context);
+    }
+
+    // NOTE most of the functionality of this class is tested through VastManagerTest
+    // through integration tests
+
+    @Test
+    public void doInBackground_shouldNotFollowRedirectsOnceTheLimitHasBeenReached() throws Exception {
+        for(int i = 0; i < VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT; i++) {
+            mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        }
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        subject.execute(TEST_VAST_XML_STRING);
+        semaphore.acquire();
+
+        assertThat(mVastVideoConfig).isNull();
+    }
+
+    @Test
+    public void doInBackground_shouldFollowMaxRedirectsMinusOne() throws Exception {
+        for(int i = 0; i < VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT - 1; i++) {
+            mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        }
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        subject.execute(TEST_VAST_XML_STRING);
+        semaphore.acquire();
+
+        assertThat(mVastVideoConfig.getNetworkMediaFileUrl()).isEqualTo("https://s3" +
+                ".amazonaws.com/mopub-vast/tapad-video.mp4");
+        assertThat(mVastVideoConfig.getClickThroughUrl()).isEqualTo("http://rtb-test.dev" +
+                ".tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMj" +
+                "AwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTN" +
+                "BMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxh" +
+                "JTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLa" +
+                "XQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMT" +
+                "E2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzM" +
+                "wMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlk" +
+                "PUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3" +
+                "D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad." +
+                "com");
+        assertThat(mVastVideoConfig.getImpressionTrackers().size()).isEqualTo(4 *
+                VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT + 1);
+        assertThat(mVastVideoConfig.getFractionalTrackers().size()).isEqualTo(3 *
+                VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT);
+    }
+
+    @Test
+    public void getBestMediaFileUrl_shouldReturnMediaFileUrl() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNullMediaType_shouldReturnNull() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, null, "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withIncompatibleMediaType_shouldReturnNull() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/rubbish", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNullMediaUrl_shouldReturnNull() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", null);
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNullDimension_shouldReturnNull() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(null, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withZeroDimension_shouldReturnNull() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(0, 250,
+                "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNegativeDimension_shouldReturnNull() throws Exception {
+        final VastMediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(-1, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea1() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastMediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
+        // Double screen size
+        final VastMediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(1600, 960, "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea2() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastMediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
+        // Half screen size
+        final VastMediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(400, 240,
+                "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(
+                Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withSameArea_shouldReturnUrlWithAspectRatioCloserToScreenAspectRatio() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Landscape
+        final VastMediaXmlManager mediaXmlManager1 =
+                initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url1");
+        // Portrait
+        final VastMediaXmlManager mediaXmlManager2 =
+                initializeMediaXmlManagerMock(240, 400, "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(
+                Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url1");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullDimension_shouldReturnNull() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Invalid media type
+        final VastMediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
+        // Null dimension
+        final VastMediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(null, null,
+                "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(
+                Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        final VastMediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
+        final VastMediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(800,
+                480, null, "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(
+                Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_shouldReturnCompanionAd() throws Exception {
+        final VastCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(
+                300, 250, "image_url", "image/jpeg", null, null);
+
+        final VastCompanionAdConfig bestCompanionAd =
+                subject.getBestCompanionAd(Arrays.asList(companionXmlManager),
+                        VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withInvalidVastResource_shouldReturnNull() throws Exception {
+        final VastCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(
+                300, 250, "image_url", "image/INVALID", null, null);
+
+        final VastCompanionAdConfig bestCompanionAd =
+                subject.getBestCompanionAd(Arrays.asList(companionXmlManager),
+                        VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withNullDimension_shouldReturnNull() throws Exception {
+        final VastCompanionAdXmlManager companionXmlManager =
+                initializeCompanionXmlManagerMock(null, 250, "image_url", "image/png", null, null);
+
+        final VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withWidthTooSmall_shouldReturnNull() throws Exception {
+        final VastCompanionAdXmlManager companionXmlManager =
+                initializeCompanionXmlManagerMock(299, 250, "image_url", "image/png", null, null);
+
+        final VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withHeightTooSmall_shouldReturnNull() throws Exception {
+        final VastCompanionAdXmlManager companionXmlManager =
+                initializeCompanionXmlManagerMock(300, 249, "image_url", "image/png", null, null);
+
+        final VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea1() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(2400, 1440, "image_url1", "image/png", null, null);
+        // Double screen size
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(1600, 960, "image_url2", "image/bmp", null, null);
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager1, companionXmlManager2),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("image_url2");
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea2() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(2400, 1440, "image_url1", "image/png", null, null);
+        // Half screen size
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(400, 250, "image_url2", "image/bmp", null, null);
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager1, companionXmlManager2),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("image_url2");
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameArea_shouldReturnLandscapeCompanionAdWithAspectRatioCloserToScreenAspectRatio() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Landscape
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(400, 250, "image_url1", "image/png", null, null);
+        // Portrait
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(250, 400, "image_url2", "image/bmp", null, null);
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager1, companionXmlManager2),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("image_url1");
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameArea_shouldReturnPortraitCompanionAdWithAspectRatioCloserToScreenAspectRatio() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Landscape
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(400, 300, "image_url1", "image/png", null, null);
+        // Portrait
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(300, 400, "image_url2", "image/bmp", null, null);
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager1, companionXmlManager2),
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("image_url2");
+    }
+
+    @Test
+    public void getBestCompanionAd_withAllThreeResourceTypes_shouldReturnStaticResourceType() throws Exception {
+        // Static Resource
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(400, 250, "StaticResource", "image/png", null,
+                        null);
+        // HTML Resource
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(250, 400, null, null, null, "HTMLResource");
+        // IFrame Resource
+        final VastCompanionAdXmlManager companionXmlManager3 =
+                initializeCompanionXmlManagerMock(250, 400, null, null, "IFrameResource", null);
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager3, companionXmlManager2, companionXmlManager1),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("StaticResource");
+    }
+
+    @Test
+    public void getBestCompanionAd_withHTMLAndStaticResourceTypes_shouldReturnStaticResourceType() throws Exception {
+        // Static Resource
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(400, 250, "StaticResource", "image/png", null, null);
+        // HTML Resource
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(250, 400, null, null, null, "HTMLResource");
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager2, companionXmlManager1),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("StaticResource");
+    }
+
+    @Test
+    public void getBestCompanionAd_withInvalidStaticResource_withValidHtmlResource_shouldReturnHtmlResource() throws Exception {
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(400, 250, "StaticResource", "INVALID",
+                        "IFrameResource", null);
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(300, 400, null, null, null, "HTMLResource");
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager2, companionXmlManager1),
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("HTMLResource");
+    }
+
+    @Test
+    public void getBestCompanionAd_withCompanionAdTooSmall_shouldReturnCompanionAdWithAtLeastMinimumSize() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // 305 x 305 is both fewer pixels (screen area) and a worse aspect ratio. It still should be
+        // chosen because 240 is not wide enough to be considered for a companion ad
+        final VastCompanionAdXmlManager companionXmlManager1 =
+                initializeCompanionXmlManagerMock(305, 305, "image_url1", "image/png", null, null);
+        final VastCompanionAdXmlManager companionXmlManager2 =
+                initializeCompanionXmlManagerMock(240, 400, "image_url2", "image/bmp", null, null);
+
+        VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
+                Arrays.asList(companionXmlManager1, companionXmlManager2),
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(bestCompanionAd.getVastResource().getResource()).isEqualTo("image_url1");
+    }
+
+    @Test
+    public void getScaledDimensions_withWidthLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point point = subject.getScaledDimensions(1600, 400);
+
+        assertThat(point.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(point.y).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withHeightLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point point = subject.getScaledDimensions(400, 960);
+
+        assertThat(point.x).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(point.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withWidthAndHeightSmallerThanScreen_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point point = subject.getScaledDimensions(800, 480);
+
+        assertThat(point.x).isEqualTo(800);
+        assertThat(point.y).isEqualTo(480);
+    }
+
+    @Test
+    public void getScaledDimensions_withWidthAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point point = subject.getScaledDimensions(1600, 2);
+
+        assertThat(point.x).isEqualTo(1600);
+        assertThat(point.y).isEqualTo(2);
+    }
+
+    @Test
+    public void getScaledDimensions_withHeightAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point point = subject.getScaledDimensions(2, 960);
+
+        assertThat(point.x).isEqualTo(2);
+        assertThat(point.y).isEqualTo(960);
+    }
+
+    @Test
+    public void getBestIcon_shouldReturnBestIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, 50, 123, 456, "staticResource1", "image/jpeg", null, null,
+                        VastUtils.stringsToVastTrackers("clickTrackingUri1", "clickTrackingUri2"),
+                        "clickThroughUri",
+                        VastUtils.stringsToVastTrackers("viewTrackingUri1", "viewTrackingUri2"));
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getWidth()).isEqualTo(40);
+        assertThat(bestIcon.getHeight()).isEqualTo(50);
+        assertThat(bestIcon.getOffsetMS()).isEqualTo(123);
+        assertThat(bestIcon.getDurationMS()).isEqualTo(456);
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource1");
+        assertThat(bestIcon.getVastResource().getType()).isEqualTo(VastResource.Type
+                .STATIC_RESOURCE);
+        assertThat(bestIcon.getVastResource().getCreativeType())
+                .isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(VastUtils.vastTrackersToStrings(bestIcon.getClickTrackingUris()))
+                .containsOnly("clickTrackingUri1", "clickTrackingUri2");
+        assertThat(bestIcon.getClickThroughUri()).isEqualTo("clickThroughUri");
+        assertThat(VastUtils.vastTrackersToStrings(bestIcon.getViewTrackingUris()))
+                .containsOnly("viewTrackingUri1", "viewTrackingUri2");
+    }
+
+    @Test
+    public void getBestIcon_withMissingWidth_shouldNotSelectThatIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(null, 50, null, null, "staticResource1", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null,
+                        new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getBestIcon_withNegativeWidth_shouldNotSelectThatIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(-1, 50, null, null, "staticResource1", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getBestIcon_withWidthGreaterThan300dp_shouldNotSelectThatIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(301, 50, null, null, "staticResource1", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getBestIcon_withMissingHeight_shouldNotSelectThatIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, null, null, null, "staticResource1", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getBestIcon_withNegativeHeight_shouldNotSelectThatIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, -1, null, null, "staticResource1", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getBestIcon_withHeightGreaterThan300dp_shouldNotSelectThatIcon() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, 301, null, null, "staticResource1", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, "staticResource2", "image/png",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager1, iconXmlManager2));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("staticResource2");
+    }
+
+    @Test
+    public void getBestIcon_withAllThreeResourceTypes_shouldReturnStaticResourceType() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, 40, null, null, "StaticResource", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, null, null, "IFrameResource",
+                        null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager3 =
+                initializeIconXmlManagerMock(40, 40, null, null, null, null, null, "HTMLResource",
+                        new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager3, iconXmlManager2,
+                iconXmlManager1));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("StaticResource");
+    }
+
+    @Test
+    public void getBestIcon_withHTMLAndStaticResourceTypes_shouldReturnStaticResourceType() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, 40, null, null, "StaticResource", "image/jpeg",
+                        null, null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, null, null, null, "HTMLResource",
+                        new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager2, iconXmlManager1));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("StaticResource");
+    }
+
+    @Test
+    public void getBestIcon_withInvalidStaticResource_withValidHtmlResource_shouldReturnHtmlResource() throws Exception {
+        final VastIconXmlManager iconXmlManager1 =
+                initializeIconXmlManagerMock(40, 40, null, null, "StaticResource", "INVALID",
+                        "IFrameResource", null, new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+        final VastIconXmlManager iconXmlManager2 =
+                initializeIconXmlManagerMock(40, 40, null, null, null, null, null, "HTMLResource",
+                        new ArrayList<VastTracker>(), null, new ArrayList<VastTracker>());
+
+        VastIconConfig bestIcon = subject.getBestIcon(Arrays.asList(iconXmlManager2, iconXmlManager1));
+        assertThat(bestIcon.getVastResource().getResource()).isEqualTo("HTMLResource");
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withStandardInline_shouldReturnValidVastVideoConfiguration() {
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_NESTED_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getImpressionTrackers()))
+                .containsOnly("http://rtb-test.dev.tapad.com:8080/creative/imp" +
+                        ".png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo" +
+                        "=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1");
+        assertThat(vastVideoConfig.getFractionalTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getAbsoluteTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getPauseTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getResumeTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getCompleteTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getCloseTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getSkipTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getClickTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getClickThroughUrl()).isEqualTo(
+                "http://rtb-test.dev.tapad" +
+                        ".com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
+        assertThat(vastVideoConfig.getNetworkMediaFileUrl()).isEqualTo(
+                "https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
+        assertThat(vastVideoConfig.getSkipOffsetString()).isNull();
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getErrorTrackers()))
+                .containsOnly("http://nestedInLineErrorOne", "http://nestedInLineErrorTwo");
+
+        VastCompanionAdConfig[] companionAds = new VastCompanionAdConfig[2];
+        companionAds[0] = vastVideoConfig.getVastCompanionAd(
+                Configuration.ORIENTATION_LANDSCAPE);
+        companionAds[1] = vastVideoConfig.getVastCompanionAd(
+                Configuration.ORIENTATION_PORTRAIT);
+        for (VastCompanionAdConfig companionAd : companionAds) {
+            assertThat(companionAd.getWidth()).isEqualTo(300);
+            assertThat(companionAd.getHeight()).isEqualTo(250);
+            assertThat(companionAd.getVastResource().getResource())
+                    .isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
+            assertThat(companionAd.getVastResource().getType())
+                    .isEqualTo(VastResource.Type.STATIC_RESOURCE);
+            assertThat(companionAd.getVastResource().getCreativeType())
+                    .isEqualTo(VastResource.CreativeType.IMAGE);
+            assertThat(companionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+            assertThat(VastUtils.vastTrackersToStrings(companionAd.getClickTrackers()))
+                    .containsOnly("http://companionClickTracking1",
+                            "http://companionClickTracking2");
+            assertThat(VastUtils.vastTrackersToStrings(companionAd.getCreativeViewTrackers()))
+                    .containsExactly("http://myTrackingURL/firstCompanionCreativeView",
+                            "http://myTrackingURL/secondCompanionCreativeView");
+        }
+
+        VastIconConfig vastIconConfig = vastVideoConfig.getVastIconConfig();
+        assertThat(vastIconConfig.getWidth()).isEqualTo(123);
+        assertThat(vastIconConfig.getHeight()).isEqualTo(234);
+        assertThat(vastIconConfig.getDurationMS()).isEqualTo(3723456);
+        assertThat(vastIconConfig.getOffsetMS()).isEqualTo(3723000);
+        assertThat(vastIconConfig.getVastResource().getResource()).isEqualTo("imageJpeg");
+        assertThat(vastIconConfig.getVastResource().getType()).isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(vastIconConfig.getVastResource().getCreativeType()).isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(VastUtils.vastTrackersToStrings(vastIconConfig.getClickTrackingUris()))
+                .containsOnly("clickTrackingUri1", "clickTrackingUri2");
+        assertThat(vastIconConfig.getClickThroughUri()).isEqualTo("clickThroughUri");
+        assertThat(VastUtils.vastTrackersToStrings(vastIconConfig.getViewTrackingUris()))
+                .containsOnly("viewTrackingUri1", "viewTrackingUri2");
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withAWrapperToAnInline_shouldReturnValidVastVideoConfiguration() {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getImpressionTrackers()))
+                .containsOnly(
+                        "http://rtb-test.dev.tapad.com:8080/creative/imp" +
+                                ".png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp" +
+                                "&ta_pinfo" +
+                                "=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1",
+                        "http://myTrackingURL/wrapper/impression1",
+                        "http://myTrackingURL/wrapper/impression2",
+                        "http://www.mopub.com/imp1",
+                        "http://www.mopub.com/imp2");
+
+        assertThat(vastVideoConfig.getFractionalTrackers()).hasSize(3);
+        assertThat(
+                vastVideoConfig.getFractionalTrackers().get(0)).isEqualsToByComparingFields(
+                new VastFractionalProgressTracker("http://myTrackingURL/wrapper/firstQuartile",
+                        0.25f));
+        assertThat(
+                vastVideoConfig.getFractionalTrackers().get(1)).isEqualsToByComparingFields(
+                new VastFractionalProgressTracker("http://myTrackingURL/wrapper/midpoint",
+                        0.5f));
+        assertThat(
+                vastVideoConfig.getFractionalTrackers().get(2)).isEqualsToByComparingFields(
+                new VastFractionalProgressTracker("http://myTrackingURL/wrapper/thirdQuartile",
+                        0.75f));
+
+        assertThat(vastVideoConfig.getAbsoluteTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfig.getAbsoluteTrackers().get(0)).isEqualsToByComparingFields(
+                new VastAbsoluteProgressTracker("http://myTrackingURL/wrapper/creativeView", 0));
+        assertThat(vastVideoConfig.getAbsoluteTrackers().get(1)).isEqualsToByComparingFields(
+                new VastAbsoluteProgressTracker("http://myTrackingURL/wrapper/start", 2000));
+
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getPauseTrackers()))
+                .containsOnly("http://myTrackingURL/wrapper/pause");
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getResumeTrackers()))
+                .containsOnly("http://myTrackingURL/wrapper/resume");
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getCompleteTrackers()))
+                .containsOnly("http://myTrackingURL/wrapper/complete");
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getErrorTrackers()))
+                .containsExactly(
+                        "http://wrapperErrorOne?errorcode=[ERRORCODE]",
+                        "http://wrapperErrorTwo?errorcode=[ERRORCODE]",
+                        "http://nestedInLineErrorOne",
+                        "http://nestedInLineErrorTwo");
+
+        assertThat(vastVideoConfig.getCloseTrackers()).isEmpty();
+        assertThat(vastVideoConfig.getSkipTrackers()).isEmpty();
+
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getClickTrackers()))
+                .containsOnly("http://myTrackingURL/wrapper/click");
+
+        assertThat(vastVideoConfig.getClickThroughUrl()).isEqualTo(
+                "http://rtb-test.dev.tapad" +
+                        ".com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
+        assertThat(vastVideoConfig.getNetworkMediaFileUrl()).isEqualTo(
+                "https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
+        assertThat(vastVideoConfig.getSkipOffsetString()).isNull();
+
+        VastCompanionAdConfig[] companionAds = new VastCompanionAdConfig[2];
+        companionAds[0] = vastVideoConfig.getVastCompanionAd(
+                Configuration.ORIENTATION_LANDSCAPE);
+        companionAds[1] = vastVideoConfig.getVastCompanionAd(
+                Configuration.ORIENTATION_PORTRAIT);
+        for (VastCompanionAdConfig companionAd : companionAds) {
+            assertThat(companionAd.getWidth()).isEqualTo(300);
+            assertThat(companionAd.getHeight()).isEqualTo(250);
+            assertThat(companionAd.getVastResource().getResource())
+                    .isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
+            assertThat(companionAd.getVastResource().getType())
+                    .isEqualTo(VastResource.Type.STATIC_RESOURCE);
+            assertThat(companionAd.getVastResource().getCreativeType())
+                    .isEqualTo(VastResource.CreativeType.IMAGE);
+            assertThat(companionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+            assertThat(VastUtils.vastTrackersToStrings(companionAd.getClickTrackers()))
+                    .containsOnly("http://companionClickTracking1",
+                            "http://companionClickTracking2",
+                            "http://noResourceWrapperCompanionClickTracking1");
+            assertThat(VastUtils.vastTrackersToStrings(companionAd.getCreativeViewTrackers()))
+                    .containsExactly("http://myTrackingURL/firstCompanionCreativeView",
+                            "http://myTrackingURL/secondCompanionCreativeView",
+                            "http://firstNoResourceWrapperCompanionCreativeView",
+                            "http://secondNoResourceWrapperCompanionCreativeView");
+        }
+
+        VastIconConfig vastIconConfig = vastVideoConfig.getVastIconConfig();
+        assertThat(vastIconConfig.getWidth()).isEqualTo(123);
+        assertThat(vastIconConfig.getHeight()).isEqualTo(234);
+        assertThat(vastIconConfig.getDurationMS()).isEqualTo(3723456);
+        assertThat(vastIconConfig.getOffsetMS()).isEqualTo(3723000);
+        assertThat(vastIconConfig.getVastResource().getResource()).isEqualTo("imageJpeg");
+        assertThat(vastIconConfig.getVastResource().getType()).isEqualTo(VastResource.Type.STATIC_RESOURCE);
+        assertThat(vastIconConfig.getVastResource().getCreativeType()).isEqualTo(VastResource.CreativeType.IMAGE);
+        assertThat(VastUtils.vastTrackersToStrings(vastIconConfig.getClickTrackingUris()))
+                .containsOnly("clickTrackingUri1", "clickTrackingUri2");
+        assertThat(vastIconConfig.getClickThroughUri()).isEqualTo("clickThroughUri");
+        assertThat(VastUtils.vastTrackersToStrings(vastIconConfig.getViewTrackingUris()))
+                .containsOnly("viewTrackingUri1", "viewTrackingUri2");
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withInvalidXml_shouldReturnNullVastVideoConfiguration() {
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_BAD_NEST_URL_XML_STRING, HttpClient.getHttpClient(),
+                new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig).isNull();
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withRedirectHavingNoCompanionAd_shouldReturnVastVideoConfigurationWithCompanionAdOfWrapper() {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_NO_COMPANION_VAST_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        VastCompanionAdConfig[] companionAds = new VastCompanionAdConfig[2];
+        companionAds[0] = vastVideoConfig.getVastCompanionAd(
+                Configuration.ORIENTATION_LANDSCAPE);
+        companionAds[1] = vastVideoConfig.getVastCompanionAd(
+                Configuration.ORIENTATION_PORTRAIT);
+        for (VastCompanionAdConfig companionAd : companionAds) {
+            assertThat(companionAd.getWidth()).isEqualTo(456);
+            assertThat(companionAd.getHeight()).isEqualTo(250);
+            assertThat(companionAd.getVastResource().getResource()).isEqualTo("http" +
+                    "://wrapperCompanionAdStaticResource");
+            assertThat(companionAd.getClickThroughUrl()).isEqualTo(
+                    "http://wrapperCompanionClickThrough");
+            assertThat(VastUtils.vastTrackersToStrings(companionAd.getClickTrackers()))
+                    .containsOnly("http://wrapperCompanionClickTracking");
+            assertThat(VastUtils.vastTrackersToStrings(companionAd.getCreativeViewTrackers()))
+                    .containsExactly("http://firstWrapperCompanionCreativeView",
+                            "http://secondWrapperCompanionCreativeView");
+        }
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withSequenceNumbers_shouldReturnVastVideoConfigurationWithNegativeSequenceNumber() {
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_WITH_NEGATIVE_SEQUENCE_NUMBER_XML_STRING, HttpClient.getHttpClient(),
+                new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig.getNetworkMediaFileUrl()).isEqualTo(
+                "http://negativeSequence");
+        assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getImpressionTrackers()))
+                .containsOnly("http://negativeSequence");
+    }
+
+    @Test
+    public void isValidSequenceNumber_withNull_shouldReturnTrue() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber(null)).isTrue();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withNegativeInteger_shouldReturnTrue() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("-123")).isTrue();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withHighPositiveInteger_shouldReturnFalse() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("123456")).isFalse();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withDecimal_shouldReturnTrue() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("123.456")).isTrue();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withInvalidInteger_shouldReturnTrue() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("this should fail!")).isTrue();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withZero_shouldReturnTrue() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("0")).isTrue();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withOne_shouldReturnTrue() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("1")).isTrue();
+    }
+
+    @Test
+    public void isValidSequenceNumber_withTwo_shouldReturnFalse() {
+        assertThat(VastXmlManagerAggregator.isValidSequenceNumber("2")).isFalse();
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withJustError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_JUST_ERROR_XML_STRING, HttpClient.getHttpClient(),
+                new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig).isNull();
+        verify(mockRequestQueue).add(argThat(isUrl("http://justErrorTracking?errorcode=900")));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withWrapperToJustError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTrackers() {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_JUST_ERROR_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig).isNull();
+        verify(mockRequestQueue).add(argThat(isUrl("http://justErrorTracking?errorcode=303")));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withWrapperToVastXmlError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_INVALID_VAST_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig).isNull();
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withWrapperToInvalidXml_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_INVALID_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig).isNull();
+        verify(mockRequestQueue).add(argThat(isUrl("http://wrapperErrorOne?errorcode=100")));
+        verify(mockRequestQueue).add(argThat(isUrl("http://wrapperErrorTwo?errorcode=100")));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withWrapperToNoHttpResponse_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+
+        assertThat(vastVideoConfig).isNull();
+        verify(mockRequestQueue).add(argThat(isUrl("http://wrapperErrorOne?errorcode=301")));
+        verify(mockRequestQueue).add(argThat(isUrl("http://wrapperErrorTwo?errorcode=301")));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    private VastMediaXmlManager initializeMediaXmlManagerMock(
+            final Integer width,
+            final Integer height,
+            final String type,
+            final String mediaUrl) {
+        VastMediaXmlManager mediaXmlManager = mock(VastMediaXmlManager.class);
+        when(mediaXmlManager.getWidth()).thenReturn(width);
+        when(mediaXmlManager.getHeight()).thenReturn(height);
+        when(mediaXmlManager.getType()).thenReturn(type);
+        when(mediaXmlManager.getMediaUrl()).thenReturn(mediaUrl);
+        return mediaXmlManager;
+    }
+
+    private VastCompanionAdXmlManager initializeCompanionXmlManagerMock(
+            final Integer width,
+            final Integer height,
+            final String staticResource,
+            final String staticResourceType,
+            final String iFrameResource,
+            final String htmlResource) {
+        VastCompanionAdXmlManager companionXmlManager = mock(VastCompanionAdXmlManager.class);
+        when(companionXmlManager.getWidth()).thenReturn(width);
+        when(companionXmlManager.getHeight()).thenReturn(height);
+
+        VastResourceXmlManager mockResourceXmlManager = initializeVastResourceXmlManagerMock(
+                staticResource,
+                staticResourceType,
+                iFrameResource,
+                htmlResource
+        );
+        when(companionXmlManager.getResourceXmlManager()).thenReturn(mockResourceXmlManager);
+
+        return companionXmlManager;
+    }
+
+    private void assertCompanionAdsAreEqual(
+            final VastCompanionAdXmlManager companionAdXmlManager,
+            final VastCompanionAdConfig companionAd) {
+        final VastCompanionAdConfig companionAd1 = new VastCompanionAdConfig(
+                companionAdXmlManager.getWidth(),
+                companionAdXmlManager.getHeight(),
+                VastResource.fromVastResourceXmlManager(
+                        companionAdXmlManager.getResourceXmlManager(),
+                        companionAdXmlManager.getWidth(),
+                        companionAdXmlManager.getHeight()),
+                companionAdXmlManager.getClickThroughUrl(),
+                companionAdXmlManager.getClickTrackers(),
+                companionAdXmlManager.getCompanionCreativeViewTrackers()
+        );
+        assertCompanionAdsAreEqual(companionAd, companionAd1);
+    }
+
+    private void assertCompanionAdsAreEqual(
+            final VastCompanionAdConfig vastCompanionAdConfig1,
+            final VastCompanionAdConfig vastCompanionAdConfig2) {
+        assertThat(vastCompanionAdConfig1.getWidth()).isEqualTo(vastCompanionAdConfig2.getWidth());
+        assertThat(vastCompanionAdConfig1.getHeight()).isEqualTo(vastCompanionAdConfig2.getHeight());
+        assertThat(vastCompanionAdConfig1.getVastResource().getResource())
+                .isEqualTo(vastCompanionAdConfig2.getVastResource().getResource());
+        assertThat(vastCompanionAdConfig1.getVastResource().getType())
+                .isEqualTo(vastCompanionAdConfig2.getVastResource().getType());
+        assertThat(vastCompanionAdConfig1.getVastResource().getCreativeType())
+                .isEqualTo(vastCompanionAdConfig2.getVastResource().getCreativeType());
+        assertThat(vastCompanionAdConfig1.getClickThroughUrl()).isEqualTo(vastCompanionAdConfig2.getClickThroughUrl());
+        assertThat(vastCompanionAdConfig1.getClickTrackers()).isEqualTo(vastCompanionAdConfig2.getClickTrackers());
+        assertThat(vastCompanionAdConfig1.getCreativeViewTrackers()).isEqualTo(
+                vastCompanionAdConfig2.getCreativeViewTrackers());
+    }
+
+    private VastIconXmlManager initializeIconXmlManagerMock(
+            final Integer width,
+            final Integer height,
+            final Integer offsetMS,
+            final Integer durationMS,
+            final String staticResource,
+            final String staticResourceType,
+            final String iFrameResource,
+            final String htmlResource,
+            final List<VastTracker> clickTrackingUris,
+            final String clickThroughUri,
+            final List<VastTracker> viewTrackingUris) {
+        VastIconXmlManager iconXmlManager = mock(VastIconXmlManager.class);
+        when(iconXmlManager.getWidth()).thenReturn(width);
+        when(iconXmlManager.getHeight()).thenReturn(height);
+        when(iconXmlManager.getOffsetMS()).thenReturn(offsetMS);
+        when(iconXmlManager.getDurationMS()).thenReturn(durationMS);
+
+        VastResourceXmlManager mockResourceXmlManager = initializeVastResourceXmlManagerMock(
+                staticResource,
+                staticResourceType,
+                iFrameResource,
+                htmlResource
+        );
+        when(iconXmlManager.getResourceXmlManager()).thenReturn(mockResourceXmlManager);
+
+        when(iconXmlManager.getClickTrackingUris()).thenReturn(clickTrackingUris);
+        when(iconXmlManager.getClickThroughUri()).thenReturn(clickThroughUri);
+        when(iconXmlManager.getViewTrackingUris()).thenReturn(viewTrackingUris);
+        return iconXmlManager;
+    }
+
+    static VastResourceXmlManager initializeVastResourceXmlManagerMock(
+            final String staticResource,
+            final String staticResourceType,
+            final String iFrameResource,
+            final String htmlResource) {
+        VastResourceXmlManager mockResourceXmlManager = mock(VastResourceXmlManager.class);
+        when(mockResourceXmlManager.getStaticResource()).thenReturn(staticResource);
+        when(mockResourceXmlManager.getStaticResourceType()).thenReturn(staticResourceType);
+        when(mockResourceXmlManager.getIFrameResource()).thenReturn(iFrameResource);
+        when(mockResourceXmlManager.getHTMLResource()).thenReturn(htmlResource);
+        return mockResourceXmlManager;
+    }
+
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java
similarity index 51%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
rename to mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java
index dd7bb02b..b056537f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java
@@ -1,6 +1,8 @@
-package com.mopub.mobileads.util.vast;
+package com.mopub.mobileads;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.mobileads.test.support.VastUtils;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -34,10 +36,9 @@
             "                        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145;sz=1x1;ord=2922389?" +
             "                        ]]>" +
             "                    </Impression>" +
-            "                    <VASTAdTagURI><![CDATA[ http://0.dsp.dev1.mopub.com/xml ]]></VASTAdTagURI>" +
             "                    <Creatives>" +
             "                        <Creative sequence=\"1\" AdID=\"\">" +
-            "                            <Linear>" +
+            "                            <Linear skipoffset=\"25%\">" +
             "                                <Duration>00:00:58</Duration>" +
             "                                <TrackingEvents>" +
             "                                    <Tracking event=\"start\">" +
@@ -45,6 +46,40 @@
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
             "                                        ]]>" +
             "                                    </Tracking>" +
+            "                                    <Tracking event=\"progress\" offset=\"13%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"progress\" offset=\"01:01:10.300\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to ambiguous offset.
+            "                                    <Tracking event=\"progress\" offset=\"01:01\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a too-high percentage offset.
+            "                                    <Tracking event=\"progress\" offset=\"113%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a negative percentage offset.
+            "                                    <Tracking event=\"progress\" offset=\"-113%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a non-number offset
+            "                                    <Tracking event=\"progress\" offset=\"ten seconds\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
             "                                    <Tracking event=\"midpoint\">" +
             "                                        <![CDATA[" +
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;" +
@@ -85,6 +120,26 @@
             "                                        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?" +
             "                                        ]]>" +
             "                                    </Tracking>" +
+            "                                    <Tracking event=\"close\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/close?q=ignatius" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"close\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/close?q=j3" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"skip\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/skip?q=ignatius" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"skip\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/skip?q=j3" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
             "                                    <Tracking event=\"mute\">" +
             "                                        <![CDATA[" +
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=16;ecn1=1;etm1=0;" +
@@ -130,6 +185,32 @@
             "                                        ]]>" +
             "                                    </MediaFile>" +
             "                                </MediaFiles>" +
+            "                               <Icons>" +
+            "                                   <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
+            "                                   yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
+            "                                   duration=\"01:02:03.456\">" +
+            "                                       <StaticResource creativeType=\"ImAge/JpEg\">" +
+            "                                           <![CDATA[imageJpeg]]>" +
+            "                                       </StaticResource>" +
+            "                                       <IconClicks>" +
+            "                                           <IconClickThrough>" +
+            "                                               <![CDATA[clickThroughUri]]>" +
+            "                                           </IconClickThrough>" +
+            "                                           <IconClickTracking>" +
+            "                                               <![CDATA[clickTrackingUri1]]>" +
+            "                                           </IconClickTracking>" +
+            "                                           <IconClickTracking>" +
+            "                                               <![CDATA[clickTrackingUri2]]>" +
+            "                                           </IconClickTracking>" +
+            "                                       </IconClicks>" +
+            "                                       <IconViewTracking>" +
+            "                                           <![CDATA[viewTrackingUri1]]>" +
+            "                                       </IconViewTracking>" +
+            "                                       <IconViewTracking>" +
+            "                                           <![CDATA[viewTrackingUri2]]>" +
+            "                                       </IconViewTracking>" +
+            "                                    </Icon>" +
+            "                                </Icons>" +
             "                            </Linear>" +
             "                        </Creative>" +
             "                        <Creative AdID=\"601364-Companion\">" +
@@ -149,6 +230,7 @@
             "                                       <Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking>" +
             "                                   </TrackingEvents>" +
             "                                   <CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough>" +
+            "                                   <CompanionClickTracking><![CDATA[http://companionClickTracking1]]></CompanionClickTracking>" +
             "                               </Companion>" +
             "                               <Companion height=\"789\" width=\"456\">" +
             "                                   <StaticResource creativeType=\"image/bmp\">" +
@@ -168,6 +250,7 @@
             "                                           http://clickThroughUrl1.com/" +
             "                                       ]]>" +
             "                                   </CompanionClickThrough>" +
+            "                                   <CompanionClickTracking><![CDATA[http://companionClickTracking2]]></CompanionClickTracking>" +
             "                               </Companion>" +
             "                               <Companion height=\"789\" width=\"1011\">" +
             "                                   <StaticResource creativeType=\"image/gif\">" +
@@ -180,6 +263,7 @@
             "                                           http://clickThroughUrl2.com/" +
             "                                       ]]>" +
             "                                   </CompanionClickThrough>" +
+            "                                   <CompanionClickTracking><![CDATA[http://companionClickTracking3]]></CompanionClickTracking>" +
             "                               </Companion>" +
             "                               <Companion width=\"300\" height=\"60\">" +
             "                                   <StaticResource creativeType=\"application/x-shockwave-flash\">" +
@@ -199,6 +283,7 @@
             "                                           http://clickThroughUrl3.com/" +
             "                                       ]]>" +
             "                                   </CompanionClickThrough>" +
+            "                                   <CompanionClickTracking><![CDATA[http://companionClickTracking4]]></CompanionClickTracking>" +
             "                               </Companion>" +
             "                               <Companion id=\"valid\" height=\"249\" width=\"299\">" +
             "                                   <BADStaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</BADStaticResource>" +
@@ -210,6 +295,7 @@
             "                                           <Tracking event=\"BADcreativeView\">http://myTrackingURL/fifthCompanionCreativeView</Tracking>" +
             "                                   </TrackingEvents>" +
             "                                   <BADCompanionClickThrough>http://www.tremormedia.com</BADCompanionClickThrough>" +
+            "                                   <BADCompanionClickTracking><![CDATA[http://companionClickTracking5]]></BADCompanionClickTracking>" +
             "                               </Companion>" +
             "                               <Companion width=\"9000\">" +
             "                                   <TrackingEvents>" +
@@ -236,8 +322,21 @@
             "                                </DeliveryData>" +
             "                            </AdServingData>" +
             "                        </Extension>" +
+            "                        <Extension type=\"MoPub\">" +
+            "                           <MoPubCtaText>custom CTA text</MoPubCtaText>" +
+            "                           <MoPubSkipText>skip</MoPubSkipText>" +
+            "                           <MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+            "                           <MoPubForceOrientation>device</MoPubForceOrientation>" +
+            "                        </Extension>" +
             "                    </Extensions>" +
             "                </InLine>" +
+            "                <Wrapper>" +
+            "                   <AdSystem>Acudeo Compatible</AdSystem>" +
+            "                   <VASTAdTagURI>http://0.dsp.dev1.mopub.com/xml</VASTAdTagURI>" +
+            "                   <Impression>http://myTrackingURL/wrapper/impression</Impression>" +
+            "                   <Creatives>" +
+            "                   </Creatives>" +
+            "                </Wrapper>" +
             "            </Ad>" +
             "        </VAST>" +
             "<MP_TRACKING_URLS>" +
@@ -267,6 +366,10 @@ public void setup() {
         }
     }
 
+    /**
+     * UNIT TESTS
+     */
+
     @Test
     public void parseVastXml_shouldNotRaiseAnExceptionProcessingValidXml() {
         assertThat(mExceptionRaised).isEqualTo(false);
@@ -281,217 +384,316 @@ public void parseVastXml_shouldNotRaiseAnExceptionProcessingXmlWithXmlHeaderTag(
     }
 
     @Test
-    public void getImpressionTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getImpressionTrackers();
+    public void parseVastXml_withMalformedXml_shouldNotCauseProblems() {
+        String badXml = "<im>going<<<to||***crash></,>CDATA[]YOUR_FACE";
 
-        assertThat(trackers.size()).isEqualTo(4);
+        VastXmlManager badManager = new VastXmlManager();
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
-        String tracker3 = trackers.get(2);
-        String tracker4 = trackers.get(3);
+        try {
+            badManager.parseVastXml(badXml);
+        } catch (ParserConfigurationException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (SAXException e) {
+            e.printStackTrace();
+        }
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/imp;v7;x;223626102;0-0;0;47414672;0/0;30477563/30495440/1;;~aopt=0/0/ff/0;~cs=j%3fhttp://s0.2mdn.net/dot.gif");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145;sz=1x1;ord=2922389?");
-        assertThat(tracker3).isEqualTo("http://www.mopub.com/imp1");
-        assertThat(tracker4).isEqualTo("http://www.mopub.com/imp2");
+        assertThat(badManager.getMoPubImpressionTrackers().size()).isEqualTo(0);
     }
 
     @Test
-    public void getVideoStartTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoStartTrackers();
+    public void parseVastXml_withMalformedNodes_shouldNotCauseProblems() {
+        String badXml = "<VAST><Impression id=\"DART\"></Impression><Tracking event=\"start\"><![CDATA[ good ]]><ExtraNode><![CDATA[ bad ]]></ExtraNode></Tracking></VAST>";
 
-        assertThat(trackers.size()).isEqualTo(1);
+        VastXmlManager badManager = new VastXmlManager();
 
-        String tracker1 = trackers.get(0);
+        try {
+            badManager.parseVastXml(badXml);
+        } catch (ParserConfigurationException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (SAXException e) {
+            e.printStackTrace();
+        }
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+        assertThat(badManager.getAdXmlManagers()).isEmpty();
     }
 
     @Test
-    public void getVideoFirstQuartileTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoFirstQuartileTrackers();
-
-        assertThat(trackers.size()).isEqualTo(2);
-
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
-
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
+    public void getAdXmlManagers_shouldReturnAllAdXmlManagers() throws Exception {
+        String vastXml = "<VAST xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.0\" xsi:noNamespaceSchemaLocation=\"vast.xsd\">" +
+                "    <Ad id=\"12345678\">" +
+                "        <InLine></InLine>" +
+                "    </Ad>" +
+                "    <Ad id=\"87654321\">" +
+                "        <Wrapper></Wrapper>" +
+                "    </Ad>" +
+                "</VAST>";
+
+        VastXmlManager subject = new VastXmlManager();
+        subject.parseVastXml(vastXml);
+        List<VastAdXmlManager> vastAdXmlManagers = subject.getAdXmlManagers();
+
+        assertThat(vastAdXmlManagers.size()).isEqualTo(2);
+        assertThat(vastAdXmlManagers.get(0).getInLineXmlManager()).isNotNull();
+        assertThat(vastAdXmlManagers.get(0).getWrapperXmlManager()).isNull();
+        assertThat(vastAdXmlManagers.get(1).getInLineXmlManager()).isNull();
+        assertThat(vastAdXmlManagers.get(1).getWrapperXmlManager()).isNotNull();
     }
 
     @Test
-    public void getVideoMidpointTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoMidpointTrackers();
-
-        assertThat(trackers.size()).isEqualTo(2);
-
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
-
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+    public void getMoPubImpressionTrackers_shouldReturnTheCorrectValue() {
+        assertThat(VastUtils.vastTrackersToStrings(mXmlManager.getMoPubImpressionTrackers()))
+                .containsOnly("http://www.mopub.com/imp1", "http://www.mopub.com/imp2");
     }
 
     @Test
-    public void getVideoThirdQuartileTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoThirdQuartileTrackers();
-
-        assertThat(trackers.size()).isEqualTo(2);
-
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+    public void getCustomCtaText_shouldReturnTheCorrectValue() {
+        String customCtaText = mXmlManager.getCustomCtaText();
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
+        assertThat(customCtaText).isEqualTo("custom CTA text");
     }
 
     @Test
-    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoCompleteTrackers();
+    public void getCustomSkipText_shouldReturnTheCorrectValue() {
+        String customSkipText = mXmlManager.getCustomSkipText();
 
-        assertThat(trackers.size()).isEqualTo(2);
+        assertThat(customSkipText).isEqualTo("skip");
+    }
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+    @Test
+    public void getCustomCloseIconUrl_shouldReturnTheCorrectValue() {
+        String customCloseIconUrl = mXmlManager.getCustomCloseIconUrl();
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
+        assertThat(customCloseIconUrl).isEqualTo("http://ton.twitter" +
+                ".com/exchange-media/images/v4/star_icon_3x.png");
     }
 
     @Test
-    public void getClickThroughUrl_shouldReturnTheCorrectValue() {
-        String url = mXmlManager.getClickThroughUrl();
+    public void getCustomForceOrientation_shouldReturnTheCorrectValue() {
+        ForceOrientation customForceOrientation = mXmlManager.getCustomForceOrientation();
 
-        assertThat(url).isEqualTo("http://www.google.com/support/richmedia");
+        assertThat(customForceOrientation).isEqualTo(ForceOrientation.DEVICE_ORIENTATION);
     }
 
-    @Test
-    public void getClickTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getClickTrackers();
+    /**
+     * INTEGRATION TESTS
+     */
 
-        assertThat(trackers.size()).isEqualTo(2);
+    @Test
+    public void getVastAdTagURI_withWrapperXmlManager_shouldReturnTheCorrectValue() {
+        String url = mXmlManager.getAdXmlManagers().get(0).getWrapperXmlManager().getVastAdTagURI();
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+        assertThat(url).isEqualTo("http://0.dsp.dev1.mopub.com/xml");
+    }
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/click%3Bh%3Dv8/3e1b/3/0/%2a/z%3B223626102%3B0-0%3B0%3B47414672%3B255-0/0%3B30477563/30495440/1%3B%3B%7Eaopt%3D0/0/ff/0%3B%7Esscs%3D%3fhttp://s0.2mdn.net/dot.gif");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/clk;212442087;33815766;i?http://www.google.com/support/richmedia");
+    @Test
+    public void getImpressionTrackers_withInLineXmlManager_shouldReturnTheCorrectValue() {
+        assertThat(VastUtils.vastTrackersToStrings(mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getImpressionTrackers()))
+                .containsOnly("http://ad.doubleclick.net/imp;v7;x;223626102;0-0;0;47414672;0/0;" +
+                                "30477563/30495440/1;;~aopt=0/0/ff/0;~cs=j%3fhttp://s0.2mdn" +
+                                ".net/dot.gif",
+                        "http://ad.doubleclick.net/ad/N270.Process_Other/B3473145;sz=1x1;ord=2922389?");
     }
 
     @Test
-    public void getCompanionAdXmlManagers_shouldReturnListOfPopulatedCompanionAdXmlManagers() throws Exception {
-        List<VastXmlManager.ImageCompanionAdXmlManager> imageCompanionAdXmlManagers = mXmlManager.getCompanionAdXmlManagers();
+    public void getCompanionAdXmlManagers_withInLineXmlManager_shouldReturnListOfPopulatedCompanionAdXmlManagers() throws Exception {
+        List<VastCompanionAdXmlManager> imageCompanionAdXmlManagers = mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getCompanionAdXmlManagers();
         assertThat(imageCompanionAdXmlManagers.size()).isEqualTo(7);
 
         assertThat(imageCompanionAdXmlManagers.get(0).getWidth()).isEqualTo(728);
         assertThat(imageCompanionAdXmlManagers.get(0).getHeight()).isEqualTo(90);
-        assertThat(imageCompanionAdXmlManagers.get(0).getType()).isEqualTo("image/jpeg");
-        assertThat(imageCompanionAdXmlManagers.get(0).getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/728x90_banner1.jpg");
-        assertThat(imageCompanionAdXmlManagers.get(0).getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+        assertThat(imageCompanionAdXmlManagers.get(0).getResourceXmlManager().getStaticResourceType())
+                .isEqualTo("image/jpeg");
+        assertThat(imageCompanionAdXmlManagers.get(0).getResourceXmlManager().getStaticResource())
+                .isEqualTo("http://demo.tremormedia.com/proddev/vast/728x90_banner1.jpg");
+        assertThat(imageCompanionAdXmlManagers.get(0).getClickThroughUrl()).isEqualTo(
+                "http://www.tremormedia.com");
         assertThat(imageCompanionAdXmlManagers.get(0).getClickTrackers()).isEmpty();
 
         assertThat(imageCompanionAdXmlManagers.get(1).getWidth()).isEqualTo(300);
         assertThat(imageCompanionAdXmlManagers.get(1).getHeight()).isEqualTo(250);
-        assertThat(imageCompanionAdXmlManagers.get(1).getType()).isEqualTo("image/png");
-        assertThat(imageCompanionAdXmlManagers.get(1).getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.png");
-        assertThat(imageCompanionAdXmlManagers.get(1).getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
-        assertThat(imageCompanionAdXmlManagers.get(1).getClickTrackers())
-                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
+        assertThat(imageCompanionAdXmlManagers.get(1).getResourceXmlManager().getStaticResourceType())
+                .isEqualTo("image/png");
+        assertThat(imageCompanionAdXmlManagers.get(1).getResourceXmlManager().getStaticResource())
+                .isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.png");
+        assertThat(imageCompanionAdXmlManagers.get(1).getClickThroughUrl()).isEqualTo(
+                "http://www.tremormedia.com");
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(1)
+                .getClickTrackers())).containsOnly("http://companionClickTracking1");
 
         assertThat(imageCompanionAdXmlManagers.get(2).getWidth()).isEqualTo(456);
         assertThat(imageCompanionAdXmlManagers.get(2).getHeight()).isEqualTo(789);
-        assertThat(imageCompanionAdXmlManagers.get(2).getType()).isEqualTo("image/bmp");
-        assertThat(imageCompanionAdXmlManagers.get(2).getImageUrl()).isEqualTo("http://cdn.liverail.com/adasset/229/7969/300x250.bmp");
-        assertThat(imageCompanionAdXmlManagers.get(2).getClickThroughUrl()).isEqualTo("http://clickThroughUrl1.com/");
-        assertThat(imageCompanionAdXmlManagers.get(2).getClickTrackers()).containsOnly("http://trackingUrl1.com/");
+        assertThat(imageCompanionAdXmlManagers.get(2).getResourceXmlManager().getStaticResourceType())
+                .isEqualTo("image/bmp");
+        assertThat(imageCompanionAdXmlManagers.get(2).getResourceXmlManager().getStaticResource())
+                .isEqualTo("http://cdn.liverail.com/adasset/229/7969/300x250.bmp");
+        assertThat(imageCompanionAdXmlManagers.get(2).getClickThroughUrl())
+                .isEqualTo("http://clickThroughUrl1.com/");
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(2)
+                .getClickTrackers())).containsOnly("http://companionClickTracking2");
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(2)
+                .getCompanionCreativeViewTrackers())).containsOnly("http://trackingUrl1.com/");
 
         assertThat(imageCompanionAdXmlManagers.get(3).getWidth()).isEqualTo(1011);
         assertThat(imageCompanionAdXmlManagers.get(3).getHeight()).isEqualTo(789);
-        assertThat(imageCompanionAdXmlManagers.get(3).getType()).isEqualTo("image/gif");
-        assertThat(imageCompanionAdXmlManagers.get(3).getImageUrl()).isEqualTo("http://cdn.liverail.com/adasset/229/7969/300x250.gif");
-        assertThat(imageCompanionAdXmlManagers.get(3).getClickThroughUrl()).isEqualTo("http://clickThroughUrl2.com/");
-        assertThat(imageCompanionAdXmlManagers.get(3).getClickTrackers()).isEmpty();
+        assertThat(imageCompanionAdXmlManagers.get(3).getResourceXmlManager().getStaticResourceType())
+                .isEqualTo("image/gif");
+        assertThat(imageCompanionAdXmlManagers.get(3).getResourceXmlManager().getStaticResource())
+                .isEqualTo("http://cdn.liverail.com/adasset/229/7969/300x250.gif");
+        assertThat(imageCompanionAdXmlManagers.get(3).getClickThroughUrl()).isEqualTo(
+                "http://clickThroughUrl2.com/");
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(3)
+                .getClickTrackers())).containsOnly("http://companionClickTracking3");
+        assertThat(imageCompanionAdXmlManagers.get(3).getCompanionCreativeViewTrackers()).isEmpty();
 
         assertThat(imageCompanionAdXmlManagers.get(4).getWidth()).isEqualTo(300);
         assertThat(imageCompanionAdXmlManagers.get(4).getHeight()).isEqualTo(60);
-        assertThat(imageCompanionAdXmlManagers.get(4).getType()).isEqualTo("application/x-shockwave-flash");
-        assertThat(imageCompanionAdXmlManagers.get(4).getImageUrl()).isEqualTo("http://cdn.liverail.com/adasset4/1331/229/7969/5122396e510b80db6b5ef4013ddabe90.swf");
-        assertThat(imageCompanionAdXmlManagers.get(4).getClickThroughUrl()).isEqualTo("http://clickThroughUrl3.com/");
-        assertThat(imageCompanionAdXmlManagers.get(4).getClickTrackers()).containsOnly("http://trackingUrl2.com/");
+        assertThat(imageCompanionAdXmlManagers.get(4).getResourceXmlManager().getStaticResourceType())
+                .isEqualTo("application/x-shockwave-flash");
+        assertThat(imageCompanionAdXmlManagers.get(4).getResourceXmlManager().getStaticResource())
+                .isEqualTo(
+                        "http://cdn.liverail.com/adasset4/1331/229/7969/5122396e510b80db6b5ef4013ddabe90.swf");
+        assertThat(imageCompanionAdXmlManagers.get(4).getClickThroughUrl()).isEqualTo(
+                "http://clickThroughUrl3.com/");
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(4)
+                .getClickTrackers())).containsOnly("http://companionClickTracking4");
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(4)
+                .getCompanionCreativeViewTrackers())).containsOnly("http://trackingUrl2.com/");
 
         assertThat(imageCompanionAdXmlManagers.get(5).getWidth()).isEqualTo(299);
         assertThat(imageCompanionAdXmlManagers.get(5).getHeight()).isEqualTo(249);
-        assertThat(imageCompanionAdXmlManagers.get(5).getType()).isNull();
-        assertThat(imageCompanionAdXmlManagers.get(5).getImageUrl()).isNull();
+        assertThat(imageCompanionAdXmlManagers.get(5).getResourceXmlManager().getStaticResourceType()).isNull();
+        assertThat(imageCompanionAdXmlManagers.get(5).getResourceXmlManager().getStaticResource()).isNull();
         assertThat(imageCompanionAdXmlManagers.get(5).getClickThroughUrl()).isNull();
-        assertThat(imageCompanionAdXmlManagers.get(5).getClickTrackers())
-                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
+        assertThat(imageCompanionAdXmlManagers.get(5).getClickTrackers()).isEmpty();
+        assertThat(VastUtils.vastTrackersToStrings(imageCompanionAdXmlManagers.get(5)
+                .getCompanionCreativeViewTrackers()))
+                .containsOnly("http://myTrackingURL/firstCompanionCreativeView",
+                        "http://myTrackingURL/secondCompanionCreativeView");
 
         assertThat(imageCompanionAdXmlManagers.get(6).getWidth()).isEqualTo(9000);
         assertThat(imageCompanionAdXmlManagers.get(6).getHeight()).isNull();
-        assertThat(imageCompanionAdXmlManagers.get(6).getType()).isNull();
-        assertThat(imageCompanionAdXmlManagers.get(6).getImageUrl()).isNull();
+        assertThat(imageCompanionAdXmlManagers.get(6).getResourceXmlManager().getStaticResourceType()).isNull();
+        assertThat(imageCompanionAdXmlManagers.get(6).getResourceXmlManager().getStaticResource()).isNull();
         assertThat(imageCompanionAdXmlManagers.get(6).getClickThroughUrl()).isNull();
         assertThat(imageCompanionAdXmlManagers.get(6).getClickTrackers()).isEmpty();
+        assertThat(imageCompanionAdXmlManagers.get(6).getCompanionCreativeViewTrackers()).isEmpty();
     }
 
     @Test
-    public void getMediaFileUrl_shouldReturnTheCorrectValue() {
-        String url = mXmlManager.getMediaFileUrl();
+    public void getAbsoluteProgressTrackers_withLinearXmlManager_shouldReturnCorrectValues() {
+        List<VastAbsoluteProgressTracker> trackers = mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getLinearXmlManagers().get(0).getAbsoluteProgressTrackers();
+
+        assertThat(trackers.size()).isEqualTo(2);
 
-        assertThat(url).isEqualTo("http://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
+        VastAbsoluteProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+
+        VastAbsoluteProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.getTrackingMilliseconds()).isEqualTo(3670300);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;" +
+                "src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;" +
+                "rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
     }
 
     @Test
-    public void getVastAdTagURI_shouldReturnTheCorrectValue() {
-        String url = mXmlManager.getVastAdTagURI();
+    public void getFractionalTrackers_withLinearXmlManager_shouldReturnCorrectValues() {
+        List<VastFractionalProgressTracker> trackers = mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getLinearXmlManagers().get(0).getFractionalProgressTrackers();
 
-        assertThat(url).isEqualTo("http://0.dsp.dev1.mopub.com/xml");
+        assertThat(trackers.size()).isEqualTo(7);
+
+        VastFractionalProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.trackingFraction()).isEqualTo(0.13f);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker2 = trackers.get(2);
+        assertThat(tracker2.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker2.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
+
+        VastFractionalProgressTracker tracker3 = trackers.get(3);
+        assertThat(tracker3.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker3.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker4 = trackers.get(4);
+        assertThat(tracker4.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker4.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+
+        VastFractionalProgressTracker tracker5 = trackers.get(5);
+        assertThat(tracker5.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker5.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
+
+        VastFractionalProgressTracker tracker6 = trackers.get(6);
+        assertThat(tracker6.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker6.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
     }
 
     @Test
-    public void parsingMalformedXml_shouldNotCauseProblems() {
-        String badXml = "<im>going<<<to||***crash></,>CDATA[]YOUR_FACE";
+    public void getVideoCompleteTrackers_withLinearXmlManager_shouldReturnTheCorrectValue() {
+        assertThat(VastUtils.vastTrackersToStrings(mXmlManager.getAdXmlManagers().get(0).getInLineXmlManager().getLinearXmlManagers().get(0).getVideoCompleteTrackers()))
+                .containsOnly("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;" +
+                                "pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;" +
+                                "timestamp=2922389;eid1=13;ecn1=1;etm1=0;",
+                        "http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;" +
+                                "ord=2922389?");
+    }
 
-        VastXmlManager badManager = new VastXmlManager();
+    @Test
+    public void getVideoCloseTrackers_withLinearXmlManager_shouldReturnTheCorrectValue() {
+        assertThat(VastUtils.vastTrackersToStrings(mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getLinearXmlManagers().get(0).getVideoCloseTrackers()))
+                .containsOnly("http://www.mopub.com/close?q=ignatius",
+                        "http://www.mopub.com/close?q=j3");
+    }
 
-        try {
-            badManager.parseVastXml(badXml);
-        } catch (ParserConfigurationException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } catch (SAXException e) {
-            e.printStackTrace();
-        }
+    @Test
+    public void getVideoSkipTrackers_withLinearXmlManager_shouldReturnTheCorrectValue() {
+        assertThat(VastUtils.vastTrackersToStrings(mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getLinearXmlManagers().get(0).getVideoSkipTrackers()))
+                .containsOnly("http://www.mopub.com/skip?q=ignatius",
+                        "http://www.mopub.com/skip?q=j3");
+    }
+
+    @Test
+    public void getClickThroughUrl_withLinearXmlManager_shouldReturnTheCorrectValue() {
+        String url = mXmlManager.getAdXmlManagers().get(0)
+                .getInLineXmlManager().getLinearXmlManagers().get(0).getClickThroughUrl();
 
-        assertThat(badManager.getImpressionTrackers().size()).isEqualTo(0);
+        assertThat(url).isEqualTo("http://www.google.com/support/richmedia");
     }
 
     @Test
-    public void parsingVastWithMalformedNodes_shouldNotCauseProblems() {
-        String badXml = "<VAST><Impression id=\"DART\"></Impression><Tracking event=\"start\"><![CDATA[ good ]]><ExtraNode><![CDATA[ bad ]]></ExtraNode></Tracking></VAST>";
+    public void getClickTrackers_withLinearXmlManager_shouldReturnTheCorrectValue() {
+        assertThat(VastUtils.vastTrackersToStrings(mXmlManager.getAdXmlManagers().get(0).getInLineXmlManager().getLinearXmlManagers().get(0).getClickTrackers()))
+                .containsOnly("http://ad.doubleclick.net/click%3Bh%3Dv8/3e1b/3/0/%2a/z%3B223626102%3B0-0%3B0%3B47414672%3B255-0/0%3B30477563/30495440/1%3B%3B%7Eaopt%3D0/0/ff/0%3B%7Esscs%3D%3fhttp://s0.2mdn.net/dot.gif",
+                        "http://ad.doubleclick.net/clk;212442087;33815766;i?http://www.google.com/support/richmedia");
+    }
 
-        VastXmlManager badManager = new VastXmlManager();
+    @Test
+    public void getSkipOffset_withLinearXmlManager_shouldReturnTheCorrectValue() {
+        String skipOffset = mXmlManager.getAdXmlManagers().get(0).getInLineXmlManager()
+                .getLinearXmlManagers().get(0).getSkipOffset();
 
-        try {
-            badManager.parseVastXml(badXml);
-        } catch (ParserConfigurationException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } catch (SAXException e) {
-            e.printStackTrace();
-        }
+        assertThat(skipOffset).isEqualTo("25%");
+    }
 
-        assertThat(badManager.getMediaFileUrl()).isEqualTo(null);
-        assertThat(badManager.getVideoMidpointTrackers().size()).isEqualTo(0);
-        assertThat(badManager.getImpressionTrackers().size()).isEqualTo(0);
+    @Test
+    public void getMediaFileUrl_withMediaXmlManager_shouldReturnTheCorrectValue() {
+        String url = mXmlManager.getAdXmlManagers().get(0).getInLineXmlManager()
+                .getLinearXmlManagers().get(0).getMediaXmlManagers().get(0).getMediaUrl();
 
-        List<String> startTrackers = badManager.getVideoStartTrackers();
-        assertThat(startTrackers.size()).isEqualTo(1);
-        assertThat(startTrackers.get(0)).isEqualTo("good");
+        assertThat(url).isEqualTo("http://s3.amazonaws.com/uploads.hipchat" +
+                ".com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
index cbc01aae..0c0935ef 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
@@ -4,11 +4,13 @@
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.shadows.ShadowGestureDetector;
 
 import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
@@ -25,7 +27,7 @@
     private ViewGestureDetector subject;
     private AdAlertGestureListener adAlertGestureListener;
     private View view;
-    private AdConfiguration adConfiguration;
+    @Mock AdReport mockAdReport;
 
     @Before
     public void setUp() throws Exception {
@@ -35,15 +37,14 @@ public void setUp() throws Exception {
         stub(view.getHeight()).toReturn(50);
 
         adAlertGestureListener = mock(AdAlertGestureListener.class);
-        adConfiguration = mock(AdConfiguration.class);
 
-        subject = new ViewGestureDetector(context, view, adConfiguration);
+        subject = new ViewGestureDetector(context, view, mockAdReport);
         subject.setAdAlertGestureListener(adAlertGestureListener);
     }
 
     @Test
     public void constructor_shouldDisableLongPressAndSetGestureListener() throws Exception {
-        subject = new ViewGestureDetector(context, view, adConfiguration);
+        subject = new ViewGestureDetector(context, view, mockAdReport);
 
         ShadowGestureDetector shadowGestureDetector = shadowOf(subject);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
index 7fa291fc..529c4a44 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
@@ -3,7 +3,10 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.Point;
 import android.location.Location;
+import android.location.LocationManager;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.net.Uri;
@@ -11,26 +14,33 @@
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
 
-import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.GpsHelper;
 import com.mopub.common.GpsHelperTest;
 import com.mopub.common.MoPub;
-import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Reflection.MethodBuilder;
 import com.mopub.common.util.Utils;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
+import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.Networking;
+import com.mopub.network.PlayServicesUrlRewriter;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowConnectivityManager;
+import org.robolectric.shadows.ShadowLocationManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
@@ -43,13 +53,13 @@
 import static android.net.ConnectivityManager.TYPE_MOBILE_SUPL;
 import static android.net.ConnectivityManager.TYPE_WIFI;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
-import static com.mopub.common.AdUrlGenerator.TwitterAppInstalledStatus;
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
-import static com.mopub.common.util.Strings.isEmpty;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
@@ -58,8 +68,12 @@
 @Config(shadows = {MoPubShadowTelephonyManager.class})
 public class WebViewAdUrlGeneratorTest {
 
-    private WebViewAdUrlGenerator subject;
     private static final String TEST_UDID = "20b013c721c";
+    private static final int TEST_SCREEN_WIDTH = 42;
+    private static final int TEST_SCREEN_HEIGHT = 1337;
+    private static final float TEST_DENSITY = 1.0f;
+
+    private WebViewAdUrlGenerator subject;
     private String expectedUdid;
     private Configuration configuration;
     private MoPubShadowTelephonyManager shadowTelephonyManager;
@@ -69,20 +83,52 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-        subject = new WebViewAdUrlGenerator(context);
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+        when(context.getPackageName()).thenReturn("testBundle");
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
+
+        subject = new WebViewAdUrlGenerator(context,
+                new MraidNativeCommandHandler().isStorePictureSupported(context));
         Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
         expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
         configuration = application.getResources().getConfiguration();
         shadowTelephonyManager = (MoPubShadowTelephonyManager) shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
         shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        Networking.useHttps(false);
     }
 
     @After
     public void tearDown() throws Exception {
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
         reset(methodBuilder);
     }
 
@@ -95,6 +141,13 @@ public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
         assertThat(adUrl).isEqualTo(expectedAdUrl);
     }
 
+    @Test
+    public void generateAdUrl_withHttpsScheme() throws Exception {
+        Networking.useHttps(true);
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).startsWith("https://");
+    }
+
     @Test
     public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
         String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
@@ -110,7 +163,7 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
         final String expectedAdUrl = new AdUrlBuilder(expectedUdid)
                 .withAdUnitId("adUnitId")
                 .withQuery("key%3Avalue")
-                .withLatLon("20.1%2C30.0", "1")
+                .withLatLon("20.1%2C30.0", "1", "101325")
                 .withMcc("123")
                 .withMnc("456")
                 .withCountryIso("expected%20country")
@@ -126,6 +179,7 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
         location.setLatitude(20.1);
         location.setLongitude(30.0);
         location.setAccuracy(1.23f); // should get rounded to "1"
+        location.setTime(System.currentTimeMillis() - 101325);
 
         String adUrl = subject
                 .withAdUnitId("adUnitId")
@@ -133,6 +187,9 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
                 .withLocation(location)
                 .generateUrlString("ads.mopub.com");
 
+        // Only compare the seconds since millis can be off
+        adUrl = adUrl.replaceFirst("llf=101[0-9]{3}", "llf=101325");
+
         assertThat(adUrl).isEqualTo(expectedAdUrl);
     }
 
@@ -283,45 +340,6 @@ public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkTy
         assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
     }
 
-    @Test
-    public void generateAdUrl_whenTwitterIsNotInstalled_shouldProcessAndNotSetTwitterInstallStatusOnFirstRequest() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
-        doReturn(TwitterAppInstalledStatus.NOT_INSTALLED).when(spySubject).getTwitterAppInstallStatus();
-
-        String adUrl = spySubject.generateUrlString("ads.mopub.com");
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED).build());
-    }
-
-    @Test
-    public void generateAdUrl_whenTwitterIsInstalled_shouldProcessAndSetTwitterInstallStatusOnFirstRequest() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
-        doReturn(TwitterAppInstalledStatus.INSTALLED).when(spySubject).getTwitterAppInstallStatus();
-
-        String adUrl = spySubject.generateUrlString("ads.mopub.com");
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withTwitterAppInstalledStatus(TwitterAppInstalledStatus.INSTALLED).build());
-    }
-
-    @Test
-    public void generateAdUrl_shouldNotProcessTwitterInstallStatusIfStatusIsAlreadySet() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED);
-        doReturn(TwitterAppInstalledStatus.INSTALLED).when(spySubject).getTwitterAppInstallStatus();
-
-        String adUrl = spySubject.generateUrlString("ads.mopub.com");
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED).build());
-    }
-
     @Test
     public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
         AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
@@ -332,6 +350,8 @@ public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
         assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
     }
 
+
+
     @Test
     public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldUseAdInfoParams() throws Exception {
         GpsHelper.setClassNamesForTesting();
@@ -340,11 +360,8 @@ public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_should
         when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
 
         GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        SharedPreferencesHelper.getSharedPreferences(context)
-                .edit()
-                .putString(GpsHelper.ADVERTISING_ID_KEY, adInfo.ADVERTISING_ID)
-                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
-                .commit();
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+        clientMetadata.setAdvertisingInfo(adInfo.mAdId, adInfo.mLimitAdTrackingEnabled);
 
         expectedUdid = "ifa%3A" + adInfo.ADVERTISING_ID;
         String expectedAdUrl = new AdUrlBuilder(expectedUdid)
@@ -353,29 +370,138 @@ public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_should
         assertThat(generateMinimumUrlString()).isEqualTo(expectedAdUrl);
     }
 
+    @Test
+    public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+    }
+
+    @Test
+    public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+
+        // Mock out the LocationManager's last known location to be older than the
+        // developer-supplied location.
+        Location olderLocation = new Location("");
+        olderLocation.setLatitude(40);
+        olderLocation.setLongitude(-105);
+        olderLocation.setAccuracy(8.0f);
+        olderLocation.setTime(500);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+    }
+
+    @Test
+    public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(38);
+        locationFromSdk.setLongitude(-123);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
+                locationFromSdk);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+    }
+
+    @Test
+    public void generateAdUrl_withNullPackageName_withEmptyPackageName_shouldNotIncludeBundleKey() {
+        when(context.getPackageName()).thenReturn(null).thenReturn("");
+
+        final String adUrlNullPackageName = generateMinimumUrlString();
+        final String adUrlEmptyPackageName = generateMinimumUrlString();
+
+        assertThat(adUrlNullPackageName).doesNotContain("&bundle=");
+        assertThat(adUrlEmptyPackageName).doesNotContain("&bundle=");
+    }
+
     @Test
     public void enableLocationTracking_shouldIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
         String adUrl = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(adUrl)).isNotNull();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNotNull();
     }
 
     @Test
     public void disableLocationCollection_shouldNotIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
         String adUrl = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(adUrl)).isNullOrEmpty();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
+    }
+
+    @Test
+    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+
+        // Mock out the LocationManager's last known location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
     }
 
-    private String getLocationFromRequestUrl(String requestString) {
+    private String getParameterFromRequestUrl(String requestString, String key) {
         Uri requestUri = Uri.parse(requestString);
-        String location = requestUri.getQueryParameter("ll");
+        String parameter = requestUri.getQueryParameter(key);
 
-        if (TextUtils.isEmpty(location)) {
+        if (TextUtils.isEmpty(parameter)) {
             return "";
         }
 
-        return location;
+        return parameter;
     }
 
     private NetworkInfo createNetworkInfo(int type) {
@@ -394,13 +520,13 @@ private String generateMinimumUrlString() {
         private String query = "";
         private String latLon = "";
         private String locationAccuracy = "";
+        private String latLonLastUpdated = "";
         private String mnc = "";
         private String mcc = "";
         private String countryIso = "";
         private String carrierName = "";
         private String dnt = "";
         private MoPubNetworkType networkType = MoPubNetworkType.MOBILE;
-        private TwitterAppInstalledStatus twitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
         private int externalStoragePermission;
 
         public AdUrlBuilder(String expectedUdid) {
@@ -415,23 +541,25 @@ public String build() {
                     "&dn=" + Build.MANUFACTURER +
                     "%2C" + Build.MODEL +
                     "%2C" + Build.PRODUCT +
-                    "&udid=" + expectedUdid +
-                    paramIfNotEmpty("dnt", dnt) +
+                    "&bundle=" + "testBundle" +
                     paramIfNotEmpty("q", query) +
-                    (isEmpty(latLon) ? "" : "&ll=" + latLon + "&lla=" + locationAccuracy) +
+                    (TextUtils.isEmpty(latLon) ? "" :
+                            "&ll=" + latLon + "&lla=" + locationAccuracy + "&llf=" + latLonLastUpdated) +
                     "&z=-0700" +
                     "&o=u" +
+                    "&w=" + TEST_SCREEN_WIDTH +
+                    "&h=" + TEST_SCREEN_HEIGHT +
                     "&sc_a=1.0" +
-                    "&mr=1" +
                     paramIfNotEmpty("mcc", mcc) +
                     paramIfNotEmpty("mnc", mnc) +
                     paramIfNotEmpty("iso", countryIso) +
                     paramIfNotEmpty("cn", carrierName) +
                     "&ct=" + networkType +
-                    "&av=1.0" +
-                    "&android_perms_ext_storage=" + externalStoragePermission +
-                    ((twitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) ? "&ts=1" : "");
-
+                    "&av=" + BuildConfig.VERSION_NAME +
+                    "&udid=" + PlayServicesUrlRewriter.UDID_TEMPLATE +
+                    "&dnt=" + PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE +
+                    "&mr=1" +
+                    "&android_perms_ext_storage=" + externalStoragePermission;
         }
 
         public AdUrlBuilder withAdUnitId(String adUnitId) {
@@ -444,9 +572,11 @@ public AdUrlBuilder withQuery(String query) {
             return this;
         }
 
-        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy) {
+        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy,
+                String latLonLastUpdated) {
             this.latLon = latLon;
             this.locationAccuracy = locationAccuracy;
+            this.latLonLastUpdated = latLonLastUpdated;
             return this;
         }
 
@@ -480,11 +610,6 @@ public AdUrlBuilder withExternalStoragePermission(boolean enabled) {
             return this;
         }
 
-        public AdUrlBuilder withTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
-            this.twitterAppInstalledStatus = status;
-            return this;
-        }
-
         public AdUrlBuilder withDnt(boolean dnt) {
             if (dnt) {
                 this.dnt = "1";
@@ -493,7 +618,7 @@ public AdUrlBuilder withDnt(boolean dnt) {
         }
 
         private String paramIfNotEmpty(String key, String value) {
-            if (isEmpty(value)) {
+            if (TextUtils.isEmpty(value)) {
                 return "";
             } else {
                 return "&" + key + "=" + value;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/ShadowVastVideoView.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/ShadowVastVideoView.java
new file mode 100644
index 00000000..b66c9708
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/ShadowVastVideoView.java
@@ -0,0 +1,10 @@
+package com.mopub.mobileads.test.support;
+
+import com.mopub.mobileads.VastVideoView;
+
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowVideoView;
+
+@Implements(VastVideoView.class)
+public class ShadowVastVideoView extends ShadowVideoView {
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetchTaskFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetchTaskFactory.java
deleted file mode 100644
index 599de6b1..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetchTaskFactory.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import com.mopub.mobileads.AdFetchTask;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.TaskTracker;
-import com.mopub.mobileads.factories.AdFetchTaskFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestAdFetchTaskFactory extends AdFetchTaskFactory {
-    private AdFetchTask mockAdFetchTask = mock(AdFetchTask.class);
-
-    public static AdFetchTask getSingletonMock() {
-        return getTestFactory().mockAdFetchTask;
-    }
-
-    private static TestAdFetchTaskFactory getTestFactory() {
-        return ((TestAdFetchTaskFactory) AdFetchTaskFactory.instance);
-    }
-
-    @Override
-    protected AdFetchTask internalCreate(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        return mockAdFetchTask;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetcherFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetcherFactory.java
deleted file mode 100644
index d36df69b..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetcherFactory.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import com.mopub.mobileads.AdFetcher;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.factories.AdFetcherFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestAdFetcherFactory extends AdFetcherFactory {
-    private AdFetcher mockAdFetcher = mock(AdFetcher.class);
-
-    public static AdFetcher getSingletonMock() {
-        return getTestFactory().mockAdFetcher;
-    }
-
-    private static TestAdFetcherFactory getTestFactory() {
-        return ((TestAdFetcherFactory) AdFetcherFactory.instance);
-    }
-
-    @Override
-    public AdFetcher internalCreate(AdViewController adViewController, String userAgent) {
-        return mockAdFetcher;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java
index a26bf457..b6301488 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java
@@ -1,16 +1,21 @@
 package com.mopub.mobileads.test.support;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventBannerAdapter;
 import com.mopub.mobileads.MoPubView;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
+import java.util.Map;
+
 import static org.mockito.Mockito.mock;
 
 public class TestCustomEventBannerAdapterFactory extends CustomEventBannerAdapterFactory {
     private CustomEventBannerAdapter mockCustomEventBannerAdapter = mock(CustomEventBannerAdapter.class);
     private MoPubView moPubView;
     private String className;
-    private String classData;
+    private Map<String, String> classData;
 
     public static CustomEventBannerAdapter getSingletonMock() {
         return getTestFactory().mockCustomEventBannerAdapter;
@@ -21,10 +26,14 @@ private static TestCustomEventBannerAdapterFactory getTestFactory() {
     }
 
     @Override
-    protected CustomEventBannerAdapter internalCreate(MoPubView moPubView, String className, String classData) {
+    protected CustomEventBannerAdapter internalCreate(@NonNull final MoPubView moPubView,
+            @NonNull final String className,
+            @NonNull final Map<String, String> serverExtras,
+            final long broadcastIdentifier,
+            @NonNull final AdReport adReport) {
         this.moPubView = moPubView;
         this.className = className;
-        this.classData = classData;
+        this.classData = serverExtras;
         return mockCustomEventBannerAdapter;
     }
 
@@ -36,7 +45,7 @@ public static String getLatestClassName() {
         return getTestFactory().className;
     }
 
-    public static String getLatestClassData() {
+    public static Map<String, String> getLatestClassData() {
         return getTestFactory().classData;
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java
index 10893134..a392ad53 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java
@@ -1,16 +1,19 @@
 package com.mopub.mobileads.test.support;
 
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventInterstitialAdapter;
 import com.mopub.mobileads.MoPubInterstitial;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
+import java.util.Map;
+
 import static org.mockito.Mockito.mock;
 
 public class TestCustomEventInterstitialAdapterFactory extends CustomEventInterstitialAdapterFactory{
     private CustomEventInterstitialAdapter mockCustomEventInterstitalAdapter = mock(CustomEventInterstitialAdapter.class);
     private MoPubInterstitial latestMoPubInterstitial;
     private String latestClassName;
-    private String latestClassData;
+    private Map<String, String> latestClassData;
 
     public static CustomEventInterstitialAdapter getSingletonMock() {
         return getTestFactory().mockCustomEventInterstitalAdapter;
@@ -28,15 +31,15 @@ public static String getLatestClassName() {
         return getTestFactory().latestClassName;
     }
 
-    public static String getLatestClassData() {
+    public static Map<String, String> getLatestServerExtras() {
         return getTestFactory().latestClassData;
     }
 
     @Override
-    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, String classData) {
+    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
         latestMoPubInterstitial = moPubInterstitial;
         latestClassName = className;
-        latestClassData = classData;
+        latestClassData = serverExtras;
         return mockCustomEventInterstitalAdapter;
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java
index 0909e309..84c91fc5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java
@@ -3,7 +3,7 @@
 import android.content.Context;
 import android.webkit.WebSettings;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlBannerWebView;
 import com.mopub.mobileads.factories.HtmlBannerWebViewFactory;
 
@@ -17,6 +17,7 @@
     private boolean latestIsScrollable;
     private String latestRedirectUrl;
     private String latestClickthroughUrl;
+    private AdReport latestAdReport;
 
     public TestHtmlBannerWebViewFactory() {
         WebSettings webSettings = mock(WebSettings.class);
@@ -34,15 +35,17 @@ private static TestHtmlBannerWebViewFactory getTestFactory() {
 
     @Override
     public HtmlBannerWebView internalCreate(
-            Context context, CustomEventBannerListener
-            customEventBannerListener,
+            Context context,
+            AdReport adReport,
+            CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl, AdConfiguration adConfiguration) {
+            String clickthroughUrl) {
         latestListener = customEventBannerListener;
         latestIsScrollable = isScrollable;
         latestRedirectUrl = redirectUrl;
         latestClickthroughUrl = clickthroughUrl;
+        latestAdReport = adReport;
         return mockHtmlBannerWebView;
     }
 
@@ -61,4 +64,8 @@ public static String getLatestRedirectUrl() {
     public static String getLatestClickthroughUrl() {
         return getTestFactory().latestClickthroughUrl;
     }
+
+    public static AdReport getLatestAdReport() {
+        return getTestFactory().latestAdReport;
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java
index d5fea284..c9dc4c47 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlInterstitialWebView;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 
@@ -16,7 +16,6 @@
     private boolean latestIsScrollable;
     private String latestRedirectUrl;
     private String latestClickthroughUrl;
-    private AdConfiguration latestAdConfiguration;
 
     public static HtmlInterstitialWebView getSingletonMock() {
         return getTestFactory().mockHtmlInterstitialWebView;
@@ -27,12 +26,11 @@ private static TestHtmlInterstitialWebViewFactory getTestFactory() {
     }
 
     @Override
-    public HtmlInterstitialWebView internalCreate(Context context, CustomEventInterstitialListener customEventInterstitialListener, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
+    public HtmlInterstitialWebView internalCreate(Context context, AdReport adReport, CustomEventInterstitialListener customEventInterstitialListener, boolean isScrollable, String redirectUrl, String clickthroughUrl) {
         latestListener = customEventInterstitialListener;
         latestIsScrollable = isScrollable;
         latestRedirectUrl = redirectUrl;
         latestClickthroughUrl = clickthroughUrl;
-        latestAdConfiguration = adConfiguration;
         return getTestFactory().mockHtmlInterstitialWebView;
     }
 
@@ -50,8 +48,4 @@ public static String getLatestRedirectUrl() {
     public static String getLatestClickthroughUrl() {
         return getTestFactory().latestClickthroughUrl;
     }
-
-    public static AdConfiguration getLatestAdConfiguration() {
-        return getTestFactory().latestAdConfiguration;
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidControllerFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidControllerFactory.java
new file mode 100644
index 00000000..511499fe
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidControllerFactory.java
@@ -0,0 +1,30 @@
+package com.mopub.mobileads.test.support;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
+import com.mopub.mobileads.factories.MraidControllerFactory;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.PlacementType;
+
+import static org.mockito.Mockito.mock;
+
+public class TestMraidControllerFactory extends MraidControllerFactory {
+    private MraidController mockMraidController = mock(MraidController.class);
+
+    public static MraidController getSingletonMock() {
+        return getTestFactory().mockMraidController;
+    }
+
+    private static TestMraidControllerFactory getTestFactory() {
+        return ((TestMraidControllerFactory) MraidControllerFactory.instance);
+    }
+
+    @Override
+    protected MraidController internalCreate(@NonNull final Context context,
+            @NonNull AdReport adReport,
+            @NonNull final PlacementType placementType) {
+        return mockMraidController;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidViewFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidViewFactory.java
deleted file mode 100644
index 005ac90d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidViewFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import android.content.Context;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.MraidView;
-import com.mopub.mobileads.factories.MraidViewFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestMraidViewFactory extends MraidViewFactory {
-    private final MraidView mockMraidView = mock(MraidView.class);
-
-    public static MraidView getSingletonMock() {
-        return getTestFactory().mockMraidView;
-    }
-
-    private static TestMraidViewFactory getTestFactory() {
-        return (TestMraidViewFactory) instance;
-    }
-
-    @Override
-    protected MraidView internalCreate(Context context, AdConfiguration adConfiguration) {
-        return mockMraidView;
-    }
-
-    @Override
-    protected MraidView internalCreate(Context context, AdConfiguration adConfiguration, MraidView.ExpansionStyle expansionStyle, MraidView.NativeCloseButtonStyle buttonStyle, MraidView.PlacementType placementType) {
-        return mockMraidView;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java
index 8e9afc9c..d2e60e1b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java
@@ -3,7 +3,7 @@
 import android.content.Context;
 
 import com.mopub.mobileads.factories.VastManagerFactory;
-import com.mopub.mobileads.util.vast.VastManager;
+import com.mopub.mobileads.VastManager;
 
 import static org.mockito.Mockito.mock;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestViewGestureDetectorFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestViewGestureDetectorFactory.java
deleted file mode 100644
index 1bce3891..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestViewGestureDetectorFactory.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import android.content.Context;
-import android.view.View;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.ViewGestureDetector;
-import com.mopub.mobileads.factories.ViewGestureDetectorFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestViewGestureDetectorFactory extends ViewGestureDetectorFactory {
-    private ViewGestureDetector mockViewGestureDetector = mock(ViewGestureDetector.class);
-
-    public static ViewGestureDetector getSingletonMock() {
-        return getTestFactory().mockViewGestureDetector;
-    }
-
-    private static TestViewGestureDetectorFactory getTestFactory() {
-        return ((TestViewGestureDetectorFactory) instance);
-    }
-
-    @Override
-    protected ViewGestureDetector internalCreate(Context context, View view, AdConfiguration adConfiguration) {
-        return mockViewGestureDetector;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/VastUtils.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/VastUtils.java
new file mode 100644
index 00000000..65eb1f81
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/VastUtils.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads.test.support;
+
+import com.mopub.mobileads.VastTracker;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.xml.sax.InputSource;
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+public class VastUtils {
+    public static Node createNode(String xml) throws Exception {
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        documentBuilderFactory.setCoalescing(true);
+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+        Document document = documentBuilder.parse(new InputSource(new StringReader(xml)));
+        return document.getFirstChild();
+    }
+
+    public static List<VastTracker> stringsToVastTrackers(String... strings) {
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>(strings.length);
+        for (int i=0; i<strings.length; i++) {
+            vastTrackers.add(new VastTracker(strings[i]));
+        }
+        return vastTrackers;
+    }
+
+    public static List<String> vastTrackersToStrings(List<VastTracker> vastTrackers) {
+        List<String> strings = new ArrayList<String>(vastTrackers.size());
+        for (VastTracker vastTracker : vastTrackers) {
+            strings.add(vastTracker.getTrackingUrl());
+        }
+        return strings;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/InterstitialsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/InterstitialsTest.java
deleted file mode 100644
index 56f21194..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/InterstitialsTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.app.Activity;
-import android.graphics.Color;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-
-import com.mopub.common.util.Dips;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static com.mopub.mobileads.util.Interstitials.addCloseEventRegion;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(RobolectricTestRunner.class)
-public class InterstitialsTest {
-
-    private Activity context;
-    private RelativeLayout.LayoutParams defaultLayoutParams;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        defaultLayoutParams = new RelativeLayout.LayoutParams(50, 50);
-    }
-
-    @Test
-    public void addCloseEventRegion_withNullViewGroup_shouldReturnFalse() throws Exception {
-        boolean result = addCloseEventRegion(null, defaultLayoutParams, null);
-
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void addCloseEventRegion_withViewGroupButNoContext_shouldReturnFalse() throws Exception {
-        ViewGroup viewGroup = mock(ViewGroup.class);
-        when(viewGroup.getContext()).thenReturn(null);
-
-        boolean result = addCloseEventRegion(viewGroup, defaultLayoutParams, null);
-
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void addCloseEventRegion_shouldAddTransparentButVisibleButton() throws Exception {
-        final LinearLayout linearLayout = new LinearLayout(context);
-
-        addCloseEventRegion(linearLayout, defaultLayoutParams, null);
-
-        final Button closeEventRegion = (Button) linearLayout.getChildAt(0);
-        assertThat(closeEventRegion.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(closeEventRegion).getBackgroundColor()).isEqualTo(Color.TRANSPARENT);
-        assertThat(Dips.pixelsToIntDips((float) closeEventRegion.getLayoutParams().width, context)).isEqualTo(50);
-        assertThat(Dips.pixelsToIntDips((float)closeEventRegion.getLayoutParams().height, context)).isEqualTo(50);
-    }
-
-    @Test
-    public void addCloseEventRegion_shouldUsePassedInClickListener() throws Exception {
-        final LinearLayout linearLayout = new LinearLayout(context);
-        final View.OnClickListener onClickListener = mock(View.OnClickListener.class);
-
-        addCloseEventRegion(linearLayout, defaultLayoutParams, onClickListener);
-
-        final Button closeEventRegion = (Button) linearLayout.getChildAt(0);
-        assertThat(shadowOf(closeEventRegion).getOnClickListener()).isEqualTo(onClickListener);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
deleted file mode 100644
index 6e24109d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
+++ /dev/null
@@ -1,186 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-import android.os.Environment;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowEnvironment;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(SdkTestRunner.class)
-public class MraidsTest {
-    Context context;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-    }
-
-    @Test
-    public void isTelAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData("tel", null, null, "android.intent.action.DIAL");
-
-        assertThat(Mraids.isTelAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isTelAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.DIAL");
-
-        assertThat(Mraids.isTelAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isSmsAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData("sms", null, null, "android.intent.action.VIEW");
-
-        assertThat(Mraids.isSmsAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isSmsAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.VIEW");
-
-        assertThat(Mraids.isSmsAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isStorePictureAvailable_whenPermissionDeclaredAndMediaMounted_shouldReturnTrue() throws Exception {
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
-
-        assertThat(Mraids.isStorePictureSupported(context)).isTrue();
-    }
-
-    @Test
-    public void isStorePictureAvailable_whenPermissionDenied_shouldReturnFalse() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
-
-        assertThat(Mraids.isStorePictureSupported(context)).isFalse();
-    }
-
-    @Test
-    public void isStorePictureAvailable_whenMediaUnmounted_shouldReturnFalse() throws Exception {
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
-
-        assertThat(Mraids.isStorePictureSupported(context)).isFalse();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void isCalendarAvailable_atLeastIcs_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, null, Mraids.ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
-        assertThat(Mraids.isCalendarAvailable(context)).isTrue();
-    }
-
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
-    @Test
-    public void isCalendarAvailable_beforeIcs_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, null, Mraids.ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
-        assertThat(Mraids.isCalendarAvailable(context)).isFalse();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void isCalendarAvailable_atLeastIcs_butCanNotAcceptIntent_shouldReturnFalse() throws
-            Exception {
-        context = createMockContextWithSpecificIntentData(null, null, "vnd.android.cursor.item/NOPE", "android.intent.action.INSERT");
-        assertThat(Mraids.isCalendarAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isInlineVideoAvailable_whenCanAcceptMraidVideoPlayerActivityIntent_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, "com.mopub.mobileads.MraidVideoPlayerActivity", null, null);
-
-        assertThat(Mraids.isInlineVideoAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isInlineVideoAvailable_whenCanNotAcceptMraidVideoPlayerActivityIntent_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, "com.mopub.mobileads.DO_NOT_ACCEPT", null, null);
-
-        assertThat(Mraids.isInlineVideoAvailable(context)).isFalse();
-    }
-
-    public static Context createMockContextWithSpecificIntentData(final String scheme, final String componentName, final String type, final String action) {
-        Context context = mock(Context.class);
-        PackageManager packageManager = mock(PackageManager.class);
-
-        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
-        resolveInfos.add(new ResolveInfo());
-
-        stub(context.getPackageManager()).toReturn(packageManager);
-
-        BaseMatcher intentWithSpecificData = new BaseMatcher() {
-            // check that the specific intent has the special data, i.e. "tel:", or a component name, or string type, based on a particular data
-
-            @Override
-            public boolean matches(Object item) {
-                if (item != null && item instanceof Intent ){
-                    boolean result = action != null || type != null || componentName != null || scheme != null;
-                    if (action != null) {
-                        if (((Intent) item).getAction() != null) {
-                            result = result && action.equals(((Intent) item).getAction());
-                        }
-                    }
-
-                    if (type != null) {
-                        if (((Intent) item).getType() != null) {
-                            result = result && type.equals(((Intent) item).getType());
-                        }
-                    }
-
-                    if (componentName != null) {
-                        if (((Intent) item).getComponent() != null) {
-                            result = result && componentName.equals(((Intent) item).getComponent().getClassName());
-                        }
-                    }
-
-                    if (scheme != null) {
-                        if (((Intent) item).getData() != null) {
-                            result = result && scheme.equals(((Intent) item).getData().getScheme());
-                        }
-                    }
-                    return result;
-                }
-                return false;
-            }
-
-            @Override
-            public void describeTo(Description description) {
-
-            }
-        };
-
-        // It is okay to query with specific intent or nothing, because by default, none of the query would normally any resolveInfo anyways
-        stub(packageManager.queryIntentActivities((Intent) argThat(intentWithSpecificData), eq(0))).toReturn(resolveInfos);
-        return context;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
new file mode 100644
index 00000000..712eef93
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
@@ -0,0 +1,42 @@
+package com.mopub.mobileads.util;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class WebViewsTest {
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void pause_withIsFinishingTrue_shouldStopLoading_shouldLoadBlankUrl_shouldPauseWebView() throws Exception {
+        WebView mockWebView = mock(WebView.class);
+
+        WebViews.onPause(mockWebView, true);
+
+        verify(mockWebView).stopLoading();
+        verify(mockWebView).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void pause_withIsFinishingFalse_shouldPauseWebView() throws Exception {
+        WebView mockWebView = mock(WebView.class);
+
+        WebViews.onPause(mockWebView, false);
+
+        verify(mockWebView, never()).stopLoading();
+        verify(mockWebView, never()).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java
new file mode 100644
index 00000000..426819d4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java
@@ -0,0 +1,249 @@
+package com.mopub.mobileads.util;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.xml.sax.InputSource;
+
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class XmlUtilsTest {
+
+    // From Microsoft's sample xml documents page: https://msdn.microsoft.com/en-us/library/bb387026.aspx
+    private String testXml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
+            "<aw:PurchaseOrders xmlns:aw=\"http://www.adventure-works.com\">\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99503\" aw:OrderDate=\"1999-10-20\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Ellen Adams</aw:Name>\n" +
+            "      <aw:Street>123 Maple Street</aw:Street>\n" +
+            "      <aw:City>Mill Valley</aw:City>\n" +
+            "      <aw:State>CA</aw:State>\n" +
+            "      <aw:Zip>10999</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Tai Yee</aw:Name>\n" +
+            "      <aw:Street>8 Oak Avenue</aw:Street>\n" +
+            "      <aw:City>Old Town</aw:City>\n" +
+            "      <aw:State>PA</aw:State>\n" +
+            "      <aw:Zip>95819</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please leave packages in shed by driveway.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Lawnmower</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>148.95</aw:USPrice>\n" +
+            "        <aw:Comment>Confirm this is electric</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"926-AA\">\n" +
+            "        <aw:ProductName>Baby Monitor</aw:ProductName>\n" +
+            "        <aw:Quantity>2</aw:Quantity>\n" +
+            "        <aw:USPrice>39.98</aw:USPrice>\n" +
+            "        <aw:ShipDate>1999-05-21</aw:ShipDate>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99505\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please notify me before shipping.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"456-NM\">\n" +
+            "        <aw:ProductName>Power Supply</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>45.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99504\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Seattle</aw:City>\n" +
+            "      <aw:State>WA</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Computer Keyboard</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>29.99</aw:USPrice>\n" +
+            "        <aw:Comment>this thing breaks all the time</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AM\">\n" +
+            "        <aw:ProductName>Wireless Mouse</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>14.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "</aw:PurchaseOrders>";
+    private Document testDoc;
+    private Node purchaseOrderNode;
+
+
+    @Before
+    public void setUp() throws Exception {
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        documentBuilderFactory.setCoalescing(true);
+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+        testDoc = documentBuilder.parse(new InputSource(new StringReader(testXml)));
+        purchaseOrderNode = testDoc.getFirstChild();
+    }
+
+    @Test
+    public void getFirstMatchingNode_shouldReturnValue() {
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder");
+        assertThat(resultNode).isNotNull();
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_shouldFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-22");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNotNull();
+        assertThat(resultNode.getNodeName()).isEqualTo("aw:PurchaseOrder");
+        assertThat(resultNode.getAttributes().getNamedItem("aw:OrderDate").getNodeValue()).isEqualTo("1999-10-22");
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_withUnmatchedAttribute_shouldNotFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNull();
+    }
+
+    @Test
+    public void getMatchingChildNodes_withNullAttributeValues_shouldReturnMultiple() throws Exception {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", null);
+        assertThat(results.size()).isEqualTo(3);
+    }
+
+    @Test
+    public void getMatchingChildNodes_withEmptyAttributeValues_shouldReturnNone() {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", new ArrayList<String>());
+        assertThat(results).isEmpty();
+    }
+
+    @Test
+    public void getAttributeValue_shouldReturnCorrectValue() throws Exception {
+        Node child = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder");
+
+        String purchaseOrderNumber = XmlUtils.getAttributeValue(child, "aw:PurchaseOrderNumber");
+        String orderDate = XmlUtils.getAttributeValue(child, "aw:OrderDate");
+
+        assertThat(purchaseOrderNumber).isEqualTo("99503");
+        assertThat(orderDate).isEqualTo("1999-10-20");
+    }
+
+    @Test
+    public void getListFromDocument_shouldReturnCorrectValue() throws Exception {
+        // Get all the "aw:PurchaseOrder" nodes. If any of them have an "aw:OrderDate" attribute, extract a Date.
+        List<Date> orderDates = XmlUtils.getListFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDates.size()).isEqualTo(3);
+        assertThat(orderDates.get(0).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(0).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(0).getDate()).isEqualTo(20);
+
+        assertThat(orderDates.get(1).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(1).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(1).getDate()).isEqualTo(22);
+
+        assertThat(orderDates.get(2).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(2).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(2).getDate()).isEqualTo(22);
+    }
+
+    @Test
+    public void getFirstMatchFromDocument_shouldReturnCorrectValue() throws Exception {
+        // Get the first "aw:PurchaseOrder" nodes. If it has an "aw:OrderDate" attribute, extract a Date.
+        Date orderDate = XmlUtils.getFirstMatchFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDate).isNotNull();
+        assertThat(orderDate.getYear()).isEqualTo(99);
+        assertThat(orderDate.getMonth()).isEqualTo(9);
+        assertThat(orderDate.getDate()).isEqualTo(20);
+    }
+
+    @Test
+    public void getStringDataAsList_shouldFindDeepNested() throws Exception {
+        final List<String> strings = XmlUtils.getStringDataAsList(testDoc, "aw:Comment", null, null);
+        assertThat(strings.size()).isEqualTo(2);
+        assertThat(strings.get(0)).isEqualTo("Confirm this is electric");
+        assertThat(strings.get(1)).isEqualTo("this thing breaks all the time");
+    }
+
+    @Test
+    public void getFirstMatchingStringData_shouldFindFirstMatch() throws Exception {
+        final String firstMatch = XmlUtils.getFirstMatchingStringData(testDoc, "aw:Comment", null, null);
+        assertThat(firstMatch).isNotNull();
+        assertThat(firstMatch).isEqualTo("Confirm this is electric");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
deleted file mode 100644
index 4e1faf55..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
+++ /dev/null
@@ -1,565 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import android.app.Activity;
-import android.content.Context;
-import android.view.Display;
-import android.view.WindowManager;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.mobileads.util.vast.VastManager.VastManagerListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class VastManagerTest {
-    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives></InLine></Ad></VAST>";
-    static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-
-    private VastManager subject;
-    private FakeHttpLayer mFakeHttpLayer;
-    private VastManagerListener vastManagerListener;
-    private Activity context;
-    private VastVideoConfiguration vastVideoConfiguration;
-    private Semaphore semaphore;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        CacheService.initializeDiskCache(context);
-        subject = new VastManager(context);
-        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
-
-        semaphore = new Semaphore(0);
-        vastManagerListener = mock(VastManagerListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                VastManagerTest.this.vastVideoConfiguration = (VastVideoConfiguration) args[0];
-                semaphore.release();
-                return null;
-            }
-        }).when(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-    }
-
-    @After
-    public void tearDown() {
-        Robolectric.getFakeHttpLayer().clearPendingHttpResponses();
-        CacheService.clearAndNullCaches();
-    }
-
-    private void prepareVastVideoConfiguration() {
-        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCorrectVastValues() throws Exception {
-        // Vast redirect responses
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
-
-        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
-
-        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
-        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(5);
-        assertThat(vastVideoConfiguration.getStartTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getMidpointTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getThirdQuartileTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(1);
-
-        final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
-        assertThat(vastCompanionAd.getWidth()).isEqualTo(300);
-        assertThat(vastCompanionAd.getHeight()).isEqualTo(250);
-        assertThat(vastCompanionAd.getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
-        assertThat(vastCompanionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
-        assertThat(vastCompanionAd.getClickTrackers())
-                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws Exception {
-        // Vast redirect responses
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        // at this point it should have 3 sets of data from TEST_VAST_XML_STRING and one set from TEST_NESTED_VAST_XML_STRING
-        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
-        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
-
-        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
-        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(13);
-        assertThat(vastVideoConfiguration.getStartTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getMidpointTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getThirdQuartileTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(3);
-
-        final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
-        assertThat(vastCompanionAd.getWidth()).isEqualTo(300);
-        assertThat(vastCompanionAd.getHeight()).isEqualTo(250);
-        assertThat(vastCompanionAd.getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
-        assertThat(vastCompanionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
-        assertThat(vastCompanionAd.getClickTrackers())
-                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
-    }
-
-
-    @Test
-    public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(404, "");
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4");
-
-        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
-
-        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo(null);
-        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(1);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withNoMediaUrlInXml_shouldReturnNull() throws Exception {
-        subject.prepareVastVideoConfiguration(TEST_VAST_BAD_NEST_URL_XML_STRING, vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withNullXml_shouldReturnNull() throws Exception {
-        subject.prepareVastVideoConfiguration(null, vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withEmptyXml_shouldReturnNull() throws Exception {
-        subject.prepareVastVideoConfiguration("", vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownloadVideo() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        CacheService.putToDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4", "video_data".getBytes());
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        assertThat(mFakeHttpLayer.getSentHttpRequestInfos().size()).isEqualTo(1);
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl())
-                .isEqualTo(CacheService.getFilePathDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4"));
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldReturnNull() throws Exception {
-        CacheService.clearAndNullCaches();
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void cancel_shouldCancelBackgroundProcessingAndNotNotifyListenerWithNull() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        Robolectric.getBackgroundScheduler().pause();
-
-        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
-
-        subject.cancel();
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void getBestMediaFileUrl_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNullMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, null, "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withIncompatibleMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/rubbish", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNullMediaUrl_shouldReturnNull() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", null);
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNullDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(null, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withZeroDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(0, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNegativeDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(-1, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea1() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
-        // Double screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(1600, 960, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea2() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
-        // Half screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withSameArea_shouldReturnUrlWithAspectRatioCloserToScreenAspectRatio() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Landscape
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url1");
-        // Portrait
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(240, 400, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url1");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullDimension_shouldReturnUrlWithNullDimension() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Invalid media type
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
-        // Null dimension
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(null, null, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(800, 480, null, "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_shouldReturnCompanionAd() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/jpeg", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withNullMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, null, "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertThat(bestCompanionAd).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_withIncompatibleMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/rubbish", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertThat(bestCompanionAd).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_withNullImageUrl_shouldReturnNull() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/png", null);
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertThat(bestCompanionAd).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_withNullDimension_shouldReturnCompanionAd() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(null, 250, "image/png", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withZeroDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(0, 250, "image/png", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withNegativeDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(-300, 250, "image/png", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea1() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(2400, 1440, "image/png", "image_url1");
-        // Double screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(1600, 960, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea2() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(2400, 1440, "image/png", "image_url1");
-        // Half screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(400, 240, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withSameArea_shouldReturnCompanionAdWithAspectRatioCloserToScreenAspectRatio() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Landscape
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(400, 240, "image/png", "image_url1");
-        // Portrait
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(240, 400, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager1, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withInvalidMediaTypeAndNullDimension_shouldReturnCompanionAdWithNullDimension() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(800, 480, "image/invalid", "image_url1");
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(null, null, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAdithInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(800, 480, "image/invalid", "image_url1");
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(800, 480, null, "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertThat(bestCompanionAd).isEqualTo(null);
-    }
-
-    private VastXmlManager.MediaXmlManager initializeMediaXmlManagerMock(
-            final Integer width,
-            final Integer height,
-            final String type,
-            final String mediaUrl) {
-        VastXmlManager.MediaXmlManager mediaXmlManager = mock(VastXmlManager.MediaXmlManager.class);
-        when(mediaXmlManager.getWidth()).thenReturn(width);
-        when(mediaXmlManager.getHeight()).thenReturn(height);
-        when(mediaXmlManager.getType()).thenReturn(type);
-        when(mediaXmlManager.getMediaUrl()).thenReturn(mediaUrl);
-        return mediaXmlManager;
-    }
-
-    private VastXmlManager.ImageCompanionAdXmlManager initializeCompanionXmlManagerMock(
-            final Integer width,
-            final Integer height,
-            final String type,
-            final String imageUrl) {
-        VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = mock(VastXmlManager.ImageCompanionAdXmlManager.class);
-        when(companionXmlManager.getWidth()).thenReturn(width);
-        when(companionXmlManager.getHeight()).thenReturn(height);
-        when(companionXmlManager.getType()).thenReturn(type);
-        when(companionXmlManager.getImageUrl()).thenReturn(imageUrl);
-        return companionXmlManager;
-    }
-
-    private void assertCompanionAdsAreEqual(
-            final VastXmlManager.ImageCompanionAdXmlManager imageCompanionAdXmlManager,
-            final VastCompanionAd vastCompanionAd) {
-        final VastCompanionAd vastCompanionAd1 = new VastCompanionAd(
-                imageCompanionAdXmlManager.getWidth(),
-                imageCompanionAdXmlManager.getHeight(),
-                imageCompanionAdXmlManager.getImageUrl(),
-                imageCompanionAdXmlManager.getClickThroughUrl(),
-                new ArrayList<String>(imageCompanionAdXmlManager.getClickTrackers())
-        );
-        assertCompanionAdsAreEqual(vastCompanionAd, vastCompanionAd1);
-    }
-
-    private void assertCompanionAdsAreEqual(
-            final VastCompanionAd vastCompanionAd1,
-            final VastCompanionAd vastCompanionAd2) {
-        assertThat(vastCompanionAd1.getWidth()).isEqualTo(vastCompanionAd2.getWidth());
-        assertThat(vastCompanionAd1.getHeight()).isEqualTo(vastCompanionAd2.getHeight());
-        assertThat(vastCompanionAd1.getImageUrl()).isEqualTo(vastCompanionAd2.getImageUrl());
-        assertThat(vastCompanionAd1.getClickThroughUrl()).isEqualTo(vastCompanionAd2.getClickThroughUrl());
-        assertThat(vastCompanionAd1.getClickTrackers()).isEqualTo(vastCompanionAd2.getClickTrackers());
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
deleted file mode 100644
index f7ddc3f2..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.mopub.mobileads.util.vast;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.util.List;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.mobileads.util.vast.VastXmlManagerAggregator.VastXmlManagerAggregatorListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyListOf;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-@RunWith(SdkTestRunner.class)
-public class VastXmlManagerAggregatorTest {
-    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives></InLine></Ad></VAST>";
-    static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-
-    private FakeHttpLayer mFakeHttpLayer;
-    private Semaphore semaphore;
-    private VastXmlManagerAggregatorListener vastXmlManagerAggregatorListener;
-    private VastXmlManagerAggregator subject;
-    private List<VastXmlManager> vastXmlManagers;
-
-    @Before
-    public void setup() {
-        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
-
-        semaphore = new Semaphore(0);
-        vastXmlManagerAggregatorListener = mock(VastXmlManagerAggregatorListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                VastXmlManagerAggregatorTest.this.vastXmlManagers = (List<VastXmlManager>) args[0];
-                semaphore.release();
-                return null;
-            }
-        }).when(vastXmlManagerAggregatorListener).onAggregationComplete(anyListOf(VastXmlManager.class));
-
-        subject = new VastXmlManagerAggregator(vastXmlManagerAggregatorListener);
-    }
-
-    // NOTE most of the functionality of this class is tested through VastManagerTest
-    // through integration tests
-
-    @Test
-    public void processVast_shouldNotFollowRedirectsOnceTheLimitHasBeenReached() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        subject.setTimesFollowedVastRedirect(VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT);
-        subject.execute(TEST_VAST_XML_STRING);
-        semaphore.acquire();
-
-        assertThat(vastXmlManagers.size()).isEqualTo(1);
-        assertThat(vastXmlManagers.get(0).getMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4");
-        assertThat(vastXmlManagers.get(0).getClickThroughUrl()).isEqualTo(null);
-        assertThat(vastXmlManagers.get(0).getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastXmlManagers.get(0).getVideoFirstQuartileTrackers().size()).isEqualTo(1);
-    }
-
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
new file mode 100644
index 00000000..79d601c8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
@@ -0,0 +1,117 @@
+package com.mopub.mraid;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.View;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.TestMraidControllerFactory;
+import com.mopub.mraid.MraidController.MraidListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
+import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MraidBannerTest {
+    private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
+
+    MraidController mockMraidController;
+    @Mock CustomEventBannerListener mockBannerListener;
+
+    private Context context;
+    private Map<String, Object> localExtras;
+    private Map<String, String> serverExtras;
+
+    private MraidBanner subject;
+
+    @Before
+    public void setUp() {
+        subject = new MraidBanner();
+        mockMraidController = TestMraidControllerFactory.getSingletonMock();
+
+        context = new Activity();
+        localExtras = new HashMap<String, Object>();
+        localExtras.put("broadcastIdentifier", 123L);
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, INPUT_HTML_DATA);
+    }
+
+    @Test
+    public void loadBanner_whenExtrasAreMalformed_shouldNotifyBannerListenerFailureAndReturn() {
+        serverExtras.remove(HTML_RESPONSE_BODY_KEY);
+
+        subject.loadBanner(context, mockBannerListener, localExtras, serverExtras);
+
+        verify(mockBannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
+    }
+
+    @Test
+    public void invalidate_shouldDestroyMraidController() {
+        subject.loadBanner(context, mockBannerListener, localExtras, serverExtras);
+        subject.onInvalidate();
+
+        verify(mockMraidController).destroy();
+    }
+
+    @Test
+    public void bannerMraidListener_onReady_shouldNotifyBannerLoaded() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onLoaded(null);
+
+        verify(mockBannerListener).onBannerLoaded(any(View.class));
+    }
+
+    @Test
+    public void bannerMraidListener_onFailure_shouldNotifyBannerFailed() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onFailedToLoad();
+
+        verify(mockBannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
+    }
+
+    @Test
+    public void bannerMraidListener_onExpand_shouldNotifyBannerExpandedAndClicked() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onExpand();
+
+        verify(mockBannerListener).onBannerExpanded();
+        verify(mockBannerListener).onBannerClicked();
+    }
+
+    @Test
+    public void bannerMraidListener_onOpen_shouldNotifyBannerClicked() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onOpen();
+
+        verify(mockBannerListener).onBannerClicked();
+    }
+
+    @Test
+    public void bannerMraidListener_onClose_shouldNotifyBannerCollapsed() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onClose();
+
+        verify(mockBannerListener).onBannerCollapsed();
+    }
+
+    private MraidListener captureMraidListener() {
+        subject.loadBanner(context, mockBannerListener, localExtras, serverExtras);
+        ArgumentCaptor<MraidListener> listenerCaptor = ArgumentCaptor.forClass(MraidListener.class);
+        verify(mockMraidController).setMraidListener(listenerCaptor.capture());
+
+        return listenerCaptor.getValue();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
new file mode 100644
index 00000000..7ecdaadb
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
@@ -0,0 +1,373 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.webkit.WebSettings;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyMapOf;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.startsWith;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MraidBridgeTest {
+    @Mock MraidNativeCommandHandler mockNativeCommandHandler;
+    @Mock MraidBridgeListener mockBridgeListener;
+    @Mock AdReport mockAdReport;
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS) MraidWebView mockBannerWebView;
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS) MraidWebView mockInterstitialWebView;
+    @Mock WebSettings mockWebSettings;
+    @Captor ArgumentCaptor<WebViewClient> bannerWebViewClientCaptor;
+
+    private Activity activity;
+    private MraidBridge subjectBanner;
+    private MraidBridge subjectInterstitial;
+
+    @Before
+    public void setUp() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        subjectBanner = new MraidBridge(mockAdReport, PlacementType.INLINE, mockNativeCommandHandler);
+        subjectBanner.setMraidBridgeListener(mockBridgeListener);
+
+        subjectInterstitial = new MraidBridge(mockAdReport, PlacementType.INTERSTITIAL, mockNativeCommandHandler);
+        subjectInterstitial.setMraidBridgeListener(mockBridgeListener);
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN_MR1, emulateSdk = Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Test
+    public void attachView_atLeastJellyBeanMr1_withInterstitial_shouldAutoPlayVideo() {
+        when(mockInterstitialWebView.getSettings()).thenReturn(mockWebSettings);
+
+        subjectInterstitial.attachView(mockInterstitialWebView);
+
+        verify(mockWebSettings).setMediaPlaybackRequiresUserGesture(false);
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN_MR1, emulateSdk = Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Test
+    public void attachView_atLeastJellyBeanMr1_withInline_shouldNotAutoPlayVideo() {
+        when(mockBannerWebView.getSettings()).thenReturn(mockWebSettings);
+
+        subjectBanner.attachView(mockBannerWebView);
+
+        verify(mockWebSettings, never()).setMediaPlaybackRequiresUserGesture(anyBoolean());
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN, emulateSdk = Build.VERSION_CODES.JELLY_BEAN)
+    @Test
+    public void attachView_belowJellyBeanMr1_withInterstitial_shouldNotAutoPlayVideo() {
+        when(mockInterstitialWebView.getSettings()).thenReturn(mockWebSettings);
+
+        subjectInterstitial.attachView(mockInterstitialWebView);
+
+        // Disregard setting of javascript
+        verify(mockWebSettings).setJavaScriptEnabled(anyBoolean());
+        // Ensure mockWebSettings.setMediaPlaybackRequiresUserGesture is never called
+        verifyNoMoreInteractions(mockWebSettings);
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN, emulateSdk = Build.VERSION_CODES.JELLY_BEAN)
+    @Test
+    public void attachView_belowJellyBeanMr1_withInline_shouldNotAutoPlayVideo() {
+        when(mockBannerWebView.getSettings()).thenReturn(mockWebSettings);
+
+        subjectBanner.attachView(mockBannerWebView);
+
+        // Disregard setting of javascript
+        verify(mockWebSettings).setJavaScriptEnabled(anyBoolean());
+        // Ensure mockWebSettings.setMediaPlaybackRequiresUserGesture is never called
+        verifyNoMoreInteractions(mockWebSettings);
+    }
+
+    @Test
+    public void attachView_thenDetach_shouldSetMRaidWebView_thenShouldClear() {
+        attachWebViews();
+        assertThat(subjectBanner.getMraidWebView()).isEqualTo(mockBannerWebView);
+
+        subjectBanner.detach();
+        assertThat(subjectBanner.getMraidWebView()).isNull();
+    }
+
+    @Test
+    public void attachView_thenOnPageFinished_shouldFireReady() {
+        attachWebViews();
+        bannerWebViewClientCaptor.getValue().onPageFinished(mockBannerWebView, "fake://url");
+
+        verify(mockBridgeListener).onPageLoaded();
+    }
+
+    @Test
+    public void attachView_thenOnPageFinished_twice_shouldNotFireReadySecondTime() {
+        attachWebViews();
+        bannerWebViewClientCaptor.getValue().onPageFinished(mockBannerWebView, "fake://url");
+        bannerWebViewClientCaptor.getValue().onPageFinished(mockBannerWebView, "fake://url2");
+
+        verify(mockBridgeListener, times(1)).onPageLoaded();
+    }
+
+    @Test
+    public void attachView_thenSetContentHtml_shouldCallLoadDataWithBaseURL() {
+        attachWebViews();
+        subjectBanner.setContentHtml("test-html");
+
+        verify(mockBannerWebView).loadDataWithBaseURL(
+                "http://" + Constants.HOST + "/", "test-html", "text/html", "UTF-8", null);
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_invalidUrl_shouldFireErrorEvent() {
+        attachWebViews();
+        boolean result = subjectBanner.handleShouldOverrideUrl("bad bad bad");
+
+        verify(mockBannerWebView).loadUrl(startsWith(
+                "javascript:window.mraidbridge.notifyErrorEvent"));
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mopubNonFailLoadUrl_shouldNeverLoadUrl_shouldReturnTrue() {
+        attachWebViews();
+        boolean result = subjectBanner.handleShouldOverrideUrl("mopub://special-mopub-command");
+
+        verify(mockBannerWebView, never()).loadUrl(anyString());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mopubFailLoadUrl_whenBanner_shouldNotifyListenerOfOnPageFailedToLoad_shouldReturnTrue() {
+        attachWebViews();
+        boolean result = subjectBanner.handleShouldOverrideUrl("mopub://failLoad");
+
+        verify(mockBridgeListener).onPageFailedToLoad();
+        verify(mockBannerWebView, never()).loadUrl(anyString());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mopubFailLoadUrl_whenInterstitial_shouldNotNotifyListenerOfOnPageFailedToLoad_shouldReturnTrue() {
+        attachWebViews();
+        boolean result = subjectInterstitial.handleShouldOverrideUrl("mopub://failLoad");
+
+        verify(mockBridgeListener, never()).onPageFailedToLoad();
+        verify(mockBannerWebView, never()).loadUrl(anyString());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mraidUrl_invalid_shouldFireErrorEvent_shouldReturnTrue() {
+        attachWebViews();
+        boolean result = subjectBanner.handleShouldOverrideUrl("mraid://bad-command");
+
+        verify(mockBannerWebView).loadUrl(startsWith(
+                "javascript:window.mraidbridge.notifyErrorEvent"));
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_smsUrl_notClicked_shouldReturnFalse() {
+        attachWebViews();
+        boolean result = subjectBanner.handleShouldOverrideUrl("sms://123456789");
+
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_smsUrl_clicked_shouldStartActivity() {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        reset(mockBannerWebView);
+        when(mockBannerWebView.getContext()).thenReturn(activity);
+
+        boolean result = subjectBanner.handleShouldOverrideUrl("sms://123456789");
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNotNull();
+        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
+        assertThat(startedIntent.getComponent()).isNull();
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_normalUrl_shouldReturnFalse() {
+        attachWebViews();
+        boolean result = subjectBanner.handleShouldOverrideUrl("http://www.mopub.com");
+
+        assertThat(result).isFalse();
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void runCommand_requiresClick_notClicked_shouldThrowException()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner = new MraidBridge(mockAdReport, PlacementType.INLINE);
+        subjectBanner.attachView(mockBannerWebView);
+        subjectBanner.setClicked(false);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.PLAY_VIDEO, params);
+    }
+
+    public void runCommand_requiresClick_clicked_shouldNotThrowException()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.PLAY_VIDEO, params);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void runCommand_interstitial_requiresClick_notClicked_shouldThrowException()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectInterstitial.setClicked(false);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectInterstitial.runCommand(MraidJavascriptCommand.OPEN, params);
+    }
+
+    @Test
+    public void runCommand_interstitial_requiresClick_clicked_shouldNotThrowException()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectInterstitial.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("url", "http://valid-url");
+
+        subjectInterstitial.runCommand(MraidJavascriptCommand.OPEN, params);
+    }
+
+    @Test
+    public void runCommand_close_shouldCallListener()
+            throws MraidCommandException {
+        attachWebViews();
+        Map<String, String> params = new HashMap<String, String>();
+        
+        subjectBanner.runCommand(MraidJavascriptCommand.CLOSE, params);
+
+        verify(mockBridgeListener).onClose();
+    }
+
+    @Test
+    public void runCommand_expand_shouldCallListener()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("shouldUseCustomClose", "true");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.EXPAND, params);
+
+        verify(mockBridgeListener).onExpand(null, true);
+    }
+
+    @Test
+    public void runCommand_expand_withUrl_shouldCallListener()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("url", "http://valid-url");
+        params.put("shouldUseCustomClose", "true");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.EXPAND, params);
+
+        ArgumentCaptor<URI> uriCaptor = ArgumentCaptor.forClass(URI.class);
+        verify(mockBridgeListener).onExpand(
+                uriCaptor.capture(), eq(true));
+        assertThat(uriCaptor.getValue().toString()).isEqualTo("http://valid-url");
+    }
+
+    @Test
+    public void runCommand_playVideo_shouldCallListener()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.PLAY_VIDEO, params);
+
+        ArgumentCaptor<URI> uriCaptor = ArgumentCaptor.forClass(URI.class);
+        verify(mockBridgeListener).onPlayVideo(uriCaptor.capture());
+        assertThat(uriCaptor.getValue().toString()).isEqualTo("http://valid-url");
+    }
+
+    @Test
+    public void runCommand_storePicture_shouldCallListener()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.STORE_PICTURE, params);
+
+        verify(mockNativeCommandHandler).storePicture(any(Context.class), eq("http://valid-url"),
+                any(MraidCommandFailureListener.class));
+    }
+
+    @Test
+    public void runCommand_createCalendarEvent_shouldCallListener()
+            throws MraidCommandException {
+        attachWebViews();
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("eventName", "Dinner at my house");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.CREATE_CALENDAR_EVENT, params);
+
+        verify(mockNativeCommandHandler).createCalendarEvent(any(Context.class),
+                anyMapOf(String.class, String.class));
+    }
+
+    private void attachWebViews() {
+        subjectBanner.attachView(mockBannerWebView);
+        subjectInterstitial.attachView(mockInterstitialWebView);
+
+        verify(mockBannerWebView).setWebViewClient(bannerWebViewClientCaptor.capture());
+        reset(mockBannerWebView);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
new file mode 100644
index 00000000..be20f706
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
@@ -0,0 +1,1041 @@
+package com.mopub.mraid;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.view.View;
+import android.widget.FrameLayout;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BaseVideoPlayerActivityTest;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+import com.mopub.mraid.MraidController.MraidListener;
+import com.mopub.mraid.MraidController.OrientationBroadcastReceiver;
+import com.mopub.mraid.MraidController.ScreenMetricsWaiter;
+import com.mopub.mraid.MraidController.ScreenMetricsWaiter.WaitRequest;
+import com.mopub.mraid.MraidController.UseCustomCloseListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.net.URI;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MraidControllerTest {
+    private long broadcastIdentifier = 123;
+    @Mock private AdReport mockAdReport;
+    @Mock private MraidBridge mockBridge;
+    @Mock private MraidBridge mockTwoPartBridge;
+    @Mock private ScreenMetricsWaiter mockScreenMetricsWaiter;
+    @Mock private WaitRequest mockWaitRequest;
+    @Mock private MraidListener mockMraidListener;
+    @Mock private UseCustomCloseListener mockUseCustomCloseListener;
+    @Mock private OrientationBroadcastReceiver mockOrientationBroadcastReceiver;
+    @Captor private ArgumentCaptor<MraidBridgeListener> bridgeListenerCaptor;
+    @Captor private ArgumentCaptor<MraidBridgeListener> twoPartBridgeListenerCaptor;
+
+    private Activity activity;
+    private FrameLayout rootView;
+
+    private MraidController subject;
+
+    @Before
+    public void setUp() {
+        Robolectric.setDisplayMetricsDensity(1.0f);
+
+        activity = spy(Robolectric.buildActivity(Activity.class).create().get());
+        activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        rootView = new FrameLayout(activity);
+        when(mockBridge.isVisible()).thenReturn(true);
+
+        // By default, immediately fulfill a screen metrics wait request. Individual tests can
+        // reset this, if desired.
+        when(mockScreenMetricsWaiter.waitFor(Mockito.<View>anyVararg()))
+                .thenReturn(mockWaitRequest);
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(final InvocationOnMock invocation) throws Throwable {
+                Runnable runnable = (Runnable) invocation.getArguments()[0];
+                runnable.run();
+                return null;
+            }
+        }).when(mockWaitRequest).start(any(Runnable.class));
+
+        subject = new MraidController(
+                activity, mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+        subject.setMraidListener(mockMraidListener);
+        subject.setOrientationBroadcastReceiver(mockOrientationBroadcastReceiver);
+        subject.setRootView(rootView);
+        subject.loadContent("fake_html_data");
+
+        verify(mockBridge).setMraidBridgeListener(bridgeListenerCaptor.capture());
+        verify(mockTwoPartBridge).setMraidBridgeListener(twoPartBridgeListenerCaptor.capture());
+    }
+
+    @Test
+    public void constructor_shouldSetStateToLoading() {
+        ViewState state = subject.getViewState();
+
+        assertThat(state).isEqualTo(ViewState.LOADING);
+    }
+
+    @Test
+    public void bridgeOnReady_shouldSetStateToDefault_shouldCallListener() {
+        bridgeListenerCaptor.getValue().onPageLoaded();
+
+        ViewState state = subject.getViewState();
+
+        assertThat(state).isEqualTo(ViewState.DEFAULT);
+        verify(mockMraidListener).onLoaded(any(View.class));
+    }
+
+    @Test
+    public void handlePageLoad_shouldNotifyBridgeOfVisibilityPlacementScreenSizeAndSupports() {
+        when(mockBridge.isVisible()).thenReturn(true);
+
+        subject.handlePageLoad();
+
+        verify(mockBridge).notifyViewability(true);
+        verify(mockBridge).notifyPlacementType(PlacementType.INLINE);
+        verify(mockBridge).notifyScreenMetrics(any(MraidScreenMetrics.class));
+
+        // The actual values here are supplied by the Mraids class, which has separate tests.
+        verify(mockBridge).notifySupports(false, false, false, false, false);
+    }
+
+    @Test
+    public void handlePageLoad_shouldCancelLastRequest() {
+        subject.handlePageLoad();
+
+        verify(mockScreenMetricsWaiter).cancelLastRequest();
+    }
+
+    @Test
+    public void handlePageLoad_thenDestroy_shouldCancelLastRequest() {
+        subject.handlePageLoad();
+        subject.destroy();
+
+        verify(mockScreenMetricsWaiter, times(2)).cancelLastRequest();
+    }
+
+    @Test
+    public void onPageFailedToLoad_shouldNotifyListener() {
+        bridgeListenerCaptor.getValue().onPageFailedToLoad();
+
+        verify(mockMraidListener).onFailedToLoad();
+    }
+
+    @Test
+    public void onPageFailedToLoad_withTwoPartBridge_shouldNotNotifyListener() {
+        twoPartBridgeListenerCaptor.getValue().onPageFailedToLoad();
+
+        verify(mockMraidListener, never()).onFailedToLoad();
+    }
+
+    @Test
+    public void bridgeOnVisibilityChanged_withTwoPartBridgeAttached_shouldNotNotifyVisibility() {
+        when(mockTwoPartBridge.isAttached()).thenReturn(true);
+
+        bridgeListenerCaptor.getValue().onVisibilityChanged(true);
+        bridgeListenerCaptor.getValue().onVisibilityChanged(false);
+
+        verify(mockBridge, never()).notifyViewability(anyBoolean());
+        verify(mockTwoPartBridge, never()).notifyViewability(anyBoolean());
+    }
+
+    @Test
+    public void handleResize_shouldBeIgnoredWhenLoadingOrHidden() throws MraidCommandException {
+        subject.setViewStateForTesting(ViewState.LOADING);
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.LOADING);
+
+        subject.setViewStateForTesting(ViewState.HIDDEN);
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_shouldThrowExceptionWhenExpanded() throws MraidCommandException {
+        subject.setViewStateForTesting(ViewState.EXPANDED);
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_shouldThrowExceptionForInterstitial() throws MraidCommandException {
+        MraidListener listener = mock(MraidListener.class);
+        subject = new MraidController(activity, mockAdReport, PlacementType.INTERSTITIAL,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+        subject.setMraidListener(listener);
+        subject.setRootView(rootView);
+
+        // Move to DEFAULT state
+        subject.loadContent("fake_html_data");
+        subject.handlePageLoad();
+
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+    }
+
+    @Test
+    public void handleResize_shouldMoveWebViewToResizedContainer_shouldSetResizedState()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, true);
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(0);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test
+    public void handleResize_noAllowOffscreen_smallView_shouldResize()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(50, 50, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_noAllowOffscreen_largeView_shouldThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(101, 101, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ false);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_allowOffscreen_largeView_closeButtonTopRight_shouldThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(150, 150, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ true);
+    }
+
+    @Test
+    public void handleResize_allowOffscreen_closeButtonTopLeft_shouldNotThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(150, 150, 0, 0, ClosePosition.TOP_LEFT, /* allowOffscreen */ true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_allowOffscreen_largeOffset_closeButtonBottomRight_shouldThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 1000);
+
+        // Throws an exception because the close button overlaps the edge
+        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_RIGHT, /* allowOffscreen */
+                true);
+    }
+
+    @Test
+    public void handleResize_allowOffscreen_largeOffset_closeButtonBottomLeft_shouldNotThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 1000);
+
+        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_heightSmallerThan50Dips_shouldFail() throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(100, 49, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                false);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_widthSmallerThan50Dips_shouldFail() throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(49, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                false);
+    }
+
+    @Test
+    public void handleClose_fromResizedState_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose()
+            throws MraidCommandException {
+        // Move to RESIZED state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, false);
+
+        subject.handleClose();
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleExpand_afterDestroy_shouldThrowException() throws MraidCommandException {
+        subject.destroy();
+        subject.handleExpand(null, false);
+    }
+
+    @Test
+    public void handleExpand_shouldBeIgnoredForInterstitial() throws MraidCommandException {
+        MraidListener listener = mock(MraidListener.class);
+        subject = new MraidController(activity, mockAdReport, PlacementType.INTERSTITIAL,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+        subject.setMraidListener(listener);
+        subject.setRootView(rootView);
+
+        // Move to DEFAULT state
+        subject.loadContent("fake_html_data");
+        subject.handlePageLoad();
+
+        subject.handleExpand(null, false);
+
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        verify(listener, never()).onExpand();
+    }
+
+    @Test
+    public void handleExpand_shouldBeIgnoredWhenLoadingHiddenOrExpanded()
+            throws MraidCommandException {
+        subject.setViewStateForTesting(ViewState.LOADING);
+        subject.handleExpand(null, false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.LOADING);
+        verify(mockMraidListener, never()).onExpand();
+
+        subject.setViewStateForTesting(ViewState.HIDDEN);
+        subject.handleExpand(null, false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
+        verify(mockMraidListener, never()).onExpand();
+
+        subject.setViewStateForTesting(ViewState.EXPANDED);
+        subject.handleExpand(null, false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.EXPANDED);
+        verify(mockMraidListener, never()).onExpand();
+    }
+
+    @Test
+    public void handleExpand_withNoUrl_shouldMoveWebViewToExpandedContainer_shouldCallOnExpand()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+
+        subject.handleExpand(null, false);
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(0);
+        verify(mockMraidListener).onExpand();
+    }
+
+    @Test
+    public void handleExpand_withTwoPartUrl_shouldAttachTwoPartBridge_shouldCallOnExpand()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+
+        subject.handleExpand(URI.create("http://two-part-url"), false);
+
+        verify(mockTwoPartBridge).setMraidBridgeListener(any(MraidBridgeListener.class));
+        verify(mockTwoPartBridge).attachView(any(MraidWebView.class));
+        verify(mockTwoPartBridge).setContentUrl(URI.create("http://two-part-url").toString());
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        verify(mockMraidListener).onExpand();
+        assertThat(subject.getViewState()).isEqualTo(ViewState.EXPANDED);
+    }
+
+    @Test
+    public void handleClose_afterDestroy_shouldNotFireOnClose() {
+        subject.destroy();
+        subject.handleClose();
+
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test
+    public void handleClose_fromExpandedState_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose() throws MraidCommandException {
+        // Move to EXPANDED state
+        subject.handlePageLoad();
+        subject.handleExpand(null, false);
+
+        subject.handleClose();
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test
+    public void handleClose_fromTwoPartExpandedState_shouldDetachTwoPartBridge_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose()
+            throws MraidCommandException {
+        URI uri = URI.create("http://two-part-url");
+
+        // Move to two part EXPANDED state
+        subject.handlePageLoad();
+        subject.handleExpand(uri, false);
+        when(mockTwoPartBridge.isAttached()).thenReturn(true);
+
+        subject.handleClose();
+
+        verify(mockTwoPartBridge).detach();
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test
+    public void handleClose_fromDefaultState_shouldHideAdContainer_shouldCallOnClose() {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+
+        subject.handleClose();
+
+        assertThat(subject.getAdContainer().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
+
+        verify(mockMraidListener).onClose();
+    }
+
+    @Test
+    public void handleShowVideo_shouldStartVideoPlayerActivity() {
+        subject.handleShowVideo("http://video");
+        BaseVideoPlayerActivityTest.assertMraidVideoPlayerActivityStarted(
+                MraidVideoPlayerActivity.class, "http://video");
+    }
+
+    @Test
+    public void handleCustomClose_shouldUpdateExpandedContainer() {
+        subject.handleCustomClose(true);
+        assertThat(subject.getExpandedAdContainer().isCloseVisible()).isFalse();
+
+        subject.handleCustomClose(false);
+        assertThat(subject.getExpandedAdContainer().isCloseVisible()).isTrue();
+    }
+
+    @Test
+    public void handleCustomClose_shouldCallCustomCloseChangedListener() {
+        subject.setUseCustomCloseListener(mockUseCustomCloseListener);
+
+        subject.handleCustomClose(true);
+        verify(mockUseCustomCloseListener).useCustomCloseChanged(true);
+
+        reset(mockUseCustomCloseListener);
+        subject.handleCustomClose(false);
+        verify(mockUseCustomCloseListener).useCustomCloseChanged(false);
+    }
+
+    @Test
+    public void handleOpen_withMoPubNativeBrowserUrl_shouldOpenExternalBrowser() {
+        subject.handleOpen("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+    }
+
+    @Test
+    public void handleOpen_withMalformedMoPubNativeBrowserUrl_shouldNotStartNewActivity() {
+        // invalid host parameter 'nav'
+        subject.handleOpen("mopubnativebrowser://nav?url=https%3A%2F%2Fwww.example.com");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleOpen_withApplicationUrl_shouldStartNewIntent() {
+        String applicationUrl = "amzn://blah";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri
+                .parse(applicationUrl)), new ResolveInfo());
+
+        subject.handleOpen(applicationUrl);
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNotNull();
+        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
+        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
+                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(startedIntent.getComponent()).isNull();
+
+        verify(mockMraidListener).onOpen();
+    }
+
+    @Test
+    public void handleOpen_withHttpApplicationUrl_shouldStartMoPubBrowser() {
+        String applicationUrl = "http://www.mopub.com/";
+
+        subject.handleOpen(applicationUrl);
+
+        Robolectric.runBackgroundTasks();
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNotNull();
+        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
+        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
+                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(startedIntent.getComponent().getClassName())
+                .isEqualTo("com.mopub.common.MoPubBrowser");
+
+        verify(mockMraidListener).onOpen();
+    }
+
+    @Test
+    public void handleOpen_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubBrowser()
+            throws Exception {
+        String applicationUrl = "canthandleme://blah";
+
+        subject.handleOpen(applicationUrl);
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNull();
+
+        verify(mockMraidListener).onOpen();
+    }
+
+    @Test
+    public void handleOpen_withAboutBlankUrl_shouldFailSilently() {
+        final String url = "about:blank";
+
+        subject.handleOpen(url);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void orientationBroadcastReceiver_whenUnregistered_shouldIgnoreOnReceive() {
+        Intent intent = mock(Intent.class);
+        when(intent.getAction()).thenReturn("some bogus action which we hope never to see");
+
+        MraidController.OrientationBroadcastReceiver receiver =
+                subject.new OrientationBroadcastReceiver();
+        receiver.register(activity);
+        receiver.unregister();
+        receiver.onReceive(activity, intent);
+
+        verify(intent, never()).getAction();
+    }
+
+    @Test
+    public void orientationProperties_shouldDefaultToAllowChangeTrueAndForceOrientationNone() {
+        // These are the default values provided by the MRAID spec
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withForcedOrientation_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+
+        assertThat(subject.getAllowOrientationChange()).isFalse();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withOrientationNone_withApplicationContext_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.NONE);
+
+        assertThat(subject.getAllowOrientationChange()).isFalse();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withForcedOrientation_withApplicationContext_shouldThrowMraidCommandExceptionAndNotUpdateProperties() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        try {
+            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withActivityInfoNotFound_shouldThrowMraidCommandException() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(false, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        try {
+            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_whenTryingToSetToOrientationDeclaredInManifest_shouldUpdateProperties() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.PORTRAIT);
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.PORTRAIT);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_whenTryingToSetToOrientationDifferentFromManifest_shouldThrowMraidCommandException() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        try {
+            subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withForcedOrientation_withMissingConfigChangeOrientation_shouldThrowMraidCommandException() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                /* missing CONFIG_ORIENTATION */ ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        try {
+            subject.handleSetOrientationProperties(true, MraidOrientation.PORTRAIT);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigChangeScreenSize_shouldUpdateProperties() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+
+        assertThat(subject.getAllowOrientationChange()).isFalse();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
+    @Test
+    public void handleSetOrientationProperties_atLeastHoneycombMr2_withMissingConfigChangeScreenSize_shouldThrowMraidCommandException() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION);
+
+        try {
+            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forExpandedBanner_shouldImmediatelyChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handlePageLoad();
+        subject.handleExpand(null, false);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forExpandedBanner_beforeExpandIsCalled_shouldChangeScreenOrientationUponExpand() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handlePageLoad();
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.handleExpand(null, false);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forDefaultBanner_shouldNotChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handlePageLoad();
+        // don't expand the banner
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forInterstitial_shouldChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity, mockAdReport, PlacementType.INTERSTITIAL,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.handlePageLoad();
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void shouldAllowForceOrientation_withNoneOrientation_shouldReturnTrue() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        final boolean result = subject.shouldAllowForceOrientation(MraidOrientation.NONE);
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void shouldAllowForceOrientation_withApplicationContext_shouldReturnFalse() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        final boolean result = subject.shouldAllowForceOrientation(MraidOrientation.PORTRAIT);
+
+        assertThat(result).isFalse();
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void lockOrientation_withApplicationContext_shouldThrowMraidCommandException() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_withActivityContext_shouldInitializeOriginalActivityOrientationAndCallActivitySetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_subsequentTimes_shouldNotModifyOriginalActivityOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void applyOrientation_withLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldResetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.NONE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void applyOrientation_withNoLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldDoNothing() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.NONE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void applyOrientation_withForcedOrientationTrue_shouldSetRequestedOrientationToForcedOrienation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void applyOrientation_withForcedOrientationFalse_shouldSetRequestedOrientationToForcedOrienation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void unapplyOrientation_withALockedOrientation_shouldReturnToOriginalOrientationAndResetOriginalActivityOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        subject.unApplyOrientation();
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void unapplyOrientation_withoutLockedOrientation_shouldNotChangeRequestedOrientation()
+            throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.unApplyOrientation();
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void destroy_shouldCancelLastMetricsRequest_shouldUnregisterBroadcastReceiver_shouldDetachAllBridges() {
+        subject.destroy();
+
+        verify(mockScreenMetricsWaiter).cancelLastRequest();
+        verify(mockOrientationBroadcastReceiver).unregister();
+        verify(mockBridge).detach();
+        verify(mockTwoPartBridge).detach();
+    }
+
+    @Test
+    public void destroy_withDefaultState_shouldSetMraidWebViewsToNull() {
+        subject.setViewStateForTesting(ViewState.DEFAULT);
+        assertThat(subject.getMraidWebView()).isNotNull();
+        // The two-part WebView is null by default
+        assertThat(subject.getTwoPartWebView()).isNull();
+
+        subject.destroy();
+
+        assertThat(subject.getMraidWebView()).isNull();
+        assertThat(subject.getTwoPartWebView()).isNull();
+    }
+
+    @Test
+    public void destroy_withExpandedState_shouldSetMraidWebViewsToNull()
+            throws MraidCommandException {
+        // Necessary to set up the webview before expanding. Also moves the state to DEFAULT.
+        subject.handlePageLoad();
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        subject.handleExpand(URI.create("http://two-part-url"), false);
+
+        assertThat(subject.getMraidWebView()).isNotNull();
+        assertThat(subject.getTwoPartWebView()).isNotNull();
+
+        subject.destroy();
+
+        assertThat(subject.getMraidWebView()).isNull();
+        assertThat(subject.getTwoPartWebView()).isNull();
+    }
+
+    @Test
+    public void destroy_afterDestroy_shouldNotThrowAnException() {
+        subject.destroy();
+        subject.destroy();
+
+        assertThat(subject.getMraidWebView()).isNull();
+        assertThat(subject.getTwoPartWebView()).isNull();
+    }
+
+    @Test
+    public void destroy_fromExpandedState_shouldRemoveCloseableAdContainerFromContentView()
+            throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.handleExpand(null, false);
+
+        assertThat(rootView.getChildCount()).isEqualTo(1);
+
+        subject.destroy();
+
+        assertThat(rootView.getChildCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void destroy_fromResizedState_shouldRemoveCloseableAdContainerFromContentView()
+            throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, true);
+
+        assertThat(rootView.getChildCount()).isEqualTo(1);
+
+        subject.destroy();
+
+        assertThat(rootView.getChildCount()).isEqualTo(0);
+    }
+
+    private void setMockActivityInfo(final boolean activityInfoFound, int screenOrientation,
+            int configChanges) throws PackageManager.NameNotFoundException {
+        final ActivityInfo mockActivityInfo = mock(ActivityInfo.class);
+
+        mockActivityInfo.screenOrientation = screenOrientation;
+        mockActivityInfo.configChanges = configChanges;
+
+        final PackageManager mockPackageManager = mock(PackageManager.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                if (!activityInfoFound) {
+                    throw new PackageManager.NameNotFoundException("");
+                }
+
+                return mockActivityInfo;
+            }
+        }).when(mockPackageManager).getActivityInfo(any(ComponentName.class), anyInt());
+
+        when(activity.getPackageManager()).thenReturn(mockPackageManager);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
similarity index 72%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
rename to mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
index d6da03a2..5424e6f2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
@@ -1,82 +1,89 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.ResponseBodyInterstitialTest;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowActivity;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf_;
 
 @RunWith(SdkTestRunner.class)
 public class MraidInterstitialTest extends ResponseBodyInterstitialTest {
-    private CustomEventInterstitialListener customEventInterstitialListener;
-    private Map<String,Object> localExtras;
-    private Map<String,String> serverExtras;
-    private Context context;
-    private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
     private static final String EXPECTED_HTML_DATA = "<html></html>";
     private long broadcastIdentifier;
 
+    @Mock CustomEventInterstitialListener customEventInterstitialListener;
+
+    private Map<String, Object> localExtras;
+    private Map<String, String> serverExtras;
+    private Context context;
+
     @Before
     public void setUp() throws Exception {
-        subject = new MraidInterstitial();
-        context = new Activity();
-        customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
+        broadcastIdentifier = 2222;
+
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, INPUT_HTML_DATA);
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, EXPECTED_HTML_DATA);
+        localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
 
-        broadcastIdentifier = 2222;
-        final AdConfiguration adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(broadcastIdentifier);
-        localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+
+        subject = new MraidInterstitial();
     }
 
     @Test
-    public void loadInterstitial_withMalformedServerExtras_shouldNotifyInterstitialFailed() throws Exception {
+    public void loadInterstitial_withMalformedServerExtras_shouldNotifyInterstitialFailed()
+            throws Exception {
         serverExtras.remove(HTML_RESPONSE_BODY_KEY);
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
 
         verify(customEventInterstitialListener).onInterstitialFailed(NETWORK_INVALID_STATE);
         verify(customEventInterstitialListener, never()).onInterstitialLoaded();
     }
 
+    @Ignore
     @Test
     public void loadInterstitial_shouldNotifyInterstitialLoaded() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
 
-//        verify(customEventInterstitialListener).onInterstitialLoaded();
+        verify(customEventInterstitialListener).onInterstitialLoaded();
     }
 
     @Test
     public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
 
-        Intent intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, broadcastIdentifier);
+        Intent intent =
+                getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, broadcastIdentifier);
         ShadowLocalBroadcastManager.getInstance(context).sendBroadcast(intent);
 
         verify(customEventInterstitialListener).onInterstitialShown();
@@ -94,21 +101,23 @@ public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws E
 
     @Test
     public void showInterstitial_shouldStartActivityWithIntent() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
         subject.showInterstitial();
 
         ShadowActivity shadowActivity = shadowOf_(context);
         Intent intent = shadowActivity.getNextStartedActivityForResult().intent;
 
-        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidActivity");
+        assertThat(intent.getComponent().getClassName())
+                .isEqualTo("com.mopub.mobileads.MraidActivity");
         assertThat(intent.getExtras().get(HTML_RESPONSE_BODY_KEY)).isEqualTo(EXPECTED_HTML_DATA);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
     }
 
     @Test
     public void onInvalidate_shouldDisconnectListenerToBroadcastReceiver() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
         subject.onInvalidate();
 
         Intent intent;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
similarity index 52%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
rename to mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
index 035a693f..533d66b3 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
@@ -1,35 +1,35 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.Manifest;
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Color;
-import android.os.Build.VERSION_CODES;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.Environment;
 import android.provider.CalendarContract;
-import android.view.Gravity;
 import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
+import android.view.WindowManager;
+import android.widget.LinearLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Dips;
 import com.mopub.mobileads.test.support.FileUtils;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
 import com.mopub.mobileads.test.support.ThreadUtils;
-import com.mopub.mobileads.util.MraidsTest;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -39,265 +39,65 @@
 import org.robolectric.shadows.ShadowLog;
 import org.robolectric.shadows.ShadowToast;
 
-import java.io.*;
+import java.io.File;
 import java.net.URI;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 
 import static android.content.DialogInterface.BUTTON_NEGATIVE;
 import static android.content.DialogInterface.BUTTON_POSITIVE;
-import static com.mopub.mobileads.BaseVideoPlayerActivitiyTest.assertMraidVideoPlayerActivityStarted;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_CURRENT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_DEFAULT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_MAX_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_SCREEN_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidCommandStorePicture.MIME_TYPE_HEADER;
-import static com.mopub.mobileads.util.Mraids.ANDROID_CALENDAR_CONTENT_TYPE;
-import static java.io.File.*;
+import static com.mopub.mraid.MraidNativeCommandHandler.ANDROID_CALENDAR_CONTENT_TYPE;
+import static java.io.File.separator;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-public class MraidDisplayControllerTest {
+public class MraidNativeCommandHandlerTest {
     private static final String IMAGE_URI_VALUE = "file://tmp/expectedFile.jpg";
     private static final int TIME_TO_PAUSE_FOR_NETWORK = 300;
-    private static final String VIDEO_URL = "http://video";
-    public static final String FAKE_IMAGE_DATA = "imageFileData";
+    private static final String FAKE_IMAGE_DATA = "imageFileData";
     //XXX: Robolectric or JUNIT doesn't support the correct suffix ZZZZZ in the parse pattern, so replacing xx:xx with xxxx for time.
-    public static final String CALENDAR_START_TIME = "2013-08-14T20:00:00-0000";
-
-    private MraidView mraidView;
-    private MraidDisplayController subject;
-    private View rootView;
-    private FrameLayout contentView;
-    private MoPubView moPubView;
-    private FrameLayout adContainerLayout;
-    private RelativeLayout expansionLayout;
-    private FrameLayout placeholderView;
+    private static final String CALENDAR_START_TIME = "2013-08-14T20:00:00-0000";
+
+
+    @Mock MraidCommandFailureListener mraidCommandFailureListener;
+    private MraidNativeCommandHandler subject;
+    private Context context;
+    private Map<String, String> params;
+
     private File expectedFile;
     private File pictureDirectory;
     private File fileWithoutExtension;
     private TestHttpResponseWithHeaders response;
-    private Map<String, String> params;
-    private AdConfiguration adConfiguration;
-    private long testBroadcastIdentifier;
 
 
     @Before
-    public void setup() {
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        moPubView = mock(MoPubView.class);
-        rootView = mock(View.class);
-        contentView = mock(FrameLayout.class);
-        adContainerLayout = mock(FrameLayout.class);
-        expansionLayout = mock(RelativeLayout.class);
-        placeholderView = mock(FrameLayout.class);
-        params = new HashMap<String, String>();
-
-        resetMockMraidView(new Activity());
-        stub(rootView.findViewById(eq(android.R.id.content))).toReturn(contentView);
-        stub(contentView.getContext()).toReturn(new Activity());
-
-        subject = new TestMraidDisplayController(mraidView, null, null);
-
-        testBroadcastIdentifier = 1235;
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-        stub(mraidView.getAdConfiguration()).toReturn(adConfiguration);
+    public void setUp() throws Exception {
+        subject = new MraidNativeCommandHandler();
+        context = Robolectric.buildActivity(Activity.class).create().get();
 
         FileUtils.copyFile("etc/expectedFile.jpg", "/tmp/expectedFile.jpg");
         expectedFile = new File(Environment.getExternalStorageDirectory(), "Pictures" + separator + "expectedFile.jpg");
         pictureDirectory = new File(Environment.getExternalStorageDirectory(), "Pictures");
         fileWithoutExtension = new File(pictureDirectory, "file");
-
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-    }
-
-    @Test
-    public void initialization_shouldSetupStartingState() throws Exception {
-        assertThat(subject.getMraidView()).isSameAs(mraidView);
-    }
-
-    @Test
-    public void initializeJavaScriptState_shouldSetMraidSupportsProperties() throws Exception {
-        subject.initializeJavaScriptState();
-        verify(mraidView).fireChangeEventForProperty(isA(MraidSupportsProperty.class));
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenPhoneIsAvailable_shouldReportPhoneAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("tel", null, null, "android.intent.action.DIAL");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("tel: true");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenPhoneNotAvailable_shouldReportPhoneNotAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.DIAL");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("tel: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSmsIsAvailable_shouldReportSmsAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("sms", null, null, "android.intent.action.VIEW");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("sms: true");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSmsNotAvailable_shouldReportSmsNotAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.VIEW");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("sms: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenWriteExternalStoragePermissionNotGranted_shouldReportStorePictureNotAvailable() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("storePicture: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSDCardNotMounted_shouldReportStorePictureNotAvailable() throws Exception {
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
-
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("storePicture: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSDCardMounted_andWriteExternalStoragePermissionGranted_shouldReportStorePictureAvailable() throws Exception {
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("storePicture: true");
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void initializeSupportedFunctionsProperty_atLeastIcs_shouldReportCalendarAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
-        resetMockMraidView(mockContext);
-
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("calendar: true");
-    }
-
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
-    @Test
-    public void initializeSupportedFunctionsProperty_beforeIcs_shouldNotReportCalendarAvailable() throws Exception {
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("calendar: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenMraidVideoPlayerActivityDeclared_shouldReportInlineVideoAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData(null, "com.mopub.mobileads.MraidVideoPlayerActivity", null, null);
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("inlineVideo: true");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_MraidVideoPlayerActivityNotDeclared_shouldReportInlineVideoNotAvailable() throws Exception {
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("inlineVideo: false");
-    }
-
-    @Test
-    public void expand_shouldSwapWithPlaceholderView() throws Exception {
-        stub(moPubView.getChildAt(eq(0))).toReturn(mraidView);
-        subject.expand(null, 320, 50, false, false);
-
-        verify(moPubView).addView(any(FrameLayout.class), eq(0), any(ViewGroup.LayoutParams.class));
-        verify(moPubView).removeView(eq(mraidView));
-        verify(adContainerLayout, times(2)).addView(any(ImageView.class), any(FrameLayout.LayoutParams.class));
-    }
-
-    @Test
-    public void close_shouldUnexpandView() throws Exception {
-        subject.expand(null, 320, 50, false, false);
-        stub(placeholderView.getParent()).toReturn(moPubView);
-
-        subject.close();
-
-        verify(adContainerLayout).removeAllViewsInLayout();
-        verify(expansionLayout).removeAllViewsInLayout();
-        verify(contentView).removeView(eq(expansionLayout));
-        verify(moPubView).addView(eq(mraidView), any(int.class));
-        verify(moPubView).removeView(eq(placeholderView));
-        verify(moPubView).invalidate();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDialog() throws Exception {
-        stub(mraidView.getContext()).toReturn(new Activity());
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
         ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
@@ -312,14 +112,13 @@ public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDia
         assertThat(alertDialog.getButton(BUTTON_NEGATIVE)).isNotNull();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_whenOkayClicked_shouldDownloadImage() throws Exception {
-        stub(mraidView.getContext()).toReturn(new Activity());
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
         Robolectric.addPendingHttpResponse(response);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
 
         ShadowAlertDialog.getLatestAlertDialog().getButton(BUTTON_POSITIVE).performClick();
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
@@ -328,13 +127,12 @@ public void showUserDownloadImageAlert_whenOkayClicked_shouldDownloadImage() thr
         assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog() throws Exception {
-        stub(mraidView.getContext()).toReturn(new Activity());
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
         ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
@@ -346,16 +144,15 @@ public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog() t
         assertThat(expectedFile.length()).isEqualTo(0);
     }
 
+    @Ignore("MRAID 2.0")
     @Test
     public void showUserDownloadImageAlert_withAppContext_shouldToastAndDownloadImage() throws Exception {
-        stub(mraidView.getContext()).toReturn(Robolectric.application);
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
         Robolectric.addPendingHttpResponse(response);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context.getApplicationContext(), IMAGE_URI_VALUE, mraidCommandFailureListener);
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
@@ -367,16 +164,15 @@ public void showUserDownloadImageAlert_withAppContext_shouldToastAndDownloadImag
         assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
     }
 
+    @Ignore("MRAID 2.0")
     @Test
     public void showUserDownloadImageAlert_withAppContext_whenDownloadImageFails_shouldDisplayFailureToastAndNotDownloadImage() throws Exception {
-        stub(mraidView.getContext()).toReturn(Robolectric.application);
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
         Robolectric.addPendingHttpResponse(response);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
 
-        subject.showUserDownloadImageAlert("this is an invalid image url and cannot be downloaded");
+        subject.storePicture(context, "this is an invalid image url and cannot be downloaded", mraidCommandFailureListener);
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
@@ -391,17 +187,19 @@ public void showUserDownloadImageAlert_withAppContext_whenDownloadImageFails_sho
         assertThat(expectedFile.length()).isEqualTo(0);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_whenStorePictureNotSupported_shouldFireErrorEvent_andNotToastNorAlertDialog() throws Exception {
         Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
 
-        subject.showUserDownloadImageAlert("http://image.jpg");
+        subject.storePicture(context, "http://image.jpg", mraidCommandFailureListener);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
         assertThat(ShadowAlertDialog.getLatestAlertDialog()).isNull();
-        verify(mraidView).fireErrorEvent(eq(STORE_PICTURE), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withMimeTypeAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
         String fileNameWithNoExtension = "https://www.somewhere.com/images/blah/file";
@@ -413,6 +211,7 @@ public void showUserDownloadImageAlert_withMimeTypeAndNoFileExtension_shouldSave
                 ".jpg");
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withMultipleContentTypesAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
         String fileNameWithNoExtension = "https://www.somewhere.com/images/blah/file";
@@ -424,6 +223,7 @@ public void showUserDownloadImageAlert_withMultipleContentTypesAndNoFileExtensio
                 ".png");
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withMimeTypeAndFileExtension_shouldSavePictureWithFileExtension() throws Exception {
         String fileNameWithExtension = "https://www.somewhere.com/images/blah/file.extension";
@@ -437,6 +237,7 @@ public void showUserDownloadImageAlert_withMimeTypeAndFileExtension_shouldSavePi
         assertThat((expectedFile.getName()).endsWith(".extension.extension")).isFalse();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withHttpUri_shouldRequestPictureFromNetwork() throws Exception {
         response = new TestHttpResponseWithHeaders(200, "OK");
@@ -446,69 +247,15 @@ public void showUserDownloadImageAlert_withHttpUri_shouldRequestPictureFromNetwo
         assertThat(latestRequest.getURI()).isEqualTo(URI.create("https://www.google.com/images/srpr/logo4w.png"));
     }
 
-    @Test
-    public void orientationBroadcastReceiver_whenUnregistered_shouldIgnoreOnReceive() throws Exception {
-        Intent intent = mock(Intent.class);
-        stub(intent.getAction()).toReturn("some bogus action which we hope never to see");
-        Context context = new Activity();
-        MraidDisplayController.OrientationBroadcastReceiver receiver = subject.new OrientationBroadcastReceiver();
-        receiver.register(context);
-
-        receiver.unregister();
-        receiver.onReceive(context, intent);
-
-        verify(intent, never()).getAction();
-    }
-
-    @Test
-    public void showVideo_shouldStartVideoPlayerActivity() throws Exception {
-        subject.showVideo(VIDEO_URL);
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, VIDEO_URL, adConfiguration);
-    }
-
-    @Test
-    public void getCurrentPosition_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getCurrentPosition();
-
-        verify(mraidView).fireErrorEvent(eq(GET_CURRENT_POSITION), any(String.class));
-    }
-
-    @Test
-    public void getDefaultPosition_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getDefaultPosition();
-
-        verify(mraidView).fireErrorEvent(eq(GET_DEFAULT_POSITION), any(String.class));
-    }
-
-    @Test
-    public void getMaxSize_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getMaxSize();
-
-        verify(mraidView).fireErrorEvent(eq(GET_MAX_SIZE), any(String.class));
-    }
-    @Test
-    public void getScreenSize_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getScreenSize();
-
-        verify(mraidView).fireErrorEvent(eq(GET_SCREEN_SIZE), any(String.class));
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEventIntent() throws Exception {
         setupCalendarParams();
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView, never()).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -518,15 +265,16 @@ public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEv
         assertThat(intent.getLongExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, -1)).isNotEqualTo(-1);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreateEventIntent() throws Exception {
         setupCalendarParams();
         params.put("start", "2012-12-21T00:00-0500");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView, never()).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -536,13 +284,14 @@ public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreat
         assertThat(intent.getLongExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, -1)).isNotEqualTo(-1);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "daily");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getType()).isEqualTo(ANDROID_CALENDAR_CONTENT_TYPE);
@@ -550,71 +299,77 @@ public void createCalendarEvent_withDailyRecurrence_shouldCreateCalendarIntent()
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_withInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "daily");
         params.put("interval", "2");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;INTERVAL=2;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInterval_withOutWeekday_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("interval", "7");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;INTERVAL=7;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_onAllWeekDays_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("daysInWeek", "0,1,2,3,4,5,6");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;BYDAY=SU,MO,TU,WE,TH,FR,SA;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_onDuplicateWeekDays_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("daysInWeek", "3,2,3,3,7,0");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;BYDAY=WE,TU,SU;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInterval_withWeekDay_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -622,13 +377,14 @@ public void createCalendarEvent_withWeeklyRecurrence_withInterval_withWeekDay_sh
         params.put("interval", "1");
         params.put("daysInWeek", "1");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;INTERVAL=1;BYDAY=MO;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_withWeeklyRecurrence_withMonthlyOccurence_shouldCreateDailyCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -638,57 +394,61 @@ public void createCalendarEvent_withDailyRecurrence_withWeeklyRecurrence_withMon
         params.put("interval", "2");
         params.put("daysInWeek", "1");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;INTERVAL=2;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
         params.put("interval", "2");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;INTERVAL=2;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_withDaysOfMonth_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
         params.put("daysInMonth", "2,-15");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;BYMONTHDAY=2,-15;");
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withInvalidDaysOfMonth_shouldNotCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
         params.put("daysInMonth", "55");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -696,13 +456,14 @@ public void createCalendarEvent_withMonthlyRecurrence_withInvalidDaysOfMonth_sho
         assertThat(ShadowLog.getLogs().size()).isEqualTo(1);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInvalidDaysOfWeek_shouldNotCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("daysInWeek", "-1,20");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -710,50 +471,50 @@ public void createCalendarEvent_withWeeklyRecurrence_withInvalidDaysOfWeek_shoul
         assertThat(ShadowLog.getLogs().size()).isEqualTo(1);
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
     @Test
     public void createCalendarEvent_beforeIcs_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
+        subject.createCalendarEvent(context, params);
 
-        subject.createCalendarEvent(params);
-
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withInvalidDate_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
         params.put("start", "2013-08-14T09:00.-08:00");
         params.put("description", "Some Event");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withMissingParameters_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
         //it needs a start time
         params.put("description", "Some Event");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
         params.put("start", null);
         params.put("description", "Some Event");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void
     createCalendarEvent_withValidParamsAllExceptRecurrence_atLeastICS_shouldCreateEventIntent() throws Exception {
@@ -763,7 +524,7 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
         params.put("summary", "some description actually");
         params.put("transparency", "transparent");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -778,48 +539,219 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
     }
 
     @Test
-    public void addCloseEventRegion_shouldAddCloseEventRegionToFrameLayout() throws Exception {
-        Activity activity = new Activity();
-        FrameLayout frameLayout = new FrameLayout(activity);
-        subject.addCloseEventRegion(frameLayout);
+    public void isTelAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
+        context = createMockContextWithSpecificIntentData("tel", null, null, "android.intent.action.DIAL");
+
+        assertThat(subject.isTelAvailable(context)).isTrue();
+    }
+
+    @Test
+    public void isTelAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
+        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.DIAL");
+
+        assertThat(subject.isTelAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isSmsAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
+        context = createMockContextWithSpecificIntentData("sms", null, null, "android.intent.action.VIEW");
+
+        assertThat(subject.isSmsAvailable(context)).isTrue();
+    }
+
+    @Test
+    public void isSmsAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
+        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.VIEW");
+
+        assertThat(subject.isSmsAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isStorePictureAvailable_whenPermissionDeclaredAndMediaMounted_shouldReturnTrue() throws Exception {
+        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
+
+        assertThat(subject.isStorePictureSupported(context)).isTrue();
+    }
+
+    @Test
+    public void isStorePictureAvailable_whenPermissionDenied_shouldReturnFalse() throws Exception {
+        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
+
+        assertThat(subject.isStorePictureSupported(context)).isFalse();
+    }
+
+    @Test
+    public void isStorePictureAvailable_whenMediaUnmounted_shouldReturnFalse() throws Exception {
+        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
+
+        assertThat(subject.isStorePictureSupported(context)).isFalse();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void isCalendarAvailable_atLeastIcs_shouldReturnTrue() throws Exception {
+        context = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
+        assertThat(subject.isCalendarAvailable(context)).isTrue();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
+    @Test
+    public void isCalendarAvailable_beforeIcs_shouldReturnFalse() throws Exception {
+        context = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
+        assertThat(subject.isCalendarAvailable(context)).isFalse();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void isCalendarAvailable_atLeastIcs_butCanNotAcceptIntent_shouldReturnFalse() throws
+            Exception {
+        context = createMockContextWithSpecificIntentData(null, null, "vnd.android.cursor.item/NOPE", "android.intent.action.INSERT");
+        assertThat(subject.isCalendarAvailable(context)).isFalse();
+    }
+
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnTrue() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isTrue();
+    }
+
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsNotHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB)
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsLessThanHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
+    }
+
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreNotHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
 
-        final Button closeEventRegion = (Button) frameLayout.getChildAt(0);
-        assertThat(closeEventRegion.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(closeEventRegion).getBackgroundColor()).isEqualTo(Color.TRANSPARENT);
-        assertThat(shadowOf(closeEventRegion).getOnClickListener()).isEqualTo(subject.getCloseOnClickListener());
-        assertThat(Dips.pixelsToIntDips((float)closeEventRegion.getLayoutParams().width, activity)).isEqualTo(50);
-        assertThat(Dips.pixelsToIntDips((float)closeEventRegion.getLayoutParams().height, activity)).isEqualTo(50);
-        assertThat(((FrameLayout.LayoutParams)closeEventRegion.getLayoutParams()).gravity).isEqualTo(Gravity.TOP | Gravity.RIGHT);
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(false);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
     }
 
-    private void resetMockMraidView(Context context) {
-        reset(mraidView);
-        stub(mraidView.getContext()).toReturn(context);
-        when(mraidView.getParent()).thenReturn(moPubView).thenReturn(null);
-        stub(mraidView.getRootView()).toReturn(rootView);
-        stub(mraidView.getAdConfiguration()).toReturn(adConfiguration);
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewParentIsNotHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+
+        // ViewParent
+        LinearLayout mockLinearLayout = mock(LinearLayout.class);
+        when(mockLinearLayout.isHardwareAccelerated()).thenReturn(false);
+        when(mockLinearLayout.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        // View
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+        when(mockView.getParent()).thenReturn(mockLinearLayout);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
     }
 
-    private MraidSupportsProperty captureMraidSupportProperties() {
-        ArgumentCaptor<MraidSupportsProperty> propertiesCaptor = ArgumentCaptor.forClass(MraidSupportsProperty.class);
-        verify(mraidView).fireChangeEventForProperty(propertiesCaptor.capture());
-        return propertiesCaptor.getValue();
+    private static Context createMockContextWithSpecificIntentData(final String scheme, final String componentName, final String type, final String action) {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+
+        BaseMatcher intentWithSpecificData = new BaseMatcher() {
+            // check that the specific intent has the special data, i.e. "tel:", or a component name, or string type, based on a particular data
+
+            @Override
+            public boolean matches(Object item) {
+                if (item != null && item instanceof Intent ){
+                    boolean result = action != null || type != null || componentName != null || scheme != null;
+                    if (action != null) {
+                        if (((Intent) item).getAction() != null) {
+                            result = result && action.equals(((Intent) item).getAction());
+                        }
+                    }
+
+                    if (type != null) {
+                        if (((Intent) item).getType() != null) {
+                            result = result && type.equals(((Intent) item).getType());
+                        }
+                    }
+
+                    if (componentName != null) {
+                        if (((Intent) item).getComponent() != null) {
+                            result = result && componentName.equals(((Intent) item).getComponent().getClassName());
+                        }
+                    }
+
+                    if (scheme != null) {
+                        if (((Intent) item).getData() != null) {
+                            result = result && scheme.equals(((Intent) item).getData().getScheme());
+                        }
+                    }
+                    return result;
+                }
+                return false;
+            }
+
+            @Override
+            public void describeTo(Description description) {
+
+            }
+        };
+
+        // It is okay to query with specific intent or nothing, because by default, none of the query would normally any resolveInfo anyways
+        stub(packageManager.queryIntentActivities((Intent) argThat(intentWithSpecificData), eq(0))).toReturn(resolveInfos);
+        return context;
     }
 
-    private void downloadImageForPendingResponse(String uri, HttpResponse response){
+    private void downloadImageForPendingResponse(String uri, HttpResponse response) throws Exception {
         Robolectric.addPendingHttpResponse(response);
 
-        stub(mraidView.getContext()).toReturn(Robolectric.application);
-        subject = new TestMraidDisplayController(mraidView, null, null);
-        subject.showUserDownloadImageAlert(uri);
+        subject.storePicture(context, uri, mraidCommandFailureListener);
 
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
     }
 
-    private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String contentType, String expectedFileName, String expectedExtension) {
+    private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String contentType,
+            String expectedFileName, String expectedExtension) throws Exception {
         expectedFile = new File(pictureDirectory, expectedFileName);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-        response.addHeader(MIME_TYPE_HEADER, contentType);
+        response.addHeader(MraidNativeCommandHandler.MIME_TYPE_HEADER, contentType);
 
         downloadImageForPendingResponse(originalFileName, response);
 
@@ -830,7 +762,8 @@ private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String
 
     private void setupCalendarParams() {
         //we need mock Context so that we can validate that isCalendarAvailable() is true
-        Context mockContext = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
+        Context mockContext = createMockContextWithSpecificIntentData(null,
+                null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
 
         //but a mock context does't know how to startActivity(), so we stub it to use ShadowContext for starting activity
         doAnswer(new Answer<Void>() {
@@ -844,34 +777,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
             }
         }).when(mockContext).startActivity(any(Intent.class));
 
-        resetMockMraidView(mockContext);
         params.put("description", "Some Event");
         params.put("start", CALENDAR_START_TIME);
     }
-
-    private Context createMockContextWithSpecificIntentData(final String scheme, final String componentName, final String type, final String action) {
-        return MraidsTest.createMockContextWithSpecificIntentData(scheme, componentName, type, action);
-    }
-
-    private class TestMraidDisplayController extends MraidDisplayController {
-        public TestMraidDisplayController(MraidView mraidView, MraidView.ExpansionStyle expStyle,
-                                          MraidView.NativeCloseButtonStyle buttonStyle) {
-            super(mraidView, expStyle, buttonStyle);
-        }
-
-        @Override
-        FrameLayout createAdContainerLayout() {
-            return adContainerLayout;
-        }
-
-        @Override
-        RelativeLayout createExpansionLayout() {
-            return expansionLayout;
-        }
-
-        @Override
-        FrameLayout createPlaceholderView() {
-            return placeholderView;
-        }
-    }
-}
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
similarity index 77%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoViewControllerTest.java
rename to mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
index 80b115ef..1ffe7e85 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
@@ -1,12 +1,12 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.app.Activity;
 import android.content.Context;
-import android.content.Intent;
 import android.os.Bundle;
 import android.widget.ImageButton;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.EventForwardingBroadcastReceiver;
 
 import org.apache.http.HttpRequest;
 import org.junit.After;
@@ -14,7 +14,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowImageButton;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 import org.robolectric.shadows.ShadowVideoView;
 import org.robolectric.tester.org.apache.http.RequestMatcher;
@@ -24,12 +23,8 @@
 import static android.view.View.VISIBLE;
 import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
 import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
@@ -39,17 +34,14 @@
 public class MraidVideoViewControllerTest {
     private Context context;
     private Bundle bundle;
-    private long testBroadcastIdentifier;
     private MraidVideoViewController subject;
     private BaseVideoViewControllerListener baseVideoViewControllerListener;
     private EventForwardingBroadcastReceiver broadcastReceiver;
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         bundle = new Bundle();
-        testBroadcastIdentifier = 1111;
-        broadcastReceiver = mock(EventForwardingBroadcastReceiver.class);
         baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
 
         bundle.putString(VIDEO_URL, "http://video_url");
@@ -96,7 +88,7 @@ public void onCreate_shouldCreateAndHideCloseButton() throws Exception {
         ImageButton closeButton = getCloseButton();
 
         assertThat(closeButton).isNotNull();
-        assertThat(getShadowImageButton(closeButton).getOnClickListener()).isNotNull();
+        assertThat(shadowOf(closeButton).getOnClickListener()).isNotNull();
         assertThat(closeButton.getVisibility()).isEqualTo(GONE);
     }
 
@@ -112,9 +104,7 @@ public void closeButton_onClick_shouldCallBaseVideoControllerListenerOnFinish()
         initializeSubject();
         subject.onCreate();
 
-        ImageButton closeButton = getCloseButton();
-
-        getShadowImageButton(closeButton).getOnClickListener().onClick(null);
+        getCloseButton().performClick();
         verify(baseVideoViewControllerListener).onFinish();
     }
 
@@ -162,32 +152,15 @@ public void onErrorListener_shouldShowCloseButton() throws Exception {
         assertThat(getCloseButton().getVisibility()).isEqualTo(VISIBLE);
     }
 
-    @Test
-    public void onErrorListener_shouldBroadcastInterstitialError() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-
-        initializeSubject();
-        subject.onCreate();
-
-        assertThat(getShadowVideoView().getOnErrorListener().onError(null, 0, 0)).isEqualTo(false);
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
     private void initializeSubject() {
-        subject = new MraidVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
+        subject = new MraidVideoViewController(context, bundle, null, baseVideoViewControllerListener);
     }
 
     private ShadowVideoView getShadowVideoView() {
         return shadowOf(subject.getVideoView());
     }
 
-    protected ImageButton getCloseButton() {
+    ImageButton getCloseButton() {
         return (ImageButton) subject.getLayout().getChildAt(1);
     }
-
-    private ShadowImageButton getShadowImageButton(ImageButton imageButton) {
-        return (ShadowImageButton) shadowOf(imageButton);
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
index fe8f94c7..a2f85dbd 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
@@ -1,15 +1,17 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.content.Context;
 
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
 
 @RunWith(SdkTestRunner.class)
 public class AdapterHelperTest {
@@ -20,31 +22,29 @@
     private int interval;
 
     @Before
-    public void setUp() throws Exception {
-        context = new Activity();
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
         start = 1;
         interval = 2;
         subject = new AdapterHelper(context, start, interval);
     }
 
-    @Test
-    public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            new AdapterHelper(context.getApplicationContext(), start, interval);
-            fail("Expected IllegalArgumentException to be thrown");
-        } catch (IllegalArgumentException e) {
-            assertThat(e.getMessage()).isEqualTo("Illegal argument: Context must be instance of Activity.");
-        }
+    @Test(expected = IllegalArgumentException.class)
+    public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumentException() {
+        new AdapterHelper(context.getApplicationContext(), start, interval);
     }
 
     @Test
-    public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() throws Exception {
+    public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() {
         subject.clearActivityContext();
-        assertThat(subject.getAdView(null, null, null, null, null).getContext()).isEqualTo(context.getApplication());
+        Context viewContext = subject.getAdView(null, null, mock(NativeResponse.class),
+                mock(ViewBinder.class),
+                null).getContext();
+        assertThat(viewContext).isEqualTo(context.getApplication());
     }
 
     @Test
-    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() throws Exception {
+    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() {
         contentRowCount = 10;
 
         start = 0;
@@ -158,7 +158,7 @@ public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() thr
     }
 
     @Test
-    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() throws Exception {
+    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() {
         contentRowCount = 1;
         start = 0;
         interval = 2;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
index 85fe6d61..6a067014 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
@@ -2,11 +2,10 @@
 
 import android.app.Activity;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.util.ResponseHeader;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+import com.mopub.common.AdType;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.nativeads.test.support.TestCustomEventNativeFactory;
+import com.mopub.network.AdResponse;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -15,6 +14,7 @@
 import java.util.HashMap;
 
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
@@ -23,12 +23,11 @@
 public class CustomEventNativeAdapterTest {
 
     private Activity context;
-    private DownloadResponse downloadResponse;
     private HashMap<String, Object> localExtras;
     private CustomEventNative.CustomEventNativeListener mCustomEventNativeListener;
     private CustomEventNative mCustomEventNative;
     private HashMap<String, String> serverExtras;
-    private TestHttpResponseWithHeaders testHttpResponseWithHeaders;
+    private AdResponse testAdResponse;
 
     @Before
     public void setUp() throws Exception {
@@ -37,12 +36,13 @@ public void setUp() throws Exception {
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
         serverExtras.put("key", "value");
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, "body");
 
-        testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "body");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_DATA.getKey(), "{ \"key\" : \"value\" }");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.mopub.nativeads.MoPubCustomEventNative");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        testAdResponse = new AdResponse.Builder()
+                .setAdType(AdType.NATIVE)
+                .setCustomEventClassName("com.mopub.nativeads.MoPubCustomEventNative")
+                .setResponseBody("body")
+                .setServerExtras(serverExtras)
+                .build();
 
         mCustomEventNativeListener = mock(CustomEventNative.CustomEventNativeListener.class);
 
@@ -51,7 +51,7 @@ public void setUp() throws Exception {
 
     @Test
     public void loadNativeAd_withValidInput_shouldCallLoadNativeAdOnTheCustomEvent() throws Exception {
-        CustomEventNativeAdapter.loadNativeAd(context, localExtras, downloadResponse, mCustomEventNativeListener);
+        CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
         verify(mCustomEventNative).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
         verify(mCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
@@ -59,10 +59,11 @@ public void loadNativeAd_withValidInput_shouldCallLoadNativeAdOnTheCustomEvent()
 
     @Test
     public void loadNativeAd_withInvalidClassName_shouldNotifyListenerOfOnNativeAdFailedAndReturn() throws Exception {
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.mopub.baaad.invalidinvalid123143");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        testAdResponse = testAdResponse.toBuilder()
+                .setCustomEventClassName("com.mopub.baaad.invalidinvalid123143")
+                .build();
 
-        CustomEventNativeAdapter.loadNativeAd(context, localExtras, downloadResponse, mCustomEventNativeListener);
+        CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
         verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_NOT_FOUND);
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
         verify(mCustomEventNative, never()).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
@@ -70,12 +71,12 @@ public void loadNativeAd_withInvalidClassName_shouldNotifyListenerOfOnNativeAdFa
 
     @Test
     public void loadNativeAd_withInvalidCustomEventNativeData_shouldNotAddToServerExtras() throws Exception {
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_DATA.getKey(), "{ \"bad json");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
-        serverExtras.remove("key");
+        testAdResponse = testAdResponse.toBuilder()
+                .setServerExtras(null)
+                .build();
 
-        CustomEventNativeAdapter.loadNativeAd(context, localExtras, downloadResponse, mCustomEventNativeListener);
-        verify(mCustomEventNative).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
+        CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
+        verify(mCustomEventNative).loadNativeAd(eq(context), eq(mCustomEventNativeListener), eq(localExtras), eq(new HashMap<String, String>()));
         verify(mCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
deleted file mode 100644
index 6d6e7195..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.nativeads.TaskManager.TaskManagerListener;
-import static junit.framework.Assert.fail;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyMap;
-import static org.mockito.Mockito.doAnswer;
-
-@RunWith(SdkTestRunner.class)
-public class ImageDiskTaskManagerTest {
-
-    @Mock private TaskManagerListener<Bitmap> imageTaskManagerListener;
-    private Semaphore semaphore;
-    private Map<String, Bitmap> bitmaps;
-    private FakeHttpLayer fakeHttpLayer;
-    private String url1;
-    private String url2;
-    private String url3;
-    private String imageData1;
-    private String imageData2;
-    private String imageData3;
-    private List<String> list;
-    private Context context;
-    private static final int TEST_WIDTH = 400;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        semaphore = new Semaphore(0);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                Map<String, Bitmap> bitmaps = (Map)args[0];
-                ImageDiskTaskManagerTest.this.bitmaps = bitmaps;
-                semaphore.release();
-                return null;
-            }
-        }).when(imageTaskManagerListener).onSuccess(anyMap());
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(imageTaskManagerListener).onFail();
-
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com";
-        url3 = "http://www.guydot.com";
-        imageData1 = "image_data_1";
-        imageData2 = "image_data_2";
-        imageData3 = "image_data_3";
-
-        list = new ArrayList<String>();
-        list.add(url1);
-        list.add(url2);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
-    @Test
-    public void constructor_withNullUrlsList_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            new ImageDiskTaskManager(null, imageTaskManagerListener, TEST_WIDTH);
-            fail("Should have thrown IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withNullInUrlsList_shouldThrowIllegalArgumentException() throws Exception {
-        List<String> myList = new ArrayList<String>();
-        myList.add(null);
-        try {
-            new ImageDiskTaskManager(myList, imageTaskManagerListener, TEST_WIDTH);
-            fail("Should have thrown IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withNullImageTaskManagerListener_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            new ImageDiskTaskManager(list, null, TEST_WIDTH);
-            fail("Should have thrown IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withEmptyDiskCache_shouldReturnNullsInMap() throws Exception {
-        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
-        semaphore.acquire();
-
-        assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(bitmaps.containsKey(url1)).isTrue();
-        assertThat(bitmaps.containsKey(url2)).isTrue();
-        assertThat(bitmaps.get(url1)).isNull();
-        assertThat(bitmaps.get(url2)).isNull();
-    }
-
-    @Test
-    public void execute_withPopulatedDiskCache_shouldReturnImagesInMap() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-
-        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
-        semaphore.acquire();
-
-        assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(bitmaps.get(url1)).isNotNull();
-        assertThat(bitmaps.get(url2)).isNotNull();
-    }
-
-    @Test
-    public void execute_withPartiallyPopulatedDiskCache_shouldReturnSomeImagesInMap() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-
-        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
-        semaphore.acquire();
-
-        assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(bitmaps.get(url1)).isNotNull();
-        assertThat(bitmaps.containsKey(url2)).isTrue();
-        assertThat(bitmaps.get(url2)).isNull();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
deleted file mode 100644
index b9664d43..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
+++ /dev/null
@@ -1,259 +0,0 @@
-package com.mopub.nativeads;
-
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.params.BasicHttpParams;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.nativeads.TaskManager.TaskManagerListener;
-import static junit.framework.Assert.fail;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyMap;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class ImageDownloadTaskManagerTest {
-
-    private ImageDownloadTaskManager subject;
-    @Mock private TaskManagerListener<DownloadResponse> mMockImageTaskManagerListener;
-    private Semaphore semaphore;
-    private Map<String, DownloadResponse> networkImages;
-    private int testMaxWidth;
-    private FakeHttpLayer fakeHttpLayer;
-    private String url1;
-    private String url2;
-
-    @Before
-    public void setUp() throws Exception {
-        semaphore = new Semaphore(0);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                Map<String, DownloadResponse> map = (Map)args[0];
-                ImageDownloadTaskManagerTest.this.networkImages = map;
-                semaphore.release();
-                return null;
-            }
-        }).when(mMockImageTaskManagerListener).onSuccess(anyMap());
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(mMockImageTaskManagerListener).onFail();
-        testMaxWidth = 30;
-
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com";
-    }
-
-    @Test
-    public void constructor_withValidUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url2),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-    }
-
-    @Test
-    public void constructor_withEmptyUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                new ArrayList<String>(),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-    }
-
-    @Test
-    public void constructor_withInvalidUrlList_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            subject = new ImageDownloadTaskManager(
-                    Arrays.asList("BAD URL", url2),
-                    mMockImageTaskManagerListener,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-
-        try {
-            subject = new ImageDownloadTaskManager(
-                    Arrays.asList(url1, null),
-                    mMockImageTaskManagerListener,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withAnyNullParams_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            subject = new ImageDownloadTaskManager(
-                    null,
-                    mMockImageTaskManagerListener,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-
-        try {
-            subject = new ImageDownloadTaskManager(
-                    Arrays.asList(url1, url2),
-                    null,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withValidUrlListAndListenerAndHttpResponses_shouldReturnMapOfUrlToDownloadResponse() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url2),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        String imageData1 = "image_data_1";
-        String imageData2 = "image_data_2";
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        subject.execute();
-        semaphore.acquire();
-
-        assertThat(networkImages.keySet()).containsOnly(url1, url2);
-
-        // These statements will fail if the objects are not of the correct type.
-        DownloadResponse bitmap1 = networkImages.get(url1);
-        DownloadResponse bitmap2 = networkImages.get(url2);
-
-        verify(mMockImageTaskManagerListener).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener, never()).onFail();
-    }
-
-    @Test
-    public void execute_withEmptyUrlList_shouldReturnEmptyMap() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                new ArrayList<String>(),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        subject.execute();
-        semaphore.acquire();
-
-        assertThat(networkImages.isEmpty()).isTrue();
-        verify(mMockImageTaskManagerListener).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener, never()).onFail();
-    }
-
-    @Test
-    public void execute_withSingleNon200Response_shouldFailAllTasks() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-
-        subject.execute();
-        semaphore.acquire();
-
-        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener).onFail();
-    }
-
-    @Test
-    public void execute_withMultipleNon200Response_shouldFailAllTasks() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-
-        subject.execute();
-        semaphore.acquire();
-
-        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener).onFail();
-    }
-
-    @Ignore("need to fix concurrency logic")
-    @Test
-    public void execute_withSingleInvalidHttpResponse_shouldFailAllTasks() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(createMockHttpResponseThatThrowsOnGetContent());
-
-        subject.execute();
-        semaphore.acquire();
-
-        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener).onFail();
-    }
-
-    private static HttpResponse createMockHttpResponseThatThrowsOnGetContent() throws IOException {
-        HttpEntity mockHttpEntity = mock(HttpEntity.class);
-        when(mockHttpEntity.getContent()).thenThrow(new IOException());
-
-        TestHttpResponse mockHttpResponse = mock(TestHttpResponse.class);
-        when(mockHttpResponse.getStatusLine()).thenReturn(mockHttpResponse.new TestStatusLine());
-        when(mockHttpResponse.getParams()).thenReturn(new BasicHttpParams());
-        when(mockHttpResponse.getEntity()).thenReturn(mockHttpEntity);
-        return mockHttpResponse;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
deleted file mode 100644
index f1298d06..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
+++ /dev/null
@@ -1,406 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.common.DownloadResponse;
-import com.mopub.nativeads.test.support.MoPubShadowBitmap;
-import com.mopub.nativeads.test.support.MoPubShadowDisplay;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.nativeads.ImageService.ImageServiceListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyMap;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
-public class ImageServiceTest {
-    private ImageServiceListener imageServiceListener;
-    private Semaphore semaphore;
-    private Map<String, Bitmap> bitmaps;
-    private FakeHttpLayer fakeHttpLayer;
-    private String url1;
-    private String url2;
-    private String url3;
-    private String imageData1;
-    private String imageData2;
-    private String imageData3;
-    private Context context;
-    private Bitmap image2;
-    private Bitmap image1;
-    private DownloadResponse downloadResponse;
-
-    @Before
-    public void setUp() throws Exception {
-        semaphore = new Semaphore(0);
-        imageServiceListener = mock(ImageServiceListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                Map<String, Bitmap> bitmaps = (Map)args[0];
-                ImageServiceTest.this.bitmaps = bitmaps;
-                semaphore.release();
-                return null;
-            }
-        }).when(imageServiceListener).onSuccess(anyMap());
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(imageServiceListener).onFail();
-
-        downloadResponse = mock(DownloadResponse.class);
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com";
-        url3 = "http://www.guydot.com";
-        imageData1 = "image_data_1";
-        imageData2 = "image_data_2";
-        imageData3 = "image_data_3";
-        image1 = BitmapFactory.decodeByteArray(imageData1.getBytes(), 0, imageData1.getBytes().length);
-        image2 = BitmapFactory.decodeByteArray(imageData2.getBytes(), 0, imageData2.getBytes().length);
-        context = new Activity();
-
-        ImageService.initialize(context);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
-    @Test
-    public void get_shouldInitializeCaches() throws Exception {
-        CacheService.clearAndNullCaches();
-        assertThat(CacheService.getBitmapLruCache()).isNull();
-        assertThat(CacheService.getDiskLruCache()).isNull();
-
-        ImageService.get(context, new ArrayList<String>(), imageServiceListener);
-
-        assertThat(CacheService.getBitmapLruCache()).isNotNull();
-        assertThat(CacheService.getDiskLruCache()).isNotNull();
-    }
-
-    @Test
-    public void get_shouldGetDisplaySize() {
-        ImageService.clear();
-        assertThat(ImageService.getTargetWidth()).isEqualTo(-1);
-
-        ImageService.get(context, new ArrayList<String>(), imageServiceListener);
-        assertThat(ImageService.getTargetWidth()).isGreaterThan(-1);
-    }
-
-    @Test
-    public void get_withImageInMemoryCache_shouldReturnImage() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToBitmapCache(url1, image1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        // no need for semaphore since memory cache is synchronous
-
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void get_withImageInDiskCache_shouldReturnImage() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void get_withEmptyCaches_shouldGetImageFromNetwork() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void get_withImagesInMemoryCacheAndDiskCache_shouldReturnBothImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-
-        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(bitmaps.get(url1)).isEqualTo(image1);
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withImagesInMemoryAndNetwork_shouldReturnBothImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withImagesInDiskAndNetwork_shouldReturnBothImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withImagesInMemoryAndDiskAndNetwork_shouldReturnAllImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(200, imageData3);
-
-        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-        assertThat(shadowOf(bitmaps.get(url3)).getDescription())
-                .isEqualTo("Bitmap for image_data_3");
-    }
-
-    @Test
-    public void get_withSameKeysInMemoryAndDiskCache_shouldReturnValueFromMemoryCache() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image2);
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
-    }
-
-    @Test
-    public void get_withSameKeysInMemoryAndNetwork_shouldReturnValueFromMemoryCache() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image2);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
-    }
-
-    @Test
-    public void get_withSameKeysInDiskAndNetwork_shouldReturnValueFromDiskCache() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToDiskCache(url1, imageData2.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withNetworkFailure_shouldFail() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(500, imageData3);
-
-        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(bitmaps).isNull();
-    }
-
-    @Test
-    public void get_withMultipleNetworkSuccessAndOneFailure_shouldFail() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-        fakeHttpLayer.addPendingHttpResponse(500, imageData3);
-
-        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(bitmaps).isNull();
-    }
-
-    @Test
-    public void putDataInCache_populatesCaches() throws Exception {
-        CacheService.initialize(context);
-
-        Bitmap bitmap1 = BitmapFactory.decodeStream(getInputStreamFromString(imageData1));
-        Bitmap bitmap2 = BitmapFactory.decodeStream(getInputStreamFromString(imageData2));
-
-        assertThat(ImageService.getBitmapFromDiskCache(url1)).isNull();
-        assertThat(ImageService.getBitmapFromDiskCache(url2)).isNull();
-        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isNull();
-        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isNull();
-
-        ImageService.putDataInCache(url1, bitmap1, imageData1.getBytes());
-        ImageService.putDataInCache(url2, bitmap2, imageData2.getBytes());
-
-        Thread.sleep(500); // disk cache put is async
-
-        assertThat(shadowOf(ImageService.getBitmapFromDiskCache(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-        assertThat(shadowOf(ImageService.getBitmapFromDiskCache(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isEqualTo(bitmap1);
-        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isEqualTo(bitmap2);
-    }
-
-    @Test
-    public void getBitmapsFromMemoryCache_withEmptyCacheAndTwoUrls_returnsNoCacheHitsAndTwoCacheMisses() throws Exception {
-        CacheService.initialize(context);
-        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
-
-        Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
-        List<String> cacheMisses =
-                ImageService.getBitmapsFromMemoryCache(Arrays.asList(url1, url2), cacheHits);
-
-        assertThat(cacheHits).isEmpty();
-        assertThat(cacheMisses).containsOnly(url1, url2);
-    }
-
-    @Test
-    public void getBitmapsFromMemoryCache_withOneCacheEntryAndTwoUrls_returnsOneCacheHitAndOneCacheMiss() throws Exception {
-        CacheService.initialize(context);
-
-        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
-
-        CacheService.putToBitmapCache(url1, image1);
-
-        Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
-        List<String> cacheMisses =
-                ImageService.getBitmapsFromMemoryCache(Arrays.asList(url1, url2), cacheHits);
-
-        assertThat(cacheHits.keySet()).containsOnly(url1);
-        assertThat(cacheMisses).containsOnly(url2);
-    }
-
-    @Test
-    public void asBitmap_withMaxSize_shouldReturnBitmap() {
-
-        String imageData = "fake_bitmap_data";
-        when(downloadResponse.getByteArray()).thenReturn(imageData.getBytes());
-
-        final Bitmap bitmap = ImageService.asBitmap(downloadResponse, 30);
-
-        assertThat(bitmap).isNotNull();
-        assertThat(bitmap).isInstanceOf(Bitmap.class);
-    }
-
-    @Test
-    public void asBitmap_withNullResponse_shouldReturnNull() throws Exception {
-        final Bitmap bitmap = ImageService.asBitmap(null, 30);
-
-        assertThat(bitmap).isNull();
-    }
-
-    @Test
-    public void calculateInSampleSize_withImageSmallerThanRequested_shouldBe1() {
-        int nativeWidth = 1024;
-        assertThat(ImageService.calculateInSampleSize(nativeWidth, 2046)).isEqualTo(1);
-    }
-
-    @Test
-    public void calculateInSampleSize_withImageSlightlyBiggerThanRequest_shouldBe1() {
-        int nativeWidth = 1024;
-        assertThat(ImageService.calculateInSampleSize(nativeWidth, 800)).isEqualTo(1);
-
-    }
-
-    @Test
-    public void calculateInSampleSize_withImageMuchBiggerThanRequest_shouldBe4() {
-        int nativeWidth = 2048;
-        int nativeHeight = 1024;
-        assertThat(ImageService.calculateInSampleSize(nativeWidth, 512)).isEqualTo(4);
-    }
-
-    private static InputStream getInputStreamFromString(final String string) {
-        return spy(new ByteArrayInputStream(string.getBytes()));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
deleted file mode 100644
index 54ea511d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
+++ /dev/null
@@ -1,202 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
-import android.widget.ImageView;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.nativeads.test.support.MoPubShadowBitmap;
-import com.mopub.nativeads.test.support.MoPubShadowDisplay;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
-public class ImageViewServiceTest {
-
-    private ImageView imageView;
-    private String url1;
-    private String url2;
-    private String imageData1;
-    private String imageData2;
-    private FakeHttpLayer fakeHttpLayer;
-    private Bitmap image1;
-
-    @Before
-    public void setUp() throws Exception {
-        Context context = new Activity();
-        imageView = new ImageView(context);
-        CacheService.initialize(context);
-        ImageService.initialize(context);
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com/";
-        imageData1 = "image_data_1";
-        imageData2 = "image_data_2";
-        image1 = BitmapFactory.decodeByteArray(imageData1.getBytes(), 0, imageData1.getBytes().length);
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
-    @Test
-    public void loadImageView_withImageInMemoryCache_shouldLoadImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToBitmapCache(url1, image1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
-                .isEqualTo(imageData1.getBytes());
-    }
-
-    @Test
-    public void loadImageView_withImageInDiskCache_shouldLoadImageDataAsync() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-        assertThat(CacheService.containsKeyDiskCache(url1)).isTrue();
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void loadImageView_withImageInNetwork_shouldLoadImageDataAsync() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-        assertThat(imageView.getDrawable()).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void loadImageView_withImageInNetworkAndUniqueIdChanges_shouldNotLoadImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url1, imageView);
-
-        // Change unique id before running async task to simulate another image load
-        ImageViewService.setImageViewUniqueId(imageView, -1);
-
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
-
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void loadImageView_withImageInNetworkAndUniqueIdIsNull_shouldNotLoadImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url1, imageView);
-
-        // Change unique id before running async task to simulate another image load
-        ImageViewService.setImageViewUniqueId(imageView, -1);
-
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
-
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void loadImageView_withTwoNetworkRequests_shouldLoadSecondImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url1, imageView);
-        ImageViewService.loadImageView(url2, imageView);
-
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
-
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void loadImageView_shouldClearDrawable() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url2, imageView);
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void loadImageView_withEmptyCachesAndNetworkFailure_shouldNotLoadImageDataAsync() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        fakeHttpLayer.addPendingHttpResponse(500, imageData1);
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    static Bitmap getBitmapFromImageView(final ImageView imageView) {
-        return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
index 880c3ba1..06f1c83d 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
@@ -1,108 +1,206 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.database.DataSetObserver;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.AdapterView.OnItemLongClickListener;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
 
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
-import org.robolectric.annotation.Config;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.AdditionalMatchers.leq;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-@Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class MoPubAdAdapterTest {
+    private static final int AD_POSITION = 1;
 
     @Mock
-    public BaseAdapter mockOriginalAdapter;
+    private MoPubStreamAdPlacer mockStreamAdPlacer;
     @Mock
-    public MoPubStreamAdPlacer mockStreamAdPlacer;
+    private NativeAdData mockNativeAdData;
     @Mock
-    public Object mockItem;
+    private View mockAdView;
     @Mock
-    public NativeAdData mockAd;
+    private VisibilityTracker mockVisibilityTracker;
     @Mock
-    public View mockAdView;
+    private MoPubNativeAdLoadedListener mockAdLoadedListener;
     @Mock
-    public View mockItemView;
+    private DataSetObserver mockDataSetObserver;
     @Mock
-    public VisibilityTracker mockVisibilityTracker;
+    private RequestParameters mockRequestParameters;
     @Mock
-    public MoPubNativeAdLoadedListener mockAdLoadedListener;
+    private ViewBinder mockViewBinder;
     @Mock
-    public DataSetObserver mockDataSetObserver;
+    private MoPubAdRenderer mockAdRenderer;
+    @Mock
+    private ListView mockListView;
+    @Mock
+    private OnItemClickListener mockOnItemClickListener;
+    @Mock
+    private OnItemLongClickListener mockOnItemLongClickListener;
+    @Mock
+    private OnItemSelectedListener mockOnItemSelectedListener;
+    @Mock
+    private View mockItemView;
 
-    public MoPubAdAdapter subject;
+    private long originalItemId = 0;
+    private boolean originalHasStableIds = false;
 
-    private static final int AD_POSITION = 4;
+    private int originalItemViewType = 0;
+    private int originalViewTypeCount = 1;
+    private boolean originalItemsAreEnabled = false;
+    private ArrayAdapter<String> originalAdapter;
+    private MoPubAdAdapter subject;
 
     @Before
     public void setup() {
+        // Set up original adapter with 2 items
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        originalAdapter = new ArrayAdapter<String>(activity, android.R.layout.simple_list_item_1) {
+            @Override
+            public boolean isEnabled(final int position) {
+                return originalItemsAreEnabled;
+            }
+
+            @Override
+            public long getItemId(final int position) {
+                return originalItemId;
+            }
 
-        // Mock setup code.
-        when(mockOriginalAdapter.getViewTypeCount()).thenReturn(1);
-        when(mockOriginalAdapter.getCount()).thenReturn(30);
-        when(mockOriginalAdapter.getItem(leq(29))).thenReturn(mockItem);
-        when(mockOriginalAdapter.getView(anyInt(), any(View.class), any(ViewGroup.class))).thenReturn(mockItemView);
+            @Override
+            public boolean hasStableIds() {
+                return originalHasStableIds;
+            }
 
-        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockAd);
+            @Override
+            public int getItemViewType(final int position) {
+                return originalItemViewType;
+            }
+
+            @Override
+            public int getViewTypeCount() {
+                return originalViewTypeCount;
+            }
+        };
+        originalAdapter.add("ITEM 1");
+        originalAdapter.add("ITEM 2");
+
+        subject = new MoPubAdAdapter(mockStreamAdPlacer, originalAdapter, mockVisibilityTracker);
+
+        // Reset because the constructor interacts with the stream ad placer, and we don't want
+        // to worry about verifying those changes in tests.
+        reset(mockStreamAdPlacer);
+
+        // Mock some simple adjustment behavior for tests. This is creating an ad placer that
+        // emulates a content item followed by an ad item, then another content item.
+        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockNativeAdData);
         when(mockStreamAdPlacer.getAdView(eq(AD_POSITION), any(View.class), any(ViewGroup.class))).thenReturn(mockAdView);
+        when(mockStreamAdPlacer.isAd(anyInt())).thenAnswer(new Answer<Boolean>() {
+            @Override
+            public Boolean answer(final InvocationOnMock invocation) throws Throwable {
+                int position = (Integer)invocation.getArguments()[0];
+                return position == AD_POSITION;
+            }
+        });
+        when(mockStreamAdPlacer.getOriginalPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition < AD_POSITION ? originalPosition : originalPosition - 1;
+            }
+        });
+        when(mockStreamAdPlacer.getAdViewType(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition == AD_POSITION ? 1 : MoPubStreamAdPlacer.CONTENT_VIEW_TYPE;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition < AD_POSITION ? originalPosition : originalPosition + 1;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedCount(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalCount = (Integer)invocation.getArguments()[0];
+                return originalCount < AD_POSITION ? originalCount : originalCount + 1;
+            }
+        });
+    }
+
+    @Test
+    public void originalAdapterChange_shouldNotifyDataSetChanged() {
+        subject.registerDataSetObserver(mockDataSetObserver);
 
-        // Mock some adjustment behavior for tests.
-        when(mockStreamAdPlacer.getOriginalPosition(eq(1))).thenReturn(1);
-        when(mockStreamAdPlacer.getOriginalPosition(eq(8))).thenReturn(7);
-        when(mockStreamAdPlacer.getAdjustedCount(eq(30))).thenReturn(31);
+        originalAdapter.notifyDataSetChanged();
 
-        subject = new MoPubAdAdapter(mockStreamAdPlacer, mockOriginalAdapter, mockVisibilityTracker);
+        verify(mockDataSetObserver).onChanged();
     }
 
     @Test
-    public void getItem_shouldCallAdPlacer() throws Exception {
-        assertThat(subject.getItem(AD_POSITION)).isEqualTo(mockAd);
-        verify(mockStreamAdPlacer, never()).getOriginalPosition(AD_POSITION);
-        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
+    public void originalAdapterInvalidated_shouldNotifyDataSetInvalidated() {
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        originalAdapter.notifyDataSetInvalidated();
+
+        verify(mockDataSetObserver).onInvalidated();
     }
 
     @Test
-    public void getItem_shouldCallOriginalAdapter() throws Exception {
-        assertThat(subject.getItem(1)).isEqualTo(mockItem);
-        verify(mockStreamAdPlacer).getOriginalPosition(1);
-        verify(mockOriginalAdapter).getItem(1);
+    public void registerAdRenderer_shouldCallRegisterAdRendererOnAdPlacer() {
+        subject.registerAdRenderer(mockAdRenderer);
 
-        assertThat(subject.getItem(8)).isEqualTo(mockItem);
-        verify(mockStreamAdPlacer).getOriginalPosition(8);
-        verify(mockOriginalAdapter).getItem(7);
+        verify(mockStreamAdPlacer).registerAdRenderer(mockAdRenderer);
     }
 
     @Test
-    public void getCount_shouldCallAdPlacer() throws Exception {
-        assertThat(subject.getCount()).isEqualTo(31);
-        verify(mockStreamAdPlacer).getAdjustedCount(30);
+    public void registerAdRenderer_withNull_shouldNotCallAdPlacer() {
+        subject.registerAdRenderer(null);
+
+        verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
     }
 
     @Test
-    public void getItemIdForAd_shouldBeNegative() throws Exception {
-        assertThat(subject.getItemId(AD_POSITION)).isLessThan(0);
+    public void registerViewBinder_shouldCallAdPlacer() {
+        subject.registerViewBinder(mockViewBinder);
+
+        final ArgumentCaptor<MoPubAdRenderer> rendererCaptor = new ArgumentCaptor<MoPubAdRenderer>();
+        verify(mockStreamAdPlacer).registerAdRenderer(rendererCaptor.capture());
+        MoPubAdRenderer renderer = rendererCaptor.getValue();
+        assertThat(renderer).isExactlyInstanceOf(MoPubNativeAdRenderer.class);
     }
-    
+
     @Test
-    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
-        subject.destroy();
-        verify(mockStreamAdPlacer).destroy();
-        verify(mockVisibilityTracker).destroy();
+    public void registerViewBinder_withNull_shouldNotCallAdPlacer() {
+        subject.registerViewBinder(null);
+
+        verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
     }
 
     @Test
@@ -111,6 +209,7 @@ public void setAdLoadedListener_handleAdLoaded_shouldCallCallback_shouldCallObse
         subject.registerDataSetObserver(mockDataSetObserver);
 
         subject.handleAdLoaded(8);
+
         verify(mockAdLoadedListener).onAdLoaded(8);
         verify(mockDataSetObserver).onChanged();
     }
@@ -121,25 +220,325 @@ public void setAdLoadedListener_handleAdRemoved_shouldCallCallback_shouldCallObs
         subject.registerDataSetObserver(mockDataSetObserver);
 
         subject.handleAdRemoved(10);
+
         verify(mockAdLoadedListener).onAdRemoved(10);
         verify(mockDataSetObserver).onChanged();
     }
 
     @Test
-    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() throws Exception {
+    public void loadAds_shouldCallLoadAdsOnAdPlacer() {
+        subject.loadAds("AD_UNIT_ID");
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID");
+
+        subject.loadAds("AD_UNIT_ID", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
+    }
+
+    @Test
+    public void isAd_shouldCallIsAdOnAdPlacer() {
+        boolean isAd = subject.isAd(AD_POSITION);
+
+        assertThat(isAd).isTrue();
+
+        isAd = subject.isAd(AD_POSITION + 1);
+
+        assertThat(isAd).isFalse();
+
+        verify(mockStreamAdPlacer, times(2)).isAd(anyInt());
+    }
+
+    @Test
+    public void clearAds_shouldCallClearAdsOnAdPlacer() {
+        subject.clearAds();
+
+        verify(mockStreamAdPlacer).clearAds();
+    }
+
+    @Test
+    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
+        subject.destroy();
+
+        verify(mockStreamAdPlacer).destroy();
+        verify(mockVisibilityTracker).destroy();
+    }
+
+    @Test
+    public void isEnabled_adPosition_shouldReturnTrue() {
+        boolean isEnabled = subject.isEnabled(AD_POSITION);
+
+        assertThat(isEnabled).isTrue();
+    }
+
+    @Test
+    public void isEnabled_withNonAdPosition_shouldUseOriginalAdapter() {
+        originalItemsAreEnabled = false;
+        boolean isEnabled = subject.isEnabled(AD_POSITION + 1);
+
+        assertThat(isEnabled).isFalse();
+
+        originalItemsAreEnabled = true;
+        isEnabled = subject.isEnabled(AD_POSITION + 1);
+
+        assertThat(isEnabled).isTrue();
+    }
+
+    @Test
+    public void getItem_withAdPosition_shouldReturnAd_shouldGetAdDataOnCallAdPlacer() {
+        Object actualItem = subject.getItem(AD_POSITION);
+
+        assertThat(actualItem).isEqualTo(mockNativeAdData);
+
+        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
+    }
+
+    @Test
+    public void getItem_withNonAdPosition_shouldCallGetOriginalPositionOnAdPlacer() {
+        Object actualItem = subject.getItem(AD_POSITION + 1);
+
+        assertThat(actualItem).isNotEqualTo(mockNativeAdData);
+
+        verify(mockStreamAdPlacer).getOriginalPosition(AD_POSITION + 1);
+    }
+
+    @Test
+    public void getCount_shouldCallGetAdjustedCountOnAdPlacer() {
+        int actualCount = subject.getCount();
+
+        assertThat(actualCount).isEqualTo(3);
+
+        verify(mockStreamAdPlacer).getAdjustedCount(anyInt());
+    }
+
+    @Test
+    public void getItemId_withAdPosition_shouldBeNegative() {
+        long itemId = subject.getItemId(AD_POSITION);
+
+        assertThat(itemId).isLessThan(0);
+    }
+
+    @Test
+    public void getItemId_withNonAdPosition_shouldUseOriginalAdapterId() {
+        originalItemId = 42;
+        long itemId = subject.getItemId(AD_POSITION + 1);
+
+        assertThat(itemId).isEqualTo(42);
+    }
+
+    @Test
+    public void hasStableIds_shouldUseOriginalAdapterValue() {
+        originalHasStableIds = false;
+        boolean hasStableIds = subject.hasStableIds();
+
+        assertThat(hasStableIds).isFalse();
+
+        originalHasStableIds = true;
+        hasStableIds = subject.hasStableIds();
+
+        assertThat(hasStableIds).isTrue();
+    }
+
+    @Test
+    public void getView_withAdPosition_shouldReturnAdView_shouldTrackVisibility() {
+        View view = subject.getView(AD_POSITION, null, null);
+
+        assertThat(view).isEqualTo(mockAdView);
+
+        verify(mockVisibilityTracker).addView(eq(mockAdView), anyInt());
+    }
+
+    @Test
+    public void getView_withNonAdPosition_shouldOriginalAdapterView_shouldTrackVisibility() {
+        View view = subject.getView(AD_POSITION + 1, null, null);
+
+        assertThat(view).isNotEqualTo(mockAdView);
+
+        verify(mockVisibilityTracker).addView(any(View.class), anyInt());
+    }
+
+    @Test
+    public void getItemViewType_withAdPosition_shouldReturnOneGreaterThanViewType() {
+        originalItemViewType = 0;
+
+        int itemViewType = subject.getItemViewType(AD_POSITION);
+        assertThat(itemViewType).isEqualTo(originalItemViewType + 1);
+    }
+
+    @Test
+    public void getItemViewType_withNonAdPosition_shouldUseOriginalAdapterId() {
+        originalItemViewType = 0;
+
+        int itemViewType = subject.getItemViewType(AD_POSITION + 1);
+        assertThat(itemViewType).isEqualTo(originalItemViewType);
+    }
+
+    @Test
+    public void getViewTypeCount_shouldReturnOriginalViewTypeCountPlusOne() {
+        originalViewTypeCount = 1;
+
+        int viewTypeCount = subject.getViewTypeCount();
+        assertThat(viewTypeCount).isEqualTo(1);
+
+        originalViewTypeCount = 2;
+
+        viewTypeCount = subject.getViewTypeCount();
+        assertThat(viewTypeCount).isEqualTo(2);
+    }
+
+    @Test
+    public void isEmpty_shouldUseOriginalAdapterValue() {
+        boolean isEmpty = subject.isEmpty();
+
+        assertThat(isEmpty).isFalse();
+
+        originalAdapter.clear();
+
+        isEmpty = subject.isEmpty();
+
+        assertThat(isEmpty).isTrue();
+    }
+
+    @Test
+    public void getOriginalPosition_shouldCallStreamAdPlacer() {
+        subject.getOriginalPosition(5);
+
+        verify(mockStreamAdPlacer).getOriginalPosition(5);
+    }
+
+    @Test
+    public void getAdjustedPosition_shouldCallStreamAdPlacer() {
+        subject.getAdjustedPosition(5);
+
+        verify(mockStreamAdPlacer).getAdjustedPosition(5);
+    }
+
+    @Test
+    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() {
         subject.insertItem(5);
+
         verify(mockStreamAdPlacer).insertItem(5);
     }
 
     @Test
-    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() throws Exception {
+    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() {
         subject.removeItem(5);
+
         verify(mockStreamAdPlacer).removeItem(5);
     }
 
     @Test
-    public void getOriginalPosition_shouldCallGetOriginalPositionOnStreamAdPlacer() throws Exception {
-        subject.getOriginalPosition(5);
-        verify(mockStreamAdPlacer).getOriginalPosition(5);
+    public void setOnItemClickListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnClickListener(mockListView, mockOnItemClickListener);
+
+        ArgumentCaptor<OnItemClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemClickListener.class);
+        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
+
+        OnItemClickListener listener = listenerCaptor.getValue();
+        listener.onItemClick(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemClickListener, never()).onItemClick(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemClickListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnClickListener(mockListView, mockOnItemClickListener);
+
+        ArgumentCaptor<OnItemClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemClickListener.class);
+        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
+
+        OnItemClickListener listener = listenerCaptor.getValue();
+        listener.onItemClick(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemClickListener).onItemClick(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setOnItemLongClickListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
+
+        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemLongClickListener.class);
+        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
+
+        OnItemLongClickListener listener = listenerCaptor.getValue();
+        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemLongClickListener, never()).onItemLongClick(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemLongClickListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
+
+        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemLongClickListener.class);
+        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
+
+        OnItemLongClickListener listener = listenerCaptor.getValue();
+        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemLongClickListener).onItemLongClick(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setOnItemSelectedListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
+
+        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemSelectedListener.class);
+        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
+
+        OnItemSelectedListener listener = listenerCaptor.getValue();
+        listener.onItemSelected(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemSelectedListener, never()).onItemSelected(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemSelectedListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
+
+        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemSelectedListener.class);
+        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
+
+        OnItemSelectedListener listener = listenerCaptor.getValue();
+        listener.onItemSelected(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemSelectedListener).onItemSelected(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setSelection_shouldCallSetSelectionOnListView() {
+        subject.setSelection(mockListView, AD_POSITION);
+
+        // Since the original position is the ad position, the adjusted position is 1 higher
+        verify(mockListView).setSelection(AD_POSITION + 1);
+    }
+
+    @Test
+    public void smoothScrollToPosition_shouldCallSmoothScrollToPositionOnListView() {
+        subject.smoothScrollToPosition(mockListView, AD_POSITION);
+
+        // Since the original position is the ad position, the adjusted position is 1 higher
+        verify(mockListView).smoothScrollToPosition(AD_POSITION + 1);
+    }
+
+    @Test
+    public void refreshAds_shouldLoadAdsOnAdPlacer() {
+        when(mockListView.getAdapter()).thenReturn(subject);
+
+        subject.refreshAds(mockListView, "AD_UNIT_ID", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
     }
-}
\ No newline at end of file
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
index cce90d4e..1f117225 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
@@ -1,19 +1,17 @@
 package com.mopub.nativeads;
 
 import com.mopub.common.Preconditions.NoThrow;
-import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
 import org.fest.util.Lists;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT;
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class MoPubClientPositioningTest {
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
index 9f67e204..361e8fce 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.json.JSONArray;
@@ -45,7 +46,7 @@ public void setUp() throws Exception {
         fakeJsonObject.put("iconimage", "iconimageurl");
         fakeJsonObject.put("extraimage", "extraimageurl");
 
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, fakeJsonObject.toString());
+        localExtras.put(DataKeys.JSON_BODY_KEY, fakeJsonObject);
 
         mCustomEventNativeListener = mock(CustomEventNativeListener.class);
     }
@@ -55,21 +56,12 @@ public void tearDown() throws Exception {
         reset(mCustomEventNativeListener);
     }
 
-    @Test
-    public void loadNativeAd_withInvalidResponseBody_shouldNotifyListenerOfOnNativeAdFailed() throws Exception {
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, "{ \"bad json");
-
-        subject.loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
-        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(MoPubCustomEventNative.MoPubForwardingNativeAd.class));
-        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_JSON);
-    }
-
     @Test
     public void loadNativeAd_withNullResponseBody_shouldNotifyListenerOfOnNativeAdFailed() throws Exception {
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, null);
+        localExtras.remove(DataKeys.JSON_BODY_KEY);
 
         subject.loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(MoPubCustomEventNative.MoPubForwardingNativeAd.class));
-        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_JSON);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
index 7ae673b8..668842d0 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
@@ -1,24 +1,26 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.graphics.Bitmap;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.CommonUtils;
 import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.nativeads.test.support.MoPubShadowDisplay;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
-import org.apache.http.HttpRequest;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -28,12 +30,17 @@
 
 import static com.mopub.nativeads.NativeResponse.Parameter;
 import static com.mopub.nativeads.NativeResponse.Parameter.requiredKeys;
+import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 @Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
@@ -42,27 +49,25 @@
     private JSONObject fakeJsonObject;
     private MoPubCustomEventNative.MoPubForwardingNativeAd subject;
     private Activity context;
+
+    @Mock
     private CustomEventNative.CustomEventNativeListener mockCustomEventNativeListener;
-    private FakeHttpLayer fakeHttpLayer;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
 
     @Before
     public void setUp() throws Exception {
         context = new Activity();
-        mockCustomEventNativeListener = mock(CustomEventNative.CustomEventNativeListener.class);
         fakeJsonObject = new JSONObject();
         fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
         fakeJsonObject.put("clktracker", "expected clicktracker");
-
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addHttpResponseRule(
-                new RequestMatcher() {
-                    @Override
-                    public boolean matches(HttpRequest request) {
-                        return true;
-                    }
-                },
-                new TestHttpResponse(200, "body")
-        );
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
     }
 
     @Test
@@ -93,7 +98,7 @@ public void loadAd_whenMissingRequiredKeys_shouldThrowIllegalArgumentException()
         fakeJsonObject.remove("imptracker");
 
         try {
-            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
             subject.loadAd();
             fail("Expected IllegalArgumentException");
         } catch (IllegalArgumentException e) {
@@ -106,7 +111,7 @@ public void loadAd_whenRequiredKeyOfWrongType_shouldThrowIllegalArgumentExceptio
         fakeJsonObject.put("imptracker", 12345);
 
         try {
-            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
             subject.loadAd();
             fail("Expected IllegalArgumentException");
         } catch (IllegalArgumentException e) {
@@ -116,7 +121,7 @@ public void loadAd_whenRequiredKeyOfWrongType_shouldThrowIllegalArgumentExceptio
 
     @Test
     public void loadAd_shouldSetRequiredExpectedFields() throws Exception {
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
     }
@@ -134,7 +139,7 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
         fakeJsonObject.put("ctatext", "expected ctatext");
         fakeJsonObject.put("starrating", 5.0);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getTitle()).isEqualTo("expected title");
@@ -154,7 +159,7 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
     public void loadAd_withIntegerStarRating_shouldSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", 3);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isEqualTo(3.0);
@@ -164,7 +169,7 @@ public void loadAd_withIntegerStarRating_shouldSetStarRating() throws Exception
     public void loadAd_withStringStarRating_shouldSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", "2.3");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isEqualTo(2.3);
@@ -174,7 +179,7 @@ public void loadAd_withStringStarRating_shouldSetStarRating() throws Exception {
     public void loadAd_withInvalidStringStarRating_shouldNotSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", "this is not a number");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isNull();
@@ -184,7 +189,7 @@ public void loadAd_withInvalidStringStarRating_shouldNotSetStarRating() throws E
     public void loadAd_withInvalidlyTypedStarRating_shouldNotSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", new Activity());
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isNull();
@@ -202,7 +207,7 @@ public void loadAd_whenImpressionTrackersContainsNonStrings_willCoerceToString()
         impressionTrackers.put(2.12);
         fakeJsonObject.put("imptracker", impressionTrackers);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "null", "2.12");
@@ -223,7 +228,7 @@ public void loadAd_shouldSetExtraFields() throws Exception {
         fakeJsonObject.put("key3", new JSONArray(array));
         fakeJsonObject.put("key4", new JSONObject(map));
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtra("key1")).isEqualTo("yay json");
@@ -238,10 +243,22 @@ public void loadAd_shouldDownloadImages_shouldNotifyListenerOfOnNativeAdLoaded()
         fakeJsonObject.put("iconimage", "iconimageurl");
         fakeJsonObject.put("extraimage", "extraimageurl");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
+                        listener.onResponse(mockImageContainer, false);
+                        return null;
+                    }
+                });
+
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
-        CommonUtils.assertHttpRequestsMade(null, "mainimageurl", "iconimageurl", "extraimageurl");
+        verify(mockImageLoader).get(eq("mainimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("iconimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("extraimageurl"), any(ImageListener.class));
 
         verify(mockCustomEventNativeListener).onNativeAdLoaded(subject);
         verify(mockCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
@@ -253,23 +270,23 @@ public void loadAd_withFailedImageDownload_shouldNotDownloadImages_shouldNotifyL
         fakeJsonObject.put("iconimage", "iconimageurl");
         fakeJsonObject.put("extraimage", "extraimageurl");
 
-        fakeHttpLayer.clearHttpResponseRules();
-        fakeHttpLayer.addPendingHttpResponse(500, "body");
+        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
+                        listener.onErrorResponse(new VolleyError());
+                        return null;
+                    }
+                });
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(subject);
         verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
     }
 
-    @Ignore("pending")
-    @Test
-    public void loadMainAndIconImages_shouldAsyncLoadImages() throws Exception {
-        // no easy way to test this since nothing can be mocked
-        // also not a critical test since it directly calls another service
-    }
-
     @Test
     public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls() throws Exception {
         // getExtrasImageUrls requires the key to end with a case-insensitive "image" to be counted as an image
@@ -278,7 +295,7 @@ public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls()
         fakeJsonObject.put("otherIMAGE", "image_url_2");
         fakeJsonObject.put("more filler", "ignored");
         fakeJsonObject.put("lastimage", "image_url_3");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtrasImageUrls()).containsOnly("image_url_1", "image_url_2", "image_url_3");
@@ -291,7 +308,7 @@ public void getExtrasImageUrls_whenExtrasDoesNotContainImageKeys_shouldReturnEmp
         fakeJsonObject.put("imageAtFront", "ignored");
         fakeJsonObject.put("middle_image_in_key", "ignored");
         fakeJsonObject.put("other", "ignored");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtrasImageUrls()).isEmpty();
@@ -302,7 +319,7 @@ public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldReturnAllU
         fakeJsonObject.put("mainimage", "mainImageUrl");
         fakeJsonObject.put("iconimage", "iconImageUrl");
         fakeJsonObject.put("extraimage", "extraImageUrl");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getAllImageUrls()).containsOnly(
@@ -316,7 +333,7 @@ public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldReturnAllU
     public void getAllImageUrls_withOnlyExtrasImages_shouldNotIncludeMainOrIconImages() throws Exception {
         fakeJsonObject.put("extra1_image", "expected extra1_image");
         fakeJsonObject.put("extra2_image", "expected extra2_image");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getAllImageUrls()).containsOnly("expected extra1_image", "expected extra2_image");
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
index 0bcebf6d..70a139c0 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
@@ -8,30 +8,25 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.DownloadResponse;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
 @RunWith(SdkTestRunner.class)
 public class MoPubNativeAdRendererTest {
     private MoPubNativeAdRenderer subject;
-    private Activity context;
     private RelativeLayout relativeLayout;
     private ViewGroup viewGroup;
     private NativeResponse nativeResponse;
-    private BaseForwardingNativeAd mNativeAd;
     private ViewBinder viewBinder;
     private TextView titleView;
     private TextView textView;
@@ -42,21 +37,22 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        Activity context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
 
-        mNativeAd = new BaseForwardingNativeAd() {};
-        mNativeAd.setTitle("test title");
-        mNativeAd.setText("test text");
-        mNativeAd.setCallToAction("test call to action");
-        mNativeAd.setClickDestinationUrl("destinationUrl");
+        BaseForwardingNativeAd baseForwardingNativeAd = new BaseForwardingNativeAd() {};
+        baseForwardingNativeAd.setTitle("test title");
+        baseForwardingNativeAd.setText("test text");
+        baseForwardingNativeAd.setCallToAction("test call to action");
+        baseForwardingNativeAd.setClickDestinationUrl("destinationUrl");
 
-        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "clickTrackerUrl");
-        final DownloadResponse downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
-        nativeResponse = new NativeResponse(context, downloadResponse, "test ID", mNativeAd, mock(MoPubNativeListener.class));
+        nativeResponse = new NativeResponse(context,
+                "impressionTrackerUrl",
+                "clickTrackerUrl",
+                "test ID", baseForwardingNativeAd,
+                mock(MoPubNative.MoPubNativeListener.class));
 
         titleView = new TextView(context);
         titleView.setId((int) Utils.generateUniqueId());
@@ -105,6 +101,8 @@ public void renderAdView_withNullNativeResponse_shouldThrowNPE() {
     }
 
     @Rule public ExpectedException exception = ExpectedException.none();
+
+    @Test
     public void renderAdView_withNullViewBinder_shouldThrowNPE() {
         subject = new MoPubNativeAdRenderer(null);
 
@@ -125,7 +123,7 @@ public void renderAdView_shouldReturnPopulatedView() {
     }
 
     @Test
-    public void renderAdView_withFailedViewBinder_shouldReturnFast() {
+    public void renderAdView_withFailedViewBinder_shouldReturnEmptyViews() {
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
                 .textId(badView.getId())
@@ -137,30 +135,31 @@ public void renderAdView_withFailedViewBinder_shouldReturnFast() {
         subject = new MoPubNativeAdRenderer(viewBinder);
         subject.renderAdView(relativeLayout, nativeResponse);
 
-        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("");
-        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
-                "");
-        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo(
-                "");
+        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText())
+                .isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText())
+                .isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText())
+                .isEqualTo("");
     }
 
     @Test
-    public void getOrCreateNativeViewHolder_withNoViewHolder_shouldCreateNativeViewHolder() {
-        final NativeViewHolder viewHolder =
-                subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, nativeResponse);
 
-        final NativeViewHolder expectedViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        NativeViewHolder expectedViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
         compareNativeViewHolders(expectedViewHolder, viewHolder);
     }
 
     @Test
     public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
-        final NativeViewHolder viewHolder =
-                subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+        subject.renderAdView(relativeLayout, nativeResponse);
+        NativeViewHolder expectedViewHolder = subject.mViewHolderMap.get(relativeLayout);
+        subject.renderAdView(relativeLayout, nativeResponse);
 
-        assertThat(subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder))
-                .isEqualTo(viewHolder);
+        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
+        assertThat(viewHolder).isEqualTo(expectedViewHolder);
     }
 
     static private void compareNativeViewHolders(final NativeViewHolder actualViewHolder,
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
index ad2d8969..a29e19ee 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -1,19 +1,23 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
-import com.mopub.common.SharedPreferencesHelper;
+
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
 import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
-import org.apache.http.client.methods.HttpGet;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -21,19 +25,23 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
-import java.util.*;
-import java.util.concurrent.*;
+import java.net.MalformedURLException;
+import java.util.List;
+import java.util.concurrent.Semaphore;
+import java.util.logging.Level;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static com.mopub.common.util.Reflection.MethodBuilder;
 import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
 import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
@@ -46,30 +54,24 @@
     private MoPubNative subject;
     private MethodBuilder methodBuilder;
     private Activity context;
-    private MoPubNative.NativeGpsHelperListener nativeGpsHelperListener;
     private Semaphore semaphore;
     private static final String adUnitId = "test_adunit_id";
-    
+
     @Mock private MoPubNativeEventListener mockEventListener;
 
     @Mock private MoPubNativeNetworkListener mockNetworkListener;
-    
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
         shadowOf(context).grantPermissions(INTERNET);
         subject = new MoPubNative(context, adUnitId, mockNetworkListener);
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        nativeGpsHelperListener = mock(MoPubNative.NativeGpsHelperListener.class);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
         semaphore = new Semaphore(0);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(nativeGpsHelperListener).onFetchAdInfoCompleted();
     }
 
     @After
@@ -77,87 +79,6 @@ public void tearDown() {
         reset(methodBuilder);
     }
 
-    @Ignore("fix concurrency issues")
-    @Test
-    public void
-    makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
-        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-
-        GpsHelper.setClassNamesForTesting();
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.ADVERTISING_ID,
-                adInfo.LIMIT_AD_TRACKING_ENABLED
-        );
-
-        subject.makeRequest(nativeGpsHelperListener);
-        semaphore.acquire();
-
-        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void makeRequest_whenGooglePlayServicesIsNotLinked_shouldFetchAdFast() throws Exception {
-        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-
-        // return error code so it fails
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-
-        subject.makeRequest(nativeGpsHelperListener);
-        // no need to sleep since it run the callback without an async task
-
-        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-    }
-
-    @Test
-    public void makeRequest_whenGooglePlayServicesIsNotLinked_withNullContext_shouldReturnFast() throws Exception {
-        subject.destroy();
-
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-
-        // return error code so it fails
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-
-        subject.makeRequest(nativeGpsHelperListener);
-        // no need to sleep since it run the callback without an async task
-
-        verify(nativeGpsHelperListener, never()).onFetchAdInfoCompleted();
-    }
-
-    @Test
-    public void makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFetchAdFast() throws Exception {
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        GpsHelperTest.populateAndVerifyClientMetadata(context, adInfo);
-        GpsHelper.setClassNamesForTesting();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
-        );
-
-        subject.makeRequest(nativeGpsHelperListener);
-        // no need to sleep since it run the callback without an async task
-
-        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
-    }
-
     @Test
     public void destroy_shouldSetListenersToEmptyAndClearContext() {
         assertThat(subject.getContextOrDestroy()).isSameAs(context);
@@ -182,64 +103,91 @@ public void setNativeEventListener_shouldSetListener() {
         assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
     }
 
-    @Ignore("pending")
-    @Test
-    public void loadNativeAd_shouldQueueAsyncDownloadTask() {
-        Robolectric.getUiThreadScheduler().pause();
-
-        subject.loadNativeAd(null);
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-    }
-
     @Test
     public void loadNativeAd_shouldReturnFast() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.destroy();
-        subject.loadNativeAd(null);
+        subject.makeRequest();
 
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
     }
 
     @Test
-    public void requestNativeAd_withValidUrl_shouldStartDownloadTaskWithUrl() {
-        Robolectric.getUiThreadScheduler().pause();
-        Robolectric.addPendingHttpResponse(200, "body");
+    public void requestNativeAd_shouldFireNetworkRequest() {
 
         subject.requestNativeAd("http://www.mopub.com");
 
         verify(mockNetworkListener, never()).onNativeFail(any(NativeErrorCode.class));
-        assertThat(wasDownloadTaskExecuted()).isTrue();
-
-        List<?> latestParams = ShadowAsyncTasks.getLatestParams();
-        assertThat(latestParams).hasSize(1);
-        HttpGet httpGet = (HttpGet) latestParams.get(0);
-        assertThat(httpGet.getURI().toString()).isEqualTo("http://www.mopub.com");
+        verify(mockRequestQueue).add(argThat(isUrl("http://www.mopub.com")));
     }
 
     @Test
-    public void requestNativeAd_withInvalidUrl_shouldFireNativeFailAndNotStartAsyncTask() {
-        Robolectric.getUiThreadScheduler().pause();
-
+    public void requestNativeAd_whenReqeustQueueDeliversUnknownError_shouldFireNativeFail() {
+
+        when(mockRequestQueue.add(any(Request.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ((Request) invocationOnMock.getArguments()[0]).deliverError(new VolleyError(new MalformedURLException()));
+                        return null;
+                    }
+                });
         subject.requestNativeAd("//\\//\\::::");
 
         verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
-        assertThat(wasDownloadTaskExecuted()).isFalse();
     }
 
     @Test
-    public void requestNativeAd_withNullUrl_shouldFireNativeFailAndNotStartAsyncTask() {
+    public void requestNativeAd_withNullUrl_shouldFireNativeFail() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.requestNativeAd(null);
 
         verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
-        assertThat(wasDownloadTaskExecuted()).isFalse();
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
-    private boolean wasDownloadTaskExecuted() {
-        return ShadowAsyncTasks.wasCalled() &&
-                (ShadowAsyncTasks.getLatestAsyncTask() instanceof DownloadTask);
+    @Test
+    public void onAdError_shouldNotifyListener() {
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.BAD_BODY));
+
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.INVALID_JSON));
+    }
+
+    @Test
+    public void onAdError_whenNotMoPubError_shouldNotifyListener() {
+        subject.onAdError(new VolleyError("generic"));
+
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.UNSPECIFIED));
+    }
+
+    @Test
+    public void onAdError_withVolleyErrorWarmingUp_shouldLogMoPubErrorCodeWarmup_shouldNotifyListener() {
+        MoPubLog.setSdkHandlerLevel(Level.ALL);
+
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP));
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.WARMUP.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.EMPTY_AD_RESPONSE));
+    }
+
+    @Test
+    public void onAdError_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldNotifyListener() {
+        MoPubLog.setSdkHandlerLevel(Level.ALL);
+        shadowOf(context).denyPermissions(INTERNET);
+
+        subject.onAdError(new NoConnectionError());
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.CONNECTION_ERROR));
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java
new file mode 100644
index 00000000..5bf340ed
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java
@@ -0,0 +1,697 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy.INSERT_AT_END;
+import static com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy.KEEP_ADS_FIXED;
+import static com.mopub.nativeads.MoPubRecyclerAdapter.ContentChangeStrategy.MOVE_ALL_ADS_WITH_CONTENT;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubRecyclerAdapterTest {
+    private static final int AD_POSITION_1 = 1;
+    private static final int AD_POSITION_7 = 7;
+
+    @Mock MoPubStreamAdPlacer mockStreamAdPlacer;
+    @Mock VisibilityTracker mockVisibilityTracker;
+    @Mock NativeAdData mockNativeAdData;
+    @Mock NativeAdData mockNativeAdData2;
+    @Mock MoPubAdRenderer mockAdRenderer;
+    @Mock ViewGroup mockParent;
+    @Mock View mockAdView;
+    @Mock RecyclerView.AdapterDataObserver mockObserver;
+    @Mock MoPubNativeAdLoadedListener mockAdLoadedListener;
+    MoPubRecyclerViewHolder spyViewHolder;
+    @Mock TestHolder mockTestHolder;
+    TestAdapter originalAdapter;
+
+    MoPubRecyclerAdapter subject;
+
+    @Mock RecyclerView mockRecyclerView;
+    @Mock LinearLayoutManager mockLayoutManager;
+
+    @Before
+    public void setUp() throws Exception {
+        originalAdapter = spy(new TestAdapter());
+        subject = new MoPubRecyclerAdapter(mockStreamAdPlacer, originalAdapter, mockVisibilityTracker);
+
+        spyViewHolder = spy(new MoPubRecyclerViewHolder(mockAdView));
+
+        // Reset because the constructor interacts with the stream ad placer, and we don't want
+        // to worry about verifying those changes in tests.
+        reset(mockStreamAdPlacer);
+        reset(originalAdapter);
+
+        // Mock some simple adjustment behavior for tests. This is creating an ad placer that
+        // emulates a content item followed by an ad item, then another content item.
+        when(mockStreamAdPlacer.getAdData(AD_POSITION_1)).thenReturn(mockNativeAdData);
+        when(mockStreamAdPlacer.getAdData(AD_POSITION_7)).thenReturn(mockNativeAdData2);
+        when(mockStreamAdPlacer.getAdRendererForViewType(MoPubRecyclerAdapter.NATIVE_AD_VIEW_TYPE_BASE))
+                .thenReturn(mockAdRenderer);
+        when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class))).thenReturn(mockAdView);
+
+        when(mockStreamAdPlacer.isAd(anyInt())).thenAnswer(new Answer<Boolean>() {
+            @Override
+            public Boolean answer(final InvocationOnMock invocation) throws Throwable {
+                int position = (Integer) invocation.getArguments()[0];
+                return position == AD_POSITION_1 || position == AD_POSITION_7;
+            }
+        });
+        when(mockStreamAdPlacer.getOriginalPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                final int adjusted = (Integer) invocation.getArguments()[0];
+                int original;
+                if (adjusted < AD_POSITION_1) {
+                    original = adjusted;
+                } else if (adjusted >= AD_POSITION_7) {
+                    original = adjusted - 2;
+                } else {
+                    original = adjusted - 1;
+                }
+                return original;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                final int originalPosition = (Integer) invocation.getArguments()[0];
+                int adjusted;
+                if (originalPosition < AD_POSITION_1) {
+                    adjusted = originalPosition;
+                } else if (originalPosition > AD_POSITION_7) {
+                    adjusted = originalPosition + 2;
+                } else {
+                    adjusted = originalPosition + 1;
+                }
+                return adjusted;
+            }
+        });
+        when(mockStreamAdPlacer.getAdViewType(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                final int originalPosition = (Integer) invocation.getArguments()[0];
+                return (originalPosition == AD_POSITION_1 || originalPosition == AD_POSITION_7)
+                        ? 1 : MoPubStreamAdPlacer.CONTENT_VIEW_TYPE;
+            }
+        });
+
+        when(mockStreamAdPlacer.getAdjustedCount(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                final int originalItemCount = (Integer) invocation.getArguments()[0];
+                int adjusted;
+                if (originalItemCount < AD_POSITION_1) {
+                    adjusted = originalItemCount;
+                } else if (originalItemCount > AD_POSITION_7) {
+                    adjusted = originalItemCount + 2;
+                } else {
+                    adjusted = originalItemCount + 1;
+                }
+                return adjusted;
+            }
+        });
+    }
+
+    @Test
+    public void computeScrollOffset_withScrollVerticallyNoStackFromEnd_shouldComputeTopOffset() {
+        when(mockAdView.getTop()).thenReturn(13);
+        when(mockAdView.getBottom()).thenReturn(14);
+        when(mockAdView.getLeft()).thenReturn(10);
+        when(mockAdView.getRight()).thenReturn(11);
+        when(mockLayoutManager.canScrollVertically()).thenReturn(true);
+        when(mockLayoutManager.canScrollHorizontally()).thenReturn(false);
+        when(mockLayoutManager.getStackFromEnd()).thenReturn(false);
+
+        int offset = MoPubRecyclerAdapter.computeScrollOffset(mockLayoutManager, spyViewHolder);
+        assertThat(offset).isEqualTo(13);
+    }
+
+    @Test
+    public void computeScrollOffset_withScrollVerticallyStackFromEnd_shouldComputeBottomOffset() {
+        when(mockAdView.getTop()).thenReturn(13);
+        when(mockAdView.getBottom()).thenReturn(14);
+        when(mockAdView.getLeft()).thenReturn(10);
+        when(mockAdView.getRight()).thenReturn(11);
+        when(mockLayoutManager.canScrollVertically()).thenReturn(true);
+        when(mockLayoutManager.canScrollHorizontally()).thenReturn(false);
+        when(mockLayoutManager.getStackFromEnd()).thenReturn(true);
+
+        int offset = MoPubRecyclerAdapter.computeScrollOffset(mockLayoutManager, spyViewHolder);
+        assertThat(offset).isEqualTo(14);
+    }
+
+    @Test
+    public void computeScrollOffset_withScrollHorizontallyStackFromEnd_shouldComputeLeftOffset() {
+        when(mockAdView.getTop()).thenReturn(13);
+        when(mockAdView.getBottom()).thenReturn(14);
+        when(mockAdView.getLeft()).thenReturn(10);
+        when(mockAdView.getRight()).thenReturn(11);
+        when(mockLayoutManager.canScrollVertically()).thenReturn(false);
+        when(mockLayoutManager.canScrollHorizontally()).thenReturn(true);
+        when(mockLayoutManager.getStackFromEnd()).thenReturn(false);
+
+        int offset = MoPubRecyclerAdapter.computeScrollOffset(mockLayoutManager, spyViewHolder);
+        assertThat(offset).isEqualTo(10);
+    }
+
+    @Test
+    public void computeScrollOffset_withScrollHorizontallyNoStackFromEnd_shouldComputeRightOffset() {
+        when(mockAdView.getTop()).thenReturn(13);
+        when(mockAdView.getBottom()).thenReturn(14);
+        when(mockAdView.getLeft()).thenReturn(10);
+        when(mockAdView.getRight()).thenReturn(11);
+
+        when(mockLayoutManager.canScrollVertically()).thenReturn(false);
+        when(mockLayoutManager.canScrollHorizontally()).thenReturn(true);
+        when(mockLayoutManager.getStackFromEnd()).thenReturn(true);
+
+        int offset = MoPubRecyclerAdapter.computeScrollOffset(mockLayoutManager, spyViewHolder);
+        assertThat(offset).isEqualTo(11);
+    }
+
+    @Test
+    public void computeScrollOffset_withCannotScroll_shouldReturnZero() {
+        when(mockLayoutManager.canScrollHorizontally()).thenReturn(false);
+        when(mockLayoutManager.canScrollVertically()).thenReturn(false);
+
+        int offset = MoPubRecyclerAdapter.computeScrollOffset(mockLayoutManager, spyViewHolder);
+        assertThat(offset).isEqualTo(0);
+    }
+
+    @Test
+    public void registerViewBinder_shouldCallRegisterAdRendererOnStreamAdPlacer() {
+        subject.registerViewBinder(new ViewBinder.Builder(1).build());
+
+        final ArgumentCaptor<MoPubAdRenderer> rendererCaptor = ArgumentCaptor.forClass(MoPubAdRenderer.class);
+        verify(mockStreamAdPlacer).registerAdRenderer(rendererCaptor.capture(), eq(-55));
+        MoPubAdRenderer renderer = rendererCaptor.getValue();
+        assertThat(renderer).isExactlyInstanceOf(MoPubNativeAdRenderer.class);
+    }
+
+    @Test
+    public void onCreateViewHolder_whenAdType_shouldInflateAdView() {
+        final RecyclerView.ViewHolder result = subject.onCreateViewHolder(mockParent, MoPubRecyclerAdapter.NATIVE_AD_VIEW_TYPE_BASE);
+
+        assertThat(result).isExactlyInstanceOf(MoPubRecyclerViewHolder.class);
+
+        verify(mockStreamAdPlacer).getAdRendererForViewType(MoPubRecyclerAdapter.NATIVE_AD_VIEW_TYPE_BASE);
+        verifyZeroInteractions(originalAdapter);
+    }
+
+    @Test
+    public void onCreateViewHolder_whenNotAdType_shouldCallOriginalAdapter() {
+        when(mockParent.getContext()).thenReturn(mock(Context.class));
+
+        subject.onCreateViewHolder(mockParent, 3);
+
+        verify(originalAdapter).onCreateViewHolder(mockParent, 3);
+        verify(mockStreamAdPlacer, never()).getAdRendererForViewType(anyInt());
+    }
+
+    @Test
+    public void onBindViewHolder_whenAdPosition_shouldGetAndBindAdData() {
+        subject.onBindViewHolder(spyViewHolder, AD_POSITION_1);
+
+        verify(mockStreamAdPlacer).bindAdView(mockNativeAdData, mockAdView);
+    }
+
+    @Test
+    public void onBindViewHolder_whenNotAdPosition_shouldCallOriginalAdapter() {
+        subject.onBindViewHolder(mockTestHolder, AD_POSITION_1 + 1);
+
+        // Position should be adjusted.
+        verify(originalAdapter).onBindViewHolder(mockTestHolder, AD_POSITION_1);
+    }
+
+    @Test
+    public void onViewAttached_whenMoPubViewHolder_shouldNotCallOriginalAdapter() {
+        subject.onViewAttachedToWindow(spyViewHolder);
+
+        verify(originalAdapter, never()).onViewAttachedToWindow(any(TestHolder.class));
+        verifyZeroInteractions(originalAdapter);
+    }
+
+    @Test
+    public void onViewAttached_whenNotMoPubViewHolder_shouldCallOriginalAdapter() {
+        subject.onViewAttachedToWindow(mockTestHolder);
+
+        verify(originalAdapter).onViewAttachedToWindow(mockTestHolder);
+    }
+
+    @Test
+    public void onViewDetached_whenMoPubViewHolder_shouldNotCallOriginalAdapter() {
+        subject.onViewDetachedFromWindow(spyViewHolder);
+
+        verifyZeroInteractions(originalAdapter);
+    }
+
+    @Test
+    public void onViewDetached_whenNotMoPubViewHolder_shouldCallOriginalAdapter() {
+        subject.onViewDetachedFromWindow(mockTestHolder);
+
+        verify(originalAdapter).onViewDetachedFromWindow(mockTestHolder);
+    }
+
+    @Test
+    public void onFailedToRecycleView_whenMoPubViewHolder_shouldNotCallOriginalAdapter() {
+        assertThat(subject.onFailedToRecycleView(spyViewHolder)).isFalse();
+
+        verifyZeroInteractions(originalAdapter);
+    }
+
+    @Test
+    public void onFailedToRecycleView_whenNotMoPubViewHolder_shouldCallOriginalAdapter() {
+        when(originalAdapter.onFailedToRecycleView(mockTestHolder)).thenReturn(true);
+
+        assertThat(subject.onFailedToRecycleView(mockTestHolder)).isTrue();
+
+        verify(originalAdapter).onFailedToRecycleView(mockTestHolder);
+    }
+
+    @Test
+    public void onViewRecycled_whenMoPubViewHolder_shouldNotCallOriginalAdapter() {
+        subject.onViewRecycled(spyViewHolder);
+
+        verifyZeroInteractions(originalAdapter);
+    }
+
+    @Test
+    public void onViewRecycled_whenNotMoPubViewHolder_shouldCallOriginalAdapter() {
+        subject.onViewRecycled(mockTestHolder);
+
+        verify(originalAdapter).onViewRecycled(mockTestHolder);
+    }
+
+    @Test
+    public void handleAdLoaded_withAndWithoutAdLoadedListener_shouldNotifyInsertToListener() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setAdLoadedListener(mockAdLoadedListener);
+        subject.handleAdLoaded(8);
+
+        verify(mockObserver).onItemRangeInserted(8, 1);
+        verify(mockAdLoadedListener).onAdLoaded(8);
+        reset(mockObserver, mockAdLoadedListener);
+
+        subject.setAdLoadedListener(null);
+        subject.handleAdLoaded(8);
+
+        verify(mockObserver).onItemRangeInserted(8, 1);
+        verifyZeroInteractions(mockAdLoadedListener);
+    }
+
+    @Test
+    public void handleAdRemoved_withAndWithoutAdLoadedListener_shouldNotifyDeleteToListener() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setAdLoadedListener(mockAdLoadedListener);
+        subject.handleAdRemoved(AD_POSITION_1);
+
+        verify(mockObserver).onItemRangeRemoved(AD_POSITION_1, 1);
+        verify(mockAdLoadedListener).onAdRemoved(AD_POSITION_1);
+        reset(mockObserver, mockAdLoadedListener);
+
+        subject.setAdLoadedListener(null);
+        subject.handleAdRemoved(AD_POSITION_1);
+
+        verify(mockObserver).onItemRangeRemoved(AD_POSITION_1, 1);
+        verifyZeroInteractions(mockAdLoadedListener);
+    }
+
+    @Test
+    public void loadAds_shouldCallLoadOnAdPlacer() {
+        subject.loadAds("testId");
+
+        verify(mockStreamAdPlacer).loadAds("testId");
+    }
+
+    @Test
+    public void loadAds_withParameters_shouldCallLoadOnAdPlacer() {
+        final RequestParameters mockRequestParameters = mock(RequestParameters.class);
+        subject.loadAds("testId", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("testId", mockRequestParameters);
+    }
+
+    @Test
+    public void isAd_shouldCallIsAdOnAdPlacer() {
+        boolean isAd = subject.isAd(4);
+
+        assertThat(isAd).isFalse();
+        verify(mockStreamAdPlacer).isAd(4);
+
+
+        isAd = subject.isAd(AD_POSITION_1);
+
+        assertThat(isAd).isTrue();
+        verify(mockStreamAdPlacer).isAd(AD_POSITION_1);
+    }
+
+    @Test
+    public void getAdjustedPosition_shouldCallAdPlacer() {
+        int adjustedPosition = subject.getAdjustedPosition(AD_POSITION_1);
+
+        assertThat(adjustedPosition).isEqualTo(AD_POSITION_1 + 1);
+        verify(mockStreamAdPlacer).getAdjustedPosition(AD_POSITION_1);
+    }
+
+    @Test
+    public void getOriginalPosition_shouldCallAdPlacer() {
+        int originalPosition = subject.getOriginalPosition(AD_POSITION_1 + 1);
+
+        assertThat(originalPosition).isEqualTo(AD_POSITION_1);
+        verify(mockStreamAdPlacer).getOriginalPosition(AD_POSITION_1 + 1);
+    }
+
+    @Test
+    public void getItemCount_shouldCallAdPlacer() {
+        int itemCount = subject.getItemCount();
+
+        assertThat(itemCount).isEqualTo(20);
+        verify(originalAdapter).getItemCount();
+        verify(mockStreamAdPlacer).getAdjustedCount(18);
+    }
+
+    @Test
+    public void setHasStableIds_shouldCallSetHasStableIdsOnOriginal() {
+        subject.setHasStableIds(true);
+
+        verify(originalAdapter).setHasStableIds(true);
+    }
+
+    @Test
+    public void getItemId_hasStableIds_shouldCallOriginalAdapter() {
+        subject.setHasStableIds(true);
+        when(originalAdapter.getItemId(anyInt())).thenAnswer(new Answer<Long>() {
+            @Override
+            public Long answer(final InvocationOnMock invocation) throws Throwable {
+                return Long.valueOf((Integer) invocation.getArguments()[0]);
+            }
+        });
+
+        long itemId = subject.getItemId(5);
+
+        assertThat(itemId).isEqualTo(4l);
+        verify(originalAdapter).getItemId(4); // Adjusted position.
+    }
+
+    @Test
+    public void getItemIds_hasStableIds_shouldReturnEnoughIds() {
+        originalAdapter.setItemCount(5000);
+
+        subject.setHasStableIds(true);
+
+        Set<Long> ids = new HashSet<>(7000, 1.0f);
+        for (int position = 0; position < subject.getItemCount(); position++) {
+            ids.add(subject.getItemId(position));
+        }
+
+        assertThat(ids.size()).isEqualTo(subject.getItemCount());
+        // Verify we called exactly the right # of times on the original adapter.
+        verify(originalAdapter, times(5000)).getItemId(anyInt());
+    }
+
+    @Test
+    public void getItemId_DoesNotHaveStableIds_shouldNotCallOriginalAdapter() {
+        subject.setHasStableIds(false);
+
+        assertThat(subject.getItemId(5)).isEqualTo(RecyclerView.NO_ID);
+        verify(originalAdapter).setHasStableIds(false);
+    }
+
+    @Test
+    public void onItemRangeInsertedAtEnd_withInsertAtEndStrategy_shouldNotifyDataChanged() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(INSERT_AT_END);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount + 3);
+        originalAdapter.notifyItemRangeInserted(originalItemCount, 3);
+
+        verify(mockObserver).onChanged();
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount + 3);
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeInsertedAtEnd_withMoveAdsStrategy_shouldNotifyItemRangeInserted() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(MOVE_ALL_ADS_WITH_CONTENT);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount + 3);
+        originalAdapter.notifyItemRangeInserted(originalItemCount, 3);
+
+        verify(mockObserver).onItemRangeInserted(originalItemCount + 2, 3);
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount + 3);
+        verify(mockStreamAdPlacer, times(3)).insertItem(anyInt());
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeInsertedAtEnd_withKeepAdsPlacedStrategy_shouldNotifyDataChanged() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(KEEP_ADS_FIXED);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount + 3);
+        originalAdapter.notifyItemRangeInserted(originalItemCount, 3);
+
+        verify(mockObserver).onChanged();
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount + 3);
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeInsertedInMiddle_withInsertAtEndStrategy_shouldNotifyItemRangeInserted() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(INSERT_AT_END);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount + 3);
+        originalAdapter.notifyItemRangeInserted(originalItemCount - 7, 3);
+
+        verify(mockObserver).onItemRangeInserted(originalItemCount - 5, 3);
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount - 7);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount + 3);
+        verify(mockStreamAdPlacer, times(3)).insertItem(anyInt());
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeInsertedInMiddle_withMoveAdsStrategy_shouldNotifyItemRangeInserted() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(MOVE_ALL_ADS_WITH_CONTENT);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount + 3);
+        originalAdapter.notifyItemRangeInserted(originalItemCount - 7, 3);
+
+        verify(mockObserver).onItemRangeInserted(originalItemCount - 5, 3);
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount - 7);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount + 3);
+        verify(mockStreamAdPlacer, times(3)).insertItem(anyInt());
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeInsertedInMiddle_withKeepAdsStrategy_shouldNotifyDataChanged() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(KEEP_ADS_FIXED);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount + 3);
+        originalAdapter.notifyItemRangeInserted(originalItemCount - 7, 3);
+
+        verify(mockObserver).onChanged();
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount - 7);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount + 3);
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromEnd_withInsertAtEndStrategy_shouldNotifyDataChanged() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(INSERT_AT_END);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 4, 3);
+
+        verify(mockObserver).onChanged();
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount - 4);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromEnd_withMoveAdsStrategy_shouldNotifyItemRangeRemoved() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(MOVE_ALL_ADS_WITH_CONTENT);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 4, 3);
+
+        verify(mockObserver).onItemRangeRemoved(originalItemCount - 2, 3);
+        verifyNoMoreInteractions(mockObserver);
+
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+        verify(mockStreamAdPlacer, times(3)).removeItem(originalItemCount - 4);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromEnd_withMoveAdsStrategyAndItemsSurroundAnAd_shouldNotifyItemRangeRemoved() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(MOVE_ALL_ADS_WITH_CONTENT);
+        originalAdapter.setItemCount(AD_POSITION_7 + 1);
+
+        final int originalItemCount = AD_POSITION_7 + 1;
+
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 4, 3);
+
+        // We remove 3 items + 1 ad
+        verify(mockObserver).onItemRangeRemoved(originalItemCount - 4, 4);
+        verifyNoMoreInteractions(mockObserver);
+
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+        verify(mockStreamAdPlacer, times(3)).removeItem(originalItemCount - 4);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromEnd_withKeepAdsStrategy_shouldNotifyDataChanged() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(KEEP_ADS_FIXED);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 4, 3);
+
+        verify(mockObserver).onChanged();
+        verifyNoMoreInteractions(mockObserver);
+
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromMiddle_withInsertAtEndStrategy_shouldNotifyItemRangeRemoved() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(INSERT_AT_END);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 8, 3);
+
+        verify(mockObserver).onItemRangeRemoved(originalItemCount - 6, 3);
+        verifyNoMoreInteractions(mockObserver);
+
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+        verify(mockStreamAdPlacer, times(3)).removeItem(originalItemCount - 8);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromMiddle_withMoveAdsStrategy_shouldNotifyItemRangeRemoved() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(MOVE_ALL_ADS_WITH_CONTENT);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 8, 3);
+
+        verify(mockObserver).onItemRangeRemoved(originalItemCount - 6, 3);
+        verifyNoMoreInteractions(mockObserver);
+
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+        verify(mockStreamAdPlacer, times(3)).removeItem(originalItemCount - 8);
+    }
+
+    @Test
+    public void onItemRangeRemovedFromMiddle_withKeepAdsStrategy_shouldNotifyChanged() {
+        subject.registerAdapterDataObserver(mockObserver);
+        subject.setContentChangeStrategy(KEEP_ADS_FIXED);
+
+        final int originalItemCount = originalAdapter.getItemCount();
+        originalAdapter.setItemCount(originalItemCount - 3);
+        originalAdapter.notifyItemRangeRemoved(originalItemCount - 8, 3);
+
+        verify(mockObserver).onChanged();
+        verifyNoMoreInteractions(mockObserver);
+        verify(mockStreamAdPlacer).getAdjustedPosition(originalItemCount - 8);
+        verify(mockStreamAdPlacer).setItemCount(originalItemCount - 3);
+        verifyNoMoreInteractions(mockStreamAdPlacer);
+    }
+
+    private class TestAdapter extends RecyclerView.Adapter<TestHolder> {
+        private int mItems = 18;
+
+        @Override
+        public TestHolder onCreateViewHolder(final ViewGroup parent, final int viewType) {
+            View view = mock(View.class);
+            return new TestHolder(view);
+        }
+
+        @Override
+        public void onBindViewHolder(final TestHolder holder, final int position) {
+            // Do nothing
+        }
+
+        @Override
+        public long getItemId(final int position) {
+            return position;
+        }
+
+        @Override
+        public int getItemCount() {
+            return mItems;
+        }
+
+        void setItemCount(int itemCount) {
+            mItems = itemCount;
+        }
+    }
+
+    private class TestHolder extends RecyclerView.ViewHolder {
+        public TestHolder(final View itemView) {
+            super(itemView);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
index 06f09512..2e772506 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
@@ -7,11 +7,13 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+import com.mopub.nativeads.PositioningSource.PositioningListener;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 
@@ -22,6 +24,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
@@ -52,7 +55,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         positioning = MoPubNativeAdPositioning.clientPositioning()
                 .enableRepeatingPositions(2);
 
@@ -84,6 +87,9 @@ public void isAd_loadAds_withoutLoadingPositions_hasNoAds() {
     @Test
     public void isAd_loadAds_thenLoadPositions_hasAds() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+
         subject.handleAdsAvailable();
         subject.handlePositioningLoad(positioning);
         subject.setItemCount(4);
@@ -93,6 +99,9 @@ public void isAd_loadAds_thenLoadPositions_hasAds() {
     @Test
     public void isAd_loadPositions_thenLoadAds_hasAds() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -108,6 +117,8 @@ public void getOriginalPosition_adjustsPositions() {
         assertThat(subject.getOriginalPosition(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -133,6 +144,8 @@ public void getAdjustedPosition_adjustsPositions() {
         assertThat(subject.getAdjustedPosition(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -158,6 +171,8 @@ public void getOriginalCount_adjustsPositions() {
         assertThat(subject.getOriginalCount(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -183,6 +198,8 @@ public void getAdjustedCount_adjustsPositions() {
         assertThat(subject.getAdjustedCount(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -202,6 +219,8 @@ public void getAdjustedCount_adjustsPositions() {
     @Test
     public void placeAds_shouldCallListener() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -219,6 +238,8 @@ public void placeAds_shouldCallListener() {
     @Test
     public void placeAdsInRange_shouldPlaceAfter() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
@@ -239,6 +260,8 @@ public void placeAdsInRange_shouldPlaceAfter() {
     @Test
     public void placeAdsInRange_shouldCallListener() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
@@ -259,6 +282,8 @@ public void placeAdsInRange_shouldCallListener() {
     @Test
     public void placeAdsInRange_aboveItemCount_shouldNotInsert() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
@@ -278,12 +303,14 @@ public void getAdView_withNoAds_returnsNull() {
     @Test
     public void loadAds_shouldClearAds_afterFirstAdLoads() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(2);
         subject.placeAdsInRange(0, 1);
 
-        subject.loadAds("test_ad-unit-id");
+        subject.loadAds("test-ad-unit-id");
 
         // Ad should still exist until a new ad is available
         checkAdPositions(1);
@@ -297,12 +324,27 @@ public void loadAds_shouldClearAds_afterFirstAdLoads() {
         checkAdPositions(1);
     }
 
+    @Test
+    public void loadAds_withFailingPositioningSource_shouldNotLoadAds() {
+        ArgumentCaptor<PositioningListener> listenerCaptor =
+                ArgumentCaptor.forClass(PositioningListener.class);
+
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        verify(mockPositioningSource).loadPositions(
+                eq("test-ad-unit-id"), listenerCaptor.capture());
+        listenerCaptor.getValue().onFailed();
+        verify(mockAdLoadedListener, never()).onAdLoaded(anyInt());
+    }
+
     @Test
     public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDestroyResponse() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
 
         subject = new MoPubStreamAdPlacer(context,
                 mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(2);  // Places 1 ad
@@ -320,6 +362,8 @@ public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker(
         when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class)))
                 .thenReturn(view);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -334,6 +378,8 @@ public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker(
     public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
         View convertView = new View(context);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -349,6 +395,8 @@ public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousN
         NativeResponse mockNativeResponse = mock(NativeResponse.class);
         View mockView = mock(View.class);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse, mockNativeResponse, stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -371,6 +419,8 @@ public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousN
     public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
         View mockView = mock(View.class);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -386,6 +436,8 @@ public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionT
     public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
         View mockView = mock(View.class);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -403,6 +455,8 @@ public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldRes
 
         subject = new MoPubStreamAdPlacer(context,
                 mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(2);  // Places 1 ad
@@ -417,6 +471,8 @@ public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldRes
     @Test
     public void modifyClientPositioning_afterConstructingAdPlacer_shouldNotModifyAdPositions() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         positioning.enableRepeatingPositions(5);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
index 4d4b3e9f..2443a4d4 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
@@ -15,6 +15,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -40,7 +41,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
@@ -60,6 +61,7 @@ public void setUp() throws Exception {
         relativeLayout.addView(titleView);
         relativeLayout.addView(textView);
         relativeLayout.addView(callToActionView);
+        relativeLayout.setTag(NativeAdViewHelper.ViewType.AD);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -77,54 +79,40 @@ public void getAdView_shouldReturnPopulatedView() throws Exception {
         when(mockNativeResponse1.getText()).thenReturn("test text");
         when(mockNativeResponse1.getCallToAction()).thenReturn("test call to action");
 
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
         assertThat(((TextView)view.findViewById(titleView.getId())).getText()).isEqualTo("test title");
         assertThat(((TextView)view.findViewById(textView.getId())).getText()).isEqualTo("test text");
         assertThat(((TextView)view.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
+        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.AD);
 
         // not testing images due to testing complexity
     }
 
     @Test
-    public void getAdView_withNullViewBinder_shouldReturnEmptyView() throws Exception {
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, null, null);
+    public void getAdView_withDestroyedNativeResponse_shouldReturnEmptyAndGoneConvertView() throws Exception {
+        when(mockNativeResponse1.isDestroyed()).thenReturn(true);
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
-        assertThat(view).isNotNull();
         assertThat(view).isNotEqualTo(relativeLayout);
-    }
-
-    @Test
-    public void getAdView_withNullNativeResponse_shouldReturnGONEConvertView() throws Exception {
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, null, viewBinder, null);
-
-        assertThat(view).isEqualTo(relativeLayout);
+        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.EMPTY);
         assertThat(view.getVisibility()).isEqualTo(View.GONE);
     }
 
-    @Test
-    public void getAdView_withDestroyedNativeResponse_shouldReturnGONEConvertView() throws Exception {
-        when(mockNativeResponse1.isDestroyed()).thenReturn(true);
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
-
-        assertThat(view).isEqualTo(relativeLayout);
-        assertThat(view.getVisibility()).isEqualTo(View.GONE);
-    }
-    
     @Test
     public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
 
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
         verify(mockImpressionTracker).removeView(relativeLayout);
 
         // Second call should clear the first NativeResponse
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse2, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse2, viewBinder);
         verify(mockImpressionTracker, times(2)).removeView(relativeLayout);
         verify(mockNativeResponse1).clear(relativeLayout);
 
         // Third call should clear the second NativeResponse
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
         verify(mockImpressionTracker, times(3)).removeView(relativeLayout);
         verify(mockNativeResponse2).clear(relativeLayout);
     }
@@ -134,7 +122,7 @@ public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionT
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
         when(mockNativeResponse1.isOverridingImpressionTracker()).thenReturn(true);
 
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
         verify(mockImpressionTracker, never()).addView(any(View.class), any(NativeResponse.class));
         verify(mockNativeResponse1).prepare(relativeLayout);
@@ -145,7 +133,7 @@ public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionT
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
         when(mockNativeResponse1.isOverridingImpressionTracker()).thenReturn(false);
 
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
         verify(mockImpressionTracker).addView(relativeLayout, mockNativeResponse1);
         verify(mockNativeResponse1).prepare(relativeLayout);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
index a1cef1c5..0bbde894 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
@@ -1,24 +1,25 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.support.annotation.NonNull;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
 
-import com.mopub.common.DownloadResponse;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.Request;
 
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.HttpRequestInfo;
 
 import java.util.List;
 import java.util.Map;
@@ -29,7 +30,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
@@ -44,11 +47,18 @@
     private NativeAdInterface mMockNativeAd;
     private boolean baseNativeAdRecordedImpression;
     private boolean baseNativeAdIsClicked;
-    private DownloadResponse downloadResponse;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    private SpinningProgressView mockSpinningProgressView;
+
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        setupWithClickUrl("clickDestinationUrl");
+    }
+
+    private void setupWithClickUrl(String clickUrl) {
+        context = Robolectric.buildActivity(Activity.class).create().get();
         mNativeAd = new BaseForwardingNativeAd() {
             @Override
             public void recordImpression() {
@@ -56,7 +66,7 @@ public void recordImpression() {
             }
 
             @Override
-            public void handleClick(final View view) {
+            public void handleClick(@NonNull final View view) {
                 baseNativeAdIsClicked = true;
             }
         };
@@ -64,7 +74,7 @@ public void handleClick(final View view) {
         mNativeAd.setText("text");
         mNativeAd.setMainImageUrl("mainImageUrl");
         mNativeAd.setIconImageUrl("iconImageUrl");
-        mNativeAd.setClickDestinationUrl("clickDestinationUrl");
+        mNativeAd.setClickDestinationUrl(clickUrl);
         mNativeAd.setCallToAction("callToAction");
         mNativeAd.addExtra("extra", "extraValue");
         mNativeAd.addExtra("extraImage", "extraImageUrl");
@@ -73,23 +83,29 @@ public void handleClick(final View view) {
 
         view = new LinearLayout(context);
 
-        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.IMPRESSION_URL.getKey(), "moPubImpressionTrackerUrl");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "moPubClickTrackerUrl");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
 
         moPubNativeListener = mock(MoPubNative.MoPubNativeListener.class);
 
-        subject = new NativeResponse(context, downloadResponse, "adunit_id", mNativeAd, moPubNativeListener);
+        subject = new NativeResponse(context,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id", mNativeAd, moPubNativeListener);
 
         mMockNativeAd = mock(NativeAdInterface.class);
-        subjectWMockBaseNativeAd = new NativeResponse(context, downloadResponse, "adunit_id", mMockNativeAd, moPubNativeListener);
+        subjectWMockBaseNativeAd = new NativeResponse(context,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id", mMockNativeAd, moPubNativeListener);
+
+        mockSpinningProgressView = mock(SpinningProgressView.class);
     }
 
     @Test
     public void constructor_shouldSetNativeEventListenerOnNativeAdInterface() {
         reset(mMockNativeAd);
-        subject = new NativeResponse(context, downloadResponse, "adunit_id", mMockNativeAd, moPubNativeListener);
+        subject = new NativeResponse(context, "moPubImpressionTrackerUrl", "moPubClickTrackerUrl",
+                "adunit_id", mMockNativeAd, moPubNativeListener);
         verify(mMockNativeAd).setNativeEventListener(any(BaseForwardingNativeAd.NativeEventListener.class));
     }
 
@@ -205,33 +221,28 @@ public void prepare_shouldAttachClickListenersToViewTree() {
 
     @Test
     public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() {
-        Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
-        Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         assertThat(subject.getRecordedImpression()).isFalse();
 
         subject.recordImpression(view);
 
         assertThat(subject.getRecordedImpression()).isTrue();
 
-        List<HttpRequestInfo> httpRequestInfos = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos();
-        assertThat(httpRequestInfos.size()).isEqualTo(2);
-        assertThat(httpRequestInfos.get(0).getHttpRequest().getRequestLine().getUri()).isEqualTo("moPubImpressionTrackerUrl");
-        assertThat(httpRequestInfos.get(1).getHttpRequest().getRequestLine().getUri()).isEqualTo("impressionUrl");
-
         assertThat(baseNativeAdRecordedImpression).isTrue();
         verify(moPubNativeListener).onNativeImpression(view);
+        // There are two impression trackers here.
+        verify(mockRequestQueue, times(2)).add(any(Request.class));
 
         // reset state
         baseNativeAdRecordedImpression = false;
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
         reset(moPubNativeListener);
+        reset(mockRequestQueue);
 
         // verify impression tracking doesn't fire again
         subject.recordImpression(view);
         assertThat(subject.getRecordedImpression()).isTrue();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdRecordedImpression).isFalse();
         verify(moPubNativeListener, never()).onNativeImpression(view);
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
     @Test
@@ -239,38 +250,34 @@ public void recordImpression_whenDestroyed_shouldReturnFast() {
         subject.destroy();
         subject.recordImpression(view);
         assertThat(subject.getRecordedImpression()).isFalse();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdRecordedImpression).isFalse();
         verify(moPubNativeListener, never()).onNativeImpression(view);
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
     @Test
     public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() {
-        Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         assertThat(subject.isClicked()).isFalse();
 
         subject.handleClick(view);
 
         assertThat(subject.isClicked()).isTrue();
 
-        List<HttpRequestInfo> httpRequestInfos = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos();
-        assertThat(httpRequestInfos.size()).isEqualTo(1);
-        assertThat(httpRequestInfos.get(0).getHttpRequest().getRequestLine().getUri()).isEqualTo("moPubClickTrackerUrl");
-
         assertThat(baseNativeAdIsClicked).isTrue();
         verify(moPubNativeListener).onNativeClick(view);
+        verify(mockRequestQueue).add(any(Request.class));
 
         // reset state
         baseNativeAdIsClicked = false;
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
         reset(moPubNativeListener);
+        reset(mockRequestQueue);
 
         // second time, tracking does not fire
         subject.handleClick(view);
         assertThat(subject.isClicked()).isTrue();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdRecordedImpression).isFalse();
         verify(moPubNativeListener).onNativeClick(view);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Ignore("pending")
@@ -279,14 +286,53 @@ public void handleClick_withBaseNativeAdClickDestinationUrl_shouldRecordClickAnd
         // Really difficult to test url resolution since it doesn't use the apache http client
     }
 
+    @Test
+    public void handleClick_shouldShowSpinner_shouldRemoveSpinner_WhenSucceeded() {
+        setupWithClickUrl("http://www.mopub.com");
+
+        Robolectric.getBackgroundScheduler().pause();
+
+        subject.handleClick(view, mockSpinningProgressView);
+
+        verify(mockSpinningProgressView).addToRoot(view);
+        Robolectric.getBackgroundScheduler().unPause();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void handleClick_shouldShowSpinner_shouldRemoveSpinner_WhenFailed() {
+        setupWithClickUrl("");
+
+        Robolectric.getBackgroundScheduler().pause();
+
+        subject.handleClick(view, mockSpinningProgressView);
+
+        verify(mockSpinningProgressView).addToRoot(view);
+        Robolectric.getBackgroundScheduler().unPause();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void handleClick_withNullView_shouldNotShowSpinner() {
+        setupWithClickUrl("http://www.mopub.com");
+
+        Robolectric.getBackgroundScheduler().pause();
+
+        subject.handleClick(null, mockSpinningProgressView);
+
+        verify(mockSpinningProgressView, never()).addToRoot(view);
+        Robolectric.getBackgroundScheduler().unPause();
+        verify(mockSpinningProgressView, never()).removeFromRoot();
+    }
+
     @Test
     public void handleClick_whenDestroyed_shouldReturnFast() {
         subject.destroy();
         subject.handleClick(view);
         assertThat(subject.isClicked()).isFalse();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdIsClicked).isFalse();
         verify(moPubNativeListener, never()).onNativeClick(view);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
index 5d96c9b0..724736a8 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
@@ -2,18 +2,32 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Point;
+import android.location.Location;
+import android.location.LocationManager;
 import android.net.Uri;
+import android.os.Build;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
 
 import com.mopub.common.MoPub;
-import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
+import com.mopub.network.Networking;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLocationManager;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -22,26 +36,66 @@
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 @Config(shadows = {MoPubShadowTelephonyManager.class})
 public class NativeUrlGeneratorTest {
     public static final String AD_UNIT_ID = "1234";
+    private static final int TEST_SCREEN_WIDTH = 999;
+    private static final int TEST_SCREEN_HEIGHT = 888;
+    private static final float TEST_DENSITY = 1.0f;
     private Activity context;
     private NativeUrlGenerator subject;
     private MoPubShadowTelephonyManager shadowTelephonyManager;
 
     @Before
     public void setup() {
-        context = new Activity();
+        Networking.useHttps(false);
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        when(context.getPackageName()).thenReturn("testBundle");
         shadowTelephonyManager = (MoPubShadowTelephonyManager)
                 shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
     }
 
     @Test
-    public void generateNativeAdUrl_shouldIncludeDesiredAssetIfSet() throws Exception {
+    public void generateUrlString_shouldIncludeDesiredAssetIfSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -55,7 +109,7 @@ public void generateNativeAdUrl_shouldIncludeDesiredAssetIfSet() throws Exceptio
     }
 
     @Test
-    public void generateNativeAdUrl_shouldIncludeDesiredAssetsIfSet() throws Exception {
+    public void generateUrlString_shouldIncludeDesiredAssetsIfSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE, RequestParameters.NativeAdAsset.TEXT, RequestParameters.NativeAdAsset.ICON_IMAGE);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -69,7 +123,7 @@ public void generateNativeAdUrl_shouldIncludeDesiredAssetsIfSet() throws Excepti
     }
 
     @Test
-    public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
@@ -79,7 +133,7 @@ public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNotSet() throws E
     }
 
     @Test
-    public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.noneOf(RequestParameters.NativeAdAsset.class);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -92,7 +146,7 @@ public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet()
     }
 
     @Test
-    public void generateNativeAdUrl_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
+    public void generateUrlString_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(true);
         shadowTelephonyManager.setReadPhoneStatePermission(false);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -102,9 +156,9 @@ public void generateNativeAdUrl_needsButDoesNotHaveReadPhoneState_shouldNotConta
 
         assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isNullOrEmpty();
     }
-    
+
     @Test
-    public void generateNativeAdUrl_needsAndHasReadPhoneState_shouldContainOperatorName() {
+    public void generateUrlString_needsAndHasReadPhoneState_shouldContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(true);
         shadowTelephonyManager.setReadPhoneStatePermission(true);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -116,7 +170,7 @@ public void generateNativeAdUrl_needsAndHasReadPhoneState_shouldContainOperatorN
     }
 
     @Test
-    public void generateNativeAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorName() {
+    public void generateUrlString_doesNotNeedReadPhoneState_shouldContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(false);
         shadowTelephonyManager.setReadPhoneStatePermission(false);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -127,13 +181,137 @@ public void generateNativeAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorN
         assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isEqualTo("TEST_CARRIER");
     }
 
+    @Test
+    public void generateUrlString_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(System.currentTimeMillis() - 555555);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("555");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(System.currentTimeMillis() - 777777);
+
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+
+        // Mock out the LocationManager's last known location to be older than the
+        // developer-supplied location.
+        Location olderLocation = new Location("");
+        olderLocation.setLatitude(40);
+        olderLocation.setLongitude(-105);
+        olderLocation.setAccuracy(8.0f);
+        olderLocation.setTime(System.currentTimeMillis() - 888888);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("777");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(38);
+        locationFromSdk.setLongitude(-123);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(System.currentTimeMillis() - 123456);
+        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
+                locationFromSdk);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("123");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_withOnlyAdUnitSet_shouldReturnMinimumUrl() {
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        final String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(
+                "http://ads.mopub.com/m/ad?id=" +
+                        AD_UNIT_ID +
+                        "&nsv=" + MoPub.SDK_VERSION + 
+                        "&dn=unknown%2Cunknown%2Cunknown" +
+                        "&bundle=testBundle" +
+                        "&z=-0700" +
+                        "&o=u" +
+                        "&w=" +
+                        TEST_SCREEN_WIDTH +
+                        "&h=" +
+                        TEST_SCREEN_HEIGHT +
+                        "&sc_a=" +
+                        TEST_DENSITY +
+                        "&ct=3&av=" + BuildConfig.VERSION_NAME +
+                        "&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track");
+    }
+
     @Test
     public void enableLocation_shouldIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(requestString)).isNotNull();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNotNull();
     }
 
     @Test
@@ -142,7 +320,26 @@ public void disableLocation_shouldNotIncludeLocationInUrl() {
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(requestString)).isNullOrEmpty();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
+    }
+
+    @Test
+    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+        subject = new NativeUrlGenerator(context);
+
+        // Mock out the LocationManager's last known location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String requestString = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
     }
 
     private List<String> getDesiredAssetsListFromRequestUrlString(String requestString) {
@@ -164,15 +361,15 @@ private String getNetworkOperatorNameFromRequestUrl(String requestString) {
         return networkOperatorName;
     }
 
-    private String getLocationFromRequestUrl(String requestString) {
+    private String getParameterFromRequestUrl(String requestString, String key) {
         Uri requestUri = Uri.parse(requestString);
-        String location = requestUri.getQueryParameter("ll");
+        String parameter = requestUri.getQueryParameter(key);
 
-        if (TextUtils.isEmpty(location)) {
+        if (TextUtils.isEmpty(parameter)) {
             return "";
         }
 
-        return location;
+        return parameter;
     }
 
     private String generateMinimumUrlString() {
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
index 52e22017..2ff97828 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
 import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.ImageView;
@@ -11,24 +12,28 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.CacheService;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
-import static org.robolectric.Robolectric.shadowOf;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class})
 public class NativeViewHolderTest {
     private Context context;
     private RelativeLayout relativeLayout;
@@ -55,9 +60,31 @@
     private Bitmap extrasImage2;
     private Bitmap extrasImage;
 
+    private static final String IMPRESSION_URL = "http://example.com";
+    private static final String CLICK_URL = "http://test.com";
+    private static final String AD_UNIT_ID = "http://blah.org";
+
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> mainImageCaptor;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> iconImageCaptor;
+
+
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
@@ -163,9 +190,6 @@ public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exc
     @Test
     public void update_shouldAddValuesToViews() throws Exception {
         // Setup for cache state for image gets
-        CacheService.initialize(context);
-        CacheService.putToBitmapCache(mainImageUrl, mainImage);
-        CacheService.putToBitmapCache(iconImageUrl, iconImage);
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.setTitle("titletext");
@@ -174,8 +198,8 @@ public void update_shouldAddValuesToViews() throws Exception {
         nativeAd.setIconImageUrl("iconimageurl");
         nativeAd.setCallToAction("cta");
 
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -193,10 +217,15 @@ public void update_shouldAddValuesToViews() throws Exception {
         assertThat(titleView.getText()).isEqualTo("titletext");
         assertThat(textView.getText()).isEqualTo("texttext");
         assertThat(callToActionView.getText()).isEqualTo("cta");
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(mainImageView))
-                .getCreatedFromBytes()).isEqualTo(mainImageData.getBytes());
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(iconImageView))
-                .getCreatedFromBytes()).isEqualTo(iconImageData.getBytes());
+        verify(mockImageLoader).get(eq("mainimageurl"), mainImageCaptor.capture());
+        verify(mockImageLoader).get(eq("iconimageurl"), iconImageCaptor.capture());
+
+        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
+        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
+        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
+
+        assertThat(((BitmapDrawable) mainImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+        assertThat(((BitmapDrawable) iconImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
     }
 
     @Test
@@ -209,8 +238,8 @@ public void update_withMissingNativeResponseFields_shouldClearPreviousValues() t
         iconImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousiconimagedata".getBytes(), 0, "previousiconimagedata".getBytes().length));
 
         // Only required fields in native response
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", mock(BaseForwardingNativeAd.class), null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, mock(BaseForwardingNativeAd.class), null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -240,8 +269,9 @@ public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.setCallToAction("cta");
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .callToActionId(callToActionView.getId())
@@ -260,16 +290,14 @@ public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws
     @Test
     public void updateExtras_shouldAddValuesToViews() throws Exception {
         // Setup for cache state for image gets
-        CacheService.initialize(context);
-        CacheService.putToBitmapCache("extrasimageurl", extrasImage);
-        CacheService.putToBitmapCache("extrasimageurl2", extrasImage2);
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.addExtra("extrastext", "extrastexttext");
         nativeAd.addExtra("extrasimage", "extrasimageurl");
         nativeAd.addExtra("extrasimage2", "extrasimageurl2");
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasTextView.getId())
@@ -280,13 +308,19 @@ public void updateExtras_shouldAddValuesToViews() throws Exception {
         NativeViewHolder nativeViewHolder =
                 NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
 
-        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+        nativeViewHolder.updateExtras(nativeResponse, viewBinder);
 
         assertThat(extrasTextView.getText()).isEqualTo("extrastexttext");
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView))
-                .getCreatedFromBytes()).isEqualTo("extrasimagedata".getBytes());
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView2))
-                .getCreatedFromBytes()).isEqualTo("extrasimagedata2".getBytes());
+
+        verify(mockImageLoader).get(eq("extrasimageurl"), mainImageCaptor.capture());
+        verify(mockImageLoader).get(eq("extrasimageurl2"), iconImageCaptor.capture());
+
+        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
+        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
+        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
+
+        assertThat(((BitmapDrawable) extrasImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+        assertThat(((BitmapDrawable) extrasImageView2.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
     }
 
     @Test
@@ -295,8 +329,8 @@ public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() thr
         extrasImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata".getBytes(), 0, "previousextrasimagedata".getBytes().length));
         extrasImageView2.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata2".getBytes(), 0, "previousextrasimagedata2".getBytes().length));
 
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", new BaseForwardingNativeAd(){}, null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, new BaseForwardingNativeAd(){}, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasTextView.getId())
@@ -308,12 +342,8 @@ public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() thr
                 NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
 
         assertThat(extrasTextView.getText()).isEqualTo("previousextrastext");
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView))
-                .getCreatedFromBytes()).isEqualTo("previousextrasimagedata".getBytes());
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView2))
-                .getCreatedFromBytes()).isEqualTo("previousextrasimagedata2".getBytes());
 
-        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+        nativeViewHolder.updateExtras(nativeResponse, viewBinder);
 
         assertThat(extrasTextView.getText()).isEqualTo("");
         assertThat(extrasImageView.getDrawable()).isNull();
@@ -326,8 +356,8 @@ public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAnd
         nativeAd.addExtra("extrastext", "extrastexttext");
         nativeAd.addExtra("extrasimage", "extrasimageurl");
 
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasImageView.getId())
@@ -340,14 +370,14 @@ public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAnd
         assertThat(extrasTextView.getText()).isEqualTo("");
         assertThat(extrasImageView.getDrawable()).isNull();
 
-        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+        nativeViewHolder.updateExtras(nativeResponse, viewBinder);
 
+        // Volley's imageloader will set this to a bitmapdrawable with no bitmap
         assertThat(extrasTextView.getText()).isEqualTo("extrasimageurl");
         assertThat(extrasImageView.getDrawable()).isNull();
     }
 
-    @Test
-    public void fromViewBinder_withMixedViewTypes_shouldReturnNull() throws Exception {
+    public void fromViewBinder_withMixedViewTypes_shouldReturnEmptyViewHolder() throws Exception {
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(mainImageView.getId())
                 .textId(textView.getId())
@@ -355,7 +385,6 @@ public void fromViewBinder_withMixedViewTypes_shouldReturnNull() throws Exceptio
 
         NativeViewHolder nativeViewHolder =
                 NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder).isNull();
+        assertThat(nativeViewHolder).isEqualTo(NativeViewHolder.EMPTY_VIEW_HOLDER);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
index 75de2550..bcab2a25 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
@@ -20,7 +20,6 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-@Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class PlacementDataTest {
     private PlacementData noAds;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
new file mode 100644
index 00000000..c67dd6cf
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
@@ -0,0 +1,144 @@
+package com.mopub.nativeads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+
+import org.json.JSONException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.TreeMap;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class PositioningRequestTest {
+
+    String url = "http://example.com";
+    @Mock
+    Response.Listener<MoPubNativeAdPositioning.MoPubClientPositioning> mockListener;
+    @Mock
+    Response.ErrorListener mockErrorListener;
+
+    NetworkResponse mockNetworkResponse;
+    PositioningRequest subject;
+
+    @Before
+    public void setup() {
+        subject = new PositioningRequest(url, mockListener, mockErrorListener);
+    }
+
+    @Test
+    public void parseNetworkResponse_shouldReturnPositioning() {
+        mockNetworkResponse = new NetworkResponse(200, "{fixed: []}".getBytes(), new TreeMap<String, String>(), false);
+        assertThat(subject.parseNetworkResponse(mockNetworkResponse).result)
+                .isExactlyInstanceOf(MoPubNativeAdPositioning.MoPubClientPositioning.class);
+    }
+    
+    @Test
+    public void parseNetworkResponse_shouldReturnError() {
+        mockNetworkResponse = new NetworkResponse(200, "garbage".getBytes(), new TreeMap<String, String>(), false);
+        assertThat(subject.parseNetworkResponse(mockNetworkResponse).error)
+                .isExactlyInstanceOf(VolleyError.class);
+    }
+    
+    @Test
+    public void parseJson_noFixedPositions_shouldReturnEmptyPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: []}");
+        assertThat(positioning.getFixedPositions()).isEmpty();
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_oneFixedPosition_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{position: 2}]}");
+        assertThat(positioning.getFixedPositions()).containsOnly(2);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_twoFixedPositions_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{position: 1}, {position: 8}]}");
+        assertThat(positioning.getFixedPositions()).containsExactly(1, 8);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_twoFixedPositions_shouldIgnoreNonZeroSection() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{section: 0, position: 5}, {section: 1, position: 8}]}");
+        assertThat(positioning.getFixedPositions()).containsOnly(5);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_invalidFixedPosition_shouldThrowException() throws Exception {
+        // Must have either fixed or repeating positions.
+        checkException("", "Empty response");
+        checkException("{}", "Must contain fixed or repeating positions");
+        checkException("{\"error\":\"WARMING_UP\"}", "WARMING_UP");
+
+        // Position is required.
+        checkException("{fixed: [{}]}", "JSONObject[\"position\"] not found.");
+        checkException("{fixed: [{section: 0}]}", "JSONObject[\"position\"] not found.");
+
+        // Section is optional, but if it exists must be > 0
+        checkException("{fixed: [{section: -1, position: 8}]}", "Invalid section -1 in JSON response");
+
+        // Positions must be between [0 and 2 ^ 16).
+        checkException("{fixed: [{position: -1}]}", "Invalid position -1 in JSON response");
+        checkException("{fixed: [{position: 1}, {position: -8}]}",
+                "Invalid position -8 in JSON response");
+        checkException("{fixed: [{position: 1}, {position: 66000}]}",
+                "Invalid position 66000 in JSON response");
+    }
+
+    @Test
+    public void parseJson_repeatingInterval_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{repeating: {interval: 2}}");
+        assertThat(positioning.getFixedPositions()).isEmpty();
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
+    }
+
+    @Test
+    public void parseJson_invalidRepeating_shouldThrowException() throws Exception {
+        checkException("{repeating: }", "Missing value at character 12");
+        checkException("{repeating: {}}", "JSONObject[\"interval\"] not found.");
+
+        // Intervals must be between [2 and 2 ^ 16).
+        checkException("{repeating: {interval: -1}}", "Invalid interval -1 in JSON response");
+        checkException("{repeating: {interval: 0}}", "Invalid interval 0 in JSON response");
+        checkException("{repeating: {interval: 1}}", "Invalid interval 1 in JSON response");
+        checkException("{repeating: {interval: 66000}}",
+                "Invalid interval 66000 in JSON response");
+    }
+
+    @Test
+    public void parseJson_fixedAndRepeating_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{position: 0}, {position: 1}], repeating: {interval: 2}}");
+        assertThat(positioning.getFixedPositions()).containsExactly(0, 1);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
+    }
+
+    private void checkException(String json, String expectedMessage) throws Exception {
+        try {
+            subject.parseJson(json);
+        } catch (JSONException e) {
+            return;
+        } catch (MoPubNetworkError e) {
+            return;
+        }
+        fail("Should have received an exception");
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
index 2930217b..824a39bc 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
@@ -1,19 +1,24 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.content.Context;
+import android.content.pm.PackageManager;
 import android.os.Build.VERSION_CODES;
 
+import com.mopub.common.ClientMetadata;
 import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.DownloadTask.DownloadTaskListener;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
-import com.mopub.nativeads.ServerPositioningSource.DownloadTaskProvider;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
 
 import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.json.JSONException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,40 +27,49 @@
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
-import java.util.concurrent.Executor;
+import java.util.List;
+import java.util.logging.Level;
 
-import static junit.framework.Assert.fail;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class ServerPositioningSourceTest {
-    @Mock DownloadTaskProvider mockDownloadTaskProvider;
-    @Mock DownloadTaskListener mockDownloadTaskListener;
-    @Mock DownloadTask mockDownloadTask;
     @Mock PositioningListener mockPositioningListener;
-    @Captor ArgumentCaptor<DownloadTaskListener> taskListenerCaptor;
+    @Captor ArgumentCaptor<PositioningRequest> positionRequestCaptor;
     @Mock DownloadResponse mockValidResponse;
     @Mock DownloadResponse mockNotFoundResponse;
     @Mock DownloadResponse mockInvalidJsonResponse;
     @Mock DownloadResponse mockWarmingUpJsonResponse;
+    @Mock Context mockContext;
+    @Mock ClientMetadata mockClientMetaData;
+    @Mock MoPubRequestQueue mockRequestQueue;
+
     @Captor ArgumentCaptor<MoPubClientPositioning> positioningCaptor;
 
     ServerPositioningSource subject;
+    private Activity spyActivity;
 
     @Before
     public void setUp() {
         Activity activity = Robolectric.buildActivity(Activity.class).create().get();
-        subject = new ServerPositioningSource(activity, mockDownloadTaskProvider);
+        spyActivity = spy(activity);
+
+
 
-        when(mockDownloadTaskProvider.get(any(DownloadTaskListener.class)))
-                .thenReturn(mockDownloadTask);
+        subject = new ServerPositioningSource(spyActivity);
+        setupClientMetadata();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
 
         when(mockValidResponse.getStatusCode()).thenReturn(HttpStatus.SC_OK);
         when(mockValidResponse.getByteArray()).thenReturn("{fixed: []}".getBytes());
@@ -70,218 +84,131 @@ public void setUp() {
         when(mockNotFoundResponse.getStatusCode()).thenReturn(HttpStatus.SC_NOT_FOUND);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void loadPositions_atLeastIcs_shouldExecuteDownloadTask() {
-        subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask).executeOnExecutor(any(Executor.class), any(HttpGet.class));
-    }
-
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
-    @Test
-    public void loadPositions_beforeIcs_shouldExecuteDownloadTask() {
+    private void setupClientMetadata() {
+        when(mockClientMetaData.getSdkVersion()).thenReturn("sdk_version");
+        when(mockClientMetaData.getAppName()).thenReturn("app_name");
+        when(mockClientMetaData.getAppPackageName()).thenReturn("app_package_name");
+        when(mockClientMetaData.getAppVersion()).thenReturn("app_version");
+        when(mockClientMetaData.getDeviceId()).thenReturn("client_device_id");
+        when(mockClientMetaData.isDoNotTrackSet()).thenReturn(true);
+        when(mockClientMetaData.getDeviceManufacturer()).thenReturn("device_manufacturer");
+        when(mockClientMetaData.getDeviceModel()).thenReturn("device_model");
+        when(mockClientMetaData.getDeviceProduct()).thenReturn("device_product");
+        when(mockClientMetaData.getDeviceOsVersion()).thenReturn("device_os_version");
+        when(mockClientMetaData.getDeviceScreenWidthDip()).thenReturn(1337);
+        when(mockClientMetaData.getDeviceScreenHeightDip()).thenReturn(70707);
+        when(mockClientMetaData.getActiveNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockClientMetaData.getNetworkOperator()).thenReturn("network_operator");
+        when(mockClientMetaData.getNetworkOperatorName()).thenReturn("network_operator_name");
+        when(mockClientMetaData.getIsoCountryCode()).thenReturn("network_iso_country_code");
+        when(mockClientMetaData.getSimOperator()).thenReturn("network_sim_operator");
+        when(mockClientMetaData.getSimOperatorName()).thenReturn("network_sim_operator_name");
+        when(mockClientMetaData.getSimIsoCountryCode()).thenReturn("network_sim_iso_country_code");
+        ClientMetadata.setInstance(mockClientMetaData);
+    }
+
+    @Test
+    public void loadPositions_shouldAddToRequestQueue() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask).execute(any(HttpGet.class));
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
     @Test
-    public void loadPositionsTwice_shouldCancelPreviousDownloadTask_shouldNotCallListener() {
+    public void loadPositionsTwice_shouldCancelPreviousRequest_shouldNotCallListener() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask).cancel(true);
+        verify(mockRequestQueue, times(2)).add(any(Request.class));
 
-        // Cancelling completes the download tasks with a null response.
-        taskListenerCaptor.getValue().onComplete("some_url", null);
         verify(mockPositioningListener, never()).onFailed();
         verify(mockPositioningListener, never()).onLoad(any(MoPubClientPositioning.class));
     }
 
     @Test
-    public void loadPositionsTwice_withPendingRetry_shouldNotCancelPreviousDownloadTask() {
+    public void loadPositionsTwice_afterSuccess_shouldNotCancelPreviousRequest() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockValidResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
 
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask, never()).cancel(anyBoolean());
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
     @Test
     public void loadPositions_thenComplete_withValidResponse_shouldCallOnLoadListener() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockValidResponse);
-
-        verify(mockPositioningListener).onLoad(positioningCaptor.capture());
-        MoPubClientPositioning positioning = positioningCaptor.getValue();
-        assertThat(positioning.getFixedPositions()).isEmpty();
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void loadPositions_thenComplete_withNotFoundResponse_shouldRetry() {
-        subject.loadPositions("test_ad_unit", mockPositioningListener);
-        
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockNotFoundResponse);
+        final PositioningRequest value = positionRequestCaptor.getValue();
+        final MoPubClientPositioning response = new MoPubClientPositioning().enableRepeatingPositions(3);
+        value.deliverResponse(response);
 
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
+        verify(mockPositioningListener).onLoad(eq(response));
     }
 
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
-    public void loadPositions_thenComplete_withWarmingUpResponse_shouldRetry() {
+    public void loadPositions_thenComplete_withErrorResponse_shouldRetry() throws Exception {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockWarmingUpJsonResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+        // We get VolleyErrors for invalid JSON, 404s, 5xx, and {"error": "WARMING_UP"}
+        positionRequestCaptor.getValue().deliverError(new VolleyError("Some test error"));
 
         Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
-    @Test
-    public void loadPositions_thenComplete_withInvalidJsonResponse_shouldRetry() {
-        subject.loadPositions("test_ad_unit", mockPositioningListener);
-
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockInvalidJsonResponse);
-
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
-    }
 
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void loadPositions_withPendingRetry_shouldNotRetry() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockInvalidJsonResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+        positionRequestCaptor.getValue().deliverError(new VolleyError("testError"));
 
         subject.loadPositions("test_ad_unit", mockPositioningListener);
         Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
+        // If a retry happened, we'd have two here.
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
     @Test
     public void loadPositions_thenFailAfterMaxRetryTime_shouldCallFailureHandler() {
-        ServerPositioningSource.MAXIMUM_RETRY_TIME_MILLISECONDS = 999;
-
         subject.loadPositions("test_ad_unit", mockPositioningListener);
+        // Simulate failure after max time.
+        subject.setMaximumRetryTimeMilliseconds(999);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockInvalidJsonResponse);
-
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new VolleyError("test error"));
         verify(mockPositioningListener).onFailed();
     }
 
     @Test
-    public void parseJsonResponse_noFixedPositions_shouldReturnEmptyPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: []}");
-        assertThat(positioning.getFixedPositions()).isEmpty();
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Test
-    public void parseJsonResponse_oneFixedPosition_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{position: 2}]}");
-        assertThat(positioning.getFixedPositions()).containsOnly(2);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Test
-    public void parseJsonResponse_twoFixedPositions_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{position: 1}, {position: 8}]}");
-        assertThat(positioning.getFixedPositions()).containsExactly(1, 8);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Test
-    public void parseJsonResponse_twoFixedPositions_shouldIgnoreNonZeroSection()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{section: 0, position: 5}, {section: 1, position: 8}]}");
-        assertThat(positioning.getFixedPositions()).containsOnly(5);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
+    public void loadPositions_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldCallFailureHandler() {
+        MoPubLog.setSdkHandlerLevel(Level.ALL);
 
-    @Test
-    public void parseJsonResponse_invalidFixedPosition_shouldThrowException() {
-        // Must have either fixed or repeating positions.
-        checkException(null, "Empty response");
-        checkException("", "Empty response");
-        checkException("{}", "Must contain fixed or repeating positions");
-        checkException("{\"error\":\"WARMING_UP\"}", "WARMING_UP");
-
-        // Position is required.
-        checkException("{fixed: [{}]}", "JSONObject[\"position\"] not found.");
-        checkException("{fixed: [{section: 0}]}", "JSONObject[\"position\"] not found.");
-
-        // Section is optional, but if it exists must be > 0
-        checkException("{fixed: [{section: -1, position: 8}]}", "Invalid section -1 in JSON response");
-
-        // Positions must be between [0 and 2 ^ 16).
-        checkException("{fixed: [{position: -1}]}", "Invalid position -1 in JSON response");
-        checkException("{fixed: [{position: 1}, {position: -8}]}",
-                "Invalid position -8 in JSON response");
-        checkException("{fixed: [{position: 1}, {position: 66000}]}",
-                "Invalid position 66000 in JSON response");
-    }
+        when(mockContext.checkCallingOrSelfPermission(anyString()))
+                .thenReturn(PackageManager.PERMISSION_DENIED);
+        when(spyActivity.getApplicationContext()).thenReturn(mockContext);
+        // Reinit the subject so we get our mocked context.
+        subject = new ServerPositioningSource(spyActivity);
 
-    @Test
-    public void parseJsonResponse_repeatingInterval_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{repeating: {interval: 2}}");
-        assertThat(positioning.getFixedPositions()).isEmpty();
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
-    }
+        // Simulate failure after max time.
+        subject.setMaximumRetryTimeMilliseconds(999);
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-    @Test
-    public void parseJsonResponse_invalidRepeating_shouldThrowException() {
-        checkException("{repeating: }", "Missing value at character 12");
-        checkException("{repeating: {}}", "JSONObject[\"interval\"] not found.");
-
-        // Intervals must be between [2 and 2 ^ 16).
-        checkException("{repeating: {interval: -1}}", "Invalid interval -1 in JSON response");
-        checkException("{repeating: {interval: 0}}", "Invalid interval 0 in JSON response");
-        checkException("{repeating: {interval: 1}}", "Invalid interval 1 in JSON response");
-        checkException("{repeating: {interval: 66000}}",
-                "Invalid interval 66000 in JSON response");
-    }
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new NoConnectionError());
 
-    @Test
-    public void parseJsonResponse_fixedAndRepeating_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{position: 0}, {position: 1}], repeating: {interval: 2}}");
-        assertThat(positioning.getFixedPositions()).containsExactly(0, 1);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
-    }
+        verify(mockPositioningListener).onFailed();
 
-    private void checkException(String json, String expectedMessage) {
-        try {
-            subject.parseJsonResponse(json);
-        } catch (JSONException e) {
-            assertThat(e.getMessage()).isEqualTo(expectedMessage);
-            return;
-        }
-        fail("Should have received an exception");
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 2);
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
index 488c1ae7..bee7ae9e 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
@@ -9,8 +9,8 @@
 import android.view.ViewTreeObserver;
 import android.view.Window;
 
-import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
 
 import org.fest.util.Lists;
 import org.junit.Before;
@@ -20,6 +20,7 @@
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowSystemClock;
 
 import java.util.ArrayList;
@@ -56,7 +57,7 @@
     public void setUp() throws Exception {
         trackedViews = new WeakHashMap<View, TrackingInfo>();
         visibilityChecker = new VisibilityChecker();
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
         view2 = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
index 9b38d956..47ab9573 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
@@ -2,7 +2,9 @@
 
 import android.graphics.Point;
 import android.view.Display;
+import android.view.Surface;
 
+import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowDisplay;
 
@@ -13,4 +15,15 @@
     public void getSize(Point size) {
         size.set(getWidth(), getHeight());
     }
+
+    private static int sRotation = Surface.ROTATION_0;
+
+    @Implementation
+    public int getRotation() {
+        return sRotation;
+    }
+
+    public static void setStaticRotation(int rotation) {
+        sRotation = rotation;
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java
index 3132f10d..f8122bb9 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads.test.support;
 
+import android.support.annotation.NonNull;
+
 import com.mopub.nativeads.CustomEventNative;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
 
@@ -17,7 +19,7 @@ private static TestCustomEventNativeFactory getTestFactory() {
     }
 
     @Override
-    protected CustomEventNative internalCreate(final Class<? extends CustomEventNative> nativeClass) {
+    protected CustomEventNative internalCreate(@NonNull final Class<? extends CustomEventNative> nativeClass) {
         return instance;
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
new file mode 100644
index 00000000..d7bd6f3b
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -0,0 +1,366 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.location.Location;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventDispatcher;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class AdRequestTest {
+
+    @Mock private AdRequest.Listener mockListener;
+    @Mock private AdResponse mockAdResponse;
+    @Mock private EventDispatcher mockEventDispatcher;
+
+    private AdRequest subject;
+    private HashMap<String, String> defaultHeaders;
+    private Activity activity;
+    private String adUnitId;
+
+    @Before
+    public void setup() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        adUnitId = "testAdUnitId";
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, adUnitId, activity, mockListener);
+        defaultHeaders = new HashMap<String, String>();
+        defaultHeaders.put(ResponseHeader.SCROLLABLE.getKey(), "0");
+        defaultHeaders.put(ResponseHeader.REDIRECT_URL.getKey(), "redirect");
+        defaultHeaders.put(ResponseHeader.CLICK_TRACKING_URL.getKey(), "click_tracking");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_URL.getKey(), "impression");
+        defaultHeaders.put(ResponseHeader.FAIL_URL.getKey(), "fail_url");
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "30");
+
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+    }
+
+    @After
+    public void teardown() {
+        // Reset our locale for other tests.
+        Locale.setDefault(Locale.US);
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void parseNetworkResponse_stringBody_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.result).isNotNull();
+        assertThat(response.result.getStringBody()).isEqualTo("abc");
+    }
+
+    @Test
+    public void parseNetworkResponse_withStringBody_shouldLogScribeEvent() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        defaultHeaders.put(ResponseHeader.FULL_AD_TYPE.getKey(), "anything");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.SCROLLABLE_KEY)).isEqualToIgnoringCase("false");
+        assertThat(serverExtras.get(DataKeys.REDIRECT_URL_KEY)).isEqualToIgnoringCase("redirect");
+        assertThat(serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY)).isEqualToIgnoringCase("click_tracking");
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isExactlyInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.BAD_BODY);
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.WARMING_UP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withRefreshTime_shouldIncludeRefreshTimeInResult() {
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "13");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isEqualTo(13000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withoutRefreshTime_shouldNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isNull();
+    }
+    
+    @Test
+    public void parseNetworkResponse_withClearAdType_withRefreshTimeHeader_shouldErrorAndIncludeRefreshTime() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isEqualTo(30000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_withNoRefreshTimeHeader_shouldErrorAndNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_shouldLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withBadJSON_shouldReturnError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse badNativeNetworkResponse = new NetworkResponse(200,
+                "{[abc}".getBytes(Charset.defaultCharset()),
+                defaultHeaders, false);
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", activity, mockListener);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(badNativeNetworkResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error.getCause()).isExactlyInstanceOf(JSONException.class);
+    }
+
+    @Test
+    public void deliverResponse_shouldCallListenerOnSuccess() throws Exception {
+        subject.deliverResponse(mockAdResponse);
+        verify(mockListener).onSuccess(mockAdResponse);
+    }
+
+    @Test
+    public void getRequestId_shouldParseAndReturnRequestIdFromFailUrl() throws Exception {
+        String requestId = subject.getRequestId("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca&exclude=043fde1fe2f9470c9aa67fec262a0596&request_id=7fd6dd3bf1c84f87876b4740c1dd7baa&fail=1");
+
+        assertThat(requestId).isEqualTo("7fd6dd3bf1c84f87876b4740c1dd7baa");
+    }
+
+    @Test
+    public void getRequestId_withNullFailUrl_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId(null)).isNull();
+    }
+
+    @Test
+    public void getRequestId_withUrlWithNoRequestIdParam_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")).isNull();
+    }
+
+    @Test
+    public void getHeaders_withDefaultLocale_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocale_shouldReturnUserPreferredLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "fr");
+
+        // Assume user-preferred locale is fr_CA
+        activity.getResources().getConfiguration().locale = Locale.CANADA_FRENCH;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocaleAsNull_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale is null
+        activity.getResources().getConfiguration().locale = null;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLanguageAsEmptyString_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withLocaleLanguageAsEmptyString_shouldNotAddLanguageHeader() throws Exception {
+        Map<String, String> expectedHeaders = Collections.emptyMap();
+
+        // Assume default locale's language code is empty string
+        Locale.setDefault(new Locale(""));
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+
+
+    }
+
+    @Test
+    public void logScribeEvent_shouldLogEvent() throws Exception {
+        AdResponse mockAdResponse = mock(AdResponse.class);
+        when(mockAdResponse.getDspCreativeId()).thenReturn("dsp_creative_id");
+        when(mockAdResponse.getAdType()).thenReturn("html");
+        when(mockAdResponse.getNetworkType()).thenReturn("network_type");
+        when(mockAdResponse.getWidth()).thenReturn(320);
+        when(mockAdResponse.getHeight()).thenReturn(50);
+        when(mockAdResponse.getRequestId()).thenReturn("ac298c522b0e412b85ff81e4b9b51f03");
+
+        NetworkResponse networkResponse = new NetworkResponse(200, null, null, false, 300);
+
+        Location mockLocation = mock(Location.class);
+        when(mockLocation.getLatitude()).thenReturn(37.7833);
+        when(mockLocation.getLongitude()).thenReturn(-122.4167);
+        when(mockLocation.getAccuracy()).thenReturn((float) 2000.0);
+
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                Object[] args = invocation.getArguments();
+                BaseEvent baseEvent = (BaseEvent) args[0];
+                assertThat(baseEvent.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+                assertThat(baseEvent.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+                assertThat(baseEvent.getSamplingRate()).isEqualTo(0.1);
+                assertThat(baseEvent.getAdUnitId()).isEqualTo(adUnitId);
+                assertThat(baseEvent.getAdCreativeId()).isEqualTo("dsp_creative_id");
+                assertThat(baseEvent.getAdType()).isEqualTo("html");
+                assertThat(baseEvent.getAdNetworkType()).isEqualTo("network_type");
+                assertThat(baseEvent.getAdWidthPx()).isEqualTo(320);
+                assertThat(baseEvent.getAdHeightPx()).isEqualTo(50);
+                assertThat(baseEvent.getGeoLat()).isEqualTo(37.7833);
+                assertThat(baseEvent.getGeoLon()).isEqualTo(-122.4167);
+                assertThat(baseEvent.getGeoAccuracy()).isEqualTo(2000.0);
+                assertThat(baseEvent.getPerformanceDurationMs()).isEqualTo(300);
+                assertThat(baseEvent.getRequestId()).isEqualTo("ac298c522b0e412b85ff81e4b9b51f03");
+                assertThat(baseEvent.getRequestStatusCode()).isEqualTo(200);
+                assertThat(baseEvent.getRequestUri()).isEqualTo("testUrl");
+                return null;
+            }
+        }).when(mockEventDispatcher).dispatch(any(BaseEvent.class));
+
+        subject.logScribeEvent(mockAdResponse, networkResponse, mockLocation);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpResponsesTest.java b/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
similarity index 59%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpResponsesTest.java
rename to mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
index 54981b2e..f91576ec 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpResponsesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
@@ -1,4 +1,4 @@
-package com.mopub.mobileads.util;
+package com.mopub.network;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
@@ -12,7 +12,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
-public class HttpResponsesTest {
+public class HeaderUtilsTest {
     private TestHttpResponseWithHeaders response;
 
     @Before
@@ -23,71 +23,71 @@ public void setup() {
     @Test
     public void extractBooleanHeader_whenValueIsZero_shouldReturnFalse() throws Exception {
         response.addHeader(SCROLLABLE.getKey(), "0");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
 
         response.addHeader(SCROLLABLE.getKey(), "0");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, true)).isFalse();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, true)).isFalse();
     }
 
     @Test
     public void extractBooleanHeader_whenValueIsOne_shouldReturnTrue() throws Exception {
         response.addHeader(SCROLLABLE.getKey(), "1");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, false)).isTrue();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, false)).isTrue();
 
         response.addHeader(SCROLLABLE.getKey(), "1");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
     }
 
     @Test
     public void extractBooleanHeader_shouldReturnDefaultValue() throws Exception {
         // no header added to response
 
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
     }
 
     @Test
     public void extractIntegerHeader_shouldReturnIntegerValue() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "10");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(10);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(10);
 
         response.addHeader(AD_TIMEOUT.getKey(), "0");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(0);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(0);
 
         response.addHeader(AD_TIMEOUT.getKey(), "-2");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-2);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-2);
     }
 
     @Test
     public void extractIntegerHeader_withDoubleValue_shouldTruncateValue() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "3.14");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(3);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(3);
 
         response.addHeader(AD_TIMEOUT.getKey(), "-3.14");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-3);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-3);
     }
 
     @Test
     public void extractIntegerHeader_whenNoHeaderPresent_shouldReturnNull() throws Exception {
         // no header added to response
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
 
         response.addHeader(AD_TIMEOUT.getKey(), null);
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
     }
 
     @Test
     public void extractIntegerHeader_withNonsenseStringValue_shouldReturnNull() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "llama!!guy");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
     }
 
     @Test
     public void extractIntHeader_withInvalidHeader_shouldUseDefaultValue() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "5");
-        assertThat(HttpResponses.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(5);
+        assertThat(HeaderUtils.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(5);
 
         response.addHeader(AD_TIMEOUT.getKey(), "five!");
-        assertThat(HttpResponses.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(10);
+        assertThat(HeaderUtils.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(10);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
new file mode 100644
index 00000000..441ed4c2
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
@@ -0,0 +1,203 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.os.Handler;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.BasicNetwork;
+import com.mopub.volley.toolbox.DiskBasedCache;
+import com.mopub.volley.toolbox.HttpStack;
+import com.mopub.volley.toolbox.HurlStack;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.io.File;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubRequestQueueTest {
+
+    private MoPubRequestQueue subject;
+    private MoPubRequestQueue.DelayedRequestHelper delayedRequestHelper;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper;
+    @Mock private Handler mockHandler;
+
+    @Before
+    public void setUp() {
+        // NOTE: It's possible to start a new test with a queue set from a previous test suite
+        // Make sure we get a fresh one
+        Networking.setRequestQueueForTesting(null);
+
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        // Construct our dependencies & build the object
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activity);
+        final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), activity);
+        // No Custom SSL Factory
+
+        final String userAgent = Networking.getUserAgent(activity.getApplicationContext());
+        HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter);
+
+        Network network = new BasicNetwork(httpStack);
+        File volleyCacheDir = new File(activity.getCacheDir().getPath() + File.separator
+                + Networking.CACHE_DIRECTORY_NAME);
+        Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+        subject = new MoPubRequestQueue(cache, network);
+        subject.start();
+
+        delayedRequestHelper = subject.new DelayedRequestHelper(mockScribeRequest, 100, mockHandler);
+    }
+
+    @After
+    public void tearDown() {
+        // NOTE: Make sure that we clear the queue after the last test in the test suite runs so
+        // that the next test suite starts fresh
+        Networking.setRequestQueueForTesting(null);
+    }
+
+    @Test
+    public void addDelayedRequest_shouldStartDelayedRequestHelper_shouldPutRequestInMap() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper).start();
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest)).isEqualTo(mockDelayedRequestHelper);
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+    }
+
+    @Test
+    public void addDelayedRequest_shouldCancelPreexistingRequest() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper, never()).cancel();
+        verify(mockScribeRequest, never()).cancel();
+
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+    }
+
+    @Test
+    public void addDelayedRequest_withUniqueRequest_shouldNotCancelOtherRequests() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        verify(mockDelayedRequestHelper, never()).cancel();
+        verify(mockScribeRequest, never()).cancel();
+
+        verify(mockDelayedRequestHelper2).start();
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest)).isEqualTo(mockDelayedRequestHelper);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(2);
+    }
+
+    @Test
+    public void cancelAll_shouldCancelAllRequestsInTheDelayedRequestMapThatPassTheFilter() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+
+        subject.cancelAll(new RequestQueue.RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request == mockScribeRequest;
+            }
+        });
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+
+    @Test
+    public void cancelAll_shouldCancelAllRequestsWithMatchingObjectTag() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        when(mockScribeRequest.getTag()).thenReturn(1);
+        when(mockScribeRequest2.getTag()).thenReturn(2);
+
+        subject.cancelAll(1);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+
+    @Test
+    public void cancel_shouldCancelMatchingRequest() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        subject.cancel(mockScribeRequest);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+    
+    @Test
+    public void DelayedRequestHelper_start_shouldPostDelayedRunnable() throws Exception {
+        delayedRequestHelper.start();
+        verify(mockHandler).postDelayed(delayedRequestHelper.mDelayedRunnable, 100);
+    }
+
+    @Test
+    public void DelayedRequestHelper_cancel_shouldCancelDelayedRunnable() throws Exception {
+        delayedRequestHelper.cancel();
+        verify(mockHandler).removeCallbacks(delayedRequestHelper.mDelayedRunnable);
+    }
+
+    @Test
+    public void DelayedRequestHelper_Runnable_run_shouldRemoveRequestFromDelayedRequestsMap_shouldAddRequestToQueue() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, 100);
+        assertThat(subject.getDelayedRequests().entrySet().size()).isEqualTo(1);
+        MoPubRequestQueue.DelayedRequestHelper delayedRequestHelper = subject.getDelayedRequests().get(mockScribeRequest);
+
+        delayedRequestHelper.mDelayedRunnable.run();
+
+        assertThat(subject.getDelayedRequests().entrySet()).isEmpty();
+        verify(mockScribeRequest).setRequestQueue(subject);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java b/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
new file mode 100644
index 00000000..625c8a8c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
@@ -0,0 +1,78 @@
+package com.mopub.network;
+
+import android.app.Activity;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import java.util.concurrent.Semaphore;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class NetworkingTest {
+    private Activity context;
+    static volatile String sUserAgent;
+
+    @Before
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    @After
+    public void tearDown() {
+        Networking.clearForTesting();
+        sUserAgent = null;
+    }
+
+    @Test
+    public void getUserAgent_usesCachedUserAgent() {
+        Networking.setUserAgentForTesting("some cached user agent");
+        String userAgent = Networking.getUserAgent(context);
+
+        assertThat(userAgent).isEqualTo("some cached user agent");
+    }
+
+    @Test
+    public void getUserAgent_fromMainThread_shouldIncludeAndroid() throws InterruptedException {
+        context.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                String userAgent = Networking.getUserAgent(context);
+                assertThat(userAgent).containsIgnoringCase("android");
+            }
+        });
+    }
+
+    @Ignore("Flaky - setProperty + threading is unreliable in the test environment.")
+    @Test
+    public void getUserAgent_fromBackgroundThread_shouldIncludeAndroid() throws InterruptedException {
+        System.setProperty("http.agent", "system level user agent");
+
+        final Semaphore semaphore = new Semaphore(0);
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                sUserAgent = Networking.getUserAgent(context);
+                semaphore.release();
+            }
+        }).start();
+
+        semaphore.acquire();
+        assertThat(sUserAgent).isEqualTo("system level user agent");
+    }
+
+    public void getCachedUserAgent_usesCachedUserAgent() {
+        Networking.setUserAgentForTesting("some cached user agent");
+        String userAgent = Networking.getCachedUserAgent();
+
+        assertThat(userAgent).isEqualTo("some cached user agent");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java b/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
new file mode 100644
index 00000000..a5225b99
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
@@ -0,0 +1,68 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Reflection;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class PlayServicesUrlRewriterTest {
+
+    private Reflection.MethodBuilder methodBuilder;
+    private PlayServicesUrlRewriter subject;
+
+    @Before
+    public void setUp() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        GpsHelper.setClassNamesForTesting();
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        reset(methodBuilder);
+        subject = new PlayServicesUrlRewriter("sha:testDeviceID", context);
+    }
+
+    @Test
+    public void rewriteUrl_whenPlayServicesPresent_shouldUsePlayServicesValue() throws Exception {
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED
+        );
+
+        assertThat(subject.rewriteUrl("http://ads.mopub.com/m/ad?ad_id=abcece&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track"))
+                .isEqualToIgnoringCase("http://ads.mopub.com/m/ad?ad_id=abcece&udid=ifa%3A38400000-8cf0-11bd-b23e-10b96e40000d&dnt=1");
+    }
+
+    @Test
+    public void rewriteUrl_whenPlayServicesNotPresent_shouldUseDeviceValue() throws Exception {
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        // return error code so it fails
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
+
+        assertThat(subject.rewriteUrl("http://ads.mopub.com/m/ad?ad_id=abcece&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track"))
+                .isEqualToIgnoringCase("http://ads.mopub.com/m/ad?ad_id=abcece&udid=sha%3AtestDeviceId&dnt=0");
+    }
+
+    @Test
+    public void rewriteUrl_noTemplates_shouldReturnIdentical() throws Exception {
+        assertThat(subject.rewriteUrl("http://ads.mopub.com/m/ad")).isEqualTo("http://ads.mopub.com/m/ad");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
new file mode 100644
index 00000000..8cadcfaf
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
@@ -0,0 +1,138 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class RequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+    }
+
+    @Test
+    public void makeRequest_shouldAddRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).add(mockScribeRequest);
+    }
+
+
+    @Test
+    public void makeRequest_shouldCancelTheCurrentRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        Request<?> request = subject.getCurrentRequest();
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).cancel(request);
+    }
+
+    @Test
+    public void cancelRequest_shouldCancelRequestInQueue_shouldClearRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullRequestQueue_shouldOnlyClearCurrentRequest() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullCurrentRequest_shouldOnlyClearCurrentRequest() throws Exception {
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void makeRequestInternal_shouldAddNewRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).add(nextRequest);
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withRetryCountGreaterThan0_shouldAddNewDelayedRequestToQueue() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).addDelayedRequest(nextRequest, 100);
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withNullRequestQueue_shouldClearCurrentRequest_shouldNotAddRequestToQueue() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void clearRequest_shouldSetCurrentRequestToNull() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        assertThat(subject.getCurrentRequest()).isNotNull();
+        subject.clearRequest();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
new file mode 100644
index 00000000..56a07c86
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
@@ -0,0 +1,129 @@
+package com.mopub.network;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeBackoffPolicyTest {
+
+    private ScribeBackoffPolicy subject;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeBackoffPolicy();
+    }
+
+    @Test
+    public void backoff_with503Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(503, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_with504Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(504, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_withNoConnectionError_shouldUpdateBackoffTime() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test(expected = VolleyError.class)
+    public void backoff_withOtherErrorType_shouldRethrowException() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(500, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        subject.backoff(volleyError);
+    }
+
+    @Test
+    public void backoff_shouldUpdateBackoffTime5TimesMax() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(120000);
+        assertThat(subject.getRetryCount()).isEqualTo(2);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(240000);
+        assertThat(subject.getRetryCount()).isEqualTo(3);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(480000);
+        assertThat(subject.getRetryCount()).isEqualTo(4);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(960000);
+        assertThat(subject.getRetryCount()).isEqualTo(5);
+        assertThat(subject.hasAttemptRemaining()).isFalse();
+    }
+
+    @Test(expected = NoConnectionError.class)
+    public void backoff_withNoAttemptsRemaining_shouldRethrowVolleyException() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        try {
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+        } catch (Exception e) {
+            fail("Exception should not be thrown from above backoffs.");
+        }
+
+        subject.backoff(volleyError);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
new file mode 100644
index 00000000..854b26a8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
@@ -0,0 +1,77 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeRequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+    }
+
+    @Test
+    public void createRequest_shouldCreateNewScribeRequest() throws Exception {
+        Request request = subject.createRequest();
+        assertThat(request).isEqualTo(mockScribeRequest);
+    }
+
+    @Test
+    public void onResponse_shouldClearRequest() throws Exception {
+        subject.onResponse();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffApplied_shouldCallBackoff_shouldMakeDelayedRequest() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+
+        VolleyError volleyError = new NoConnectionError();
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue).addDelayedRequest(mockScribeRequest, 100);
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffNotApplied_shouldClearRequest() throws Exception {
+        reset(mockRequestQueue);
+
+        VolleyError volleyError = new NoConnectionError();
+        doThrow(new VolleyError()).when(mockScribeBackoffPolicy).backoff(volleyError);
+
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue, never()).add(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
new file mode 100644
index 00000000..7bf2d5bb
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.app.Activity;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONArray;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeRequestTest {
+
+    private ScribeRequest subject;
+    @Mock private List<BaseEvent> mockEvents;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequest.Listener mockListener;
+
+    @Before
+    public void setUp() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.getRequestQueue(activity);
+
+        subject = new ScribeRequest("url", mockEvents, mockEventSerializer, mockListener);
+    }
+
+    @Test
+    public void constructor_shouldSetShouldCacheToFalse() throws Exception {
+        assertThat(subject.shouldCache()).isFalse();
+    }
+
+    @Test
+    public void constructor_shouldSetRetryPolicyToDefaultRetryPolicy() throws Exception {
+        assertThat(subject.getRetryPolicy()).isExactlyInstanceOf(DefaultRetryPolicy.class);
+    }
+
+    @Test
+    public void getParams_returnJsonSerializedEventsInMap() throws Exception {
+        JSONArray mockJsonArray = mock(JSONArray.class);
+        when(mockJsonArray.toString()).thenReturn("jsonArrayToString");
+        when(mockEventSerializer.serializeAsJson(mockEvents)).thenReturn(mockJsonArray);
+
+        Map<String, String> params = subject.getParams();
+
+        verify(mockEventSerializer).serializeAsJson(mockEvents);
+        assertThat(params.keySet().size()).isEqualTo(1);
+        assertThat(params.get("log")).isEqualTo("jsonArrayToString");
+    }
+    
+    @Test
+    public void parseNetworkResponse_shouldReturnSuccessResponse() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), new HashMap<String, String>(), false);
+
+        Response<Void> response = subject.parseNetworkResponse(networkResponse);
+
+        assertThat(response.isSuccess()).isTrue();
+    }
+
+    @Test
+    public void deliverResponse_shouldNotifyListener() throws Exception {
+        subject.deliverResponse(null);
+
+        verify(mockListener).onResponse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
new file mode 100644
index 00000000..1ae6f03f
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
@@ -0,0 +1,113 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.VastErrorCode;
+import com.mopub.mobileads.VastTracker;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.util.Arrays;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class TrackingRequestTest {
+
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    private Context context;
+    private String url;
+
+
+    @Before
+    public void setup() {
+        context = (Context) Robolectric.buildActivity(Activity.class).create().get();
+        url = "testUrl";
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void makeTrackingHttpRequest_shouldMakeTrackingHttpRequestWithWebViewUserAgent() throws Exception {
+        TrackingRequest.makeTrackingHttpRequest(url, context);
+
+        verify(mockRequestQueue).add(any(TrackingRequest.class));
+    }
+
+    @Test
+    public void makeTrackingHttpRequest_withNullUrl_shouldNotMakeTrackingHttpRequest() throws Exception {
+        TrackingRequest.makeTrackingHttpRequest((String) null, context);
+
+        verify(mockRequestQueue, never()).add(any(TrackingRequest.class));
+    }
+
+    @Test
+    public void makeTrackingHttpRequest_withNullContext_shouldNotMakeTrackingHttpRequest() throws Exception {
+        TrackingRequest.makeTrackingHttpRequest(url, null);
+
+        verify(mockRequestQueue, never()).add(any(TrackingRequest.class));
+    }
+
+    @Test
+    public void makeVastTrackingHttpRequest_shouldSubstituteMacros_shouldMakeSingleRequest() throws Exception {
+        VastTracker vastTracker = new VastTracker("uri?errorcode=[ERRORCODE]&contentplayhead=[CONTENTPLAYHEAD]&asseturi=[ASSETURI]");
+        TrackingRequest.makeVastTrackingHttpRequest(
+                Arrays.asList(vastTracker),
+                VastErrorCode.UNDEFINED_ERROR,
+                123,
+                "assetUri",
+                context
+        );
+
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "uri?errorcode=900&contentplayhead=00:00:00.123&asseturi=assetUri")));
+
+        TrackingRequest.makeVastTrackingHttpRequest(
+                Arrays.asList(vastTracker),
+                VastErrorCode.UNDEFINED_ERROR,
+                123,
+                "assetUri",
+                context
+        );
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void makeVastTrackingHttpRequest_withRepeatableRequest_shouldMakeMultipleTrackingRequests() throws Exception {
+        VastTracker vastTracker = new VastTracker("uri?errorcode=[ERRORCODE]&contentplayhead=[CONTENTPLAYHEAD]&asseturi=[ASSETURI]");
+        TrackingRequest.makeVastTrackingHttpRequest(
+                Arrays.asList(vastTracker),
+                VastErrorCode.UNDEFINED_ERROR,
+                123,
+                "assetUri",
+                context
+        );
+
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "uri?errorcode=900&contentplayhead=00:00:00.123&asseturi=assetUri")));
+
+        TrackingRequest.makeVastTrackingHttpRequest(
+                Arrays.asList(vastTracker),
+                VastErrorCode.UNDEFINED_ERROR,
+                123,
+                "assetUri",
+                context
+        );
+
+        verify(mockRequestQueue).add(argThat(isUrl(
+                "uri?errorcode=900&contentplayhead=00:00:00.123&asseturi=assetUri")));
+    }
+}
diff --git a/mopub-sdk/src/test/resources/org.robolectric.Config.properties b/mopub-sdk/src/test/resources/org.robolectric.Config.properties
new file mode 100644
index 00000000..973e581e
--- /dev/null
+++ b/mopub-sdk/src/test/resources/org.robolectric.Config.properties
@@ -0,0 +1,2 @@
+emulateSdk=18
+shadows=com.mopub.nativeads.test.support.MoPubShadowDisplay,com.mopub.nativeads.test.support.MoPubShadowBitmap,com.mopub.mobileads.test.support.ShadowVastVideoView
diff --git a/pom.xml b/pom.xml
index 7d637a7c..be233e50 100644
--- a/pom.xml
+++ b/pom.xml
@@ -16,6 +16,12 @@
     <packaging>pom</packaging>
 
     <repositories>
+        <repository>
+            <id>jcenter</id>
+            <name>JCenter</name>
+            <url>http://jcenter.bintray.com</url>
+        </repository>
+
         <repository>
             <id>andsupport</id>
             <name>Android Support</name>
@@ -32,7 +38,5 @@
     <modules>
         <module>mopub-sdk</module>
         <module>mopub-sample</module>
-        <module>robotium-sample</module>
-        <module>robotium-tests</module>
     </modules>
-</project>
\ No newline at end of file
+</project>
diff --git a/robotium-sample/pom.xml b/robotium-sample/pom.xml
index 3481483f..468cbf9b 100644
--- a/robotium-sample/pom.xml
+++ b/robotium-sample/pom.xml
@@ -22,7 +22,7 @@
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
             <version>1.0.0-SNAPSHOT</version>
-            <type>jar</type>
+            <type>aar</type>
         </dependency>
 
 
@@ -86,13 +86,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/robotium-tests/pom.xml b/robotium-tests/pom.xml
index c3710758..99a113ce 100644
--- a/robotium-tests/pom.xml
+++ b/robotium-tests/pom.xml
@@ -27,8 +27,8 @@
 
         <dependency>
             <groupId>com.google.android.gms</groupId>
-            <artifactId>play-services</artifactId>
-            <version>5.0.89</version>
+            <artifactId>play-services-ads</artifactId>
+            <version>7.0.0</version>
             <type>aar</type>
         </dependency>
 
@@ -62,17 +62,16 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
-                    <test>
-                        <skip>true</skip>
-                    </test>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
                 <extensions>true</extensions>
