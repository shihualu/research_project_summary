diff --git a/.travis.yml b/.travis.yml
index ee50d51cb..963e19f6e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,7 @@
 language: java
 
 jdk:
-  - oraclejdk7
+  - openjdk7
   - oraclejdk8
 
 install: mvn -f gson install -DskipTests=true
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 75d3ec2dd..12949841b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,16 @@
 Change Log
 ==========
 
+## Version 2.8.2
+_2017-09-19_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.1...gson-parent-2.8.2)
+ * Introduced a new API, `JsonElement.deepCopy()`
+ * Numerous other bugfixes
+
+## Version 2.8.1
+_2017-05-30_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.0...gson-parent-2.8.1)
+ * New: `JsonObject.keySet()`
+ * `@JsonAdapter` annotation can now use `JsonSerializer` and `JsonDeserializer` as well.
+
 ## Version 2.8
 _2016-10-26_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.7...gson-parent-2.8.0)
  * New: `TypeToken.getParameterized()` and `TypeToken.getArray()` make it easier to
@@ -73,7 +83,7 @@ _2015-10-04_
 
 ## Version 2.3.1
 
-__2014-11-20_
+_2014-11-20_
 
  * Added support to serialize objects with self-referential fields. The self-referential field is set to null in JSON. Previous version of Gson threw a StackOverflowException on encountering any self-referential fields.
    * The most visible impact of this is that Gson can now serialize Throwable (Exception and Error)
diff --git a/GsonDesignDocument.md b/GsonDesignDocument.md
index 51f150a92..2c3702ee1 100644
--- a/GsonDesignDocument.md
+++ b/GsonDesignDocument.md
@@ -1,4 +1,4 @@
-#Gson Design Document
+# Gson Design Document
 
 This document presents issues that we faced while designing Gson. It is meant for advanced users or developers working on Gson. If you are interested in learning how to use Gson, see its user guide. 
 
diff --git a/README.md b/README.md
index 6007ee1c5..8733722a1 100644
--- a/README.md
+++ b/README.md
@@ -5,34 +5,49 @@
 [![Javadoc](https://javadoc-emblem.rhcloud.com/doc/com.google.code.gson/gson/badge.svg)](http://www.javadoc.io/doc/com.google.code.gson/gson)
 
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
-Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of. 
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
 
-There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
+There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.
 
-###*Gson Goals*
+### Gson Goals
   * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
-###*Gson Download and Maven*
+### Gson Download and Maven
+  * To use Gson in Android
+```gradle
+dependencies {
+    compile 'com.google.code.gson:gson:2.8.2'
+}
+```
+
   * [Gson Download](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) downloads at Maven Central
-  * For Maven check "Dependency Information" tab, on the left side.
+  * To use Gson with Maven
+  ```xml
+<dependency>
+    <groupId>com.google.code.gson</groupId>
+    <artifactId>gson</artifactId>
+    <version>2.8.2</version>
+</dependency>
+```
 
-###*Gson Documentation*
+### Gson Documentation
   * Gson [API](http://www.javadoc.io/doc/com.google.code.gson/gson): Javadocs for the current Gson release
   * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
   * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
-  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
 
-Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
+Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions.
 
-###*Gson-related Content Created by Third Parties*
+### Gson-related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
   * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
+  * [Gson API Report](https://abi-laboratory.pro/java/tracker/timeline/gson/)
 
-###*License*
+### License
 
 Gson is released under the [Apache 2.0 license](LICENSE).
 
diff --git a/ReleaseProcess.md b/ReleaseProcess.md
index f75ce398e..f34f47ecc 100644
--- a/ReleaseProcess.md
+++ b/ReleaseProcess.md
@@ -3,10 +3,10 @@
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
 1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
-1. Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
+1. (obsolete step) Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
 1. Ensure all changelists are code-reviewed and have +1
-1. Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
-1. `cd gson`; ensure there are no open files and all changes are committed.
+1. (obsolete step) Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
+1. `cd gson` to the parent directory; ensure there are no open files and all changes are committed.
 1. Run `mvn release:clean`
 1. Do a dry run: `mvn release:prepare -DdryRun=true`
 1. Start the release: `mvn release:prepare`
diff --git a/UserGuide.md b/UserGuide.md
index f7b30bc76..4feaf11c6 100644
--- a/UserGuide.md
+++ b/UserGuide.md
@@ -1,36 +1,37 @@
-#Gson User Guide
+# Gson User Guide
 
 1. [Overview](#TOC-Overview)
 2. [Goals for Gson](#TOC-Goals-for-Gson)
 3. [Gson Performance and Scalability](#TOC-Gson-Performance-and-Scalability)
 4. [Gson Users](#TOC-Gson-Users)
 5. [Using Gson](#TOC-Using-Gson)
-  * [Using Gson with Maven](#TOC-Gson-With-Maven)
-  * [Primitives Examples](#TOC-Primitives-Examples)
-  * [Object Examples](#TOC-Object-Examples)
-  * [Finer Points with Objects](#TOC-Finer-Points-with-Objects)
-  * [Nested Classes (including Inner Classes)](#TOC-Nested-Classes-including-Inner-Classes-)
-  * [Array Examples](#TOC-Array-Examples)
-  * [Collections Examples](#TOC-Collections-Examples)
-    * [Collections Limitations](#TOC-Collections-Limitations)
-  * [Serializing and Deserializing Generic Types](#TOC-Serializing-and-Deserializing-Generic-Types)
-  * [Serializing and Deserializing Collection with Objects of Arbitrary Types](#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types)
-  * [Built-in Serializers and Deserializers](#TOC-Built-in-Serializers-and-Deserializers)
-  * [Custom Serialization and Deserialization](#TOC-Custom-Serialization-and-Deserialization)
-    * [Writing a Serializer](#TOC-Writing-a-Serializer)
-    * [Writing a Deserializer](#TOC-Writing-a-Deserializer)
-  * [Writing an Instance Creator](#TOC-Writing-an-Instance-Creator)
-    * [InstanceCreator for a Parameterized Type](#TOC-InstanceCreator-for-a-Parameterized-Type)
-  * [Compact Vs. Pretty Printing for JSON Output Format](#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format)
-  * [Null Object Support](#TOC-Null-Object-Support)
-  * [Versioning Support](#TOC-Versioning-Support)
-  * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
-    * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
-    * [Gson's `@Expose`](#TOC-Gson-s-Expose)
-    * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
-  * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
-  * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
-  * [Streaming](#TOC-Streaming)
+   * [Using Gson with Gradle/Android](#TOC-Gson-With-Gradle)
+   * [Using Gson with Maven](#TOC-Gson-With-Maven)
+   * [Primitives Examples](#TOC-Primitives-Examples)
+   * [Object Examples](#TOC-Object-Examples)
+   * [Finer Points with Objects](#TOC-Finer-Points-with-Objects)
+   * [Nested Classes (including Inner Classes)](#TOC-Nested-Classes-including-Inner-Classes-)
+   * [Array Examples](#TOC-Array-Examples)
+   * [Collections Examples](#TOC-Collections-Examples)
+     * [Collections Limitations](#TOC-Collections-Limitations)
+   * [Serializing and Deserializing Generic Types](#TOC-Serializing-and-Deserializing-Generic-Types)
+   * [Serializing and Deserializing Collection with Objects of Arbitrary Types](#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types)
+   * [Built-in Serializers and Deserializers](#TOC-Built-in-Serializers-and-Deserializers)
+   * [Custom Serialization and Deserialization](#TOC-Custom-Serialization-and-Deserialization)
+     * [Writing a Serializer](#TOC-Writing-a-Serializer)
+     * [Writing a Deserializer](#TOC-Writing-a-Deserializer)
+   * [Writing an Instance Creator](#TOC-Writing-an-Instance-Creator)
+     * [InstanceCreator for a Parameterized Type](#TOC-InstanceCreator-for-a-Parameterized-Type)
+   * [Compact Vs. Pretty Printing for JSON Output Format](#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format)
+   * [Null Object Support](#TOC-Null-Object-Support)
+   * [Versioning Support](#TOC-Versioning-Support)
+   * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
+     * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
+     * [Gson's `@Expose`](#TOC-Gson-s-Expose)
+     * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
+   * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
+   * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
+   * [Streaming](#TOC-Streaming)
 6. [Issues in Designing Gson](#TOC-Issues-in-Designing-Gson)
 7. [Future Enhancements to Gson](#TOC-Future-Enhancements-to-Gson)
 
@@ -62,7 +63,7 @@ Note: Delete the `disabled_` prefix to run these tests. We use this prefix to pr
 
 ## <a name="TOC-Gson-Users"></a>Gson Users
 
-Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details [here](https://sites.google.com/site/gson/gson-users).
+Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.
 
 ## <a name="TOC-Using-Gson"></a>Using Gson
 
@@ -70,6 +71,12 @@ The primary class to use is [`Gson`](gson/src/main/java/com/google/gson/Gson.jav
 
 The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.
 
+## <a name="TOC-Gson-With-Gradle"></a>Using Gson with Gradle/Android
+```
+dependencies {
+    compile 'com.google.code.gson:gson:2.8.2'
+}
+```
 ## <a name="TOC-Gson-With-Maven"></a>Using Gson with Maven
 To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:
 
@@ -79,7 +86,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.7</version>
+      <version>2.8.2</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>
@@ -137,14 +144,14 @@ BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
 
 #### <a name="TOC-Finer-Points-with-Objects"></a>**Finer Points with Objects**
 
-* It is perfectly fine (and recommended) to use private fields
+* It is perfectly fine (and recommended) to use private fields.
 * There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
 * If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
-* This implementation handles nulls correctly
-* While serializing, a null field is skipped from the output
-* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to null
-* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
-* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
+* This implementation handles nulls correctly.
+* While serializing, a null field is omitted from the output.
+* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.
+* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization.
+* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.
 
 ### <a name="TOC-Nested-Classes-including-Inner-Classes-"></a>Nested Classes (including Inner Classes)
 
@@ -655,7 +662,7 @@ In addition Gson's object model and data binding, you can use Gson to read from
 
 ## <a name="TOC-Issues-in-Designing-Gson"></a>Issues in Designing Gson
 
-See the [Gson design document](https://sites.google.com/site/gson/gson-design-document "Gson design document") for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.
+See the [Gson design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md "Gson design document") for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.
 
 ## <a name="TOC-Future-Enhancements-to-Gson"></a>Future Enhancements to Gson
 
diff --git a/examples/android-proguard-example/proguard.cfg b/examples/android-proguard-example/proguard.cfg
index 5db375b8b..6c5709f3d 100644
--- a/examples/android-proguard-example/proguard.cfg
+++ b/examples/android-proguard-example/proguard.cfg
@@ -7,7 +7,7 @@
 -keepattributes *Annotation*
 
 # Gson specific classes
--keep class sun.misc.Unsafe { *; }
+-dontwarn sun.misc.**
 #-keep class com.google.gson.stream.** { *; }
 
 # Application classes that will be serialized/deserialized over Gson
diff --git a/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
index 6d02b958c..36e06da20 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
@@ -33,7 +33,7 @@
     // copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a
     @Override
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-        for (Class<?> t = type.getRawType(); t != Object.class; t = t.getSuperclass()) {
+        for (Class<?> t = type.getRawType(); (t != Object.class) && (t.getSuperclass() != null); t = t.getSuperclass()) {
             for (Method m : t.getDeclaredMethods()) {
                 if (m.isAnnotationPresent(PostConstruct.class)) {
                     m.setAccessible(true);
@@ -73,4 +73,4 @@ public PostConstructAdapter(TypeAdapter<T> delegate, Method method) {
             delegate.write(out, value);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java b/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
index 5e8c0ccee..1e889d373 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
@@ -229,7 +229,7 @@ private static Date parse(String date, ParsePosition pos) throws ParseException
     } catch (IllegalArgumentException e) {
       fail = e;
     }
-    String input = (date == null) ? null : ('"' + date + "'");
+    String input = (date == null) ? null : ("'" + date + "'");
     throw new ParseException("Failed to parse date [" + input + "]: " + fail.getMessage(), pos.getIndex());
   }
 
diff --git a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
index 1c934b11e..7bd0a520d 100644
--- a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
+++ b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
@@ -23,6 +23,9 @@
 
 import junit.framework.TestCase;
 
+import java.util.Arrays;
+import java.util.List;
+
 public class PostConstructAdapterFactoryTest extends TestCase {
     public void test() throws Exception {
         Gson gson = new GsonBuilder()
@@ -37,14 +40,73 @@ public void test() throws Exception {
         }
     }
 
+    public void testList() {
+        MultipleSandwiches sandwiches = new MultipleSandwiches(Arrays.asList(
+            new Sandwich("white", "cheddar"),
+            new Sandwich("whole wheat", "swiss")));
+
+        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();
+
+        // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
+        String json = gson.toJson(sandwiches);
+        assertEquals("{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},{\"bread\":\"whole wheat\",\"cheese\":\"swiss\"}]}", json);
+
+        MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);
+        assertEquals(sandwiches, sandwichesFromJson);
+    }
+
     static class Sandwich {
-        String bread;
-        String cheese;
+        public String bread;
+        public String cheese;
 
-        @PostConstruct void validate() {
+        public Sandwich(String bread, String cheese) {
+            this.bread = bread;
+            this.cheese = cheese;
+        }
+
+        @PostConstruct private void validate() {
             if (bread.equals("cheesey bread") && cheese != null) {
                 throw new IllegalArgumentException("too cheesey");
             }
         }
+
+        public boolean equals(Object o) {
+            if (o == this) {
+                return true;
+            }
+            if (!(o instanceof Sandwich)) {
+                return false;
+            }
+            final Sandwich other = (Sandwich) o;
+            if (this.bread == null ? other.bread != null : !this.bread.equals(other.bread)) {
+                return false;
+            }
+            if (this.cheese == null ? other.cheese != null : !this.cheese.equals(other.cheese)) {
+                return false;
+            }
+            return true;
+        }
+    }
+
+    static class MultipleSandwiches {
+        public List<Sandwich> sandwiches;
+
+        public MultipleSandwiches(List<Sandwich> sandwiches) {
+            this.sandwiches = sandwiches;
+        }
+
+        public boolean equals(Object o) {
+            if (o == this) {
+                return true;
+            }
+            if (!(o instanceof MultipleSandwiches)) {
+                return false;
+            }
+            final MultipleSandwiches other = (MultipleSandwiches) o;
+            if (this.sandwiches == null ? other.sandwiches != null : !this.sandwiches.equals(other.sandwiches)) {
+                return false;
+            }
+            return true;
+        }
     }
 }
diff --git a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
index 902dc4774..56e54290c 100644
--- a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
+++ b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
@@ -22,6 +22,7 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
+import com.google.gson.JsonParseException;
 import junit.framework.TestCase;
 
 import com.google.gson.Gson;
@@ -76,4 +77,13 @@ public void testNullDateSerialization() {
     String json = gson.toJson(null, Date.class);
     assertEquals("null", json);
   }
+
+  public void testWellFormedParseException() {
+    try {
+      gson.fromJson("2017-06-20T14:32:30", Date.class);
+      fail("No exception");
+    } catch (JsonParseException exe) {
+      assertEquals(exe.getMessage(), "java.text.ParseException: Failed to parse date ['2017-06-20T14']: 2017-06-20T14");
+    }
+  }
 }
diff --git a/gson/pom.xml b/gson/pom.xml
index e3fd6a389..cf0594633 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.8.1-SNAPSHOT</version>
+    <version>2.8.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>
@@ -43,6 +43,19 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+          </archive>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.felix</groupId>
+        <artifactId>maven-bundle-plugin</artifactId>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/gson/src/main/java/com.google.gson/module-info.java b/gson/src/main/java/com.google.gson/module-info.java
new file mode 100644
index 000000000..d567d8ce5
--- /dev/null
+++ b/gson/src/main/java/com.google.gson/module-info.java
@@ -0,0 +1,8 @@
+module com.google.gson {
+	exports com.google.gson;
+	exports com.google.gson.annotations;
+	exports com.google.gson.reflect;
+	exports com.google.gson.stream;
+
+	requires java.sql;
+}
diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
index 35b803054..0cbf77cea 100644
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
@@ -16,16 +16,23 @@
 
 package com.google.gson;
 
-import java.lang.reflect.Type;
+import java.io.IOException;
 import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
 
+import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import com.google.gson.util.VersionUtils;
 
 /**
  * This type adapter supports three subclasses of date: Date, Timestamp, and
@@ -34,85 +41,125 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
+final class DefaultDateTypeAdapter extends TypeAdapter<Date> {
 
-  // TODO: migrate to streaming adapter
+  private static final String SIMPLE_NAME = "DefaultDateTypeAdapter";
 
-  private final DateFormat enUsFormat;
-  private final DateFormat localFormat;
+  private final Class<? extends Date> dateType;
 
-  DefaultDateTypeAdapter() {
-    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
-        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+  /**
+   * List of 1 or more different date formats used for de-serialization attempts.
+   * The first of them is used for serialization as well.
+   */
+  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
+
+  DefaultDateTypeAdapter(Class<? extends Date> dateType) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
   }
 
-  DefaultDateTypeAdapter(String datePattern) {
-    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(new SimpleDateFormat(datePattern, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(new SimpleDateFormat(datePattern));
+    }
   }
 
-  DefaultDateTypeAdapter(int style) {
-    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateInstance(style, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateInstance(style));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateFormat(style));
+    }
   }
 
   public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
-    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    this(Date.class, dateStyle, timeStyle);
   }
 
-  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {
-    this.enUsFormat = enUsFormat;
-    this.localFormat = localFormat;
+  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(dateStyle, timeStyle));
+    }
+  }
+
+  private static Class<? extends Date> verifyDateType(Class<? extends Date> dateType) {
+    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {
+      throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType);
+    }
+    return dateType;
   }
 
   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
   // See issue 162
   @Override
-  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {
-    synchronized (localFormat) {
-      String dateFormatAsString = enUsFormat.format(src);
-      return new JsonPrimitive(dateFormatAsString);
+  public void write(JsonWriter out, Date value) throws IOException {
+    if (value == null) {
+      out.nullValue();
+      return;
+    }
+    synchronized(dateFormats) {
+      String dateFormatAsString = dateFormats.get(0).format(value);
+      out.value(dateFormatAsString);
     }
   }
 
   @Override
-  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
-      throws JsonParseException {
-    if (!(json instanceof JsonPrimitive)) {
-      throw new JsonParseException("The date should be a string value");
+  public Date read(JsonReader in) throws IOException {
+    if (in.peek() == JsonToken.NULL) {
+      in.nextNull();
+      return null;
     }
-    Date date = deserializeToDate(json);
-    if (typeOfT == Date.class) {
+    Date date = deserializeToDate(in.nextString());
+    if (dateType == Date.class) {
       return date;
-    } else if (typeOfT == Timestamp.class) {
+    } else if (dateType == Timestamp.class) {
       return new Timestamp(date.getTime());
-    } else if (typeOfT == java.sql.Date.class) {
+    } else if (dateType == java.sql.Date.class) {
       return new java.sql.Date(date.getTime());
     } else {
-      throw new IllegalArgumentException(getClass() + " cannot deserialize to " + typeOfT);
+      // This must never happen: dateType is guarded in the primary constructor
+      throw new AssertionError();
     }
   }
 
-  private Date deserializeToDate(JsonElement json) {
-    synchronized (localFormat) {
-      try {
-      	return localFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {}
-      try {
-        return enUsFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {}
+  private Date deserializeToDate(String s) {
+    synchronized (dateFormats) {
+      for (DateFormat dateFormat : dateFormats) {
+        try {
+          return dateFormat.parse(s);
+        } catch (ParseException ignored) {}
+      }
       try {
-        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));
+        return ISO8601Utils.parse(s, new ParsePosition(0));
       } catch (ParseException e) {
-        throw new JsonSyntaxException(json.getAsString(), e);
+        throw new JsonSyntaxException(s, e);
       }
     }
   }
 
   @Override
   public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(DefaultDateTypeAdapter.class.getSimpleName());
-    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');
-    return sb.toString();
+    DateFormat defaultFormat = dateFormats.get(0);
+    if (defaultFormat instanceof SimpleDateFormat) {
+      return SIMPLE_NAME + '(' + ((SimpleDateFormat) defaultFormat).toPattern() + ')';
+    } else {
+      return SIMPLE_NAME + '(' + defaultFormat.getClass().getSimpleName() + ')';
+    }
   }
 }
diff --git a/gson/src/main/java/com/google/gson/FieldAttributes.java b/gson/src/main/java/com/google/gson/FieldAttributes.java
index bcabff14a..4ee906a60 100644
--- a/gson/src/main/java/com/google/gson/FieldAttributes.java
+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java
@@ -136,9 +136,13 @@ public boolean hasModifier(int modifier) {
   }
 
   /**
-   * This is exposed internally only for the removing synthetic fields from the JSON output.
+   * Returns the value of the field represented by this {@code Field}, on
+   * the specified object. The value is automatically wrapped in an
+   * object if it has a primitive type.
    *
-   * @return true if the field is synthetic; otherwise false
+   * @return the value of the represented field in object
+   * {@code obj}; primitive values are wrapped in an appropriate
+   * object before being returned
    * @throws IllegalAccessException
    * @throws IllegalArgumentException
    */
diff --git a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
index 3b325a4fd..ad7bb6c89 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
@@ -122,7 +122,7 @@
    */
   static String separateCamelCase(String name, String separator) {
     StringBuilder translation = new StringBuilder();
-    for (int i = 0; i < name.length(); i++) {
+    for (int i = 0, length = name.length(); i < length; i++) {
       char character = name.charAt(i);
       if (Character.isUpperCase(character) && translation.length() != 0) {
         translation.append(separator);
@@ -139,8 +139,9 @@ static String upperCaseFirstLetter(String name) {
     StringBuilder fieldNameBuilder = new StringBuilder();
     int index = 0;
     char firstCharacter = name.charAt(index);
+    int length = name.length();
 
-    while (index < name.length() - 1) {
+    while (index < length - 1) {
       if (Character.isLetter(firstCharacter)) {
         break;
       }
@@ -149,10 +150,6 @@ static String upperCaseFirstLetter(String name) {
       firstCharacter = name.charAt(++index);
     }
 
-    if (index == name.length()) {
-      return fieldNameBuilder.toString();
-    }
-
     if (!Character.isUpperCase(firstCharacter)) {
       String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);
       return fieldNameBuilder.append(modifiedTarget).toString();
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index e97b16279..5b1c6c833 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -25,6 +25,7 @@
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -109,7 +110,7 @@
   static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
   static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
 
-  private static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};
+  private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
 
   /**
@@ -124,18 +125,28 @@
 
   private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();
 
-  private final List<TypeAdapterFactory> factories;
   private final ConstructorConstructor constructorConstructor;
-
-  private final Excluder excluder;
-  private final FieldNamingStrategy fieldNamingStrategy;
-  private final boolean serializeNulls;
-  private final boolean htmlSafe;
-  private final boolean generateNonExecutableJson;
-  private final boolean prettyPrinting;
-  private final boolean lenient;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
+  final List<TypeAdapterFactory> factories;
+
+  final Excluder excluder;
+  final FieldNamingStrategy fieldNamingStrategy;
+  final Map<Type, InstanceCreator<?>> instanceCreators;
+  final boolean serializeNulls;
+  final boolean complexMapKeySerialization;
+  final boolean generateNonExecutableJson;
+  final boolean htmlSafe;
+  final boolean prettyPrinting;
+  final boolean lenient;
+  final boolean serializeSpecialFloatingPointValues;
+  final String datePattern;
+  final int dateStyle;
+  final int timeStyle;
+  final LongSerializationPolicy longSerializationPolicy;
+  final List<TypeAdapterFactory> builderFactories;
+  final List<TypeAdapterFactory> builderHierarchyFactories;
+
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
    * following settings:
@@ -175,23 +186,36 @@ public Gson() {
         Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
         DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());
+        LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
+        Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
+        Collections.<TypeAdapterFactory>emptyList());
   }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
       final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
-      LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
-    this.constructorConstructor = new ConstructorConstructor(instanceCreators);
+      LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
+      int timeStyle, List<TypeAdapterFactory> builderFactories,
+      List<TypeAdapterFactory> builderHierarchyFactories,
+      List<TypeAdapterFactory> factoriesToBeAdded) {
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
+    this.instanceCreators = instanceCreators;
+    this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.serializeNulls = serializeNulls;
+    this.complexMapKeySerialization = complexMapKeySerialization;
     this.generateNonExecutableJson = generateNonExecutableGson;
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
     this.lenient = lenient;
+    this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
+    this.longSerializationPolicy = longSerializationPolicy;
+    this.datePattern = datePattern;
+    this.dateStyle = dateStyle;
+    this.timeStyle = timeStyle;
+    this.builderFactories = builderFactories;
+    this.builderHierarchyFactories = builderHierarchyFactories;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -202,8 +226,8 @@ public Gson() {
     // the excluder must precede all adapters that handle user-defined types
     factories.add(excluder);
 
-    // user's type adapters
-    factories.addAll(typeAdapterFactories);
+    // users' type adapters
+    factories.addAll(factoriesToBeAdded);
 
     // type adapters for basic platform types
     factories.add(TypeAdapters.STRING_FACTORY);
@@ -255,6 +279,16 @@ public Gson() {
     this.factories = Collections.unmodifiableList(factories);
   }
 
+  /**
+   * Returns a new GsonBuilder containing all custom factories and configuration used by the current
+   * instance.
+   *
+   * @return a GsonBuilder instance.
+   */
+  public GsonBuilder newBuilder() {
+    return new GsonBuilder(this);
+  }
+
   public Excluder excluder() {
     return excluder;
   }
@@ -765,7 +799,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @param <T> the type of the desired object
    * @param json the string from which the object is to be deserialized
    * @param classOfT the class of T
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type
    * classOfT
    */
@@ -981,7 +1016,7 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {
   public String toString() {
     return new StringBuilder("{serializeNulls:")
         .append(serializeNulls)
-        .append("factories:").append(factories)
+        .append(",factories:").append(factories)
         .append(",instanceCreators:").append(constructorConstructor)
         .append("}")
         .toString();
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 0c917d46f..b97be452b 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -16,7 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.stream.JsonReader;
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -32,6 +31,7 @@
 import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
 
 import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
 import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
@@ -104,6 +104,31 @@
   public GsonBuilder() {
   }
 
+  /**
+   * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder
+   * has the same configuration as the previously built Gson instance.
+   *
+   * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
+   */
+  GsonBuilder(Gson gson) {
+    this.excluder = gson.excluder;
+    this.fieldNamingPolicy = gson.fieldNamingStrategy;
+    this.instanceCreators.putAll(gson.instanceCreators);
+    this.serializeNulls = gson.serializeNulls;
+    this.complexMapKeySerialization = gson.complexMapKeySerialization;
+    this.generateNonExecutableJson = gson.generateNonExecutableJson;
+    this.escapeHtmlChars = gson.htmlSafe;
+    this.prettyPrinting = gson.prettyPrinting;
+    this.lenient = gson.lenient;
+    this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;
+    this.longSerializationPolicy = gson.longSerializationPolicy;
+    this.datePattern = gson.datePattern;
+    this.dateStyle = gson.dateStyle;
+    this.timeStyle = gson.timeStyle;
+    this.factories.addAll(gson.builderFactories);
+    this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+  }
+
   /**
    * Configures Gson to enable versioning support.
    *
@@ -519,8 +544,7 @@ public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAd
         || typeAdapter instanceof JsonDeserializer<?>
         || typeAdapter instanceof TypeAdapter<?>);
     if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {
-      hierarchyFactories.add(0,
-          TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
+      hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
     }
     if (typeAdapter instanceof TypeAdapter<?>) {
       factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));
@@ -560,31 +584,44 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
    * @return an instance of Gson configured with the options currently set in this builder
    */
   public Gson create() {
-    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
+    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>(this.factories.size() + this.hierarchyFactories.size() + 3);
     factories.addAll(this.factories);
     Collections.reverse(factories);
-    factories.addAll(this.hierarchyFactories);
+
+    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>(this.hierarchyFactories);
+    Collections.reverse(hierarchyFactories);
+    factories.addAll(hierarchyFactories);
+
     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);
 
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
-        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
+        serializeSpecialFloatingPointValues, longSerializationPolicy,
+        datePattern, dateStyle, timeStyle,
+        this.factories, this.hierarchyFactories, factories);
   }
 
+  @SuppressWarnings("unchecked")
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
       List<TypeAdapterFactory> factories) {
     DefaultDateTypeAdapter dateTypeAdapter;
+    TypeAdapter<Timestamp> timestampTypeAdapter;
+    TypeAdapter<java.sql.Date> javaSqlDateTypeAdapter;
     if (datePattern != null && !"".equals(datePattern.trim())) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);
+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, datePattern);
+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, datePattern);
+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, datePattern);
     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);
+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle, timeStyle);
+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, dateStyle, timeStyle);
+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, dateStyle, timeStyle);
     } else {
       return;
     }
 
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));
+    factories.add(TypeAdapters.newFactory(Date.class, dateTypeAdapter));
+    factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));
+    factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));
   }
 }
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/gson/JsonArray.java
index 19299d14e..f2b3b31f5 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/gson/JsonArray.java
@@ -39,14 +39,25 @@
   public JsonArray() {
     elements = new ArrayList<JsonElement>();
   }
+  
+  public JsonArray(int capacity) {
+    elements = new ArrayList<JsonElement>(capacity);
+  }
 
+  /**
+   * Creates a deep copy of this element and all its children
+   * @since 2.8.2
+   */
   @Override
-  JsonArray deepCopy() {
-    JsonArray result = new JsonArray();
-    for (JsonElement element : elements) {
-      result.add(element.deepCopy());
+  public JsonArray deepCopy() {
+    if (!elements.isEmpty()) {
+      JsonArray result = new JsonArray(elements.size());
+      for (JsonElement element : elements) {
+        result.add(element.deepCopy());
+      }
+      return result;
     }
-    return result;
+    return new JsonArray();
   }
 
   /**
diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/gson/JsonElement.java
index d9cd91846..62bb920cd 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/gson/JsonElement.java
@@ -34,8 +34,9 @@
   /**
    * Returns a deep copy of this element. Immutable elements like primitives
    * and nulls are not copied.
+   * @since 2.8.2
    */
-  abstract JsonElement deepCopy();
+  public abstract JsonElement deepCopy();
 
   /**
    * provides check for verifying if this element is an array or not.
@@ -103,7 +104,7 @@ public JsonArray getAsJsonArray() {
     if (isJsonArray()) {
       return (JsonArray) this;
     }
-    throw new IllegalStateException("This is not a JSON Array.");
+    throw new IllegalStateException("Not a JSON Array: " + this);
   }
 
   /**
@@ -119,7 +120,7 @@ public JsonPrimitive getAsJsonPrimitive() {
     if (isJsonPrimitive()) {
       return (JsonPrimitive) this;
     }
-    throw new IllegalStateException("This is not a JSON Primitive.");
+    throw new IllegalStateException("Not a JSON Primitive: " + this);
   }
 
   /**
@@ -136,7 +137,7 @@ public JsonNull getAsJsonNull() {
     if (isJsonNull()) {
       return (JsonNull) this;
     }
-    throw new IllegalStateException("This is not a JSON Null.");
+    throw new IllegalStateException("Not a JSON Null: " + this);
   }
 
   /**
diff --git a/gson/src/main/java/com/google/gson/JsonNull.java b/gson/src/main/java/com/google/gson/JsonNull.java
index 56883369e..67cb9325b 100755
--- a/gson/src/main/java/com/google/gson/JsonNull.java
+++ b/gson/src/main/java/com/google/gson/JsonNull.java
@@ -40,8 +40,12 @@ public JsonNull() {
     // Do nothing
   }
 
+  /**
+   * Returns the same instance since it is an immutable value
+   * @since 2.8.2
+   */
   @Override
-  JsonNull deepCopy() {
+  public JsonNull deepCopy() {
     return INSTANCE;
   }
 
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 621019189..4b63db56c 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -33,8 +33,12 @@
   private final LinkedTreeMap<String, JsonElement> members =
       new LinkedTreeMap<String, JsonElement>();
 
+  /**
+   * Creates a deep copy of this element and all its children
+   * @since 2.8.2
+   */
   @Override
-  JsonObject deepCopy() {
+  public JsonObject deepCopy() {
     JsonObject result = new JsonObject();
     for (Map.Entry<String, JsonElement> entry : members.entrySet()) {
       result.add(entry.getKey(), entry.getValue().deepCopy());
@@ -132,6 +136,16 @@ private JsonElement createJsonElement(Object value) {
     return members.entrySet();
   }
 
+  /**
+   * Returns a set of members key values.
+   *
+   * @return a set of member keys as Strings
+   * @since 2.8.1
+   */
+  public Set<String> keySet() {
+    return members.keySet();
+  }
+
   /**
    * Returns the number of key/value pairs in the object.
    *
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index e2443d435..adb18fad0 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -85,8 +85,12 @@ public JsonPrimitive(Character c) {
     setValue(primitive);
   }
 
+  /**
+   * Returns the same value as primitives are immutable.
+   * @since 2.8.2
+   */
   @Override
-  JsonPrimitive deepCopy() {
+  public JsonPrimitive deepCopy() {
     return this;
   }
 
diff --git a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
index a98b27a1a..93163f858 100644
--- a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
+++ b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.annotations;
 
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import java.lang.annotation.ElementType;
@@ -77,8 +79,10 @@
  * adapters, which in turn take precedence over annotated types.
  *
  * <p>The class referenced by this annotation must be either a {@link
- * TypeAdapter} or a {@link TypeAdapterFactory}. Using the factory interface
- * makes it possible to delegate to the enclosing {@code Gson} instance.
+ * TypeAdapter} or a {@link TypeAdapterFactory}, or must implement one
+ * or both of {@link JsonDeserializer} or {@link JsonSerializer}. 
+ * Using {@link TypeAdapterFactory} makes it possible to delegate 
+ * to the enclosing {@code Gson} instance.
  *
  * @since 2.3
  *
@@ -91,7 +95,7 @@
 @Target({ElementType.TYPE, ElementType.FIELD})
 public @interface JsonAdapter {
 
-  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}. */
+  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}, or one or both of {@link JsonDeserializer} or {@link JsonSerializer}. */
   Class<?> value();
 
   /** false, to be able to handle {@code null} values within the adapter, default value is true. */
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
index 017e27cee..adea605f5 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
@@ -25,11 +25,7 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Properties;
+import java.util.*;
 
 import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
 import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
@@ -75,7 +71,13 @@ public static GenericArrayType arrayOf(Type componentType) {
    * this returns {@code ?}, which is shorthand for {@code ? extends Object}.
    */
   public static WildcardType subtypeOf(Type bound) {
-    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);
+    Type[] upperBounds;
+    if (bound instanceof WildcardType) {
+      upperBounds = ((WildcardType) bound).getUpperBounds();
+    } else {
+      upperBounds = new Type[] { bound };
+    }
+    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
   }
 
   /**
@@ -84,7 +86,13 @@ public static WildcardType subtypeOf(Type bound) {
    * super String}.
    */
   public static WildcardType supertypeOf(Type bound) {
-    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });
+    Type[] lowerBounds;
+    if (bound instanceof WildcardType) {
+      lowerBounds = ((WildcardType) bound).getLowerBounds();
+    } else {
+      lowerBounds = new Type[] { bound };
+    }
+    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
   }
 
   /**
@@ -267,6 +275,10 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
    * @param supertype a superclass of, or interface implemented by, this.
    */
   static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (context instanceof WildcardType) {
+      // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead
+      context = ((WildcardType)context).getUpperBounds()[0];
+    }
     checkArgument(supertype.isAssignableFrom(contextRawType));
     return resolve(context, contextRawType,
         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
@@ -322,10 +334,21 @@ public static Type getCollectionElementType(Type context, Class<?> contextRawTyp
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
+  }
+
+  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
+                              Collection<TypeVariable> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        if (visitedTypeVariables.contains(typeVariable)) {
+          // cannot reduce due to infinite recursion
+          return toResolve;
+        } else {
+          visitedTypeVariables.add(typeVariable);
+        }
         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
         if (toResolve == typeVariable) {
           return toResolve;
@@ -334,7 +357,7 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
         Class<?> original = (Class<?>) toResolve;
         Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
+        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
         return componentType == newComponentType
             ? original
             : arrayOf(newComponentType);
@@ -342,7 +365,7 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
       } else if (toResolve instanceof GenericArrayType) {
         GenericArrayType original = (GenericArrayType) toResolve;
         Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
+        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
         return componentType == newComponentType
             ? original
             : arrayOf(newComponentType);
@@ -350,12 +373,12 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
       } else if (toResolve instanceof ParameterizedType) {
         ParameterizedType original = (ParameterizedType) toResolve;
         Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
         boolean changed = newOwnerType != ownerType;
 
         Type[] args = original.getActualTypeArguments();
         for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
           if (resolvedTypeArgument != args[t]) {
             if (!changed) {
               args = args.clone();
@@ -375,12 +398,12 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
         Type[] originalUpperBound = original.getUpperBounds();
 
         if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
           if (lowerBound != originalLowerBound[0]) {
             return supertypeOf(lowerBound);
           }
         } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
           if (upperBound != originalUpperBound[0]) {
             return subtypeOf(upperBound);
           }
@@ -411,7 +434,7 @@ static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVaria
   }
 
   private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
+    for (int i = 0, length = array.length; i < length; i++) {
       if (toFind.equals(array[i])) {
         return i;
       }
@@ -451,7 +474,7 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
       this.ownerType = ownerType == null ? null : canonicalize(ownerType);
       this.rawType = canonicalize(rawType);
       this.typeArguments = typeArguments.clone();
-      for (int t = 0; t < this.typeArguments.length; t++) {
+      for (int t = 0, length = this.typeArguments.length; t < length; t++) {
         checkNotNull(this.typeArguments[t]);
         checkNotPrimitive(this.typeArguments[t]);
         this.typeArguments[t] = canonicalize(this.typeArguments[t]);
@@ -482,15 +505,14 @@ public Type getOwnerType() {
     }
 
     @Override public String toString() {
-      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));
-      stringBuilder.append(typeToString(rawType));
-
-      if (typeArguments.length == 0) {
-        return stringBuilder.toString();
+      int length = typeArguments.length;
+      if (length == 0) {
+        return typeToString(rawType);
       }
 
-      stringBuilder.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
+      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));
+      stringBuilder.append(typeToString(rawType)).append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < length; i++) {
         stringBuilder.append(", ").append(typeToString(typeArguments[i]));
       }
       return stringBuilder.append(">").toString();
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index ffe3cb48e..5fab46010 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -40,6 +40,7 @@
 
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonIOException;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 
 /**
@@ -47,6 +48,7 @@
  */
 public final class ConstructorConstructor {
   private final Map<Type, InstanceCreator<?>> instanceCreators;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     this.instanceCreators = instanceCreators;
@@ -98,7 +100,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     try {
       final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
       if (!constructor.isAccessible()) {
-        constructor.setAccessible(true);
+        accessor.makeAccessible(constructor);
       }
       return new ObjectConstructor<T>() {
         @SuppressWarnings("unchecked") // T is the same raw type as is requested
@@ -224,7 +226,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
           return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
-              + "Register an InstanceCreator with Gson for this type may fix this problem."), e);
+              + "Registering an InstanceCreator with Gson for this type may fix this problem."), e);
         }
       }
     };
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index bef790406..6b83757ed 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -110,8 +110,10 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
 
   public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
-    final boolean skipSerialize = excludeClass(rawType, true);
-    final boolean skipDeserialize = excludeClass(rawType, false);
+    boolean excludeClass = excludeClassChecks(rawType);
+
+    final boolean skipSerialize = excludeClass || excludeClassInStrategy(rawType, true);
+    final boolean skipDeserialize = excludeClass ||  excludeClassInStrategy(rawType, false);
 
     if (!skipSerialize && !skipDeserialize) {
       return null;
@@ -188,28 +190,35 @@ public boolean excludeField(Field field, boolean serialize) {
     return false;
   }
 
-  public boolean excludeClass(Class<?> clazz, boolean serialize) {
-    if (version != Excluder.IGNORE_VERSIONS
-        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
-      return true;
-    }
-
-    if (!serializeInnerClasses && isInnerClass(clazz)) {
-      return true;
-    }
+  private boolean excludeClassChecks(Class<?> clazz) {
+      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
+          return true;
+      }
 
-    if (isAnonymousOrLocal(clazz)) {
-      return true;
-    }
+      if (!serializeInnerClasses && isInnerClass(clazz)) {
+          return true;
+      }
 
-    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-    for (ExclusionStrategy exclusionStrategy : list) {
-      if (exclusionStrategy.shouldSkipClass(clazz)) {
-        return true;
+      if (isAnonymousOrLocal(clazz)) {
+          return true;
       }
-    }
 
-    return false;
+      return false;
+  }
+
+  public boolean excludeClass(Class<?> clazz, boolean serialize) {
+      return excludeClassChecks(clazz) ||
+              excludeClassInStrategy(clazz, serialize);
+  }
+
+  private boolean excludeClassInStrategy(Class<?> clazz, boolean serialize) {
+      List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
+      for (ExclusionStrategy exclusionStrategy : list) {
+          if (exclusionStrategy.shouldSkipClass(clazz)) {
+              return true;
+          }
+      }
+      return false;
   }
 
   private boolean isAnonymousOrLocal(Class<?> clazz) {
diff --git a/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
new file mode 100644
index 000000000..beb527c9e
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Locale;
+
+/**
+ * Provides DateFormats for US locale with patterns which were the default ones before Java 9.
+ */
+public class PreJava9DateFormatProvider {
+
+  /**
+   * Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8 or below.
+   */
+  public static DateFormat getUSDateFormat(int style) {
+    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);
+  }
+
+  /**
+   * Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US)}
+   * in Java 8 or below.
+   */
+  public static DateFormat getUSDateTimeFormat(int dateStyle, int timeStyle) {
+    String pattern = getDatePartOfDateTimePattern(dateStyle) + " " + getTimePartOfDateTimePattern(timeStyle);
+    return new SimpleDateFormat(pattern, Locale.US);
+  }
+
+  private static String getDateFormatPattern(int style) {
+    switch (style) {
+    case DateFormat.SHORT:
+      return "M/d/yy";
+    case DateFormat.MEDIUM:
+      return "MMM d, y";
+    case DateFormat.LONG:
+      return "MMMM d, y";
+    case DateFormat.FULL:
+      return "EEEE, MMMM d, y";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + style);
+    }
+  }
+
+  private static String getDatePartOfDateTimePattern(int dateStyle) {
+    switch (dateStyle) {
+    case DateFormat.SHORT:
+      return "M/d/yy";
+    case DateFormat.MEDIUM:
+      return "MMM d, yyyy";
+    case DateFormat.LONG:
+      return "MMMM d, yyyy";
+    case DateFormat.FULL:
+      return "EEEE, MMMM d, yyyy";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + dateStyle);
+    }
+  }
+
+  private static String getTimePartOfDateTimePattern(int timeStyle) {
+    switch (timeStyle) {
+    case DateFormat.SHORT:
+      return "h:mm a";
+    case DateFormat.MEDIUM:
+      return "h:mm:ss a";
+    case DateFormat.FULL:
+    case DateFormat.LONG:
+      return "h:mm:ss a z";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + timeStyle);
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
index 41e7cd156..999a2b57e 100644
--- a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
+++ b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
@@ -111,7 +111,7 @@ public static UnsafeAllocator create() {
    * throw an {@link java.lang.UnsupportedOperationException}
    * @param c instance of the class to be checked
    */
-  private static void assertInstantiable(Class<?> c) {
+  static void assertInstantiable(Class<?> c) {
     int modifiers = c.getModifiers();
     if (Modifier.isInterface(modifiers)) {
       throw new UnsupportedOperationException("Interface can't be instantiated! Interface name: " + c.getName());
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
index 3fb7c0568..56101706b 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
@@ -73,8 +73,10 @@ public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class
       list.add(instance);
     }
     in.endArray();
-    Object array = Array.newInstance(componentType, list.size());
-    for (int i = 0; i < list.size(); i++) {
+
+    int size = list.size();
+    Object array = Array.newInstance(componentType, size);
+    for (int i = 0; i < size; i++) {
       Array.set(array, i, list.get(i));
     }
     return array;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
index 561af1985..c3a3de1b5 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
@@ -20,16 +20,21 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+import com.google.gson.util.VersionUtils;
+
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.ParsePosition;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
 
 /**
@@ -46,10 +51,21 @@
     }
   };
 
-  private final DateFormat enUsFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);
-  private final DateFormat localFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);
+  /**
+   * List of 1 or more different date formats used for de-serialization attempts.
+   * The first of them (default US format) is used for serialization as well.
+   */
+  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
+
+  public DateTypeAdapter() {
+    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+  }
 
   @Override public Date read(JsonReader in) throws IOException {
     if (in.peek() == JsonToken.NULL) {
@@ -60,13 +76,10 @@
   }
 
   private synchronized Date deserializeToDate(String json) {
-    try {
-      return localFormat.parse(json);
-    } catch (ParseException ignored) {
-    }
-    try {
-      return enUsFormat.parse(json);
-    } catch (ParseException ignored) {
+    for (DateFormat dateFormat : dateFormats) {
+      try {
+        return dateFormat.parse(json);
+      } catch (ParseException ignored) {}
     }
     try {
     	return ISO8601Utils.parse(json, new ParsePosition(0));
@@ -80,7 +93,7 @@ private synchronized Date deserializeToDate(String json) {
       out.nullValue();
       return;
     }
-    String dateFormatAsString = enUsFormat.format(value);
+    String dateFormatAsString = dateFormats.get(0).format(value);
     out.value(dateFormatAsString);
   }
   
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index 7cfb910a6..13a7bb7eb 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -68,9 +68,10 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
           : null;
       typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);
     } else {
-      throw new IllegalArgumentException(
-          "@JsonAdapter value must be TypeAdapter, TypeAdapterFactory, "
-              + "JsonSerializer or JsonDeserializer reference.");
+      throw new IllegalArgumentException("Invalid attempt to bind an instance of "
+          + instance.getClass().getName() + " as a @JsonAdapter for " + type.toString()
+          + ". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,"
+          + " JsonSerializer or JsonDeserializer.");
     }
 
     if (typeAdapter != null && annotation.nullSafe()) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
index 012123156..387b29e9b 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
@@ -259,9 +259,13 @@ private void expect(JsonToken expected) throws IOException {
       pathNames[stackSize - 2] = "null";
     } else {
       popStack();
-      pathNames[stackSize - 1] = "null";
+      if (stackSize > 0) {
+        pathNames[stackSize - 1] = "null";
+      }
+    }
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
     }
-    pathIndices[stackSize - 1]++;
   }
 
   @Override public String toString() {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 1682aad04..5a34a5d5f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -224,7 +224,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 
       if (hasComplexKeys) {
         out.beginArray();
-        for (int i = 0; i < keys.size(); i++) {
+        for (int i = 0, size = keys.size(); i < size; i++) {
           out.beginArray(); // entry array
           Streams.write(keys.get(i), out);
           valueTypeAdapter.write(out, values.get(i));
@@ -233,7 +233,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
         out.endArray();
       } else {
         out.beginObject();
-        for (int i = 0; i < keys.size(); i++) {
+        for (int i = 0, size = keys.size(); i < size; i++) {
           JsonElement keyElement = keys.get(i);
           out.name(keyToString(keyElement));
           valueTypeAdapter.write(out, values.get(i));
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 34e97664e..777e7dee3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -28,6 +28,7 @@
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Primitives;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -49,6 +50,7 @@
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
@@ -154,11 +156,11 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
         if (!serialize && !deserialize) {
           continue;
         }
-        field.setAccessible(true);
+        accessor.makeAccessible(field);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;
-        for (int i = 0; i < fieldNames.size(); ++i) {
+        for (int i = 0, size = fieldNames.size(); i < size; ++i) {
           String name = fieldNames.get(i);
           if (i != 0) serialize = false; // only serialize the default name
           BoundField boundField = createBoundField(context, field, name,
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index e13e3489f..a5c6c5dcd 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -41,7 +41,7 @@
 public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
   private final JsonSerializer<T> serializer;
   private final JsonDeserializer<T> deserializer;
-  private final Gson gson;
+  final Gson gson;
   private final TypeToken<T> typeToken;
   private final TypeAdapterFactory skipPast;
   private final GsonContextImpl context = new GsonContextImpl();
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 6a51c64e8..354ce5a1f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -69,33 +69,20 @@ private TypeAdapters() {
   public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {
     @Override
     public void write(JsonWriter out, Class value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-      } else {
-        throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
-            + value.getName() + ". Forgot to register a type adapter?");
-      }
+      throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
+              + value.getName() + ". Forgot to register a type adapter?");
     }
     @Override
     public Class read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      } else {
-        throw new UnsupportedOperationException(
-            "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
-      }
+      throw new UnsupportedOperationException(
+              "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
     }
-  };
+  }.nullSafe();
+
   public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);
 
   public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {
     @Override public BitSet read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-
       BitSet bitset = new BitSet();
       in.beginArray();
       int i = 0;
@@ -132,29 +119,25 @@ public Class read(JsonReader in) throws IOException {
     }
 
     @Override public void write(JsonWriter out, BitSet src) throws IOException {
-      if (src == null) {
-        out.nullValue();
-        return;
-      }
-
       out.beginArray();
-      for (int i = 0; i < src.length(); i++) {
+      for (int i = 0, length = src.length(); i < length; i++) {
         int value = (src.get(i)) ? 1 : 0;
         out.value(value);
       }
       out.endArray();
     }
-  };
+  }.nullSafe();
 
   public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);
 
   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
     @Override
     public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
+      JsonToken peek = in.peek();
+      if (peek == JsonToken.NULL) {
         in.nextNull();
         return null;
-      } else if (in.peek() == JsonToken.STRING) {
+      } else if (peek == JsonToken.STRING) {
         // support strings for compatibility with GSON 1.7
         return Boolean.parseBoolean(in.nextString());
       }
@@ -368,6 +351,7 @@ public Number read(JsonReader in) throws IOException {
         in.nextNull();
         return null;
       case NUMBER:
+      case STRING:
         return new LazilyParsedNumber(in.nextString());
       default:
         throw new JsonSyntaxException("Expecting number, got: " + jsonToken);
@@ -921,4 +905,4 @@ public EnumTypeAdapter(Class<T> classOfT) {
       }
     };
   }
-}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
index c931b0906..99ec679a7 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
@@ -266,7 +266,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
         } catch (IllegalArgumentException e) {
             fail = e;
         }
-        String input = (date == null) ? null : ('"' + date + "'");
+        String input = (date == null) ? null : ('"' + date + '"');
         String msg = fail.getMessage();
         if (msg == null || msg.isEmpty()) {
             msg = "("+fail.getClass().getName()+")";
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
new file mode 100644
index 000000000..2f006517e
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import java.lang.reflect.AccessibleObject;
+
+/**
+ * A basic implementation of {@link ReflectionAccessor} which is suitable for Java 8 and below.
+ * <p>
+ * This implementation just calls {@link AccessibleObject#setAccessible(boolean) setAccessible(true)}, which worked
+ * fine before Java 9.
+ */
+final class PreJava9ReflectionAccessor extends ReflectionAccessor {
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void makeAccessible(AccessibleObject ao) {
+    ao.setAccessible(true);
+  }
+
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
new file mode 100644
index 000000000..42230d254
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import com.google.gson.util.VersionUtils;
+
+import java.lang.reflect.AccessibleObject;
+
+/**
+ * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
+ * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}
+ * thrown or warnings like
+ * <pre>
+ *   WARNING: An illegal reflective access operation has occurred
+ *   WARNING: Illegal reflective access by ...
+ * </pre>
+ * <p/>
+ * Works both for Java 9 and earlier Java versions.
+ */
+public abstract class ReflectionAccessor {
+
+  // the singleton instance, use getInstance() to obtain
+  private static final ReflectionAccessor instance = VersionUtils.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
+
+  /**
+   * Does the same as {@code ao.setAccessible(true)}, but never throws
+   * {@link java.lang.reflect.InaccessibleObjectException}
+   */
+  public abstract void makeAccessible(AccessibleObject ao);
+
+  /**
+   * Obtains a {@link ReflectionAccessor} instance suitable for the current Java version.
+   * <p>
+   * You may need one a reflective operation in your code throws {@link java.lang.reflect.InaccessibleObjectException}.
+   * In such a case, use {@link ReflectionAccessor#makeAccessible(AccessibleObject)} on a field, method or constructor
+   * (instead of basic {@link AccessibleObject#setAccessible(boolean)}).
+   */
+  public static ReflectionAccessor getInstance() {
+    return instance;
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
new file mode 100644
index 000000000..5bc59bd8e
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import sun.misc.Unsafe;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Field;
+
+/**
+ * An implementation of {@link ReflectionAccessor} based on {@link Unsafe}.
+ * <p>
+ * NOTE: This implementation is designed for Java 9. Although it should work with earlier Java releases, it is better to
+ * use {@link PreJava9ReflectionAccessor} for them.
+ */
+final class UnsafeReflectionAccessor extends ReflectionAccessor {
+
+  private final Unsafe theUnsafe = getUnsafeInstance();
+  private final Field overrideField = getOverrideField();
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void makeAccessible(AccessibleObject ao) {
+    if (theUnsafe != null && overrideField != null) {
+      long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
+      theUnsafe.putBoolean(ao, overrideOffset, true);
+    }
+  }
+
+  private static Unsafe getUnsafeInstance() {
+    try {
+      Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
+      unsafeField.setAccessible(true);
+      return (Unsafe) unsafeField.get(null);
+    } catch (Exception e) {
+      e.printStackTrace();
+      return null;
+    }
+  }
+
+  private static Field getOverrideField() {
+    try {
+      return AccessibleObject.class.getDeclaredField("override");
+    } catch (NoSuchFieldException e) {
+      e.printStackTrace();
+      return null;
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/reflect/package-info.java b/gson/src/main/java/com/google/gson/reflect/package-info.java
index e666c4311..5e43ee9fc 100644
--- a/gson/src/main/java/com/google/gson/reflect/package-info.java
+++ b/gson/src/main/java/com/google/gson/reflect/package-info.java
@@ -1,6 +1,6 @@
 /**
  * This package provides utility classes for finding type information for generic types.
- *  
+ *
  * @author Inderjeet Singh, Joel Leitch
  */
 package com.google.gson.reflect;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 9c55c4367..e0799d736 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -728,7 +728,7 @@ private int peekNumber() throws IOException {
     }
 
     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
       peekedLong = negative ? value : -value;
       pos += i;
       return peeked = PEEKED_LONG;
@@ -985,7 +985,7 @@ public long nextLong() throws IOException {
   private String nextQuotedValue(char quote) throws IOException {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
     char[] buffer = this.buffer;
-    StringBuilder builder = new StringBuilder();
+    StringBuilder builder = null;
     while (true) {
       int p = pos;
       int l = limit;
@@ -996,11 +996,21 @@ private String nextQuotedValue(char quote) throws IOException {
 
         if (c == quote) {
           pos = p;
-          builder.append(buffer, start, p - start - 1);
-          return builder.toString();
+          int len = p - start - 1;
+          if (builder == null) {
+            return new String(buffer, start, len);
+          } else {
+            builder.append(buffer, start, len);
+            return builder.toString();
+          }
         } else if (c == '\\') {
           pos = p;
-          builder.append(buffer, start, p - start - 1);
+          int len = p - start - 1;
+          if (builder == null) {
+            int estimatedLength = (len + 1) * 2;
+            builder = new StringBuilder(Math.max(estimatedLength, 16));
+          }
+          builder.append(buffer, start, len);
           builder.append(readEscapeCharacter());
           p = pos;
           l = limit;
@@ -1011,6 +1021,10 @@ private String nextQuotedValue(char quote) throws IOException {
         }
       }
 
+      if (builder == null) {
+        int estimatedLength = (p - start) * 2;
+        builder = new StringBuilder(Math.max(estimatedLength, 16));
+      }
       builder.append(buffer, start, p - start);
       pos = p;
       if (!fillBuffer(1)) {
@@ -1063,7 +1077,7 @@ private String nextUnquotedValue() throws IOException {
 
       // use a StringBuilder when the value is too long. This is too long to be a number!
       if (builder == null) {
-        builder = new StringBuilder();
+        builder = new StringBuilder(Math.max(i,16));
       }
       builder.append(buffer, pos, i);
       pos += i;
@@ -1072,14 +1086,8 @@ private String nextUnquotedValue() throws IOException {
         break;
       }
     }
-
-    String result;
-    if (builder == null) {
-      result = new String(buffer, pos, i);
-    } else {
-      builder.append(buffer, pos, i);
-      result = builder.toString();
-    }
+   
+    String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
     pos += i;
     return result;
   }
@@ -1424,14 +1432,15 @@ private void skipToEndOfLine() throws IOException {
    * @param toFind a string to search for. Must not contain a newline.
    */
   private boolean skipTo(String toFind) throws IOException {
+    int length = toFind.length();
     outer:
-    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
+    for (; pos + length <= limit || fillBuffer(length); pos++) {
       if (buffer[pos] == '\n') {
         lineNumber++;
         lineStart = pos + 1;
         continue;
       }
-      for (int c = 0; c < toFind.length(); c++) {
+      for (int c = 0; c < length; c++) {
         if (buffer[pos + c] != toFind.charAt(c)) {
           continue outer;
         }
@@ -1445,7 +1454,7 @@ private boolean skipTo(String toFind) throws IOException {
     return getClass().getSimpleName() + locationString();
   }
 
-  private String locationString() {
+  String locationString() {
     int line = lineNumber + 1;
     int column = pos - lineStart + 1;
     return " at line " + line + " column " + column + " path " + getPath();
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index e2fc19611..8148816c2 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -491,10 +491,10 @@ public JsonWriter value(Boolean value) throws IOException {
    * @return this writer.
    */
   public JsonWriter value(double value) throws IOException {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
+    writeDeferredName();
+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
-    writeDeferredName();
     beforeValue();
     out.append(Double.toString(value));
     return this;
diff --git a/gson/src/main/java/com/google/gson/util/VersionUtils.java b/gson/src/main/java/com/google/gson/util/VersionUtils.java
new file mode 100644
index 000000000..d81e43c09
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/util/VersionUtils.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.util;
+
+/**
+ * Utility to check the major Java version of the current JVM.
+ */
+public class VersionUtils {
+
+  private static final int majorJavaVersion = determineMajorJavaVersion();
+
+  private static int determineMajorJavaVersion() {
+    String[] parts = System.getProperty("java.version").split("[._]");
+    int firstVer = Integer.parseInt(parts[0]);
+    if (firstVer == 1 && parts.length > 1) {
+      return Integer.parseInt(parts[1]);
+    } else {
+      return firstVer;
+    }
+  }
+
+  /**
+   * @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc.
+   */
+  public static int getMajorJavaVersion() {
+    return majorJavaVersion;
+  }
+
+  /**
+   * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.
+   */
+  public static boolean isJava9OrLater() {
+    return majorJavaVersion >= 9;
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
index 5ce65d748..a074bea0c 100644
--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
@@ -16,11 +16,14 @@
 
 package com.google.gson;
 
+import java.io.IOException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
+
+import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -44,17 +47,21 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(locale);
     try {
-      assertFormatted("Jan 1, 1970 12:00:00 AM", new DefaultDateTypeAdapter());
-      assertFormatted("1/1/70", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertFormatted("Jan 1, 1970", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertFormatted("January 1, 1970", new DefaultDateTypeAdapter(DateFormat.LONG));
-      assertFormatted("1/1/70 12:00 AM",
+      String afterYearSep = VersionUtils.isJava9OrLater() ? ", " : " ";
+      String afterYearLongSep = VersionUtils.isJava9OrLater() ? " at " : " ";
+      String utcFull = VersionUtils.isJava9OrLater() ? "Coordinated Universal Time" : "UTC";
+      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
+      assertFormatted("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertFormatted("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertFormatted("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
+      assertFormatted(String.format("1/1/70%s12:00 AM", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertFormatted("Jan 1, 1970 12:00:00 AM",
+      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertFormatted("January 1, 1970 12:00:00 AM UTC",
+      assertFormatted(String.format("January 1, 1970%s12:00:00 AM UTC", afterYearLongSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertFormatted("Thursday, January 1, 1970 12:00:00 AM UTC",
+      assertFormatted(String.format("Thursday, January 1, 1970%s12:00:00 AM %s", afterYearLongSep, utcFull),
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -62,23 +69,27 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     }
   }
 
-  public void testParsingDatesFormattedWithSystemLocale() {
+  public void testParsingDatesFormattedWithSystemLocale() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.FRANCE);
     try {
-      assertParsed("1 janv. 1970 00:00:00", new DefaultDateTypeAdapter());
-      assertParsed("01/01/70", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertParsed("1 janv. 1970", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertParsed("1 janvier 1970", new DefaultDateTypeAdapter(DateFormat.LONG));
+      String afterYearSep = VersionUtils.isJava9OrLater() ? "  " : " ";
+      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
+      assertParsed("01/01/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertParsed("1 janv. 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertParsed("1 janvier 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed("01/01/70 00:00",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertParsed("1 janv. 1970 00:00:00",
+      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertParsed("1 janvier 1970 00:00:00 UTC",
+      assertParsed(String.format("1 janvier 1970%s00:00:00 UTC", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed("jeudi 1 janvier 1970 00 h 00 UTC",
+      assertParsed(VersionUtils.isJava9OrLater() ?
+                      "jeudi 1 janvier 1970  00:00:00 Coordinated Universal Time" :
+                      "jeudi 1 janvier 1970 00 h 00 UTC",
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -86,16 +97,16 @@ public void testParsingDatesFormattedWithSystemLocale() {
     }
   }
 
-  public void testParsingDatesFormattedWithUsLocale() {
+  public void testParsingDatesFormattedWithUsLocale() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertParsed("Jan 1, 1970 0:00:00 AM", new DefaultDateTypeAdapter());
-      assertParsed("1/1/70", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertParsed("Jan 1, 1970", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertParsed("January 1, 1970", new DefaultDateTypeAdapter(DateFormat.LONG));
+      assertParsed("Jan 1, 1970 0:00:00 AM", new DefaultDateTypeAdapter(Date.class));
+      assertParsed("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertParsed("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertParsed("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed("1/1/70 0:00 AM",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
       assertParsed("Jan 1, 1970 0:00:00 AM",
@@ -110,14 +121,16 @@ public void testParsingDatesFormattedWithUsLocale() {
     }
   }
 
-  public void testFormatUsesDefaultTimezone() {
+  public void testFormatUsesDefaultTimezone() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertFormatted("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter());
-      assertParsed("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter());
+      String afterYearSep = VersionUtils.isJava9OrLater() ? ", " : " ";
+      assertFormatted(String.format("Dec 31, 1969%s4:00:00 PM", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
+      assertParsed("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter(Date.class));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
       Locale.setDefault(defaultLocale);
@@ -125,7 +138,7 @@ public void testFormatUsesDefaultTimezone() {
   }
 
   public void testDateDeserializationISO8601() throws Exception {
-  	DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();
+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
     assertParsed("1970-01-01T00:00:00.000Z", adapter);
     assertParsed("1970-01-01T00:00Z", adapter);
     assertParsed("1970-01-01T00:00:00+00:00", adapter);
@@ -135,38 +148,55 @@ public void testDateDeserializationISO8601() throws Exception {
   
   public void testDateSerialization() throws Exception {
     int dateStyle = DateFormat.LONG;
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);
+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle);
     DateFormat formatter = DateFormat.getDateInstance(dateStyle, Locale.US);
     Date currentDate = new Date();
 
-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();
-    assertEquals(formatter.format(currentDate), dateString);
+    String dateString = dateTypeAdapter.toJson(currentDate);
+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
   public void testDatePattern() throws Exception {
     String pattern = "yyyy-MM-dd";
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);
+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, pattern);
     DateFormat formatter = new SimpleDateFormat(pattern);
     Date currentDate = new Date();
 
-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();
-    assertEquals(formatter.format(currentDate), dateString);
+    String dateString = dateTypeAdapter.toJson(currentDate);
+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
   public void testInvalidDatePattern() throws Exception {
     try {
-      new DefaultDateTypeAdapter("I am a bad Date pattern....");
+      new DefaultDateTypeAdapter(Date.class, "I am a bad Date pattern....");
       fail("Invalid date pattern should fail.");
     } catch (IllegalArgumentException expected) { }
   }
 
+  public void testNullValue() throws Exception {
+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+    assertNull(adapter.fromJson("null"));
+    assertEquals("null", adapter.toJson(null));
+  }
+
+  public void testUnexpectedToken() throws Exception {
+    try {
+      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+      adapter.fromJson("{}");
+      fail("Unexpected token should fail.");
+    } catch (IllegalStateException expected) { }
+  }
+
   private void assertFormatted(String formatted, DefaultDateTypeAdapter adapter) {
-    assertEquals(formatted, adapter.serialize(new Date(0), Date.class, null).getAsString());
+    assertEquals(toLiteral(formatted), adapter.toJson(new Date(0)));
+  }
+
+  private void assertParsed(String date, DefaultDateTypeAdapter adapter) throws IOException {
+    assertEquals(date, new Date(0), adapter.fromJson(toLiteral(date)));
+    assertEquals("ISO 8601", new Date(0), adapter.fromJson(toLiteral("1970-01-01T00:00:00Z")));
   }
 
-  private void assertParsed(String date, DefaultDateTypeAdapter  adapter) {
-    assertEquals(date, new Date(0), adapter.deserialize(new JsonPrimitive(date), Date.class, null));
-    assertEquals("ISO 8601", new Date(0), adapter.deserialize(
-        new JsonPrimitive("1970-01-01T00:00:00Z"), Date.class, null));
+  private static String toLiteral(String s) {
+    return '"' + s + '"';
   }
 }
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index fb0c00321..eec2ec91c 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -17,8 +17,12 @@
 package com.google.gson;
 
 import com.google.gson.internal.Excluder;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
+import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.HashMap;
 import junit.framework.TestCase;
@@ -43,12 +47,34 @@
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, true, false, LongSerializationPolicy.DEFAULT,
-        new ArrayList<TypeAdapterFactory>());
+        true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
     assertEquals(true, gson.serializeNulls());
     assertEquals(false, gson.htmlSafe());
   }
+
+  public void testClonedTypeAdapterFactoryListsAreIndependent() {
+    Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
+        new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+        true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+
+    Gson clone = original.newBuilder()
+        .registerTypeAdapter(Object.class, new TestTypeAdapter())
+        .create();
+
+    assertEquals(original.factories.size() + 1, clone.factories.size());
+  }
+
+  private static final class TestTypeAdapter extends TypeAdapter<Object> {
+    @Override public void write(JsonWriter out, Object value) throws IOException {
+      // Test stub.
+    }
+    @Override public Object read(JsonReader in) throws IOException { return null; }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/JsonObjectTest.java b/gson/src/test/java/com/google/gson/JsonObjectTest.java
index 32d9d3608..d071c3baa 100644
--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java
+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java
@@ -183,4 +183,19 @@ public void testDeepCopy() {
     assertEquals(1, original.get("key").getAsJsonArray().size());
     assertEquals(0, copy.get("key").getAsJsonArray().size());
   }
+
+  /**
+   * From issue 941
+   */
+  public void testKeySet() {
+    JsonObject a = new JsonObject();
+
+    a.add("foo", new JsonArray());
+    a.add("bar", new JsonObject());
+
+    assertEquals(2, a.size());
+    assertEquals(2, a.keySet().size());
+    assertTrue(a.keySet().contains("foo"));
+    assertTrue(a.keySet().contains("bar"));
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
index 9a8f707b4..4ec7378b2 100644
--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
@@ -393,4 +393,23 @@ public void testSetDeserialization() {
       assertTrue(entry.value == 1 || entry.value == 2);
     }
   }
+
+  private class BigClass { private Map<String, ? extends List<SmallClass>> inBig; }
+
+  private class SmallClass { private String inSmall; }
+
+  public void testIssue1107() {
+    String json = "{\n" +
+            "  \"inBig\": {\n" +
+            "    \"key\": [\n" +
+            "      { \"inSmall\": \"hello\" }\n" +
+            "    ]\n" +
+            "  }\n" +
+            "}";
+    BigClass bigClass = new Gson().fromJson(json, BigClass.class);
+    SmallClass small = bigClass.inBig.get("key").get(0);
+    assertNotNull(small);
+    assertEquals("hello", small.inSmall);
+  }
+
 }
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index 198667162..635c20887 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -55,6 +55,8 @@
 import java.util.TimeZone;
 import java.util.TreeSet;
 import java.util.UUID;
+
+import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -328,7 +330,11 @@ public void testBitSetDeserialization() throws Exception {
   public void testDefaultDateSerialization() {
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
+    } else {
+      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    }
   }
 
   public void testDefaultDateDeserialization() {
@@ -369,7 +375,11 @@ public void testDefaultJavaSqlDateDeserialization() {
   public void testDefaultJavaSqlTimestampSerialization() {
     Timestamp now = new java.sql.Timestamp(1259875082000L);
     String json = gson.toJson(now);
-    assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("\"Dec 3, 2009, 1:18:02 PM\"", json);
+    } else {
+      assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
+    }
   }
 
   public void testDefaultJavaSqlTimestampDeserialization() {
@@ -395,7 +405,11 @@ public void testDefaultDateSerializationUsingBuilder() throws Exception {
     Gson gson = new GsonBuilder().create();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
+    } else {
+      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    }
   }
 
   public void testDefaultDateDeserializationUsingBuilder() throws Exception {
diff --git a/gson/src/test/java/com/google/gson/functional/EnumTest.java b/gson/src/test/java/com/google/gson/functional/EnumTest.java
index 4a9f05b59..66b855ebf 100644
--- a/gson/src/test/java/com/google/gson/functional/EnumTest.java
+++ b/gson/src/test/java/com/google/gson/functional/EnumTest.java
@@ -16,6 +16,12 @@
 
 package com.google.gson.functional;
 
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Set;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
@@ -29,13 +35,6 @@
 import com.google.gson.common.MoreAsserts;
 import com.google.gson.reflect.TypeToken;
 
-
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.Set;
-
 import junit.framework.TestCase;
 /**
  * Functional tests for Java 5.0 enums.
@@ -199,4 +198,19 @@ public void testEnumSet() {
     @SerializedName("girl")
     FEMALE
   }
+
+  public void testEnumClassWithFields() {
+	  assertEquals("\"RED\"", gson.toJson(Color.RED));
+	  assertEquals("red", gson.fromJson("RED", Color.class).value);
+  }
+
+  public enum Color {
+	  RED("red", 1), BLUE("blue", 2), GREEN("green", 3);
+	  String value;
+	  int index;
+	  private Color(String value, int index) {
+		  this.value = value;
+		  this.index = index;
+	  }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index b7b29a656..4288bfe3b 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -249,4 +249,15 @@ public NullableClass read(JsonReader in) throws IOException {
       return Foo.valueOf(in.nextString().toUpperCase(Locale.US));
     }
   }
+
+  public void testIncorrectJsonAdapterType() {
+    try {
+      new Gson().toJson(new D());
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+  @JsonAdapter(Integer.class)
+  private static final class D {
+    @SuppressWarnings("unused") final String value = "a";
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index de1219a6a..cf82457a3 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -43,6 +43,8 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
+
+import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -482,7 +484,11 @@ public void testSingletonLists() {
   public void testDateAsMapObjectField() {
     HasObjectMap a = new HasObjectMap();
     a.map.put("date", new Date(0));
-    assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969, 4:00:00 PM\"}}", gson.toJson(a));
+    } else {
+      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
+    }
   }
 
   public class HasObjectMap {
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index bb28ed1ec..9da983a3b 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -158,6 +158,11 @@ public void testNumberDeserialization() {
     assertEquals(1L, actual.longValue());
   }
 
+  public void testNumberAsStringDeserialization() {
+    Number value = gson.fromJson("\"18\"", Number.class);
+    assertEquals(18, value.intValue());
+  }
+
   public void testPrimitiveDoubleAutoboxedSerialization() {
     assertEquals("-122.08234335", gson.toJson(-122.08234335));
     assertEquals("122.08112002", gson.toJson(new Double(122.08112002)));
diff --git a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 551ceffc0..45e85342c 100644
--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -27,8 +27,6 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -43,59 +41,59 @@
   private TypeAdapter<Map<String, Double>> mapAdapter
       = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});
 
-  public void testSerialize() throws IOException {
+  public void testSerialize() {
     Truck truck = new Truck();
     truck.passengers = Arrays.asList(new Person("Jesse", 29), new Person("Jodie", 29));
     truck.horsePower = 300;
 
     assertEquals("{'horsePower':300.0,"
         + "'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserialize() throws IOException {
     String json = "{'horsePower':300.0,"
         + "'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}";
-    Truck truck = fromJson(truckAdapter, json);
+    Truck truck = truckAdapter.fromJson(json.replace('\'', '\"'));
     assertEquals(300.0, truck.horsePower);
     assertEquals(Arrays.asList(new Person("Jesse", 29), new Person("Jodie", 29)), truck.passengers);
   }
 
-  public void testSerializeNullField() throws IOException {
+  public void testSerializeNullField() {
     Truck truck = new Truck();
     truck.passengers = null;
     assertEquals("{'horsePower':0.0,'passengers':null}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserializeNullField() throws IOException {
-    Truck truck = fromJson(truckAdapter, "{'horsePower':0.0,'passengers':null}");
+    Truck truck = truckAdapter.fromJson("{'horsePower':0.0,'passengers':null}".replace('\'', '\"'));
     assertNull(truck.passengers);
   }
 
-  public void testSerializeNullObject() throws IOException {
+  public void testSerializeNullObject() {
     Truck truck = new Truck();
     truck.passengers = Arrays.asList((Person) null);
     assertEquals("{'horsePower':0.0,'passengers':[null]}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserializeNullObject() throws IOException {
-    Truck truck = fromJson(truckAdapter, "{'horsePower':0.0,'passengers':[null]}");
+    Truck truck = truckAdapter.fromJson("{'horsePower':0.0,'passengers':[null]}".replace('\'', '\"'));
     assertEquals(Arrays.asList((Person) null), truck.passengers);
   }
 
-  public void testSerializeWithCustomTypeAdapter() throws IOException {
+  public void testSerializeWithCustomTypeAdapter() {
     usePersonNameAdapter();
     Truck truck = new Truck();
     truck.passengers = Arrays.asList(new Person("Jesse", 29), new Person("Jodie", 29));
     assertEquals("{'horsePower':0.0,'passengers':['Jesse','Jodie']}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserializeWithCustomTypeAdapter() throws IOException {
     usePersonNameAdapter();
-    Truck truck = fromJson(truckAdapter, "{'horsePower':0.0,'passengers':['Jesse','Jodie']}");
+    Truck truck = truckAdapter.fromJson("{'horsePower':0.0,'passengers':['Jesse','Jodie']}".replace('\'', '\"'));
     assertEquals(Arrays.asList(new Person("Jesse", -1), new Person("Jodie", -1)), truck.passengers);
   }
 
@@ -113,40 +111,40 @@ private void usePersonNameAdapter() {
     truckAdapter = miniGson.getAdapter(Truck.class);
   }
 
-  public void testSerializeMap() throws IOException {
+  public void testSerializeMap() {
     Map<String, Double> map = new LinkedHashMap<String, Double>();
     map.put("a", 5.0);
     map.put("b", 10.0);
-    assertEquals("{'a':5.0,'b':10.0}", toJson(mapAdapter, map).replace('"', '\''));
+    assertEquals("{'a':5.0,'b':10.0}", mapAdapter.toJson(map).replace('"', '\''));
   }
 
   public void testDeserializeMap() throws IOException {
     Map<String, Double> map = new LinkedHashMap<String, Double>();
     map.put("a", 5.0);
     map.put("b", 10.0);
-    assertEquals(map, fromJson(mapAdapter, "{'a':5.0,'b':10.0}"));
+    assertEquals(map, mapAdapter.fromJson("{'a':5.0,'b':10.0}".replace('\'', '\"')));
   }
 
-  public void testSerialize1dArray() throws IOException {
+  public void testSerialize1dArray() {
     TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});
-    assertEquals("[1.0,2.0,3.0]", toJson(arrayAdapter, new double[]{1.0, 2.0, 3.0}));
+    assertEquals("[1.0,2.0,3.0]", arrayAdapter.toJson(new double[]{ 1.0, 2.0, 3.0 }));
   }
 
   public void testDeserialize1dArray() throws IOException {
     TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});
-    double[] array = fromJson(arrayAdapter, "[1.0,2.0,3.0]");
+    double[] array = arrayAdapter.fromJson("[1.0,2.0,3.0]");
     assertTrue(Arrays.toString(array), Arrays.equals(new double[]{1.0, 2.0, 3.0}, array));
   }
 
-  public void testSerialize2dArray() throws IOException {
+  public void testSerialize2dArray() {
     TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});
     double[][] array = { {1.0, 2.0 }, { 3.0 } };
-    assertEquals("[[1.0,2.0],[3.0]]", toJson(arrayAdapter, array));
+    assertEquals("[[1.0,2.0],[3.0]]", arrayAdapter.toJson(array));
   }
 
   public void testDeserialize2dArray() throws IOException {
     TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});
-    double[][] array = fromJson(arrayAdapter, "[[1.0,2.0],[3.0]]");
+    double[][] array = arrayAdapter.fromJson("[[1.0,2.0],[3.0]]");
     double[][] expected = { {1.0, 2.0 }, { 3.0 } };
     assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));
   }
@@ -186,7 +184,7 @@ public void write(JsonWriter out, Person person) throws IOException {
     assertEquals("jesse", truck.passengers.get(1).name);
   }
 
-  public void testSerializeRecursive() throws IOException {
+  public void testSerializeRecursive() {
     TypeAdapter<Node> nodeAdapter = miniGson.getAdapter(Node.class);
     Node root = new Node("root");
     root.left = new Node("left");
@@ -194,7 +192,7 @@ public void testSerializeRecursive() throws IOException {
     assertEquals("{'label':'root',"
         + "'left':{'label':'left','left':null,'right':null},"
         + "'right':{'label':'right','left':null,'right':null}}",
-        toJson(nodeAdapter, root).replace('"', '\''));
+        nodeAdapter.toJson(root).replace('"', '\''));
   }
   
   public void testFromJsonTree() {
@@ -243,19 +241,4 @@ public void testFromJsonTree() {
       this.label = label;
     }
   }
-
-  // TODO: remove this when TypeAdapter.toJson() is public
-  private static <T> String toJson(TypeAdapter<T> typeAdapter, T value) throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
-    typeAdapter.write(writer, value);
-    return stringWriter.toString();
-  }
-
-  // TODO: remove this when TypeAdapter.fromJson() is public
-  private <T> T fromJson(TypeAdapter<T> typeAdapter, String json) throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(json));
-    reader.setLenient(true); // TODO: non-lenient?
-    return typeAdapter.read(reader);
-  }
 }
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
new file mode 100644
index 000000000..f6a5bf33e
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.bind;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonObject;
+import com.google.gson.stream.JsonToken;
+import java.io.IOException;
+import junit.framework.TestCase;
+
+@SuppressWarnings("resource")
+public class JsonTreeReaderTest extends TestCase {
+  public void testSkipValue_emptyJsonObject() throws IOException {
+    JsonTreeReader in = new JsonTreeReader(new JsonObject());
+    in.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, in.peek());
+  }
+
+  public void testSkipValue_filledJsonObject() throws IOException {
+    JsonObject jsonObject = new JsonObject();
+    JsonArray jsonArray = new JsonArray();
+    jsonArray.add('c');
+    jsonArray.add("text");
+    jsonObject.add("a", jsonArray);
+    jsonObject.addProperty("b", true);
+    jsonObject.addProperty("i", 1);
+    jsonObject.add("n", JsonNull.INSTANCE);
+    JsonObject jsonObject2 = new JsonObject();
+    jsonObject2.addProperty("n", 2L);
+    jsonObject.add("o", jsonObject2);
+    jsonObject.addProperty("s", "text");
+    JsonTreeReader in = new JsonTreeReader(jsonObject);
+    in.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, in.peek());
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
new file mode 100644
index 000000000..aaa577b53
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2017 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal.bind;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.internal.$Gson$Types;
+import junit.framework.TestCase;
+
+import java.io.PrintStream;
+import java.lang.ref.WeakReference;
+
+/**
+ * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,
+ * java.lang.reflect.Type)}, described at <a href="https://github.com/google/gson/issues/440">Issue #440</a>
+ * and similar issues.
+ * <p>
+ * These tests originally caused {@link StackOverflowError} because of infinite recursion on attempts to
+ * resolve generics on types, with an intermediate types like 'Foo2&lt;? extends ? super ? extends ... ? extends A&gt;'
+ */
+public class RecursiveTypesResolveTest extends TestCase {
+
+  private static class Foo1<A> {
+    public Foo2<? extends A> foo2;
+  }
+
+  private static class Foo2<B> {
+    public Foo1<? super B> foo1;
+  }
+
+  /**
+   * Test simplest case of recursion.
+   */
+  public void testRecursiveResolveSimple() {
+    TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);
+    assertNotNull(adapter);
+  }
+
+  //
+  // Real-world samples, found in Issues #603 and #440.
+  //
+  public void testIssue603PrintStream() {
+    TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);
+    assertNotNull(adapter);
+  }
+
+  public void testIssue440WeakReference() throws Exception {
+    TypeAdapter<WeakReference> adapter = new Gson().getAdapter(WeakReference.class);
+    assertNotNull(adapter);
+  }
+
+  //
+  // Tests belows check the behaviour of the methods changed for the fix
+  //
+
+  public void testDoubleSupertype() {
+    assertEquals($Gson$Types.supertypeOf(Number.class),
+            $Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)));
+  }
+
+  public void testDoubleSubtype() {
+    assertEquals($Gson$Types.subtypeOf(Number.class),
+            $Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)));
+  }
+
+  public void testSuperSubtype() {
+    assertEquals($Gson$Types.subtypeOf(Object.class),
+            $Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)));
+  }
+
+  public void testSubSupertype() {
+    assertEquals($Gson$Types.subtypeOf(Object.class),
+            $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));
+  }
+
+  //
+  // tests for recursion while resolving type variables
+  //
+
+  private static class TestType<X> {
+    TestType<? super X> superType;
+  }
+
+  private static class TestType2<X, Y> {
+    TestType2<? super Y, ? super X> superReversedType;
+  }
+
+  public void testRecursiveTypeVariablesResolve1() throws Exception {
+    TypeAdapter<TestType> adapter = new Gson().getAdapter(TestType.class);
+    assertNotNull(adapter);
+  }
+
+  public void testRecursiveTypeVariablesResolve12() throws Exception {
+    TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);
+    assertNotNull(adapter);
+  }
+}
+
+
+
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
index d6b7a838f..19ca2d234 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
@@ -560,6 +560,18 @@ public void testLongLargerThanMinLongThatWrapsAround() throws IOException {
     } catch (NumberFormatException expected) {
     }
   }
+  
+  /**
+   * Issue 1053, negative zero.
+   * @throws Exception
+   */
+  public void testNegativeZero() throws Exception {
+	  	JsonReader reader = new JsonReader(reader("[-0]"));
+	    reader.setLenient(false);
+	    reader.beginArray();
+	    assertEquals(NUMBER, reader.peek());
+	    assertEquals("-0", reader.nextString());
+  }
 
   /**
    * This test fails because there's no double for 9223372036854775808, and our
diff --git a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
index 34dc91402..2bcec173c 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
@@ -16,11 +16,12 @@
 
 package com.google.gson.stream;
 
+import junit.framework.TestCase;
+
 import java.io.IOException;
 import java.io.StringWriter;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
 public final class JsonWriterTest extends TestCase {
@@ -213,6 +214,30 @@ public void testNonFiniteBoxedDoubles() throws IOException {
     }
   }
 
+  public void testNonFiniteDoublesWhenLenient() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.setLenient(true);
+    jsonWriter.beginArray();
+    jsonWriter.value(Double.NaN);
+    jsonWriter.value(Double.NEGATIVE_INFINITY);
+    jsonWriter.value(Double.POSITIVE_INFINITY);
+    jsonWriter.endArray();
+    assertEquals("[NaN,-Infinity,Infinity]", stringWriter.toString());
+  }
+
+  public void testNonFiniteBoxedDoublesWhenLenient() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.setLenient(true);
+    jsonWriter.beginArray();
+    jsonWriter.value(Double.valueOf(Double.NaN));
+    jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));
+    jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));
+    jsonWriter.endArray();
+    assertEquals("[NaN,-Infinity,Infinity]", stringWriter.toString());
+  }
+
   public void testDoubles() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
diff --git a/pom.xml b/pom.xml
index 9e5c435fc..c6b454b57 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.8.1-SNAPSHOT</version>
+  <version>2.8.3-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>
@@ -63,8 +63,9 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.7.0</version>
           <configuration>
+            <excludes>**/module-info.java</excludes>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
@@ -72,24 +73,30 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.3</version>
+          <version>2.10.4</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-jar-plugin</artifactId>
         </plugin>
+        <plugin>
+          <groupId>org.apache.felix</groupId>
+          <artifactId>maven-bundle-plugin</artifactId>
+          <version>3.3.0</version>
+          <inherited>true</inherited>
+        </plugin>
       </plugins>
     </pluginManagement>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.4.2</version>
+        <version>2.5.3</version>
         <dependencies>
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9</version>
+            <version>1.9.5</version>
           </dependency>
         </dependencies>
         <configuration>
diff --git a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
index 4fba080d6..c378685c8 100644
--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Converter;
 import com.google.common.collect.MapMaker;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonDeserializationContext;
@@ -35,8 +34,8 @@
 import com.google.protobuf.Descriptors.EnumDescriptor;
 import com.google.protobuf.Descriptors.EnumValueDescriptor;
 import com.google.protobuf.Descriptors.FieldDescriptor;
+import com.google.protobuf.DynamicMessage;
 import com.google.protobuf.Extension;
-import com.google.protobuf.GeneratedMessage;
 import com.google.protobuf.Message;
 
 import java.lang.reflect.Field;
@@ -73,7 +72,7 @@
  * @author Stanley Wang
  */
 public class ProtoTypeAdapter
-    implements JsonSerializer<GeneratedMessage>, JsonDeserializer<GeneratedMessage> {
+    implements JsonSerializer<Message>, JsonDeserializer<Message> {
   /**
    * Determines how enum <u>values</u> should be serialized.
    */
@@ -94,7 +93,8 @@
     private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
     private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
     private EnumSerialization enumSerialization;
-    private Converter<String, String> fieldNameSerializationFormat;
+    private CaseFormat protoFormat;
+    private CaseFormat jsonFormat;
 
     private Builder(EnumSerialization enumSerialization, CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
@@ -126,7 +126,8 @@ public Builder setEnumSerialization(EnumSerialization enumSerialization) {
      */
     public Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
-      fieldNameSerializationFormat = fromFieldNameFormat.converterTo(toFieldNameFormat);
+      this.protoFormat = fromFieldNameFormat;
+      this.jsonFormat = toFieldNameFormat;
       return this;
     }
 
@@ -174,7 +175,7 @@ public Builder addSerializedEnumValueExtension(
     }
 
     public ProtoTypeAdapter build() {
-      return new ProtoTypeAdapter(enumSerialization, fieldNameSerializationFormat,
+      return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat,
           serializedNameExtensions, serializedEnumValueExtensions);
     }
   }
@@ -195,22 +196,25 @@ public static Builder newBuilder() {
       new MapMaker().makeMap();
 
   private final EnumSerialization enumSerialization;
-  private final Converter<String, String> fieldNameSerializationFormat;
+  private final CaseFormat protoFormat;
+  private final CaseFormat jsonFormat;
   private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
   private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
 
   private ProtoTypeAdapter(EnumSerialization enumSerialization,
-      Converter<String, String> fieldNameSerializationFormat,
+      CaseFormat protoFormat,
+      CaseFormat jsonFormat,
       Set<Extension<FieldOptions, String>> serializedNameExtensions,
       Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions) {
     this.enumSerialization = enumSerialization;
-    this.fieldNameSerializationFormat = fieldNameSerializationFormat;
+    this.protoFormat = protoFormat;
+    this.jsonFormat = jsonFormat;
     this.serializedNameExtensions = serializedNameExtensions;
     this.serializedEnumValueExtensions = serializedEnumValueExtensions;
   }
 
   @Override
-  public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
+  public JsonElement serialize(Message src, Type typeOfSrc,
       JsonSerializationContext context) {
     JsonObject ret = new JsonObject();
     final Map<FieldDescriptor, Object> fields = src.getAllFields();
@@ -243,17 +247,24 @@ public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
   }
 
   @Override
-  public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
+  public Message deserialize(JsonElement json, Type typeOfT,
       JsonDeserializationContext context) throws JsonParseException {
     try {
       JsonObject jsonObject = json.getAsJsonObject();
       @SuppressWarnings("unchecked")
-      Class<? extends GeneratedMessage> protoClass = (Class<? extends GeneratedMessage>) typeOfT;
+      Class<? extends Message> protoClass = (Class<? extends Message>) typeOfT;
+
+      if (DynamicMessage.class.isAssignableFrom(protoClass)) {
+        throw new IllegalStateException("only generated messages are supported");
+      }
 
       try {
         // Invoke the ProtoClass.newBuilder() method
-        GeneratedMessage.Builder<?> protoBuilder =
-            (GeneratedMessage.Builder<?>) getCachedMethod(protoClass, "newBuilder").invoke(null);
+        Message.Builder protoBuilder =
+            (Message.Builder) getCachedMethod(protoClass, "newBuilder").invoke(null);
+
+        Message defaultInstance =
+            (Message) getCachedMethod(protoClass, "getDefaultInstance").invoke(null);
 
         Descriptor protoDescriptor =
             (Descriptor) getCachedMethod(protoClass, "getDescriptor").invoke(null);
@@ -270,7 +281,7 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
               if (jsonElement.isJsonArray()) {
                 // Handling array
                 Collection<EnumValueDescriptor> enumCollection =
-                    new ArrayList<EnumValueDescriptor>();
+                    new ArrayList<EnumValueDescriptor>(jsonElement.getAsJsonArray().size());
                 for (JsonElement element : jsonElement.getAsJsonArray()) {
                   enumCollection.add(
                       findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));
@@ -284,21 +295,21 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else if (fieldDescriptor.isRepeated()) {
               // If the type is an array, then we have to grab the type from the class.
+              // protobuf java field names are always lower camel case
               String protoArrayFieldName =
-                  fieldNameSerializationFormat.convert(fieldDescriptor.getName()) + "_";
+                  protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + "_";
               Field protoArrayField = protoClass.getDeclaredField(protoArrayFieldName);
               Type protoArrayFieldType = protoArrayField.getGenericType();
               fieldValue = context.deserialize(jsonElement, protoArrayFieldType);
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else {
-              Message prototype = protoBuilder.build();
-              Object field = prototype.getField(fieldDescriptor);
+              Object field = defaultInstance.getField(fieldDescriptor);
               fieldValue = context.deserialize(jsonElement, field.getClass());
               protoBuilder.setField(fieldDescriptor, fieldValue);
             }
           }
         }
-        return (GeneratedMessage) protoBuilder.build();
+        return (Message) protoBuilder.build();
       } catch (SecurityException e) {
         throw new JsonParseException(e);
       } catch (NoSuchMethodException e) {
@@ -325,7 +336,7 @@ private String getCustSerializedName(FieldOptions options, String defaultName) {
         return options.getExtension(extension);
       }
     }
-    return fieldNameSerializationFormat.convert(defaultName);
+    return protoFormat.to(jsonFormat, defaultName);
   }
 
   /**
diff --git a/proto/src/main/protobuf/bag.proto b/proto/src/main/protobuf/bag.proto
index 26189a24f..48cc96397 100644
--- a/proto/src/main/protobuf/bag.proto
+++ b/proto/src/main/protobuf/bag.proto
@@ -24,6 +24,11 @@ message SimpleProto {
   optional int32 count = 2;
 }
 
+message ProtoWithDifferentCaseFormat {
+  repeated string name_that_tests_case_format = 1;
+  optional string another_field = 2;
+}
+
 message ProtoWithRepeatedFields {
   repeated int64 numbers = 1;
   repeated SimpleProto simples = 2;
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
index 964549d6b..b61d3f509 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
@@ -15,10 +15,13 @@
  */
 package com.google.gson.protobuf.functional;
 
+import com.google.common.base.CaseFormat;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+import com.google.gson.JsonObject;
 import com.google.gson.protobuf.ProtoTypeAdapter;
 import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
+import com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat;
 import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;
 import com.google.gson.protobuf.generated.Bag.SimpleProto;
 import com.google.protobuf.GeneratedMessage;
@@ -32,6 +35,7 @@
  */
 public class ProtosWithComplexAndRepeatedFieldsTest extends TestCase {
   private Gson gson;
+  private Gson upperCamelGson;
 
   @Override
   protected void setUp() throws Exception {
@@ -43,6 +47,14 @@ protected void setUp() throws Exception {
                     .setEnumSerialization(EnumSerialization.NUMBER)
                     .build())
             .create();
+    upperCamelGson =
+        new GsonBuilder()
+            .registerTypeHierarchyAdapter(
+                GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
+                    .setFieldNameSerializationFormat(
+                        CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
+                    .build())
+            .create();
   }
 
   public void testSerializeRepeatedFields() {
@@ -67,4 +79,23 @@ public void testDeserializeRepeatedFieldsProto() {
     assertEquals("bar", proto.getSimples(0).getMsg());
     assertEquals(7, proto.getSimples(1).getCount());
   }
+
+  public void testSerializeDifferentCaseFormat() {
+    final ProtoWithDifferentCaseFormat proto =
+      ProtoWithDifferentCaseFormat.newBuilder()
+        .setAnotherField("foo")
+        .addNameThatTestsCaseFormat("bar")
+        .build();
+    final JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
+    assertEquals("foo", json.get("AnotherField").getAsString());
+    assertEquals("bar", json.get("NameThatTestsCaseFormat").getAsJsonArray().get(0).getAsString());
+  }
+
+  public void testDeserializeDifferentCaseFormat() {
+    final String json = "{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}";
+    ProtoWithDifferentCaseFormat proto =
+      upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);
+    assertEquals("foo", proto.getAnotherField());
+    assertEquals("bar", proto.getNameThatTestsCaseFormat(0));
+  }
 }
